commit,file,added_code,deleted_code,hash_clean,cve_id,hash,repo_url,rel_type,score,extraction_status,text_norm,cluster_kmeans
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,frontend/src/pages/404.jsx,"import Header from ""../components/Header"";
import Footer from ""../components/Footer"";

export default function Contact() {
  return (
    <div className=""text-black"">
      <Header />
      <div className=""flex flex-col justify-center mx-auto mt-52 text-center max-w-2x1"">
        <h1 className=""text-3xl font-bold tracking-tight text-black md:text-5xl"">
          404 – Unavailable
        </h1>
        <br />
        <a
          className=""w-64 p-1 mx-auto font-bold text-center text-black border border-gray-500 rounded-lg sm:p-4""
          href=""/""
        >
          Return Home
        </a>
      </div>
      <div className=""mt-64""></div>
      <Footer />
    </div>
  );
}",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-VAR""> <VAR /> <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-52 VAR-VAR VAR-VAR-2x1""> <VAR VAR=""VAR-3xl VAR-VAR VAR-VAR VAR-VAR VAR:VAR-5xl""> 404 – VAR </VAR> <VAR /> <VAR VAR=""VAR-64 VAR-1 VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR VAR-VAR-500 VAR-VAR VAR:VAR-4"" VAR=""/"" > VAR VAR </VAR> </VAR> <VAR VAR=""VAR-64""></VAR> <VAR /> </VAR> ); } ",10
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/pages/404.jsx,"import Header from ""../components/Header"";
import Footer from ""../components/Footer"";

export default function Contact() {
  return (
    <div className=""text-black"">
      <Header />
      <div className=""flex flex-col justify-center mx-auto mt-52 text-center max-w-2x1"">
        <h1 className=""text-3xl font-bold tracking-tight text-black md:text-5xl"">
          404 – Unavailable
        </h1>
        <br />
        <a
          className=""w-64 p-1 mx-auto font-bold text-center text-black border border-gray-500 rounded-lg sm:p-4""
          href=""/""
        >
          Return Home
        </a>
      </div>
      <div className=""mt-64""></div>
      <Footer />
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-VAR""> <VAR /> <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-52 VAR-VAR VAR-VAR-2x1""> <VAR VAR=""VAR-3xl VAR-VAR VAR-VAR VAR-VAR VAR:VAR-5xl""> 404 – VAR </VAR> <VAR /> <VAR VAR=""VAR-64 VAR-1 VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR VAR-VAR-500 VAR-VAR VAR:VAR-4"" VAR=""/"" > VAR VAR </VAR> </VAR> <VAR VAR=""VAR-64""></VAR> <VAR /> </VAR> ); } ",10
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/pages/404.jsx,"import Header from ""../components/Header"";
import Footer from ""../components/Footer"";

export default function Contact() {
  return (
    <div className=""text-black"">
      <Header />
      <div className=""flex flex-col justify-center mx-auto mt-52 text-center max-w-2x1"">
        <h1 className=""text-3xl font-bold tracking-tight text-black md:text-5xl"">
          404 – Unavailable
        </h1>
        <br />
        <a
          className=""w-64 p-1 mx-auto font-bold text-center text-black border border-gray-500 rounded-lg sm:p-4""
          href=""/""
        >
          Return Home
        </a>
      </div>
      <div className=""mt-64""></div>
      <Footer />
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-VAR""> <VAR /> <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-52 VAR-VAR VAR-VAR-2x1""> <VAR VAR=""VAR-3xl VAR-VAR VAR-VAR VAR-VAR VAR:VAR-5xl""> 404 – VAR </VAR> <VAR /> <VAR VAR=""VAR-64 VAR-1 VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR VAR-VAR-500 VAR-VAR VAR:VAR-4"" VAR=""/"" > VAR VAR </VAR> </VAR> <VAR VAR=""VAR-64""></VAR> <VAR /> </VAR> ); } ",10
envoy_2d69e30c51f2418faf267aaa6c1126fce9948c62,bazel/external/icuuc.BUILD,"load(""@rules_cc//cc:defs.bzl"", ""cc_library"")

licenses([""notice""])  # Apache 2

exports_files([
    ""icu4c/LICENSE"",
    ""icu4j/main/shared/licenses/LICENSE"",
])

icuuc_copts = [
    ""-DU_STATIC_IMPLEMENTATION"",
    ""-DU_COMMON_IMPLEMENTATION"",
    ""-DU_HAVE_STD_ATOMICS"",
] + select({
    ""@envoy//bazel:apple"": [
        ""-Wno-shorten-64-to-32"",
        ""-Wno-unused-variable"",
    ],
    ""@envoy//bazel:windows_x86_64"": [
        ""/utf-8"",
        ""/DLOCALE_ALLOW_NEUTRAL_NAMES=0"",
    ],
    # TODO(dio): Add ""@envoy//bazel:android"" when we have it.
    # ""@envoy//bazel:android"": [
    #     ""-fdata-sections"",
    #     ""-DU_HAVE_NL_LANGINFO_CODESET=0"",
    #     ""-Wno-deprecated-declarations"",
    # ],
    ""//conditions:default"": [],
})

cc_library(
    name = ""headers"",
    hdrs = glob([""icu4c/source/common/unicode/*.h""]),
    includes = [""icu4c/source/common""],
    visibility = [""//visibility:public""],
)

cc_library(
    name = ""common"",
    hdrs = glob([""icu4c/source/common/unicode/*.h""]),
    includes = [""icu4c/source/common""],
    visibility = [""//visibility:public""],
    deps = ["":icuuc""],
)

cc_library(
    name = ""icuuc"",
    srcs = glob([
        ""icu4c/source/common/*.c"",
        ""icu4c/source/common/*.cpp"",
        ""icu4c/source/stubdata/*.cpp"",
    ]),
    hdrs = glob([""icu4c/source/common/*.h""]),
    copts = icuuc_copts,
    tags = [""requires-rtti""],
    visibility = [""//visibility:private""],
    deps = ["":headers""],
)",,2d69e30c51f2418faf267aaa6c1126fce9948c62,CVE-2020-25018,2d69e30c51f2418faf267aaa6c1126fce9948c62,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED,"VAR(""@VAR VAR([""VAR""])  VAR([ ""VAR/VAR"", ""VAR/VAR/VAR/VAR/VAR"", ]) VAR = [ ""-VAR"", ""-VAR"", ""-VAR"", ] + VAR({ ""@VAR ""-VAR-VAR-64-VAR-32"", ""-VAR-VAR-VAR"", ], ""@VAR ""/VAR-8"", ""/VAR=0"", ],       "" }) VAR( VAR = ""VAR"", VAR = VAR([""VAR/VAR/VAR/VAR/*.VAR""]), VAR = [""VAR/VAR/VAR""], VAR = ["" ) VAR( VAR = ""VAR"", VAR = VAR([""VAR/VAR/VAR/VAR/*.VAR""]), VAR = [""VAR/VAR/VAR""], VAR = ["" VAR = ["":VAR""], ) VAR( VAR = ""VAR"", VAR = VAR([ ""VAR/VAR/VAR/*.VAR"", ""VAR/VAR/VAR/*.VAR"", ""VAR/VAR/VAR/*.VAR"", ]), VAR = VAR([""VAR/VAR/VAR/*.VAR""]), VAR = VAR, VAR = [""VAR-VAR""], VAR = ["" VAR = ["":VAR""], ) ",10
envoy_2d69e30c51f2418faf267aaa6c1126fce9948c62,bazel/repository_locations.bzl,"    org_unicode_icuuc = dict(
        strip_prefix = ""icu-release-64-2"",
        sha256 = ""524960ac99d086cdb6988d2a92fc163436fd3c6ec0a84c475c6382fbf989be05"",
        urls = [""https://github.com/unicode-org/icu/archive/release-64-2.tar.gz""],
        use_category = [""dataplane""],
        cpe = ""cpe:2.3:a:icu-project:international_components_for_unicode"",
    ),",,2d69e30c51f2418faf267aaa6c1126fce9948c62,CVE-2020-25018,2d69e30c51f2418faf267aaa6c1126fce9948c62,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED,"VAR = VAR( VAR = ""VAR-VAR-64-2"", VAR = ""524960ac99d086cdb6988d2a92fc163436fd3c6ec0a84c475c6382fbf989be05"", VAR = [""VAR: VAR = [""VAR""], VAR = ""VAR:2.3:VAR:VAR-VAR:VAR"", ), ",10
envoy_3b5acb2f43548862dadb243de7cf3994986a8e04,bazel/external/icuuc.BUILD,,"load(""@rules_cc//cc:defs.bzl"", ""cc_library"")

licenses([""notice""])  # Apache 2

exports_files([""LICENSE""])

icuuc_copts = [
    ""-DU_STATIC_IMPLEMENTATION"",
    ""-DU_COMMON_IMPLEMENTATION"",
    ""-DU_HAVE_STD_ATOMICS"",
] + select({
    ""@envoy//bazel:apple"": [
        ""-Wno-shorten-64-to-32"",
        ""-Wno-unused-variable"",
    ],
    ""@envoy//bazel:windows_x86_64"": [
        ""/utf-8"",
        ""/DLOCALE_ALLOW_NEUTRAL_NAMES=0"",
    ],
    # TODO(dio): Add ""@envoy//bazel:android"" when we have it.
    # ""@envoy//bazel:android"": [
    #     ""-fdata-sections"",
    #     ""-DU_HAVE_NL_LANGINFO_CODESET=0"",
    #     ""-Wno-deprecated-declarations"",
    # ],
    ""//conditions:default"": [],
})

cc_library(
    name = ""headers"",
    hdrs = glob([""source/common/unicode/*.h""]),
    includes = [""source/common""],
    visibility = [""//visibility:public""],
)

cc_library(
    name = ""common"",
    hdrs = glob([""source/common/unicode/*.h""]),
    includes = [""source/common""],
    visibility = [""//visibility:public""],
    deps = ["":icuuc""],
)

cc_library(
    name = ""icuuc"",
    srcs = glob([
        ""source/common/*.c"",
        ""source/common/*.cpp"",
        ""source/stubdata/*.cpp"",
    ]),
    hdrs = glob([""source/common/*.h""]),
    copts = icuuc_copts,
    visibility = [""//visibility:private""],
    deps = ["":headers""],
)",3b5acb2f43548862dadb243de7cf3994986a8e04,CVE-2020-25018,3b5acb2f43548862dadb243de7cf3994986a8e04,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED," VAR(""@VAR VAR([""VAR""])  VAR([""VAR""]) VAR = [ ""-VAR"", ""-VAR"", ""-VAR"", ] + VAR({ ""@VAR ""-VAR-VAR-64-VAR-32"", ""-VAR-VAR-VAR"", ], ""@VAR ""/VAR-8"", ""/VAR=0"", ],       "" }) VAR( VAR = ""VAR"", VAR = VAR([""VAR/VAR/VAR/*.VAR""]), VAR = [""VAR/VAR""], VAR = ["" ) VAR( VAR = ""VAR"", VAR = VAR([""VAR/VAR/VAR/*.VAR""]), VAR = [""VAR/VAR""], VAR = ["" VAR = ["":VAR""], ) VAR( VAR = ""VAR"", VAR = VAR([ ""VAR/VAR/*.VAR"", ""VAR/VAR/*.VAR"", ""VAR/VAR/*.VAR"", ]), VAR = VAR([""VAR/VAR/*.VAR""]), VAR = VAR, VAR = ["" VAR = ["":VAR""], )",10
FFmpeg_5aba5b89d0b1d73164d3b81764828bb8b20ff32a,libavcodec/mpeg4videodec.c,"static int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
    return 0;","static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)",5aba5b89d0b1d73164d3b81764828bb8b20ff32a,CVE-2018-1999015,5aba5b89d0b1d73164d3b81764828bb8b20ff32a,https://github.com/FFmpeg/FFmpeg,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR *VAR, VAR *VAR) VAR (VAR(VAR) < 64*8) VAR VAR; VAR (VAR(VAR) < 64*8) VAR VAR; VAR (VAR(VAR) < 64*8) VAR VAR; VAR (VAR(VAR) < 64*8) VAR VAR; VAR 0; VAR VAR VAR(VAR *VAR, VAR *VAR)",10
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/mpegvideo.c,"#include ""libavutil/avassert.h""
    pic->tf.f = &pic->f;
        r = ff_thread_get_buffer(s->avctx, &pic->tf,
                                 pic->reference ? AV_GET_BUFFER_FLAG_REF : 0);
    else {
        pic->f.width  = s->avctx->width;
        pic->f.height = s->avctx->height;
        pic->f.format = s->avctx->pix_fmt;
        r = avcodec_default_get_buffer2(s->avctx, &pic->f, 0);
    }

    if (r < 0 || !pic->f.data[0]) {
        av_log(s->avctx, AV_LOG_ERROR, ""get_buffer() failed (%d %p)\n"",
               r, pic->f.data[0]);
        ff_mpeg_unref_picture(s, pic);
        ff_mpeg_unref_picture(s, pic);
        ff_mpeg_unref_picture(s, pic);
static void free_picture_tables(Picture *pic)
    int i;
    av_buffer_unref(&pic->mb_var_buf);
    av_buffer_unref(&pic->mc_mb_var_buf);
    av_buffer_unref(&pic->mb_mean_buf);
    av_buffer_unref(&pic->mbskip_table_buf);
    av_buffer_unref(&pic->qscale_table_buf);
    av_buffer_unref(&pic->mb_type_buf);
    for (i = 0; i < 2; i++) {
        av_buffer_unref(&pic->motion_val_buf[i]);
        av_buffer_unref(&pic->ref_index_buf[i]);
    }
}

static int alloc_picture_tables(MpegEncContext *s, Picture *pic)
{
    const int big_mb_num    = s->mb_stride * (s->mb_height + 1) + 1;


    pic->mbskip_table_buf = av_buffer_allocz(mb_array_size + 2);
    pic->qscale_table_buf = av_buffer_allocz(big_mb_num + s->mb_stride);
    pic->mb_type_buf      = av_buffer_allocz((big_mb_num + s->mb_stride) *
                                             sizeof(uint32_t));
    if (!pic->mbskip_table_buf || !pic->qscale_table_buf || !pic->mb_type_buf)
        return AVERROR(ENOMEM);

    if (s->encoding) {
        pic->mb_var_buf    = av_buffer_allocz(mb_array_size * sizeof(int16_t));
        pic->mc_mb_var_buf = av_buffer_allocz(mb_array_size * sizeof(int16_t));
        pic->mb_mean_buf   = av_buffer_allocz(mb_array_size);
        if (!pic->mb_var_buf || !pic->mc_mb_var_buf || !pic->mb_mean_buf)
            return AVERROR(ENOMEM);
    }

    if (s->out_format == FMT_H263 || s->encoding ||
               (s->avctx->debug & FF_DEBUG_MV) || s->avctx->debug_mv) {
        int mv_size        = 2 * (b8_array_size + 4) * sizeof(int16_t);
        int ref_index_size = 4 * mb_array_size;

        for (i = 0; mv_size && i < 2; i++) {
            pic->motion_val_buf[i] = av_buffer_allocz(mv_size);
            pic->ref_index_buf[i]  = av_buffer_allocz(ref_index_size);
            if (!pic->motion_val_buf[i] || !pic->ref_index_buf[i])
                return AVERROR(ENOMEM);
        }
    }

    return 0;
}

static int make_tables_writable(Picture *pic)
{
    int ret, i;
#define MAKE_WRITABLE(table) \
do {\
    if (pic->table &&\
       (ret = av_buffer_make_writable(&pic->table)) < 0)\
    return ret;\
} while (0)

    MAKE_WRITABLE(mb_var_buf);
    MAKE_WRITABLE(mc_mb_var_buf);
    MAKE_WRITABLE(mb_mean_buf);
    MAKE_WRITABLE(mbskip_table_buf);
    MAKE_WRITABLE(qscale_table_buf);
    MAKE_WRITABLE(mb_type_buf);

    for (i = 0; i < 2; i++) {
        MAKE_WRITABLE(motion_val_buf[i]);
        MAKE_WRITABLE(ref_index_buf[i]);
    }

    return 0;
}

/**
 * Allocate a Picture.
 * The pixels are allocated/set by calling get_buffer() if shared = 0
 */
int ff_alloc_picture(MpegEncContext *s, Picture *pic, int shared)
{
    int i, ret;
        pic->shared = 1;
    if (!pic->qscale_table_buf)
        ret = alloc_picture_tables(s, pic);
    else
        ret = make_tables_writable(pic);
    if (ret < 0)
        goto fail;
    if (s->encoding) {
        pic->mb_var    = (uint16_t*)pic->mb_var_buf->data;
        pic->mc_mb_var = (uint16_t*)pic->mc_mb_var_buf->data;
        pic->mb_mean   = pic->mb_mean_buf->data;
    pic->mbskip_table = pic->mbskip_table_buf->data;
    pic->qscale_table = pic->qscale_table_buf->data + 2 * s->mb_stride + 1;
    pic->mb_type      = (uint32_t*)pic->mb_type_buf->data + 2 * s->mb_stride + 1;

    if (pic->motion_val_buf[0]) {
        for (i = 0; i < 2; i++) {
            pic->motion_val[i] = (int16_t (*)[2])pic->motion_val_buf[i]->data + 4;
            pic->ref_index[i]  = pic->ref_index_buf[i]->data;
        }
    }
fail:
    av_log(s->avctx, AV_LOG_ERROR, ""Error allocating a picture.\n"");
    ff_mpeg_unref_picture(s, pic);
    free_picture_tables(pic);
    return AVERROR(ENOMEM);
void ff_mpeg_unref_picture(MpegEncContext *s, Picture *pic)
    int off = offsetof(Picture, mb_mean) + sizeof(pic->mb_mean);

    pic->tf.f = &pic->f;
    /* WM Image / Screen codecs allocate internal buffers with different
     * dimensions / colorspaces; ignore user-defined callbacks for these. */
    if (s->codec_id != AV_CODEC_ID_WMV3IMAGE &&
        s->codec_id != AV_CODEC_ID_VC1IMAGE  &&
        s->codec_id != AV_CODEC_ID_MSS2)
        ff_thread_release_buffer(s->avctx, &pic->tf);
    else
        av_frame_unref(&pic->f);

    av_buffer_unref(&pic->hwaccel_priv_buf);
    memset((uint8_t*)pic + off, 0, sizeof(*pic) - off);
}

static int update_picture_tables(Picture *dst, Picture *src)
{
     int i;

#define UPDATE_TABLE(table)\
do {\
    if (src->table &&\
        (!dst->table || dst->table->buffer != src->table->buffer)) {\
        av_buffer_unref(&dst->table);\
        dst->table = av_buffer_ref(src->table);\
        if (!dst->table) {\
            free_picture_tables(dst);\
            return AVERROR(ENOMEM);\
        }\
    }\
} while (0)

    UPDATE_TABLE(mb_var_buf);
    UPDATE_TABLE(mc_mb_var_buf);
    UPDATE_TABLE(mb_mean_buf);
    UPDATE_TABLE(mbskip_table_buf);
    UPDATE_TABLE(qscale_table_buf);
    UPDATE_TABLE(mb_type_buf);
        UPDATE_TABLE(motion_val_buf[i]);
        UPDATE_TABLE(ref_index_buf[i]);
    dst->mb_var        = src->mb_var;
    dst->mc_mb_var     = src->mc_mb_var;
    dst->mb_mean       = src->mb_mean;
    dst->mbskip_table  = src->mbskip_table;
    dst->qscale_table  = src->qscale_table;
    dst->mb_type       = src->mb_type;
    for (i = 0; i < 2; i++) {
        dst->motion_val[i] = src->motion_val[i];
        dst->ref_index[i]  = src->ref_index[i];

    return 0;
}

int ff_mpeg_ref_picture(MpegEncContext *s, Picture *dst, Picture *src)
{
    int ret;

    av_assert0(!dst->f.buf[0]);
    av_assert0(src->f.buf[0]);

    src->tf.f = &src->f;
    dst->tf.f = &dst->f;
    ret = ff_thread_ref_frame(&dst->tf, &src->tf);
    if (ret < 0)
        goto fail;

    ret = update_picture_tables(dst, src);
    if (ret < 0)
        goto fail;

    if (src->hwaccel_picture_private) {
        dst->hwaccel_priv_buf = av_buffer_ref(src->hwaccel_priv_buf);
        if (!dst->hwaccel_priv_buf)
            goto fail;
        dst->hwaccel_picture_private = dst->hwaccel_priv_buf->data;
    }

    dst->field_picture           = src->field_picture;
    dst->mb_var_sum              = src->mb_var_sum;
    dst->mc_mb_var_sum           = src->mc_mb_var_sum;
    dst->b_frame_score           = src->b_frame_score;
    dst->needs_realloc           = src->needs_realloc;
    dst->reference               = src->reference;
    dst->shared                  = src->shared;

    return 0;
fail:
    ff_mpeg_unref_picture(s, dst);
    return ret;
    int i, ret;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        ff_mpeg_unref_picture(s, &s->picture[i]);
        if (s1->picture[i].f.data[0] &&
            (ret = ff_mpeg_ref_picture(s, &s->picture[i], &s1->picture[i])) < 0)
            return ret;
    }

#define UPDATE_PICTURE(pic)\
do {\
    ff_mpeg_unref_picture(s, &s->pic);\
    if (s1->pic.f.data[0])\
        ret = ff_mpeg_ref_picture(s, &s->pic, &s1->pic);\
    else\
        ret = update_picture_tables(&s->pic, &s1->pic);\
    if (ret < 0)\
        return ret;\
} while (0)

    UPDATE_PICTURE(current_picture);
    UPDATE_PICTURE(last_picture);
    UPDATE_PICTURE(next_picture);
                      MAX_PICTURE_COUNT * sizeof(Picture), fail);
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
    memset(&s->next_picture, 0, sizeof(s->next_picture));
    memset(&s->last_picture, 0, sizeof(s->last_picture));
    memset(&s->current_picture, 0, sizeof(s->current_picture));
    avcodec_get_frame_defaults(&s->next_picture.f);
    avcodec_get_frame_defaults(&s->last_picture.f);
    avcodec_get_frame_defaults(&s->current_picture.f);
    if ((err = free_context_frame(s)) < 0)
        return err;
        for (i = 0; i < MAX_PICTURE_COUNT; i++) {
    if (s->picture) {
        for (i = 0; i < MAX_PICTURE_COUNT; i++) {
            free_picture_tables(&s->picture[i]);
            ff_mpeg_unref_picture(s, &s->picture[i]);
    free_picture_tables(&s->last_picture);
    ff_mpeg_unref_picture(s, &s->last_picture);
    free_picture_tables(&s->current_picture);
    ff_mpeg_unref_picture(s, &s->current_picture);
    free_picture_tables(&s->next_picture);
    ff_mpeg_unref_picture(s, &s->next_picture);
    free_picture_tables(&s->new_picture);
    ff_mpeg_unref_picture(s, &s->new_picture);
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (!s->picture[i].reference &&
            (remove_current || &s->picture[i] !=  s->current_picture_ptr)) {
            ff_mpeg_unref_picture(s, &s->picture[i]);
    if (pic->needs_realloc && !(pic->reference & DELAYED_PIC_REF))
        return 1;
        for (i = 0; i < MAX_PICTURE_COUNT; i++) {
            if (s->picture[i].f.data[0] == NULL)
        for (i = 0; i < MAX_PICTURE_COUNT; i++) {
    if (ret >= 0 && ret < MAX_PICTURE_COUNT) {
            free_picture_tables(&s->picture[ret]);
            ff_mpeg_unref_picture(s, &s->picture[ret]);
    int i, ret;
            ff_mpeg_unref_picture(s, s->last_picture_ptr);
            for (i = 0; i < MAX_PICTURE_COUNT; i++) {
                if (&s->picture[i] != s->last_picture_ptr &&
                    s->picture[i].reference && !s->picture[i].needs_realloc) {
                    ff_mpeg_unref_picture(s, &s->picture[i]);
        pic->reference = 0;
                pic->reference = s->picture_structure;
                pic->reference = 3;
    ff_mpeg_unref_picture(s, &s->current_picture);
    if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,
                                   s->current_picture_ptr)) < 0)
        return ret;
    if (s->codec_id != AV_CODEC_ID_H264 && s->pict_type != AV_PICTURE_TYPE_B) {
            ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);
            ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);
            ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);
            ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);
    if (s->codec_id != AV_CODEC_ID_H264) {
        if (s->last_picture_ptr) {
            ff_mpeg_unref_picture(s, &s->last_picture);
            if (s->last_picture_ptr->f.data[0] &&
                (ret = ff_mpeg_ref_picture(s, &s->last_picture,
                                           s->last_picture_ptr)) < 0)
                return ret;
        }
        if (s->next_picture_ptr) {
            ff_mpeg_unref_picture(s, &s->next_picture);
            if (s->next_picture_ptr->f.data[0] &&
                (ret = ff_mpeg_ref_picture(s, &s->next_picture,
                                           s->next_picture_ptr)) < 0)
                return ret;
        }
        assert(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&
                                                     s->last_picture_ptr->f.data[0]));
              s->current_picture.reference &&
        for (i = 0; i < MAX_PICTURE_COUNT; i++) {
            if (!s->picture[i].reference)
                ff_mpeg_unref_picture(s, &s->picture[i]);
    if (s->codec_id != AV_CODEC_ID_H264 && s->current_picture.reference)
        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
void ff_print_debug_info(MpegEncContext *s, Picture *p)
    AVFrame *pict;
    if (s->avctx->hwaccel || !p || !p->mb_type)
    pict = &p->f;
                           p->qscale_table[x + y * s->mb_stride]);
                    int mb_type = p->mb_type[x + y * s->mb_stride];
                if ((s->avctx->debug_mv) && p->motion_val) {
                        if (!USES_LIST(p->mb_type[mb_index], direction))
                        if (IS_8X8(p->mb_type[mb_index])) {
                                int mx = (p->motion_val[direction][xy][0] >> shift) + sx;
                                int my = (p->motion_val[direction][xy][1] >> shift) + sy;
                        } else if (IS_16X8(p->mb_type[mb_index])) {
                                int mx = (p->motion_val[direction][xy][0] >> shift);
                                int my = (p->motion_val[direction][xy][1] >> shift);
                                if (IS_INTERLACED(p->mb_type[mb_index]))
                        } else if (IS_8X16(p->mb_type[mb_index])) {
                                int mx = p->motion_val[direction][xy][0] >> shift;
                                int my = p->motion_val[direction][xy][1] >> shift;
                                if (IS_INTERLACED(p->mb_type[mb_index]))
                              int mx = p->motion_val[direction][xy][0] >> shift + sx;
                              int my = p->motion_val[direction][xy][1] >> shift + sy;
                if ((s->avctx->debug & FF_DEBUG_VIS_QP) && p->motion_val) {
                    uint64_t c = (p->qscale_table[mb_index] * 128 / 31) *
                    p->motion_val) {
                    int mb_type = p->mb_type[mb_index];
                            int32_t *mv = (int32_t *) &p->motion_val[0][xy];
       /* print DCT coefficients */
               av_log(s->avctx, AV_LOG_DEBUG, ""%5d"", block[i][s->dsp.idct_permutation[j]]);
    s->current_picture.qscale_table[mb_xy] = s->qscale;
            } else if(!s->current_picture.reference) {
                        ff_thread_await_progress(&s->last_picture_ptr->tf,
                        ff_thread_await_progress(&s->next_picture_ptr->tf,
        cur->reference &&
    for (i = 0; i < MAX_PICTURE_COUNT; i++)
        ff_mpeg_unref_picture(s, &s->picture[i]);
        ff_thread_report_progress(&s->current_picture_ptr->tf, s->mb_y, 0);","void ff_copy_picture(Picture *dst, Picture *src)
{
    *dst = *src;
    dst->f.type = FF_BUFFER_TYPE_COPY;
}

/**
 * Release a frame buffer
 */
static void free_frame_buffer(MpegEncContext *s, Picture *pic)
{
    /* WM Image / Screen codecs allocate internal buffers with different
     * dimensions / colorspaces; ignore user-defined callbacks for these. */
    if (s->codec_id != AV_CODEC_ID_WMV3IMAGE &&
        s->codec_id != AV_CODEC_ID_VC1IMAGE  &&
        s->codec_id != AV_CODEC_ID_MSS2)
        ff_thread_release_buffer(s->avctx, &pic->f);
    else
        avcodec_default_release_buffer(s->avctx, &pic->f);
    av_freep(&pic->hwaccel_picture_private);
}

        r = ff_thread_get_buffer(s->avctx, &pic->f);
    else
        r = avcodec_default_get_buffer(s->avctx, &pic->f);

    if (r < 0 || !pic->f.type || !pic->f.data[0]) {
        av_log(s->avctx, AV_LOG_ERROR, ""get_buffer() failed (%d %d %p)\n"",
               r, pic->f.type, pic->f.data[0]);
        free_frame_buffer(s, pic);
        free_frame_buffer(s, pic);
        free_frame_buffer(s, pic);
/**
 * Allocate a Picture.
 * The pixels are allocated/set by calling get_buffer() if shared = 0
 */
int ff_alloc_picture(MpegEncContext *s, Picture *pic, int shared)
    const int big_mb_num = s->mb_stride * (s->mb_height + 1) + 1;
    // the + 1 is needed so memset(,,stride*height) does not sig11
    const int b4_array_size = s->b4_stride * s->mb_height * 4;
    int r = -1;
        assert(pic->f.type == 0 || pic->f.type == FF_BUFFER_TYPE_SHARED);
        pic->f.type = FF_BUFFER_TYPE_SHARED;
    if (pic->f.qscale_table == NULL) {
        if (s->encoding) {
            FF_ALLOCZ_OR_GOTO(s->avctx, pic->mb_var,
                              mb_array_size * sizeof(int16_t), fail)
            FF_ALLOCZ_OR_GOTO(s->avctx, pic->mc_mb_var,
                              mb_array_size * sizeof(int16_t), fail)
            FF_ALLOCZ_OR_GOTO(s->avctx, pic->mb_mean,
                              mb_array_size * sizeof(int8_t ), fail)
        }
        FF_ALLOCZ_OR_GOTO(s->avctx, pic->f.mbskip_table,
                          mb_array_size * sizeof(uint8_t) + 2, fail)// the + 2 is for the slice end check
        FF_ALLOCZ_OR_GOTO(s->avctx, pic->qscale_table_base,
                          (big_mb_num + s->mb_stride) * sizeof(uint8_t),
                          fail)
        FF_ALLOCZ_OR_GOTO(s->avctx, pic->mb_type_base,
                          (big_mb_num + s->mb_stride) * sizeof(uint32_t),
                          fail)
        pic->f.mb_type = pic->mb_type_base + 2 * s->mb_stride + 1;
        pic->f.qscale_table = pic->qscale_table_base + 2 * s->mb_stride + 1;
        if (s->out_format == FMT_H264) {
            for (i = 0; i < 2; i++) {
                FF_ALLOCZ_OR_GOTO(s->avctx, pic->motion_val_base[i],
                                  2 * (b4_array_size + 4) * sizeof(int16_t),
                                  fail)
                pic->f.motion_val[i] = pic->motion_val_base[i] + 4;
                FF_ALLOCZ_OR_GOTO(s->avctx, pic->f.ref_index[i],
                                  4 * mb_array_size * sizeof(uint8_t), fail)
            }
            pic->f.motion_subsample_log2 = 2;
        } else if (s->out_format == FMT_H263 || s->encoding ||
                   (s->avctx->debug & FF_DEBUG_MV) || s->avctx->debug_mv) {
            for (i = 0; i < 2; i++) {
                FF_ALLOCZ_OR_GOTO(s->avctx, pic->motion_val_base[i],
                                  2 * (b8_array_size + 4) * sizeof(int16_t),
                                  fail)
                pic->f.motion_val[i] = pic->motion_val_base[i] + 4;
                FF_ALLOCZ_OR_GOTO(s->avctx, pic->f.ref_index[i],
                                  4 * mb_array_size * sizeof(uint8_t), fail)
            }
            pic->f.motion_subsample_log2 = 3;
        }
        if (s->avctx->debug&FF_DEBUG_DCT_COEFF) {
            FF_ALLOCZ_OR_GOTO(s->avctx, pic->f.dct_coeff,
                              64 * mb_array_size * sizeof(int16_t) * 6, fail)
        }
        pic->f.qstride = s->mb_stride;
        FF_ALLOCZ_OR_GOTO(s->avctx, pic->f.pan_scan,
                          1 * sizeof(AVPanScan), fail)
    pic->owner2 = s;
fail: // for  the FF_ALLOCZ_OR_GOTO macro
    if (r >= 0)
        free_frame_buffer(s, pic);
    return -1;
static void free_picture(MpegEncContext *s, Picture *pic)
    int i;
    if (pic->f.data[0] && pic->f.type != FF_BUFFER_TYPE_SHARED) {
        free_frame_buffer(s, pic);
    }

    av_freep(&pic->mb_var);
    av_freep(&pic->mc_mb_var);
    av_freep(&pic->mb_mean);
    av_freep(&pic->f.mbskip_table);
    av_freep(&pic->qscale_table_base);
    pic->f.qscale_table = NULL;
    av_freep(&pic->mb_type_base);
    pic->f.mb_type = NULL;
    av_freep(&pic->f.dct_coeff);
    av_freep(&pic->f.pan_scan);
    pic->f.mb_type = NULL;
        av_freep(&pic->motion_val_base[i]);
        av_freep(&pic->f.ref_index[i]);
        pic->f.motion_val[i] = NULL;
    if (pic->f.type == FF_BUFFER_TYPE_SHARED) {
        for (i = 0; i < 4; i++) {
            pic->f.base[i] =
            pic->f.data[i] = NULL;
        }
        pic->f.type = 0;
    int i;
        s->picture_range_start  += MAX_PICTURE_COUNT;
        s->picture_range_end    += MAX_PICTURE_COUNT;
    memcpy(s->picture, s1->picture, s1->picture_count * sizeof(Picture));
    memcpy(&s->last_picture, &s1->last_picture,
           (char *) &s1->last_picture_ptr - (char *) &s1->last_picture);

    // reset s->picture[].f.extended_data to s->picture[].f.data
    for (i = 0; i < s->picture_count; i++)
        s->picture[i].f.extended_data = s->picture[i].f.data;
    s->picture_range_start   = 0;
    s->picture_range_end     = MAX_PICTURE_COUNT;

    s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count);
                      s->picture_count * sizeof(Picture), fail);
    for (i = 0; i < s->picture_count; i++) {
    free_context_frame(s);
        for (i = 0; i < s->picture_count; i++) {
    if (s->picture && !s->avctx->internal->is_copy) {
        for (i = 0; i < s->picture_count; i++) {
            free_picture(s, &s->picture[i]);
    if (!(s->avctx->active_thread_type & FF_THREAD_FRAME))
        avcodec_default_free_buffers(s->avctx);

    for (i = 0; i < s->picture_count; i++) {
        if (s->picture[i].f.data[0] && !s->picture[i].f.reference &&
            (!s->picture[i].owner2 || s->picture[i].owner2 == s) &&
            (remove_current || &s->picture[i] !=  s->current_picture_ptr)
            /* && s->picture[i].type!= FF_BUFFER_TYPE_SHARED */) {
            free_frame_buffer(s, &s->picture[i]);
    if (pic->needs_realloc && !(pic->f.reference & DELAYED_PIC_REF))
        if (!pic->owner2 || pic->owner2 == s)
            return 1;
        for (i = s->picture_range_start; i < s->picture_range_end; i++) {
            if (s->picture[i].f.data[0] == NULL && s->picture[i].f.type == 0)
        for (i = s->picture_range_start; i < s->picture_range_end; i++) {
            if (pic_is_unused(s, &s->picture[i]) && s->picture[i].f.type != 0)
                return i; // FIXME
        }
        for (i = s->picture_range_start; i < s->picture_range_end; i++) {
    if (ret >= 0 && ret < s->picture_range_end) {
            free_picture(s, &s->picture[ret]);
    int i;
            if (s->last_picture_ptr->owner2 == s)
                free_frame_buffer(s, s->last_picture_ptr);
            for (i = 0; i < s->picture_count; i++) {
                if (s->picture[i].owner2 == s && s->picture[i].f.data[0] &&
                    &s->picture[i] != s->last_picture_ptr &&
                    s->picture[i].f.reference && !s->picture[i].needs_realloc) {
                    free_frame_buffer(s, &s->picture[i]);
        pic->f.reference = 0;
                pic->f.reference = s->picture_structure;
                pic->f.reference = 3;
    ff_copy_picture(&s->current_picture, s->current_picture_ptr);
    if (s->pict_type != AV_PICTURE_TYPE_B) {
            ff_thread_report_progress(&s->last_picture_ptr->f, INT_MAX, 0);
            ff_thread_report_progress(&s->last_picture_ptr->f, INT_MAX, 1);
            s->last_picture_ptr->f.reference = 3;
            ff_thread_report_progress(&s->next_picture_ptr->f, INT_MAX, 0);
            ff_thread_report_progress(&s->next_picture_ptr->f, INT_MAX, 1);
            s->next_picture_ptr->f.reference = 3;
    if (s->last_picture_ptr)
        ff_copy_picture(&s->last_picture, s->last_picture_ptr);
    if (s->next_picture_ptr)
        ff_copy_picture(&s->next_picture, s->next_picture_ptr);
    if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (s->next_picture_ptr)
            s->next_picture_ptr->owner2 = s;
        if (s->last_picture_ptr)
            s->last_picture_ptr->owner2 = s;
    assert(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&
                                                 s->last_picture_ptr->f.data[0]));

              s->current_picture.f.reference &&
        for (i = 0; i < s->picture_count; i++) {
            if (s->picture[i].f.data[0] && !s->picture[i].f.reference
                /* && s->picture[i].type != FF_BUFFER_TYPE_SHARED */) {
                free_frame_buffer(s, &s->picture[i]);
            }
    if (s->codec_id != AV_CODEC_ID_H264 && s->current_picture.f.reference) {
        ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX, 0);
    }
void ff_print_debug_info(MpegEncContext *s, AVFrame *pict)
    if (s->avctx->hwaccel || !pict || !pict->mb_type)
                           pict->qscale_table[x + y * s->mb_stride]);
                    int mb_type = pict->mb_type[x + y * s->mb_stride];
        pict->type   = FF_BUFFER_TYPE_COPY;
                if ((s->avctx->debug_mv) && pict->motion_val) {
                        if (!USES_LIST(pict->mb_type[mb_index], direction))
                        if (IS_8X8(pict->mb_type[mb_index])) {
                                int mx = (pict->motion_val[direction][xy][0] >> shift) + sx;
                                int my = (pict->motion_val[direction][xy][1] >> shift) + sy;
                        } else if (IS_16X8(pict->mb_type[mb_index])) {
                                int mx = (pict->motion_val[direction][xy][0] >> shift);
                                int my = (pict->motion_val[direction][xy][1] >> shift);
                                if (IS_INTERLACED(pict->mb_type[mb_index]))
                        } else if (IS_8X16(pict->mb_type[mb_index])) {
                                int mx = pict->motion_val[direction][xy][0] >> shift;
                                int my = pict->motion_val[direction][xy][1] >> shift;
                                if (IS_INTERLACED(pict->mb_type[mb_index]))
                              int mx = pict->motion_val[direction][xy][0] >> shift + sx;
                              int my = pict->motion_val[direction][xy][1] >> shift + sy;
                if ((s->avctx->debug & FF_DEBUG_VIS_QP) && pict->motion_val) {
                    uint64_t c = (pict->qscale_table[mb_index] * 128 / 31) *
                    pict->motion_val) {
                    int mb_type = pict->mb_type[mb_index];
                            int32_t *mv = (int32_t *) &pict->motion_val[0][xy];
       /* save DCT coefficients */
       int16_t *dct = &s->current_picture.f.dct_coeff[mb_xy * 64 * 6];
               *dct++ = block[i][s->dsp.idct_permutation[j]];
               av_log(s->avctx, AV_LOG_DEBUG, ""%5d"", dct[-1]);
    s->current_picture.f.qscale_table[mb_xy] = s->qscale;
            } else if(!s->current_picture.f.reference) {
                        ff_thread_await_progress(&s->last_picture_ptr->f,
                        ff_thread_await_progress(&s->next_picture_ptr->f,
        cur->f.reference &&
    for(i=0; i<s->picture_count; i++){
       if (s->picture[i].f.data[0] &&
           (s->picture[i].f.type == FF_BUFFER_TYPE_INTERNAL ||
            s->picture[i].f.type == FF_BUFFER_TYPE_USER))
        free_frame_buffer(s, &s->picture[i]);
    }
        ff_thread_report_progress(&s->current_picture_ptr->f, s->mb_y, 0);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED," VAR->VAR.VAR = &VAR->VAR; VAR = VAR(VAR->VAR, &VAR->VAR, VAR->VAR ? VAR : 0); VAR { VAR->VAR.VAR = VAR->VAR->VAR; VAR->VAR.VAR = VAR->VAR->VAR; VAR->VAR.VAR = VAR->VAR->VAR; VAR = VAR(VAR->VAR, &VAR->VAR, 0); } VAR (VAR < 0 || !VAR->VAR.VAR[0]) { VAR(VAR->VAR, VAR, ""VAR() VAR (%VAR %VAR)\VAR"", VAR, VAR->VAR.VAR[0]); VAR(VAR, VAR); VAR(VAR, VAR); VAR(VAR, VAR); VAR VAR VAR(VAR *VAR) VAR VAR; VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR (VAR = 0; VAR < 2; VAR++) { VAR(&VAR->VAR[VAR]); VAR(&VAR->VAR[VAR]); } } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR VAR = VAR->VAR * (VAR->VAR + 1) + 1; VAR->VAR = VAR(VAR + 2); VAR->VAR = VAR(VAR + VAR->VAR); VAR->VAR = VAR((VAR + VAR->VAR) * VAR(VAR)); VAR (!VAR->VAR || !VAR->VAR || !VAR->VAR) VAR VAR(VAR); VAR (VAR->VAR) { VAR->VAR = VAR(VAR * VAR(VAR)); VAR->VAR = VAR(VAR * VAR(VAR)); VAR->VAR = VAR(VAR); VAR (!VAR->VAR || !VAR->VAR || !VAR->VAR) VAR VAR(VAR); } VAR (VAR->VAR == VAR || VAR->VAR || (VAR->VAR->VAR & VAR) || VAR->VAR->VAR) { VAR VAR = 2 * (VAR + 4) * VAR(VAR); VAR VAR = 4 * VAR; VAR (VAR = 0; VAR && VAR < 2; VAR++) { VAR->VAR[VAR] = VAR(VAR); VAR->VAR[VAR] = VAR(VAR); VAR (!VAR->VAR[VAR] || !VAR->VAR[VAR]) VAR VAR(VAR); } } VAR 0; } VAR VAR VAR(VAR *VAR) { VAR VAR, VAR;  VAR {\ VAR (VAR->VAR &&\ (VAR = VAR(&VAR->VAR)) < 0)\ VAR VAR;\ } VAR (0) VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR (VAR = 0; VAR < 2; VAR++) { VAR(VAR[VAR]); VAR(VAR[VAR]); } VAR 0; } /** * VAR VAR VAR. * VAR VAR VAR VAR/VAR VAR VAR VAR() VAR VAR = 0 */ VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) { VAR VAR, VAR; VAR->VAR = 1; VAR (!VAR->VAR) VAR = VAR(VAR, VAR); VAR VAR = VAR(VAR); VAR (VAR < 0) VAR VAR; VAR (VAR->VAR) { VAR->VAR = (VAR*)VAR->VAR->VAR; VAR->VAR = (VAR*)VAR->VAR->VAR; VAR->VAR = VAR->VAR->VAR; VAR->VAR = VAR->VAR->VAR; VAR->VAR = VAR->VAR->VAR + 2 * VAR->VAR + 1; VAR->VAR = (VAR*)VAR->VAR->VAR + 2 * VAR->VAR + 1; VAR (VAR->VAR[0]) { VAR (VAR = 0; VAR < 2; VAR++) { VAR->VAR[VAR] = (VAR (*)[2])VAR->VAR[VAR]->VAR + 4; VAR->VAR[VAR] = VAR->VAR[VAR]->VAR; } } VAR: VAR(VAR->VAR, VAR, ""VAR VAR VAR VAR.\VAR""); VAR(VAR, VAR); VAR(VAR); VAR VAR(VAR); VAR VAR(VAR *VAR, VAR *VAR) VAR VAR = VAR(VAR, VAR) + VAR(VAR->VAR); VAR->VAR.VAR = &VAR->VAR; /* VAR VAR / VAR VAR VAR VAR VAR VAR VAR * VAR / VAR; VAR VAR-VAR VAR VAR VAR. */ VAR (VAR->VAR != VAR && VAR->VAR != VAR && VAR->VAR != VAR) VAR(VAR->VAR, &VAR->VAR); VAR VAR(&VAR->VAR); VAR(&VAR->VAR); VAR((VAR*)VAR + VAR, 0, VAR(*VAR) - VAR); } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR;  VAR {\ VAR (VAR->VAR &&\ (!VAR->VAR || VAR->VAR->VAR != VAR->VAR->VAR)) {\ VAR(&VAR->VAR);\ VAR->VAR = VAR(VAR->VAR);\ VAR (!VAR->VAR) {\ VAR(VAR);\ VAR VAR(VAR);\ }\ }\ } VAR (0) VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR[VAR]); VAR(VAR[VAR]); VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR (VAR = 0; VAR < 2; VAR++) { VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR->VAR[VAR]; VAR 0; } VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR) { VAR VAR; VAR(!VAR->VAR.VAR[0]); VAR(VAR->VAR.VAR[0]); VAR->VAR.VAR = &VAR->VAR; VAR->VAR.VAR = &VAR->VAR; VAR = VAR(&VAR->VAR, &VAR->VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR, VAR); VAR (VAR < 0) VAR VAR; VAR (VAR->VAR) { VAR->VAR = VAR(VAR->VAR); VAR (!VAR->VAR) VAR VAR; VAR->VAR = VAR->VAR->VAR; } VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR 0; VAR: VAR(VAR, VAR); VAR VAR; VAR VAR, VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR[VAR].VAR.VAR[0] && (VAR = VAR(VAR, &VAR->VAR[VAR], &VAR->VAR[VAR])) < 0) VAR VAR; }  VAR {\ VAR(VAR, &VAR->VAR);\ VAR (VAR->VAR.VAR.VAR[0])\ VAR = VAR(VAR, &VAR->VAR, &VAR->VAR);\ VAR\ VAR = VAR(&VAR->VAR, &VAR->VAR);\ VAR (VAR < 0)\ VAR VAR;\ } VAR (0) VAR(VAR); VAR(VAR); VAR(VAR); VAR * VAR(VAR), VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR(&VAR->VAR, 0, VAR(VAR->VAR)); VAR(&VAR->VAR, 0, VAR(VAR->VAR)); VAR(&VAR->VAR, 0, VAR(VAR->VAR)); VAR(&VAR->VAR.VAR); VAR(&VAR->VAR.VAR); VAR(&VAR->VAR.VAR); VAR ((VAR = VAR(VAR)) < 0) VAR VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR (VAR->VAR) { VAR (VAR = 0; VAR < VAR; VAR++) { VAR(&VAR->VAR[VAR]); VAR(VAR, &VAR->VAR[VAR]); VAR(&VAR->VAR); VAR(VAR, &VAR->VAR); VAR(&VAR->VAR); VAR(VAR, &VAR->VAR); VAR(&VAR->VAR); VAR(VAR, &VAR->VAR); VAR(&VAR->VAR); VAR(VAR, &VAR->VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR (!VAR->VAR[VAR].VAR && (VAR || &VAR->VAR[VAR] != VAR->VAR)) { VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR && !(VAR->VAR & VAR)) VAR 1; VAR (VAR = 0; VAR < VAR; VAR++) { VAR (VAR->VAR[VAR].VAR.VAR[0] == VAR) VAR (VAR = 0; VAR < VAR; VAR++) { VAR (VAR >= 0 && VAR < VAR) { VAR(&VAR->VAR[VAR]); VAR(VAR, &VAR->VAR[VAR]); VAR VAR, VAR; VAR(VAR, VAR->VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR (&VAR->VAR[VAR] != VAR->VAR && VAR->VAR[VAR].VAR && !VAR->VAR[VAR].VAR) { VAR(VAR, &VAR->VAR[VAR]); VAR->VAR = 0; VAR->VAR = VAR->VAR; VAR->VAR = 3; VAR(VAR, &VAR->VAR); VAR ((VAR = VAR(VAR, &VAR->VAR, VAR->VAR)) < 0) VAR VAR; VAR (VAR->VAR != VAR && VAR->VAR != VAR) { VAR(&VAR->VAR->VAR, VAR, 0); VAR(&VAR->VAR->VAR, VAR, 1); VAR(&VAR->VAR->VAR, VAR, 0); VAR(&VAR->VAR->VAR, VAR, 1); VAR (VAR->VAR != VAR) { VAR (VAR->VAR) { VAR(VAR, &VAR->VAR); VAR (VAR->VAR->VAR.VAR[0] && (VAR = VAR(VAR, &VAR->VAR, VAR->VAR)) < 0) VAR VAR; } VAR (VAR->VAR) { VAR(VAR, &VAR->VAR); VAR (VAR->VAR->VAR.VAR[0] && (VAR = VAR(VAR, &VAR->VAR, VAR->VAR)) < 0) VAR VAR; } VAR(VAR->VAR == VAR || (VAR->VAR && VAR->VAR->VAR.VAR[0])); VAR->VAR.VAR && VAR (VAR = 0; VAR < VAR; VAR++) { VAR (!VAR->VAR[VAR].VAR) VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR != VAR && VAR->VAR.VAR) VAR(&VAR->VAR->VAR, VAR, 0); VAR VAR(VAR *VAR, VAR *VAR) VAR *VAR; VAR (VAR->VAR->VAR || !VAR || !VAR->VAR) VAR = &VAR->VAR; VAR->VAR[VAR + VAR * VAR->VAR]); VAR VAR = VAR->VAR[VAR + VAR * VAR->VAR]; VAR ((VAR->VAR->VAR) && VAR->VAR) { VAR (!VAR(VAR->VAR[VAR], VAR)) VAR (VAR(VAR->VAR[VAR])) { VAR VAR = (VAR->VAR[VAR][VAR][0] >> VAR) + VAR; VAR VAR = (VAR->VAR[VAR][VAR][1] >> VAR) + VAR; } VAR VAR (VAR(VAR->VAR[VAR])) { VAR VAR = (VAR->VAR[VAR][VAR][0] >> VAR); VAR VAR = (VAR->VAR[VAR][VAR][1] >> VAR); VAR (VAR(VAR->VAR[VAR])) } VAR VAR (VAR(VAR->VAR[VAR])) { VAR VAR = VAR->VAR[VAR][VAR][0] >> VAR; VAR VAR = VAR->VAR[VAR][VAR][1] >> VAR; VAR (VAR(VAR->VAR[VAR])) VAR VAR = VAR->VAR[VAR][VAR][0] >> VAR + VAR; VAR VAR = VAR->VAR[VAR][VAR][1] >> VAR + VAR; VAR ((VAR->VAR->VAR & VAR) && VAR->VAR) { VAR VAR = (VAR->VAR[VAR] * 128 / 31) * VAR->VAR) { VAR VAR = VAR->VAR[VAR]; VAR *VAR = (VAR *) &VAR->VAR[0][VAR];  VAR(VAR->VAR, VAR, ""%5d"", VAR[VAR][VAR->VAR.VAR[VAR]]); VAR->VAR.VAR[VAR] = VAR->VAR; } VAR VAR(!VAR->VAR.VAR) { VAR(&VAR->VAR->VAR, VAR(&VAR->VAR->VAR, VAR->VAR && VAR (VAR = 0; VAR < VAR; VAR++) VAR(VAR, &VAR->VAR[VAR]); VAR(&VAR->VAR->VAR, VAR->VAR, 0); VAR VAR(VAR *VAR, VAR *VAR) { *VAR = *VAR; VAR->VAR.VAR = VAR; } /** * VAR VAR VAR VAR */ VAR VAR VAR(VAR *VAR, VAR *VAR) { /* VAR VAR / VAR VAR VAR VAR VAR VAR VAR * VAR / VAR; VAR VAR-VAR VAR VAR VAR. */ VAR (VAR->VAR != VAR && VAR->VAR != VAR && VAR->VAR != VAR) VAR(VAR->VAR, &VAR->VAR); VAR VAR(VAR->VAR, &VAR->VAR); VAR(&VAR->VAR); } VAR = VAR(VAR->VAR, &VAR->VAR); VAR VAR = VAR(VAR->VAR, &VAR->VAR); VAR (VAR < 0 || !VAR->VAR.VAR || !VAR->VAR.VAR[0]) { VAR(VAR->VAR, VAR, ""VAR() VAR (%VAR %VAR %VAR)\VAR"", VAR, VAR->VAR.VAR, VAR->VAR.VAR[0]); VAR(VAR, VAR); VAR(VAR, VAR); VAR(VAR, VAR); /** * VAR VAR VAR. * VAR VAR VAR VAR/VAR VAR VAR VAR() VAR VAR = 0 */ VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR VAR VAR = VAR->VAR * (VAR->VAR + 1) + 1;  VAR VAR VAR = VAR->VAR * VAR->VAR * 4; VAR VAR = -1; VAR(VAR->VAR.VAR == 0 || VAR->VAR.VAR == VAR); VAR->VAR.VAR = VAR; VAR (VAR->VAR.VAR == VAR) { VAR (VAR->VAR) { VAR(VAR->VAR, VAR->VAR, VAR * VAR(VAR), VAR) VAR(VAR->VAR, VAR->VAR, VAR * VAR(VAR), VAR) VAR(VAR->VAR, VAR->VAR, VAR * VAR(VAR ), VAR) } VAR(VAR->VAR, VAR->VAR.VAR, VAR * VAR(VAR) + 2, VAR) VAR(VAR->VAR, VAR->VAR, (VAR + VAR->VAR) * VAR(VAR), VAR) VAR(VAR->VAR, VAR->VAR, (VAR + VAR->VAR) * VAR(VAR), VAR) VAR->VAR.VAR = VAR->VAR + 2 * VAR->VAR + 1; VAR->VAR.VAR = VAR->VAR + 2 * VAR->VAR + 1; VAR (VAR->VAR == VAR) { VAR (VAR = 0; VAR < 2; VAR++) { VAR(VAR->VAR, VAR->VAR[VAR], 2 * (VAR + 4) * VAR(VAR), VAR) VAR->VAR.VAR[VAR] = VAR->VAR[VAR] + 4; VAR(VAR->VAR, VAR->VAR.VAR[VAR], 4 * VAR * VAR(VAR), VAR) } VAR->VAR.VAR = 2; } VAR VAR (VAR->VAR == VAR || VAR->VAR || (VAR->VAR->VAR & VAR) || VAR->VAR->VAR) { VAR (VAR = 0; VAR < 2; VAR++) { VAR(VAR->VAR, VAR->VAR[VAR], 2 * (VAR + 4) * VAR(VAR), VAR) VAR->VAR.VAR[VAR] = VAR->VAR[VAR] + 4; VAR(VAR->VAR, VAR->VAR.VAR[VAR], 4 * VAR * VAR(VAR), VAR) } VAR->VAR.VAR = 3; } VAR (VAR->VAR->VAR&VAR) { VAR(VAR->VAR, VAR->VAR.VAR, 64 * VAR * VAR(VAR) * 6, VAR) } VAR->VAR.VAR = VAR->VAR; VAR(VAR->VAR, VAR->VAR.VAR, 1 * VAR(VAR), VAR) VAR->VAR = VAR; VAR:  VAR (VAR >= 0) VAR(VAR, VAR); VAR -1; VAR VAR VAR(VAR *VAR, VAR *VAR) VAR VAR; VAR (VAR->VAR.VAR[0] && VAR->VAR.VAR != VAR) { VAR(VAR, VAR); } VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR.VAR); VAR(&VAR->VAR); VAR->VAR.VAR = VAR; VAR(&VAR->VAR); VAR->VAR.VAR = VAR; VAR(&VAR->VAR.VAR); VAR(&VAR->VAR.VAR); VAR->VAR.VAR = VAR; VAR(&VAR->VAR[VAR]); VAR(&VAR->VAR.VAR[VAR]); VAR->VAR.VAR[VAR] = VAR; VAR (VAR->VAR.VAR == VAR) { VAR (VAR = 0; VAR < 4; VAR++) { VAR->VAR.VAR[VAR] = VAR->VAR.VAR[VAR] = VAR; } VAR->VAR.VAR = 0; VAR VAR; VAR->VAR += VAR; VAR->VAR += VAR; VAR(VAR->VAR, VAR->VAR, VAR->VAR * VAR(VAR)); VAR(&VAR->VAR, &VAR->VAR, (VAR *) &VAR->VAR - (VAR *) &VAR->VAR);  VAR (VAR = 0; VAR < VAR->VAR; VAR++) VAR->VAR[VAR].VAR.VAR = VAR->VAR[VAR].VAR.VAR; VAR->VAR = 0; VAR->VAR = VAR; VAR->VAR = VAR * VAR(1, VAR->VAR->VAR); VAR->VAR * VAR(VAR), VAR); VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR(VAR); VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR->VAR && !VAR->VAR->VAR->VAR) { VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR(VAR, &VAR->VAR[VAR]); VAR (!(VAR->VAR->VAR & VAR)) VAR(VAR->VAR); VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR->VAR[VAR].VAR.VAR[0] && !VAR->VAR[VAR].VAR.VAR && (!VAR->VAR[VAR].VAR || VAR->VAR[VAR].VAR == VAR) && (VAR || &VAR->VAR[VAR] != VAR->VAR) ) { VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR && !(VAR->VAR.VAR & VAR)) VAR (!VAR->VAR || VAR->VAR == VAR) VAR 1; VAR (VAR = VAR->VAR; VAR < VAR->VAR; VAR++) { VAR (VAR->VAR[VAR].VAR.VAR[0] == VAR && VAR->VAR[VAR].VAR.VAR == 0) VAR (VAR = VAR->VAR; VAR < VAR->VAR; VAR++) { VAR (VAR(VAR, &VAR->VAR[VAR]) && VAR->VAR[VAR].VAR.VAR != 0) VAR VAR;  } VAR (VAR = VAR->VAR; VAR < VAR->VAR; VAR++) { VAR (VAR >= 0 && VAR < VAR->VAR) { VAR(VAR, &VAR->VAR[VAR]); VAR VAR; VAR (VAR->VAR->VAR == VAR) VAR(VAR, VAR->VAR); VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR->VAR[VAR].VAR == VAR && VAR->VAR[VAR].VAR.VAR[0] && &VAR->VAR[VAR] != VAR->VAR && VAR->VAR[VAR].VAR.VAR && !VAR->VAR[VAR].VAR) { VAR(VAR, &VAR->VAR[VAR]); VAR->VAR.VAR = 0; VAR->VAR.VAR = VAR->VAR; VAR->VAR.VAR = 3; VAR(&VAR->VAR, VAR->VAR); VAR (VAR->VAR != VAR) { VAR(&VAR->VAR->VAR, VAR, 0); VAR(&VAR->VAR->VAR, VAR, 1); VAR->VAR->VAR.VAR = 3; VAR(&VAR->VAR->VAR, VAR, 0); VAR(&VAR->VAR->VAR, VAR, 1); VAR->VAR->VAR.VAR = 3; VAR (VAR->VAR) VAR(&VAR->VAR, VAR->VAR); VAR (VAR->VAR) VAR(&VAR->VAR, VAR->VAR); VAR (VAR && (VAR->VAR & VAR)) { VAR (VAR->VAR) VAR->VAR->VAR = VAR; VAR (VAR->VAR) VAR->VAR->VAR = VAR; VAR(VAR->VAR == VAR || (VAR->VAR && VAR->VAR->VAR.VAR[0])); VAR->VAR.VAR.VAR && VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR->VAR[VAR].VAR.VAR[0] && !VAR->VAR[VAR].VAR.VAR ) { VAR(VAR, &VAR->VAR[VAR]); } VAR (VAR->VAR != VAR && VAR->VAR.VAR.VAR) { VAR(&VAR->VAR->VAR, VAR, 0); } VAR VAR(VAR *VAR, VAR *VAR) VAR (VAR->VAR->VAR || !VAR || !VAR->VAR) VAR->VAR[VAR + VAR * VAR->VAR]); VAR VAR = VAR->VAR[VAR + VAR * VAR->VAR]; VAR->VAR = VAR; VAR ((VAR->VAR->VAR) && VAR->VAR) { VAR (!VAR(VAR->VAR[VAR], VAR)) VAR (VAR(VAR->VAR[VAR])) { VAR VAR = (VAR->VAR[VAR][VAR][0] >> VAR) + VAR; VAR VAR = (VAR->VAR[VAR][VAR][1] >> VAR) + VAR; } VAR VAR (VAR(VAR->VAR[VAR])) { VAR VAR = (VAR->VAR[VAR][VAR][0] >> VAR); VAR VAR = (VAR->VAR[VAR][VAR][1] >> VAR); VAR (VAR(VAR->VAR[VAR])) } VAR VAR (VAR(VAR->VAR[VAR])) { VAR VAR = VAR->VAR[VAR][VAR][0] >> VAR; VAR VAR = VAR->VAR[VAR][VAR][1] >> VAR; VAR (VAR(VAR->VAR[VAR])) VAR VAR = VAR->VAR[VAR][VAR][0] >> VAR + VAR; VAR VAR = VAR->VAR[VAR][VAR][1] >> VAR + VAR; VAR ((VAR->VAR->VAR & VAR) && VAR->VAR) { VAR VAR = (VAR->VAR[VAR] * 128 / 31) * VAR->VAR) { VAR VAR = VAR->VAR[VAR]; VAR *VAR = (VAR *) &VAR->VAR[0][VAR];  VAR *VAR = &VAR->VAR.VAR.VAR[VAR * 64 * 6]; *VAR++ = VAR[VAR][VAR->VAR.VAR[VAR]]; VAR(VAR->VAR, VAR, ""%5d"", VAR[-1]); VAR->VAR.VAR.VAR[VAR] = VAR->VAR; } VAR VAR(!VAR->VAR.VAR.VAR) { VAR(&VAR->VAR->VAR, VAR(&VAR->VAR->VAR, VAR->VAR.VAR && VAR(VAR=0; VAR<VAR->VAR; VAR++){ VAR (VAR->VAR[VAR].VAR.VAR[0] && (VAR->VAR[VAR].VAR.VAR == VAR || VAR->VAR[VAR].VAR.VAR == VAR)) VAR(VAR, &VAR->VAR[VAR]); } VAR(&VAR->VAR->VAR, VAR->VAR, 0);",10
FFmpeg_9a271a9368eaabf99e6c2046103acb33957e63b7,libavcodec/jpeg2000dec.c,"    if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {
        avpriv_request_sample(s->avctx, ""cblk size > 64"");
        return AVERROR_PATCHWELCOME;
    }

    av_assert0(width  <= JPEG2000_MAX_CBLKW);
    av_assert0(height <= JPEG2000_MAX_CBLKH);
",,9a271a9368eaabf99e6c2046103acb33957e63b7,CVE-2013-7018,9a271a9368eaabf99e6c2046103acb33957e63b7,https://github.com/FFmpeg/FFmpeg,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR (VAR->VAR > 6 || VAR->VAR > 6) { VAR(VAR->VAR, ""VAR VAR > 64""); VAR VAR; } VAR(VAR <= VAR); VAR(VAR <= VAR); ",10
FFmpeg_c509f4f74713b035a06f79cb4d00e708f5226bc5,libavcodec/atrac3.c,"                if (component_count >= 64)
                    return AVERROR_INVALIDDATA;",,c509f4f74713b035a06f79cb4d00e708f5226bc5,CVE-2012-0853,c509f4f74713b035a06f79cb4d00e708f5226bc5,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,154,COMPLETED,VAR (VAR >= 64) VAR VAR; ,10
glpi_e0d6a24d16f11505663928cc47292aec77ca2612,tests/functionnal/Session.php,"

   protected function idorProvider() {
      return [
         ['itemtype' => 'Computer'],
         ['itemtype' => 'Ticket'],
         ['itemtype' => 'Glpi\\Dashboard\\Item'],
         ['itemtype' => 'User', 'add_params' => ['right' => 'all']],
      ];
   }

   /**
    * @dataProvider idorProvider
    */
   function testIDORToken(string $itemtype = """", array $add_params = []) {
      // generate token
      $token = \Session::getNewIDORToken($itemtype, $add_params);
      $this->string($token)->hasLength(64);

      // token exists in session and is valid
      $this->array($_SESSION['glpiidortokens'][$token])
         ->string['itemtype']->isEqualTo($itemtype)
         ->string['expires'];

      if (count($add_params) > 0) {
         $this->array($_SESSION['glpiidortokens'][$token])->size->isEqualTo(2 + count($add_params));
      }

      // validate token with dedicated method
      $result = \Session::validateIDOR([
         '_idor_token' => $token,
         'itemtype'    => $itemtype,
      ] + $add_params);
      $this->boolean($result)->isTrue();
   }


   function testDORInvalid() {
      //  random token
      $result = \Session::validateIDOR([
         '_idor_token' => bin2hex(random_bytes(32)),
         'itemtype'    => 'Computer',
      ]);
      $this->boolean($result)->isFalse();

      // bad itemtype
      $token_bad_itt = \Session::getNewIDORToken('Ticket');
      $result = \Session::validateIDOR([
         '_idor_token' => $token_bad_itt,
         'itemtype'    => 'Computer',
      ]);
      $this->boolean($result)->isFalse();

      // missing add params
      $token_miss_param = \Session::getNewIDORToken('User', ['right' => 'all']);
      $result = \Session::validateIDOR([
         '_idor_token' => $token_miss_param,
         'itemtype'    => 'User',
      ]);
      $this->boolean($result)->isFalse();
      $result = \Session::validateIDOR([
         '_idor_token' => $token_miss_param,
         'itemtype'    => 'User',
         'right'       => 'all'
      ]);
      $this->boolean($result)->isTrue();
   }",,e0d6a24d16f11505663928cc47292aec77ca2612,CVE-2020-27663,e0d6a24d16f11505663928cc47292aec77ca2612,https://github.com/glpi-project/glpi,NVD_GIT_REPOBASED,88,COMPLETED,"VAR VAR VAR() { VAR [ ['VAR' => 'VAR'], ['VAR' => 'VAR'], ['VAR' => 'VAR\\VAR\\VAR'], ['VAR' => 'VAR', 'VAR' => ['VAR' => 'VAR']], ]; } /** * @VAR VAR */ VAR VAR(VAR $VAR = """", VAR $VAR = []) {  $VAR = \VAR::VAR($VAR, $VAR); $VAR->VAR($VAR)->VAR(64);  $VAR->VAR($VAR['VAR'][$VAR]) ->VAR['VAR']->VAR($VAR) ->VAR['VAR']; VAR (VAR($VAR) > 0) { $VAR->VAR($VAR['VAR'][$VAR])->VAR->VAR(2 + VAR($VAR)); }  $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => $VAR, ] + $VAR); $VAR->VAR($VAR)->VAR(); } VAR VAR() {  $VAR = \VAR::VAR([ 'VAR' => VAR(VAR(32)), 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR();  $VAR = \VAR::VAR('VAR'); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR();  $VAR = \VAR::VAR('VAR', ['VAR' => 'VAR']); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR(); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', 'VAR' => 'VAR' ]); $VAR->VAR($VAR)->VAR(); } ",10
glpi_e0d6a24d16f11505663928cc47292aec77ca2612,tests/functionnal/Session.php,"

   protected function idorProvider() {
      return [
         ['itemtype' => 'Computer'],
         ['itemtype' => 'Ticket'],
         ['itemtype' => 'Glpi\\Dashboard\\Item'],
         ['itemtype' => 'User', 'add_params' => ['right' => 'all']],
      ];
   }

   /**
    * @dataProvider idorProvider
    */
   function testIDORToken(string $itemtype = """", array $add_params = []) {
      // generate token
      $token = \Session::getNewIDORToken($itemtype, $add_params);
      $this->string($token)->hasLength(64);

      // token exists in session and is valid
      $this->array($_SESSION['glpiidortokens'][$token])
         ->string['itemtype']->isEqualTo($itemtype)
         ->string['expires'];

      if (count($add_params) > 0) {
         $this->array($_SESSION['glpiidortokens'][$token])->size->isEqualTo(2 + count($add_params));
      }

      // validate token with dedicated method
      $result = \Session::validateIDOR([
         '_idor_token' => $token,
         'itemtype'    => $itemtype,
      ] + $add_params);
      $this->boolean($result)->isTrue();
   }


   function testDORInvalid() {
      //  random token
      $result = \Session::validateIDOR([
         '_idor_token' => bin2hex(random_bytes(32)),
         'itemtype'    => 'Computer',
      ]);
      $this->boolean($result)->isFalse();

      // bad itemtype
      $token_bad_itt = \Session::getNewIDORToken('Ticket');
      $result = \Session::validateIDOR([
         '_idor_token' => $token_bad_itt,
         'itemtype'    => 'Computer',
      ]);
      $this->boolean($result)->isFalse();

      // missing add params
      $token_miss_param = \Session::getNewIDORToken('User', ['right' => 'all']);
      $result = \Session::validateIDOR([
         '_idor_token' => $token_miss_param,
         'itemtype'    => 'User',
      ]);
      $this->boolean($result)->isFalse();
      $result = \Session::validateIDOR([
         '_idor_token' => $token_miss_param,
         'itemtype'    => 'User',
         'right'       => 'all'
      ]);
      $this->boolean($result)->isTrue();
   }",,e0d6a24d16f11505663928cc47292aec77ca2612,CVE-2020-27662,e0d6a24d16f11505663928cc47292aec77ca2612,https://github.com/glpi-project/glpi,NVD_GIT_REPOBASED,96,COMPLETED,"VAR VAR VAR() { VAR [ ['VAR' => 'VAR'], ['VAR' => 'VAR'], ['VAR' => 'VAR\\VAR\\VAR'], ['VAR' => 'VAR', 'VAR' => ['VAR' => 'VAR']], ]; } /** * @VAR VAR */ VAR VAR(VAR $VAR = """", VAR $VAR = []) {  $VAR = \VAR::VAR($VAR, $VAR); $VAR->VAR($VAR)->VAR(64);  $VAR->VAR($VAR['VAR'][$VAR]) ->VAR['VAR']->VAR($VAR) ->VAR['VAR']; VAR (VAR($VAR) > 0) { $VAR->VAR($VAR['VAR'][$VAR])->VAR->VAR(2 + VAR($VAR)); }  $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => $VAR, ] + $VAR); $VAR->VAR($VAR)->VAR(); } VAR VAR() {  $VAR = \VAR::VAR([ 'VAR' => VAR(VAR(32)), 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR();  $VAR = \VAR::VAR('VAR'); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR();  $VAR = \VAR::VAR('VAR', ['VAR' => 'VAR']); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR(); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', 'VAR' => 'VAR' ]); $VAR->VAR($VAR)->VAR(); } ",10
gpac_3d17f9524b48e8564bba50055c3502e660c41a64,src/media_tools/media_import.c,"
typedef struct
{
	u32 layer_id_plus_one;
	u32 min_temporal_id, max_temporal_id;
} LHVCLayerInfo;

static void gf_lhevc_set_layer_information(GF_ISOFile *file, u32 track, LHVCLayerInfo *linf)
{
	u32 i, nb_layers=0, di=0;
	char *data;
	u32 data_size;

	GF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);

	for (i=0; i<64; i++) {
		if (linf[i].layer_id_plus_one) nb_layers++;
	}
	gf_bs_write_int(bs, 0, 2);
	gf_bs_write_int(bs, nb_layers, 6);
	for (i=0; i<nb_layers; i++) {
		if (! linf[i].layer_id_plus_one) continue;
		gf_bs_write_int(bs, 0, 4);
		gf_bs_write_int(bs, linf[i].layer_id_plus_one - 1, 6);
		gf_bs_write_int(bs, linf[i].min_temporal_id, 3);
		gf_bs_write_int(bs, linf[i].max_temporal_id, 3);
		gf_bs_write_int(bs, 0, 1);
		gf_bs_write_int(bs, 0xFF, 7);

	}
	gf_bs_get_content(bs, &data, &data_size);
	gf_bs_del(bs);
	gf_isom_add_sample_group_info(file, track, GF_4CC( 'l', 'i', 'n', 'f'), data, data_size, GF_TRUE, &di);
	gf_free(data);
}

	LHVCLayerInfo linf[64];
	memset(linf, 0, sizeof(linf));

		if (copy_size) {
			linf[layer_id].layer_id_plus_one = layer_id + 1;
			if (! linf[layer_id].max_temporal_id ) linf[layer_id].max_temporal_id = temporal_id;
			else if (linf[layer_id].max_temporal_id < temporal_id) linf[layer_id].max_temporal_id = temporal_id;

			if (! linf[layer_id].min_temporal_id ) linf[layer_id].min_temporal_id = temporal_id;
			else if (linf[layer_id].min_temporal_id > temporal_id) linf[layer_id].min_temporal_id = temporal_id;
		}
		gf_lhevc_set_layer_information(import->dest, track, &linf[0]);",,3d17f9524b48e8564bba50055c3502e660c41a64,CVE-2018-1000100,3d17f9524b48e8564bba50055c3502e660c41a64,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,76,COMPLETED,"VAR VAR { VAR VAR; VAR VAR, VAR; } VAR; VAR VAR VAR(VAR *VAR, VAR VAR, VAR *VAR) { VAR VAR, VAR=0, VAR=0; VAR *VAR; VAR VAR; VAR *VAR = VAR(VAR, 0, VAR); VAR (VAR=0; VAR<64; VAR++) { VAR (VAR[VAR].VAR) VAR++; } VAR(VAR, 0, 2); VAR(VAR, VAR, 6); VAR (VAR=0; VAR<VAR; VAR++) { VAR (! VAR[VAR].VAR) VAR; VAR(VAR, 0, 4); VAR(VAR, VAR[VAR].VAR - 1, 6); VAR(VAR, VAR[VAR].VAR, 3); VAR(VAR, VAR[VAR].VAR, 3); VAR(VAR, 0, 1); VAR(VAR, 0xFF, 7); } VAR(VAR, &VAR, &VAR); VAR(VAR); VAR(VAR, VAR, VAR( 'VAR', 'VAR', 'VAR', 'VAR'), VAR, VAR, VAR, &VAR); VAR(VAR); } VAR VAR[64]; VAR(VAR, 0, VAR(VAR)); VAR (VAR) { VAR[VAR].VAR = VAR + 1; VAR (! VAR[VAR].VAR ) VAR[VAR].VAR = VAR; VAR VAR (VAR[VAR].VAR < VAR) VAR[VAR].VAR = VAR; VAR (! VAR[VAR].VAR ) VAR[VAR].VAR = VAR; VAR VAR (VAR[VAR].VAR > VAR) VAR[VAR].VAR = VAR; } VAR(VAR->VAR, VAR, &VAR[0]); ",10
gpac_524e2bbdb294d5aa4c84bf83db4d328a588b55f7,include/gpac/internal/isomedia_dev.h,"	/*the default size is 64, cause we need to handle large boxes...
	the other_boxes container is by default NOT created. When parsing a box and adding
	a sub-box with gf_isom_box_add_default, the list is created.
	This list is destroyed befaore calling the final box destructor
	This list is automatically taken into account during size() and write() functions
	*/
	Bool is_unknown;","/*the default size is 64, cause we need to handle large boxes...
the other_boxes container is by default NOT created. When parsing a box and adding
a sub-box with gf_isom_box_add_default, the list is created.
This list is destroyed befaore calling the final box destructor
This list is automatically taken into account during size() and write() functions
*/",524e2bbdb294d5aa4c84bf83db4d328a588b55f7,CVE-2020-22678,524e2bbdb294d5aa4c84bf83db4d328a588b55f7,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,68,COMPLETED,"/*VAR VAR VAR VAR 64, VAR VAR VAR VAR VAR VAR VAR... VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR() VAR VAR() VAR */ VAR VAR; /*VAR VAR VAR VAR 64, VAR VAR VAR VAR VAR VAR VAR... VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR() VAR VAR() VAR */",10
linux_20418acd6874792359b42c12d159f42f17593f34,fs/cifs/connect.c,"

	rc = CIFS_SessSetup(xid, pSesInfo, first_time, nls_info);
		spin_lock(&GlobalMid_Lock);
		pSesInfo->status = CifsGood;
		pSesInfo->need_reconnect = false;
		spin_unlock(&GlobalMid_Lock);","static int
CIFSSessSetup(unsigned int xid, struct cifsSesInfo *ses,
	      char session_key[CIFS_SESS_KEY_SIZE],
	      const struct nls_table *nls_codepage)
{
	struct smb_hdr *smb_buffer;
	struct smb_hdr *smb_buffer_response;
	SESSION_SETUP_ANDX *pSMB;
	SESSION_SETUP_ANDX *pSMBr;
	char *bcc_ptr;
	char *user;
	char *domain;
	int rc = 0;
	int remaining_words = 0;
	int bytes_returned = 0;
	int len;
	__u32 capabilities;
	__u16 count;

	cFYI(1, (""In sesssetup""));
	if (ses == NULL)
		return -EINVAL;
	user = ses->userName;
	domain = ses->domainName;
	smb_buffer = cifs_buf_get();

	if (smb_buffer == NULL)
		return -ENOMEM;

	smb_buffer_response = smb_buffer;
	pSMBr = pSMB = (SESSION_SETUP_ANDX *) smb_buffer;

	/* send SMBsessionSetup here */
	header_assemble(smb_buffer, SMB_COM_SESSION_SETUP_ANDX,
			NULL /* no tCon exists yet */ , 13 /* wct */ );

	smb_buffer->Mid = GetNextMid(ses->server);
	pSMB->req_no_secext.AndXCommand = 0xFF;
	pSMB->req_no_secext.MaxBufferSize = cpu_to_le16(ses->server->maxBuf);
	pSMB->req_no_secext.MaxMpxCount = cpu_to_le16(ses->server->maxReq);

	if (ses->server->secMode &
			(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))
		smb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;

	capabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |
		CAP_LARGE_WRITE_X | CAP_LARGE_READ_X;
	if (ses->capabilities & CAP_UNICODE) {
		smb_buffer->Flags2 |= SMBFLG2_UNICODE;
		capabilities |= CAP_UNICODE;
	}
	if (ses->capabilities & CAP_STATUS32) {
		smb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;
		capabilities |= CAP_STATUS32;
	}
	if (ses->capabilities & CAP_DFS) {
		smb_buffer->Flags2 |= SMBFLG2_DFS;
		capabilities |= CAP_DFS;
	}
	pSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);

	pSMB->req_no_secext.CaseInsensitivePasswordLength =
		cpu_to_le16(CIFS_SESS_KEY_SIZE);

	pSMB->req_no_secext.CaseSensitivePasswordLength =
	    cpu_to_le16(CIFS_SESS_KEY_SIZE);
	bcc_ptr = pByteArea(smb_buffer);
	memcpy(bcc_ptr, (char *) session_key, CIFS_SESS_KEY_SIZE);
	bcc_ptr += CIFS_SESS_KEY_SIZE;
	memcpy(bcc_ptr, (char *) session_key, CIFS_SESS_KEY_SIZE);
	bcc_ptr += CIFS_SESS_KEY_SIZE;

	if (ses->capabilities & CAP_UNICODE) {
		if ((long) bcc_ptr % 2) { /* must be word aligned for Unicode */
			*bcc_ptr = 0;
			bcc_ptr++;
		}
		if (user == NULL)
			bytes_returned = 0; /* skip null user */
		else
			bytes_returned =
				cifs_strtoUCS((__le16 *) bcc_ptr, user, 100,
					nls_codepage);
		/* convert number of 16 bit words to bytes */
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;	/* trailing null */
		if (domain == NULL)
			bytes_returned =
			    cifs_strtoUCS((__le16 *) bcc_ptr,
					  ""CIFS_LINUX_DOM"", 32, nls_codepage);
		else
			bytes_returned =
			    cifs_strtoUCS((__le16 *) bcc_ptr, domain, 64,
					  nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, ""Linux version "",
				  32, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, utsname()->release,
				  32, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,
				  64, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;
	} else {
		if (user != NULL) {
		    strncpy(bcc_ptr, user, 200);
		    bcc_ptr += strnlen(user, 200);
		}
		*bcc_ptr = 0;
		bcc_ptr++;
		if (domain == NULL) {
			strcpy(bcc_ptr, ""CIFS_LINUX_DOM"");
			bcc_ptr += strlen(""CIFS_LINUX_DOM"") + 1;
		} else {
			strncpy(bcc_ptr, domain, 64);
			bcc_ptr += strnlen(domain, 64);
			*bcc_ptr = 0;
			bcc_ptr++;
		}
		strcpy(bcc_ptr, ""Linux version "");
		bcc_ptr += strlen(""Linux version "");
		strcpy(bcc_ptr, utsname()->release);
		bcc_ptr += strlen(utsname()->release) + 1;
		strcpy(bcc_ptr, CIFS_NETWORK_OPSYS);
		bcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;
	}
	count = (long) bcc_ptr - (long) pByteArea(smb_buffer);
	smb_buffer->smb_buf_length += count;
	pSMB->req_no_secext.ByteCount = cpu_to_le16(count);

	rc = SendReceive(xid, ses, smb_buffer, smb_buffer_response,
			 &bytes_returned, CIFS_LONG_OP);
	if (rc) {
/* rc = map_smb_to_linux_error(smb_buffer_response); now done in SendReceive */
	} else if ((smb_buffer_response->WordCount == 3)
		   || (smb_buffer_response->WordCount == 4)) {
		__u16 action = le16_to_cpu(pSMBr->resp.Action);
		__u16 blob_len = le16_to_cpu(pSMBr->resp.SecurityBlobLength);
		if (action & GUEST_LOGIN)
			cFYI(1, (""Guest login"")); /* BB mark SesInfo struct? */
		ses->Suid = smb_buffer_response->Uid; /* UID left in wire format
							 (little endian) */
		cFYI(1, (""UID = %d "", ses->Suid));
	/* response can have either 3 or 4 word count - Samba sends 3 */
		bcc_ptr = pByteArea(smb_buffer_response);
		if ((pSMBr->resp.hdr.WordCount == 3)
		    || ((pSMBr->resp.hdr.WordCount == 4)
			&& (blob_len < pSMBr->resp.ByteCount))) {
			if (pSMBr->resp.hdr.WordCount == 4)
				bcc_ptr += blob_len;

			if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
				if ((long) (bcc_ptr) % 2) {
					remaining_words =
					    (BCC(smb_buffer_response) - 1) / 2;
					/* Unicode strings must be word
					   aligned */
					bcc_ptr++;
				} else {
					remaining_words =
						BCC(smb_buffer_response) / 2;
				}
				len =
				    UniStrnlen((wchar_t *) bcc_ptr,
					       remaining_words - 1);
/* We look for obvious messed up bcc or strings in response so we do not go off
   the end since (at least) WIN2K and Windows XP have a major bug in not null
   terminating last Unicode string in response  */
				kfree(ses->serverOS);
				ses->serverOS = kzalloc(2 * (len + 1),
							GFP_KERNEL);
				if (ses->serverOS == NULL)
					goto sesssetup_nomem;
				cifs_strfromUCS_le(ses->serverOS,
						   (__le16 *)bcc_ptr,
						   len, nls_codepage);
				bcc_ptr += 2 * (len + 1);
				remaining_words -= len + 1;
				ses->serverOS[2 * len] = 0;
				ses->serverOS[1 + (2 * len)] = 0;
				if (remaining_words > 0) {
					len = UniStrnlen((wchar_t *)bcc_ptr,
							 remaining_words-1);
					kfree(ses->serverNOS);
					ses->serverNOS = kzalloc(2 * (len + 1),
								 GFP_KERNEL);
					if (ses->serverNOS == NULL)
						goto sesssetup_nomem;
					cifs_strfromUCS_le(ses->serverNOS,
							   (__le16 *)bcc_ptr,
							   len, nls_codepage);
					bcc_ptr += 2 * (len + 1);
					ses->serverNOS[2 * len] = 0;
					ses->serverNOS[1 + (2 * len)] = 0;
					if (strncmp(ses->serverNOS,
						""NT LAN Manager 4"", 16) == 0) {
						cFYI(1, (""NT4 server""));
						ses->flags |= CIFS_SES_NT4;
					}
					remaining_words -= len + 1;
					if (remaining_words > 0) {
						len = UniStrnlen((wchar_t *) bcc_ptr, remaining_words);
				/* last string is not always null terminated
				   (for e.g. for Windows XP & 2000) */
						kfree(ses->serverDomain);
						ses->serverDomain =
						    kzalloc(2*(len+1),
							    GFP_KERNEL);
						if (ses->serverDomain == NULL)
							goto sesssetup_nomem;
						cifs_strfromUCS_le(ses->serverDomain,
							(__le16 *)bcc_ptr,
							len, nls_codepage);
						bcc_ptr += 2 * (len + 1);
						ses->serverDomain[2*len] = 0;
						ses->serverDomain[1+(2*len)] = 0;
					} else { /* else no more room so create
						  dummy domain string */
						kfree(ses->serverDomain);
						ses->serverDomain =
							kzalloc(2, GFP_KERNEL);
					}
				} else { /* no room so create dummy domain
					    and NOS string */

					/* if these kcallocs fail not much we
					   can do, but better to not fail the
					   sesssetup itself */
					kfree(ses->serverDomain);
					ses->serverDomain =
					    kzalloc(2, GFP_KERNEL);
					kfree(ses->serverNOS);
					ses->serverNOS =
					    kzalloc(2, GFP_KERNEL);
				}
			} else {	/* ASCII */
				len = strnlen(bcc_ptr, 1024);
				if (((long) bcc_ptr + len) - (long)
				    pByteArea(smb_buffer_response)
					    <= BCC(smb_buffer_response)) {
					kfree(ses->serverOS);
					ses->serverOS = kzalloc(len + 1,
								GFP_KERNEL);
					if (ses->serverOS == NULL)
						goto sesssetup_nomem;
					strncpy(ses->serverOS, bcc_ptr, len);

					bcc_ptr += len;
					/* null terminate the string */
					bcc_ptr[0] = 0;
					bcc_ptr++;

					len = strnlen(bcc_ptr, 1024);
					kfree(ses->serverNOS);
					ses->serverNOS = kzalloc(len + 1,
								 GFP_KERNEL);
					if (ses->serverNOS == NULL)
						goto sesssetup_nomem;
					strncpy(ses->serverNOS, bcc_ptr, len);
					bcc_ptr += len;
					bcc_ptr[0] = 0;
					bcc_ptr++;

					len = strnlen(bcc_ptr, 1024);
					kfree(ses->serverDomain);
					ses->serverDomain = kzalloc(len + 1,
								    GFP_KERNEL);
					if (ses->serverDomain == NULL)
						goto sesssetup_nomem;
					strncpy(ses->serverDomain, bcc_ptr,
						len);
					bcc_ptr += len;
					bcc_ptr[0] = 0;
					bcc_ptr++;
				} else
					cFYI(1,
					     (""Variable field of length %d ""
						""extends beyond end of smb "",
					      len));
			}
		} else {
			cERROR(1, (""Security Blob Length extends beyond ""
				""end of SMB""));
		}
	} else {
		cERROR(1, (""Invalid Word count %d: "",
			smb_buffer_response->WordCount));
		rc = -EIO;
	}
sesssetup_nomem:	/* do not return an error on nomem for the info strings,
			   since that could make reconnection harder, and
			   reconnection might be needed to free memory */
	cifs_buf_release(smb_buffer);

	return rc;
}

	/*	pSesInfo->sequence_number = 0;*/
	if (experimEnabled < 2)
		rc = CIFS_SessSetup(xid, pSesInfo, first_time, nls_info);
	else if (extended_security
			&& (pSesInfo->capabilities & CAP_EXTENDED_SECURITY)
			&& (server->secType == NTLMSSP)) {
		rc = -EOPNOTSUPP;
	} else if (extended_security
			&& (pSesInfo->capabilities & CAP_EXTENDED_SECURITY)
			&& (server->secType == RawNTLMSSP)) {
		cFYI(1, (""NTLMSSP sesssetup""));
		rc = CIFSNTLMSSPNegotiateSessSetup(xid, pSesInfo, &ntlmv2_flag,
						   nls_info);
		if (!rc) {
			if (ntlmv2_flag) {
				char *v2_response;
				cFYI(1, (""more secure NTLM ver2 hash""));
				if (CalcNTLMv2_partial_mac_key(pSesInfo,
								nls_info)) {
					rc = -ENOMEM;
					goto ss_err_exit;
				} else
					v2_response = kmalloc(16 + 64 /* blob*/,
								GFP_KERNEL);
				if (v2_response) {
					CalcNTLMv2_response(pSesInfo,
								v2_response);
				/*	if (first_time)
						cifs_calculate_ntlmv2_mac_key */
					kfree(v2_response);
					/* BB Put dummy sig in SessSetup PDU? */
				} else {
					rc = -ENOMEM;
					goto ss_err_exit;
				}

			} else {
				SMBNTencrypt(pSesInfo->password,
					     server->cryptKey,
					     ntlm_session_key);

				if (first_time)
					cifs_calculate_mac_key(
					     &server->mac_signing_key,
					     ntlm_session_key,
					     pSesInfo->password);
			}
			/* for better security the weaker lanman hash not sent
			   in AuthSessSetup so we no longer calculate it */

			rc = CIFSNTLMSSPAuthSessSetup(xid, pSesInfo,
						      ntlm_session_key,
						      ntlmv2_flag,
						      nls_info);
		}
	} else { /* old style NTLM 0.12 session setup */
		SMBNTencrypt(pSesInfo->password, server->cryptKey,
			     ntlm_session_key);

		if (first_time)
			cifs_calculate_mac_key(&server->mac_signing_key,
						ntlm_session_key,
						pSesInfo->password);

		rc = CIFSSessSetup(xid, pSesInfo, ntlm_session_key, nls_info);
	}
			spin_lock(&GlobalMid_Lock);
			pSesInfo->status = CifsGood;
			pSesInfo->need_reconnect = false;
			spin_unlock(&GlobalMid_Lock);",20418acd6874792359b42c12d159f42f17593f34,CVE-2009-1633,20418acd6874792359b42c12d159f42f17593f34,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,84,COMPLETED,"VAR = VAR(VAR, VAR, VAR, VAR); VAR(&VAR); VAR->VAR = VAR; VAR->VAR = VAR; VAR(&VAR); VAR VAR VAR(VAR VAR VAR, VAR VAR *VAR, VAR VAR[VAR], VAR VAR VAR *VAR) { VAR VAR *VAR; VAR VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR VAR; VAR VAR; VAR VAR; VAR(1, (""VAR VAR"")); VAR (VAR == VAR) VAR -VAR; VAR = VAR->VAR; VAR = VAR->VAR; VAR = VAR(); VAR (VAR == VAR) VAR -VAR; VAR = VAR; VAR = VAR = (VAR *) VAR;  VAR(VAR, VAR, VAR , 13 ); VAR->VAR = VAR(VAR->VAR); VAR->VAR.VAR = 0xFF; VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR (VAR->VAR->VAR & (VAR | VAR)) VAR->VAR |= VAR; VAR = VAR | VAR | VAR | VAR | VAR; VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR = VAR(VAR); VAR(VAR, (VAR *) VAR, VAR); VAR += VAR; VAR(VAR, (VAR *) VAR, VAR); VAR += VAR; VAR (VAR->VAR & VAR) { VAR ((VAR) VAR % 2) {  *VAR = 0; VAR++; } VAR (VAR == VAR) VAR = 0;  VAR VAR = VAR((VAR *) VAR, VAR, 100, VAR);  VAR += 2 * VAR; VAR += 2;  VAR (VAR == VAR) VAR = VAR((VAR *) VAR, ""VAR"", 32, VAR); VAR VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR += 2 * VAR; VAR += 2; VAR = VAR((VAR *) VAR, ""VAR VAR "", 32, VAR); VAR += 2 * VAR; VAR = VAR((VAR *) VAR, VAR()->VAR, 32, VAR); VAR += 2 * VAR; VAR += 2; VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR += 2 * VAR; VAR += 2; } VAR { VAR (VAR != VAR) { VAR(VAR, VAR, 200); VAR += VAR(VAR, 200); } *VAR = 0; VAR++; VAR (VAR == VAR) { VAR(VAR, ""VAR""); VAR += VAR(""VAR"") + 1; } VAR { VAR(VAR, VAR, 64); VAR += VAR(VAR, 64); *VAR = 0; VAR++; } VAR(VAR, ""VAR VAR ""); VAR += VAR(""VAR VAR ""); VAR(VAR, VAR()->VAR); VAR += VAR(VAR()->VAR) + 1; VAR(VAR, VAR); VAR += VAR(VAR) + 1; } VAR = (VAR) VAR - (VAR) VAR(VAR); VAR->VAR += VAR; VAR->VAR.VAR = VAR(VAR); VAR = VAR(VAR, VAR, VAR, VAR, &VAR, VAR); VAR (VAR) {  } VAR VAR ((VAR->VAR == 3) || (VAR->VAR == 4)) { VAR VAR = VAR(VAR->VAR.VAR); VAR VAR = VAR(VAR->VAR.VAR); VAR (VAR & VAR) VAR(1, (""VAR VAR""));  VAR->VAR = VAR->VAR; /* VAR VAR VAR VAR VAR (VAR VAR) */ VAR(1, (""VAR = %VAR "", VAR->VAR));  VAR = VAR(VAR); VAR ((VAR->VAR.VAR.VAR == 3) || ((VAR->VAR.VAR.VAR == 4) && (VAR < VAR->VAR.VAR))) { VAR (VAR->VAR.VAR.VAR == 4) VAR += VAR; VAR (VAR->VAR & VAR) { VAR ((VAR) (VAR) % 2) { VAR = (VAR(VAR) - 1) / 2; /* VAR VAR VAR VAR VAR VAR */ VAR++; } VAR { VAR = VAR(VAR) / 2; } VAR = VAR((VAR *) VAR, VAR - 1); /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR -= VAR + 1; VAR->VAR[2 * VAR] = 0; VAR->VAR[1 + (2 * VAR)] = 0; VAR (VAR > 0) { VAR = VAR((VAR *)VAR, VAR-1); VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR->VAR[2 * VAR] = 0; VAR->VAR[1 + (2 * VAR)] = 0; VAR (VAR(VAR->VAR, ""VAR VAR VAR 4"", 16) == 0) { VAR(1, (""VAR VAR"")); VAR->VAR |= VAR; } VAR -= VAR + 1; VAR (VAR > 0) { VAR = VAR((VAR *) VAR, VAR); /* VAR VAR VAR VAR VAR VAR VAR (VAR VAR.VAR. VAR VAR VAR & 2000) */ VAR(VAR->VAR); VAR->VAR = VAR(2*(VAR+1), VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR->VAR[2*VAR] = 0; VAR->VAR[1+(2*VAR)] = 0; } VAR { /* VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); } } VAR { /* VAR VAR VAR VAR VAR VAR VAR VAR VAR */ /* VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); } } VAR {  VAR = VAR(VAR, 1024); VAR (((VAR) VAR + VAR) - (VAR) VAR(VAR) <= VAR(VAR)) { VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, VAR, VAR); VAR += VAR;  VAR[0] = 0; VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; } VAR VAR(1, (""VAR VAR VAR VAR %VAR "" ""VAR VAR VAR VAR VAR "", VAR)); } } VAR { VAR(1, (""VAR VAR VAR VAR VAR "" ""VAR VAR VAR"")); } } VAR { VAR(1, (""VAR VAR VAR %VAR: "", VAR->VAR)); VAR = -VAR; } VAR: /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR); VAR VAR; }  VAR (VAR < 2) VAR = VAR(VAR, VAR, VAR, VAR); VAR VAR (VAR && (VAR->VAR & VAR) && (VAR->VAR == VAR)) { VAR = -VAR; } VAR VAR (VAR && (VAR->VAR & VAR) && (VAR->VAR == VAR)) { VAR(1, (""VAR VAR"")); VAR = VAR(VAR, VAR, &VAR, VAR); VAR (!VAR) { VAR (VAR) { VAR *VAR; VAR(1, (""VAR VAR VAR VAR VAR"")); VAR (VAR(VAR, VAR)) { VAR = -VAR; VAR VAR; } VAR VAR = VAR(16 + 64 , VAR); VAR (VAR) { VAR(VAR, VAR); /* VAR (VAR) VAR */ VAR(VAR);  } VAR { VAR = -VAR; VAR VAR; } } VAR { VAR(VAR->VAR, VAR->VAR, VAR); VAR (VAR) VAR( &VAR->VAR, VAR, VAR->VAR); } /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR = VAR(VAR, VAR, VAR, VAR, VAR); } } VAR {  VAR(VAR->VAR, VAR->VAR, VAR); VAR (VAR) VAR(&VAR->VAR, VAR, VAR->VAR); VAR = VAR(VAR, VAR, VAR, VAR); } VAR(&VAR); VAR->VAR = VAR; VAR->VAR = VAR; VAR(&VAR);",10
linux_2edd6c5b0517b9131ede9e74cb121898ccd73042,fs/cifs/connect.c,,"static int
CIFSNTLMSSPNegotiateSessSetup(unsigned int xid,
			      struct cifsSesInfo *ses, bool *pNTLMv2_flag,
			      const struct nls_table *nls_codepage)
{
	struct smb_hdr *smb_buffer;
	struct smb_hdr *smb_buffer_response;
	SESSION_SETUP_ANDX *pSMB;
	SESSION_SETUP_ANDX *pSMBr;
	char *bcc_ptr;
	char *domain;
	int rc = 0;
	int remaining_words = 0;
	int bytes_returned = 0;
	int len;
	int SecurityBlobLength = sizeof(NEGOTIATE_MESSAGE);
	PNEGOTIATE_MESSAGE SecurityBlob;
	PCHALLENGE_MESSAGE SecurityBlob2;
	__u32 negotiate_flags, capabilities;
	__u16 count;

	cFYI(1, (""In NTLMSSP sesssetup (negotiate)""));
	if (ses == NULL)
		return -EINVAL;
	domain = ses->domainName;
	*pNTLMv2_flag = false;
	smb_buffer = cifs_buf_get();
	if (smb_buffer == NULL) {
		return -ENOMEM;
	}
	smb_buffer_response = smb_buffer;
	pSMB = (SESSION_SETUP_ANDX *) smb_buffer;
	pSMBr = (SESSION_SETUP_ANDX *) smb_buffer_response;

	/* send SMBsessionSetup here */
	header_assemble(smb_buffer, SMB_COM_SESSION_SETUP_ANDX,
			NULL /* no tCon exists yet */ , 12 /* wct */ );

	smb_buffer->Mid = GetNextMid(ses->server);
	pSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;
	pSMB->req.hdr.Flags |= (SMBFLG_CASELESS | SMBFLG_CANONICAL_PATH_FORMAT);

	pSMB->req.AndXCommand = 0xFF;
	pSMB->req.MaxBufferSize = cpu_to_le16(ses->server->maxBuf);
	pSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);

	if (ses->server->secMode & (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))
		smb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;

	capabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |
	    CAP_EXTENDED_SECURITY;
	if (ses->capabilities & CAP_UNICODE) {
		smb_buffer->Flags2 |= SMBFLG2_UNICODE;
		capabilities |= CAP_UNICODE;
	}
	if (ses->capabilities & CAP_STATUS32) {
		smb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;
		capabilities |= CAP_STATUS32;
	}
	if (ses->capabilities & CAP_DFS) {
		smb_buffer->Flags2 |= SMBFLG2_DFS;
		capabilities |= CAP_DFS;
	}
	pSMB->req.Capabilities = cpu_to_le32(capabilities);

	bcc_ptr = (char *) &pSMB->req.SecurityBlob;
	SecurityBlob = (PNEGOTIATE_MESSAGE) bcc_ptr;
	strncpy(SecurityBlob->Signature, NTLMSSP_SIGNATURE, 8);
	SecurityBlob->MessageType = NtLmNegotiate;
	negotiate_flags =
	    NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_OEM |
	    NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_NTLM |
	    NTLMSSP_NEGOTIATE_56 |
	    /* NTLMSSP_NEGOTIATE_ALWAYS_SIGN | */ NTLMSSP_NEGOTIATE_128;
	if (sign_CIFS_PDUs)
		negotiate_flags |= NTLMSSP_NEGOTIATE_SIGN;
	/* setup pointers to domain name and workstation name */
	bcc_ptr += SecurityBlobLength;

	SecurityBlob->WorkstationName.BufferOffset = 0;
	SecurityBlob->WorkstationName.Length = 0;
	SecurityBlob->WorkstationName.MaximumLength = 0;

	/* Domain not sent on first Sesssetup in NTLMSSP, instead it is sent
	along with username on auth request (ie the response to challenge) */
	SecurityBlob->DomainName.BufferOffset = 0;
	SecurityBlob->DomainName.Length = 0;
	SecurityBlob->DomainName.MaximumLength = 0;
	if (ses->capabilities & CAP_UNICODE) {
		if ((long) bcc_ptr % 2) {
			*bcc_ptr = 0;
			bcc_ptr++;
		}

		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, ""Linux version "",
				  32, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, utsname()->release, 32,
				  nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;	/* null terminate Linux version */
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,
				  64, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		*(bcc_ptr + 1) = 0;
		*(bcc_ptr + 2) = 0;
		bcc_ptr += 2;	/* null terminate network opsys string */
		*(bcc_ptr + 1) = 0;
		*(bcc_ptr + 2) = 0;
		bcc_ptr += 2;	/* null domain */
	} else {		/* ASCII */
		strcpy(bcc_ptr, ""Linux version "");
		bcc_ptr += strlen(""Linux version "");
		strcpy(bcc_ptr, utsname()->release);
		bcc_ptr += strlen(utsname()->release) + 1;
		strcpy(bcc_ptr, CIFS_NETWORK_OPSYS);
		bcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;
		bcc_ptr++;	/* empty domain field */
		*bcc_ptr = 0;
	}
	SecurityBlob->NegotiateFlags = cpu_to_le32(negotiate_flags);
	pSMB->req.SecurityBlobLength = cpu_to_le16(SecurityBlobLength);
	count = (long) bcc_ptr - (long) pByteArea(smb_buffer);
	smb_buffer->smb_buf_length += count;
	pSMB->req.ByteCount = cpu_to_le16(count);

	rc = SendReceive(xid, ses, smb_buffer, smb_buffer_response,
			 &bytes_returned, CIFS_LONG_OP);

	if (smb_buffer_response->Status.CifsError ==
	    cpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))
		rc = 0;

	if (rc) {
/*    rc = map_smb_to_linux_error(smb_buffer_response);  *//* done in SendReceive now */
	} else if ((smb_buffer_response->WordCount == 3)
		   || (smb_buffer_response->WordCount == 4)) {
		__u16 action = le16_to_cpu(pSMBr->resp.Action);
		__u16 blob_len = le16_to_cpu(pSMBr->resp.SecurityBlobLength);

		if (action & GUEST_LOGIN)
			cFYI(1, (""Guest login""));
	/* Do we want to set anything in SesInfo struct when guest login? */

		bcc_ptr = pByteArea(smb_buffer_response);
	/* response can have either 3 or 4 word count - Samba sends 3 */

		SecurityBlob2 = (PCHALLENGE_MESSAGE) bcc_ptr;
		if (SecurityBlob2->MessageType != NtLmChallenge) {
			cFYI(1, (""Unexpected NTLMSSP message type received %d"",
			      SecurityBlob2->MessageType));
		} else if (ses) {
			ses->Suid = smb_buffer_response->Uid; /* UID left in le format */
			cFYI(1, (""UID = %d"", ses->Suid));
			if ((pSMBr->resp.hdr.WordCount == 3)
			    || ((pSMBr->resp.hdr.WordCount == 4)
				&& (blob_len <
				    pSMBr->resp.ByteCount))) {

				if (pSMBr->resp.hdr.WordCount == 4) {
					bcc_ptr += blob_len;
					cFYI(1, (""Security Blob Length %d"",
					      blob_len));
				}

				cFYI(1, (""NTLMSSP Challenge rcvd""));

				memcpy(ses->server->cryptKey,
				       SecurityBlob2->Challenge,
				       CIFS_CRYPTO_KEY_SIZE);
/* NTLMV2 flag is not for NTLMv2 password hash */
/*				if (SecurityBlob2->NegotiateFlags &
					cpu_to_le32(NTLMSSP_NEGOTIATE_NTLMV2))
					*pNTLMv2_flag = true; */ /* BB wrong */

				if ((SecurityBlob2->NegotiateFlags &
					cpu_to_le32(NTLMSSP_NEGOTIATE_ALWAYS_SIGN))
					|| (sign_CIFS_PDUs > 1))
						ses->server->secMode |=
							SECMODE_SIGN_REQUIRED;
				if ((SecurityBlob2->NegotiateFlags &
					cpu_to_le32(NTLMSSP_NEGOTIATE_SIGN)) && (sign_CIFS_PDUs))
						ses->server->secMode |=
							SECMODE_SIGN_ENABLED;

				if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
					if ((long) (bcc_ptr) % 2) {
						remaining_words =
						    (BCC(smb_buffer_response)
						     - 1) / 2;
					 /* Must word align unicode strings */
						bcc_ptr++;
					} else {
						remaining_words =
						    BCC
						    (smb_buffer_response) / 2;
					}
					len =
					    UniStrnlen((wchar_t *) bcc_ptr,
						       remaining_words - 1);
/* We look for obvious messed up bcc or strings in response so we do not go off
   the end since (at least) WIN2K and Windows XP have a major bug in not null
   terminating last Unicode string in response  */
					kfree(ses->serverOS);
					ses->serverOS =
					    kzalloc(2 * (len + 1), GFP_KERNEL);
					cifs_strfromUCS_le(ses->serverOS,
							   (__le16 *)
							   bcc_ptr, len,
							   nls_codepage);
					bcc_ptr += 2 * (len + 1);
					remaining_words -= len + 1;
					ses->serverOS[2 * len] = 0;
					ses->serverOS[1 + (2 * len)] = 0;
					if (remaining_words > 0) {
						len = UniStrnlen((wchar_t *)
								 bcc_ptr,
								 remaining_words
								 - 1);
						kfree(ses->serverNOS);
						ses->serverNOS =
						    kzalloc(2 * (len + 1),
							    GFP_KERNEL);
						cifs_strfromUCS_le(ses->
								   serverNOS,
								   (__le16 *)
								   bcc_ptr,
								   len,
								   nls_codepage);
						bcc_ptr += 2 * (len + 1);
						ses->serverNOS[2 * len] = 0;
						ses->serverNOS[1 +
							       (2 * len)] = 0;
						remaining_words -= len + 1;
						if (remaining_words > 0) {
							len = UniStrnlen((wchar_t *) bcc_ptr, remaining_words);
				/* last string not always null terminated
				   (for e.g. for Windows XP & 2000) */
							kfree(ses->serverDomain);
							ses->serverDomain =
							    kzalloc(2 *
								    (len +
								     1),
								    GFP_KERNEL);
							cifs_strfromUCS_le
							    (ses->serverDomain,
							     (__le16 *)bcc_ptr,
							     len, nls_codepage);
							bcc_ptr +=
							    2 * (len + 1);
							ses->serverDomain[2*len]
							    = 0;
							ses->serverDomain
								[1 + (2 * len)]
							    = 0;
						} /* else no more room so create dummy domain string */
						else {
							kfree(ses->serverDomain);
							ses->serverDomain =
							    kzalloc(2,
								    GFP_KERNEL);
						}
					} else {	/* no room so create dummy domain and NOS string */
						kfree(ses->serverDomain);
						ses->serverDomain =
						    kzalloc(2, GFP_KERNEL);
						kfree(ses->serverNOS);
						ses->serverNOS =
						    kzalloc(2, GFP_KERNEL);
					}
				} else {	/* ASCII */
					len = strnlen(bcc_ptr, 1024);
					if (((long) bcc_ptr + len) - (long)
					    pByteArea(smb_buffer_response)
					    <= BCC(smb_buffer_response)) {
						kfree(ses->serverOS);
						ses->serverOS =
						    kzalloc(len + 1,
							    GFP_KERNEL);
						strncpy(ses->serverOS,
							bcc_ptr, len);

						bcc_ptr += len;
						bcc_ptr[0] = 0;	/* null terminate string */
						bcc_ptr++;

						len = strnlen(bcc_ptr, 1024);
						kfree(ses->serverNOS);
						ses->serverNOS =
						    kzalloc(len + 1,
							    GFP_KERNEL);
						strncpy(ses->serverNOS, bcc_ptr, len);
						bcc_ptr += len;
						bcc_ptr[0] = 0;
						bcc_ptr++;

						len = strnlen(bcc_ptr, 1024);
						kfree(ses->serverDomain);
						ses->serverDomain =
						    kzalloc(len + 1,
							    GFP_KERNEL);
						strncpy(ses->serverDomain,
							bcc_ptr, len);
						bcc_ptr += len;
						bcc_ptr[0] = 0;
						bcc_ptr++;
					} else
						cFYI(1,
						     (""field of length %d ""
						    ""extends beyond end of smb"",
						      len));
				}
			} else {
				cERROR(1, (""Security Blob Length extends beyond""
					   "" end of SMB""));
			}
		} else {
			cERROR(1, (""No session structure passed in.""));
		}
	} else {
		cERROR(1, (""Invalid Word count %d:"",
			smb_buffer_response->WordCount));
		rc = -EIO;
	}

	cifs_buf_release(smb_buffer);

	return rc;
}

static int
CIFSNTLMSSPAuthSessSetup(unsigned int xid, struct cifsSesInfo *ses,
			char *ntlm_session_key, bool ntlmv2_flag,
			const struct nls_table *nls_codepage)
{
	struct smb_hdr *smb_buffer;
	struct smb_hdr *smb_buffer_response;
	SESSION_SETUP_ANDX *pSMB;
	SESSION_SETUP_ANDX *pSMBr;
	char *bcc_ptr;
	char *user;
	char *domain;
	int rc = 0;
	int remaining_words = 0;
	int bytes_returned = 0;
	int len;
	int SecurityBlobLength = sizeof(AUTHENTICATE_MESSAGE);
	PAUTHENTICATE_MESSAGE SecurityBlob;
	__u32 negotiate_flags, capabilities;
	__u16 count;

	cFYI(1, (""In NTLMSSPSessSetup (Authenticate)""));
	if (ses == NULL)
		return -EINVAL;
	user = ses->userName;
	domain = ses->domainName;
	smb_buffer = cifs_buf_get();
	if (smb_buffer == NULL) {
		return -ENOMEM;
	}
	smb_buffer_response = smb_buffer;
	pSMB = (SESSION_SETUP_ANDX *)smb_buffer;
	pSMBr = (SESSION_SETUP_ANDX *)smb_buffer_response;

	/* send SMBsessionSetup here */
	header_assemble(smb_buffer, SMB_COM_SESSION_SETUP_ANDX,
			NULL /* no tCon exists yet */ , 12 /* wct */ );

	smb_buffer->Mid = GetNextMid(ses->server);
	pSMB->req.hdr.Flags |= (SMBFLG_CASELESS | SMBFLG_CANONICAL_PATH_FORMAT);
	pSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;
	pSMB->req.AndXCommand = 0xFF;
	pSMB->req.MaxBufferSize = cpu_to_le16(ses->server->maxBuf);
	pSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);

	pSMB->req.hdr.Uid = ses->Suid;

	if (ses->server->secMode & (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))
		smb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;

	capabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |
			CAP_EXTENDED_SECURITY;
	if (ses->capabilities & CAP_UNICODE) {
		smb_buffer->Flags2 |= SMBFLG2_UNICODE;
		capabilities |= CAP_UNICODE;
	}
	if (ses->capabilities & CAP_STATUS32) {
		smb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;
		capabilities |= CAP_STATUS32;
	}
	if (ses->capabilities & CAP_DFS) {
		smb_buffer->Flags2 |= SMBFLG2_DFS;
		capabilities |= CAP_DFS;
	}
	pSMB->req.Capabilities = cpu_to_le32(capabilities);

	bcc_ptr = (char *)&pSMB->req.SecurityBlob;
	SecurityBlob = (PAUTHENTICATE_MESSAGE)bcc_ptr;
	strncpy(SecurityBlob->Signature, NTLMSSP_SIGNATURE, 8);
	SecurityBlob->MessageType = NtLmAuthenticate;
	bcc_ptr += SecurityBlobLength;
	negotiate_flags = NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_REQUEST_TARGET |
			NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_TARGET_INFO |
			NTLMSSP_NEGOTIATE_56 | NTLMSSP_NEGOTIATE_128 |
			NTLMSSP_NEGOTIATE_EXTENDED_SEC;
	if (sign_CIFS_PDUs)
		negotiate_flags |= /* NTLMSSP_NEGOTIATE_ALWAYS_SIGN |*/ NTLMSSP_NEGOTIATE_SIGN;

/* setup pointers to domain name and workstation name */

	SecurityBlob->WorkstationName.BufferOffset = 0;
	SecurityBlob->WorkstationName.Length = 0;
	SecurityBlob->WorkstationName.MaximumLength = 0;
	SecurityBlob->SessionKey.Length = 0;
	SecurityBlob->SessionKey.MaximumLength = 0;
	SecurityBlob->SessionKey.BufferOffset = 0;

	SecurityBlob->LmChallengeResponse.Length = 0;
	SecurityBlob->LmChallengeResponse.MaximumLength = 0;
	SecurityBlob->LmChallengeResponse.BufferOffset = 0;

	SecurityBlob->NtChallengeResponse.Length =
	    cpu_to_le16(CIFS_SESS_KEY_SIZE);
	SecurityBlob->NtChallengeResponse.MaximumLength =
	    cpu_to_le16(CIFS_SESS_KEY_SIZE);
	memcpy(bcc_ptr, ntlm_session_key, CIFS_SESS_KEY_SIZE);
	SecurityBlob->NtChallengeResponse.BufferOffset =
	    cpu_to_le32(SecurityBlobLength);
	SecurityBlobLength += CIFS_SESS_KEY_SIZE;
	bcc_ptr += CIFS_SESS_KEY_SIZE;

	if (ses->capabilities & CAP_UNICODE) {
		if (domain == NULL) {
			SecurityBlob->DomainName.BufferOffset = 0;
			SecurityBlob->DomainName.Length = 0;
			SecurityBlob->DomainName.MaximumLength = 0;
		} else {
			__u16 ln = cifs_strtoUCS((__le16 *) bcc_ptr, domain, 64,
					  nls_codepage);
			ln *= 2;
			SecurityBlob->DomainName.MaximumLength =
			    cpu_to_le16(ln);
			SecurityBlob->DomainName.BufferOffset =
			    cpu_to_le32(SecurityBlobLength);
			bcc_ptr += ln;
			SecurityBlobLength += ln;
			SecurityBlob->DomainName.Length = cpu_to_le16(ln);
		}
		if (user == NULL) {
			SecurityBlob->UserName.BufferOffset = 0;
			SecurityBlob->UserName.Length = 0;
			SecurityBlob->UserName.MaximumLength = 0;
		} else {
			__u16 ln = cifs_strtoUCS((__le16 *) bcc_ptr, user, 64,
					  nls_codepage);
			ln *= 2;
			SecurityBlob->UserName.MaximumLength =
			    cpu_to_le16(ln);
			SecurityBlob->UserName.BufferOffset =
			    cpu_to_le32(SecurityBlobLength);
			bcc_ptr += ln;
			SecurityBlobLength += ln;
			SecurityBlob->UserName.Length = cpu_to_le16(ln);
		}

		/* SecurityBlob->WorkstationName.Length =
		 cifs_strtoUCS((__le16 *) bcc_ptr, ""AMACHINE"",64, nls_codepage);
		   SecurityBlob->WorkstationName.Length *= 2;
		   SecurityBlob->WorkstationName.MaximumLength =
			cpu_to_le16(SecurityBlob->WorkstationName.Length);
		   SecurityBlob->WorkstationName.BufferOffset =
				 cpu_to_le32(SecurityBlobLength);
		   bcc_ptr += SecurityBlob->WorkstationName.Length;
		   SecurityBlobLength += SecurityBlob->WorkstationName.Length;
		   SecurityBlob->WorkstationName.Length =
			cpu_to_le16(SecurityBlob->WorkstationName.Length);  */

		if ((long) bcc_ptr % 2) {
			*bcc_ptr = 0;
			bcc_ptr++;
		}
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, ""Linux version "",
				  32, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, utsname()->release, 32,
				  nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;	/* null term version string */
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,
				  64, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		*(bcc_ptr + 1) = 0;
		*(bcc_ptr + 2) = 0;
		bcc_ptr += 2;	/* null terminate network opsys string */
		*(bcc_ptr + 1) = 0;
		*(bcc_ptr + 2) = 0;
		bcc_ptr += 2;	/* null domain */
	} else {		/* ASCII */
		if (domain == NULL) {
			SecurityBlob->DomainName.BufferOffset = 0;
			SecurityBlob->DomainName.Length = 0;
			SecurityBlob->DomainName.MaximumLength = 0;
		} else {
			__u16 ln;
			negotiate_flags |= NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED;
			strncpy(bcc_ptr, domain, 63);
			ln = strnlen(domain, 64);
			SecurityBlob->DomainName.MaximumLength =
			    cpu_to_le16(ln);
			SecurityBlob->DomainName.BufferOffset =
			    cpu_to_le32(SecurityBlobLength);
			bcc_ptr += ln;
			SecurityBlobLength += ln;
			SecurityBlob->DomainName.Length = cpu_to_le16(ln);
		}
		if (user == NULL) {
			SecurityBlob->UserName.BufferOffset = 0;
			SecurityBlob->UserName.Length = 0;
			SecurityBlob->UserName.MaximumLength = 0;
		} else {
			__u16 ln;
			strncpy(bcc_ptr, user, 63);
			ln = strnlen(user, 64);
			SecurityBlob->UserName.MaximumLength = cpu_to_le16(ln);
			SecurityBlob->UserName.BufferOffset =
						cpu_to_le32(SecurityBlobLength);
			bcc_ptr += ln;
			SecurityBlobLength += ln;
			SecurityBlob->UserName.Length = cpu_to_le16(ln);
		}
		/* BB fill in our workstation name if known BB */

		strcpy(bcc_ptr, ""Linux version "");
		bcc_ptr += strlen(""Linux version "");
		strcpy(bcc_ptr, utsname()->release);
		bcc_ptr += strlen(utsname()->release) + 1;
		strcpy(bcc_ptr, CIFS_NETWORK_OPSYS);
		bcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;
		bcc_ptr++;	/* null domain */
		*bcc_ptr = 0;
	}
	SecurityBlob->NegotiateFlags = cpu_to_le32(negotiate_flags);
	pSMB->req.SecurityBlobLength = cpu_to_le16(SecurityBlobLength);
	count = (long) bcc_ptr - (long) pByteArea(smb_buffer);
	smb_buffer->smb_buf_length += count;
	pSMB->req.ByteCount = cpu_to_le16(count);

	rc = SendReceive(xid, ses, smb_buffer, smb_buffer_response,
			 &bytes_returned, CIFS_LONG_OP);
	if (rc) {
/*   rc = map_smb_to_linux_error(smb_buffer_response) done in SendReceive now */
	} else if ((smb_buffer_response->WordCount == 3) ||
		   (smb_buffer_response->WordCount == 4)) {
		__u16 action = le16_to_cpu(pSMBr->resp.Action);
		__u16 blob_len = le16_to_cpu(pSMBr->resp.SecurityBlobLength);
		if (action & GUEST_LOGIN)
			cFYI(1, (""Guest login"")); /* BB Should we set anything
							 in SesInfo struct ? */
/*		if (SecurityBlob2->MessageType != NtLm??) {
			cFYI(""Unexpected message type on auth response is %d""));
		} */

		if (ses) {
			cFYI(1,
			     (""Check challenge UID %d vs auth response UID %d"",
			      ses->Suid, smb_buffer_response->Uid));
			/* UID left in wire format */
			ses->Suid = smb_buffer_response->Uid;
			bcc_ptr = pByteArea(smb_buffer_response);
		/* response can have either 3 or 4 word count - Samba sends 3 */
			if ((pSMBr->resp.hdr.WordCount == 3)
			    || ((pSMBr->resp.hdr.WordCount == 4)
				&& (blob_len <
				    pSMBr->resp.ByteCount))) {
				if (pSMBr->resp.hdr.WordCount == 4) {
					bcc_ptr +=
					    blob_len;
					cFYI(1,
					     (""Security Blob Length %d "",
					      blob_len));
				}

				cFYI(1,
				     (""NTLMSSP response to Authenticate ""));

				if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
					if ((long) (bcc_ptr) % 2) {
						remaining_words =
						    (BCC(smb_buffer_response)
						     - 1) / 2;
						bcc_ptr++;	/* Unicode strings must be word aligned */
					} else {
						remaining_words = BCC(smb_buffer_response) / 2;
					}
					len = UniStrnlen((wchar_t *) bcc_ptr,
							remaining_words - 1);
/* We look for obvious messed up bcc or strings in response so we do not go off
  the end since (at least) WIN2K and Windows XP have a major bug in not null
  terminating last Unicode string in response  */
					kfree(ses->serverOS);
					ses->serverOS =
					    kzalloc(2 * (len + 1), GFP_KERNEL);
					cifs_strfromUCS_le(ses->serverOS,
							   (__le16 *)
							   bcc_ptr, len,
							   nls_codepage);
					bcc_ptr += 2 * (len + 1);
					remaining_words -= len + 1;
					ses->serverOS[2 * len] = 0;
					ses->serverOS[1 + (2 * len)] = 0;
					if (remaining_words > 0) {
						len = UniStrnlen((wchar_t *)
								 bcc_ptr,
								 remaining_words
								 - 1);
						kfree(ses->serverNOS);
						ses->serverNOS =
						    kzalloc(2 * (len + 1),
							    GFP_KERNEL);
						cifs_strfromUCS_le(ses->
								   serverNOS,
								   (__le16 *)
								   bcc_ptr,
								   len,
								   nls_codepage);
						bcc_ptr += 2 * (len + 1);
						ses->serverNOS[2 * len] = 0;
						ses->serverNOS[1+(2*len)] = 0;
						remaining_words -= len + 1;
						if (remaining_words > 0) {
							len = UniStrnlen((wchar_t *) bcc_ptr, remaining_words);
     /* last string not always null terminated (e.g. for Windows XP & 2000) */
							kfree(ses->serverDomain);
							ses->serverDomain =
							    kzalloc(2 *
								    (len +
								     1),
								    GFP_KERNEL);
							cifs_strfromUCS_le
							    (ses->
							     serverDomain,
							     (__le16 *)
							     bcc_ptr, len,
							     nls_codepage);
							bcc_ptr +=
							    2 * (len + 1);
							ses->
							    serverDomain[2
									 * len]
							    = 0;
							ses->
							    serverDomain[1
									 +
									 (2
									  *
									  len)]
							    = 0;
						} /* else no more room so create dummy domain string */
						else {
							kfree(ses->serverDomain);
							ses->serverDomain = kzalloc(2,GFP_KERNEL);
						}
					} else {  /* no room so create dummy domain and NOS string */
						kfree(ses->serverDomain);
						ses->serverDomain = kzalloc(2, GFP_KERNEL);
						kfree(ses->serverNOS);
						ses->serverNOS = kzalloc(2, GFP_KERNEL);
					}
				} else {	/* ASCII */
					len = strnlen(bcc_ptr, 1024);
					if (((long) bcc_ptr + len) -
					   (long) pByteArea(smb_buffer_response)
						<= BCC(smb_buffer_response)) {
						kfree(ses->serverOS);
						ses->serverOS = kzalloc(len + 1, GFP_KERNEL);
						strncpy(ses->serverOS,bcc_ptr, len);

						bcc_ptr += len;
						bcc_ptr[0] = 0;	/* null terminate the string */
						bcc_ptr++;

						len = strnlen(bcc_ptr, 1024);
						kfree(ses->serverNOS);
						ses->serverNOS = kzalloc(len+1,
								    GFP_KERNEL);
						strncpy(ses->serverNOS,
							bcc_ptr, len);
						bcc_ptr += len;
						bcc_ptr[0] = 0;
						bcc_ptr++;

						len = strnlen(bcc_ptr, 1024);
						kfree(ses->serverDomain);
						ses->serverDomain =
								kzalloc(len+1,
								    GFP_KERNEL);
						strncpy(ses->serverDomain,
							bcc_ptr, len);
						bcc_ptr += len;
						bcc_ptr[0] = 0;
						bcc_ptr++;
					} else
						cFYI(1, (""field of length %d ""
						   ""extends beyond end of smb "",
						      len));
				}
			} else {
				cERROR(1, (""Security Blob extends beyond end ""
					""of SMB""));
			}
		} else {
			cERROR(1, (""No session structure passed in.""));
		}
	} else {
		cERROR(1, (""Invalid Word count %d: "",
			smb_buffer_response->WordCount));
		rc = -EIO;
	}

	cifs_buf_release(smb_buffer);

	return rc;
}
",2edd6c5b0517b9131ede9e74cb121898ccd73042,CVE-2009-1633,2edd6c5b0517b9131ede9e74cb121898ccd73042,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,80,COMPLETED," VAR VAR VAR(VAR VAR VAR, VAR VAR *VAR, VAR *VAR, VAR VAR VAR *VAR) { VAR VAR *VAR; VAR VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR VAR; VAR VAR = VAR(VAR); VAR VAR; VAR VAR; VAR VAR, VAR; VAR VAR; VAR(1, (""VAR VAR VAR (VAR)"")); VAR (VAR == VAR) VAR -VAR; VAR = VAR->VAR; *VAR = VAR; VAR = VAR(); VAR (VAR == VAR) { VAR -VAR; } VAR = VAR; VAR = (VAR *) VAR; VAR = (VAR *) VAR;  VAR(VAR, VAR, VAR , 12 ); VAR->VAR = VAR(VAR->VAR); VAR->VAR.VAR.VAR |= VAR; VAR->VAR.VAR.VAR |= (VAR | VAR); VAR->VAR.VAR = 0xFF; VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR (VAR->VAR->VAR & (VAR | VAR)) VAR->VAR |= VAR; VAR = VAR | VAR | VAR | VAR; VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR->VAR.VAR = VAR(VAR); VAR = (VAR *) &VAR->VAR.VAR; VAR = (VAR) VAR; VAR(VAR->VAR, VAR, 8); VAR->VAR = VAR; VAR = VAR | VAR | VAR | VAR | VAR |  VAR; VAR (VAR) VAR |= VAR;  VAR += VAR; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; /* VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR VAR VAR VAR VAR) */ VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR (VAR->VAR & VAR) { VAR ((VAR) VAR % 2) { *VAR = 0; VAR++; } VAR = VAR((VAR *) VAR, ""VAR VAR "", 32, VAR); VAR += 2 * VAR; VAR = VAR((VAR *) VAR, VAR()->VAR, 32, VAR); VAR += 2 * VAR; VAR += 2;  VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR += 2 * VAR; *(VAR + 1) = 0; *(VAR + 2) = 0; VAR += 2;  *(VAR + 1) = 0; *(VAR + 2) = 0; VAR += 2;  } VAR {  VAR(VAR, ""VAR VAR ""); VAR += VAR(""VAR VAR ""); VAR(VAR, VAR()->VAR); VAR += VAR(VAR()->VAR) + 1; VAR(VAR, VAR); VAR += VAR(VAR) + 1; VAR++;  *VAR = 0; } VAR->VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR = (VAR) VAR - (VAR) VAR(VAR); VAR->VAR += VAR; VAR->VAR.VAR = VAR(VAR); VAR = VAR(VAR, VAR, VAR, VAR, &VAR, VAR); VAR (VAR->VAR.VAR == VAR(VAR)) VAR = 0; VAR (VAR) { /* VAR = VAR(VAR); * } VAR VAR ((VAR->VAR == 3) || (VAR->VAR == 4)) { VAR VAR = VAR(VAR->VAR.VAR); VAR VAR = VAR(VAR->VAR.VAR); VAR (VAR & VAR) VAR(1, (""VAR VAR""));  VAR = VAR(VAR);  VAR = (VAR) VAR; VAR (VAR->VAR != VAR) { VAR(1, (""VAR VAR VAR VAR VAR %VAR"", VAR->VAR)); } VAR VAR (VAR) { VAR->VAR = VAR->VAR;  VAR(1, (""VAR = %VAR"", VAR->VAR)); VAR ((VAR->VAR.VAR.VAR == 3) || ((VAR->VAR.VAR.VAR == 4) && (VAR < VAR->VAR.VAR))) { VAR (VAR->VAR.VAR.VAR == 4) { VAR += VAR; VAR(1, (""VAR VAR VAR %VAR"", VAR)); } VAR(1, (""VAR VAR VAR"")); VAR(VAR->VAR->VAR, VAR->VAR, VAR);  /* VAR (VAR->VAR & VAR(VAR)) *VAR = VAR; */  VAR ((VAR->VAR & VAR(VAR)) || (VAR > 1)) VAR->VAR->VAR |= VAR; VAR ((VAR->VAR & VAR(VAR)) && (VAR)) VAR->VAR->VAR |= VAR; VAR (VAR->VAR & VAR) { VAR ((VAR) (VAR) % 2) { VAR = (VAR(VAR) - 1) / 2;  VAR++; } VAR { VAR = VAR (VAR) / 2; } VAR = VAR((VAR *) VAR, VAR - 1); /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR(VAR->VAR, (VAR *) VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR -= VAR + 1; VAR->VAR[2 * VAR] = 0; VAR->VAR[1 + (2 * VAR)] = 0; VAR (VAR > 0) { VAR = VAR((VAR *) VAR, VAR - 1); VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR(VAR-> VAR, (VAR *) VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR->VAR[2 * VAR] = 0; VAR->VAR[1 + (2 * VAR)] = 0; VAR -= VAR + 1; VAR (VAR > 0) { VAR = VAR((VAR *) VAR, VAR); /* VAR VAR VAR VAR VAR VAR (VAR VAR.VAR. VAR VAR VAR & 2000) */ VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR (VAR->VAR, (VAR *)VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR->VAR[2*VAR] = 0; VAR->VAR [1 + (2 * VAR)] = 0; }  VAR { VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); } } VAR {  VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); } } VAR {  VAR = VAR(VAR, 1024); VAR (((VAR) VAR + VAR) - (VAR) VAR(VAR) <= VAR(VAR)) { VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0;  VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; } VAR VAR(1, (""VAR VAR VAR %VAR "" ""VAR VAR VAR VAR VAR"", VAR)); } } VAR { VAR(1, (""VAR VAR VAR VAR VAR"" "" VAR VAR VAR"")); } } VAR { VAR(1, (""VAR VAR VAR VAR VAR."")); } } VAR { VAR(1, (""VAR VAR VAR %VAR:"", VAR->VAR)); VAR = -VAR; } VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR VAR, VAR VAR *VAR, VAR *VAR, VAR VAR, VAR VAR VAR *VAR) { VAR VAR *VAR; VAR VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR VAR; VAR VAR = VAR(VAR); VAR VAR; VAR VAR, VAR; VAR VAR; VAR(1, (""VAR VAR (VAR)"")); VAR (VAR == VAR) VAR -VAR; VAR = VAR->VAR; VAR = VAR->VAR; VAR = VAR(); VAR (VAR == VAR) { VAR -VAR; } VAR = VAR; VAR = (VAR *)VAR; VAR = (VAR *)VAR;  VAR(VAR, VAR, VAR , 12 ); VAR->VAR = VAR(VAR->VAR); VAR->VAR.VAR.VAR |= (VAR | VAR); VAR->VAR.VAR.VAR |= VAR; VAR->VAR.VAR = 0xFF; VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR->VAR.VAR.VAR = VAR->VAR; VAR (VAR->VAR->VAR & (VAR | VAR)) VAR->VAR |= VAR; VAR = VAR | VAR | VAR | VAR; VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR->VAR.VAR = VAR(VAR); VAR = (VAR *)&VAR->VAR.VAR; VAR = (VAR)VAR; VAR(VAR->VAR, VAR, 8); VAR->VAR = VAR; VAR += VAR; VAR = VAR | VAR | VAR | VAR | VAR | VAR | VAR; VAR (VAR) VAR |= VAR;  VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR(VAR, VAR, VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR; VAR += VAR; VAR (VAR->VAR & VAR) { VAR (VAR == VAR) { VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; } VAR { VAR VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR *= 2; VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR; VAR += VAR; VAR->VAR.VAR = VAR(VAR); } VAR (VAR == VAR) { VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; } VAR { VAR VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR *= 2; VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR; VAR += VAR; VAR->VAR.VAR = VAR(VAR); } /* VAR->VAR.VAR = VAR((VAR *) VAR, ""VAR"",64, VAR); VAR->VAR.VAR *= 2; VAR->VAR.VAR = VAR(VAR->VAR.VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR->VAR.VAR; VAR += VAR->VAR.VAR; VAR->VAR.VAR = VAR(VAR->VAR.VAR); */ VAR ((VAR) VAR % 2) { *VAR = 0; VAR++; } VAR = VAR((VAR *) VAR, ""VAR VAR "", 32, VAR); VAR += 2 * VAR; VAR = VAR((VAR *) VAR, VAR()->VAR, 32, VAR); VAR += 2 * VAR; VAR += 2;  VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR += 2 * VAR; *(VAR + 1) = 0; *(VAR + 2) = 0; VAR += 2;  *(VAR + 1) = 0; *(VAR + 2) = 0; VAR += 2;  } VAR {  VAR (VAR == VAR) { VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; } VAR { VAR VAR; VAR |= VAR; VAR(VAR, VAR, 63); VAR = VAR(VAR, 64); VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR; VAR += VAR; VAR->VAR.VAR = VAR(VAR); } VAR (VAR == VAR) { VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; } VAR { VAR VAR; VAR(VAR, VAR, 63); VAR = VAR(VAR, 64); VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR; VAR += VAR; VAR->VAR.VAR = VAR(VAR); }  VAR(VAR, ""VAR VAR ""); VAR += VAR(""VAR VAR ""); VAR(VAR, VAR()->VAR); VAR += VAR(VAR()->VAR) + 1; VAR(VAR, VAR); VAR += VAR(VAR) + 1; VAR++;  *VAR = 0; } VAR->VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR = (VAR) VAR - (VAR) VAR(VAR); VAR->VAR += VAR; VAR->VAR.VAR = VAR(VAR); VAR = VAR(VAR, VAR, VAR, VAR, &VAR, VAR); VAR (VAR) {  } VAR VAR ((VAR->VAR == 3) || (VAR->VAR == 4)) { VAR VAR = VAR(VAR->VAR.VAR); VAR VAR = VAR(VAR->VAR.VAR); VAR (VAR & VAR) VAR(1, (""VAR VAR"")); /* VAR VAR VAR VAR VAR VAR VAR VAR ? */ /* VAR (VAR->VAR != VAR??) { VAR(""VAR VAR VAR VAR VAR VAR VAR %VAR"")); } */ VAR (VAR) { VAR(1, (""VAR VAR VAR %VAR VAR VAR VAR VAR %VAR"", VAR->VAR, VAR->VAR));  VAR->VAR = VAR->VAR; VAR = VAR(VAR);  VAR ((VAR->VAR.VAR.VAR == 3) || ((VAR->VAR.VAR.VAR == 4) && (VAR < VAR->VAR.VAR))) { VAR (VAR->VAR.VAR.VAR == 4) { VAR += VAR; VAR(1, (""VAR VAR VAR %VAR "", VAR)); } VAR(1, (""VAR VAR VAR VAR "")); VAR (VAR->VAR & VAR) { VAR ((VAR) (VAR) % 2) { VAR = (VAR(VAR) - 1) / 2; VAR++;  } VAR { VAR = VAR(VAR) / 2; } VAR = VAR((VAR *) VAR, VAR - 1); /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR(VAR->VAR, (VAR *) VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR -= VAR + 1; VAR->VAR[2 * VAR] = 0; VAR->VAR[1 + (2 * VAR)] = 0; VAR (VAR > 0) { VAR = VAR((VAR *) VAR, VAR - 1); VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR(VAR-> VAR, (VAR *) VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR->VAR[2 * VAR] = 0; VAR->VAR[1+(2*VAR)] = 0; VAR -= VAR + 1; VAR (VAR > 0) { VAR = VAR((VAR *) VAR, VAR);  VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR (VAR-> VAR, (VAR *) VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR-> VAR[2 * VAR] = 0; VAR-> VAR[1 + (2 * VAR)] = 0; }  VAR { VAR(VAR->VAR); VAR->VAR = VAR(2,VAR); } } VAR {  VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); } } VAR {  VAR = VAR(VAR, 1024); VAR (((VAR) VAR + VAR) - (VAR) VAR(VAR) <= VAR(VAR)) { VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR(VAR->VAR,VAR, VAR); VAR += VAR; VAR[0] = 0;  VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR+1, VAR); VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR+1, VAR); VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; } VAR VAR(1, (""VAR VAR VAR %VAR "" ""VAR VAR VAR VAR VAR "", VAR)); } } VAR { VAR(1, (""VAR VAR VAR VAR VAR "" ""VAR VAR"")); } } VAR { VAR(1, (""VAR VAR VAR VAR VAR."")); } } VAR { VAR(1, (""VAR VAR VAR %VAR: "", VAR->VAR)); VAR = -VAR; } VAR(VAR); VAR VAR; }",10
linux_394f56fe480140877304d342dec46d50dc823d46,arch/x86/vdso/vma.c,"/*
 * Put the vdso above the (randomized) stack with another randomized
 * offset.  This way there is no hole in the middle of address space.
 * To save memory make sure it is still in the same PTE as the stack
 * top.  This doesn't give that many random bits.
 *
 * Note that this algorithm is imperfect: the distribution of the vdso
 * start address within a PMD is biased toward the end.
 *
 * Only used for the 64-bit and x32 vdsos.
 */

	/*
	 * Round up the start address.  It can start out unaligned as a result
	 * of stack start randomization.
	 */
	start = PAGE_ALIGN(start);

	/* Round the lowest possible end address up to a PMD boundary. */
	end = (start + len + PMD_SIZE - 1) & PMD_MASK;

	if (end > start) {
		offset = get_random_int() % (((end - start) >> PAGE_SHIFT) + 1);
		addr = start + (offset << PAGE_SHIFT);
	} else {
		addr = start;
	}
	 * Forcibly align the final address in case we have a hardware
	 * issue that requires alignment for performance reasons.","/* Put the vdso above the (randomized) stack with another randomized offset.
   This way there is no hole in the middle of address space.
   To save memory make sure it is still in the same PTE as the stack top.
   This doesn't give that many random bits.

   Only used for the 64-bit and x32 vdsos. */
	end = (start + PMD_SIZE - 1) & PMD_MASK;
	/* This loses some more bits than a modulo, but is cheaper */
	offset = get_random_int() & (PTRS_PER_PTE - 1);
	addr = start + (offset << PAGE_SHIFT);
	if (addr >= end)
		addr = end;
	 * page-align it here so that get_unmapped_area doesn't
	 * align it wrongfully again to the next page. addr can come in 4K
	 * unaligned here as a result of stack start randomization.
	addr = PAGE_ALIGN(addr);",394f56fe480140877304d342dec46d50dc823d46,CVE-2014-9585,394f56fe480140877304d342dec46d50dc823d46,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,/* * VAR VAR VAR VAR VAR (VAR) VAR VAR VAR VAR * VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. VAR VAR'VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR 64-VAR VAR VAR VAR. */ /* * VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR. */ VAR = VAR(VAR);  VAR = (VAR + VAR + VAR - 1) & VAR; VAR (VAR > VAR) { VAR = VAR() % (((VAR - VAR) >> VAR) + 1); VAR = VAR + (VAR << VAR); } VAR { VAR = VAR; } * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR. /* VAR VAR VAR VAR VAR (VAR) VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR'VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR 64-VAR VAR VAR VAR. */ VAR = (VAR + VAR - 1) & VAR;  VAR = VAR() & (VAR - 1); VAR = VAR + (VAR << VAR); VAR (VAR >= VAR) VAR = VAR; * VAR-VAR VAR VAR VAR VAR VAR VAR'VAR * VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR 4K * VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR = VAR(VAR);,10
linux_4180bf1b655a791a0a6ef93a2ffffc762722c782,Documentation/virtual/kvm/hypercalls.txt,"
6. KVM_HC_SEND_IPI
------------------------
Architecture: x86
Status: active
Purpose: Send IPIs to multiple vCPUs.

a0: lower part of the bitmap of destination APIC IDs
a1: higher part of the bitmap of destination APIC IDs
a2: the lowest APIC ID in bitmap
a3: APIC ICR

The hypercall lets a guest send multicast IPIs, with at most 128
128 destinations per hypercall in 64-bit mode and 64 vCPUs per
hypercall in 32-bit mode.  The destinations are represented by a
bitmap contained in the first two arguments (a0 and a1). Bit 0 of
a0 corresponds to the APIC ID in the third argument (a2), bit 1
corresponds to the APIC ID a2+1, and so on.

Returns the number of CPUs to which the IPIs were delivered successfully.",,4180bf1b655a791a0a6ef93a2ffffc762722c782,CVE-2018-19406,4180bf1b655a791a0a6ef93a2ffffc762722c782,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,"6. VAR ------------------------ VAR: VAR VAR: VAR VAR: VAR VAR VAR VAR VAR. VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR 128 128 VAR VAR VAR VAR 64-VAR VAR VAR 64 VAR VAR VAR VAR 32-VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR VAR VAR). VAR 0 VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR), VAR 1 VAR VAR VAR VAR VAR VAR+1, VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ",10
linux_4180bf1b655a791a0a6ef93a2ffffc762722c782,arch/x86/kvm/lapic.c,"int kvm_pv_send_ipi(struct kvm *kvm, unsigned long ipi_bitmap_low,
    		    unsigned long ipi_bitmap_high, int min,
		    unsigned long icr, int op_64_bit)
{
	int i;
	struct kvm_apic_map *map;
	struct kvm_vcpu *vcpu;
	struct kvm_lapic_irq irq = {0};
	int cluster_size = op_64_bit ? 64 : 32;
	int count = 0;

	irq.vector = icr & APIC_VECTOR_MASK;
	irq.delivery_mode = icr & APIC_MODE_MASK;
	irq.level = (icr & APIC_INT_ASSERT) != 0;
	irq.trig_mode = icr & APIC_INT_LEVELTRIG;

	if (icr & APIC_DEST_MASK)
		return -KVM_EINVAL;
	if (icr & APIC_SHORT_MASK)
		return -KVM_EINVAL;

	rcu_read_lock();
	map = rcu_dereference(kvm->arch.apic_map);

	/* Bits above cluster_size are masked in the caller.  */
	for_each_set_bit(i, &ipi_bitmap_low, BITS_PER_LONG) {
		vcpu = map->phys_map[min + i]->vcpu;
		count += kvm_apic_set_irq(vcpu, &irq, NULL);
	}

	min += cluster_size;
	for_each_set_bit(i, &ipi_bitmap_high, BITS_PER_LONG) {
		vcpu = map->phys_map[min + i]->vcpu;
		count += kvm_apic_set_irq(vcpu, &irq, NULL);
	}

	rcu_read_unlock();
	return count;
}
",,4180bf1b655a791a0a6ef93a2ffffc762722c782,CVE-2018-19406,4180bf1b655a791a0a6ef93a2ffffc762722c782,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,"VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR VAR, VAR VAR, VAR VAR VAR, VAR VAR) { VAR VAR; VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR = {0}; VAR VAR = VAR ? 64 : 32; VAR VAR = 0; VAR.VAR = VAR & VAR; VAR.VAR = VAR & VAR; VAR.VAR = (VAR & VAR) != 0; VAR.VAR = VAR & VAR; VAR (VAR & VAR) VAR -VAR; VAR (VAR & VAR) VAR -VAR; VAR(); VAR = VAR(VAR->VAR.VAR);  VAR(VAR, &VAR, VAR) { VAR = VAR->VAR[VAR + VAR]->VAR; VAR += VAR(VAR, &VAR, VAR); } VAR += VAR; VAR(VAR, &VAR, VAR) { VAR = VAR->VAR[VAR + VAR]->VAR; VAR += VAR(VAR, &VAR, VAR); } VAR(); VAR VAR; } ",10
linux_4cf949c7fafe21e085a4ee386bb2dade9067316e,drivers/gpu/drm/vmwgfx/vmwgfx_kms.c,"	    box->d != 1    || box_count != 1 ||
	    box->w > 64 || box->h > 64) {",	    box->d != 1    || box_count != 1) {,4cf949c7fafe21e085a4ee386bb2dade9067316e,CVE-2022-36280,4cf949c7fafe21e085a4ee386bb2dade9067316e,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,72,COMPLETED,VAR->VAR != 1 || VAR != 1 || VAR->VAR > 64 || VAR->VAR > 64) { VAR->VAR != 1 || VAR != 1) {,10
linux_59089d8d162ddcb5c434672e915331964d38a754,include/linux/ethtool.h," * Portions Copyright (C) Sun Microsystems 2008
/* The following structures are for supporting RX network flow
 * classification configuration. Note, all multibyte fields, e.g.,
 * ip4src, ip4dst, psrc, pdst, spi, etc. are expected to be in network
 * byte order.
 */
struct ethtool_tcpip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__be16	psrc;
	__be16	pdst;
	__u8    tos;
};

struct ethtool_ah_espip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__be32	spi;
	__u8    tos;
};

struct ethtool_rawip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__u8	hdata[64];
};

struct ethtool_ether_spec {
	__be16	ether_type;
	__u8	frame_size;
	__u8	eframe[16];
};

#define	ETH_RX_NFC_IP4	1
#define	ETH_RX_NFC_IP6	2

struct ethtool_usrip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__be32	l4_4_bytes;
	__u8    tos;
	__u8    ip_ver;
	__u8    proto;
};

struct ethtool_rx_flow_spec {
	union {
		struct ethtool_tcpip4_spec		tcp_ip4_spec;
		struct ethtool_tcpip4_spec		udp_ip4_spec;
		struct ethtool_tcpip4_spec		sctp_ip4_spec;
		struct ethtool_ah_espip4_spec		ah_ip4_spec;
		struct ethtool_ah_espip4_spec		esp_ip4_spec;
		struct ethtool_rawip4_spec		raw_ip4_spec;
		struct ethtool_ether_spec		ether_spec;
		struct ethtool_usrip4_spec		usr_ip4_spec;
		__u8					hdata[64];
	} h_u, m_u; /* entry, mask */
	__u64		ring_cookie;
	__u32		location;
};

struct ethtool_rxnfc {
	__u32				cmd;
	__u32				flow_type;
	/* The rx flow hash value or the rule DB size */
	__u64				data;
	struct ethtool_rx_flow_spec	fs;
	__u32				rule_cnt;
	__u32				rule_locs[0];
	int	(*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, void *);
	int	(*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
#define	ETHTOOL_GRXRINGS	0x0000002d /* Get RX rings available for LB */
#define	ETHTOOL_GRXCLSRLCNT	0x0000002e /* Get RX class rule count */
#define	ETHTOOL_GRXCLSRULE	0x0000002f /* Get RX classification rule */
#define	ETHTOOL_GRXCLSRLALL	0x00000030 /* Get all RX classification rule */
#define	ETHTOOL_SRXCLSRLDEL	0x00000031 /* Delete RX classification rule */
#define	ETHTOOL_SRXCLSRLINS	0x00000032 /* Insert RX classification rule */
#define	AH_V4_FLOW	0x09
#define	ESP_V4_FLOW	0x0a
#define	AH_V6_FLOW	0x0b
#define	ESP_V6_FLOW	0x0c
#define	IP_USER_FLOW	0x0d
#define	RX_CLS_FLOW_DISC	0xffffffffffffffffULL","struct ethtool_rxnfc {
	__u32		cmd;
	__u64		data;
	int	(*get_rxhash)(struct net_device *, struct ethtool_rxnfc *);
	int	(*set_rxhash)(struct net_device *, struct ethtool_rxnfc *);
#define	RXH_DEV_PORT	(1 << 0)",59089d8d162ddcb5c434672e915331964d38a754,CVE-2010-2478,59089d8d162ddcb5c434672e915331964d38a754,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,"* VAR VAR (VAR) VAR VAR 2008 /* VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. VAR, VAR VAR VAR, VAR.VAR., * VAR, VAR, VAR, VAR, VAR, VAR. VAR VAR VAR VAR VAR VAR * VAR VAR. */ VAR VAR { VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR { VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR { VAR VAR; VAR VAR; VAR VAR[64]; }; VAR VAR { VAR VAR; VAR VAR; VAR VAR[16]; };   VAR VAR { VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR { VAR { VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR[64]; } VAR, VAR;  VAR VAR; VAR VAR; }; VAR VAR { VAR VAR; VAR VAR;  VAR VAR; VAR VAR VAR; VAR VAR; VAR VAR[0]; VAR (*VAR)(VAR VAR *, VAR VAR *, VAR *); VAR (*VAR)(VAR VAR *, VAR VAR *);             VAR VAR { VAR VAR; VAR VAR; VAR (*VAR)(VAR VAR *, VAR VAR *); VAR (*VAR)(VAR VAR *, VAR VAR *); ",10
linux_5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,fs/9p/v9fs_vfs.h,"/* flags for v9fs_stat2inode() & v9fs_stat2inode_dotl() */
#define V9FS_STAT2INODE_KEEP_ISIZE 1

void v9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,
		      struct super_block *sb, unsigned int flags);
void v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode,
			   unsigned int flags);

static inline void v9fs_i_size_write(struct inode *inode, loff_t i_size)
{
	/*
	 * 32-bit need the lock, concurrent updates could break the
	 * sequences and make i_size_read() loop forever.
	 * 64-bit updates are atomic and can skip the locking.
	 */
	if (sizeof(i_size) > sizeof(long))
		spin_lock(&inode->i_lock);
	i_size_write(inode, i_size);
	if (sizeof(i_size) > sizeof(long))
		spin_unlock(&inode->i_lock);
}","void v9fs_stat2inode(struct p9_wstat *, struct inode *, struct super_block *);
void v9fs_stat2inode_dotl(struct p9_stat_dotl *, struct inode *);",5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,CVE-2019-16413,5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,86,COMPLETED,"  VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR VAR); VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR VAR); VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR) { /* * 32-VAR VAR VAR VAR, VAR VAR VAR VAR VAR * VAR VAR VAR VAR() VAR VAR. * 64-VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR (VAR(VAR) > VAR(VAR)) VAR(&VAR->VAR); VAR(VAR, VAR); VAR (VAR(VAR) > VAR(VAR)) VAR(&VAR->VAR); } VAR VAR(VAR VAR *, VAR VAR *, VAR VAR *); VAR VAR(VAR VAR *, VAR VAR *);",10
linux_721151d004dcf01a71b12bb6b893f9160284cf6e,arch/powerpc/mm/hash_low_64.S,"	andis.	r0,r31,_PAGE_4K_PFN@h
	srdi	r5,r31,PTE_RPN_SHIFT
	bne-	htab_special_pfn
htab_special_pfn:","	rldicl	r5,r31,64-PTE_RPN_SHIFT,PTE_RPN_SHIFT",721151d004dcf01a71b12bb6b893f9160284cf6e,CVE-2007-3850,721151d004dcf01a71b12bb6b893f9160284cf6e,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,84,COMPLETED,"VAR. VAR,VAR,VAR@VAR VAR VAR,VAR,VAR VAR- VAR VAR: VAR VAR,VAR,64-VAR,VAR",10
linux_7a1abd08d52fdeddb3e9a5a33f2f15cc6a5674d2,net/ipv4/tcp.c,		if (val < 64 || val > MAX_TCP_WINDOW) {,		if (val < 8 || val > MAX_TCP_WINDOW) {,7a1abd08d52fdeddb3e9a5a33f2f15cc6a5674d2,CVE-2010-4165,7a1abd08d52fdeddb3e9a5a33f2f15cc6a5674d2,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,VAR (VAR < 64 || VAR > VAR) { VAR (VAR < 8 || VAR > VAR) {,10
linux_844817e47eef14141cf59b8d5ac08dd11c0a9189,drivers/hid/hid-picolcd_core.c,"	if (size > 64) {
		hid_warn(hdev, ""invalid size value (%d) for picolcd raw event\n"",
				size);
		return 0;
	}
",,844817e47eef14141cf59b8d5ac08dd11c0a9189,CVE-2014-3186,844817e47eef14141cf59b8d5ac08dd11c0a9189,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR (VAR > 64) { VAR(VAR, ""VAR VAR VAR (%VAR) VAR VAR VAR VAR\VAR"", VAR); VAR 0; } ",10
linux_854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,arch/x86/kvm/x86.c,"	switch (msr->index) {
	case MSR_FS_BASE:
	case MSR_GS_BASE:
	case MSR_KERNEL_GS_BASE:
	case MSR_CSTAR:
	case MSR_LSTAR:
		if (is_noncanonical_address(msr->data))
			return 1;
		break;
	case MSR_IA32_SYSENTER_EIP:
	case MSR_IA32_SYSENTER_ESP:
		/*
		 * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if
		 * non-canonical address is written on Intel but not on
		 * AMD (which ignores the top 32-bits, because it does
		 * not implement 64-bit SYSENTER).
		 *
		 * 64-bit code should hence be able to write a non-canonical
		 * value on AMD.  Making the address canonical ensures that
		 * vmentry does not fail on Intel after writing a non-canonical
		 * value, and that something deterministic happens if the guest
		 * invokes 64-bit SYSENTER.
		 */
		msr->data = get_canonical(msr->data);
	}
EXPORT_SYMBOL_GPL(kvm_set_msr);",,854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,CVE-2014-3610,854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR (VAR->VAR) { VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR (VAR(VAR->VAR)) VAR 1; VAR; VAR VAR: VAR VAR: /* * VAR VAR VAR VAR  * VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR (VAR VAR VAR VAR 32-VAR, VAR VAR VAR * VAR VAR 64-VAR VAR). * * 64-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR * VAR VAR VAR. VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR * VAR, VAR VAR VAR VAR VAR VAR VAR VAR * VAR 64-VAR VAR. */ VAR->VAR = VAR(VAR->VAR); } VAR(VAR); ",10
linux_ad67b74d2469d9b82aaa572d76474c95bc484d57,Documentation/printk-formats.txt,"Pointer Types
=============

Pointers printed without a specifier extension (i.e unadorned %p) are
hashed to give a unique identifier without leaking kernel addresses to user
space. On 64 bit machines the first 32 bits are zeroed.

::

	%p	abcdef12 or 00000000abcdef12
",,ad67b74d2469d9b82aaa572d76474c95bc484d57,CVE-2018-5995,ad67b74d2469d9b82aaa572d76474c95bc484d57,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,76,COMPLETED,VAR VAR ============= VAR VAR VAR VAR VAR VAR (VAR.VAR VAR %VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR 64 VAR VAR VAR VAR 32 VAR VAR VAR. :: %VAR VAR VAR 00000000abcdef12 ,10
linux_ad67b74d2469d9b82aaa572d76474c95bc484d57,Documentation/printk-formats.txt,"Pointer Types
=============

Pointers printed without a specifier extension (i.e unadorned %p) are
hashed to give a unique identifier without leaking kernel addresses to user
space. On 64 bit machines the first 32 bits are zeroed.

::

	%p	abcdef12 or 00000000abcdef12
",,ad67b74d2469d9b82aaa572d76474c95bc484d57,CVE-2018-5953,ad67b74d2469d9b82aaa572d76474c95bc484d57,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,76,COMPLETED,VAR VAR ============= VAR VAR VAR VAR VAR VAR (VAR.VAR VAR %VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR 64 VAR VAR VAR VAR 32 VAR VAR VAR. :: %VAR VAR VAR 00000000abcdef12 ,10
linux_ad67b74d2469d9b82aaa572d76474c95bc484d57,Documentation/printk-formats.txt,"Pointer Types
=============

Pointers printed without a specifier extension (i.e unadorned %p) are
hashed to give a unique identifier without leaking kernel addresses to user
space. On 64 bit machines the first 32 bits are zeroed.

::

	%p	abcdef12 or 00000000abcdef12
",,ad67b74d2469d9b82aaa572d76474c95bc484d57,CVE-2018-7754,ad67b74d2469d9b82aaa572d76474c95bc484d57,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,72,COMPLETED,VAR VAR ============= VAR VAR VAR VAR VAR VAR (VAR.VAR VAR %VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR 64 VAR VAR VAR VAR 32 VAR VAR VAR. :: %VAR VAR VAR 00000000abcdef12 ,10
linux_cea4dcfdad926a27a18e188720efe0f2c9403456,drivers/target/iscsi/iscsi_target_parameters.h,"#include <scsi/iscsi_proto.h>

	char key[KEY_MAXLEN];",	char key[64];,cea4dcfdad926a27a18e188720efe0f2c9403456,CVE-2013-2850,cea4dcfdad926a27a18e188720efe0f2c9403456,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED, VAR VAR[VAR]; VAR VAR[64];,10
linux_e572ff80f05c33cd0cb4860f864f5c9c044280b6,kernel/bpf/verifier.c,"static bool __reg32_bound_s64(s32 a)
{
	return a >= 0 && a <= S32_MAX;
}


	/* Attempt to pull 32-bit signed bounds into 64-bit bounds but must
	 * be positive otherwise set to worse case bounds and refine later
	 * from tnum.
	if (__reg32_bound_s64(reg->s32_min_value) &&
	    __reg32_bound_s64(reg->s32_max_value)) {
		reg->smax_value = reg->s32_max_value;
	} else {
		reg->smax_value = U32_MAX;
	}","	/* Attempt to pull 32-bit signed bounds into 64-bit bounds
	 * but must be positive otherwise set to worse case bounds
	 * and refine later from tnum.
	if (reg->s32_min_value >= 0 && reg->s32_max_value >= 0)
		reg->smax_value = reg->s32_max_value;
	else
		reg->smax_value = U32_MAX;
	if (reg->s32_min_value >= 0)
	else",e572ff80f05c33cd0cb4860f864f5c9c044280b6,CVE-2021-45402,e572ff80f05c33cd0cb4860f864f5c9c044280b6,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,80,COMPLETED,VAR VAR VAR(VAR VAR) { VAR VAR >= 0 && VAR <= VAR; } /* VAR VAR VAR 32-VAR VAR VAR VAR 64-VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. VAR (VAR(VAR->VAR) && VAR(VAR->VAR)) { VAR->VAR = VAR->VAR; } VAR { VAR->VAR = VAR; } /* VAR VAR VAR 32-VAR VAR VAR VAR 64-VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR (VAR->VAR >= 0 && VAR->VAR >= 0) VAR->VAR = VAR->VAR; VAR VAR->VAR = VAR; VAR (VAR->VAR >= 0) VAR,10
linux_ea8c66fe8d8f4f93df941e52120a3512d7bf5128,arch/x86/kvm/hyperv.c,"	u64 valid_bank_mask;
		if (hc->var_cnt != bitmap_weight((unsigned long *)&valid_bank_mask, 64))","	unsigned long valid_bank_mask;
		if (hc->var_cnt != bitmap_weight(&valid_bank_mask, 64))",ea8c66fe8d8f4f93df941e52120a3512d7bf5128,CVE-2022-1789,ea8c66fe8d8f4f93df941e52120a3512d7bf5128,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,70,COMPLETED,"VAR VAR; VAR (VAR->VAR != VAR((VAR VAR *)&VAR, 64)) VAR VAR VAR; VAR (VAR->VAR != VAR(&VAR, 64))",10
openssl_8aed2a7548362e88e84a7feb795a3a97e8395008,crypto/ec/ec_lcl.h,"
	BN_MONT_CTX *mont_data;    /* data for ECDSA inverse */
int ec_precompute_mont_data(EC_GROUP *);

#ifdef ECP_NISTZ256_ASM
/** Returns GFp methods using montgomery multiplication, with x86-64 optimized
 * P256. See http://eprint.iacr.org/2013/816.
 *  \return  EC_METHOD object
 */
const EC_METHOD *EC_GFp_nistz256_method(void);
#endif",,8aed2a7548362e88e84a7feb795a3a97e8395008,CVE-2016-7056,8aed2a7548362e88e84a7feb795a3a97e8395008,https://github.com/openssl/openssl,CPE_GIT_REPOBASED,90,COMPLETED,"VAR *VAR;  VAR VAR(VAR *);  /** VAR VAR VAR VAR VAR VAR, VAR VAR-64 VAR * VAR. VAR VAR: * \VAR VAR VAR */ VAR VAR *VAR(VAR);  ",10
openssl_b15a19c148384e73338aa7c5b12652138e35ed28,Makefile.shared,"    LIBDEPS=$${LIBDEPS:-'$(LIBDEPS)'}; \
    LDCMD=$${LDCMD:-'$(CC)'}; LDFLAGS=$${LDFLAGS:-'$(CFLAGS) $(LDFLAGS)'}; \
    eval ""$${LDCMD} $${LDFLAGS} -o $${APPNAME:=$(APPNAME)} $(OBJECTS) $${LIBDEPS}"" )
    LIBDEPS=$${LIBDEPS:-'$(LIBDEPS)'}; \
    SHAREDCMD=$${SHAREDCMD:-'$(CC)'}; \
    SHAREDFLAGS=$${SHAREDFLAGS:-'$(CFLAGS) $(SHARED_LDFLAGS)'}; \
    eval ""$${SHAREDCMD} $${SHAREDFLAGS} \
	$$ALLSYMSFLAGS $$SHOBJECTS $$NOALLSYMSFLAGS $$LIBDEPS"" \
		if [ -n '$(SHLIBNAME_FULL)' -a -n '$(SHLIBNAME)' -a \
		     '$(SHLIBNAME_FULL)' != '$(SHLIBNAME)' ]; then \
LINK_SO_SHLIB=	SHOBJECTS='$(STLIBNAME) $(LIBEXTRAS)'; $(LINK_SO)
LINK_SO_DSO=	INHIBIT_SYMLINKS=yes; SHOBJECTS='$(LIBEXTRAS)'; $(LINK_SO)
  ([ -z '$(LIBEXTRAS)' ] || cp $(LIBEXTRAS) $$UNPACKDIR) && \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-Bsymbolic -Wl,-soname=$(SHLIBNAME_FULL)'
DO_GNU_APP=LDFLAGS='$(CFLAGS) $(LDFLAGS)'
	LIBDEPS=' '; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -nostdlib'; \
	LIBDEPS=' '; \
	ALLSYMSFLAGS='-Wl,-Bforcearchive'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -nostdlib'; \
	LDFLAGS='$(CFLAGS) $(LDFLAGS)'; \
	SHAREDFLAGS='$(CFLAGS) '""`echo '$(SHARED_LDFLAGS)' | sed s/dynamiclib/bundle/`""; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -current_version $(SHLIBVERSION) -compatibility_version $(SHLIBVERSION) -install_name $(INSTALLTOP)/$(LIBDIR)/$(SHLIBNAME_FULL)'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS)'"" -shared $$base -Wl,-Bsymbolic""; \
	echo '$(PERL) $(SRCDIR)/util/mkrc.pl $(SHLIBNAME_FULL) |' \
		     '$(RC) $(SHARED_RCFLAGS) -o rc.o'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,--enable-auto-image-base -Wl,-Bsymbolic -Wl,--out-implib,$(SHLIBNAME) rc.o'; \
	base=; [ '$(LIBNAME)' = 'crypto' -a -n '$(FIPSCANLIB)' ] && base=-Wl,--image-base,0x63000000; \
	echo '$(PERL) $(SRCDIR)/util/mkrc.pl $(SHLIBNAME_FULL) |' \
		'$(RC) $(SHARED_RCFLAGS) -o rc.o'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared '""$$base""' -Wl,-Bsymbolic -Wl,--out-implib,$(SHLIBNAME) $(LIBNAME).def rc.o'; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-B,symbolic'; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-B,symbolic -set_version $(SHLIBVERSION)'; \
		LDFLAGS='$(CFLAGS) $(LDFLAGS)'; \
		ALLSYMSFLAGS=''; \
		NOALLSYMSFLAGS=''; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -h $(SHLIBNAME_FULL) -Wl,-Bsymbolic'; \
		ALLSYMSFLAGS='-Wl,-z,allextract,-M,$(LIBNAME).map'; \
		NOALLSYMSFLAGS='-Wl,-z,defaultextract'; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -h $(SHLIBNAME_FULL) -Wl,-Bsymbolic'; \
		LDFLAGS='$(CFLAGS) $(LDFLAGS)'; \
		SHAREDFLAGS='$(CFLAGS) -G -h $(SHLIBNAME_FULL)'; \
		SHAREDFLAGS='$(CFLAGS) -G -h $(SHLIBNAME_FULL)'; \
		SHAREDFLAGS='$(CFLAGS) '""$${SHARE_FLAG}""' -h $(SHLIBNAME_FULL)'; \
		SHAREDFLAGS='$(CFLAGS) '""$${SHARE_FLAG}""' -h $(SHLIBNAME_FULL)'; \
		ALLSYMSFLAGS=''; \
		NOALLSYMSFLAGS=''; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname,$(SHLIBNAME_FULL),-B,symbolic'; \
		MINUSWL=''; \
		($(CC) -v 2>&1 | grep gcc) > /dev/null && MINUSWL='-Wl,'; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname,$(SHLIBNAME_FULL),-B,symbolic'; \
	@LDFLAGS='$(CFLAGS) $(LDFLAGS)'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-B,symbolic,+vnocompatwarnings,-z,+s,+h,$(SHLIBNAME_FULL),+cdp,../:,+cdp,./:'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-B,symbolic,+vnocompatwarnings,-z,+s,+h,$(SHLIBNAME_FULL),+cdp,../:,+cdp,./:'; \
	LDFLAGS='$(CFLAGS) $(LDFLAGS) -Wl,+s,+cdp,../:,+cdp,./:'; \
	@OBJECT_MODE=`expr 'x$(SHARED_LDFLAGS)' : 'x\-[a-z]*\(64\)'` || :; \
	@ OBJECT_MODE=`expr 'x$(SHARED_LDFLAGS)' : 'x\-[a-z]*\(64\)'` || : ; \
	LDFLAGS='$(CFLAGS) -Wl,-bsvr4 $(LDFLAGS)'; \","    LIBDEPS=""$${LIBDEPS:-$(LIBDEPS)}""; \
    LDCMD=""$${LDCMD:-$(CC)}""; LDFLAGS=""$${LDFLAGS:-$(CFLAGS) $(LDFLAGS)}""; \
    $${LDCMD} $${LDFLAGS} -o $${APPNAME:=$(APPNAME)} $(OBJECTS) $${LIBDEPS} )
    LIBDEPS=""$${LIBDEPS:-$(LIBDEPS)}""; \
    SHAREDCMD=""$${SHAREDCMD:-$(CC)}""; \
    SHAREDFLAGS=""$${SHAREDFLAGS:-$(CFLAGS) $(SHARED_LDFLAGS)}""; \
    $${SHAREDCMD} $${SHAREDFLAGS} \
	$$ALLSYMSFLAGS $$SHOBJECTS $$NOALLSYMSFLAGS $$LIBDEPS \
		if [ -n ""$(SHLIBNAME_FULL)"" -a -n ""$(SHLIBNAME)"" -a \
		     ""$(SHLIBNAME_FULL)"" != ""$(SHLIBNAME)"" ]; then \
LINK_SO_SHLIB=	SHOBJECTS=""$(STLIBNAME) $(LIBEXTRAS)""; $(LINK_SO)
LINK_SO_DSO=	INHIBIT_SYMLINKS=yes; SHOBJECTS=""$(LIBEXTRAS)""; $(LINK_SO)
  ([ -z ""$(LIBEXTRAS)"" ] || cp $(LIBEXTRAS) $$UNPACKDIR) && \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-Bsymbolic -Wl,-soname=$(SHLIBNAME_FULL)""
DO_GNU_APP=LDFLAGS=""$(CFLAGS) $(LDFLAGS)""
	LIBDEPS="" ""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -nostdlib""; \
	LIBDEPS="" ""; \
	ALLSYMSFLAGS=""-Wl,-Bforcearchive""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -nostdlib""; \
	LDFLAGS=""$(CFLAGS) $(LDFLAGS)""; \
	SHAREDFLAGS=""$(CFLAGS) `echo $(SHARED_LDFLAGS) | sed s/dynamiclib/bundle/`""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -current_version $(SHLIBVERSION) -compatibility_version $(SHLIBVERSION) -install_name $(INSTALLTOP)/$(LIBDIR)/$(SHLIBNAME_FULL)""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared $$base -Wl,-Bsymbolic""; \
	echo ""$(PERL) $(SRCDIR)/util/mkrc.pl $(SHLIBNAME_FULL) |"" \
		     ""$(RC) $(SHARED_RCFLAGS) -o rc.o""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,--enable-auto-image-base -Wl,-Bsymbolic -Wl,--out-implib,$(SHLIBNAME) rc.o""; \
	base=; [ $(LIBNAME) = ""crypto"" -a -n ""$(FIPSCANLIB)"" ] && base=-Wl,--image-base,0x63000000; \
	echo ""$(PERL) $(SRCDIR)/util/mkrc.pl $(SHLIBNAME_FULL) |"" \
		""$(RC) $(SHARED_RCFLAGS) -o rc.o""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared $$base -Wl,-Bsymbolic -Wl,--out-implib,$(SHLIBNAME) $(LIBNAME).def rc.o""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-B,symbolic""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-B,symbolic -set_version $(SHLIBVERSION)""; \
		LDFLAGS=""$(CFLAGS) $(LDFLAGS)""; \
		ALLSYMSFLAGS=""""; \
		NOALLSYMSFLAGS=""""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -h $(SHLIBNAME_FULL) -Wl,-Bsymbolic""; \
		ALLSYMSFLAGS=""-Wl,-z,allextract,-M,$(LIBNAME).map""; \
		NOALLSYMSFLAGS=""-Wl,-z,defaultextract""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -h $(SHLIBNAME_FULL) -Wl,-Bsymbolic""; \
		LDFLAGS=""$(CFLAGS) $(LDFLAGS)""; \
		SHAREDFLAGS=""$(CFLAGS) -G -h $(SHLIBNAME_FULL)""; \
		SHAREDFLAGS=""$(CFLAGS) -G -h $(SHLIBNAME_FULL)""; \
		SHAREDFLAGS=""$(CFLAGS) $${SHARE_FLAG} -h $(SHLIBNAME_FULL)""; \
		SHAREDFLAGS=""$(CFLAGS) $${SHARE_FLAG} -h $(SHLIBNAME_FULL)""; \
		ALLSYMSFLAGS=""""; \
		NOALLSYMSFLAGS=""""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname,$(SHLIBNAME_FULL),-B,symbolic""; \
		MINUSWL=""""; \
		($(CC) -v 2>&1 | grep gcc) > /dev/null && MINUSWL=""-Wl,""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname,$(SHLIBNAME_FULL),-B,symbolic""; \
	@LDFLAGS=""$(CFLAGS) $(LDFLAGS)""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-B,symbolic,+vnocompatwarnings,-z,+s,+h,$(SHLIBNAME_FULL),+cdp,../:,+cdp,./:""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-B,symbolic,+vnocompatwarnings,-z,+s,+h,$(SHLIBNAME_FULL),+cdp,../:,+cdp,./:""; \
	LDFLAGS=""$(CFLAGS) $(LDFLAGS) -Wl,+s,+cdp,../:,+cdp,./:""; \
	@OBJECT_MODE=`expr ""x$(SHARED_LDFLAGS)"" : 'x\-[a-z]*\(64\)'` || :; \
	@ OBJECT_MODE=`expr ""x$(SHARED_LDFLAGS)"" : 'x\-[a-z]*\(64\)'` || : ; \
	LDFLAGS=""$(CFLAGS) -Wl,-bsvr4 $(LDFLAGS)""; \",b15a19c148384e73338aa7c5b12652138e35ed28,CVE-2019-1552,b15a19c148384e73338aa7c5b12652138e35ed28,https://github.com/openssl/openssl,CPE_GIT_REPOBASED,144,COMPLETED,"VAR=$${VAR:-'$(VAR)'}; \ VAR=$${VAR:-'$(VAR)'}; VAR=$${VAR:-'$(VAR) $(VAR)'}; \ VAR ""$${VAR} $${VAR} -VAR $${VAR:=$(VAR)} $(VAR) $${VAR}"" ) VAR=$${VAR:-'$(VAR)'}; \ VAR=$${VAR:-'$(VAR)'}; \ VAR=$${VAR:-'$(VAR) $(VAR)'}; \ VAR ""$${VAR} $${VAR} \ $$VAR $$VAR $$VAR $$VAR"" \ VAR [ -VAR '$(VAR)' -VAR -VAR '$(VAR)' -VAR \ '$(VAR)' != '$(VAR)' ]; VAR \ VAR= VAR='$(VAR) $(VAR)'; $(VAR) VAR= VAR=VAR; VAR='$(VAR)'; $(VAR) ([ -VAR '$(VAR)' ] || VAR $(VAR) $$VAR) && \ VAR='$(VAR) $(VAR) -VAR -VAR,-VAR -VAR,-VAR=$(VAR)' VAR=VAR='$(VAR) $(VAR)' VAR=' '; \ VAR='$(VAR) $(VAR) -VAR -VAR'; \ VAR=' '; \ VAR='-VAR,-VAR'; \ VAR='$(VAR) $(VAR) -VAR -VAR'; \ VAR='$(VAR) $(VAR)'; \ VAR='$(VAR) '""`VAR '$(VAR)' | VAR VAR/VAR/VAR/`""; \ VAR='$(VAR) $(VAR) -VAR $(VAR) -VAR $(VAR) -VAR $(VAR)/$(VAR)/$(VAR)'; \ VAR='$(VAR) $(VAR)'"" -VAR $$VAR -VAR,-VAR""; \ VAR '$(VAR) $(VAR)/VAR/VAR.VAR $(VAR) |' \ '$(VAR) $(VAR) -VAR VAR.VAR'; \ VAR='$(VAR) $(VAR) -VAR -VAR,--VAR-VAR-VAR-VAR -VAR,-VAR -VAR,--VAR-VAR,$(VAR) VAR.VAR'; \ VAR=; [ '$(VAR)' = 'VAR' -VAR -VAR '$(VAR)' ] && VAR=-VAR,--VAR-VAR,0x63000000; \ VAR '$(VAR) $(VAR)/VAR/VAR.VAR $(VAR) |' \ '$(VAR) $(VAR) -VAR VAR.VAR'; \ VAR='$(VAR) $(VAR) -VAR '""$$VAR""' -VAR,-VAR -VAR,--VAR-VAR,$(VAR) $(VAR).VAR VAR.VAR'; \ VAR='$(VAR) $(VAR) -VAR -VAR,-VAR,VAR'; \ VAR='$(VAR) $(VAR) -VAR -VAR,-VAR,VAR -VAR $(VAR)'; \ VAR='$(VAR) $(VAR)'; \ VAR=''; \ VAR=''; \ VAR='$(VAR) $(VAR) -VAR $(VAR) -VAR,-VAR'; \ VAR='-VAR,-VAR,VAR,-VAR,$(VAR).VAR'; \ VAR='-VAR,-VAR,VAR'; \ VAR='$(VAR) $(VAR) -VAR $(VAR) -VAR,-VAR'; \ VAR='$(VAR) $(VAR)'; \ VAR='$(VAR) -VAR -VAR $(VAR)'; \ VAR='$(VAR) -VAR -VAR $(VAR)'; \ VAR='$(VAR) '""$${VAR}""' -VAR $(VAR)'; \ VAR='$(VAR) '""$${VAR}""' -VAR $(VAR)'; \ VAR=''; \ VAR=''; \ VAR='$(VAR) $(VAR) -VAR -VAR,-VAR,$(VAR),-VAR,VAR'; \ VAR=''; \ ($(VAR) -VAR 2>&1 | VAR VAR) > /VAR/VAR && VAR='-VAR,'; \ VAR='$(VAR) $(VAR) -VAR -VAR,-VAR,$(VAR),-VAR,VAR'; \ @VAR='$(VAR) $(VAR)'; \ VAR='$(VAR) $(VAR) -VAR,-VAR,VAR,+VAR,-VAR,+VAR,+VAR,$(VAR),+VAR,../:,+VAR,./:'; \ VAR='$(VAR) $(VAR) -VAR,-VAR,VAR,+VAR,-VAR,+VAR,+VAR,$(VAR),+VAR,../:,+VAR,./:'; \ VAR='$(VAR) $(VAR) -VAR,+VAR,+VAR,../:,+VAR,./:'; \ @VAR=`VAR 'VAR$(VAR)' : 'VAR\-[VAR-VAR]*\(64\)'` || :; \ @ VAR=`VAR 'VAR$(VAR)' : 'VAR\-[VAR-VAR]*\(64\)'` || : ; \ VAR='$(VAR) -VAR,-VAR $(VAR)'; \ VAR=""$${VAR:-$(VAR)}""; \ VAR=""$${VAR:-$(VAR)}""; VAR=""$${VAR:-$(VAR) $(VAR)}""; \ $${VAR} $${VAR} -VAR $${VAR:=$(VAR)} $(VAR) $${VAR} ) VAR=""$${VAR:-$(VAR)}""; \ VAR=""$${VAR:-$(VAR)}""; \ VAR=""$${VAR:-$(VAR) $(VAR)}""; \ $${VAR} $${VAR} \ $$VAR $$VAR $$VAR $$VAR \ VAR [ -VAR ""$(VAR)"" -VAR -VAR ""$(VAR)"" -VAR \ ""$(VAR)"" != ""$(VAR)"" ]; VAR \ VAR= VAR=""$(VAR) $(VAR)""; $(VAR) VAR= VAR=VAR; VAR=""$(VAR)""; $(VAR) ([ -VAR ""$(VAR)"" ] || VAR $(VAR) $$VAR) && \ VAR=""$(VAR) $(VAR) -VAR -VAR,-VAR -VAR,-VAR=$(VAR)"" VAR=VAR=""$(VAR) $(VAR)"" VAR="" ""; \ VAR=""$(VAR) $(VAR) -VAR -VAR""; \ VAR="" ""; \ VAR=""-VAR,-VAR""; \ VAR=""$(VAR) $(VAR) -VAR -VAR""; \ VAR=""$(VAR) $(VAR)""; \ VAR=""$(VAR) `VAR $(VAR) | VAR VAR/VAR/VAR/`""; \ VAR=""$(VAR) $(VAR) -VAR $(VAR) -VAR $(VAR) -VAR $(VAR)/$(VAR)/$(VAR)""; \ VAR=""$(VAR) $(VAR) -VAR $$VAR -VAR,-VAR""; \ VAR ""$(VAR) $(VAR)/VAR/VAR.VAR $(VAR) |"" \ ""$(VAR) $(VAR) -VAR VAR.VAR""; \ VAR=""$(VAR) $(VAR) -VAR -VAR,--VAR-VAR-VAR-VAR -VAR,-VAR -VAR,--VAR-VAR,$(VAR) VAR.VAR""; \ VAR=; [ $(VAR) = ""VAR"" -VAR -VAR ""$(VAR)"" ] && VAR=-VAR,--VAR-VAR,0x63000000; \ VAR ""$(VAR) $(VAR)/VAR/VAR.VAR $(VAR) |"" \ ""$(VAR) $(VAR) -VAR VAR.VAR""; \ VAR=""$(VAR) $(VAR) -VAR $$VAR -VAR,-VAR -VAR,--VAR-VAR,$(VAR) $(VAR).VAR VAR.VAR""; \ VAR=""$(VAR) $(VAR) -VAR -VAR,-VAR,VAR""; \ VAR=""$(VAR) $(VAR) -VAR -VAR,-VAR,VAR -VAR $(VAR)""; \ VAR=""$(VAR) $(VAR)""; \ VAR=""""; \ VAR=""""; \ VAR=""$(VAR) $(VAR) -VAR $(VAR) -VAR,-VAR""; \ VAR=""-VAR,-VAR,VAR,-VAR,$(VAR).VAR""; \ VAR=""-VAR,-VAR,VAR""; \ VAR=""$(VAR) $(VAR) -VAR $(VAR) -VAR,-VAR""; \ VAR=""$(VAR) $(VAR)""; \ VAR=""$(VAR) -VAR -VAR $(VAR)""; \ VAR=""$(VAR) -VAR -VAR $(VAR)""; \ VAR=""$(VAR) $${VAR} -VAR $(VAR)""; \ VAR=""$(VAR) $${VAR} -VAR $(VAR)""; \ VAR=""""; \ VAR=""""; \ VAR=""$(VAR) $(VAR) -VAR -VAR,-VAR,$(VAR),-VAR,VAR""; \ VAR=""""; \ ($(VAR) -VAR 2>&1 | VAR VAR) > /VAR/VAR && VAR=""-VAR,""; \ VAR=""$(VAR) $(VAR) -VAR -VAR,-VAR,$(VAR),-VAR,VAR""; \ @VAR=""$(VAR) $(VAR)""; \ VAR=""$(VAR) $(VAR) -VAR,-VAR,VAR,+VAR,-VAR,+VAR,+VAR,$(VAR),+VAR,../:,+VAR,./:""; \ VAR=""$(VAR) $(VAR) -VAR,-VAR,VAR,+VAR,-VAR,+VAR,+VAR,$(VAR),+VAR,../:,+VAR,./:""; \ VAR=""$(VAR) $(VAR) -VAR,+VAR,+VAR,../:,+VAR,./:""; \ @VAR=`VAR ""VAR$(VAR)"" : 'VAR\-[VAR-VAR]*\(64\)'` || :; \ @ VAR=`VAR ""VAR$(VAR)"" : 'VAR\-[VAR-VAR]*\(64\)'` || : ; \ VAR=""$(VAR) -VAR,-VAR $(VAR)""; \",10
server_c0868f93f1175c32379f6e64b245b724c40478be,liprivate/User/Database.php,"		if (mb_strlen($displayName) > 64) {
			return false;
		}
",,c0868f93f1175c32379f6e64b245b724c40478be,CVE-2022-39346,c0868f93f1175c32379f6e64b245b724c40478be,https://github.com/nextcloud/server,NVD_GIT_REPOBASED,74,COMPLETED,VAR (VAR($VAR) > 64) { VAR VAR; } ,10
squid_7a5af8db8e0377c06ed9ffbdcb1334389c7cd8ab,src/ipc/mem/PageStack.cc,"#include <cmath>
#include <algorithm>
/*

Ipc::Mem::IdSet and related code maintains a perfect full binary tree structure:

         (l,r)
           /\
    (ll,lr)  (rl,rr)
       /\      /\
      L1 L2   L3 L4

where

    * (l,r) is an always-present root node;
    * inner nodes, including the root one, count the total number of available
      IDs in the leaf nodes of the left and right subtrees (e.g., r = rl + rr);
    * leaf nodes are bitsets of available IDs (e.g., rl = number of 1s in L3);
      all leaf nodes are always present.

The above sample tree would be stored as seven 64-bit atomic integers:
    (l,r), (ll,lr), (rl,rr), L1, L2, L3, L4

*/

namespace Ipc
{

namespace Mem
{

/// the maximum number of pages that a leaf node can store
static const IdSet::size_type BitsPerLeaf = 64;

class IdSetPosition
{
public:
    using size_type = IdSet::size_type;

    IdSetPosition() = default; ///< root node position
    IdSetPosition(size_type aLevel, size_type anOffset);

    /// whether we are at the top of the tree
    bool atRoot() const { return !level && !offset; }

    /// which direction is this position from our parent node
    IdSetNavigationDirection ascendDirection() const;

    /// the number of levels above us (e.g., zero for the root node)
    IdSet::size_type level = 0;
    /// the number of nodes (at our level) to the left of us
    IdSet::size_type offset = 0;
};

/// a helper class to perform inner node manipulation for IdSet
class IdSetInnerNode
{
public:
    using size_type = IdSet::size_type;
    typedef uint64_t Packed; ///< (atomically) stored serialized value

    /// de-serializes a given value
    static IdSetInnerNode Unpack(Packed packed);

    IdSetInnerNode() = default;
    IdSetInnerNode(size_type left, size_type right);

    /// returns a serializes value suitable for shared memory storage
    Packed pack() const { return (static_cast<Packed>(left) << 32) | right; }

    size_type left = 0; ///< the number of available IDs in the left subtree
    size_type right = 0; ///< the number of available IDs in the right subtree
};

} // namespace Mem

} // namespace Ipc

/* Ipc::Mem::IdSetPosition */

Ipc::Mem::IdSetPosition::IdSetPosition(size_type aLevel, size_type anOffset):
    level(aLevel),
    offset(anOffset)
{
}

Ipc::Mem::IdSetNavigationDirection
Ipc::Mem::IdSetPosition::ascendDirection() const
{
    return (offset % 2 == 0) ? dirLeft : dirRight;
}

/* Ipc::Mem::IdSetMeasurements */

Ipc::Mem::IdSetMeasurements::IdSetMeasurements(const size_type aCapacity)
{
    capacity = aCapacity;

    // For simplicity, we want a perfect full binary tree with root and leaves.
    // We could compute all this with log2() calls, but rounding and honoring
    // root+leaves minimums make that approach more complex than this fast loop.
    requestedLeafNodeCount = (capacity + (BitsPerLeaf-1))/BitsPerLeaf;
    treeHeight = 1+1; // the root level plus the leaf nodes level
    leafNodeCount = 2; // the root node can have only two leaf nodes
    while (leafNodeCount < requestedLeafNodeCount) {
        leafNodeCount *= 2;
        ++treeHeight;
    }
    innerLevelCount = treeHeight - 1;

    debugs(54, 5, ""rounded capacity up from "" << capacity << "" to "" << (leafNodeCount*BitsPerLeaf));

    // we do (1 << level) when computing 32-bit IdSetInnerNode::left
    assert(treeHeight < 32);
}

/* Ipc::Mem::IdSetInnerNode */

Ipc::Mem::IdSetInnerNode::IdSetInnerNode(size_type aLeft, size_type aRight):
    left(aLeft),
    right(aRight)
{
}

Ipc::Mem::IdSetInnerNode
Ipc::Mem::IdSetInnerNode::Unpack(Packed packed)
{
    // truncation during the cast is intentional here
    return IdSetInnerNode(packed >> 32, static_cast<uint32_t>(packed));
}

/* Ipc::Mem::IdSet */

Ipc::Mem::IdSet::IdSet(const size_type capacity):
    measurements(capacity),
    nodes_(capacity)
{
    // For valueAddress() to be able to return a raw uint64_t pointer, the
    // atomic wrappers in nodes_ must be zero-size. Check the best we can. Once.
    static_assert(sizeof(StoredNode) == sizeof(Node), ""atomic locks use no storage"");
    assert(StoredNode().is_lock_free());

    makeFullBeforeSharing();
}

void
Ipc::Mem::IdSet::makeFullBeforeSharing()
{
    // initially, all IDs are marked as available
    fillAllNodes();

    // ... but IDs beyond the requested capacity should not be available
    if (measurements.capacity != measurements.leafNodeCount*BitsPerLeaf)
        truncateExtras();
}

/// populates the entire allocated tree with available IDs
/// may exceed the requested capacity; \see truncateExtras()
void
Ipc::Mem::IdSet::fillAllNodes()
{
    // leaf nodes
    auto pos = Position(measurements.treeHeight-1, 0);
    const auto allOnes = ~uint64_t(0);
    std::fill_n(valueAddress(pos), measurements.leafNodeCount, allOnes);

    // inner nodes, starting from the bottom of the tree
    auto nodesAtLevel = measurements.leafNodeCount/2;
    auto pagesBelow = BitsPerLeaf;
    do {
        pos = ascend(pos);
        const auto value = IdSetInnerNode(pagesBelow, pagesBelow).pack();
        std::fill_n(valueAddress(pos), nodesAtLevel, value);
        nodesAtLevel /= 2;
        pagesBelow *= 2;
    } while (!pos.atRoot());
}

/// effectively removes IDs that exceed the requested capacity after makeFull()
void
Ipc::Mem::IdSet::truncateExtras()
{
    // leaf nodes
    // start with the left-most leaf that should have some 0s; it may even have
    // no 1s at all (i.e. be completely unused)
    auto pos = Position(measurements.treeHeight-1, measurements.capacity/BitsPerLeaf);
    leafTruncate(pos, measurements.capacity % BitsPerLeaf);
    const auto rightLeaves = measurements.leafNodeCount - measurements.requestedLeafNodeCount;
    // this zeroing of the leaf nodes to the right from pos is only necessary to
    // trigger asserts if the code dealing with the inner node counters is buggy
    if (rightLeaves > 1)
        std::fill_n(valueAddress(pos) + 1, rightLeaves-1, 0);
    // inner nodes, starting from the bottom of the tree; optimization: only
    // adjusting nodes on the way up from the first leaf-with-0s position
    auto toSubtract = BitsPerLeaf - (measurements.capacity % BitsPerLeaf);
    do {
        const auto direction = pos.ascendDirection();
        pos = ascend(pos);
        toSubtract = innerTruncate(pos, direction, toSubtract);
    } while (!pos.atRoot());
}

/// fill the leaf node at a given position with 0s, leaving only idsToKeep IDs
Ipc::Mem::IdSet::leafTruncate(const Position pos, const size_type idsToKeep)
    Node &node = *valueAddress(pos); // no auto to simplify the asserts() below
    assert(node == std::numeric_limits<Node>::max()); // all 1s
    static_assert(std::is_unsigned<Node>::value, ""right shift prepends 0s"");
    node >>= BitsPerLeaf - idsToKeep;
    // node can be anything here, including all 0s and all 1s
}

/// accounts for toSubtract IDs removal from a subtree in the given direction of
/// the given position
/// \returns the number of IDs to subtract from the parent node
Ipc::Mem::IdSet::size_type
Ipc::Mem::IdSet::innerTruncate(const Position pos, const NavigationDirection dir, const size_type toSubtract)
{
    auto *valuePtr = valueAddress(pos);
    auto value = IdSetInnerNode::Unpack(*valuePtr);
    size_type toSubtractNext = 0;
    if (dir == dirLeft) {
        toSubtractNext = toSubtract + value.right;
        assert(value.left >= toSubtract);
        value.left -= toSubtract;
        value.right = 0;
    } else {
        assert(dir == dirRight);
        toSubtractNext = toSubtract;
        assert(value.right >= toSubtract);
        // value.left is unchanged; we have only adjusted the right branch
        value.right -= toSubtract;
    }
    *valuePtr = value.pack();
    return toSubtractNext;
}

/// accounts for an ID added to subtree in the given dir from the given position
void
Ipc::Mem::IdSet::innerPush(const Position pos, const NavigationDirection dir)
{
    // either left or right component will be true/1; the other will be false/0
    const auto increment = IdSetInnerNode(dir == dirLeft, dir == dirRight).pack();
    const auto previousValue = nodeAt(pos).fetch_add(increment);
    // no overflows
    assert(previousValue <= std::numeric_limits<Node>::max() - increment);
}

/// accounts for future ID removal from a subtree of the given position
/// \returns the direction of the subtree chosen to relinquish the ID
Ipc::Mem::IdSet::NavigationDirection
Ipc::Mem::IdSet::innerPop(const Position pos)
{
    NavigationDirection direction = dirNone;

    auto &node = nodeAt(pos);
    auto oldValue = node.load();
    IdSetInnerNode newValue;
    do {
        newValue = IdSetInnerNode::Unpack(oldValue);
        if (newValue.left) {
            --newValue.left;
            direction = dirLeft;
        } else if (newValue.right) {
            --newValue.right;
            direction = dirRight;
        } else {
            return dirEnd;
        }
    } while (!node.compare_exchange_weak(oldValue, newValue.pack()));

    assert(direction == dirLeft || direction == dirRight);
    return direction;
/// adds the given ID to the leaf node at the given position
Ipc::Mem::IdSet::leafPush(const Position pos, const size_type id)
    const auto mask = Node(1) << (id % BitsPerLeaf);
    const auto oldValue = nodeAt(pos).fetch_or(mask);
    // this was a new entry
    assert((oldValue & mask) == 0);
}

// TODO: After switching to C++20, use countr_zero() which may compile to a
// single TZCNT assembly instruction on modern CPUs.
/// a temporary C++20 countr_zero() replacement
static inline
int trailingZeros(uint64_t x)
{
    if (!x)
        return 64;
    int count = 0;
    for (uint64_t mask = 1; !(x & mask); mask <<= 1)
        ++count;
    return count;
}

/// extracts and returns an ID from the leaf node at the given position
Ipc::Mem::IdSet::size_type
Ipc::Mem::IdSet::leafPop(const Position pos)
{
    auto &node = nodeAt(pos);
    auto oldValue = node.load();
    Node newValue;
    do {
        assert(oldValue > 0);
        const auto mask = oldValue - 1; // flips the rightmost 1 and trailing 0s
        newValue = oldValue & mask; // clears the rightmost 1
    } while (!node.compare_exchange_weak(oldValue, newValue));

    return pos.offset*BitsPerLeaf + trailingZeros(oldValue);
}

/// \returns the position of a parent node of the node at the given position
Ipc::Mem::IdSet::Position
Ipc::Mem::IdSet::ascend(Position pos)
{
    assert(pos.level > 0);
    --pos.level;
    pos.offset /= 2;
    return pos;
}

/// \returns the position of a child node in the given direction of the parent
/// node at the given position
Ipc::Mem::IdSet::Position
Ipc::Mem::IdSet::descend(Position pos, const NavigationDirection direction)
{
    assert(pos.level < measurements.treeHeight);
    ++pos.level;

    pos.offset *= 2;
    if (direction == dirRight)
        ++pos.offset;
    else
        assert(direction == dirLeft);

    return pos;
}

/// \returns the atomic node (either inner or leaf) at the given position
Ipc::Mem::IdSet::StoredNode &
Ipc::Mem::IdSet::nodeAt(const Position pos)
{
    assert(pos.level < measurements.treeHeight);
    // n = 2^(h+1) - 1 with h = level-1
    const auto nodesAbove = (1U << pos.level) - 1;

    // the second clause is for the special case of a root node
    assert(pos.offset < nodesAbove*2 || (pos.atRoot() && nodesAbove == 0));
    const auto nodesToTheLeft = pos.offset;

    const size_t nodesBefore = nodesAbove + nodesToTheLeft;
    assert(nodesBefore < measurements.nodeCount());
    return nodes_[nodesBefore];
}

/// \returns the location of the raw (inner or leaf) node at the given position
Ipc::Mem::IdSet::Node *
Ipc::Mem::IdSet::valueAddress(const Position pos)
{
    // IdSet() constructor asserts that this frequent reinterpret_cast is safe
    return &reinterpret_cast<Node&>(nodeAt(pos));
}

bool
Ipc::Mem::IdSet::pop(size_type &id)
{
    Position rootPos;
    const auto directionFromRoot = innerPop(rootPos);
    if (directionFromRoot == dirEnd)
        return false; // an empty tree

    auto pos = descend(rootPos, directionFromRoot);
    for (size_t level = 1; level < measurements.innerLevelCount; ++level) {
        const auto direction = innerPop(pos);
        pos = descend(pos, direction);
    }

    id = leafPop(pos);
    return true;
}

void
Ipc::Mem::IdSet::push(const size_type id)
{
    const auto offsetAtLeafLevel = id/BitsPerLeaf;
    auto pos = Position(measurements.innerLevelCount, offsetAtLeafLevel);
    leafPush(pos, id);

    do {
        const auto direction = pos.ascendDirection();
        pos = ascend(pos);
        innerPush(pos, direction);
    } while (!pos.atRoot());
}

size_t
Ipc::Mem::IdSet::MemorySize(const size_type capacity)
{
    const IdSetMeasurements measurements(capacity);
    // Adding sizeof(IdSet) double-counts the first node but it is better to
    // overestimate (a little) than to underestimate our memory needs due to
    // padding, new data members, etc.
    return sizeof(IdSet) + measurements.nodeCount() * sizeof(StoredNode);
    ids_(capacity_)
{
    size_ = capacity_;
    if (!capacity_)
        return false;
    IdSet::size_type pageIndex = 0;
    if (!ids_.pop(pageIndex))
        return false;
    page.number = pageIndex + 1;
    assert(pageIdIsValid(page));
    const auto pageIndex = page.number - 1;
    ids_.push(pageIndex);
    // Adding sizeof(PageStack) double-counts the fixed portion of the ids_ data
    // member but it is better to overestimate (a little) than to underestimate
    // our memory needs due to padding, new data members, etc.
    return sizeof(PageStack) + IdSet::MemorySize(capacity);","#include ""base/TextException.h""
/* Ipc::Mem::PageStackStorageSlot */
static_assert(sizeof(Ipc::Mem::PageStackStorageSlot::Pointer) ==
              sizeof(decltype(Ipc::Mem::PageId::number)), ""page indexing types are consistent"");
Ipc::Mem::PageStackStorageSlot::take()
    const auto nxt = nextOrMarker.exchange(TakenPage);
    assert(nxt != TakenPage);
Ipc::Mem::PageStackStorageSlot::put(const PointerOrMarker expected, const Pointer nxt)
    assert(nxt != TakenPage);
    const auto old = nextOrMarker.exchange(nxt);
    assert(old == expected);
    head_(Slot::NilPtr),
    slots_(aCapacity)
{
    assert(thePoolId);

    assert(capacity_ < Slot::TakenPage);
    assert(capacity_ < Slot::NilPtr);

    // initially, all pages are free
    if (capacity_) {
        const auto lastIndex = capacity_-1;
        // FlexibleArray cannot construct its phantom elements so, technically,
        // all slots (except the very first one) are uninitialized until now.
        for (Slot::Pointer i = 0; i < lastIndex; ++i)
            (void)new(&slots_[i])Slot(i+1);
        (void)new(&slots_[lastIndex])Slot(Slot::NilPtr);
        size_ = capacity_;
        head_ = 0;
    }
    Slot::Pointer current = head_.load();
    auto nextFree = Slot::NilPtr;
    do {
        if (current == Slot::NilPtr)
            return false;
        nextFree = slots_[current].next();
    } while (!head_.compare_exchange_weak(current, nextFree));
    slots_[current].take();
    page.number = current + 1;
    const auto pageIndex = page.number - 1;
    auto &slot = slots_[pageIndex];

    auto current = head_.load();
    auto expected = Slot::TakenPage;
    do {
        slot.put(expected, current);
        expected = current;
    } while (!head_.compare_exchange_weak(current, pageIndex));
    return sizeof(PageStack) + capacity * sizeof(Slot);",7a5af8db8e0377c06ed9ffbdcb1334389c7cd8ab,CVE-2020-14059,7a5af8db8e0377c06ed9ffbdcb1334389c7cd8ab,https://github.com/squid-cache/squid,CPE_GIT_REPOBASED,92,COMPLETED,"  /* VAR::VAR::VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: (VAR,VAR) /\ (VAR,VAR) (VAR,VAR) /\ /\ VAR VAR VAR VAR VAR * (VAR,VAR) VAR VAR VAR-VAR VAR VAR; * VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR.VAR., VAR = VAR + VAR); * VAR VAR VAR VAR VAR VAR VAR (VAR.VAR., VAR = VAR VAR 1s VAR VAR); VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR 64-VAR VAR VAR: (VAR,VAR), (VAR,VAR), (VAR,VAR), VAR, VAR, VAR, VAR */ VAR VAR { VAR VAR {  VAR VAR VAR::VAR VAR = 64; VAR VAR { VAR: VAR VAR = VAR::VAR; VAR() = VAR;  VAR(VAR VAR, VAR VAR);  VAR VAR() VAR { VAR !VAR && !VAR; }  VAR VAR() VAR;  VAR::VAR VAR = 0;  VAR::VAR VAR = 0; };  VAR VAR { VAR: VAR VAR = VAR::VAR; VAR VAR VAR;   VAR VAR VAR(VAR VAR); VAR() = VAR; VAR(VAR VAR, VAR VAR);  VAR VAR() VAR { VAR (VAR<VAR>(VAR) << 32) | VAR; } VAR VAR = 0;  VAR VAR = 0;  }; }  }   VAR::VAR::VAR::VAR(VAR VAR, VAR VAR): VAR(VAR), VAR(VAR) { } VAR::VAR::VAR VAR::VAR::VAR::VAR() VAR { VAR (VAR % 2 == 0) ? VAR : VAR; }  VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR = VAR;    VAR = (VAR + (VAR-1))/VAR; VAR = 1+1;  VAR = 2;  VAR (VAR < VAR) { VAR *= 2; ++VAR; } VAR = VAR - 1; VAR(54, 5, ""VAR VAR VAR VAR "" << VAR << "" VAR "" << (VAR*VAR));  VAR(VAR < 32); }  VAR::VAR::VAR::VAR(VAR VAR, VAR VAR): VAR(VAR), VAR(VAR) { } VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR) {  VAR VAR(VAR >> 32, VAR<VAR>(VAR)); }  VAR::VAR::VAR::VAR(VAR VAR VAR): VAR(VAR), VAR(VAR) {   VAR(VAR(VAR) == VAR(VAR), ""VAR VAR VAR VAR VAR""); VAR(VAR().VAR()); VAR(); } VAR VAR::VAR::VAR::VAR() {  VAR();  VAR (VAR.VAR != VAR.VAR*VAR) VAR(); }   VAR VAR::VAR::VAR::VAR() {  VAR VAR = VAR(VAR.VAR-1, 0); VAR VAR VAR = ~VAR(0); VAR::VAR(VAR(VAR), VAR.VAR, VAR);  VAR VAR = VAR.VAR/2; VAR VAR = VAR; VAR { VAR = VAR(VAR); VAR VAR VAR = VAR(VAR, VAR).VAR(); VAR::VAR(VAR(VAR), VAR, VAR); VAR /= 2; VAR *= 2; } VAR (!VAR.VAR()); }  VAR VAR::VAR::VAR::VAR() {    VAR VAR = VAR(VAR.VAR-1, VAR.VAR/VAR); VAR(VAR, VAR.VAR % VAR); VAR VAR VAR = VAR.VAR - VAR.VAR;   VAR (VAR > 1) VAR::VAR(VAR(VAR) + 1, VAR-1, 0);   VAR VAR = VAR - (VAR.VAR % VAR); VAR { VAR VAR VAR = VAR.VAR(); VAR = VAR(VAR); VAR = VAR(VAR, VAR, VAR); } VAR (!VAR.VAR()); }  VAR::VAR::VAR::VAR(VAR VAR VAR, VAR VAR VAR) VAR &VAR = *VAR(VAR);  VAR(VAR == VAR::VAR<VAR>::VAR());  VAR(VAR::VAR<VAR>::VAR, ""VAR VAR VAR 0s""); VAR >>= VAR - VAR;  }    VAR::VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR VAR, VAR VAR VAR, VAR VAR VAR) { VAR *VAR = VAR(VAR); VAR VAR = VAR::VAR(*VAR); VAR VAR = 0; VAR (VAR == VAR) { VAR = VAR + VAR.VAR; VAR(VAR.VAR >= VAR); VAR.VAR -= VAR; VAR.VAR = 0; } VAR { VAR(VAR == VAR); VAR = VAR; VAR(VAR.VAR >= VAR);  VAR.VAR -= VAR; } *VAR = VAR.VAR(); VAR VAR; }  VAR VAR::VAR::VAR::VAR(VAR VAR VAR, VAR VAR VAR) {  VAR VAR VAR = VAR(VAR == VAR, VAR == VAR).VAR(); VAR VAR VAR = VAR(VAR).VAR(VAR);  VAR(VAR <= VAR::VAR<VAR>::VAR() - VAR); }   VAR::VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR VAR = VAR; VAR &VAR = VAR(VAR); VAR VAR = VAR.VAR(); VAR VAR; VAR { VAR = VAR::VAR(VAR); VAR (VAR.VAR) { --VAR.VAR; VAR = VAR; } VAR VAR (VAR.VAR) { --VAR.VAR; VAR = VAR; } VAR { VAR VAR; } } VAR (!VAR.VAR(VAR, VAR.VAR())); VAR(VAR == VAR || VAR == VAR); VAR VAR;  VAR::VAR::VAR::VAR(VAR VAR VAR, VAR VAR VAR) VAR VAR VAR = VAR(1) << (VAR % VAR); VAR VAR VAR = VAR(VAR).VAR(VAR);  VAR((VAR & VAR) == 0); }    VAR VAR VAR VAR(VAR VAR) { VAR (!VAR) VAR 64; VAR VAR = 0; VAR (VAR VAR = 1; !(VAR & VAR); VAR <<= 1) ++VAR; VAR VAR; }  VAR::VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR &VAR = VAR(VAR); VAR VAR = VAR.VAR(); VAR VAR; VAR { VAR(VAR > 0); VAR VAR VAR = VAR - 1;  VAR = VAR & VAR;  } VAR (!VAR.VAR(VAR, VAR)); VAR VAR.VAR*VAR + VAR(VAR); }  VAR::VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR) { VAR(VAR.VAR > 0); --VAR.VAR; VAR.VAR /= 2; VAR VAR; }   VAR::VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR, VAR VAR VAR) { VAR(VAR.VAR < VAR.VAR); ++VAR.VAR; VAR.VAR *= 2; VAR (VAR == VAR) ++VAR.VAR; VAR VAR(VAR == VAR); VAR VAR; }  VAR::VAR::VAR::VAR & VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR(VAR.VAR < VAR.VAR);  VAR VAR VAR = (1U << VAR.VAR) - 1;  VAR(VAR.VAR < VAR*2 || (VAR.VAR() && VAR == 0)); VAR VAR VAR = VAR.VAR; VAR VAR VAR = VAR + VAR; VAR(VAR < VAR.VAR()); VAR VAR[VAR]; }  VAR::VAR::VAR::VAR * VAR::VAR::VAR::VAR(VAR VAR VAR) {  VAR &VAR<VAR&>(VAR(VAR)); } VAR VAR::VAR::VAR::VAR(VAR &VAR) { VAR VAR; VAR VAR VAR = VAR(VAR); VAR (VAR == VAR) VAR VAR;  VAR VAR = VAR(VAR, VAR); VAR (VAR VAR = 1; VAR < VAR.VAR; ++VAR) { VAR VAR VAR = VAR(VAR); VAR = VAR(VAR, VAR); } VAR = VAR(VAR); VAR VAR; } VAR VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR VAR VAR = VAR/VAR; VAR VAR = VAR(VAR.VAR, VAR); VAR(VAR, VAR); VAR { VAR VAR VAR = VAR.VAR(); VAR = VAR(VAR); VAR(VAR, VAR); } VAR (!VAR.VAR()); } VAR VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR VAR VAR(VAR);    VAR VAR(VAR) + VAR.VAR() * VAR(VAR); VAR(VAR) { VAR = VAR; VAR (!VAR) VAR VAR; VAR::VAR VAR = 0; VAR (!VAR.VAR(VAR)) VAR VAR; VAR.VAR = VAR + 1; VAR(VAR(VAR)); VAR VAR VAR = VAR.VAR - 1; VAR.VAR(VAR);    VAR VAR(VAR) + VAR::VAR(VAR);   VAR(VAR(VAR::VAR::VAR::VAR) == VAR(VAR(VAR::VAR::VAR::VAR)), ""VAR VAR VAR VAR VAR""); VAR::VAR::VAR::VAR() VAR VAR VAR = VAR.VAR(VAR); VAR(VAR != VAR); VAR::VAR::VAR::VAR(VAR VAR VAR, VAR VAR VAR) VAR(VAR != VAR); VAR VAR VAR = VAR.VAR(VAR); VAR(VAR == VAR); VAR(VAR::VAR), VAR(VAR) { VAR(VAR); VAR(VAR < VAR::VAR); VAR(VAR < VAR::VAR);  VAR (VAR) { VAR VAR VAR = VAR-1;   VAR (VAR::VAR VAR = 0; VAR < VAR; ++VAR) (VAR)VAR(&VAR[VAR])VAR(VAR+1); (VAR)VAR(&VAR[VAR])VAR(VAR::VAR); VAR = VAR; VAR = 0; } VAR::VAR VAR = VAR.VAR(); VAR VAR = VAR::VAR; VAR { VAR (VAR == VAR::VAR) VAR VAR; VAR = VAR[VAR].VAR(); } VAR (!VAR.VAR(VAR, VAR)); VAR[VAR].VAR(); VAR.VAR = VAR + 1; VAR VAR VAR = VAR.VAR - 1; VAR &VAR = VAR[VAR]; VAR VAR = VAR.VAR(); VAR VAR = VAR::VAR; VAR { VAR.VAR(VAR, VAR); VAR = VAR; } VAR (!VAR.VAR(VAR, VAR)); VAR VAR(VAR) + VAR * VAR(VAR);",10
squid_93f5fda134a2a010b84ffedbe833d670e63ba4be,src/ssl/ErrorDetail.cc,"    {   X509_V_ERR_APPLICATION_VERIFICATION, //50
        ""X509_V_ERR_APPLICATION_VERIFICATION""
    },
#if defined(X509_V_ERR_PATH_LOOP)
    {
        X509_V_ERR_PATH_LOOP, //55
        ""X509_V_ERR_PATH_LOOP""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_INVALID_VERSION)
    {
        X509_V_ERR_SUITE_B_INVALID_VERSION, //56
        ""X509_V_ERR_SUITE_B_INVALID_VERSION""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_INVALID_ALGORITHM)
    {
        X509_V_ERR_SUITE_B_INVALID_ALGORITHM, //57
        ""X509_V_ERR_SUITE_B_INVALID_ALGORITHM""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_INVALID_CURVE)
    {
        X509_V_ERR_SUITE_B_INVALID_CURVE, //58
        ""X509_V_ERR_SUITE_B_INVALID_CURVE""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM)
    {
        X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM, //59
        ""X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED)
    {
        X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED, //60
        ""X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256)
    {
        X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256, //61
        ""X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256""
    },
#endif
#if defined(X509_V_ERR_HOSTNAME_MISMATCH)
    {
        X509_V_ERR_HOSTNAME_MISMATCH, //62
        ""X509_V_ERR_HOSTNAME_MISMATCH""
    },
#endif
#if defined(X509_V_ERR_EMAIL_MISMATCH)
    {
        X509_V_ERR_EMAIL_MISMATCH, //63
        ""X509_V_ERR_EMAIL_MISMATCH""
    },
#endif
#if defined(X509_V_ERR_IP_ADDRESS_MISMATCH)
    {
        X509_V_ERR_IP_ADDRESS_MISMATCH, //64
        ""X509_V_ERR_IP_ADDRESS_MISMATCH""
    },
#endif
#if defined(X509_V_ERR_DANE_NO_MATCH)
    {
        X509_V_ERR_DANE_NO_MATCH, //65
        ""X509_V_ERR_DANE_NO_MATCH""
#endif
#if defined(X509_V_ERR_EE_KEY_TOO_SMALL)
    {
        X509_V_ERR_EE_KEY_TOO_SMALL, //66
        ""X509_V_ERR_EE_KEY_TOO_SMALL""
    },
#endif
#if defined(X509_V_ERR_CA_KEY_TOO_SMALL)
    {
        X509_V_ERR_CA_KEY_TOO_SMALL, //67
        ""X509_V_ERR_CA_KEY_TOO_SMALL""
    },
#endif
#if defined(X509_V_ERR_CA_MD_TOO_WEAK)
    {
        X509_V_ERR_CA_MD_TOO_WEAK, //68
        ""X509_V_ERR_CA_MD_TOO_WEAK""
    },
#endif
#if defined(X509_V_ERR_INVALID_CALL)
    {
        X509_V_ERR_INVALID_CALL, //69
        ""X509_V_ERR_INVALID_CALL""
    },
#endif
#if defined(X509_V_ERR_STORE_LOOKUP)
    {
        X509_V_ERR_STORE_LOOKUP, //70
        ""X509_V_ERR_STORE_LOOKUP""
    },
#endif
#if defined(X509_V_ERR_NO_VALID_SCTS)
    {
        X509_V_ERR_NO_VALID_SCTS, //71
        ""X509_V_ERR_NO_VALID_SCTS""
    },
#endif
#if defined(X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION)
    {
        X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION, //72
        ""X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION""
    },
#endif
#if defined(X509_V_ERR_OCSP_VERIFY_NEEDED)
    {
        X509_V_ERR_OCSP_VERIFY_NEEDED, //73
        ""X509_V_ERR_OCSP_VERIFY_NEEDED""
    },
#endif
#if defined(X509_V_ERR_OCSP_VERIFY_FAILED)
    {
        X509_V_ERR_OCSP_VERIFY_FAILED, //74
        ""X509_V_ERR_OCSP_VERIFY_FAILED""
    },
#endif
#if defined(X509_V_ERR_OCSP_CERT_UNKNOWN)
    {
        X509_V_ERR_OCSP_CERT_UNKNOWN, //75
        ""X509_V_ERR_OCSP_CERT_UNKNOWN""
    },
#endif
    ""X509_V_ERR_PATH_LOOP"",
    ""X509_V_ERR_SUITE_B_INVALID_VERSION"",
    ""X509_V_ERR_SUITE_B_INVALID_ALGORITHM"",
    ""X509_V_ERR_SUITE_B_INVALID_CURVE"",
    ""X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM"",
    ""X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED"",
    ""X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256"",
    ""X509_V_ERR_HOSTNAME_MISMATCH"",
    ""X509_V_ERR_EMAIL_MISMATCH"",
    ""X509_V_ERR_IP_ADDRESS_MISMATCH"",
    ""X509_V_ERR_DANE_NO_MATCH"",
    ""X509_V_ERR_EE_KEY_TOO_SMALL"",
    ""X509_V_ERR_CA_KEY_TOO_SMALL"",
    ""X509_V_ERR_CA_MD_TOO_WEAK"",
    ""X509_V_ERR_INVALID_CALL"",
    ""X509_V_ERR_STORE_LOOKUP"",
    ""X509_V_ERR_NO_VALID_SCTS"",
    ""X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION"",
    ""X509_V_ERR_OCSP_VERIFY_NEEDED"",
    ""X509_V_ERR_OCSP_VERIFY_FAILED"",
    ""X509_V_ERR_OCSP_CERT_UNKNOWN"",
const char *Ssl::GetErrorName(Security::ErrorCode value, const bool prefixRawCode)
    static char tmpBuffer[128];
    snprintf(tmpBuffer, sizeof(tmpBuffer), ""%s%d"", prefixRawCode ? ""SSL_ERR="" : """", (int)value);
    return tmpBuffer;
    if (const char *err = detailEntry.name.termedBuf())
        return err;
    return GetErrorName(error_no);","    {   X509_V_ERR_APPLICATION_VERIFICATION,
        ""X509_V_ERR_APPLICATION_VERIFICATION""
const char *Ssl::GetErrorName(Security::ErrorCode value)
    return NULL;
    static char tmpBuffer[64];
    const char *err = detailEntry.name.termedBuf();
    if (!err)
        err = GetErrorName(error_no);

    if (!err) {
        snprintf(tmpBuffer, 64, ""%d"", (int)error_no);
        err = tmpBuffer;
    }
    return err;",93f5fda134a2a010b84ffedbe833d670e63ba4be,CVE-2020-14058,93f5fda134a2a010b84ffedbe833d670e63ba4be,https://github.com/squid-cache/squid,CPE_GIT_REPOBASED,84,COMPLETED,"{ VAR,  ""VAR"" },  { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR""   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },  ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", VAR VAR *VAR::VAR(VAR::VAR VAR, VAR VAR VAR) VAR VAR VAR[128]; VAR(VAR, VAR(VAR), ""%VAR%VAR"", VAR ? ""VAR="" : """", (VAR)VAR); VAR VAR; VAR (VAR VAR *VAR = VAR.VAR.VAR()) VAR VAR; VAR VAR(VAR); { VAR, ""VAR"" VAR VAR *VAR::VAR(VAR::VAR VAR) VAR VAR; VAR VAR VAR[64]; VAR VAR *VAR = VAR.VAR.VAR(); VAR (!VAR) VAR = VAR(VAR); VAR (!VAR) { VAR(VAR, 64, ""%VAR"", (VAR)VAR); VAR = VAR; } VAR VAR;",10
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,appveyor.yml,"# AppVeyor.yml from https://github.com/ogrisel/python-appveyor-demo
# License: CC0 1.0 Universal: http://creativecommons.org/publicdomain/zero/1.0/

skip_branch_with_pr: true
build: off

environment:

  matrix:
    - PYTHON: ""C:\\Python27-x64""
      PYTHON_VERSION: ""2.7.x""
      PYTHON_ARCH: ""64""
      TOXENV: ""py27""
      TOXPY27: ""%PYTHON%\\python.exe""

    - PYTHON: ""C:\\Python34-x64""
      PYTHON_VERSION: ""3.4.x""
      PYTHON_ARCH: ""64""
      TOXENV: ""py34""
      TOXPY34: ""%PYTHON%\\python.exe""

    - PYTHON: ""C:\\Python35-x64""
      PYTHON_VERSION: ""3.5.x""
      PYTHON_ARCH: ""64""
      TOXENV: ""py35""
      TOXPY35: ""%PYTHON%\\python.exe""

    - PYTHON: ""C:\\Python36-x64""
      PYTHON_VERSION: ""3.6.x""
      PYTHON_ARCH: ""64""
      TOXENV: ""py36""
      TOXPY36: ""%PYTHON%\\python.exe""

    - PYTHON: ""C:\\Python37-x64""
      PYTHON_VERSION: ""3.7.x""
      PYTHON_ARCH: ""64""
      TOXENV: ""py37""
      TOXPY37: ""%PYTHON%\\python.exe""

cache:
  - C:\Users\appveyor\AppData\Local\pip\Cache

install:
  # Install Python (from the official .msi of http://python.org) and pip when
  # not already installed.
  - ps: if (-not(Test-Path($env:PYTHON))) { & _appveyor\install.ps1 }

  # Prepend newly installed Python to the PATH of this build (this cannot be
  # done from inside the powershell script as it would require to restart
  # the parent CMD process).
  - SET PATH=%PYTHON%;%PYTHON%\\Scripts;%PATH%

  # Check that we have the expected version and architecture for Python
  - python --version
  - python -c ""import struct; print(struct.calcsize('P') * 8)""

  # Upgrade to the latest version of pip to avoid it displaying warnings
  # about it being out of date.
  - python -m pip install --upgrade pip wheel
  - pip install tox virtualenv

test_script:
  - tox

on_success:
  - .tox/%TOXENV%/Scripts/activate.bat
  - pip install codecov
  - codecov --env PLATFORM,TOXENV",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"  VAR: VAR VAR: VAR VAR: VAR: - VAR: ""VAR:\\VAR-VAR"" VAR: ""2.7.VAR"" VAR: ""64"" VAR: ""VAR"" VAR: ""%VAR%\\VAR.VAR"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.4.VAR"" VAR: ""64"" VAR: ""VAR"" VAR: ""%VAR%\\VAR.VAR"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.5.VAR"" VAR: ""64"" VAR: ""VAR"" VAR: ""%VAR%\\VAR.VAR"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.6.VAR"" VAR: ""64"" VAR: ""VAR"" VAR: ""%VAR%\\VAR.VAR"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.7.VAR"" VAR: ""64"" VAR: ""VAR"" VAR: ""%VAR%\\VAR.VAR"" VAR: - VAR:\VAR\VAR\VAR\VAR\VAR\VAR VAR:   - VAR: VAR (-VAR(VAR-VAR($VAR:VAR))) { & VAR\VAR.VAR }    - VAR VAR=%VAR%;%VAR%\\VAR;%VAR%  - VAR --VAR - VAR -VAR ""VAR VAR; VAR(VAR.VAR('VAR') * 8)""   - VAR -VAR VAR VAR --VAR VAR VAR - VAR VAR VAR VAR VAR: - VAR VAR: - .VAR/%VAR%/VAR/VAR.VAR - VAR VAR VAR - VAR --VAR VAR,VAR ",10
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,appveyor.yml,"# AppVeyor.yml from https://github.com/ogrisel/python-appveyor-demo
# License: CC0 1.0 Universal: http://creativecommons.org/publicdomain/zero/1.0/

skip_branch_with_pr: true
build: off

environment:

  matrix:
    - PYTHON: ""C:\\Python27-x64""
      PYTHON_VERSION: ""2.7.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-2.7""

    - PYTHON: ""C:\\Python34-x64""
      PYTHON_VERSION: ""3.4.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.4""

    - PYTHON: ""C:\\Python35-x64""
      PYTHON_VERSION: ""3.5.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.5""

    - PYTHON: ""C:\\Python36-x64""
      PYTHON_VERSION: ""3.6.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.6""

    - PYTHON: ""C:\\Python37-x64""
      PYTHON_VERSION: ""3.7.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.7""

cache:
  - C:\Users\appveyor\AppData\Local\pip\Cache

install:
  # Install Python (from the official .msi of http://python.org) and pip when
  # not already installed.
  - ps: if (-not(Test-Path($env:PYTHON))) { & _appveyor\install.ps1 }

  # Prepend newly installed Python to the PATH of this build (this cannot be
  # done from inside the powershell script as it would require to restart
  # the parent CMD process).
  - SET PATH=%PYTHON%;%PYTHON%\\Scripts;%PATH%

  # Upgrade to the latest version of pip to avoid it displaying warnings
  # about it being out of date.
  - C:\Python36-x64\python.exe -m pip install --upgrade pip wheel
  - C:\Python36-x64\python.exe -m pip install nox

test_script:
  - C:\Python36-x64\python.exe -m nox -s ""%NOX_SESSION%""

on_success:
  - pip install codecov
  - codecov --env PLATFORM,TOXENV",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"  VAR: VAR VAR: VAR VAR: VAR: - VAR: ""VAR:\\VAR-VAR"" VAR: ""2.7.VAR"" VAR: ""64"" VAR: ""VAR-2.7"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.4.VAR"" VAR: ""64"" VAR: ""VAR-3.4"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.5.VAR"" VAR: ""64"" VAR: ""VAR-3.5"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.6.VAR"" VAR: ""64"" VAR: ""VAR-3.6"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.7.VAR"" VAR: ""64"" VAR: ""VAR-3.7"" VAR: - VAR:\VAR\VAR\VAR\VAR\VAR\VAR VAR:   - VAR: VAR (-VAR(VAR-VAR($VAR:VAR))) { & VAR\VAR.VAR }    - VAR VAR=%VAR%;%VAR%\\VAR;%VAR%   - VAR:\VAR-VAR\VAR.VAR -VAR VAR VAR --VAR VAR VAR - VAR:\VAR-VAR\VAR.VAR -VAR VAR VAR VAR VAR: - VAR:\VAR-VAR\VAR.VAR -VAR VAR -VAR ""%VAR%"" VAR: - VAR VAR VAR - VAR --VAR VAR,VAR ",10
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,appveyor.yml,"# AppVeyor.yml from https://github.com/ogrisel/python-appveyor-demo
# License: CC0 1.0 Universal: http://creativecommons.org/publicdomain/zero/1.0/

skip_branch_with_pr: true
build: off

environment:

  matrix:
    - PYTHON: ""C:\\Python27-x64""
      PYTHON_VERSION: ""2.7.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-2.7""

    - PYTHON: ""C:\\Python34-x64""
      PYTHON_VERSION: ""3.4.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.4""

    - PYTHON: ""C:\\Python35-x64""
      PYTHON_VERSION: ""3.5.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.5""

    - PYTHON: ""C:\\Python36-x64""
      PYTHON_VERSION: ""3.6.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.6""

    - PYTHON: ""C:\\Python37-x64""
      PYTHON_VERSION: ""3.7.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.7""

cache:
  - C:\Users\appveyor\AppData\Local\pip\Cache

install:
  # Install Python (from the official .msi of http://python.org) and pip when
  # not already installed.
  - ps: if (-not(Test-Path($env:PYTHON))) { & _appveyor\install.ps1 }

  # Prepend newly installed Python to the PATH of this build (this cannot be
  # done from inside the powershell script as it would require to restart
  # the parent CMD process).
  - SET PATH=%PYTHON%;%PYTHON%\\Scripts;%PATH%

  # Upgrade to the latest version of pip to avoid it displaying warnings
  # about it being out of date.
  - C:\Python36-x64\python.exe -m pip install --upgrade pip wheel
  - C:\Python36-x64\python.exe -m pip install nox

test_script:
  - C:\Python36-x64\python.exe -m nox -s ""%NOX_SESSION%""

on_success:
  - pip install codecov
  - codecov --env PLATFORM,TOXENV",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"  VAR: VAR VAR: VAR VAR: VAR: - VAR: ""VAR:\\VAR-VAR"" VAR: ""2.7.VAR"" VAR: ""64"" VAR: ""VAR-2.7"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.4.VAR"" VAR: ""64"" VAR: ""VAR-3.4"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.5.VAR"" VAR: ""64"" VAR: ""VAR-3.5"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.6.VAR"" VAR: ""64"" VAR: ""VAR-3.6"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.7.VAR"" VAR: ""64"" VAR: ""VAR-3.7"" VAR: - VAR:\VAR\VAR\VAR\VAR\VAR\VAR VAR:   - VAR: VAR (-VAR(VAR-VAR($VAR:VAR))) { & VAR\VAR.VAR }    - VAR VAR=%VAR%;%VAR%\\VAR;%VAR%   - VAR:\VAR-VAR\VAR.VAR -VAR VAR VAR --VAR VAR VAR - VAR:\VAR-VAR\VAR.VAR -VAR VAR VAR VAR VAR: - VAR:\VAR-VAR\VAR.VAR -VAR VAR -VAR ""%VAR%"" VAR: - VAR VAR VAR - VAR --VAR VAR,VAR ",10
xrdp_1e42426db59120c6596d673f1bb2dc8b0312e692,libxrdp/xrdp_sec.c,"#define CS_CORE_MIN_LENGTH \
    (\
     4 +            /* Version */ \
     2 + 2 +        /* desktopWidth + desktopHeight */ \
     2 + 2 +        /* colorDepth + SASSequence */ \
     4 +            /* keyboardLayout */ \
     4 + 32 +       /* clientBuild + clientName */ \
     4 + 4 + 4 +    /* keyboardType + keyboardSubType + keyboardFunctionKey */ \
     64 +           /* imeFileName */ \
     0)

    if (!s_check_rem_and_log(s, CS_CORE_MIN_LENGTH,
                             ""Parsing [MS-RDPBCGR] TS_UD_CS_CORE""))
    {
        return 1;
    }
    if (!s_check_rem(s, 2))
    {
        return 0;
    }
#undef CS_CORE_MIN_LENGTH",,1e42426db59120c6596d673f1bb2dc8b0312e692,CVE-2022-23482,1e42426db59120c6596d673f1bb2dc8b0312e692,https://github.com/neutrinolabs/xrdp,NVD_GIT_REPOBASED,138,COMPLETED," (\ 4 + \ 2 + 2 + \ 2 + 2 + \ 4 + \ 4 + 32 + \ 4 + 4 + 4 + \ 64 + \ 0) VAR (!VAR(VAR, VAR, ""VAR [VAR-VAR] VAR"")) { VAR 1; } VAR (!VAR(VAR, 2)) { VAR 0; }  ",10
xrdp_96afae1ec559f9befa1c222f92f0d982e410c864,sesman/chansrv/audin.c,"    struct xr_wave_format_ex *wf = g_client_formats[g_current_format];
    /* wf->cbSize was checked when the format was received */
    init_stream(s, wf->cbSize + 64);
","    struct xr_wave_format_ex *wf;
    init_stream(s, 8192);
    wf = g_client_formats[g_current_format];",96afae1ec559f9befa1c222f92f0d982e410c864,CVE-2022-23477,96afae1ec559f9befa1c222f92f0d982e410c864,https://github.com/neutrinolabs/xrdp,NVD_GIT_REPOBASED,142,COMPLETED,"VAR VAR *VAR = VAR[VAR];  VAR(VAR, VAR->VAR + 64); VAR VAR *VAR; VAR(VAR, 8192); VAR = VAR[VAR];",10

commit,file,added_code,deleted_code,hash_clean,cve_id,hash,repo_url,rel_type,score,extraction_status,text_norm,cluster_kmeans
aiohttp_d5c12ba890557a575c313bb3017910d7616fce3d,aiohttp/http_parser.py,"# See https://www.rfc-editor.org/rfc/rfc9110.html#name-overview
# and https://www.rfc-editor.org/rfc/rfc9110.html#name-tokens
VERSRE: Final[Pattern[str]] = re.compile(r""HTTP/(\d).(\d)"")
HDRRE: Final[Pattern[bytes]] = re.compile(rb""[\x00-\x1F\x7F()<>@,;:\[\]={} \t\""\\]"")
            # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2
            if {bname[0], bname[-1]} & {32, 9}:  # {"" "", ""\t""}
                raise InvalidHeader(line)

            bvalue = bvalue.lstrip(b"" \t"")
            # Deprecated: https://www.rfc-editor.org/rfc/rfc9112.html#name-obsolete-line-folding
            bvalue = bvalue.strip(b"" \t"")
            # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5
            if ""\n"" in value or ""\r"" in value or ""\x00"" in value:
                raise InvalidHeader(bvalue)

                            # Shouldn't allow +/- or other number formats.
                            # https://www.rfc-editor.org/rfc/rfc9110#section-8.6-2
                            if not length_hdr.strip("" \t"").isdigit():
                            return int(length_hdr)
        # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-6
        # https://www.rfc-editor.org/rfc/rfc9110.html#name-collected-abnf
        singletons = (
            hdrs.CONTENT_LENGTH,
            hdrs.CONTENT_LOCATION,
            hdrs.CONTENT_RANGE,
            hdrs.CONTENT_TYPE,
            hdrs.ETAG,
            hdrs.HOST,
            hdrs.MAX_FORWARDS,
            hdrs.SERVER,
            hdrs.TRANSFER_ENCODING,
            hdrs.USER_AGENT,
        )
        bad_hdr = next((h for h in singletons if len(headers.getall(h, ())) > 1), None)
        if bad_hdr is not None:
            raise BadHttpMessage(f""Duplicate '{bad_hdr}' header found."")

            method, path, version = line.split(maxsplit=2)
        match = VERSRE.match(version)
        if match is None:
            raise BadStatusLine(line)
        version_o = HttpVersion(int(match.group(1)), int(match.group(2)))
            version, status = line.split(maxsplit=1)
            status, reason = status.split(maxsplit=1)
        if len(status) != 3 or not status.isdigit():
        status_i = int(status)
                        if not size_b.isdigit():
                            raise exc
                        size = int(bytes(size_b), 16)","# See https://tools.ietf.org/html/rfc7230#section-3.1.1
# and https://tools.ietf.org/html/rfc7230#appendix-B
VERSRE: Final[Pattern[str]] = re.compile(r""HTTP/(\d+).(\d+)"")
HDRRE: Final[Pattern[bytes]] = re.compile(rb""[\x00-\x1F\x7F()<>@,;:\[\]={} \t\\\\\""]"")
            bname = bname.strip(b"" \t"")
            bvalue = bvalue.lstrip()
            bvalue = bvalue.strip()
                            try:
                                length = int(length_hdr)
                            except ValueError:
                            if length < 0:
                                raise InvalidHeader(CONTENT_LENGTH)

                            return length
            method, path, version = line.split(None, 2)
        try:
            if version.startswith(""HTTP/""):
                n1, n2 = version[5:].split(""."", 1)
                version_o = HttpVersion(int(n1), int(n2))
            else:
                raise BadStatusLine(version)
        except Exception:
            raise BadStatusLine(version)
            version, status = line.split(None, 1)
            status, reason = status.split(None, 1)
        try:
            status_i = int(status)
        except ValueError:
            raise BadStatusLine(line) from None

        if status_i > 999:
                        try:
                            size = int(bytes(size_b), 16)
                        except ValueError:
                            raise exc from None",d5c12ba890557a575c313bb3017910d7616fce3d,CVE-2023-47627,d5c12ba890557a575c313bb3017910d7616fce3d,https://github.com/aio-libs/aiohttp,NVD_DIRECT_COMMIT,1337,COMPLETED,"  VAR: VAR[VAR[VAR]] = VAR.VAR(VAR""VAR/(\VAR).(\VAR)"") VAR: VAR[VAR[VAR]] = VAR.VAR(VAR""[\VAR-\VAR\VAR()<>@,;:\[\]={} \VAR\""\\]"")  VAR {VAR[0], VAR[-1]} & {32, 9}:  VAR VAR(VAR) VAR = VAR.VAR(VAR"" \VAR"")  VAR = VAR.VAR(VAR"" \VAR"")  VAR ""\VAR"" VAR VAR VAR ""\VAR"" VAR VAR VAR ""\VAR"" VAR VAR: VAR VAR(VAR)   VAR VAR VAR.VAR("" \VAR"").VAR(): VAR VAR(VAR)   VAR = ( VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, ) VAR = VAR((VAR VAR VAR VAR VAR VAR VAR(VAR.VAR(VAR, ())) > 1), VAR) VAR VAR VAR VAR VAR: VAR VAR(VAR""VAR '{VAR}' VAR VAR."") VAR, VAR, VAR = VAR.VAR(VAR=2) VAR = VAR.VAR(VAR) VAR VAR VAR VAR: VAR VAR(VAR) VAR = VAR(VAR(VAR.VAR(1)), VAR(VAR.VAR(2))) VAR, VAR = VAR.VAR(VAR=1) VAR, VAR = VAR.VAR(VAR=1) VAR VAR(VAR) != 3 VAR VAR VAR.VAR(): VAR = VAR(VAR) VAR VAR VAR.VAR(): VAR VAR VAR = VAR(VAR(VAR), 16)   VAR: VAR[VAR[VAR]] = VAR.VAR(VAR""VAR/(\VAR+).(\VAR+)"") VAR: VAR[VAR[VAR]] = VAR.VAR(VAR""[\VAR-\VAR\VAR()<>@,;:\[\]={} \VAR\\\\\""]"") VAR = VAR.VAR(VAR"" \VAR"") VAR = VAR.VAR() VAR = VAR.VAR() VAR: VAR = VAR(VAR) VAR VAR: VAR VAR < 0: VAR VAR(VAR) VAR VAR VAR, VAR, VAR = VAR.VAR(VAR, 2) VAR: VAR VAR.VAR(""VAR/""): VAR, VAR = VAR[5:].VAR(""."", 1) VAR = VAR(VAR(VAR), VAR(VAR)) VAR: VAR VAR(VAR) VAR VAR: VAR VAR(VAR) VAR, VAR = VAR.VAR(VAR, 1) VAR, VAR = VAR.VAR(VAR, 1) VAR: VAR = VAR(VAR) VAR VAR: VAR VAR(VAR) VAR VAR VAR VAR > 999: VAR: VAR = VAR(VAR(VAR), 16) VAR VAR: VAR VAR VAR VAR",1
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,frontend/src/components/Preloader.jsx,"export default function PreLoader() {
  return (
    <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
  );
}

export function FullScreenLoader() {
  return (
    <div
      id=""preloader""
      className=""fixed left-0 top-0 z-999999 flex h-screen w-screen items-center justify-center bg-white dark:bg-stone-800""
    >
      <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
    </div>
  );
}",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> ); } VAR VAR VAR() { VAR ( <VAR VAR=""VAR"" VAR=""VAR VAR-0 VAR-0 VAR-999999 VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR:VAR-VAR-800"" > <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> </VAR> ); } ",1
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/package.json,"{
  ""name"": ""anything-llm-server"",
  ""version"": ""0.0.1-beta"",
  ""description"": ""Server endpoints to process or create content for chatting"",
  ""main"": ""index.js"",
  ""author"": ""Timothy Carambat (Mintplex Labs)"",
  ""license"": ""MIT"",
  ""private"": false,
  ""engines"": {
    ""node"": "">=18.12.1""
  },
  ""scripts"": {
    ""dev"": ""NODE_ENV=development nodemon --ignore documents --ignore vector-cache --ignore storage --ignore swagger --trace-warnings index.js"",
    ""start"": ""NODE_ENV=production node index.js"",
    ""lint"": ""yarn prettier --write ./endpoints ./models ./utils index.js"",
    ""swagger"": ""node ./swagger/init.js""
  },
  ""dependencies"": {
    ""@azure/openai"": ""^1.0.0-beta.3"",
    ""@googleapis/youtube"": ""^9.0.0"",
    ""@pinecone-database/pinecone"": ""^0.1.6"",
    ""@qdrant/js-client-rest"": ""^1.4.0"",
    ""archiver"": ""^5.3.1"",
    ""bcrypt"": ""^5.1.0"",
    ""body-parser"": ""^1.20.2"",
    ""check-disk-space"": ""^3.4.0"",
    ""chromadb"": ""^1.5.2"",
    ""cors"": ""^2.8.5"",
    ""dotenv"": ""^16.0.3"",
    ""express"": ""^4.18.2"",
    ""extract-zip"": ""^2.0.1"",
    ""graphql"": ""^16.7.1"",
    ""jsonwebtoken"": ""^8.5.1"",
    ""langchain"": ""^0.0.90"",
    ""mime"": ""^3.0.0"",
    ""moment"": ""^2.29.4"",
    ""multer"": ""^1.4.5-lts.1"",
    ""openai"": ""^3.2.1"",
    ""pinecone-client"": ""^1.1.0"",
    ""posthog-node"": ""^3.1.1"",
    ""serve-index"": ""^1.9.1"",
    ""slugify"": ""^1.6.6"",
    ""sqlite"": ""^4.2.1"",
    ""sqlite3"": ""^5.1.6"",
    ""swagger-autogen"": ""^2.23.5"",
    ""swagger-ui-express"": ""^5.0.0"",
    ""uuid"": ""^9.0.0"",
    ""uuid-apikey"": ""^1.5.3"",
    ""vectordb"": ""0.1.12"",
    ""weaviate-ts-client"": ""^1.4.0""
  },
  ""devDependencies"": {
    ""nodemon"": ""^2.0.22"",
    ""prettier"": ""^2.4.1""
  }
}",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"{ ""VAR"": ""VAR-VAR-VAR"", ""VAR"": ""0.0.1-VAR"", ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"", ""VAR"": ""VAR.VAR"", ""VAR"": ""VAR VAR (VAR VAR)"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": "">=18.12.1"" }, ""VAR"": { ""VAR"": ""VAR=VAR VAR --VAR VAR --VAR VAR-VAR --VAR VAR --VAR VAR --VAR-VAR VAR.VAR"", ""VAR"": ""VAR=VAR VAR VAR.VAR"", ""VAR"": ""VAR VAR --VAR ./VAR ./VAR ./VAR VAR.VAR"", ""VAR"": ""VAR ./VAR/VAR.VAR"" }, ""VAR"": { ""@VAR/VAR"": ""^1.0.0-VAR.3"", ""@VAR/VAR"": ""^9.0.0"", ""@VAR-VAR/VAR"": ""^0.1.6"", ""@VAR/VAR-VAR-VAR"": ""^1.4.0"", ""VAR"": ""^5.3.1"", ""VAR"": ""^5.1.0"", ""VAR-VAR"": ""^1.20.2"", ""VAR-VAR-VAR"": ""^3.4.0"", ""VAR"": ""^1.5.2"", ""VAR"": ""^2.8.5"", ""VAR"": ""^16.0.3"", ""VAR"": ""^4.18.2"", ""VAR-VAR"": ""^2.0.1"", ""VAR"": ""^16.7.1"", ""VAR"": ""^8.5.1"", ""VAR"": ""^0.0.90"", ""VAR"": ""^3.0.0"", ""VAR"": ""^2.29.4"", ""VAR"": ""^1.4.5-VAR.1"", ""VAR"": ""^3.2.1"", ""VAR-VAR"": ""^1.1.0"", ""VAR-VAR"": ""^3.1.1"", ""VAR-VAR"": ""^1.9.1"", ""VAR"": ""^1.6.6"", ""VAR"": ""^4.2.1"", ""VAR"": ""^5.1.6"", ""VAR-VAR"": ""^2.23.5"", ""VAR-VAR-VAR"": ""^5.0.0"", ""VAR"": ""^9.0.0"", ""VAR-VAR"": ""^1.5.3"", ""VAR"": ""0.1.12"", ""VAR-VAR-VAR"": ""^1.4.0"" }, ""VAR"": { ""VAR"": ""^2.0.22"", ""VAR"": ""^2.4.1"" } } ",1
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/utils/AiProviders/azureOpenAi/index.js,"const { toChunks } = require(""../../helpers"");

class AzureOpenAi {
  constructor() {
    const { OpenAIClient, AzureKeyCredential } = require(""@azure/openai"");
    const openai = new OpenAIClient(
      process.env.AZURE_OPENAI_ENDPOINT,
      new AzureKeyCredential(process.env.AZURE_OPENAI_KEY)
    );
    this.openai = openai;

    // The maximum amount of ""inputs"" that OpenAI API can process in a single call.
    // https://learn.microsoft.com/en-us/azure/ai-services/openai/faq#i-am-trying-to-use-embeddings-and-received-the-error--invalidrequesterror--too-many-inputs--the-max-number-of-inputs-is-1---how-do-i-fix-this-:~:text=consisting%20of%20up%20to%2016%20inputs%20per%20API%20request
    this.embeddingChunkLimit = 16;
  }

  isValidChatModel(_modelName = """") {
    // The Azure user names their ""models"" as deployments and they can be any name
    // so we rely on the user to put in the correct deployment as only they would
    // know it.
    return true;
  }

  async isSafe(_input = """") {
    // Not implemented by Azure OpenAI so must be stubbed
    return { safe: true, reasons: [] };
  }

  async sendChat(chatHistory = [], prompt, workspace = {}) {
    const model = process.env.OPEN_MODEL_PREF;
    if (!model)
      throw new Error(
        ""No OPEN_MODEL_PREF ENV defined. This must the name of a deployment on your Azure account for an LLM chat model like GPT-3.5.""
      );

    const textResponse = await this.openai
      .getChatCompletions(
        model,
        [
          { role: ""system"", content: """" },
          ...chatHistory,
          { role: ""user"", content: prompt },
        ],
        {
          temperature: Number(workspace?.openAiTemp ?? 0.7),
          n: 1,
        }
      )
      .then((res) => {
        if (!res.hasOwnProperty(""choices""))
          throw new Error(""OpenAI chat: No results!"");
        if (res.choices.length === 0)
          throw new Error(""OpenAI chat: No results length!"");
        return res.choices[0].message.content;
      })
      .catch((error) => {
        console.log(error);
        throw new Error(
          `AzureOpenAI::getChatCompletions failed with: ${error.message}`
        );
      });
    return textResponse;
  }

  async getChatCompletion(messages = [], { temperature = 0.7 }) {
    const model = process.env.OPEN_MODEL_PREF;
    if (!model)
      throw new Error(
        ""No OPEN_MODEL_PREF ENV defined. This must the name of a deployment on your Azure account for an LLM chat model like GPT-3.5.""
      );

    const data = await this.openai.getChatCompletions(model, messages, {
      temperature,
    });
    if (!data.hasOwnProperty(""choices"")) return null;
    return data.choices[0].message.content;
  }

  async embedTextInput(textInput) {
    const result = await this.embedChunks(textInput);
    return result?.[0] || [];
  }

  async embedChunks(textChunks = []) {
    const textEmbeddingModel =
      process.env.EMBEDDING_MODEL_PREF || ""text-embedding-ada-002"";
    if (!textEmbeddingModel)
      throw new Error(
        ""No EMBEDDING_MODEL_PREF ENV defined. This must the name of a deployment on your Azure account for an embedding model.""
      );

    // Because there is a limit on how many chunks can be sent at once to Azure OpenAI
    // we concurrently execute each max batch of text chunks possible.
    // Refer to constructor embeddingChunkLimit for more info.
    const embeddingRequests = [];
    for (const chunk of toChunks(textChunks, this.embeddingChunkLimit)) {
      embeddingRequests.push(
        new Promise((resolve) => {
          this.openai
            .getEmbeddings(textEmbeddingModel, chunk)
            .then((res) => {
              resolve({ data: res.data, error: null });
            })
            .catch((e) => {
              resolve({ data: [], error: e?.error });
            });
        })
      );
    }

    const { data = [], error = null } = await Promise.all(
      embeddingRequests
    ).then((results) => {
      // If any errors were returned from Azure abort the entire sequence because the embeddings
      // will be incomplete.
      const errors = results
        .filter((res) => !!res.error)
        .map((res) => res.error)
        .flat();
      if (errors.length > 0) {
        return {
          data: [],
          error: `(${errors.length}) Embedding Errors! ${errors
            .map((error) => `[${error.type}]: ${error.message}`)
            .join("", "")}`,
        };
      }
      return {
        data: results.map((res) => res?.data || []).flat(),
        error: null,
      };
    });

    if (!!error) throw new Error(`Azure OpenAI Failed to embed: ${error}`);
    return data.length > 0 &&
      data.every((embd) => embd.hasOwnProperty(""embedding""))
      ? data.map((embd) => embd.embedding)
      : null;
  }
}

module.exports = {
  AzureOpenAi,
};",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../VAR""); VAR VAR { VAR() { VAR { VAR, VAR } = VAR(""@VAR/VAR""); VAR VAR = VAR VAR( VAR.VAR.VAR, VAR VAR(VAR.VAR.VAR) ); VAR.VAR = VAR;   VAR.VAR = 16; } VAR(VAR = """") {    VAR VAR; } VAR VAR(VAR = """") {  VAR { VAR: VAR, VAR: [] }; } VAR VAR(VAR = [], VAR, VAR = {}) { VAR VAR = VAR.VAR.VAR; VAR (!VAR) VAR VAR VAR( ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-3.5."" ); VAR VAR = VAR VAR.VAR .VAR( VAR, [ { VAR: ""VAR"", VAR: """" }, ...VAR, { VAR: ""VAR"", VAR: VAR }, ], { VAR: VAR(VAR?.VAR ?? 0.7), VAR: 1, } ) .VAR((VAR) => { VAR (!VAR.VAR(""VAR"")) VAR VAR VAR(""VAR VAR: VAR VAR!""); VAR (VAR.VAR.VAR === 0) VAR VAR VAR(""VAR VAR: VAR VAR VAR!""); VAR VAR.VAR[0].VAR.VAR; }) .VAR((VAR) => { VAR.VAR(VAR); VAR VAR VAR( `VAR::VAR VAR VAR: ${VAR.VAR}` ); }); VAR VAR; } VAR VAR(VAR = [], { VAR = 0.7 }) { VAR VAR = VAR.VAR.VAR; VAR (!VAR) VAR VAR VAR( ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-3.5."" ); VAR VAR = VAR VAR.VAR.VAR(VAR, VAR, { VAR, }); VAR (!VAR.VAR(""VAR"")) VAR VAR; VAR VAR.VAR[0].VAR.VAR; } VAR VAR(VAR) { VAR VAR = VAR VAR.VAR(VAR); VAR VAR?.[0] || []; } VAR VAR(VAR = []) { VAR VAR = VAR.VAR.VAR || ""VAR-VAR-VAR-002""; VAR (!VAR) VAR VAR VAR( ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."" );    VAR VAR = []; VAR (VAR VAR VAR VAR(VAR, VAR.VAR)) { VAR.VAR( VAR VAR((VAR) => { VAR.VAR .VAR(VAR, VAR) .VAR((VAR) => { VAR({ VAR: VAR.VAR, VAR: VAR }); }) .VAR((VAR) => { VAR({ VAR: [], VAR: VAR?.VAR }); }); }) ); } VAR { VAR = [], VAR = VAR } = VAR VAR.VAR( VAR ).VAR((VAR) => {   VAR VAR = VAR .VAR((VAR) => !!VAR.VAR) .VAR((VAR) => VAR.VAR) .VAR(); VAR (VAR.VAR > 0) { VAR { VAR: [], VAR: `(${VAR.VAR}) VAR VAR! ${VAR .VAR((VAR) => `[${VAR.VAR}]: ${VAR.VAR}`) .VAR("", "")}`, }; } VAR { VAR: VAR.VAR((VAR) => VAR?.VAR || []).VAR(), VAR: VAR, }; }); VAR (!!VAR) VAR VAR VAR(`VAR VAR VAR VAR VAR: ${VAR}`); VAR VAR.VAR > 0 && VAR.VAR((VAR) => VAR.VAR(""VAR"")) ? VAR.VAR((VAR) => VAR.VAR) : VAR; } } VAR.VAR = { VAR, }; ",1
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/components/Preloader.jsx,"export default function PreLoader() {
  return (
    <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
  );
}

export function FullScreenLoader() {
  return (
    <div
      id=""preloader""
      className=""fixed left-0 top-0 z-999999 flex h-screen w-screen items-center justify-center bg-white dark:bg-stone-800""
    >
      <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> ); } VAR VAR VAR() { VAR ( <VAR VAR=""VAR"" VAR=""VAR VAR-0 VAR-0 VAR-999999 VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR:VAR-VAR-800"" > <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> </VAR> ); } ",1
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/components/Preloader.jsx,"export default function PreLoader() {
  return (
    <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
  );
}

export function FullScreenLoader() {
  return (
    <div
      id=""preloader""
      className=""fixed left-0 top-0 z-999999 flex h-screen w-screen items-center justify-center bg-white dark:bg-stone-800""
    >
      <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> ); } VAR VAR VAR() { VAR ( <VAR VAR=""VAR"" VAR=""VAR VAR-0 VAR-0 VAR-999999 VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR:VAR-VAR-800"" > <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> </VAR> ); } ",1
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/package.json,"{
  ""name"": ""anything-llm-server"",
  ""version"": ""0.0.1-beta"",
  ""description"": ""Server endpoints to process or create content for chatting"",
  ""main"": ""index.js"",
  ""author"": ""Timothy Carambat (Mintplex Labs)"",
  ""license"": ""MIT"",
  ""private"": false,
  ""engines"": {
    ""node"": "">=18.12.1""
  },
  ""scripts"": {
    ""dev"": ""NODE_ENV=development nodemon --ignore documents --ignore vector-cache --ignore storage --ignore swagger --trace-warnings index.js"",
    ""start"": ""NODE_ENV=production node index.js"",
    ""lint"": ""yarn prettier --write ./endpoints ./models ./utils index.js"",
    ""swagger"": ""node ./swagger/init.js""
  },
  ""dependencies"": {
    ""@azure/openai"": ""^1.0.0-beta.3"",
    ""@googleapis/youtube"": ""^9.0.0"",
    ""@pinecone-database/pinecone"": ""^0.1.6"",
    ""@qdrant/js-client-rest"": ""^1.4.0"",
    ""archiver"": ""^5.3.1"",
    ""bcrypt"": ""^5.1.0"",
    ""body-parser"": ""^1.20.2"",
    ""check-disk-space"": ""^3.4.0"",
    ""chromadb"": ""^1.5.2"",
    ""cors"": ""^2.8.5"",
    ""dotenv"": ""^16.0.3"",
    ""express"": ""^4.18.2"",
    ""extract-zip"": ""^2.0.1"",
    ""graphql"": ""^16.7.1"",
    ""jsonwebtoken"": ""^8.5.1"",
    ""langchain"": ""^0.0.90"",
    ""mime"": ""^3.0.0"",
    ""moment"": ""^2.29.4"",
    ""multer"": ""^1.4.5-lts.1"",
    ""openai"": ""^3.2.1"",
    ""pinecone-client"": ""^1.1.0"",
    ""posthog-node"": ""^3.1.1"",
    ""serve-index"": ""^1.9.1"",
    ""slugify"": ""^1.6.6"",
    ""sqlite"": ""^4.2.1"",
    ""sqlite3"": ""^5.1.6"",
    ""sqlstring-sqlite"": ""^0.1.1"",
    ""swagger-autogen"": ""^2.23.5"",
    ""swagger-ui-express"": ""^5.0.0"",
    ""uuid"": ""^9.0.0"",
    ""uuid-apikey"": ""^1.5.3"",
    ""vectordb"": ""0.1.12"",
    ""weaviate-ts-client"": ""^1.4.0""
  },
  ""devDependencies"": {
    ""nodemon"": ""^2.0.22"",
    ""prettier"": ""^2.4.1""
  }
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"{ ""VAR"": ""VAR-VAR-VAR"", ""VAR"": ""0.0.1-VAR"", ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"", ""VAR"": ""VAR.VAR"", ""VAR"": ""VAR VAR (VAR VAR)"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": "">=18.12.1"" }, ""VAR"": { ""VAR"": ""VAR=VAR VAR --VAR VAR --VAR VAR-VAR --VAR VAR --VAR VAR --VAR-VAR VAR.VAR"", ""VAR"": ""VAR=VAR VAR VAR.VAR"", ""VAR"": ""VAR VAR --VAR ./VAR ./VAR ./VAR VAR.VAR"", ""VAR"": ""VAR ./VAR/VAR.VAR"" }, ""VAR"": { ""@VAR/VAR"": ""^1.0.0-VAR.3"", ""@VAR/VAR"": ""^9.0.0"", ""@VAR-VAR/VAR"": ""^0.1.6"", ""@VAR/VAR-VAR-VAR"": ""^1.4.0"", ""VAR"": ""^5.3.1"", ""VAR"": ""^5.1.0"", ""VAR-VAR"": ""^1.20.2"", ""VAR-VAR-VAR"": ""^3.4.0"", ""VAR"": ""^1.5.2"", ""VAR"": ""^2.8.5"", ""VAR"": ""^16.0.3"", ""VAR"": ""^4.18.2"", ""VAR-VAR"": ""^2.0.1"", ""VAR"": ""^16.7.1"", ""VAR"": ""^8.5.1"", ""VAR"": ""^0.0.90"", ""VAR"": ""^3.0.0"", ""VAR"": ""^2.29.4"", ""VAR"": ""^1.4.5-VAR.1"", ""VAR"": ""^3.2.1"", ""VAR-VAR"": ""^1.1.0"", ""VAR-VAR"": ""^3.1.1"", ""VAR-VAR"": ""^1.9.1"", ""VAR"": ""^1.6.6"", ""VAR"": ""^4.2.1"", ""VAR"": ""^5.1.6"", ""VAR-VAR"": ""^0.1.1"", ""VAR-VAR"": ""^2.23.5"", ""VAR-VAR-VAR"": ""^5.0.0"", ""VAR"": ""^9.0.0"", ""VAR-VAR"": ""^1.5.3"", ""VAR"": ""0.1.12"", ""VAR-VAR-VAR"": ""^1.4.0"" }, ""VAR"": { ""VAR"": ""^2.0.22"", ""VAR"": ""^2.4.1"" } } ",1
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/package.json,"{
  ""name"": ""anything-llm-server"",
  ""version"": ""0.0.1-beta"",
  ""description"": ""Server endpoints to process or create content for chatting"",
  ""main"": ""index.js"",
  ""author"": ""Timothy Carambat (Mintplex Labs)"",
  ""license"": ""MIT"",
  ""private"": false,
  ""engines"": {
    ""node"": "">=18.12.1""
  },
  ""scripts"": {
    ""dev"": ""NODE_ENV=development nodemon --ignore documents --ignore vector-cache --ignore storage --ignore swagger --trace-warnings index.js"",
    ""start"": ""NODE_ENV=production node index.js"",
    ""lint"": ""yarn prettier --write ./endpoints ./models ./utils index.js"",
    ""swagger"": ""node ./swagger/init.js""
  },
  ""dependencies"": {
    ""@azure/openai"": ""^1.0.0-beta.3"",
    ""@googleapis/youtube"": ""^9.0.0"",
    ""@pinecone-database/pinecone"": ""^0.1.6"",
    ""@qdrant/js-client-rest"": ""^1.4.0"",
    ""archiver"": ""^5.3.1"",
    ""bcrypt"": ""^5.1.0"",
    ""body-parser"": ""^1.20.2"",
    ""check-disk-space"": ""^3.4.0"",
    ""chromadb"": ""^1.5.2"",
    ""cors"": ""^2.8.5"",
    ""dotenv"": ""^16.0.3"",
    ""express"": ""^4.18.2"",
    ""extract-zip"": ""^2.0.1"",
    ""graphql"": ""^16.7.1"",
    ""jsonwebtoken"": ""^8.5.1"",
    ""langchain"": ""^0.0.90"",
    ""mime"": ""^3.0.0"",
    ""moment"": ""^2.29.4"",
    ""multer"": ""^1.4.5-lts.1"",
    ""openai"": ""^3.2.1"",
    ""pinecone-client"": ""^1.1.0"",
    ""posthog-node"": ""^3.1.1"",
    ""serve-index"": ""^1.9.1"",
    ""slugify"": ""^1.6.6"",
    ""sqlite"": ""^4.2.1"",
    ""sqlite3"": ""^5.1.6"",
    ""sqlstring-sqlite"": ""^0.1.1"",
    ""swagger-autogen"": ""^2.23.5"",
    ""swagger-ui-express"": ""^5.0.0"",
    ""uuid"": ""^9.0.0"",
    ""uuid-apikey"": ""^1.5.3"",
    ""vectordb"": ""0.1.12"",
    ""weaviate-ts-client"": ""^1.4.0""
  },
  ""devDependencies"": {
    ""nodemon"": ""^2.0.22"",
    ""prettier"": ""^2.4.1""
  }
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"{ ""VAR"": ""VAR-VAR-VAR"", ""VAR"": ""0.0.1-VAR"", ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"", ""VAR"": ""VAR.VAR"", ""VAR"": ""VAR VAR (VAR VAR)"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": "">=18.12.1"" }, ""VAR"": { ""VAR"": ""VAR=VAR VAR --VAR VAR --VAR VAR-VAR --VAR VAR --VAR VAR --VAR-VAR VAR.VAR"", ""VAR"": ""VAR=VAR VAR VAR.VAR"", ""VAR"": ""VAR VAR --VAR ./VAR ./VAR ./VAR VAR.VAR"", ""VAR"": ""VAR ./VAR/VAR.VAR"" }, ""VAR"": { ""@VAR/VAR"": ""^1.0.0-VAR.3"", ""@VAR/VAR"": ""^9.0.0"", ""@VAR-VAR/VAR"": ""^0.1.6"", ""@VAR/VAR-VAR-VAR"": ""^1.4.0"", ""VAR"": ""^5.3.1"", ""VAR"": ""^5.1.0"", ""VAR-VAR"": ""^1.20.2"", ""VAR-VAR-VAR"": ""^3.4.0"", ""VAR"": ""^1.5.2"", ""VAR"": ""^2.8.5"", ""VAR"": ""^16.0.3"", ""VAR"": ""^4.18.2"", ""VAR-VAR"": ""^2.0.1"", ""VAR"": ""^16.7.1"", ""VAR"": ""^8.5.1"", ""VAR"": ""^0.0.90"", ""VAR"": ""^3.0.0"", ""VAR"": ""^2.29.4"", ""VAR"": ""^1.4.5-VAR.1"", ""VAR"": ""^3.2.1"", ""VAR-VAR"": ""^1.1.0"", ""VAR-VAR"": ""^3.1.1"", ""VAR-VAR"": ""^1.9.1"", ""VAR"": ""^1.6.6"", ""VAR"": ""^4.2.1"", ""VAR"": ""^5.1.6"", ""VAR-VAR"": ""^0.1.1"", ""VAR-VAR"": ""^2.23.5"", ""VAR-VAR-VAR"": ""^5.0.0"", ""VAR"": ""^9.0.0"", ""VAR-VAR"": ""^1.5.3"", ""VAR"": ""0.1.12"", ""VAR-VAR-VAR"": ""^1.4.0"" }, ""VAR"": { ""VAR"": ""^2.0.22"", ""VAR"": ""^2.4.1"" } } ",1
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/utils/AiProviders/azureOpenAi/index.js,"const { toChunks } = require(""../../helpers"");

class AzureOpenAi {
  constructor() {
    const { OpenAIClient, AzureKeyCredential } = require(""@azure/openai"");
    const openai = new OpenAIClient(
      process.env.AZURE_OPENAI_ENDPOINT,
      new AzureKeyCredential(process.env.AZURE_OPENAI_KEY)
    );
    this.openai = openai;

    // The maximum amount of ""inputs"" that OpenAI API can process in a single call.
    // https://learn.microsoft.com/en-us/azure/ai-services/openai/faq#i-am-trying-to-use-embeddings-and-received-the-error--invalidrequesterror--too-many-inputs--the-max-number-of-inputs-is-1---how-do-i-fix-this-:~:text=consisting%20of%20up%20to%2016%20inputs%20per%20API%20request
    this.embeddingChunkLimit = 16;
  }

  isValidChatModel(_modelName = """") {
    // The Azure user names their ""models"" as deployments and they can be any name
    // so we rely on the user to put in the correct deployment as only they would
    // know it.
    return true;
  }

  async isSafe(_input = """") {
    // Not implemented by Azure OpenAI so must be stubbed
    return { safe: true, reasons: [] };
  }

  async sendChat(chatHistory = [], prompt, workspace = {}) {
    const model = process.env.OPEN_MODEL_PREF;
    if (!model)
      throw new Error(
        ""No OPEN_MODEL_PREF ENV defined. This must the name of a deployment on your Azure account for an LLM chat model like GPT-3.5.""
      );

    const textResponse = await this.openai
      .getChatCompletions(
        model,
        [
          { role: ""system"", content: """" },
          ...chatHistory,
          { role: ""user"", content: prompt },
        ],
        {
          temperature: Number(workspace?.openAiTemp ?? 0.7),
          n: 1,
        }
      )
      .then((res) => {
        if (!res.hasOwnProperty(""choices""))
          throw new Error(""OpenAI chat: No results!"");
        if (res.choices.length === 0)
          throw new Error(""OpenAI chat: No results length!"");
        return res.choices[0].message.content;
      })
      .catch((error) => {
        console.log(error);
        throw new Error(
          `AzureOpenAI::getChatCompletions failed with: ${error.message}`
        );
      });
    return textResponse;
  }

  async getChatCompletion(messages = [], { temperature = 0.7 }) {
    const model = process.env.OPEN_MODEL_PREF;
    if (!model)
      throw new Error(
        ""No OPEN_MODEL_PREF ENV defined. This must the name of a deployment on your Azure account for an LLM chat model like GPT-3.5.""
      );

    const data = await this.openai.getChatCompletions(model, messages, {
      temperature,
    });
    if (!data.hasOwnProperty(""choices"")) return null;
    return data.choices[0].message.content;
  }

  async embedTextInput(textInput) {
    const result = await this.embedChunks(textInput);
    return result?.[0] || [];
  }

  async embedChunks(textChunks = []) {
    const textEmbeddingModel =
      process.env.EMBEDDING_MODEL_PREF || ""text-embedding-ada-002"";
    if (!textEmbeddingModel)
      throw new Error(
        ""No EMBEDDING_MODEL_PREF ENV defined. This must the name of a deployment on your Azure account for an embedding model.""
      );

    // Because there is a limit on how many chunks can be sent at once to Azure OpenAI
    // we concurrently execute each max batch of text chunks possible.
    // Refer to constructor embeddingChunkLimit for more info.
    const embeddingRequests = [];
    for (const chunk of toChunks(textChunks, this.embeddingChunkLimit)) {
      embeddingRequests.push(
        new Promise((resolve) => {
          this.openai
            .getEmbeddings(textEmbeddingModel, chunk)
            .then((res) => {
              resolve({ data: res.data, error: null });
            })
            .catch((e) => {
              resolve({ data: [], error: e?.error });
            });
        })
      );
    }

    const { data = [], error = null } = await Promise.all(
      embeddingRequests
    ).then((results) => {
      // If any errors were returned from Azure abort the entire sequence because the embeddings
      // will be incomplete.
      const errors = results
        .filter((res) => !!res.error)
        .map((res) => res.error)
        .flat();
      if (errors.length > 0) {
        return {
          data: [],
          error: `(${errors.length}) Embedding Errors! ${errors
            .map((error) => `[${error.type}]: ${error.message}`)
            .join("", "")}`,
        };
      }
      return {
        data: results.map((res) => res?.data || []).flat(),
        error: null,
      };
    });

    if (!!error) throw new Error(`Azure OpenAI Failed to embed: ${error}`);
    return data.length > 0 &&
      data.every((embd) => embd.hasOwnProperty(""embedding""))
      ? data.map((embd) => embd.embedding)
      : null;
  }
}

module.exports = {
  AzureOpenAi,
};",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../VAR""); VAR VAR { VAR() { VAR { VAR, VAR } = VAR(""@VAR/VAR""); VAR VAR = VAR VAR( VAR.VAR.VAR, VAR VAR(VAR.VAR.VAR) ); VAR.VAR = VAR;   VAR.VAR = 16; } VAR(VAR = """") {    VAR VAR; } VAR VAR(VAR = """") {  VAR { VAR: VAR, VAR: [] }; } VAR VAR(VAR = [], VAR, VAR = {}) { VAR VAR = VAR.VAR.VAR; VAR (!VAR) VAR VAR VAR( ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-3.5."" ); VAR VAR = VAR VAR.VAR .VAR( VAR, [ { VAR: ""VAR"", VAR: """" }, ...VAR, { VAR: ""VAR"", VAR: VAR }, ], { VAR: VAR(VAR?.VAR ?? 0.7), VAR: 1, } ) .VAR((VAR) => { VAR (!VAR.VAR(""VAR"")) VAR VAR VAR(""VAR VAR: VAR VAR!""); VAR (VAR.VAR.VAR === 0) VAR VAR VAR(""VAR VAR: VAR VAR VAR!""); VAR VAR.VAR[0].VAR.VAR; }) .VAR((VAR) => { VAR.VAR(VAR); VAR VAR VAR( `VAR::VAR VAR VAR: ${VAR.VAR}` ); }); VAR VAR; } VAR VAR(VAR = [], { VAR = 0.7 }) { VAR VAR = VAR.VAR.VAR; VAR (!VAR) VAR VAR VAR( ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-3.5."" ); VAR VAR = VAR VAR.VAR.VAR(VAR, VAR, { VAR, }); VAR (!VAR.VAR(""VAR"")) VAR VAR; VAR VAR.VAR[0].VAR.VAR; } VAR VAR(VAR) { VAR VAR = VAR VAR.VAR(VAR); VAR VAR?.[0] || []; } VAR VAR(VAR = []) { VAR VAR = VAR.VAR.VAR || ""VAR-VAR-VAR-002""; VAR (!VAR) VAR VAR VAR( ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."" );    VAR VAR = []; VAR (VAR VAR VAR VAR(VAR, VAR.VAR)) { VAR.VAR( VAR VAR((VAR) => { VAR.VAR .VAR(VAR, VAR) .VAR((VAR) => { VAR({ VAR: VAR.VAR, VAR: VAR }); }) .VAR((VAR) => { VAR({ VAR: [], VAR: VAR?.VAR }); }); }) ); } VAR { VAR = [], VAR = VAR } = VAR VAR.VAR( VAR ).VAR((VAR) => {   VAR VAR = VAR .VAR((VAR) => !!VAR.VAR) .VAR((VAR) => VAR.VAR) .VAR(); VAR (VAR.VAR > 0) { VAR { VAR: [], VAR: `(${VAR.VAR}) VAR VAR! ${VAR .VAR((VAR) => `[${VAR.VAR}]: ${VAR.VAR}`) .VAR("", "")}`, }; } VAR { VAR: VAR.VAR((VAR) => VAR?.VAR || []).VAR(), VAR: VAR, }; }); VAR (!!VAR) VAR VAR VAR(`VAR VAR VAR VAR VAR: ${VAR}`); VAR VAR.VAR > 0 && VAR.VAR((VAR) => VAR.VAR(""VAR"")) ? VAR.VAR((VAR) => VAR.VAR) : VAR; } } VAR.VAR = { VAR, }; ",1
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/utils/AiProviders/azureOpenAi/index.js,"const { toChunks } = require(""../../helpers"");

class AzureOpenAi {
  constructor() {
    const { OpenAIClient, AzureKeyCredential } = require(""@azure/openai"");
    const openai = new OpenAIClient(
      process.env.AZURE_OPENAI_ENDPOINT,
      new AzureKeyCredential(process.env.AZURE_OPENAI_KEY)
    );
    this.openai = openai;

    // The maximum amount of ""inputs"" that OpenAI API can process in a single call.
    // https://learn.microsoft.com/en-us/azure/ai-services/openai/faq#i-am-trying-to-use-embeddings-and-received-the-error--invalidrequesterror--too-many-inputs--the-max-number-of-inputs-is-1---how-do-i-fix-this-:~:text=consisting%20of%20up%20to%2016%20inputs%20per%20API%20request
    this.embeddingChunkLimit = 16;
  }

  isValidChatModel(_modelName = """") {
    // The Azure user names their ""models"" as deployments and they can be any name
    // so we rely on the user to put in the correct deployment as only they would
    // know it.
    return true;
  }

  async isSafe(_input = """") {
    // Not implemented by Azure OpenAI so must be stubbed
    return { safe: true, reasons: [] };
  }

  async sendChat(chatHistory = [], prompt, workspace = {}) {
    const model = process.env.OPEN_MODEL_PREF;
    if (!model)
      throw new Error(
        ""No OPEN_MODEL_PREF ENV defined. This must the name of a deployment on your Azure account for an LLM chat model like GPT-3.5.""
      );

    const textResponse = await this.openai
      .getChatCompletions(
        model,
        [
          { role: ""system"", content: """" },
          ...chatHistory,
          { role: ""user"", content: prompt },
        ],
        {
          temperature: Number(workspace?.openAiTemp ?? 0.7),
          n: 1,
        }
      )
      .then((res) => {
        if (!res.hasOwnProperty(""choices""))
          throw new Error(""OpenAI chat: No results!"");
        if (res.choices.length === 0)
          throw new Error(""OpenAI chat: No results length!"");
        return res.choices[0].message.content;
      })
      .catch((error) => {
        console.log(error);
        throw new Error(
          `AzureOpenAI::getChatCompletions failed with: ${error.message}`
        );
      });
    return textResponse;
  }

  async getChatCompletion(messages = [], { temperature = 0.7 }) {
    const model = process.env.OPEN_MODEL_PREF;
    if (!model)
      throw new Error(
        ""No OPEN_MODEL_PREF ENV defined. This must the name of a deployment on your Azure account for an LLM chat model like GPT-3.5.""
      );

    const data = await this.openai.getChatCompletions(model, messages, {
      temperature,
    });
    if (!data.hasOwnProperty(""choices"")) return null;
    return data.choices[0].message.content;
  }

  async embedTextInput(textInput) {
    const result = await this.embedChunks(textInput);
    return result?.[0] || [];
  }

  async embedChunks(textChunks = []) {
    const textEmbeddingModel =
      process.env.EMBEDDING_MODEL_PREF || ""text-embedding-ada-002"";
    if (!textEmbeddingModel)
      throw new Error(
        ""No EMBEDDING_MODEL_PREF ENV defined. This must the name of a deployment on your Azure account for an embedding model.""
      );

    // Because there is a limit on how many chunks can be sent at once to Azure OpenAI
    // we concurrently execute each max batch of text chunks possible.
    // Refer to constructor embeddingChunkLimit for more info.
    const embeddingRequests = [];
    for (const chunk of toChunks(textChunks, this.embeddingChunkLimit)) {
      embeddingRequests.push(
        new Promise((resolve) => {
          this.openai
            .getEmbeddings(textEmbeddingModel, chunk)
            .then((res) => {
              resolve({ data: res.data, error: null });
            })
            .catch((e) => {
              resolve({ data: [], error: e?.error });
            });
        })
      );
    }

    const { data = [], error = null } = await Promise.all(
      embeddingRequests
    ).then((results) => {
      // If any errors were returned from Azure abort the entire sequence because the embeddings
      // will be incomplete.
      const errors = results
        .filter((res) => !!res.error)
        .map((res) => res.error)
        .flat();
      if (errors.length > 0) {
        return {
          data: [],
          error: `(${errors.length}) Embedding Errors! ${errors
            .map((error) => `[${error.type}]: ${error.message}`)
            .join("", "")}`,
        };
      }
      return {
        data: results.map((res) => res?.data || []).flat(),
        error: null,
      };
    });

    if (!!error) throw new Error(`Azure OpenAI Failed to embed: ${error}`);
    return data.length > 0 &&
      data.every((embd) => embd.hasOwnProperty(""embedding""))
      ? data.map((embd) => embd.embedding)
      : null;
  }
}

module.exports = {
  AzureOpenAi,
};",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../VAR""); VAR VAR { VAR() { VAR { VAR, VAR } = VAR(""@VAR/VAR""); VAR VAR = VAR VAR( VAR.VAR.VAR, VAR VAR(VAR.VAR.VAR) ); VAR.VAR = VAR;   VAR.VAR = 16; } VAR(VAR = """") {    VAR VAR; } VAR VAR(VAR = """") {  VAR { VAR: VAR, VAR: [] }; } VAR VAR(VAR = [], VAR, VAR = {}) { VAR VAR = VAR.VAR.VAR; VAR (!VAR) VAR VAR VAR( ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-3.5."" ); VAR VAR = VAR VAR.VAR .VAR( VAR, [ { VAR: ""VAR"", VAR: """" }, ...VAR, { VAR: ""VAR"", VAR: VAR }, ], { VAR: VAR(VAR?.VAR ?? 0.7), VAR: 1, } ) .VAR((VAR) => { VAR (!VAR.VAR(""VAR"")) VAR VAR VAR(""VAR VAR: VAR VAR!""); VAR (VAR.VAR.VAR === 0) VAR VAR VAR(""VAR VAR: VAR VAR VAR!""); VAR VAR.VAR[0].VAR.VAR; }) .VAR((VAR) => { VAR.VAR(VAR); VAR VAR VAR( `VAR::VAR VAR VAR: ${VAR.VAR}` ); }); VAR VAR; } VAR VAR(VAR = [], { VAR = 0.7 }) { VAR VAR = VAR.VAR.VAR; VAR (!VAR) VAR VAR VAR( ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-3.5."" ); VAR VAR = VAR VAR.VAR.VAR(VAR, VAR, { VAR, }); VAR (!VAR.VAR(""VAR"")) VAR VAR; VAR VAR.VAR[0].VAR.VAR; } VAR VAR(VAR) { VAR VAR = VAR VAR.VAR(VAR); VAR VAR?.[0] || []; } VAR VAR(VAR = []) { VAR VAR = VAR.VAR.VAR || ""VAR-VAR-VAR-002""; VAR (!VAR) VAR VAR VAR( ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."" );    VAR VAR = []; VAR (VAR VAR VAR VAR(VAR, VAR.VAR)) { VAR.VAR( VAR VAR((VAR) => { VAR.VAR .VAR(VAR, VAR) .VAR((VAR) => { VAR({ VAR: VAR.VAR, VAR: VAR }); }) .VAR((VAR) => { VAR({ VAR: [], VAR: VAR?.VAR }); }); }) ); } VAR { VAR = [], VAR = VAR } = VAR VAR.VAR( VAR ).VAR((VAR) => {   VAR VAR = VAR .VAR((VAR) => !!VAR.VAR) .VAR((VAR) => VAR.VAR) .VAR(); VAR (VAR.VAR > 0) { VAR { VAR: [], VAR: `(${VAR.VAR}) VAR VAR! ${VAR .VAR((VAR) => `[${VAR.VAR}]: ${VAR.VAR}`) .VAR("", "")}`, }; } VAR { VAR: VAR.VAR((VAR) => VAR?.VAR || []).VAR(), VAR: VAR, }; }); VAR (!!VAR) VAR VAR VAR(`VAR VAR VAR VAR VAR: ${VAR}`); VAR VAR.VAR > 0 && VAR.VAR((VAR) => VAR.VAR(""VAR"")) ? VAR.VAR((VAR) => VAR.VAR) : VAR; } } VAR.VAR = { VAR, }; ",1
argo-cd_17f7f4f462bdb233e1b9b36f67099f41052d8cb0,pkg/apiclient/grpcproxy.go,"	randSuffix, err := rand.String(16)
	if err != nil {
		return nil, nil, fmt.Errorf(""failed to generate random socket filename: %w"", err)
	}
	serverAddr := fmt.Sprintf(""%s/argocd-%s.sock"", os.TempDir(), randSuffix)","	serverAddr := fmt.Sprintf(""%s/argocd-%s.sock"", os.TempDir(), rand.RandString(16))",17f7f4f462bdb233e1b9b36f67099f41052d8cb0,CVE-2022-31034,17f7f4f462bdb233e1b9b36f67099f41052d8cb0,https://github.com/argoproj/argo-cd,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR, VAR := VAR.VAR(16) VAR VAR != VAR { VAR VAR, VAR, VAR.VAR(""VAR VAR VAR VAR VAR VAR: %VAR"", VAR) } VAR := VAR.VAR(""%VAR/VAR-%VAR.VAR"", VAR.VAR(), VAR) VAR := VAR.VAR(""%VAR/VAR-%VAR.VAR"", VAR.VAR(), VAR.VAR(16))",1
argo-cd_3a28c8a18cc2aa84fe81492625545d25c7a90bc3,docs/operator-manual/upgrading/2.4-2.5.md,"
## `argocd app create` for old CLI versions fails with API version >=2.5.16

Starting with Argo CD 2.5.16, the API returns `PermissionDenied` instead of `NotFound` for Application `GET` requests if
the Application does not exist.

The Argo CD CLI before versions starting with version 2.5.0-rc1 and before versions 2.5.16 and 2.6.7 does a `GET`
request before the `POST` request in `argocd app create`. The command does not gracefully handle the `PermissionDenied`
response and will therefore fail to create/update the Application.

To solve the issue, upgrade the CLI to at least 2.5.16, or 2.6.7.

CLIs older than 2.5.0-rc1 are unaffected.",,3a28c8a18cc2aa84fe81492625545d25c7a90bc3,CVE-2022-41354,3a28c8a18cc2aa84fe81492625545d25c7a90bc3,https://github.com/argoproj/argo-cd,GHSD_DIRECT_COMMIT,1337,COMPLETED," VAR VAR VAR VAR 2.5.16, VAR VAR VAR `VAR` VAR VAR `VAR` VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR 2.5.0-VAR VAR VAR VAR 2.5.16 VAR 2.6.7 VAR VAR `VAR` VAR VAR VAR `VAR` VAR VAR `VAR VAR VAR`. VAR VAR VAR VAR VAR VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR. VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR 2.5.16, VAR 2.6.7. VAR VAR VAR 2.5.0-VAR VAR VAR. ",1
argo-cd_3a28c8a18cc2aa84fe81492625545d25c7a90bc3,docs/operator-manual/upgrading/2.5-2.6.md,"
## `argocd app create` for old CLI versions fails with API version >=2.6.7

Starting with Argo CD 2.6.7, the API returns `PermissionDenied` instead of `NotFound` for Application `GET` requests if
the Application does not exist.

The Argo CD CLI before versions starting with version 2.5.0-rc1 and before versions 2.5.16 and 2.6.7 does a `GET`
request before the `POST` request in `argocd app create`. The command does not gracefully handle the `PermissionDenied`
response and will therefore fail to create/update the Application.

To solve the issue, upgrade the CLI to at least 2.5.16, or 2.6.7.

CLIs older than 2.5.0-rc1 are unaffected.
",,3a28c8a18cc2aa84fe81492625545d25c7a90bc3,CVE-2022-41354,3a28c8a18cc2aa84fe81492625545d25c7a90bc3,https://github.com/argoproj/argo-cd,GHSD_DIRECT_COMMIT,1337,COMPLETED," VAR VAR VAR VAR 2.6.7, VAR VAR VAR `VAR` VAR VAR `VAR` VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR 2.5.0-VAR VAR VAR VAR 2.5.16 VAR 2.6.7 VAR VAR `VAR` VAR VAR VAR `VAR` VAR VAR `VAR VAR VAR`. VAR VAR VAR VAR VAR VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR. VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR 2.5.16, VAR 2.6.7. VAR VAR VAR 2.5.0-VAR VAR VAR. ",1
cacti_80c2a88fb2afb93f87703ba4641f9970478c102d,tree.php,"			form_selectable_cell($tree['id'], $tree['id'], '', 'right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'right');","			form_selectable_cell($tree['id'], $tree['id'], '', 'text-align:right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'text-align:right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'text-align:right');",80c2a88fb2afb93f87703ba4641f9970478c102d,CVE-2018-20726,80c2a88fb2afb93f87703ba4641f9970478c102d,https://github.com/Cacti/cacti,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR');",1
cacti_80c2a88fb2afb93f87703ba4641f9970478c102d,tree.php,"			form_selectable_cell($tree['id'], $tree['id'], '', 'right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'right');","			form_selectable_cell($tree['id'], $tree['id'], '', 'text-align:right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'text-align:right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'text-align:right');",80c2a88fb2afb93f87703ba4641f9970478c102d,CVE-2018-20723,80c2a88fb2afb93f87703ba4641f9970478c102d,https://github.com/Cacti/cacti,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR');",1
cacti_80c2a88fb2afb93f87703ba4641f9970478c102d,tree.php,"			form_selectable_cell($tree['id'], $tree['id'], '', 'right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'right');","			form_selectable_cell($tree['id'], $tree['id'], '', 'text-align:right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'text-align:right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'text-align:right');",80c2a88fb2afb93f87703ba4641f9970478c102d,CVE-2018-20725,80c2a88fb2afb93f87703ba4641f9970478c102d,https://github.com/Cacti/cacti,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR');",1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/cilium/Chart.yaml,"version: 1.9.16
appVersion: 1.9.16
icon: https://cdn.jsdelivr.net/gh/cilium/cilium@v1.9.16/Documentation/images/logo-solo.svg","version: 1.9.15
appVersion: 1.9.15
icon: https://cdn.jsdelivr.net/gh/cilium/cilium@v1.9.15/Documentation/images/logo-solo.svg",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29178,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,84,COMPLETED,VAR: 1.9.16 VAR: 1.9.16 VAR: VAR: VAR: 1.9.15 VAR: 1.9.15 VAR: VAR:,1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/cilium/Chart.yaml,"version: 1.9.16
appVersion: 1.9.16
icon: https://cdn.jsdelivr.net/gh/cilium/cilium@v1.9.16/Documentation/images/logo-solo.svg","version: 1.9.15
appVersion: 1.9.15
icon: https://cdn.jsdelivr.net/gh/cilium/cilium@v1.9.15/Documentation/images/logo-solo.svg",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29179,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,68,COMPLETED,VAR: 1.9.16 VAR: 1.9.16 VAR: VAR: VAR: 1.9.15 VAR: 1.9.15 VAR: VAR:,1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/cilium/README.md,"![Version: 1.9.16](https://img.shields.io/badge/Version-1.9.16-informational?style=flat-square) ![AppVersion: 1.9.16](https://img.shields.io/badge/AppVersion-1.9.16-informational?style=flat-square)
| clustermesh.apiserver.image | object | `{""digest"":"""",""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/clustermesh-apiserver"",""tag"":""v1.9.16"",""useDigest"":false}` | Clustermesh API server image. |
| hubble.relay.image | object | `{""digest"":"""",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/hubble-relay"",""tag"":""v1.9.16"",""useDigest"":false}` | Hubble-relay container image. |
| image | object | `{""digest"":"""",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/cilium"",""tag"":""v1.9.16"",""useDigest"":false}` | Agent container image. |
| operator.image | object | `{""awsDigest"":"""",""azureDigest"":"""",""genericDigest"":"""",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/operator"",""suffix"":"""",""tag"":""v1.9.16"",""useDigest"":false}` | cilium-operator image. |
| preflight.image | object | `{""digest"":"""",""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/cilium"",""tag"":""v1.9.16"",""useDigest"":false}` | Cilium pre-flight image. |","![Version: 1.9.15](https://img.shields.io/badge/Version-1.9.15-informational?style=flat-square) ![AppVersion: 1.9.15](https://img.shields.io/badge/AppVersion-1.9.15-informational?style=flat-square)
| clustermesh.apiserver.image | object | `{""digest"":""sha256:59cabe18234077448b3410a1d9f0ffe9c78a41783e83cc3d80310ddd92b81822"",""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/clustermesh-apiserver"",""tag"":""v1.9.15"",""useDigest"":false}` | Clustermesh API server image. |
| hubble.relay.image | object | `{""digest"":""sha256:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322"",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/hubble-relay"",""tag"":""v1.9.15"",""useDigest"":false}` | Hubble-relay container image. |
| image | object | `{""digest"":""sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/cilium"",""tag"":""v1.9.15"",""useDigest"":false}` | Agent container image. |
| operator.image | object | `{""awsDigest"":""sha256:5ab748219bec4ac0a0e971e53e1b1ba6a569114eb6dea78951c2edb8ae460265"",""azureDigest"":""sha256:b1f236b2c9e99d1ed22ea99e7fcb6bd2f86707825b7c3d271715e6cbc29147d4"",""genericDigest"":""sha256:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1"",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/operator"",""suffix"":"""",""tag"":""v1.9.15"",""useDigest"":false}` | cilium-operator image. |
| preflight.image | object | `{""digest"":""sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"",""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/cilium"",""tag"":""v1.9.15"",""useDigest"":false}` | Cilium pre-flight image. |",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29178,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,84,COMPLETED,"![VAR: 1.9.16](VAR: | VAR.VAR.VAR | VAR | `{""VAR"":"""",""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR-VAR"",""VAR"":""VAR.9.16"",""VAR"":VAR}` | VAR VAR VAR VAR. | | VAR.VAR.VAR | VAR | `{""VAR"":"""",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR-VAR"",""VAR"":""VAR.9.16"",""VAR"":VAR}` | VAR-VAR VAR VAR. | | VAR | VAR | `{""VAR"":"""",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":""VAR.9.16"",""VAR"":VAR}` | VAR VAR VAR. | | VAR.VAR | VAR | `{""VAR"":"""",""VAR"":"""",""VAR"":"""",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":"""",""VAR"":""VAR.9.16"",""VAR"":VAR}` | VAR-VAR VAR. | | VAR.VAR | VAR | `{""VAR"":"""",""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":""VAR.9.16"",""VAR"":VAR}` | VAR VAR-VAR VAR. | ![VAR: 1.9.15](VAR: | VAR.VAR.VAR | VAR | `{""VAR"":""VAR:59cabe18234077448b3410a1d9f0ffe9c78a41783e83cc3d80310ddd92b81822"",""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR-VAR"",""VAR"":""VAR.9.15"",""VAR"":VAR}` | VAR VAR VAR VAR. | | VAR.VAR.VAR | VAR | `{""VAR"":""VAR:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322"",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR-VAR"",""VAR"":""VAR.9.15"",""VAR"":VAR}` | VAR-VAR VAR VAR. | | VAR | VAR | `{""VAR"":""VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":""VAR.9.15"",""VAR"":VAR}` | VAR VAR VAR. | | VAR.VAR | VAR | `{""VAR"":""VAR:5ab748219bec4ac0a0e971e53e1b1ba6a569114eb6dea78951c2edb8ae460265"",""VAR"":""VAR:VAR"",""VAR"":""VAR:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1"",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":"""",""VAR"":""VAR.9.15"",""VAR"":VAR}` | VAR-VAR VAR. | | VAR.VAR | VAR | `{""VAR"":""VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"",""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":""VAR.9.15"",""VAR"":VAR}` | VAR VAR-VAR VAR. |",1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/cilium/README.md,"![Version: 1.9.16](https://img.shields.io/badge/Version-1.9.16-informational?style=flat-square) ![AppVersion: 1.9.16](https://img.shields.io/badge/AppVersion-1.9.16-informational?style=flat-square)
| clustermesh.apiserver.image | object | `{""digest"":"""",""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/clustermesh-apiserver"",""tag"":""v1.9.16"",""useDigest"":false}` | Clustermesh API server image. |
| hubble.relay.image | object | `{""digest"":"""",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/hubble-relay"",""tag"":""v1.9.16"",""useDigest"":false}` | Hubble-relay container image. |
| image | object | `{""digest"":"""",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/cilium"",""tag"":""v1.9.16"",""useDigest"":false}` | Agent container image. |
| operator.image | object | `{""awsDigest"":"""",""azureDigest"":"""",""genericDigest"":"""",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/operator"",""suffix"":"""",""tag"":""v1.9.16"",""useDigest"":false}` | cilium-operator image. |
| preflight.image | object | `{""digest"":"""",""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/cilium"",""tag"":""v1.9.16"",""useDigest"":false}` | Cilium pre-flight image. |","![Version: 1.9.15](https://img.shields.io/badge/Version-1.9.15-informational?style=flat-square) ![AppVersion: 1.9.15](https://img.shields.io/badge/AppVersion-1.9.15-informational?style=flat-square)
| clustermesh.apiserver.image | object | `{""digest"":""sha256:59cabe18234077448b3410a1d9f0ffe9c78a41783e83cc3d80310ddd92b81822"",""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/clustermesh-apiserver"",""tag"":""v1.9.15"",""useDigest"":false}` | Clustermesh API server image. |
| hubble.relay.image | object | `{""digest"":""sha256:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322"",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/hubble-relay"",""tag"":""v1.9.15"",""useDigest"":false}` | Hubble-relay container image. |
| image | object | `{""digest"":""sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/cilium"",""tag"":""v1.9.15"",""useDigest"":false}` | Agent container image. |
| operator.image | object | `{""awsDigest"":""sha256:5ab748219bec4ac0a0e971e53e1b1ba6a569114eb6dea78951c2edb8ae460265"",""azureDigest"":""sha256:b1f236b2c9e99d1ed22ea99e7fcb6bd2f86707825b7c3d271715e6cbc29147d4"",""genericDigest"":""sha256:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1"",""override"":null,""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/operator"",""suffix"":"""",""tag"":""v1.9.15"",""useDigest"":false}` | cilium-operator image. |
| preflight.image | object | `{""digest"":""sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"",""pullPolicy"":""IfNotPresent"",""repository"":""quay.io/cilium/cilium"",""tag"":""v1.9.15"",""useDigest"":false}` | Cilium pre-flight image. |",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29179,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,68,COMPLETED,"![VAR: 1.9.16](VAR: | VAR.VAR.VAR | VAR | `{""VAR"":"""",""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR-VAR"",""VAR"":""VAR.9.16"",""VAR"":VAR}` | VAR VAR VAR VAR. | | VAR.VAR.VAR | VAR | `{""VAR"":"""",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR-VAR"",""VAR"":""VAR.9.16"",""VAR"":VAR}` | VAR-VAR VAR VAR. | | VAR | VAR | `{""VAR"":"""",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":""VAR.9.16"",""VAR"":VAR}` | VAR VAR VAR. | | VAR.VAR | VAR | `{""VAR"":"""",""VAR"":"""",""VAR"":"""",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":"""",""VAR"":""VAR.9.16"",""VAR"":VAR}` | VAR-VAR VAR. | | VAR.VAR | VAR | `{""VAR"":"""",""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":""VAR.9.16"",""VAR"":VAR}` | VAR VAR-VAR VAR. | ![VAR: 1.9.15](VAR: | VAR.VAR.VAR | VAR | `{""VAR"":""VAR:59cabe18234077448b3410a1d9f0ffe9c78a41783e83cc3d80310ddd92b81822"",""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR-VAR"",""VAR"":""VAR.9.15"",""VAR"":VAR}` | VAR VAR VAR VAR. | | VAR.VAR.VAR | VAR | `{""VAR"":""VAR:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322"",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR-VAR"",""VAR"":""VAR.9.15"",""VAR"":VAR}` | VAR-VAR VAR VAR. | | VAR | VAR | `{""VAR"":""VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":""VAR.9.15"",""VAR"":VAR}` | VAR VAR VAR. | | VAR.VAR | VAR | `{""VAR"":""VAR:5ab748219bec4ac0a0e971e53e1b1ba6a569114eb6dea78951c2edb8ae460265"",""VAR"":""VAR:VAR"",""VAR"":""VAR:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1"",""VAR"":VAR,""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":"""",""VAR"":""VAR.9.15"",""VAR"":VAR}` | VAR-VAR VAR. | | VAR.VAR | VAR | `{""VAR"":""VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"",""VAR"":""VAR"",""VAR"":""VAR.VAR/VAR/VAR"",""VAR"":""VAR.9.15"",""VAR"":VAR}` | VAR VAR-VAR VAR. |",1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/cilium/values.yaml,"  tag: v1.9.16
  digest: """"
      tag: v1.9.16
      digest: """"
    tag: v1.9.16
    genericDigest: """"
    azureDigest: """"
    awsDigest: """"
    tag: v1.9.16
    digest: """"
      tag: v1.9.16
      digest: """"","  tag: v1.9.15
  digest: ""sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
      tag: v1.9.15
      digest: ""sha256:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322""
    tag: v1.9.15
    genericDigest: ""sha256:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1""
    azureDigest: ""sha256:b1f236b2c9e99d1ed22ea99e7fcb6bd2f86707825b7c3d271715e6cbc29147d4""
    awsDigest: ""sha256:5ab748219bec4ac0a0e971e53e1b1ba6a569114eb6dea78951c2edb8ae460265""
    tag: v1.9.15
    digest: ""sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
      tag: v1.9.15
      digest: ""sha256:59cabe18234077448b3410a1d9f0ffe9c78a41783e83cc3d80310ddd92b81822""",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29178,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,84,COMPLETED,"VAR: VAR.9.16 VAR: """" VAR: VAR.9.16 VAR: """" VAR: VAR.9.16 VAR: """" VAR: """" VAR: """" VAR: VAR.9.16 VAR: """" VAR: VAR.9.16 VAR: """" VAR: VAR.9.15 VAR: ""VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: VAR.9.15 VAR: ""VAR:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322"" VAR: VAR.9.15 VAR: ""VAR:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1"" VAR: ""VAR:VAR"" VAR: ""VAR:5ab748219bec4ac0a0e971e53e1b1ba6a569114eb6dea78951c2edb8ae460265"" VAR: VAR.9.15 VAR: ""VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: VAR.9.15 VAR: ""VAR:59cabe18234077448b3410a1d9f0ffe9c78a41783e83cc3d80310ddd92b81822""",1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/cilium/values.yaml,"  tag: v1.9.16
  digest: """"
      tag: v1.9.16
      digest: """"
    tag: v1.9.16
    genericDigest: """"
    azureDigest: """"
    awsDigest: """"
    tag: v1.9.16
    digest: """"
      tag: v1.9.16
      digest: """"","  tag: v1.9.15
  digest: ""sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
      tag: v1.9.15
      digest: ""sha256:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322""
    tag: v1.9.15
    genericDigest: ""sha256:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1""
    azureDigest: ""sha256:b1f236b2c9e99d1ed22ea99e7fcb6bd2f86707825b7c3d271715e6cbc29147d4""
    awsDigest: ""sha256:5ab748219bec4ac0a0e971e53e1b1ba6a569114eb6dea78951c2edb8ae460265""
    tag: v1.9.15
    digest: ""sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
      tag: v1.9.15
      digest: ""sha256:59cabe18234077448b3410a1d9f0ffe9c78a41783e83cc3d80310ddd92b81822""",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29179,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,68,COMPLETED,"VAR: VAR.9.16 VAR: """" VAR: VAR.9.16 VAR: """" VAR: VAR.9.16 VAR: """" VAR: """" VAR: """" VAR: VAR.9.16 VAR: """" VAR: VAR.9.16 VAR: """" VAR: VAR.9.15 VAR: ""VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: VAR.9.15 VAR: ""VAR:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322"" VAR: VAR.9.15 VAR: ""VAR:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1"" VAR: ""VAR:VAR"" VAR: ""VAR:5ab748219bec4ac0a0e971e53e1b1ba6a569114eb6dea78951c2edb8ae460265"" VAR: VAR.9.15 VAR: ""VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: VAR.9.15 VAR: ""VAR:59cabe18234077448b3410a1d9f0ffe9c78a41783e83cc3d80310ddd92b81822""",1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/experimental-install.yaml,"        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/operator-generic:v1.9.16""
          image: ""quay.io/cilium/hubble-relay:v1.9.16""","        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/operator-generic:v1.9.15@sha256:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1""
          image: ""quay.io/cilium/hubble-relay:v1.9.15@sha256:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322""",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29178,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,84,COMPLETED,"VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.15@VAR:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.15@VAR:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322""",1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/experimental-install.yaml,"        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/operator-generic:v1.9.16""
          image: ""quay.io/cilium/hubble-relay:v1.9.16""","        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/operator-generic:v1.9.15@sha256:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1""
          image: ""quay.io/cilium/hubble-relay:v1.9.15@sha256:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322""",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29179,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,68,COMPLETED,"VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.15@VAR:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.15@VAR:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322""",1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/quick-hubble-install.yaml,"          image: ""quay.io/cilium/hubble-relay:v1.9.16""","          image: ""quay.io/cilium/hubble-relay:v1.9.15@sha256:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322""",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29178,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,84,COMPLETED,"VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.15@VAR:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322""",1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/quick-hubble-install.yaml,"          image: ""quay.io/cilium/hubble-relay:v1.9.16""","          image: ""quay.io/cilium/hubble-relay:v1.9.15@sha256:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322""",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29179,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,68,COMPLETED,"VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.15@VAR:748813e49877d66614d947495972f32b7f9675e9c327578c0ea81ca4f7adf322""",1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/quick-install.yaml,"        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/operator-generic:v1.9.16""","        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/operator-generic:v1.9.15@sha256:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1""",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29178,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,84,COMPLETED,"VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.15@VAR:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1""",1
cilium_33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,install/kubernetes/quick-install.yaml,"        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/cilium:v1.9.16""
        image: ""quay.io/cilium/operator-generic:v1.9.16""","        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/cilium:v1.9.15@sha256:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce""
        image: ""quay.io/cilium/operator-generic:v1.9.15@sha256:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1""",33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,CVE-2022-29179,33d1941c97201b4d7f4b4f6efc2d1c071f5c2cfe,https://github.com/cilium/cilium,NVD_GIT_REPOBASED,68,COMPLETED,"VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.16"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR:VAR.9.15@VAR:20c0f6cedc09a880d76695e7ac70755a662c4bddf6d5197cf609ffe499ab72ce"" VAR: ""VAR.VAR/VAR/VAR-VAR:VAR.9.15@VAR:5f38912e638b96377f905369035e0afc89b45f24f7f27565b520f3573c4411f1""",1
cpython_225e3659556616ad70186e7efc02baeebfeb5ec4,Litest/test_plistlib.py,"import struct
INVALID_BINARY_PLISTS = [
    ('too short data',
        b''
    ),
    ('too large offset_table_offset and offset_size = 1',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x2a'
    ),
    ('too large offset_table_offset and nonstandard offset_size',
        b'\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x03\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x2c'
    ),
    ('integer overflow in offset_table_offset',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\xff\xff\xff\xff\xff\xff\xff\xff'
    ),
    ('too large top_object',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('integer overflow in top_object',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\xff\xff\xff\xff\xff\xff\xff\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('too large num_objects and offset_size = 1',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('too large num_objects and nonstandard offset_size',
        b'\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x03\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('extremally large num_objects (32 bit)',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x7f\xff\xff\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('extremally large num_objects (64 bit)',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\xff\xff\xff\xff\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('integer overflow in num_objects',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\xff\xff\xff\xff\xff\xff\xff\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('offset_size = 0',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('ref_size = 0',
        b'\xa1\x01\x00\x08\x0a'
        b'\x00\x00\x00\x00\x00\x00\x01\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0b'
    ),
    ('too large offset',
        b'\x00\x2a'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('integer overflow in offset',
        b'\x00\xff\xff\xff\xff\xff\xff\xff\xff'
        b'\x00\x00\x00\x00\x00\x00\x08\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('too large array size',
        b'\xaf\x00\x01\xff\x00\x08\x0c'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0d'
    ),
    ('extremally large array size (32-bit)',
        b'\xaf\x02\x7f\xff\xff\xff\x01\x00\x08\x0f'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x10'
    ),
    ('extremally large array size (64-bit)',
        b'\xaf\x03\x00\x00\x00\xff\xff\xff\xff\xff\x01\x00\x08\x13'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x14'
    ),
    ('integer overflow in array size',
        b'\xaf\x03\xff\xff\xff\xff\xff\xff\xff\xff\x01\x00\x08\x13'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x14'
    ),
    ('too large reference index',
        b'\xa1\x02\x00\x08\x0a'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0b'
    ),
    ('integer overflow in reference index',
        b'\xa1\xff\xff\xff\xff\xff\xff\xff\xff\x00\x08\x11'
        b'\x00\x00\x00\x00\x00\x00\x01\x08'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x12'
    ),
    ('too large bytes size',
        b'\x4f\x00\x23\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0c'
    ),
    ('extremally large bytes size (32-bit)',
        b'\x4f\x02\x7f\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0f'
    ),
    ('extremally large bytes size (64-bit)',
        b'\x4f\x03\x00\x00\x00\xff\xff\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x13'
    ),
    ('integer overflow in bytes size',
        b'\x4f\x03\xff\xff\xff\xff\xff\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x13'
    ),
    ('too large ASCII size',
        b'\x5f\x00\x23\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0c'
    ),
    ('extremally large ASCII size (32-bit)',
        b'\x5f\x02\x7f\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0f'
    ),
    ('extremally large ASCII size (64-bit)',
        b'\x5f\x03\x00\x00\x00\xff\xff\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x13'
    ),
    ('integer overflow in ASCII size',
        b'\x5f\x03\xff\xff\xff\xff\xff\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x13'
    ),
    ('invalid ASCII',
        b'\x51\xff\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0a'
    ),
    ('too large UTF-16 size',
        b'\x6f\x00\x13\x20\xac\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0e'
    ),
    ('extremally large UTF-16 size (32-bit)',
        b'\x6f\x02\x4f\xff\xff\xff\x20\xac\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x11'
    ),
    ('extremally large UTF-16 size (64-bit)',
        b'\x6f\x03\x00\x00\x00\xff\xff\xff\xff\xff\x20\xac\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x15'
    ),
    ('integer overflow in UTF-16 size',
        b'\x6f\x03\xff\xff\xff\xff\xff\xff\xff\xff\x20\xac\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x15'
    ),
    ('invalid UTF-16',
        b'\x61\xd8\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0b'
    ),
    ('non-hashable key',
        b'\xd1\x01\x01\xa0\x08\x0b'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0c'
    ),
    ('too large datetime (datetime overflow)',
        b'\x33\x42\x50\x00\x00\x00\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x11'
    ),
    ('too large datetime (timedelta overflow)',
        b'\x33\x42\xe0\x00\x00\x00\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x11'
    ),
    ('invalid datetime (Infinity)',
        b'\x33\x7f\xf0\x00\x00\x00\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x11'
    ),
    ('invalid datetime (NaN)',
        b'\x33\x7f\xf8\x00\x00\x00\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x11'
    ),
]

    @staticmethod
    def decode(*objects, offset_size=1, ref_size=1):
        data = [b'bplist00']
        offset = 8
        offsets = []
        for x in objects:
            offsets.append(offset.to_bytes(offset_size, 'big'))
            data.append(x)
            offset += len(x)
        tail = struct.pack('>6xBBQQQ', offset_size, ref_size,
                           len(objects), 0, offset)
        data.extend(offsets)
        data.append(tail)
        return plistlib.loads(b''.join(data), fmt=plistlib.FMT_BINARY)

        for x in (None, False, True, 12345, 123.45, 'abcde', '', b'abcde',
    def test_deep_nesting(self):
        for N in [300, 100000]:
            chunks = [b'\xa1' + (i + 1).to_bytes(4, 'big') for i in range(N)]
            try:
                result = self.decode(*chunks, b'\x54seed', offset_size=4, ref_size=4)
            except RecursionError:
                pass
            else:
                for i in range(N):
                    self.assertIsInstance(result, list)
                    self.assertEqual(len(result), 1)
                    result = result[0]
                self.assertEqual(result, 'seed')

    def test_load_singletons(self):
        self.assertIs(self.decode(b'\x00'), None)
        self.assertIs(self.decode(b'\x08'), False)
        self.assertIs(self.decode(b'\x09'), True)
        self.assertEqual(self.decode(b'\x0f'), b'')

    def test_load_int(self):
        self.assertEqual(self.decode(b'\x10\x00'), 0)
        self.assertEqual(self.decode(b'\x10\xfe'), 0xfe)
        self.assertEqual(self.decode(b'\x11\xfe\xdc'), 0xfedc)
        self.assertEqual(self.decode(b'\x12\xfe\xdc\xba\x98'), 0xfedcba98)
        self.assertEqual(self.decode(b'\x13\x01\x23\x45\x67\x89\xab\xcd\xef'),
                         0x0123456789abcdef)
        self.assertEqual(self.decode(b'\x13\xfe\xdc\xba\x98\x76\x54\x32\x10'),
                         -0x123456789abcdf0)

    def test_unsupported(self):
        unsupported = [*range(1, 8), *range(10, 15),
                       0x20, 0x21, *range(0x24, 0x33), *range(0x34, 0x40)]
        for i in [0x70, 0x90, 0xb0, 0xc0, 0xe0, 0xf0]:
            unsupported.extend(i + j for j in range(16))
        for token in unsupported:
            with self.subTest(f'token {token:02x}'):
                with self.assertRaises(plistlib.InvalidFileException):
                    self.decode(bytes([token]) + b'\x00'*16)

        for name, data in INVALID_BINARY_PLISTS:
            with self.subTest(name):
                with self.assertRaises(plistlib.InvalidFileException):
                    plistlib.loads(b'bplist00' + data, fmt=plistlib.FMT_BINARY)
    unittest.main()","        for x in (None, False, True, 12345, 123.45, 'abcde', b'abcde',
        for data in [
                # too short data
                b'',
                # too large offset_table_offset and nonstandard offset_size
                b'\x00\x08'
                b'\x00\x00\x00\x00\x00\x00\x03\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x2a',
                # integer overflow in offset_table_offset
                b'\x00\x08'
                b'\x00\x00\x00\x00\x00\x00\x01\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\xff\xff\xff\xff\xff\xff\xff\xff',
                # offset_size = 0
                b'\x00\x08'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x09',
                # ref_size = 0
                b'\xa1\x01\x00\x08\x0a'
                b'\x00\x00\x00\x00\x00\x00\x01\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x02'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x0b',
                # integer overflow in offset
                b'\x00\xff\xff\xff\xff\xff\xff\xff\xff'
                b'\x00\x00\x00\x00\x00\x00\x08\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x09',
                # invalid ASCII
                b'\x51\xff\x08'
                b'\x00\x00\x00\x00\x00\x00\x01\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x0a',
                # invalid UTF-16
                b'\x61\xd8\x00\x08'
                b'\x00\x00\x00\x00\x00\x00\x01\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x0b',
                ]:
            with self.assertRaises(plistlib.InvalidFileException):
                plistlib.loads(b'bplist00' + data, fmt=plistlib.FMT_BINARY)
def test_main():
    support.run_unittest(TestPlistlib, TestPlistlibDeprecated, MiscTestCase)


    test_main()",225e3659556616ad70186e7efc02baeebfeb5ec4,CVE-2022-48564,225e3659556616ad70186e7efc02baeebfeb5ec4,https://github.com/python/cpython,CPE_GIT_REPOBASED,128,COMPLETED,"VAR VAR VAR = [ ('VAR VAR VAR', VAR'' ), ('VAR VAR VAR VAR VAR = 1', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR = 1', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR (32 VAR)', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR (64 VAR)', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR = 0', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR = 0', VAR'\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (32-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (64-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (32-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (64-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (32-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (64-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR', VAR'\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR-16 VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR-16 VAR (32-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR-16 VAR (64-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR-16 VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR-16', VAR'\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR-VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR (VAR VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR (VAR VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR (VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR (VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ] @VAR VAR VAR(*VAR, VAR=1, VAR=1): VAR = [VAR'VAR'] VAR = 8 VAR = [] VAR VAR VAR VAR: VAR.VAR(VAR.VAR(VAR, 'VAR')) VAR.VAR(VAR) VAR += VAR(VAR) VAR = VAR.VAR('>6xBBQQQ', VAR, VAR, VAR(VAR), 0, VAR) VAR.VAR(VAR) VAR.VAR(VAR) VAR VAR.VAR(VAR''.VAR(VAR), VAR=VAR.VAR) VAR VAR VAR (VAR, VAR, VAR, 12345, 123.45, 'VAR', '', VAR'VAR', VAR VAR(VAR): VAR VAR VAR [300, 100000]: VAR = [VAR'\VAR' + (VAR + 1).VAR(4, 'VAR') VAR VAR VAR VAR(VAR)] VAR: VAR = VAR.VAR(*VAR, VAR'\VAR', VAR=4, VAR=4) VAR VAR: VAR VAR: VAR VAR VAR VAR(VAR): VAR.VAR(VAR, VAR) VAR.VAR(VAR(VAR), 1) VAR = VAR[0] VAR.VAR(VAR, 'VAR') VAR VAR(VAR): VAR.VAR(VAR.VAR(VAR'\VAR'), VAR) VAR.VAR(VAR.VAR(VAR'\VAR'), VAR) VAR.VAR(VAR.VAR(VAR'\VAR'), VAR) VAR.VAR(VAR.VAR(VAR'\VAR'), VAR'') VAR VAR(VAR): VAR.VAR(VAR.VAR(VAR'\VAR\VAR'), 0) VAR.VAR(VAR.VAR(VAR'\VAR\VAR'), 0xfe) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR'), 0xfedc) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR'), 0xfedcba98) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR'), 0x0123456789abcdef) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR'), -0x123456789abcdf0) VAR VAR(VAR): VAR = [*VAR(1, 8), *VAR(10, 15), 0x20, 0x21, *VAR(0x24, 0x33), *VAR(0x34, 0x40)] VAR VAR VAR [0x70, 0x90, 0xb0, 0xc0, 0xe0, 0xf0]: VAR.VAR(VAR + VAR VAR VAR VAR VAR(16)) VAR VAR VAR VAR: VAR VAR.VAR(VAR'VAR {VAR:02x}'): VAR VAR.VAR(VAR.VAR): VAR.VAR(VAR([VAR]) + VAR'\VAR'*16) VAR VAR, VAR VAR VAR: VAR VAR.VAR(VAR): VAR VAR.VAR(VAR.VAR): VAR.VAR(VAR'VAR' + VAR, VAR=VAR.VAR) VAR.VAR() VAR VAR VAR (VAR, VAR, VAR, 12345, 123.45, 'VAR', VAR'VAR', VAR VAR VAR [  VAR'',  VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR', ]: VAR VAR.VAR(VAR.VAR): VAR.VAR(VAR'VAR' + VAR, VAR=VAR.VAR) VAR VAR(): VAR.VAR(VAR, VAR, VAR) VAR()",1
cpython_511ca9452033ef95bc7d7fc404b8161068226002,Python/initconfig.c,"#include ""pycore_long.h""          // _PY_LONG_MAX_STR_DIGITS_THRESHOLD
   The default is \""on\"" (or \""off\"" if you are running a local build).\n\
\n\
-X int_max_str_digits=number: limit the size of int<->str conversions.\n\
    This helps avoid denial of service attacks when parsing untrusted data.\n\
    The default is sys.int_info.default_max_str_digits.  0 disables."";
""PYTHONINTMAXSTRDIGITS: limits the maximum digit characters in an int value\n""
""   when converting from a string and when converting an int back to a str.\n""
""   A value of 0 disables the limit.  Conversions to or from bases 2, 4, 8,\n""
""   16, and 32 are never limited.\n""
/* Excluded from public struct PyConfig for backporting reasons. */
/* default to unconfigured, _PyLong_InitTypes() does the rest */
int _Py_global_config_int_max_str_digits = -1;

static PyStatus
config_init_int_max_str_digits(PyConfig *config)
{
    int maxdigits;
    int valid = 0;

    const char *env = config_get_env(config, ""PYTHONINTMAXSTRDIGITS"");
    if (env) {
        if (!_Py_str_to_int(env, &maxdigits)) {
            valid = ((maxdigits == 0) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD));
        }
        if (!valid) {
#define STRINGIFY(VAL) _STRINGIFY(VAL)
#define _STRINGIFY(VAL) #VAL
            return _PyStatus_ERR(
                    ""PYTHONINTMAXSTRDIGITS: invalid limit; must be >= ""
                    STRINGIFY(_PY_LONG_MAX_STR_DIGITS_THRESHOLD)
                    "" or 0 for unlimited."");
        }
        _Py_global_config_int_max_str_digits = maxdigits;
    }

    const wchar_t *xoption = config_get_xoption(config, L""int_max_str_digits"");
    if (xoption) {
        const wchar_t *sep = wcschr(xoption, L'=');
        if (sep) {
            if (!config_wstr_to_int(sep + 1, &maxdigits)) {
                valid = ((maxdigits == 0) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD));
            }
        }
        if (!valid) {
            return _PyStatus_ERR(
                    ""-X int_max_str_digits: invalid limit; must be >= ""
                    STRINGIFY(_PY_LONG_MAX_STR_DIGITS_THRESHOLD)
                    "" or 0 for unlimited."");
#undef _STRINGIFY
#undef STRINGIFY
        }
        _Py_global_config_int_max_str_digits = maxdigits;
    }
    return _PyStatus_OK();
}

    if (_Py_global_config_int_max_str_digits < 0) {
        status = config_init_int_max_str_digits(config);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
    }
","   The default is \""on\"" (or \""off\"" if you are running a local build)."";",511ca9452033ef95bc7d7fc404b8161068226002,CVE-2020-10735,511ca9452033ef95bc7d7fc404b8161068226002,https://github.com/python/cpython,NVD_GIT_REPOBASED,186,COMPLETED," VAR VAR VAR \""VAR\"" (VAR \""VAR\"" VAR VAR VAR VAR VAR VAR VAR).\VAR\ \VAR\ -VAR VAR=VAR: VAR VAR VAR VAR VAR<->VAR VAR.\VAR\ VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.\VAR\ VAR VAR VAR VAR.VAR.VAR. 0 VAR.""; ""VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR\VAR"" "" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.\VAR"" "" VAR VAR VAR 0 VAR VAR VAR. VAR VAR VAR VAR VAR 2, 4, 8,\VAR"" "" 16, VAR 32 VAR VAR VAR.\VAR""   VAR VAR = -1; VAR VAR VAR(VAR *VAR) { VAR VAR; VAR VAR = 0; VAR VAR *VAR = VAR(VAR, ""VAR""); VAR (VAR) { VAR (!VAR(VAR, &VAR)) { VAR = ((VAR == 0) || (VAR >= VAR)); } VAR (!VAR) {   VAR VAR( ""VAR: VAR VAR; VAR VAR >= "" VAR(VAR) "" VAR 0 VAR VAR.""); } VAR = VAR; } VAR VAR *VAR = VAR(VAR, VAR""VAR""); VAR (VAR) { VAR VAR *VAR = VAR(VAR, VAR'='); VAR (VAR) { VAR (!VAR(VAR + 1, &VAR)) { VAR = ((VAR == 0) || (VAR >= VAR)); } } VAR (!VAR) { VAR VAR( ""-VAR VAR: VAR VAR; VAR VAR >= "" VAR(VAR) "" VAR 0 VAR VAR."");   } VAR = VAR; } VAR VAR(); } VAR (VAR < 0) { VAR = VAR(VAR); VAR (VAR(VAR)) { VAR VAR; } } VAR VAR VAR \""VAR\"" (VAR \""VAR\"" VAR VAR VAR VAR VAR VAR VAR)."";",1
cpython_8f0fa4bd10aba723aff988720cd26b93be99bc12,Python/initconfig.c,"#include ""pycore_long.h""          // _PY_LONG_MAX_STR_DIGITS_THRESHOLD
         -X int_max_str_digits=number: limit the size of int<->str conversions.\n\
             This helps avoid denial of service attacks when parsing untrusted data.\n\
             The default is sys.int_info.default_max_str_digits.  0 disables.\n\
\n\
""PYTHONINTMAXSTRDIGITS: limits the maximum digit characters in an int value\n""
""   when converting from a string and when converting an int back to a str.\n""
""   A value of 0 disables the limit.  Conversions to or from bases 2, 4, 8,\n""
""   16, and 32 are never limited.\n""
/* Excluded from public struct PyConfig for backporting reasons. */
/* default to unconfigured, _PyLong_InitTypes() does the rest */
int _Py_global_config_int_max_str_digits = -1;

static PyStatus
config_init_int_max_str_digits(PyConfig *config)
{
    int maxdigits;
    int valid = 0;

    const char *env = config_get_env(config, ""PYTHONINTMAXSTRDIGITS"");
    if (env) {
        if (!_Py_str_to_int(env, &maxdigits)) {
            valid = ((maxdigits == 0) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD));
        }
        if (!valid) {
#define STRINGIFY(VAL) _STRINGIFY(VAL)
#define _STRINGIFY(VAL) #VAL
            return _PyStatus_ERR(
                    ""PYTHONINTMAXSTRDIGITS: invalid limit; must be >= ""
                    STRINGIFY(_PY_LONG_MAX_STR_DIGITS_THRESHOLD)
                    "" or 0 for unlimited."");
        }
        _Py_global_config_int_max_str_digits = maxdigits;
    }

    const wchar_t *xoption = config_get_xoption(config, L""int_max_str_digits"");
    if (xoption) {
        const wchar_t *sep = wcschr(xoption, L'=');
        if (sep) {
            if (!config_wstr_to_int(sep + 1, &maxdigits)) {
                valid = ((maxdigits == 0) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD));
            }
        }
        if (!valid) {
            return _PyStatus_ERR(
                    ""-X int_max_str_digits: invalid limit; must be >= ""
                    STRINGIFY(_PY_LONG_MAX_STR_DIGITS_THRESHOLD)
                    "" or 0 for unlimited."");
#undef _STRINGIFY
#undef STRINGIFY
        }
        _Py_global_config_int_max_str_digits = maxdigits;
    }
    return _PyStatus_OK();
}
    if (_Py_global_config_int_max_str_digits < 0) {
        status = config_init_int_max_str_digits(config);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
    }",,8f0fa4bd10aba723aff988720cd26b93be99bc12,CVE-2020-10735,8f0fa4bd10aba723aff988720cd26b93be99bc12,https://github.com/python/cpython,NVD_GIT_REPOBASED,186,COMPLETED," -VAR VAR=VAR: VAR VAR VAR VAR VAR<->VAR VAR.\VAR\ VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.\VAR\ VAR VAR VAR VAR.VAR.VAR. 0 VAR.\VAR\ \VAR\ ""VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR\VAR"" "" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.\VAR"" "" VAR VAR VAR 0 VAR VAR VAR. VAR VAR VAR VAR VAR 2, 4, 8,\VAR"" "" 16, VAR 32 VAR VAR VAR.\VAR""   VAR VAR = -1; VAR VAR VAR(VAR *VAR) { VAR VAR; VAR VAR = 0; VAR VAR *VAR = VAR(VAR, ""VAR""); VAR (VAR) { VAR (!VAR(VAR, &VAR)) { VAR = ((VAR == 0) || (VAR >= VAR)); } VAR (!VAR) {   VAR VAR( ""VAR: VAR VAR; VAR VAR >= "" VAR(VAR) "" VAR 0 VAR VAR.""); } VAR = VAR; } VAR VAR *VAR = VAR(VAR, VAR""VAR""); VAR (VAR) { VAR VAR *VAR = VAR(VAR, VAR'='); VAR (VAR) { VAR (!VAR(VAR + 1, &VAR)) { VAR = ((VAR == 0) || (VAR >= VAR)); } } VAR (!VAR) { VAR VAR( ""-VAR VAR: VAR VAR; VAR VAR >= "" VAR(VAR) "" VAR 0 VAR VAR."");   } VAR = VAR; } VAR VAR(); } VAR (VAR < 0) { VAR = VAR(VAR); VAR (VAR(VAR)) { VAR VAR; } } ",1
cpython_cec1e9dfd769bd3a16142d0fdd1a36f19c77ed15,Python/initconfig.c,"#include ""pycore_long.h""          // _PY_LONG_MAX_STR_DIGITS_THRESHOLD
         -X int_max_str_digits=number: limit the size of int<->str conversions.\n\
             This helps avoid denial of service attacks when parsing untrusted data.\n\
             The default is sys.int_info.default_max_str_digits.  0 disables.\n\
""PYTHONINTMAXSTRDIGITS: limits the maximum digit characters in an int value\n""
""   when converting from a string and when converting an int back to a str.\n""
""   A value of 0 disables the limit.  Conversions to or from bases 2, 4, 8,\n""
""   16, and 32 are never limited.\n""
/* Excluded from public struct PyConfig for backporting reasons. */
/* default to unconfigured, _PyLong_Init() does the rest */
int _Py_global_config_int_max_str_digits = -1;

static PyStatus
config_init_int_max_str_digits(PyConfig *config)
{
    int maxdigits;
    int valid = 0;

    const char *env = config_get_env(config, ""PYTHONINTMAXSTRDIGITS"");
    if (env) {
        if (!_Py_str_to_int(env, &maxdigits)) {
            valid = ((maxdigits == 0) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD));
        }
        if (!valid) {
#define STRINGIFY(VAL) _STRINGIFY(VAL)
#define _STRINGIFY(VAL) #VAL
            return _PyStatus_ERR(
                    ""PYTHONINTMAXSTRDIGITS: invalid limit; must be >= ""
                    STRINGIFY(_PY_LONG_MAX_STR_DIGITS_THRESHOLD)
                    "" or 0 for unlimited."");
        }
        _Py_global_config_int_max_str_digits = maxdigits;
    }

    const wchar_t *xoption = config_get_xoption(config, L""int_max_str_digits"");
    if (xoption) {
        const wchar_t *sep = wcschr(xoption, L'=');
        if (sep) {
            if (!config_wstr_to_int(sep + 1, &maxdigits)) {
                valid = ((maxdigits == 0) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD));
            }
        }
        if (!valid) {
            return _PyStatus_ERR(
                    ""-X int_max_str_digits: invalid limit; must be >= ""
                    STRINGIFY(_PY_LONG_MAX_STR_DIGITS_THRESHOLD)
                    "" or 0 for unlimited."");
#undef _STRINGIFY
#undef STRINGIFY
        }
        _Py_global_config_int_max_str_digits = maxdigits;
    }
    return _PyStatus_OK();
}
    if (_Py_global_config_int_max_str_digits < 0) {
        status = config_init_int_max_str_digits(config);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
    }",,cec1e9dfd769bd3a16142d0fdd1a36f19c77ed15,CVE-2020-10735,cec1e9dfd769bd3a16142d0fdd1a36f19c77ed15,https://github.com/python/cpython,NVD_GIT_REPOBASED,186,COMPLETED," -VAR VAR=VAR: VAR VAR VAR VAR VAR<->VAR VAR.\VAR\ VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.\VAR\ VAR VAR VAR VAR.VAR.VAR. 0 VAR.\VAR\ ""VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR\VAR"" "" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.\VAR"" "" VAR VAR VAR 0 VAR VAR VAR. VAR VAR VAR VAR VAR 2, 4, 8,\VAR"" "" 16, VAR 32 VAR VAR VAR.\VAR""   VAR VAR = -1; VAR VAR VAR(VAR *VAR) { VAR VAR; VAR VAR = 0; VAR VAR *VAR = VAR(VAR, ""VAR""); VAR (VAR) { VAR (!VAR(VAR, &VAR)) { VAR = ((VAR == 0) || (VAR >= VAR)); } VAR (!VAR) {   VAR VAR( ""VAR: VAR VAR; VAR VAR >= "" VAR(VAR) "" VAR 0 VAR VAR.""); } VAR = VAR; } VAR VAR *VAR = VAR(VAR, VAR""VAR""); VAR (VAR) { VAR VAR *VAR = VAR(VAR, VAR'='); VAR (VAR) { VAR (!VAR(VAR + 1, &VAR)) { VAR = ((VAR == 0) || (VAR >= VAR)); } } VAR (!VAR) { VAR VAR( ""-VAR VAR: VAR VAR; VAR VAR >= "" VAR(VAR) "" VAR 0 VAR VAR."");   } VAR = VAR; } VAR VAR(); } VAR (VAR < 0) { VAR = VAR(VAR); VAR (VAR(VAR)) { VAR VAR; } } ",1
cpython_cec1e9dfd769bd3a16142d0fdd1a36f19c77ed15,Python/sysmodule.c,"#include ""pycore_long.h""          // _PY_LONG_MAX_STR_DIGITS_THRESHOLD

/*[clinic input]
sys.get_int_max_str_digits

Set the maximum string digits limit for non-binary int<->str conversions.
[clinic start generated code]*/

static PyObject *
sys_get_int_max_str_digits_impl(PyObject *module)
/*[clinic end generated code: output=0042f5e8ae0e8631 input=8dab13e2023e60d5]*/
{
    PyInterpreterState *interp = _PyInterpreterState_GET();
    return PyLong_FromSsize_t(interp->int_max_str_digits);
}

/*[clinic input]
sys.set_int_max_str_digits

    maxdigits: int

Set the maximum string digits limit for non-binary int<->str conversions.
[clinic start generated code]*/

static PyObject *
sys_set_int_max_str_digits_impl(PyObject *module, int maxdigits)
/*[clinic end generated code: output=734d4c2511f2a56d input=d7e3f325db6910c5]*/
{
    PyThreadState *tstate = _PyThreadState_GET();
    if ((!maxdigits) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD)) {
        tstate->interp->int_max_str_digits = maxdigits;
        Py_RETURN_NONE;
    } else {
        PyErr_Format(
            PyExc_ValueError, ""maxdigits must be 0 or larger than %d"",
            _PY_LONG_MAX_STR_DIGITS_THRESHOLD);
        return NULL;
    }
}

    SYS_GET_INT_MAX_STR_DIGITS_METHODDEF
    SYS_SET_INT_MAX_STR_DIGITS_METHODDEF
    {""int_max_str_digits"",      ""-X int_max_str_digits""},
    16
    SetFlag(_Py_global_config_int_max_str_digits);",    15,cec1e9dfd769bd3a16142d0fdd1a36f19c77ed15,CVE-2020-10735,cec1e9dfd769bd3a16142d0fdd1a36f19c77ed15,https://github.com/python/cpython,NVD_GIT_REPOBASED,186,COMPLETED," /*[VAR VAR] VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR<->VAR VAR. [VAR VAR VAR VAR]*/ VAR VAR * VAR(VAR *VAR)  { VAR *VAR = VAR(); VAR VAR(VAR->VAR); } /*[VAR VAR] VAR.VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR<->VAR VAR. [VAR VAR VAR VAR]*/ VAR VAR * VAR(VAR *VAR, VAR VAR)  { VAR *VAR = VAR(); VAR ((!VAR) || (VAR >= VAR)) { VAR->VAR->VAR = VAR; VAR; } VAR { VAR( VAR, ""VAR VAR VAR 0 VAR VAR VAR %VAR"", VAR); VAR VAR; } } VAR VAR {""VAR"", ""-VAR VAR""}, 16 VAR(VAR); 15",1
cpython_f8b71da9aac6ea74808dcdd0cc266e705431356b,Python/initconfig.c,"#include ""pycore_long.h""          // _PY_LONG_MAX_STR_DIGITS_THRESHOLD
   The default is \""on\"" (or \""off\"" if you are running a local build).\n\
\n\
-X int_max_str_digits=number: limit the size of int<->str conversions.\n\
    This helps avoid denial of service attacks when parsing untrusted data.\n\
    The default is sys.int_info.default_max_str_digits.  0 disables."";
""PYTHONINTMAXSTRDIGITS: limits the maximum digit characters in an int value\n""
""   when converting from a string and when converting an int back to a str.\n""
""   A value of 0 disables the limit.  Conversions to or from bases 2, 4, 8,\n""
""   16, and 32 are never limited.\n""
/* Excluded from public struct PyConfig for backporting reasons. */
/* default to unconfigured, _PyLong_InitTypes() does the rest */
int _Py_global_config_int_max_str_digits = -1;

static PyStatus
config_init_int_max_str_digits(PyConfig *config)
{
    int maxdigits;
    int valid = 0;

    const char *env = config_get_env(config, ""PYTHONINTMAXSTRDIGITS"");
    if (env) {
        if (!_Py_str_to_int(env, &maxdigits)) {
            valid = ((maxdigits == 0) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD));
        }
        if (!valid) {
#define STRINGIFY(VAL) _STRINGIFY(VAL)
#define _STRINGIFY(VAL) #VAL
            return _PyStatus_ERR(
                    ""PYTHONINTMAXSTRDIGITS: invalid limit; must be >= ""
                    STRINGIFY(_PY_LONG_MAX_STR_DIGITS_THRESHOLD)
                    "" or 0 for unlimited."");
        }
        _Py_global_config_int_max_str_digits = maxdigits;
    }

    const wchar_t *xoption = config_get_xoption(config, L""int_max_str_digits"");
    if (xoption) {
        const wchar_t *sep = wcschr(xoption, L'=');
        if (sep) {
            if (!config_wstr_to_int(sep + 1, &maxdigits)) {
                valid = ((maxdigits == 0) || (maxdigits >= _PY_LONG_MAX_STR_DIGITS_THRESHOLD));
            }
        }
        if (!valid) {
            return _PyStatus_ERR(
                    ""-X int_max_str_digits: invalid limit; must be >= ""
                    STRINGIFY(_PY_LONG_MAX_STR_DIGITS_THRESHOLD)
                    "" or 0 for unlimited."");
#undef _STRINGIFY
#undef STRINGIFY
        }
        _Py_global_config_int_max_str_digits = maxdigits;
    }
    return _PyStatus_OK();
}
    if (_Py_global_config_int_max_str_digits < 0) {
        status = config_init_int_max_str_digits(config);
        if (_PyStatus_EXCEPTION(status)) {
            return status;
        }
    }","   The default is \""on\"" (or \""off\"" if you are running a local build)."";",f8b71da9aac6ea74808dcdd0cc266e705431356b,CVE-2020-10735,f8b71da9aac6ea74808dcdd0cc266e705431356b,https://github.com/python/cpython,NVD_GIT_REPOBASED,186,COMPLETED," VAR VAR VAR \""VAR\"" (VAR \""VAR\"" VAR VAR VAR VAR VAR VAR VAR).\VAR\ \VAR\ -VAR VAR=VAR: VAR VAR VAR VAR VAR<->VAR VAR.\VAR\ VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.\VAR\ VAR VAR VAR VAR.VAR.VAR. 0 VAR.""; ""VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR\VAR"" "" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.\VAR"" "" VAR VAR VAR 0 VAR VAR VAR. VAR VAR VAR VAR VAR 2, 4, 8,\VAR"" "" 16, VAR 32 VAR VAR VAR.\VAR""   VAR VAR = -1; VAR VAR VAR(VAR *VAR) { VAR VAR; VAR VAR = 0; VAR VAR *VAR = VAR(VAR, ""VAR""); VAR (VAR) { VAR (!VAR(VAR, &VAR)) { VAR = ((VAR == 0) || (VAR >= VAR)); } VAR (!VAR) {   VAR VAR( ""VAR: VAR VAR; VAR VAR >= "" VAR(VAR) "" VAR 0 VAR VAR.""); } VAR = VAR; } VAR VAR *VAR = VAR(VAR, VAR""VAR""); VAR (VAR) { VAR VAR *VAR = VAR(VAR, VAR'='); VAR (VAR) { VAR (!VAR(VAR + 1, &VAR)) { VAR = ((VAR == 0) || (VAR >= VAR)); } } VAR (!VAR) { VAR VAR( ""-VAR VAR: VAR VAR; VAR VAR >= "" VAR(VAR) "" VAR 0 VAR VAR."");   } VAR = VAR; } VAR VAR(); } VAR (VAR < 0) { VAR = VAR(VAR); VAR (VAR(VAR)) { VAR VAR; } } VAR VAR VAR \""VAR\"" (VAR \""VAR\"" VAR VAR VAR VAR VAR VAR VAR)."";",1
django_8d7271578d7b153435b40fe40236ebec43cbf1b9,docs/releases/2.2.16.txt,"Django 2.2.16 fixes a security issue and two data loss bugs in 2.2.15.

CVE-2020-24583: Incorrect permissions on intermediate-level directories on Python 3.7+
======================================================================================

On Python 3.7+, :setting:`FILE_UPLOAD_DIRECTORY_PERMISSIONS` mode was not
applied to intermediate-level directories created in the process of uploading
files and to intermediate-level collected static directories when using the
:djadmin:`collectstatic` management command.

You should review and manually fix permissions on existing intermediate-level
directories.",Django 2.2.16 fixes two data loss bugs in 2.2.15.,8d7271578d7b153435b40fe40236ebec43cbf1b9,CVE-2020-24583,8d7271578d7b153435b40fe40236ebec43cbf1b9,https://github.com/django/django,GHSD_DIRECT_COMMIT,1337,COMPLETED,"VAR 2.2.16 VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 2.2.15. VAR-2020-24583: VAR VAR VAR VAR-VAR VAR VAR VAR 3.7+ ====================================================================================== VAR VAR 3.7+, :VAR:`VAR` VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR` VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. VAR 2.2.16 VAR VAR VAR VAR VAR VAR 2.2.15.",1
envoy_3b5acb2f43548862dadb243de7cf3994986a8e04,source/common/chromium_url/url_canon.h,"// Envoy snapshot of Chromium URL path normalization, see README.md.
// NOLINT(namespace-envoy)

// Copyright 2013 The Chromium Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef URL_URL_CANON_H_
#define URL_URL_CANON_H_

#include <stdlib.h>
#include <string.h>

#include ""common/chromium_url/envoy_shim.h""
#include ""common/chromium_url/url_parse.h""

namespace chromium_url {

// Canonicalizer output -------------------------------------------------------

// Base class for the canonicalizer output, this maintains a buffer and
// supports simple resizing and append operations on it.
//
// It is VERY IMPORTANT that no virtual function calls be made on the common
// code path. We only have two virtual function calls, the destructor and a
// resize function that is called when the existing buffer is not big enough.
// The derived class is then in charge of setting up our buffer which we will
// manage.
template <typename T> class CanonOutputT {
public:
  CanonOutputT() : buffer_(NULL), buffer_len_(0), cur_len_(0) {}
  virtual ~CanonOutputT() = default;

  // Implemented to resize the buffer. This function should update the buffer
  // pointer to point to the new buffer, and any old data up to |cur_len_| in
  // the buffer must be copied over.
  //
  // The new size |sz| must be larger than buffer_len_.
  virtual void Resize(int sz) = 0;

  // Accessor for returning a character at a given position. The input offset
  // must be in the valid range.
  inline T at(int offset) const { return buffer_[offset]; }

  // Sets the character at the given position. The given position MUST be less
  // than the length().
  inline void set(int offset, T ch) { buffer_[offset] = ch; }

  // Returns the number of characters currently in the buffer.
  inline int length() const { return cur_len_; }

  // Returns the current capacity of the buffer. The length() is the number of
  // characters that have been declared to be written, but the capacity() is
  // the number that can be written without reallocation. If the caller must
  // write many characters at once, it can make sure there is enough capacity,
  // write the data, then use set_size() to declare the new length().
  int capacity() const { return buffer_len_; }

  // Called by the user of this class to get the output. The output will NOT
  // be NULL-terminated. Call length() to get the
  // length.
  const T* data() const { return buffer_; }
  T* data() { return buffer_; }

  // Shortens the URL to the new length. Used for ""backing up"" when processing
  // relative paths. This can also be used if an external function writes a lot
  // of data to the buffer (when using the ""Raw"" version below) beyond the end,
  // to declare the new length.
  //
  // This MUST NOT be used to expand the size of the buffer beyond capacity().
  void set_length(int new_len) { cur_len_ = new_len; }

  // This is the most performance critical function, since it is called for
  // every character.
  void push_back(T ch) {
    // In VC2005, putting this common case first speeds up execution
    // dramatically because this branch is predicted as taken.
    if (cur_len_ < buffer_len_) {
      buffer_[cur_len_] = ch;
      cur_len_++;
      return;
    }

    // Grow the buffer to hold at least one more item. Hopefully we won't have
    // to do this very often.
    if (!Grow(1))
      return;

    // Actually do the insertion.
    buffer_[cur_len_] = ch;
    cur_len_++;
  }

  // Appends the given string to the output.
  void Append(const T* str, int str_len) {
    if (cur_len_ + str_len > buffer_len_) {
      if (!Grow(cur_len_ + str_len - buffer_len_))
        return;
    }
    for (int i = 0; i < str_len; i++)
      buffer_[cur_len_ + i] = str[i];
    cur_len_ += str_len;
  }

  void ReserveSizeIfNeeded(int estimated_size) {
    // Reserve a bit extra to account for escaped chars.
    if (estimated_size > buffer_len_)
      Resize(estimated_size + 8);
  }

protected:
  // Grows the given buffer so that it can fit at least |min_additional|
  // characters. Returns true if the buffer could be resized, false on OOM.
  bool Grow(int min_additional) {
    static const int kMinBufferLen = 16;
    int new_len = (buffer_len_ == 0) ? kMinBufferLen : buffer_len_;
    do {
      if (new_len >= (1 << 30)) // Prevent overflow below.
        return false;
      new_len *= 2;
    } while (new_len < buffer_len_ + min_additional);
    Resize(new_len);
    return true;
  }

  T* buffer_;
  int buffer_len_;

  // Used characters in the buffer.
  int cur_len_;
};

// Simple implementation of the CanonOutput using new[]. This class
// also supports a static buffer so if it is allocated on the stack, most
// URLs can be canonicalized with no heap allocations.
template <typename T, int fixed_capacity = 1024> class RawCanonOutputT : public CanonOutputT<T> {
public:
  RawCanonOutputT() : CanonOutputT<T>() {
    this->buffer_ = fixed_buffer_;
    this->buffer_len_ = fixed_capacity;
  }
  ~RawCanonOutputT() override {
    if (this->buffer_ != fixed_buffer_)
      delete[] this->buffer_;
  }

  void Resize(int sz) override {
    T* new_buf = new T[sz];
    memcpy(new_buf, this->buffer_, sizeof(T) * (this->cur_len_ < sz ? this->cur_len_ : sz));
    if (this->buffer_ != fixed_buffer_)
      delete[] this->buffer_;
    this->buffer_ = new_buf;
    this->buffer_len_ = sz;
  }

protected:
  T fixed_buffer_[fixed_capacity];
};

// Explicitly instantiate commonly used instantiations.
extern template class EXPORT_TEMPLATE_DECLARE(COMPONENT_EXPORT(URL)) CanonOutputT<char>;

// Normally, all canonicalization output is in narrow characters. We support
// the templates so it can also be used internally if a wide buffer is
// required.
using CanonOutput = CanonOutputT<char>;

template <int fixed_capacity>
class RawCanonOutput : public RawCanonOutputT<char, fixed_capacity> {};

// Path. If the input does not begin in a slash (including if the input is
// empty), we'll prepend a slash to the path to make it canonical.
//
// The 8-bit version assumes UTF-8 encoding, but does not verify the validity
// of the UTF-8 (i.e., you can have invalid UTF-8 sequences, invalid
// characters, etc.). Normally, URLs will come in as UTF-16, so this isn't
// an issue. Somebody giving us an 8-bit path is responsible for generating
// the path that the server expects (we'll escape high-bit characters), so
// if something is invalid, it's their problem.
COMPONENT_EXPORT(URL)
bool CanonicalizePath(const char* spec, const Component& path, CanonOutput* output,
                      Component* out_path);

} // namespace chromium_url

#endif // URL_URL_CANON_H_",,3b5acb2f43548862dadb243de7cf3994986a8e04,CVE-2020-25018,3b5acb2f43548862dadb243de7cf3994986a8e04,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED,"           VAR VAR {          VAR <VAR VAR> VAR VAR { VAR: VAR() : VAR(VAR), VAR(0), VAR(0) {} VAR ~VAR() = VAR;      VAR VAR VAR(VAR VAR) = 0;   VAR VAR VAR(VAR VAR) VAR { VAR VAR[VAR]; }   VAR VAR VAR(VAR VAR, VAR VAR) { VAR[VAR] = VAR; }  VAR VAR VAR() VAR { VAR VAR; }      VAR VAR() VAR { VAR VAR; }    VAR VAR* VAR() VAR { VAR VAR; } VAR* VAR() { VAR VAR; }       VAR VAR(VAR VAR) { VAR = VAR; }   VAR VAR(VAR VAR) {   VAR (VAR < VAR) { VAR[VAR] = VAR; VAR++; VAR; }   VAR (!VAR(1)) VAR;  VAR[VAR] = VAR; VAR++; }  VAR VAR(VAR VAR* VAR, VAR VAR) { VAR (VAR + VAR > VAR) { VAR (!VAR(VAR + VAR - VAR)) VAR; } VAR (VAR VAR = 0; VAR < VAR; VAR++) VAR[VAR + VAR] = VAR[VAR]; VAR += VAR; } VAR VAR(VAR VAR) {  VAR (VAR > VAR) VAR(VAR + 8); } VAR:   VAR VAR(VAR VAR) { VAR VAR VAR VAR = 16; VAR VAR = (VAR == 0) ? VAR : VAR; VAR { VAR (VAR >= (1 << 30))  VAR VAR; VAR *= 2; } VAR (VAR < VAR + VAR); VAR(VAR); VAR VAR; } VAR* VAR; VAR VAR;  VAR VAR; };    VAR <VAR VAR, VAR VAR = 1024> VAR VAR : VAR VAR<VAR> { VAR: VAR() : VAR<VAR>() { VAR->VAR = VAR; VAR->VAR = VAR; } ~VAR() VAR { VAR (VAR->VAR != VAR) VAR[] VAR->VAR; } VAR VAR(VAR VAR) VAR { VAR* VAR = VAR VAR[VAR]; VAR(VAR, VAR->VAR, VAR(VAR) * (VAR->VAR < VAR ? VAR->VAR : VAR)); VAR (VAR->VAR != VAR) VAR[] VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR; } VAR: VAR VAR[VAR]; };  VAR VAR VAR VAR(VAR(VAR)) VAR<VAR>;    VAR VAR = VAR<VAR>; VAR <VAR VAR> VAR VAR : VAR VAR<VAR, VAR> {};          VAR(VAR) VAR VAR(VAR VAR* VAR, VAR VAR& VAR, VAR* VAR, VAR* VAR); }   ",1
envoy_79984e40b456f30cfb53564c4afe955aea19f9f9,docs/root/version_history/version_history.rst,  v1.16.0,,79984e40b456f30cfb53564c4afe955aea19f9f9,CVE-2020-35471,79984e40b456f30cfb53564c4afe955aea19f9f9,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,104,COMPLETED,VAR.16.0 ,1
FFmpeg_21270cffaeab2f67a613907516b2b0cd6c9eacf4,libavcodec/mpegvideo.c,"                for(i=0; i<avctx->height; i++)
                    memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width);","                for(i=0; i<s->height; i++)
                    memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, s->width);",21270cffaeab2f67a613907516b2b0cd6c9eacf4,CVE-2012-0856,21270cffaeab2f67a613907516b2b0cd6c9eacf4,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,90,COMPLETED,"VAR(VAR=0; VAR<VAR->VAR; VAR++) VAR(VAR->VAR->VAR.VAR[0] + VAR->VAR->VAR.VAR[0]*VAR, 16, VAR->VAR); VAR(VAR=0; VAR<VAR->VAR; VAR++) VAR(VAR->VAR->VAR.VAR[0] + VAR->VAR->VAR.VAR[0]*VAR, 16, VAR->VAR);",1
FFmpeg_2171dfae8c065878a2e130390eb78cf2947a5b69,libavcodec/scpr.c,"    if (x >= 16 || c >= 256) {
        return AVERROR_INVALIDDATA;
    }",,2171dfae8c065878a2e130390eb78cf2947a5b69,CVE-2017-9995,2171dfae8c065878a2e130390eb78cf2947a5b69,https://github.com/FFmpeg/FFmpeg,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR (VAR >= 16 || VAR >= 256) { VAR VAR; } ,1
FFmpeg_4565747056a11356210ed8edcecb920105e40b60,libavcodec/evc_ps.c,"static int ref_pic_list_struct(EVCParserSPS *sps, GetBitContext *gb, RefPicListStruct *rpl)

    if ((unsigned)rpl->ref_pic_num  > sps->sps_max_dec_pic_buffering_minus1)
        return AVERROR_INVALIDDATA;

        if ((unsigned)sps->sps_max_dec_pic_buffering_minus1 > 16 - 1)
            return AVERROR_INVALIDDATA;
        for (int i = 0; i < sps->num_ref_pic_list_in_sps[0]; ++i) {
            ret = ref_pic_list_struct(sps, gb, &sps->rpls[0][i]);
            if (ret < 0)
                goto fail;
        }
            for (int i = 0; i < sps->num_ref_pic_list_in_sps[1]; ++i) {
                ret = ref_pic_list_struct(sps, gb, &sps->rpls[1][i]);
                if (ret < 0)
                    goto fail;
            }","static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)
        for (int i = 0; i < sps->num_ref_pic_list_in_sps[0]; ++i)
            ref_pic_list_struct(gb, &sps->rpls[0][i]);
            for (int i = 0; i < sps->num_ref_pic_list_in_sps[1]; ++i)
                ref_pic_list_struct(gb, &sps->rpls[1][i]);",4565747056a11356210ed8edcecb920105e40b60,CVE-2023-47470,4565747056a11356210ed8edcecb920105e40b60,https://github.com/FFmpeg/FFmpeg,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR) VAR ((VAR)VAR->VAR > VAR->VAR) VAR VAR; VAR ((VAR)VAR->VAR > 16 - 1) VAR VAR; VAR (VAR VAR = 0; VAR < VAR->VAR[0]; ++VAR) { VAR = VAR(VAR, VAR, &VAR->VAR[0][VAR]); VAR (VAR < 0) VAR VAR; } VAR (VAR VAR = 0; VAR < VAR->VAR[1]; ++VAR) { VAR = VAR(VAR, VAR, &VAR->VAR[1][VAR]); VAR (VAR < 0) VAR VAR; } VAR VAR VAR(VAR *VAR, VAR *VAR) VAR (VAR VAR = 0; VAR < VAR->VAR[0]; ++VAR) VAR(VAR, &VAR->VAR[0][VAR]); VAR (VAR VAR = 0; VAR < VAR->VAR[1]; ++VAR) VAR(VAR, &VAR->VAR[1][VAR]);",1
FFmpeg_47b7c68ae54560e2308bdb6be4fb076c73b93081,libavcodec/utvideodec.c,"        c->pro         = 1;
        c->pro         = 1;
        c->pro         = 1;
    } else if (!c->pro && avctx->extradata_size >= 16) {
    } else if (c->pro && avctx->extradata_size == 8) {","    } else if (avctx->extradata_size >= 16) {
    } else if (avctx->extradata_size == 8) {
        c->pro         = 1;",47b7c68ae54560e2308bdb6be4fb076c73b93081,CVE-2018-10001,47b7c68ae54560e2308bdb6be4fb076c73b93081,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,88,COMPLETED,VAR->VAR = 1; VAR->VAR = 1; VAR->VAR = 1; } VAR VAR (!VAR->VAR && VAR->VAR >= 16) { } VAR VAR (VAR->VAR && VAR->VAR == 8) { } VAR VAR (VAR->VAR >= 16) { } VAR VAR (VAR->VAR == 8) { VAR->VAR = 1;,1
FFmpeg_73472053516f82b7d273a3d42c583f894077a191,libavcodec/qdm2.c,"    int i, out_size;
    out_size = 16 * s->channels * s->frame_size *
               av_get_bytes_per_sample(avctx->sample_fmt);
    if (*data_size < out_size) {
        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");
        return AVERROR(EINVAL);
    }

    *data_size = out_size;","    int i;
    *data_size = (uint8_t*)out - (uint8_t*)data;",73472053516f82b7d273a3d42c583f894077a191,CVE-2011-4351,73472053516f82b7d273a3d42c583f894077a191,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,70,COMPLETED,"VAR VAR, VAR; VAR = 16 * VAR->VAR * VAR->VAR * VAR(VAR->VAR); VAR (*VAR < VAR) { VAR(VAR, VAR, ""VAR VAR VAR VAR VAR\VAR""); VAR VAR(VAR); } *VAR = VAR; VAR VAR; *VAR = (VAR*)VAR - (VAR*)VAR;",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/ansi.c,"#include ""libavutil/frame.h""
    AVFrame *frame;
    s->frame = av_frame_alloc();
    if (!s->frame)
        return AVERROR(ENOMEM);

        memcpy(s->frame->data[0] + i * s->frame->linesize[0],
               s->frame->data[0] + (i + s->font_height) * s->frame->linesize[0],
        memset(s->frame->data[0] + i * s->frame->linesize[0],
        memset(s->frame->data[0] + (s->y + i)*s->frame->linesize[0] + xoffset,
        memset(s->frame->data[0] + i * s->frame->linesize[0], DEFAULT_BG_COLOR, avctx->width);
    ff_draw_pc_font(s->frame->data[0] + s->y * s->frame->linesize[0] + s->x,
                    s->frame->linesize[0], s->font, s->font_height, c, fg, bg);
            av_frame_unref(s->frame);
            ret = ff_get_buffer(avctx, s->frame, AV_GET_BUFFER_FLAG_REF);
            s->frame->pict_type           = AV_PICTURE_TYPE_I;
            s->frame->palette_has_changed = 1;
            memcpy(s->frame->data[1], ff_cga_palette, 16 * 4);
                memset(s->frame->data[0] + (s->y + s->font_height)*s->frame->linesize[0],
                    DEFAULT_BG_COLOR, (avctx->height - s->y - s->font_height)*s->frame->linesize[0]);
                memset(s->frame->data[0], DEFAULT_BG_COLOR, s->y * s->frame->linesize[0]);
    ret = ff_reget_buffer(avctx, s->frame);
        memset(s->frame->data[0], 0, avctx->height * FFABS(s->frame->linesize[0]));
        memset(s->frame->data[1], 0, AVPALETTE_SIZE);
    s->frame->pict_type           = AV_PICTURE_TYPE_I;
    s->frame->palette_has_changed = 1;
    memcpy(s->frame->data[1], ff_cga_palette, 16 * 4);
    if ((ret = av_frame_ref(data, s->frame)) < 0)
        return ret;

    av_frame_free(&s->frame);","    AVFrame frame;
        memcpy(s->frame.data[0] + i * s->frame.linesize[0],
               s->frame.data[0] + (i + s->font_height) * s->frame.linesize[0],
        memset(s->frame.data[0] + i * s->frame.linesize[0],
        memset(s->frame.data[0] + (s->y + i)*s->frame.linesize[0] + xoffset,
        memset(s->frame.data[0] + i * s->frame.linesize[0], DEFAULT_BG_COLOR, avctx->width);
    ff_draw_pc_font(s->frame.data[0] + s->y * s->frame.linesize[0] + s->x,
                    s->frame.linesize[0], s->font, s->font_height, c, fg, bg);
            if (s->frame.data[0])
                avctx->release_buffer(avctx, &s->frame);
            ret = ff_get_buffer(avctx, &s->frame);
            s->frame.pict_type           = AV_PICTURE_TYPE_I;
            s->frame.palette_has_changed = 1;
            memcpy(s->frame.data[1], ff_cga_palette, 16 * 4);
                memset(s->frame.data[0] + (s->y + s->font_height)*s->frame.linesize[0],
                    DEFAULT_BG_COLOR, (avctx->height - s->y - s->font_height)*s->frame.linesize[0]);
                memset(s->frame.data[0], DEFAULT_BG_COLOR, s->y * s->frame.linesize[0]);
    ret = avctx->reget_buffer(avctx, &s->frame);
        memset(s->frame.data[0], 0, avctx->height * FFABS(s->frame.linesize[0]));
        memset(s->frame.data[1], 0, AVPALETTE_SIZE);
    s->frame.pict_type           = AV_PICTURE_TYPE_I;
    s->frame.palette_has_changed = 1;
    memcpy(s->frame.data[1], ff_cga_palette, 16 * 4);
    *(AVFrame*)data = s->frame;
    if (s->frame.data[0])
        avctx->release_buffer(avctx, &s->frame);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED," VAR *VAR; VAR->VAR = VAR(); VAR (!VAR->VAR) VAR VAR(VAR); VAR(VAR->VAR->VAR[0] + VAR * VAR->VAR->VAR[0], VAR->VAR->VAR[0] + (VAR + VAR->VAR) * VAR->VAR->VAR[0], VAR(VAR->VAR->VAR[0] + VAR * VAR->VAR->VAR[0], VAR(VAR->VAR->VAR[0] + (VAR->VAR + VAR)*VAR->VAR->VAR[0] + VAR, VAR(VAR->VAR->VAR[0] + VAR * VAR->VAR->VAR[0], VAR, VAR->VAR); VAR(VAR->VAR->VAR[0] + VAR->VAR * VAR->VAR->VAR[0] + VAR->VAR, VAR->VAR->VAR[0], VAR->VAR, VAR->VAR, VAR, VAR, VAR); VAR(VAR->VAR); VAR = VAR(VAR, VAR->VAR, VAR); VAR->VAR->VAR = VAR; VAR->VAR->VAR = 1; VAR(VAR->VAR->VAR[1], VAR, 16 * 4); VAR(VAR->VAR->VAR[0] + (VAR->VAR + VAR->VAR)*VAR->VAR->VAR[0], VAR, (VAR->VAR - VAR->VAR - VAR->VAR)*VAR->VAR->VAR[0]); VAR(VAR->VAR->VAR[0], VAR, VAR->VAR * VAR->VAR->VAR[0]); VAR = VAR(VAR, VAR->VAR); VAR(VAR->VAR->VAR[0], 0, VAR->VAR * VAR(VAR->VAR->VAR[0])); VAR(VAR->VAR->VAR[1], 0, VAR); VAR->VAR->VAR = VAR; VAR->VAR->VAR = 1; VAR(VAR->VAR->VAR[1], VAR, 16 * 4); VAR ((VAR = VAR(VAR, VAR->VAR)) < 0) VAR VAR; VAR(&VAR->VAR); VAR VAR; VAR(VAR->VAR.VAR[0] + VAR * VAR->VAR.VAR[0], VAR->VAR.VAR[0] + (VAR + VAR->VAR) * VAR->VAR.VAR[0], VAR(VAR->VAR.VAR[0] + VAR * VAR->VAR.VAR[0], VAR(VAR->VAR.VAR[0] + (VAR->VAR + VAR)*VAR->VAR.VAR[0] + VAR, VAR(VAR->VAR.VAR[0] + VAR * VAR->VAR.VAR[0], VAR, VAR->VAR); VAR(VAR->VAR.VAR[0] + VAR->VAR * VAR->VAR.VAR[0] + VAR->VAR, VAR->VAR.VAR[0], VAR->VAR, VAR->VAR, VAR, VAR, VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR = VAR(VAR, &VAR->VAR); VAR->VAR.VAR = VAR; VAR->VAR.VAR = 1; VAR(VAR->VAR.VAR[1], VAR, 16 * 4); VAR(VAR->VAR.VAR[0] + (VAR->VAR + VAR->VAR)*VAR->VAR.VAR[0], VAR, (VAR->VAR - VAR->VAR - VAR->VAR)*VAR->VAR.VAR[0]); VAR(VAR->VAR.VAR[0], VAR, VAR->VAR * VAR->VAR.VAR[0]); VAR = VAR->VAR(VAR, &VAR->VAR); VAR(VAR->VAR.VAR[0], 0, VAR->VAR * VAR(VAR->VAR.VAR[0])); VAR(VAR->VAR.VAR[1], 0, VAR); VAR->VAR.VAR = VAR; VAR->VAR.VAR = 1; VAR(VAR->VAR.VAR[1], VAR, 16 * 4); *(VAR*)VAR = VAR->VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR);",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/asvdec.c,"static inline void idct_put(ASV1Context *a, AVFrame *frame, int mb_x, int mb_y)
    int linesize         = frame->linesize[0];
    uint8_t *dest_y  = frame->data[0] + (mb_y * 16* linesize              ) + mb_x * 16;
    uint8_t *dest_cb = frame->data[1] + (mb_y * 8 * frame->linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = frame->data[2] + (mb_y * 8 * frame->linesize[2]) + mb_x * 8;
        a->dsp.idct_put(dest_cb, frame->linesize[1], block[4]);
        a->dsp.idct_put(dest_cr, frame->linesize[2], block[5]);
    AVFrame * const p     = data;
    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {
            idct_put(a, p, mb_x, mb_y);
            idct_put(a, p, mb_x, mb_y);
            idct_put(a, p, mb_x, mb_y);","static inline void idct_put(ASV1Context *a, int mb_x, int mb_y)
    int linesize         = a->picture.linesize[0];
    uint8_t *dest_y  = a->picture.data[0] + (mb_y * 16* linesize              ) + mb_x * 16;
    uint8_t *dest_cb = a->picture.data[1] + (mb_y * 8 * a->picture.linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = a->picture.data[2] + (mb_y * 8 * a->picture.linesize[2]) + mb_x * 8;
        a->dsp.idct_put(dest_cb, a->picture.linesize[1], block[4]);
        a->dsp.idct_put(dest_cr, a->picture.linesize[2], block[5]);
    AVFrame *picture      = data;
    AVFrame * const p     = &a->picture;
    if (p->data[0])
        avctx->release_buffer(avctx, p);

    p->reference = 0;
    if ((ret = ff_get_buffer(avctx, p)) < 0) {
            idct_put(a, mb_x, mb_y);
            idct_put(a, mb_x, mb_y);
            idct_put(a, mb_x, mb_y);
    *picture   = a->picture;
    AVFrame *p            = &a->picture;
    p->qstride      = a->mb_width;
    p->qscale_table = av_malloc(p->qstride * a->mb_height);
    p->quality      = (32 * scale + a->inv_qscale / 2) / a->inv_qscale;
    memset(p->qscale_table, p->quality, p->qstride * a->mb_height);

    av_freep(&a->picture.qscale_table);
    if (a->picture.data[0])
        avctx->release_buffer(avctx, &a->picture);
",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR) VAR VAR = VAR->VAR[0]; VAR *VAR = VAR->VAR[0] + (VAR * 16* VAR ) + VAR * 16; VAR *VAR = VAR->VAR[1] + (VAR * 8 * VAR->VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR[2] + (VAR * 8 * VAR->VAR[2]) + VAR * 8; VAR->VAR.VAR(VAR, VAR->VAR[1], VAR[4]); VAR->VAR.VAR(VAR, VAR->VAR[2], VAR[5]); VAR * VAR VAR = VAR; VAR ((VAR = VAR(VAR, VAR, 0)) < 0) { VAR(VAR, VAR, VAR, VAR); VAR(VAR, VAR, VAR, VAR); VAR(VAR, VAR, VAR, VAR); VAR VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR) VAR VAR = VAR->VAR.VAR[0]; VAR *VAR = VAR->VAR.VAR[0] + (VAR * 16* VAR ) + VAR * 16; VAR *VAR = VAR->VAR.VAR[1] + (VAR * 8 * VAR->VAR.VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR.VAR[2] + (VAR * 8 * VAR->VAR.VAR[2]) + VAR * 8; VAR->VAR.VAR(VAR, VAR->VAR.VAR[1], VAR[4]); VAR->VAR.VAR(VAR, VAR->VAR.VAR[2], VAR[5]); VAR *VAR = VAR; VAR * VAR VAR = &VAR->VAR; VAR (VAR->VAR[0]) VAR->VAR(VAR, VAR); VAR->VAR = 0; VAR ((VAR = VAR(VAR, VAR)) < 0) { VAR(VAR, VAR, VAR); VAR(VAR, VAR, VAR); VAR(VAR, VAR, VAR); *VAR = VAR->VAR; VAR *VAR = &VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR(VAR->VAR * VAR->VAR); VAR->VAR = (32 * VAR + VAR->VAR / 2) / VAR->VAR; VAR(VAR->VAR, VAR->VAR, VAR->VAR * VAR->VAR); VAR(&VAR->VAR.VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR);",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/avcodec.h,"#if FF_API_GET_BUFFER
#endif

/**
 * The decoder will keep a reference to the frame and may reuse it later.
 */
#define AV_GET_BUFFER_FLAG_REF (1 << 0)
#if FF_API_GET_BUFFER
     *
     * @deprecated use get_buffer2()
    attribute_deprecated
     *
     * @deprecated custom freeing callbacks should be set from get_buffer2()
    attribute_deprecated
    attribute_deprecated
#endif
    /**
     * This callback is called at the beginning of each frame to get data
     * buffer(s) for it. There may be one contiguous buffer for all the data or
     * there may be a buffer per each data plane or anything in between. Each
     * buffer must be reference-counted using the AVBuffer API.
     *
     * The following fields will be set in the frame before this callback is
     * called:
     * - format
     * - width, height (video only)
     * - sample_rate, channel_layout, nb_samples (audio only)
     * Their values may differ from the corresponding values in
     * AVCodecContext. This callback must use the frame values, not the codec
     * context values, to calculate the required buffer size.
     *
     * This callback must fill the following fields in the frame:
     * - data[]
     * - linesize[]
     * - extended_data:
     *   * if the data is planar audio with more than 8 channels, then this
     *     callback must allocate and fill extended_data to contain all pointers
     *     to all data planes. data[] must hold as many pointers as it can.
     *     extended_data must be allocated with av_malloc() and will be freed in
     *     av_frame_unref().
     *   * otherwise exended_data must point to data
     * - buf[] must contain references to the buffers that contain the frame
     *   data.
     * - extended_buf and nb_extended_buf must be allocated with av_malloc() by
     *   this callback and filled with the extra buffers if there are more
     *   buffers than buf[] can hold. extended_buf will be freed in
     *   av_frame_unref().
     *
     * If CODEC_CAP_DR1 is not set then get_buffer2() must call
     * avcodec_default_get_buffer2() instead of providing buffers allocated by
     * some other means.
     *
     * Each data plane must be aligned to the maximum required by the target
     * CPU.
     *
     * @see avcodec_default_get_buffer2()
     *
     * Video:
     *
     * If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
     * (read and/or written to if it is writable) later by libavcodec.
     *
     * If CODEC_FLAG_EMU_EDGE is not set in s->flags, the buffer must contain an
     * edge of the size returned by avcodec_get_edge_width() on all sides.
     *
     * avcodec_align_dimensions2() should be used to find the required width and
     * height, as they normally need to be rounded up to the next multiple of 16.
     *
     * If frame multithreading is used and thread_safe_callbacks is set,
     * this callback may be called from a different thread, but not from more
     * than one at once. Does not need to be reentrant.
     *
     * @see avcodec_align_dimensions2()
     *
     * Audio:
     *
     * Decoders request a buffer of a particular size by setting
     * AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
     * however, utilize only part of the buffer by setting AVFrame.nb_samples
     * to a smaller value in the output frame.
     *
     * As a convenience, av_samples_get_buffer_size() and
     * av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()
     * functions to find the required data size and to fill data pointers and
     * linesize. In AVFrame.linesize, only linesize[0] may be set for audio
     * since all planes must be the same size.
     *
     * @see av_samples_get_buffer_size(), av_samples_fill_arrays()
     *
     * - encoding: unused
     * - decoding: Set by libavcodec, user can override.
     */
    int (*get_buffer2)(struct AVCodecContext *s, AVFrame *frame, int flags);

    /**
     * If non-zero, the decoded audio and video frames returned from
     * avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted
     * and are valid indefinitely. The caller must free them with
     * av_frame_unref() when they are not needed anymore.
     * Otherwise, the decoded frames must not be freed by the caller and are
     * only valid until the next decode call.
     *
     * - encoding: unused
     * - decoding: set by the caller before avcodec_open2().
     */
    int refcounted_frames;
#if FF_API_GET_BUFFER
attribute_deprecated int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic);
attribute_deprecated void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic);
attribute_deprecated int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic);
#endif

/**
 * The default callback for AVCodecContext.get_buffer2(). It is made public so
 * it can be called by custom get_buffer2() implementations for decoders without
 * CODEC_CAP_DR1 set.
 */
int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags);","int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic);
void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic);
int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic);
void avcodec_default_free_buffers(AVCodecContext *s);
",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"  /** * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. */   * * @VAR VAR VAR() VAR * * @VAR VAR VAR VAR VAR VAR VAR VAR VAR() VAR VAR  /** * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR(VAR) VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR * VAR VAR VAR VAR-VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR: * - VAR * - VAR, VAR (VAR VAR) * - VAR, VAR, VAR (VAR VAR) * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR * VAR VAR, VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: * - VAR[] * - VAR[] * - VAR: * * VAR VAR VAR VAR VAR VAR VAR VAR VAR 8 VAR, VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR. VAR[] VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR() VAR VAR VAR VAR VAR * VAR(). * * VAR VAR VAR VAR VAR VAR * - VAR[] VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. * - VAR VAR VAR VAR VAR VAR VAR VAR() VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR[] VAR VAR. VAR VAR VAR VAR VAR * VAR(). * * VAR VAR VAR VAR VAR VAR VAR() VAR VAR * VAR() VAR VAR VAR VAR VAR VAR * VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. * * @VAR VAR() * * VAR: * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * (VAR VAR/VAR VAR VAR VAR VAR VAR VAR) VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR->VAR, VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR() VAR VAR VAR. * * VAR() VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 16. * * VAR VAR VAR VAR VAR VAR VAR VAR VAR, * VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR * VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR. * * @VAR VAR() * * VAR: * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR.VAR VAR VAR VAR VAR(). VAR VAR VAR, * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR * VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR, VAR() VAR * VAR() VAR VAR VAR VAR VAR VAR VAR VAR() * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. VAR VAR.VAR, VAR VAR[0] VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR. * * @VAR VAR(), VAR() * * - VAR: VAR * - VAR: VAR VAR VAR, VAR VAR VAR. */ VAR (*VAR)(VAR VAR *VAR, VAR *VAR, VAR VAR); /** * VAR VAR-VAR, VAR VAR VAR VAR VAR VAR VAR VAR * VAR() VAR VAR() VAR VAR-VAR * VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR * VAR() VAR VAR VAR VAR VAR VAR. * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR. * * - VAR: VAR * - VAR: VAR VAR VAR VAR VAR VAR(). */ VAR VAR;  VAR VAR VAR(VAR *VAR, VAR *VAR); VAR VAR VAR(VAR *VAR, VAR *VAR); VAR VAR VAR(VAR *VAR, VAR *VAR);  /** * VAR VAR VAR VAR VAR.VAR(). VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR() VAR VAR VAR VAR * VAR VAR. */ VAR VAR(VAR *VAR, VAR *VAR, VAR VAR); VAR VAR(VAR *VAR, VAR *VAR); VAR VAR(VAR *VAR, VAR *VAR); VAR VAR(VAR *VAR, VAR *VAR); VAR VAR(VAR *VAR);",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/eamad.c,"static inline void comp_block(MadContext *t, AVFrame *frame,
                              int mb_x, int mb_y,
        comp(frame->data[0] + (mb_y*16 + ((j&2)<<2))*frame->linesize[0] + mb_x*16 + ((j&1)<<3),
             frame->linesize[0],
        comp(frame->data[index] + (mb_y*8)*frame->linesize[index] + mb_x * 8,
             frame->linesize[index],
static inline void idct_put(MadContext *t, AVFrame *frame, int16_t *block,
                            int mb_x, int mb_y, int j)
            frame->data[0] + (mb_y*16 + ((j&2)<<2))*frame->linesize[0] + mb_x*16 + ((j&1)<<3),
            frame->linesize[0], block);
            frame->data[index] + (mb_y*8)*frame->linesize[index] + mb_x*8,
            frame->linesize[index], block);
static void decode_mb(MadContext *s, AVFrame *frame, int inter)
            comp_block(s, frame, s->mb_x, s->mb_y, j, mv_x, mv_y, add);
            idct_put(s, frame, s->block, s->mb_x, s->mb_y, j);
    AVFrame *frame    = data;
    int inter, ret;
        av_frame_unref(&s->last_frame);
    if ((ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
        return ret;
            decode_mb(s, frame, inter);
    if (chunk_type != MADe_TAG) {
        av_frame_unref(&s->last_frame);
        if ((ret = av_frame_ref(&s->last_frame, frame)) < 0)
            return ret;
    }
    av_frame_unref(&t->last_frame);","    AVFrame frame;
static inline void comp_block(MadContext *t, int mb_x, int mb_y,
        comp(t->frame.data[0] + (mb_y*16 + ((j&2)<<2))*t->frame.linesize[0] + mb_x*16 + ((j&1)<<3),
             t->frame.linesize[0],
        comp(t->frame.data[index] + (mb_y*8)*t->frame.linesize[index] + mb_x * 8,
             t->frame.linesize[index],
static inline void idct_put(MadContext *t, int16_t *block, int mb_x, int mb_y, int j)
            t->frame.data[0] + (mb_y*16 + ((j&2)<<2))*t->frame.linesize[0] + mb_x*16 + ((j&1)<<3),
            t->frame.linesize[0], block);
            t->frame.data[index] + (mb_y*8)*t->frame.linesize[index] + mb_x*8,
            t->frame.linesize[index], block);
static void decode_mb(MadContext *s, int inter)
            comp_block(s, s->mb_x, s->mb_y, j, mv_x, mv_y, add);
            idct_put(s, s->block, s->mb_x, s->mb_y, j);
    int inter;
        if (s->frame.data[0])
            avctx->release_buffer(avctx, &s->frame);
    s->frame.reference = 1;
    if (!s->frame.data[0]) {
        if (ff_get_buffer(avctx, &s->frame) < 0) {
            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
            return -1;
        }
            decode_mb(s, inter);
    *(AVFrame*)data = s->frame;
    if (chunk_type != MADe_TAG)
        FFSWAP(AVFrame, s->frame, s->last_frame);
    if (t->frame.data[0])
        avctx->release_buffer(avctx, &t->frame);
    if (t->last_frame.data[0])
        avctx->release_buffer(avctx, &t->last_frame);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR, VAR(VAR->VAR[0] + (VAR*16 + ((VAR&2)<<2))*VAR->VAR[0] + VAR*16 + ((VAR&1)<<3), VAR->VAR[0], VAR(VAR->VAR[VAR] + (VAR*8)*VAR->VAR[VAR] + VAR * 8, VAR->VAR[VAR], VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR, VAR VAR, VAR VAR, VAR VAR) VAR->VAR[0] + (VAR*16 + ((VAR&2)<<2))*VAR->VAR[0] + VAR*16 + ((VAR&1)<<3), VAR->VAR[0], VAR); VAR->VAR[VAR] + (VAR*8)*VAR->VAR[VAR] + VAR*8, VAR->VAR[VAR], VAR); VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR(VAR, VAR, VAR->VAR, VAR->VAR, VAR, VAR, VAR, VAR); VAR(VAR, VAR, VAR->VAR, VAR->VAR, VAR->VAR, VAR); VAR *VAR = VAR; VAR VAR, VAR; VAR(&VAR->VAR); VAR ((VAR = VAR(VAR, VAR, VAR)) < 0) { VAR(VAR, VAR, ""VAR() VAR\VAR""); VAR VAR; VAR(VAR, VAR, VAR); VAR (VAR != VAR) { VAR(&VAR->VAR); VAR ((VAR = VAR(&VAR->VAR, VAR)) < 0) VAR VAR; } VAR(&VAR->VAR); VAR VAR; VAR VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR, VAR(VAR->VAR.VAR[0] + (VAR*16 + ((VAR&2)<<2))*VAR->VAR.VAR[0] + VAR*16 + ((VAR&1)<<3), VAR->VAR.VAR[0], VAR(VAR->VAR.VAR[VAR] + (VAR*8)*VAR->VAR.VAR[VAR] + VAR * 8, VAR->VAR.VAR[VAR], VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR, VAR VAR) VAR->VAR.VAR[0] + (VAR*16 + ((VAR&2)<<2))*VAR->VAR.VAR[0] + VAR*16 + ((VAR&1)<<3), VAR->VAR.VAR[0], VAR); VAR->VAR.VAR[VAR] + (VAR*8)*VAR->VAR.VAR[VAR] + VAR*8, VAR->VAR.VAR[VAR], VAR); VAR VAR VAR(VAR *VAR, VAR VAR) VAR(VAR, VAR->VAR, VAR->VAR, VAR, VAR, VAR, VAR); VAR(VAR, VAR->VAR, VAR->VAR, VAR->VAR, VAR); VAR VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR->VAR.VAR = 1; VAR (!VAR->VAR.VAR[0]) { VAR (VAR(VAR, &VAR->VAR) < 0) { VAR(VAR, VAR, ""VAR() VAR\VAR""); VAR -1; } VAR(VAR, VAR); *(VAR*)VAR = VAR->VAR; VAR (VAR != VAR) VAR(VAR, VAR->VAR, VAR->VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR);",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/eatgq.c,"static void tgq_idct_put_mb(TgqContext *s, int16_t (*block)[64], AVFrame *frame,
    int linesize = frame->linesize[0];
    uint8_t *dest_y  = frame->data[0] + (mb_y * 16 * linesize)           + mb_x * 16;
    uint8_t *dest_cb = frame->data[1] + (mb_y * 8  * frame->linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = frame->data[2] + (mb_y * 8  * frame->linesize[2]) + mb_x * 8;
         ff_ea_idct_put_c(dest_cb, frame->linesize[1], block[4]);
         ff_ea_idct_put_c(dest_cr, frame->linesize[2], block[5]);
static void tgq_idct_put_mb_dconly(TgqContext *s, AVFrame *frame,
                                   int mb_x, int mb_y, const int8_t *dc)
    int linesize = frame->linesize[0];
    uint8_t *dest_y  = frame->data[0] + (mb_y * 16 * linesize)             + mb_x * 16;
    uint8_t *dest_cb = frame->data[1] + (mb_y * 8  * frame->linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = frame->data[2] + (mb_y * 8  * frame->linesize[2]) + mb_x * 8;
        tgq_dconly(s, dest_cb, frame->linesize[1], dc[4]);
        tgq_dconly(s, dest_cr, frame->linesize[2], dc[5]);
static void tgq_decode_mb(TgqContext *s, AVFrame *frame, int mb_y, int mb_x)
        tgq_idct_put_mb(s, s->block, frame, mb_x, mb_y);
        tgq_idct_put_mb_dconly(s, frame, mb_x, mb_y, dc);
    AVFrame *frame     = data;
    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
        return ret;
    frame->key_frame = 1;
    frame->pict_type = AV_PICTURE_TYPE_I;
            tgq_decode_mb(s, frame, y, x);","    AVFrame frame;
static void tgq_idct_put_mb(TgqContext *s, int16_t (*block)[64],
    int linesize = s->frame.linesize[0];
    uint8_t *dest_y  = s->frame.data[0] + (mb_y * 16 * linesize)             + mb_x * 16;
    uint8_t *dest_cb = s->frame.data[1] + (mb_y * 8  * s->frame.linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = s->frame.data[2] + (mb_y * 8  * s->frame.linesize[2]) + mb_x * 8;
         ff_ea_idct_put_c(dest_cb, s->frame.linesize[1], block[4]);
         ff_ea_idct_put_c(dest_cr, s->frame.linesize[2], block[5]);
static void tgq_idct_put_mb_dconly(TgqContext *s, int mb_x, int mb_y, const int8_t *dc)
    int linesize = s->frame.linesize[0];
    uint8_t *dest_y  = s->frame.data[0] + (mb_y * 16 * linesize)             + mb_x * 16;
    uint8_t *dest_cb = s->frame.data[1] + (mb_y * 8  * s->frame.linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = s->frame.data[2] + (mb_y * 8  * s->frame.linesize[2]) + mb_x * 8;
        tgq_dconly(s, dest_cb, s->frame.linesize[1], dc[4]);
        tgq_dconly(s, dest_cr, s->frame.linesize[2], dc[5]);
static void tgq_decode_mb(TgqContext *s, int mb_y, int mb_x)
        tgq_idct_put_mb(s, s->block, mb_x, mb_y);
        tgq_idct_put_mb_dconly(s, mb_x, mb_y, dc);
        if (s->frame.data[0])
            avctx->release_buffer(avctx, &s->frame);
    if (!s->frame.data[0]) {
        s->frame.key_frame = 1;
        s->frame.pict_type = AV_PICTURE_TYPE_I;
        s->frame.buffer_hints = FF_BUFFER_HINTS_VALID;
        if ((ret = ff_get_buffer(avctx, &s->frame)) < 0) {
            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
            return ret;
        }
            tgq_decode_mb(s, y, x);
    *(AVFrame*)data = s->frame;
static av_cold int tgq_decode_end(AVCodecContext *avctx)
{
    TgqContext *s = avctx->priv_data;
    if (s->frame.data[0])
        s->avctx->release_buffer(avctx, &s->frame);
    return 0;
}

    .close          = tgq_decode_end,",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR VAR(VAR *VAR, VAR (*VAR)[64], VAR *VAR, VAR VAR = VAR->VAR[0]; VAR *VAR = VAR->VAR[0] + (VAR * 16 * VAR) + VAR * 16; VAR *VAR = VAR->VAR[1] + (VAR * 8 * VAR->VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR[2] + (VAR * 8 * VAR->VAR[2]) + VAR * 8; VAR(VAR, VAR->VAR[1], VAR[4]); VAR(VAR, VAR->VAR[2], VAR[5]); VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR, VAR VAR *VAR) VAR VAR = VAR->VAR[0]; VAR *VAR = VAR->VAR[0] + (VAR * 16 * VAR) + VAR * 16; VAR *VAR = VAR->VAR[1] + (VAR * 8 * VAR->VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR[2] + (VAR * 8 * VAR->VAR[2]) + VAR * 8; VAR(VAR, VAR, VAR->VAR[1], VAR[4]); VAR(VAR, VAR, VAR->VAR[2], VAR[5]); VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR) VAR(VAR, VAR->VAR, VAR, VAR, VAR); VAR(VAR, VAR, VAR, VAR, VAR); VAR *VAR = VAR; VAR ((VAR = VAR(VAR, VAR, 0)) < 0) { VAR(VAR, VAR, ""VAR() VAR\VAR""); VAR VAR; VAR->VAR = 1; VAR->VAR = VAR; VAR(VAR, VAR, VAR, VAR); VAR VAR; VAR VAR VAR(VAR *VAR, VAR (*VAR)[64], VAR VAR = VAR->VAR.VAR[0]; VAR *VAR = VAR->VAR.VAR[0] + (VAR * 16 * VAR) + VAR * 16; VAR *VAR = VAR->VAR.VAR[1] + (VAR * 8 * VAR->VAR.VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR.VAR[2] + (VAR * 8 * VAR->VAR.VAR[2]) + VAR * 8; VAR(VAR, VAR->VAR.VAR[1], VAR[4]); VAR(VAR, VAR->VAR.VAR[2], VAR[5]); VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR, VAR VAR *VAR) VAR VAR = VAR->VAR.VAR[0]; VAR *VAR = VAR->VAR.VAR[0] + (VAR * 16 * VAR) + VAR * 16; VAR *VAR = VAR->VAR.VAR[1] + (VAR * 8 * VAR->VAR.VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR.VAR[2] + (VAR * 8 * VAR->VAR.VAR[2]) + VAR * 8; VAR(VAR, VAR, VAR->VAR.VAR[1], VAR[4]); VAR(VAR, VAR, VAR->VAR.VAR[2], VAR[5]); VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR) VAR(VAR, VAR->VAR, VAR, VAR); VAR(VAR, VAR, VAR, VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR (!VAR->VAR.VAR[0]) { VAR->VAR.VAR = 1; VAR->VAR.VAR = VAR; VAR->VAR.VAR = VAR; VAR ((VAR = VAR(VAR, &VAR->VAR)) < 0) { VAR(VAR, VAR, ""VAR() VAR\VAR""); VAR VAR; } VAR(VAR, VAR, VAR); *(VAR*)VAR = VAR->VAR; VAR VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR->VAR(VAR, &VAR->VAR); VAR 0; } .VAR = VAR,",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/eatqi.c,"static inline void tqi_idct_put(TqiContext *t, AVFrame *frame, int16_t (*block)[64])
    int linesize = frame->linesize[0];
    uint8_t *dest_y  = frame->data[0] + (s->mb_y * 16* linesize            ) + s->mb_x * 16;
    uint8_t *dest_cb = frame->data[1] + (s->mb_y * 8 * frame->linesize[1]) + s->mb_x * 8;
    uint8_t *dest_cr = frame->data[2] + (s->mb_y * 8 * frame->linesize[2]) + s->mb_x * 8;
        ff_ea_idct_put_c(dest_cb, frame->linesize[1], block[4]);
        ff_ea_idct_put_c(dest_cr, frame->linesize[2], block[5]);
    AVFrame *frame = data;
    int ret;
    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
        return ret;
        tqi_idct_put(t, frame, t->block);","    AVFrame frame;
static inline void tqi_idct_put(TqiContext *t, int16_t (*block)[64])
    int linesize= t->frame.linesize[0];
    uint8_t *dest_y  = t->frame.data[0] + (s->mb_y * 16* linesize            ) + s->mb_x * 16;
    uint8_t *dest_cb = t->frame.data[1] + (s->mb_y * 8 * t->frame.linesize[1]) + s->mb_x * 8;
    uint8_t *dest_cr = t->frame.data[2] + (s->mb_y * 8 * t->frame.linesize[2]) + s->mb_x * 8;
        ff_ea_idct_put_c(dest_cb, t->frame.linesize[1], block[4]);
        ff_ea_idct_put_c(dest_cr, t->frame.linesize[2], block[5]);
    if (t->frame.data[0])
        avctx->release_buffer(avctx, &t->frame);

    if(ff_get_buffer(avctx, &t->frame) < 0) {
        return -1;
        tqi_idct_put(t, t->block);
    *(AVFrame*)data = t->frame;
    if(t->frame.data[0])
        avctx->release_buffer(avctx, &t->frame);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR (*VAR)[64]) VAR VAR = VAR->VAR[0]; VAR *VAR = VAR->VAR[0] + (VAR->VAR * 16* VAR ) + VAR->VAR * 16; VAR *VAR = VAR->VAR[1] + (VAR->VAR * 8 * VAR->VAR[1]) + VAR->VAR * 8; VAR *VAR = VAR->VAR[2] + (VAR->VAR * 8 * VAR->VAR[2]) + VAR->VAR * 8; VAR(VAR, VAR->VAR[1], VAR[4]); VAR(VAR, VAR->VAR[2], VAR[5]); VAR *VAR = VAR; VAR VAR; VAR ((VAR = VAR(VAR, VAR, 0)) < 0) { VAR VAR; VAR(VAR, VAR, VAR->VAR); VAR VAR; VAR VAR VAR VAR(VAR *VAR, VAR (*VAR)[64]) VAR VAR= VAR->VAR.VAR[0]; VAR *VAR = VAR->VAR.VAR[0] + (VAR->VAR * 16* VAR ) + VAR->VAR * 16; VAR *VAR = VAR->VAR.VAR[1] + (VAR->VAR * 8 * VAR->VAR.VAR[1]) + VAR->VAR * 8; VAR *VAR = VAR->VAR.VAR[2] + (VAR->VAR * 8 * VAR->VAR.VAR[2]) + VAR->VAR * 8; VAR(VAR, VAR->VAR.VAR[1], VAR[4]); VAR(VAR, VAR->VAR.VAR[2], VAR[5]); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR(VAR(VAR, &VAR->VAR) < 0) { VAR -1; VAR(VAR, VAR->VAR); *(VAR*)VAR = VAR->VAR; VAR(VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR);",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/mdec.c,"    ThreadFrame frame;
static inline void idct_put(MDECContext *a, AVFrame *frame, int mb_x, int mb_y)
    int linesize = frame->linesize[0];
    uint8_t *dest_y  = frame->data[0] + (mb_y * 16* linesize              ) + mb_x * 16;
    uint8_t *dest_cb = frame->data[1] + (mb_y * 8 * frame->linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = frame->data[2] + (mb_y * 8 * frame->linesize[2]) + mb_x * 8;
        a->dsp.idct_put(dest_cb, frame->linesize[1], block[4]);
        a->dsp.idct_put(dest_cr, frame->linesize[2], block[5]);
    ThreadFrame frame     = { .f = data };
    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) {
    frame.f->pict_type = AV_PICTURE_TYPE_I;
    frame.f->key_frame = 1;
            idct_put(a, frame.f, a->mb_x, a->mb_y);","    AVFrame picture;
static inline void idct_put(MDECContext *a, int mb_x, int mb_y)
    int linesize = a->picture.linesize[0];
    uint8_t *dest_y  = a->picture.data[0] + (mb_y * 16 * linesize              ) + mb_x * 16;
    uint8_t *dest_cb = a->picture.data[1] + (mb_y * 8  * a->picture.linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = a->picture.data[2] + (mb_y * 8  * a->picture.linesize[2]) + mb_x * 8;
        a->dsp.idct_put(dest_cb, a->picture.linesize[1], block[4]);
        a->dsp.idct_put(dest_cr, a->picture.linesize[2], block[5]);
    AVFrame *picture      = data;
    AVFrame * const p     = &a->picture;
    if (p->data[0])
        ff_thread_release_buffer(avctx, p);

    p->reference = 0;
    if ((ret = ff_thread_get_buffer(avctx, p)) < 0) {
    p->pict_type = AV_PICTURE_TYPE_I;
    p->key_frame = 1;
            idct_put(a, a->mb_x, a->mb_y);
    p->quality = a->qscale * FF_QP2LAMBDA;
    memset(p->qscale_table, a->qscale, a->mb_width);

    *picture   = a->picture;
    AVFrame *p            = &a->picture;
    avctx->coded_frame = &a->picture;
    p->qstride      = 0;
    p->qscale_table = av_mallocz(a->mb_width);
    AVFrame *p            = &a->picture;
    avctx->coded_frame = p;
    p->qscale_table = av_mallocz( a->mb_width);

    if (a->picture.data[0])
        avctx->release_buffer(avctx, &a->picture);
    av_freep(&a->picture.qscale_table);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR; VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR) VAR VAR = VAR->VAR[0]; VAR *VAR = VAR->VAR[0] + (VAR * 16* VAR ) + VAR * 16; VAR *VAR = VAR->VAR[1] + (VAR * 8 * VAR->VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR[2] + (VAR * 8 * VAR->VAR[2]) + VAR * 8; VAR->VAR.VAR(VAR, VAR->VAR[1], VAR[4]); VAR->VAR.VAR(VAR, VAR->VAR[2], VAR[5]); VAR VAR = { .VAR = VAR }; VAR ((VAR = VAR(VAR, &VAR, 0)) < 0) { VAR.VAR->VAR = VAR; VAR.VAR->VAR = 1; VAR(VAR, VAR.VAR, VAR->VAR, VAR->VAR); VAR VAR; VAR VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR) VAR VAR = VAR->VAR.VAR[0]; VAR *VAR = VAR->VAR.VAR[0] + (VAR * 16 * VAR ) + VAR * 16; VAR *VAR = VAR->VAR.VAR[1] + (VAR * 8 * VAR->VAR.VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR.VAR[2] + (VAR * 8 * VAR->VAR.VAR[2]) + VAR * 8; VAR->VAR.VAR(VAR, VAR->VAR.VAR[1], VAR[4]); VAR->VAR.VAR(VAR, VAR->VAR.VAR[2], VAR[5]); VAR *VAR = VAR; VAR * VAR VAR = &VAR->VAR; VAR (VAR->VAR[0]) VAR(VAR, VAR); VAR->VAR = 0; VAR ((VAR = VAR(VAR, VAR)) < 0) { VAR->VAR = VAR; VAR->VAR = 1; VAR(VAR, VAR->VAR, VAR->VAR); VAR->VAR = VAR->VAR * VAR; VAR(VAR->VAR, VAR->VAR, VAR->VAR); *VAR = VAR->VAR; VAR *VAR = &VAR->VAR; VAR->VAR = &VAR->VAR; VAR->VAR = 0; VAR->VAR = VAR(VAR->VAR); VAR *VAR = &VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR( VAR->VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR(&VAR->VAR.VAR);",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/mimic.c,"    ThreadFrame     frames     [16];
static av_cold int mimic_decode_end(AVCodecContext *avctx)
{
    MimicContext *ctx = avctx->priv_data;
    int i;

    av_free(ctx->swap_buf);

    for (i = 0; i < FF_ARRAY_ELEMS(ctx->frames); i++) {
        if (ctx->frames[i].f)
            ff_thread_release_buffer(avctx, &ctx->frames[i]);
        av_frame_free(&ctx->frames[i].f);
    }

    if (!avctx->internal->is_copy)
        ff_free_vlc(&ctx->vlc);

    return 0;
}

    int ret, i;

    avctx->internal->allocate_progress = 1;
    for (i = 0; i < FF_ARRAY_ELEMS(ctx->frames); i++) {
        ctx->frames[i].f = av_frame_alloc();
        if (!ctx->frames[i].f) {
            mimic_decode_end(avctx);
            return AVERROR(ENOMEM);
        }
    }

    int i, ret;
    for (i = 0; i < FF_ARRAY_ELEMS(dst->frames); i++) {
        ff_thread_release_buffer(avctx, &dst->frames[i]);
        if (src->frames[i].f->data[0]) {
            ret = ff_thread_ref_frame(&dst->frames[i], &src->frames[i]);
            if (ret < 0)
                return ret;
        }
    }
                            ff_thread_await_progress(&ctx->frames[index],
                    ff_thread_await_progress(&ctx->frames[ctx->prev_index],
            ff_thread_report_progress(&ctx->frames[ctx->cur_index],
    if (is_pframe && !ctx->frames[ctx->prev_index].f->data[0]) {
    ff_thread_release_buffer(avctx, &ctx->frames[ctx->cur_index]);
    ctx->frames[ctx->cur_index].f->pict_type = is_pframe ? AV_PICTURE_TYPE_P :
                                                           AV_PICTURE_TYPE_I;
    if ((res = ff_thread_get_buffer(avctx, &ctx->frames[ctx->cur_index],
                                    AV_GET_BUFFER_FLAG_REF)) < 0) {
                  ctx->frames[ctx->cur_index].f);
    ff_thread_report_progress(&ctx->frames[ctx->cur_index], INT_MAX, 0);
            ff_thread_release_buffer(avctx, &ctx->frames[ctx->cur_index]);
    if ((res = av_frame_ref(data, ctx->frames[ctx->cur_index].f)) < 0)
        return res;
    ff_thread_release_buffer(avctx, &ctx->frames[ctx->cur_index]);
static av_cold int mimic_init_thread_copy(AVCodecContext *avctx)
    for (i = 0; i < FF_ARRAY_ELEMS(ctx->frames); i++) {
        ctx->frames[i].f = av_frame_alloc();
        if (!ctx->frames[i].f) {
            mimic_decode_end(avctx);
            return AVERROR(ENOMEM);
        }
    }
    .update_thread_context = ONLY_IF_THREADS_ENABLED(mimic_decode_update_thread_context),
    .init_thread_copy      = ONLY_IF_THREADS_ENABLED(mimic_init_thread_copy),","    AVFrame         buf_ptrs    [16];
    int ret;
    memcpy(dst->buf_ptrs, src->buf_ptrs, sizeof(src->buf_ptrs));
    memset(&dst->buf_ptrs[dst->cur_index], 0, sizeof(AVFrame));
                            ff_thread_await_progress(&ctx->buf_ptrs[index],
                    ff_thread_await_progress(&ctx->buf_ptrs[ctx->prev_index],
            ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index],
    if (is_pframe && !ctx->buf_ptrs[ctx->prev_index].data[0]) {
    ctx->buf_ptrs[ctx->cur_index].reference = 1;
    ctx->buf_ptrs[ctx->cur_index].pict_type = is_pframe ? AV_PICTURE_TYPE_P :
                                                          AV_PICTURE_TYPE_I;
    if ((res = ff_thread_get_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index])) < 0) {
                  &ctx->buf_ptrs[ctx->cur_index]);
    ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index], INT_MAX, 0);
            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);
    *(AVFrame*)data = ctx->buf_ptrs[ctx->cur_index];
    if (ctx->buf_ptrs[ctx->cur_index].data[0])
        ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);
static av_cold int mimic_decode_end(AVCodecContext *avctx)
    av_free(ctx->swap_buf);

    if (avctx->internal->is_copy)
        return 0;

    for (i = 0; i < 16; i++)
        if (ctx->buf_ptrs[i].data[0])
            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[i]);
    ff_free_vlc(&ctx->vlc);
    .update_thread_context = ONLY_IF_THREADS_ENABLED(mimic_decode_update_thread_context)",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR [16]; VAR VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR VAR; VAR(VAR->VAR); VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR (VAR->VAR[VAR].VAR) VAR(VAR, &VAR->VAR[VAR]); VAR(&VAR->VAR[VAR].VAR); } VAR (!VAR->VAR->VAR) VAR(&VAR->VAR); VAR 0; } VAR VAR, VAR; VAR->VAR->VAR = 1; VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR->VAR[VAR].VAR = VAR(); VAR (!VAR->VAR[VAR].VAR) { VAR(VAR); VAR VAR(VAR); } } VAR VAR, VAR; VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR[VAR].VAR->VAR[0]) { VAR = VAR(&VAR->VAR[VAR], &VAR->VAR[VAR]); VAR (VAR < 0) VAR VAR; } } VAR(&VAR->VAR[VAR], VAR(&VAR->VAR[VAR->VAR], VAR(&VAR->VAR[VAR->VAR], VAR (VAR && !VAR->VAR[VAR->VAR].VAR->VAR[0]) { VAR(VAR, &VAR->VAR[VAR->VAR]); VAR->VAR[VAR->VAR].VAR->VAR = VAR ? VAR : VAR; VAR ((VAR = VAR(VAR, &VAR->VAR[VAR->VAR], VAR)) < 0) { VAR->VAR[VAR->VAR].VAR); VAR(&VAR->VAR[VAR->VAR], VAR, 0); VAR(VAR, &VAR->VAR[VAR->VAR]); VAR ((VAR = VAR(VAR, VAR->VAR[VAR->VAR].VAR)) < 0) VAR VAR; VAR(VAR, &VAR->VAR[VAR->VAR]); VAR VAR VAR VAR(VAR *VAR) VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR->VAR[VAR].VAR = VAR(); VAR (!VAR->VAR[VAR].VAR) { VAR(VAR); VAR VAR(VAR); } } .VAR = VAR(VAR), .VAR = VAR(VAR), VAR VAR [16]; VAR VAR; VAR(VAR->VAR, VAR->VAR, VAR(VAR->VAR)); VAR(&VAR->VAR[VAR->VAR], 0, VAR(VAR)); VAR(&VAR->VAR[VAR], VAR(&VAR->VAR[VAR->VAR], VAR(&VAR->VAR[VAR->VAR], VAR (VAR && !VAR->VAR[VAR->VAR].VAR[0]) { VAR->VAR[VAR->VAR].VAR = 1; VAR->VAR[VAR->VAR].VAR = VAR ? VAR : VAR; VAR ((VAR = VAR(VAR, &VAR->VAR[VAR->VAR])) < 0) { &VAR->VAR[VAR->VAR]); VAR(&VAR->VAR[VAR->VAR], VAR, 0); VAR(VAR, &VAR->VAR[VAR->VAR]); *(VAR*)VAR = VAR->VAR[VAR->VAR]; VAR (VAR->VAR[VAR->VAR].VAR[0]) VAR(VAR, &VAR->VAR[VAR->VAR]); VAR VAR VAR VAR(VAR *VAR) VAR(VAR->VAR); VAR (VAR->VAR->VAR) VAR 0; VAR (VAR = 0; VAR < 16; VAR++) VAR (VAR->VAR[VAR].VAR[0]) VAR(VAR, &VAR->VAR[VAR]); VAR(&VAR->VAR); .VAR = VAR(VAR)",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/mpegvideo_enc.c,"    int8_t * const qscale_table = s->current_picture.qscale_table;
    Picture *pic = NULL;
    int i, display_picture_number = 0, ret;
        if (!pic_arg->buf[0]);
            pic = &s->picture[i];
            if ((ret = av_frame_ref(&pic->f, pic_arg)) < 0)
                return ret;
            if (ff_alloc_picture(s, pic, 1) < 0) {
            pic = &s->picture[i];
            if (ff_alloc_picture(s, pic, 0) < 0) {
            if (pic->f.data[0] + INPLACE_OFFSET == pic_arg->data[0] &&
                pic->f.data[1] + INPLACE_OFFSET == pic_arg->data[1] &&
                pic->f.data[2] + INPLACE_OFFSET == pic_arg->data[2]) {
                    uint8_t *dst = pic->f.data[i];
        copy_picture_attributes(s, &pic->f, pic_arg);
        pic->f.display_picture_number = display_picture_number;
        pic->f.pts = pts; // we set this here to avoid modifiying pic_arg
                int off = p->shared ? 0 : 16;
            if (!pre_input.shared && i) {
    int i, ret;
                    av_frame_unref(&s->input_picture[0]->f);
        s->reordered_input_picture[0]->reference =
        ff_mpeg_unref_picture(s, &s->new_picture);
        if ((ret = ff_mpeg_ref_picture(s, &s->new_picture, s->reordered_input_picture[0])))
            return ret;
        if (s->reordered_input_picture[0]->shared || s->avctx->rc_buffer_size) {
            pic->reference = s->reordered_input_picture[0]->reference;
            /* mark us unused / free shared pic */
            av_frame_unref(&s->reordered_input_picture[0]->f);
            s->reordered_input_picture[0]->shared = 0;

        ff_mpeg_unref_picture(s, &s->current_picture);
        if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,
                                       s->current_picture_ptr)) < 0)
            return ret;
        ff_mpeg_unref_picture(s, &s->new_picture);
            s->qscale = s->current_picture_ptr->qscale_table[mb_xy];
                        s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0];
                        s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1];
                s->current_picture.qscale_table[xy] = best_s.qscale;
                        s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0];
                        s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1];","    int8_t * const qscale_table = s->current_picture.f.qscale_table;
    AVFrame *pic = NULL;
    int i, display_picture_number = 0;
        if (encoding_delay && !(s->flags & CODEC_FLAG_INPUT_PRESERVED))
            pic = &s->picture[i].f;
            for (i = 0; i < 4; i++) {
                pic->data[i]     = pic_arg->data[i];
                pic->linesize[i] = pic_arg->linesize[i];
            }
            if (ff_alloc_picture(s, (Picture *) pic, 1) < 0) {
            pic = &s->picture[i].f;
            if (ff_alloc_picture(s, (Picture *) pic, 0) < 0) {
            if (pic->data[0] + INPLACE_OFFSET == pic_arg->data[0] &&
                pic->data[1] + INPLACE_OFFSET == pic_arg->data[1] &&
                pic->data[2] + INPLACE_OFFSET == pic_arg->data[2]) {
                    uint8_t *dst = pic->data[i];
        copy_picture_attributes(s, pic, pic_arg);
        pic->display_picture_number = display_picture_number;
        pic->pts = pts; // we set this here to avoid modifiying pic_arg
                int off = p->f.type == FF_BUFFER_TYPE_SHARED ? 0 : 16;
            if (pre_input.f.type != FF_BUFFER_TYPE_SHARED && i) {
    int i;
                    if (s->input_picture[0]->f.type == FF_BUFFER_TYPE_SHARED) {
                        for (i = 0; i < 4; i++)
                            s->input_picture[0]->f.data[i] = NULL;
                        s->input_picture[0]->f.type = 0;
                    } else {
                        assert(s->input_picture[0]->f.type == FF_BUFFER_TYPE_USER ||
                               s->input_picture[0]->f.type == FF_BUFFER_TYPE_INTERNAL);

                        s->avctx->release_buffer(s->avctx,
                                                 &s->input_picture[0]->f);
                    }
        s->reordered_input_picture[0]->f.reference =
        ff_copy_picture(&s->new_picture, s->reordered_input_picture[0]);
        if (s->reordered_input_picture[0]->f.type == FF_BUFFER_TYPE_SHARED ||
            s->avctx->rc_buffer_size) {
            pic->f.reference = s->reordered_input_picture[0]->f.reference;
            /* mark us unused / free shared pic */
            if (s->reordered_input_picture[0]->f.type == FF_BUFFER_TYPE_INTERNAL)
                s->avctx->release_buffer(s->avctx,
                                         &s->reordered_input_picture[0]->f);
            for (i = 0; i < 4; i++)
                s->reordered_input_picture[0]->f.data[i] = NULL;
            s->reordered_input_picture[0]->f.type = 0;


            assert(s->reordered_input_picture[0]->f.type ==
                       FF_BUFFER_TYPE_USER ||
                   s->reordered_input_picture[0]->f.type ==
                       FF_BUFFER_TYPE_INTERNAL);

        ff_copy_picture(&s->current_picture, s->current_picture_ptr);
        memset(&s->new_picture, 0, sizeof(Picture));
            s->qscale = s->current_picture_ptr->f.qscale_table[mb_xy];
                        s->mv[0][i][0] = s->current_picture.f.motion_val[0][s->block_index[i]][0];
                        s->mv[0][i][1] = s->current_picture.f.motion_val[0][s->block_index[i]][1];
                s->current_picture.f.qscale_table[xy] = best_s.qscale;
                        s->mv[0][i][0] = s->current_picture.f.motion_val[0][s->block_index[i]][0];
                        s->mv[0][i][1] = s->current_picture.f.motion_val[0][s->block_index[i]][1];",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR * VAR VAR = VAR->VAR.VAR; VAR *VAR = VAR; VAR VAR, VAR = 0, VAR; VAR (!VAR->VAR[0]); VAR = &VAR->VAR[VAR]; VAR ((VAR = VAR(&VAR->VAR, VAR)) < 0) VAR VAR; VAR (VAR(VAR, VAR, 1) < 0) { VAR = &VAR->VAR[VAR]; VAR (VAR(VAR, VAR, 0) < 0) { VAR (VAR->VAR.VAR[0] + VAR == VAR->VAR[0] && VAR->VAR.VAR[1] + VAR == VAR->VAR[1] && VAR->VAR.VAR[2] + VAR == VAR->VAR[2]) { VAR *VAR = VAR->VAR.VAR[VAR]; VAR(VAR, &VAR->VAR, VAR); VAR->VAR.VAR = VAR; VAR->VAR.VAR = VAR;  VAR VAR = VAR->VAR ? 0 : 16; VAR (!VAR.VAR && VAR) { VAR VAR, VAR; VAR(&VAR->VAR[0]->VAR); VAR->VAR[0]->VAR = VAR(VAR, &VAR->VAR); VAR ((VAR = VAR(VAR, &VAR->VAR, VAR->VAR[0]))) VAR VAR; VAR (VAR->VAR[0]->VAR || VAR->VAR->VAR) { VAR->VAR = VAR->VAR[0]->VAR;  VAR(&VAR->VAR[0]->VAR); VAR->VAR[0]->VAR = 0; VAR(VAR, &VAR->VAR); VAR ((VAR = VAR(VAR, &VAR->VAR, VAR->VAR)) < 0) VAR VAR; VAR(VAR, &VAR->VAR); VAR->VAR = VAR->VAR->VAR[VAR]; VAR->VAR[0][VAR][0] = VAR->VAR.VAR[0][VAR->VAR[VAR]][0]; VAR->VAR[0][VAR][1] = VAR->VAR.VAR[0][VAR->VAR[VAR]][1]; VAR->VAR.VAR[VAR] = VAR.VAR; VAR->VAR[0][VAR][0] = VAR->VAR.VAR[0][VAR->VAR[VAR]][0]; VAR->VAR[0][VAR][1] = VAR->VAR.VAR[0][VAR->VAR[VAR]][1]; VAR * VAR VAR = VAR->VAR.VAR.VAR; VAR *VAR = VAR; VAR VAR, VAR = 0; VAR (VAR && !(VAR->VAR & VAR)) VAR = &VAR->VAR[VAR].VAR; VAR (VAR = 0; VAR < 4; VAR++) { VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR->VAR[VAR]; } VAR (VAR(VAR, (VAR *) VAR, 1) < 0) { VAR = &VAR->VAR[VAR].VAR; VAR (VAR(VAR, (VAR *) VAR, 0) < 0) { VAR (VAR->VAR[0] + VAR == VAR->VAR[0] && VAR->VAR[1] + VAR == VAR->VAR[1] && VAR->VAR[2] + VAR == VAR->VAR[2]) { VAR *VAR = VAR->VAR[VAR]; VAR(VAR, VAR, VAR); VAR->VAR = VAR; VAR->VAR = VAR;  VAR VAR = VAR->VAR.VAR == VAR ? 0 : 16; VAR (VAR.VAR.VAR != VAR && VAR) { VAR VAR; VAR (VAR->VAR[0]->VAR.VAR == VAR) { VAR (VAR = 0; VAR < 4; VAR++) VAR->VAR[0]->VAR.VAR[VAR] = VAR; VAR->VAR[0]->VAR.VAR = 0; } VAR { VAR(VAR->VAR[0]->VAR.VAR == VAR || VAR->VAR[0]->VAR.VAR == VAR); VAR->VAR->VAR(VAR->VAR, &VAR->VAR[0]->VAR); } VAR->VAR[0]->VAR.VAR = VAR(&VAR->VAR, VAR->VAR[0]); VAR (VAR->VAR[0]->VAR.VAR == VAR || VAR->VAR->VAR) { VAR->VAR.VAR = VAR->VAR[0]->VAR.VAR;  VAR (VAR->VAR[0]->VAR.VAR == VAR) VAR->VAR->VAR(VAR->VAR, &VAR->VAR[0]->VAR); VAR (VAR = 0; VAR < 4; VAR++) VAR->VAR[0]->VAR.VAR[VAR] = VAR; VAR->VAR[0]->VAR.VAR = 0; VAR(VAR->VAR[0]->VAR.VAR == VAR || VAR->VAR[0]->VAR.VAR == VAR); VAR(&VAR->VAR, VAR->VAR); VAR(&VAR->VAR, 0, VAR(VAR)); VAR->VAR = VAR->VAR->VAR.VAR[VAR]; VAR->VAR[0][VAR][0] = VAR->VAR.VAR.VAR[0][VAR->VAR[VAR]][0]; VAR->VAR[0][VAR][1] = VAR->VAR.VAR.VAR[0][VAR->VAR[VAR]][1]; VAR->VAR.VAR.VAR[VAR] = VAR.VAR; VAR->VAR[0][VAR][0] = VAR->VAR.VAR.VAR[0][VAR->VAR[VAR]][0]; VAR->VAR[0][VAR][1] = VAR->VAR.VAR.VAR[0][VAR->VAR[VAR]][1];",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/tmv.c,"    AVFrame *frame     = data;
    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
    frame->pict_type = AV_PICTURE_TYPE_I;
    frame->key_frame = 1;
    dst              = frame->data[0];
    frame->palette_has_changed = 1;
    memcpy(frame->data[1], ff_cga_palette, 16 * 4);
            ff_draw_pc_font(dst + x * 8, frame->linesize[0],
        dst += frame->linesize[0] * 8;
","typedef struct TMVContext {
    AVFrame pic;
} TMVContext;

    TMVContext *tmv    = avctx->priv_data;
    if (tmv->pic.data[0])
        avctx->release_buffer(avctx, &tmv->pic);

    if ((ret = ff_get_buffer(avctx, &tmv->pic)) < 0) {
    tmv->pic.pict_type = AV_PICTURE_TYPE_I;
    tmv->pic.key_frame = 1;
    dst                = tmv->pic.data[0];
    tmv->pic.palette_has_changed = 1;
    memcpy(tmv->pic.data[1], ff_cga_palette, 16 * 4);
            ff_draw_pc_font(dst + x * 8, tmv->pic.linesize[0],
        dst += tmv->pic.linesize[0] * 8;
    *(AVFrame *)data = tmv->pic;
static av_cold int tmv_decode_close(AVCodecContext *avctx)
{
    TMVContext *tmv = avctx->priv_data;

    if (tmv->pic.data[0])
        avctx->release_buffer(avctx, &tmv->pic);

    return 0;
}

    .priv_data_size = sizeof(TMVContext),
    .close          = tmv_decode_close,",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR *VAR = VAR; VAR ((VAR = VAR(VAR, VAR, 0)) < 0) { VAR->VAR = VAR; VAR->VAR = 1; VAR = VAR->VAR[0]; VAR->VAR = 1; VAR(VAR->VAR[1], VAR, 16 * 4); VAR(VAR + VAR * 8, VAR->VAR[0], VAR += VAR->VAR[0] * 8; VAR VAR VAR { VAR VAR; } VAR; VAR *VAR = VAR->VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR ((VAR = VAR(VAR, &VAR->VAR)) < 0) { VAR->VAR.VAR = VAR; VAR->VAR.VAR = 1; VAR = VAR->VAR.VAR[0]; VAR->VAR.VAR = 1; VAR(VAR->VAR.VAR[1], VAR, 16 * 4); VAR(VAR + VAR * 8, VAR->VAR.VAR[0], VAR += VAR->VAR.VAR[0] * 8; *(VAR *)VAR = VAR->VAR; VAR VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR 0; } .VAR = VAR(VAR), .VAR = VAR,",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/utils.c,"#include ""libavutil/frame.h""
static int update_frame_pool(AVCodecContext *avctx, AVFrame *frame)
    FramePool *pool = avctx->internal->pool;
    int i, ret;
    switch (avctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO: {
        int size[4] = { 0 };
        int w = frame->width;
        int h = frame->height;
        int tmpsize, unaligned;
        if (pool->format == frame->format &&
            pool->width == frame->width && pool->height == frame->height)
            return 0;
        avcodec_align_dimensions2(avctx, &w, &h, pool->stride_align);
        if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) {
            av_image_fill_linesizes(picture.linesize, avctx->pix_fmt, w);
                unaligned |= picture.linesize[i] % pool->stride_align[i];
        tmpsize = av_image_fill_pointers(picture.data, avctx->pix_fmt, h,
                                         NULL, picture.linesize);
        for (i = 0; i < 4; i++) {
            av_buffer_pool_uninit(&pool->pools[i]);
            pool->linesize[i] = picture.linesize[i];
            if (size[i]) {
                pool->pools[i] = av_buffer_pool_init(size[i] + 16, NULL);
                if (!pool->pools[i]) {
                    ret = AVERROR(ENOMEM);
                    goto fail;
                }
            }
        }
        pool->format = frame->format;
        pool->width  = frame->width;
        pool->height = frame->height;
        break;
        }
    case AVMEDIA_TYPE_AUDIO: {
        int ch     = av_get_channel_layout_nb_channels(frame->channel_layout);
        int planar = av_sample_fmt_is_planar(frame->format);
        int planes = planar ? ch : 1;

        if (pool->format == frame->format && pool->planes == planes &&
            pool->channels == ch && frame->nb_samples == pool->samples)
            return 0;

        av_buffer_pool_uninit(&pool->pools[0]);
        ret = av_samples_get_buffer_size(&pool->linesize[0], ch,
                                         frame->nb_samples, frame->format, 0);
        if (ret < 0)
            goto fail;

        pool->pools[0] = av_buffer_pool_init(pool->linesize[0], NULL);
        if (!pool->pools[0]) {
            ret = AVERROR(ENOMEM);
            goto fail;
        }
        pool->format     = frame->format;
        pool->planes     = planes;
        pool->channels   = ch;
        pool->samples = frame->nb_samples;
        break;
        }
    default: av_assert0(0);
    }
    return 0;
fail:
    for (i = 0; i < 4; i++)
        av_buffer_pool_uninit(&pool->pools[i]);
    pool->format = -1;
    pool->planes = pool->channels = pool->samples = 0;
    pool->width  = pool->height = 0;
    return ret;
}
static int audio_get_buffer(AVCodecContext *avctx, AVFrame *frame)
{
    FramePool *pool = avctx->internal->pool;
    int planes = pool->planes;
    int i;
    frame->linesize[0] = pool->linesize[0];

    if (planes > AV_NUM_DATA_POINTERS) {
        frame->extended_data = av_mallocz(planes * sizeof(*frame->extended_data));
        frame->nb_extended_buf = planes - AV_NUM_DATA_POINTERS;
        frame->extended_buf  = av_mallocz(frame->nb_extended_buf *
                                          sizeof(*frame->extended_buf));
        if (!frame->extended_data || !frame->extended_buf) {
            av_freep(&frame->extended_data);
            av_freep(&frame->extended_buf);
            return AVERROR(ENOMEM);
    } else
        frame->extended_data = frame->data;

    for (i = 0; i < FFMIN(planes, AV_NUM_DATA_POINTERS); i++) {
        frame->buf[i] = av_buffer_pool_get(pool->pools[0]);
        if (!frame->buf[i])
            goto fail;
        frame->extended_data[i] = frame->data[i] = frame->buf[i]->data;
    for (i = 0; i < frame->nb_extended_buf; i++) {
        frame->extended_buf[i] = av_buffer_pool_get(pool->pools[0]);
        if (!frame->extended_buf[i])
            goto fail;
        frame->extended_data[i + AV_NUM_DATA_POINTERS] = frame->extended_buf[i]->data;
    }

    if (avctx->debug & FF_DEBUG_BUFFERS)
        av_log(avctx, AV_LOG_DEBUG, ""default_get_buffer called on frame %p"", frame);

    return 0;
fail:
    av_frame_unref(frame);
    return AVERROR(ENOMEM);
}
static int video_get_buffer(AVCodecContext *s, AVFrame *pic)
{
    FramePool *pool = s->internal->pool;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pic->format);
    int pixel_size = desc->comp[0].step_minus1 + 1;
    int h_chroma_shift, v_chroma_shift;
    int i;

    if (pic->data[0] != NULL) {
        av_log(s, AV_LOG_ERROR, ""pic->data[0]!=NULL in avcodec_default_get_buffer\n"");
        return -1;

    memset(pic->data, 0, sizeof(pic->data));

    av_pix_fmt_get_chroma_sub_sample(s->pix_fmt, &h_chroma_shift, &v_chroma_shift);

    for (i = 0; i < 4 && pool->pools[i]; i++) {
        const int h_shift = i == 0 ? 0 : h_chroma_shift;
        const int v_shift = i == 0 ? 0 : v_chroma_shift;

        pic->linesize[i] = pool->linesize[i];

        pic->buf[i] = av_buffer_pool_get(pool->pools[i]);
        if (!pic->buf[i])
            goto fail;

        // no edge if EDGE EMU or not planar YUV
        if ((s->flags & CODEC_FLAG_EMU_EDGE) || !pool->pools[2])
            pic->data[i] = pic->buf[i]->data;
        else {
            pic->data[i] = pic->buf[i]->data +
                FFALIGN((pic->linesize[i] * EDGE_WIDTH >> v_shift) +
                        (pixel_size * EDGE_WIDTH >> h_shift), pool->stride_align[i]);
        }
    }
    for (; i < AV_NUM_DATA_POINTERS; i++) {
        pic->data[i] = NULL;
        pic->linesize[i] = 0;
    }
    if (pic->data[1] && !pic->data[2])
        avpriv_set_systematic_pal2((uint32_t *)pic->data[1], s->pix_fmt);
        av_log(s, AV_LOG_DEBUG, ""default_get_buffer called on pic %p\n"", pic);
fail:
    av_frame_unref(pic);
    return AVERROR(ENOMEM);
int avcodec_default_get_buffer2(AVCodecContext *avctx, AVFrame *frame, int flags)
    int ret;

    if ((ret = update_frame_pool(avctx, frame)) < 0)
        return ret;

#if FF_API_GET_BUFFER
#endif

#if FF_API_GET_BUFFER
int avcodec_default_get_buffer(AVCodecContext *avctx, AVFrame *frame)
    return avcodec_default_get_buffer2(avctx, frame, 0);
}

typedef struct CompatReleaseBufPriv {
    AVCodecContext avctx;
    AVFrame frame;
} CompatReleaseBufPriv;

static void compat_free_buffer(void *opaque, uint8_t *data)
{
    CompatReleaseBufPriv *priv = opaque;
    priv->avctx.release_buffer(&priv->avctx, &priv->frame);
    av_freep(&priv);
}

static void compat_release_buffer(void *opaque, uint8_t *data)
{
    AVBufferRef *buf = opaque;
    av_buffer_unref(&buf);
}
#endif

int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags)
{
    int ret;


        if ((ret = av_image_check_size(avctx->width, avctx->height, 0, avctx)) < 0)
            return ret;
#if FF_API_GET_BUFFER
    /*
     * Wrap an old get_buffer()-allocated buffer in an bunch of AVBuffers.
     * We wrap each plane in its own AVBuffer. Each of those has a reference to
     * a dummy AVBuffer as its private data, unreffing it on free.
     * When all the planes are freed, the dummy buffer's free callback calls
     * release_buffer().
     */
    if (avctx->get_buffer) {
        CompatReleaseBufPriv *priv = NULL;
        AVBufferRef *dummy_buf = NULL;
        int planes, i, ret;
        if (flags & AV_GET_BUFFER_FLAG_REF)
            frame->reference    = 1;
        ret = avctx->get_buffer(avctx, frame);
        if (ret < 0)
            return ret;
        /* return if the buffers are already set up
         * this would happen e.g. when a custom get_buffer() calls
         * avcodec_default_get_buffer
         */
        if (frame->buf[0])
            return 0;

        priv = av_mallocz(sizeof(*priv));
        if (!priv) {
            ret = AVERROR(ENOMEM);
            goto fail;
        }
        priv->avctx = *avctx;
        priv->frame = *frame;
        dummy_buf = av_buffer_create(NULL, 0, compat_free_buffer, priv, 0);
        if (!dummy_buf) {
            ret = AVERROR(ENOMEM);
            goto fail;
#define WRAP_PLANE(ref_out, data, data_size)                            \
do {                                                                    \
    AVBufferRef *dummy_ref = av_buffer_ref(dummy_buf);                  \
    if (!dummy_ref) {                                                   \
        ret = AVERROR(ENOMEM);                                          \
        goto fail;                                                      \
    }                                                                   \
    ref_out = av_buffer_create(data, data_size, compat_release_buffer,  \
                               dummy_ref, 0);                           \
    if (!ref_out) {                                                     \
        av_frame_unref(frame);                                          \
        ret = AVERROR(ENOMEM);                                          \
        goto fail;                                                      \
    }                                                                   \
} while (0)

        if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);

            if (!desc) {
                ret = AVERROR(EINVAL);
                goto fail;
            }
            planes = (desc->flags & PIX_FMT_PLANAR) ? desc->nb_components : 1;
            for (i = 0; i < planes; i++) {
                int h_shift    = (i == 1 || i == 2) ? desc->log2_chroma_h : 0;
                int plane_size = (frame->width >> h_shift) * frame->linesize[i];
                WRAP_PLANE(frame->buf[i], frame->data[i], plane_size);
            }
        } else {
            int planar = av_sample_fmt_is_planar(frame->format);
            planes = planar ? avctx->channels : 1;

            if (planes > FF_ARRAY_ELEMS(frame->buf)) {
                frame->nb_extended_buf = planes - FF_ARRAY_ELEMS(frame->buf);
                frame->extended_buf = av_malloc(sizeof(*frame->extended_buf) *
                                                frame->nb_extended_buf);
                if (!frame->extended_buf) {
                    ret = AVERROR(ENOMEM);
                    goto fail;
                }
            }
            for (i = 0; i < FFMIN(planes, FF_ARRAY_ELEMS(frame->buf)); i++)
                WRAP_PLANE(frame->buf[i], frame->extended_data[i], frame->linesize[0]);

            for (i = 0; i < planes - FF_ARRAY_ELEMS(frame->buf); i++)
                WRAP_PLANE(frame->extended_buf[i],
                           frame->extended_data[i + FF_ARRAY_ELEMS(frame->buf)],
                           frame->linesize[0]);
        }

        av_buffer_unref(&dummy_buf);
        return 0;
fail:
        avctx->release_buffer(avctx, frame);
        av_freep(&priv);
        av_buffer_unref(&dummy_buf);
        return ret;
#endif

    return avctx->get_buffer2(avctx, frame, flags);
}

int ff_reget_buffer(AVCodecContext *avctx, AVFrame *frame)
{
    AVFrame tmp;
    int ret;
    av_assert0(avctx->codec_type == AVMEDIA_TYPE_VIDEO);

    if (!frame->data[0])
        return ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF);
    if (av_frame_is_writable(frame))

    av_frame_move_ref(&tmp, frame);

    ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF);
    if (ret < 0) {
        av_frame_unref(&tmp);
        return ret;
    av_image_copy(frame->data, frame->linesize, tmp.data, tmp.linesize,
                  frame->format, frame->width, frame->height);

    av_frame_unref(&tmp);

#if FF_API_GET_BUFFER
void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic)
{
    av_frame_unref(pic);
}

int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)
{
    av_assert0(0);
}
#endif

    avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));
    if (!avctx->internal->pool) {
        ret = AVERROR(ENOMEM);
        goto free_and_end;
    }

    if (avctx->internal)
        av_freep(&avctx->internal->pool);
    AVCodecInternal *avci = avctx->internal;
    if (!avctx->refcounted_frames)
        av_frame_unref(&avci->to_free);

        if (ret < 0 && picture->data[0])
            av_frame_unref(picture);

        if (*got_picture_ptr) {
            if (!avctx->refcounted_frames) {
                avci->to_free = *picture;
                avci->to_free.extended_data = avci->to_free.data;
            }

        }
    AVCodecInternal *avci = avctx->internal;
    if (!avctx->refcounted_frames)
        av_frame_unref(&avci->to_free);


            if (!avctx->refcounted_frames) {
                avci->to_free = *frame;
                avci->to_free.extended_data = avci->to_free.data;
            }

        if (ret < 0 && frame->data[0])
            av_frame_unref(frame);
        FramePool *pool = avctx->internal->pool;
        int i;
        if (!avctx->refcounted_frames)
            av_frame_unref(&avctx->internal->to_free);
        for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)
            av_buffer_pool_uninit(&pool->pools[i]);
        av_freep(&avctx->internal->pool);
int ff_thread_ref_frame(ThreadFrame *dst, ThreadFrame *src)
{
    int ret;

    dst->owner = src->owner;

    ret = av_frame_ref(dst->f, src->f);
    if (ret < 0)
        return ret;

    if (src->progress &&
        !(dst->progress = av_buffer_ref(src->progress))) {
        ff_thread_release_buffer(dst->owner, dst);
        return AVERROR(ENOMEM);
    }

    return 0;
}

int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f, int flags)
    return ff_get_buffer(avctx, f, flags);
    av_frame_unref(f);","#define INTERNAL_BUFFER_SIZE (32 + 1)

static int audio_get_buffer(AVCodecContext *avctx, AVFrame *frame)
{
    AVCodecInternal *avci = avctx->internal;
    int buf_size, ret;

    av_freep(&avci->audio_data);
    buf_size = av_samples_get_buffer_size(NULL, avctx->channels,
                                          frame->nb_samples, avctx->sample_fmt,
                                          0);
    if (buf_size < 0)
        return AVERROR(EINVAL);

    frame->data[0] = av_mallocz(buf_size);
    if (!frame->data[0])
        return AVERROR(ENOMEM);

    ret = avcodec_fill_audio_frame(frame, avctx->channels, avctx->sample_fmt,
                                   frame->data[0], buf_size, 0);
    if (ret < 0) {
        av_freep(&frame->data[0]);
        return ret;
    }

    avci->audio_data = frame->data[0];
    if (avctx->debug & FF_DEBUG_BUFFERS)
        av_log(avctx, AV_LOG_DEBUG, ""default_get_buffer called on frame %p, ""
                                    ""internal audio buffer used\n"", frame);

    return 0;
}

static int video_get_buffer(AVCodecContext *s, AVFrame *pic)
    int i;
    int w = s->width;
    int h = s->height;
    InternalBuffer *buf;
    AVCodecInternal *avci = s->internal;

    if (pic->data[0] != NULL) {
        av_log(s, AV_LOG_ERROR, ""pic->data[0]!=NULL in avcodec_default_get_buffer\n"");
        return -1;
    }
    if (avci->buffer_count >= INTERNAL_BUFFER_SIZE) {
        av_log(s, AV_LOG_ERROR, ""buffer_count overflow (missing release_buffer?)\n"");
        return -1;
    }
    if (av_image_check_size(w, h, 0, s))
        return -1;

    if (!avci->buffer) {
        avci->buffer = av_mallocz((INTERNAL_BUFFER_SIZE + 1) *
                                  sizeof(InternalBuffer));
    }

    buf = &avci->buffer[avci->buffer_count];

    if (buf->base[0] && (buf->width != w || buf->height != h || buf->pix_fmt != s->pix_fmt)) {
        for (i = 0; i < AV_NUM_DATA_POINTERS; i++) {
            av_freep(&buf->base[i]);
            buf->data[i] = NULL;
        }
    }

    if (!buf->base[0]) {
        int h_chroma_shift, v_chroma_shift;
        int size[4] = { 0 };
        int tmpsize;
        int unaligned;
        int stride_align[AV_NUM_DATA_POINTERS];
        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
        const int pixel_size = desc->comp[0].step_minus1 + 1;
        av_pix_fmt_get_chroma_sub_sample(s->pix_fmt, &h_chroma_shift,
                                         &v_chroma_shift);
        avcodec_align_dimensions2(s, &w, &h, stride_align);
        if (!(s->flags & CODEC_FLAG_EMU_EDGE)) {
            av_image_fill_linesizes(picture.linesize, s->pix_fmt, w);
                unaligned |= picture.linesize[i] % stride_align[i];
        tmpsize = av_image_fill_pointers(picture.data, s->pix_fmt, h, NULL, picture.linesize);
        memset(buf->base, 0, sizeof(buf->base));
        memset(buf->data, 0, sizeof(buf->data));
        for (i = 0; i < 4 && size[i]; i++) {
            const int h_shift = i == 0 ? 0 : h_chroma_shift;
            const int v_shift = i == 0 ? 0 : v_chroma_shift;
            buf->linesize[i] = picture.linesize[i];
            buf->base[i] = av_malloc(size[i] + 16); //FIXME 16
            if (buf->base[i] == NULL)
                return -1;
            // no edge if EDGE EMU or not planar YUV
            if ((s->flags & CODEC_FLAG_EMU_EDGE) || !size[2])
                buf->data[i] = buf->base[i];
            else
                buf->data[i] = buf->base[i] + FFALIGN((buf->linesize[i] * EDGE_WIDTH >> v_shift) + (pixel_size * EDGE_WIDTH >> h_shift), stride_align[i]);
        }
        for (; i < AV_NUM_DATA_POINTERS; i++) {
            buf->base[i]     = buf->data[i] = NULL;
            buf->linesize[i] = 0;
        if (size[1] && !size[2])
            avpriv_set_systematic_pal2((uint32_t *)buf->data[1], s->pix_fmt);
        buf->width   = s->width;
        buf->height  = s->height;
        buf->pix_fmt = s->pix_fmt;
    for (i = 0; i < AV_NUM_DATA_POINTERS; i++) {
        pic->base[i]     = buf->base[i];
        pic->data[i]     = buf->data[i];
        pic->linesize[i] = buf->linesize[i];
    avci->buffer_count++;
        av_log(s, AV_LOG_DEBUG, ""default_get_buffer called on pic %p, %d ""
                                ""buffers used\n"", pic, avci->buffer_count);
int avcodec_default_get_buffer(AVCodecContext *avctx, AVFrame *frame)
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame)
    return avctx->get_buffer(avctx, frame);
}
void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic)
{
    int i;
    InternalBuffer *buf, *last;
    AVCodecInternal *avci = s->internal;
    assert(s->codec_type == AVMEDIA_TYPE_VIDEO);
    assert(pic->type == FF_BUFFER_TYPE_INTERNAL);
    assert(avci->buffer_count);
    if (avci->buffer) {
        buf = NULL; /* avoids warning */
        for (i = 0; i < avci->buffer_count; i++) { //just 3-5 checks so is not worth to optimize
            buf = &avci->buffer[i];
            if (buf->data[0] == pic->data[0])
                break;
        assert(i < avci->buffer_count);
        avci->buffer_count--;
        last = &avci->buffer[avci->buffer_count];
        if (buf != last)
            FFSWAP(InternalBuffer, *buf, *last);
    }
    for (i = 0; i < AV_NUM_DATA_POINTERS; i++)
        pic->data[i] = NULL;
//        pic->base[i]=NULL;
    if (s->debug & FF_DEBUG_BUFFERS)
        av_log(s, AV_LOG_DEBUG, ""default_release_buffer called on pic %p, %d ""
                                ""buffers used\n"", pic, avci->buffer_count);
}
int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)
{
    AVFrame temp_pic;
    int i;
    assert(s->codec_type == AVMEDIA_TYPE_VIDEO);
    /* If no picture return a new buffer */
    if (pic->data[0] == NULL) {
        /* We will copy from buffer, so must be readable */
        pic->buffer_hints |= FF_BUFFER_HINTS_READABLE;
        return ff_get_buffer(s, pic);
    assert(s->pix_fmt == pic->format);
    /* If internal buffer type return the same buffer */
    if (pic->type == FF_BUFFER_TYPE_INTERNAL) {
        if (s->pkt)
            pic->pkt_pts = s->pkt->pts;
        else
            pic->pkt_pts = AV_NOPTS_VALUE;
        pic->reordered_opaque = s->reordered_opaque;
    /*
     * Not internal type and reget_buffer not overridden, emulate cr buffer
     */
    temp_pic = *pic;
    for (i = 0; i < AV_NUM_DATA_POINTERS; i++)
        pic->data[i] = pic->base[i] = NULL;
    pic->opaque = NULL;
    /* Allocate new frame */
    if (ff_get_buffer(s, pic))
        return -1;
    /* Copy image data from old buffer to new buffer */
    av_picture_copy((AVPicture *)pic, (AVPicture *)&temp_pic, s->pix_fmt, s->width,
                    s->height);
    s->release_buffer(s, &temp_pic); // Release old frame
        if (*got_picture_ptr)
        avcodec_default_free_buffers(avctx);
static void video_free_buffers(AVCodecContext *s)
{
    AVCodecInternal *avci = s->internal;
    int i, j;

    if (!avci->buffer)
        return;

    if (avci->buffer_count)
        av_log(s, AV_LOG_WARNING, ""Found %i unreleased buffers!\n"",
               avci->buffer_count);
    for (i = 0; i < INTERNAL_BUFFER_SIZE; i++) {
        InternalBuffer *buf = &avci->buffer[i];
        for (j = 0; j < 4; j++) {
            av_freep(&buf->base[j]);
            buf->data[j] = NULL;
        }
    }
    av_freep(&avci->buffer);

    avci->buffer_count = 0;
}

static void audio_free_buffers(AVCodecContext *avctx)
{
    AVCodecInternal *avci = avctx->internal;
    av_freep(&avci->audio_data);
}

void avcodec_default_free_buffers(AVCodecContext *avctx)
{
    switch (avctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
        video_free_buffers(avctx);
        break;
    case AVMEDIA_TYPE_AUDIO:
        audio_free_buffers(avctx);
        break;
    default:
        break;
    }
}

int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)
    return ff_get_buffer(avctx, f);
    f->owner->release_buffer(f->owner, f);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED," VAR VAR VAR(VAR *VAR, VAR *VAR) VAR *VAR = VAR->VAR->VAR; VAR VAR, VAR; VAR (VAR->VAR) { VAR VAR: { VAR VAR[4] = { 0 }; VAR VAR = VAR->VAR; VAR VAR = VAR->VAR; VAR VAR, VAR; VAR (VAR->VAR == VAR->VAR && VAR->VAR == VAR->VAR && VAR->VAR == VAR->VAR) VAR 0; VAR(VAR, &VAR, &VAR, VAR->VAR); VAR (!(VAR->VAR & VAR)) { VAR(VAR.VAR, VAR->VAR, VAR); VAR |= VAR.VAR[VAR] % VAR->VAR[VAR]; VAR = VAR(VAR.VAR, VAR->VAR, VAR, VAR, VAR.VAR); VAR (VAR = 0; VAR < 4; VAR++) { VAR(&VAR->VAR[VAR]); VAR->VAR[VAR] = VAR.VAR[VAR]; VAR (VAR[VAR]) { VAR->VAR[VAR] = VAR(VAR[VAR] + 16, VAR); VAR (!VAR->VAR[VAR]) { VAR = VAR(VAR); VAR VAR; } } } VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR; } VAR VAR: { VAR VAR = VAR(VAR->VAR); VAR VAR = VAR(VAR->VAR); VAR VAR = VAR ? VAR : 1; VAR (VAR->VAR == VAR->VAR && VAR->VAR == VAR && VAR->VAR == VAR && VAR->VAR == VAR->VAR) VAR 0; VAR(&VAR->VAR[0]); VAR = VAR(&VAR->VAR[0], VAR, VAR->VAR, VAR->VAR, 0); VAR (VAR < 0) VAR VAR; VAR->VAR[0] = VAR(VAR->VAR[0], VAR); VAR (!VAR->VAR[0]) { VAR = VAR(VAR); VAR VAR; } VAR->VAR = VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR; } VAR: VAR(0); } VAR 0; VAR: VAR (VAR = 0; VAR < 4; VAR++) VAR(&VAR->VAR[VAR]); VAR->VAR = -1; VAR->VAR = VAR->VAR = VAR->VAR = 0; VAR->VAR = VAR->VAR = 0; VAR VAR; } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR *VAR = VAR->VAR->VAR; VAR VAR = VAR->VAR; VAR VAR; VAR->VAR[0] = VAR->VAR[0]; VAR (VAR > VAR) { VAR->VAR = VAR(VAR * VAR(*VAR->VAR)); VAR->VAR = VAR - VAR; VAR->VAR = VAR(VAR->VAR * VAR(*VAR->VAR)); VAR (!VAR->VAR || !VAR->VAR) { VAR(&VAR->VAR); VAR(&VAR->VAR); VAR VAR(VAR); } VAR VAR->VAR = VAR->VAR; VAR (VAR = 0; VAR < VAR(VAR, VAR); VAR++) { VAR->VAR[VAR] = VAR(VAR->VAR[0]); VAR (!VAR->VAR[VAR]) VAR VAR; VAR->VAR[VAR] = VAR->VAR[VAR] = VAR->VAR[VAR]->VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR->VAR[VAR] = VAR(VAR->VAR[0]); VAR (!VAR->VAR[VAR]) VAR VAR; VAR->VAR[VAR + VAR] = VAR->VAR[VAR]->VAR; } VAR (VAR->VAR & VAR) VAR(VAR, VAR, ""VAR VAR VAR VAR %VAR"", VAR); VAR 0; VAR: VAR(VAR); VAR VAR(VAR); } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR *VAR = VAR->VAR->VAR; VAR VAR *VAR = VAR(VAR->VAR); VAR VAR = VAR->VAR[0].VAR + 1; VAR VAR, VAR; VAR VAR; VAR (VAR->VAR[0] != VAR) { VAR(VAR, VAR, ""VAR->VAR[0]!=VAR VAR VAR\VAR""); VAR -1; VAR(VAR->VAR, 0, VAR(VAR->VAR)); VAR(VAR->VAR, &VAR, &VAR); VAR (VAR = 0; VAR < 4 && VAR->VAR[VAR]; VAR++) { VAR VAR VAR = VAR == 0 ? 0 : VAR; VAR VAR VAR = VAR == 0 ? 0 : VAR; VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR(VAR->VAR[VAR]); VAR (!VAR->VAR[VAR]) VAR VAR;  VAR ((VAR->VAR & VAR) || !VAR->VAR[2]) VAR->VAR[VAR] = VAR->VAR[VAR]->VAR; VAR { VAR->VAR[VAR] = VAR->VAR[VAR]->VAR + VAR((VAR->VAR[VAR] * VAR >> VAR) + (VAR * VAR >> VAR), VAR->VAR[VAR]); } } VAR (; VAR < VAR; VAR++) { VAR->VAR[VAR] = VAR; VAR->VAR[VAR] = 0; } VAR (VAR->VAR[1] && !VAR->VAR[2]) VAR((VAR *)VAR->VAR[1], VAR->VAR); VAR(VAR, VAR, ""VAR VAR VAR VAR %VAR\VAR"", VAR); VAR: VAR(VAR); VAR VAR(VAR); VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR VAR; VAR ((VAR = VAR(VAR, VAR)) < 0) VAR VAR;    VAR VAR(VAR *VAR, VAR *VAR) VAR VAR(VAR, VAR, 0); } VAR VAR VAR { VAR VAR; VAR VAR; } VAR; VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR *VAR = VAR; VAR->VAR.VAR(&VAR->VAR, &VAR->VAR); VAR(&VAR); } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR *VAR = VAR; VAR(&VAR); }  VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) { VAR VAR; VAR ((VAR = VAR(VAR->VAR, VAR->VAR, 0, VAR)) < 0) VAR VAR;  /* * VAR VAR VAR VAR()-VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR, VAR VAR VAR'VAR VAR VAR VAR * VAR(). */ VAR (VAR->VAR) { VAR *VAR = VAR; VAR *VAR = VAR; VAR VAR, VAR, VAR; VAR (VAR & VAR) VAR->VAR = 1; VAR = VAR->VAR(VAR, VAR); VAR (VAR < 0) VAR VAR; /* VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR.VAR. VAR VAR VAR VAR() VAR * VAR */ VAR (VAR->VAR[0]) VAR 0; VAR = VAR(VAR(*VAR)); VAR (!VAR) { VAR = VAR(VAR); VAR VAR; } VAR->VAR = *VAR; VAR->VAR = *VAR; VAR = VAR(VAR, 0, VAR, VAR, 0); VAR (!VAR) { VAR = VAR(VAR); VAR VAR;  VAR { \ VAR *VAR = VAR(VAR); \ VAR (!VAR) { \ VAR = VAR(VAR); \ VAR VAR; \ } \ VAR = VAR(VAR, VAR, VAR, \ VAR, 0); \ VAR (!VAR) { \ VAR(VAR); \ VAR = VAR(VAR); \ VAR VAR; \ } \ } VAR (0) VAR (VAR->VAR == VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR (!VAR) { VAR = VAR(VAR); VAR VAR; } VAR = (VAR->VAR & VAR) ? VAR->VAR : 1; VAR (VAR = 0; VAR < VAR; VAR++) { VAR VAR = (VAR == 1 || VAR == 2) ? VAR->VAR : 0; VAR VAR = (VAR->VAR >> VAR) * VAR->VAR[VAR]; VAR(VAR->VAR[VAR], VAR->VAR[VAR], VAR); } } VAR { VAR VAR = VAR(VAR->VAR); VAR = VAR ? VAR->VAR : 1; VAR (VAR > VAR(VAR->VAR)) { VAR->VAR = VAR - VAR(VAR->VAR); VAR->VAR = VAR(VAR(*VAR->VAR) * VAR->VAR); VAR (!VAR->VAR) { VAR = VAR(VAR); VAR VAR; } } VAR (VAR = 0; VAR < VAR(VAR, VAR(VAR->VAR)); VAR++) VAR(VAR->VAR[VAR], VAR->VAR[VAR], VAR->VAR[0]); VAR (VAR = 0; VAR < VAR - VAR(VAR->VAR); VAR++) VAR(VAR->VAR[VAR], VAR->VAR[VAR + VAR(VAR->VAR)], VAR->VAR[0]); } VAR(&VAR); VAR 0; VAR: VAR->VAR(VAR, VAR); VAR(&VAR); VAR(&VAR); VAR VAR;  VAR VAR->VAR(VAR, VAR, VAR); } VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR; VAR VAR; VAR(VAR->VAR == VAR); VAR (!VAR->VAR[0]) VAR VAR(VAR, VAR, VAR); VAR (VAR(VAR)) VAR(&VAR, VAR); VAR = VAR(VAR, VAR, VAR); VAR (VAR < 0) { VAR(&VAR); VAR VAR; VAR(VAR->VAR, VAR->VAR, VAR.VAR, VAR.VAR, VAR->VAR, VAR->VAR, VAR->VAR); VAR(&VAR);  VAR VAR(VAR *VAR, VAR *VAR) { VAR(VAR); } VAR VAR(VAR *VAR, VAR *VAR) { VAR(0); }  VAR->VAR->VAR = VAR(VAR(*VAR->VAR->VAR)); VAR (!VAR->VAR->VAR) { VAR = VAR(VAR); VAR VAR; } VAR (VAR->VAR) VAR(&VAR->VAR->VAR); VAR *VAR = VAR->VAR; VAR (!VAR->VAR) VAR(&VAR->VAR); VAR (VAR < 0 && VAR->VAR[0]) VAR(VAR); VAR (*VAR) { VAR (!VAR->VAR) { VAR->VAR = *VAR; VAR->VAR.VAR = VAR->VAR.VAR; } } VAR *VAR = VAR->VAR; VAR (!VAR->VAR) VAR(&VAR->VAR); VAR (!VAR->VAR) { VAR->VAR = *VAR; VAR->VAR.VAR = VAR->VAR.VAR; } VAR (VAR < 0 && VAR->VAR[0]) VAR(VAR); VAR *VAR = VAR->VAR->VAR; VAR VAR; VAR (!VAR->VAR) VAR(&VAR->VAR->VAR); VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) VAR(&VAR->VAR[VAR]); VAR(&VAR->VAR->VAR); VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR; VAR->VAR = VAR->VAR; VAR = VAR(VAR->VAR, VAR->VAR); VAR (VAR < 0) VAR VAR; VAR (VAR->VAR && !(VAR->VAR = VAR(VAR->VAR))) { VAR(VAR->VAR, VAR); VAR VAR(VAR); } VAR 0; } VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR VAR(VAR, VAR, VAR); VAR(VAR);  VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR *VAR = VAR->VAR; VAR VAR, VAR; VAR(&VAR->VAR); VAR = VAR(VAR, VAR->VAR, VAR->VAR, VAR->VAR, 0); VAR (VAR < 0) VAR VAR(VAR); VAR->VAR[0] = VAR(VAR); VAR (!VAR->VAR[0]) VAR VAR(VAR); VAR = VAR(VAR, VAR->VAR, VAR->VAR, VAR->VAR[0], VAR, 0); VAR (VAR < 0) { VAR(&VAR->VAR[0]); VAR VAR; } VAR->VAR = VAR->VAR[0]; VAR (VAR->VAR & VAR) VAR(VAR, VAR, ""VAR VAR VAR VAR %VAR, "" ""VAR VAR VAR VAR\VAR"", VAR); VAR 0; } VAR VAR VAR(VAR *VAR, VAR *VAR) VAR VAR; VAR VAR = VAR->VAR; VAR VAR = VAR->VAR; VAR *VAR; VAR *VAR = VAR->VAR; VAR (VAR->VAR[0] != VAR) { VAR(VAR, VAR, ""VAR->VAR[0]!=VAR VAR VAR\VAR""); VAR -1; } VAR (VAR->VAR >= VAR) { VAR(VAR, VAR, ""VAR VAR (VAR VAR?)\VAR""); VAR -1; } VAR (VAR(VAR, VAR, 0, VAR)) VAR -1; VAR (!VAR->VAR) { VAR->VAR = VAR((VAR + 1) * VAR(VAR)); } VAR = &VAR->VAR[VAR->VAR]; VAR (VAR->VAR[0] && (VAR->VAR != VAR || VAR->VAR != VAR || VAR->VAR != VAR->VAR)) { VAR (VAR = 0; VAR < VAR; VAR++) { VAR(&VAR->VAR[VAR]); VAR->VAR[VAR] = VAR; } } VAR (!VAR->VAR[0]) { VAR VAR, VAR; VAR VAR[4] = { 0 }; VAR VAR; VAR VAR; VAR VAR[VAR]; VAR VAR *VAR = VAR(VAR->VAR); VAR VAR VAR = VAR->VAR[0].VAR + 1; VAR(VAR->VAR, &VAR, &VAR); VAR(VAR, &VAR, &VAR, VAR); VAR (!(VAR->VAR & VAR)) { VAR(VAR.VAR, VAR->VAR, VAR); VAR |= VAR.VAR[VAR] % VAR[VAR]; VAR = VAR(VAR.VAR, VAR->VAR, VAR, VAR, VAR.VAR); VAR(VAR->VAR, 0, VAR(VAR->VAR)); VAR(VAR->VAR, 0, VAR(VAR->VAR)); VAR (VAR = 0; VAR < 4 && VAR[VAR]; VAR++) { VAR VAR VAR = VAR == 0 ? 0 : VAR; VAR VAR VAR = VAR == 0 ? 0 : VAR; VAR->VAR[VAR] = VAR.VAR[VAR]; VAR->VAR[VAR] = VAR(VAR[VAR] + 16);  VAR (VAR->VAR[VAR] == VAR) VAR -1;  VAR ((VAR->VAR & VAR) || !VAR[2]) VAR->VAR[VAR] = VAR->VAR[VAR]; VAR VAR->VAR[VAR] = VAR->VAR[VAR] + VAR((VAR->VAR[VAR] * VAR >> VAR) + (VAR * VAR >> VAR), VAR[VAR]); } VAR (; VAR < VAR; VAR++) { VAR->VAR[VAR] = VAR->VAR[VAR] = VAR; VAR->VAR[VAR] = 0; VAR (VAR[1] && !VAR[2]) VAR((VAR *)VAR->VAR[1], VAR->VAR); VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR++; VAR(VAR, VAR, ""VAR VAR VAR VAR %VAR, %VAR "" ""VAR VAR\VAR"", VAR, VAR->VAR); VAR VAR(VAR *VAR, VAR *VAR) VAR VAR(VAR *VAR, VAR *VAR) VAR VAR->VAR(VAR, VAR); } VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR; VAR *VAR, *VAR; VAR *VAR = VAR->VAR; VAR(VAR->VAR == VAR); VAR(VAR->VAR == VAR); VAR(VAR->VAR); VAR (VAR->VAR) { VAR = VAR;  VAR (VAR = 0; VAR < VAR->VAR; VAR++) {  VAR = &VAR->VAR[VAR]; VAR (VAR->VAR[0] == VAR->VAR[0]) VAR; VAR(VAR < VAR->VAR); VAR->VAR--; VAR = &VAR->VAR[VAR->VAR]; VAR (VAR != VAR) VAR(VAR, *VAR, *VAR); } VAR (VAR = 0; VAR < VAR; VAR++) VAR->VAR[VAR] = VAR;  VAR (VAR->VAR & VAR) VAR(VAR, VAR, ""VAR VAR VAR VAR %VAR, %VAR "" ""VAR VAR\VAR"", VAR, VAR->VAR); } VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR; VAR VAR; VAR(VAR->VAR == VAR);  VAR (VAR->VAR[0] == VAR) {  VAR->VAR |= VAR; VAR VAR(VAR, VAR); VAR(VAR->VAR == VAR->VAR);  VAR (VAR->VAR == VAR) { VAR (VAR->VAR) VAR->VAR = VAR->VAR->VAR; VAR VAR->VAR = VAR; VAR->VAR = VAR->VAR; /* * VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR */ VAR = *VAR; VAR (VAR = 0; VAR < VAR; VAR++) VAR->VAR[VAR] = VAR->VAR[VAR] = VAR; VAR->VAR = VAR;  VAR (VAR(VAR, VAR)) VAR -1;  VAR((VAR *)VAR, (VAR *)&VAR, VAR->VAR, VAR->VAR, VAR->VAR); VAR->VAR(VAR, &VAR);  VAR (*VAR) VAR(VAR); VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR VAR, VAR; VAR (!VAR->VAR) VAR; VAR (VAR->VAR) VAR(VAR, VAR, ""VAR %VAR VAR VAR!\VAR"", VAR->VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR *VAR = &VAR->VAR[VAR]; VAR (VAR = 0; VAR < 4; VAR++) { VAR(&VAR->VAR[VAR]); VAR->VAR[VAR] = VAR; } } VAR(&VAR->VAR); VAR->VAR = 0; } VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR(&VAR->VAR); } VAR VAR(VAR *VAR) { VAR (VAR->VAR) { VAR VAR: VAR(VAR); VAR; VAR VAR: VAR(VAR); VAR; VAR: VAR; } } VAR VAR(VAR *VAR, VAR *VAR) VAR VAR(VAR, VAR); VAR->VAR->VAR(VAR->VAR, VAR);",1
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/vp8.c,"static int vp8_alloc_frame(VP8Context *s, VP8Frame *f, int ref)
    if ((ret = ff_thread_get_buffer(s->avctx, &f->tf,
                                    ref ? AV_GET_BUFFER_FLAG_REF : 0)) < 0)
    if (!(f->seg_map = av_buffer_allocz(s->mb_width * s->mb_height))) {
        ff_thread_release_buffer(s->avctx, &f->tf);
static void vp8_release_frame(VP8Context *s, VP8Frame *f)
    av_buffer_unref(&f->seg_map);
    ff_thread_release_buffer(s->avctx, &f->tf);
}

static int vp8_ref_frame(VP8Context *s, VP8Frame *dst, VP8Frame *src)
{
    int ret;

    vp8_release_frame(s, dst);

    if ((ret = ff_thread_ref_frame(&dst->tf, &src->tf)) < 0)
        return ret;
    if (src->seg_map &&
        !(dst->seg_map = av_buffer_ref(src->seg_map))) {
        vp8_release_frame(s, dst);
        return AVERROR(ENOMEM);

    return 0;

static void vp8_decode_flush_impl(AVCodecContext *avctx, int free_mem)
    for (i = 0; i < FF_ARRAY_ELEMS(s->frames); i++)
        vp8_release_frame(s, &s->frames[i]);
    if (free_mem)
    vp8_decode_flush_impl(avctx, 0);
        vp8_decode_flush_impl(s->avctx, 1);
                 ThreadFrame *ref, const VP56mv *mv,
    uint8_t *src = ref->f->data[0];
                   ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off,
    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];
                 ThreadFrame *ref_frame, int x_off, int y_off,
        uint8_t **src= s->framep[ref]->tf.f->data;
    ThreadFrame *ref = &s->framep[mb->ref_frame]->tf;
static void vp8_decode_mv_mb_modes(AVCodecContext *avctx, VP8Frame *curframe,
                                   VP8Frame *prev_frame)
            decode_mb_mode(s, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy,
                           prev_frame && prev_frame->seg_map ?
                           prev_frame->seg_map->data + mb_xy : NULL, 1);
    VP8Frame *curframe = s->curframe, *prev_frame = s->prev_frame;
        curframe->tf.f->data[0] + 16*mb_y*s->linesize,
        curframe->tf.f->data[1] +  8*mb_y*s->uvlinesize,
        curframe->tf.f->data[2] +  8*mb_y*s->uvlinesize
                dst[i][y*curframe->tf.f->linesize[i]-1] = 129;
            decode_mb_mode(s, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy,
                           prev_frame && prev_frame->seg_map ?
                           prev_frame->seg_map->data + mb_xy : NULL, 0);
    AVFrame *curframe = s->curframe->tf.f;
    VP8Frame *curframe = s->curframe;
            ff_thread_report_progress(&curframe->tf, mb_y, 0);
    VP8Frame *av_uninit(curframe), *prev_frame;
        if (s->frames[i].tf.f->data[0] &&
            vp8_release_frame(s, &s->frames[i]);
    if (curframe->tf.f->data[0])
        vp8_release_frame(s, curframe);
    curframe->tf.f->key_frame = s->keyframe;
    curframe->tf.f->pict_type = s->keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;
    if ((ret = vp8_alloc_frame(s, curframe, referenced))) {
    s->linesize   = curframe->tf.f->linesize[0];
    s->uvlinesize = curframe->tf.f->linesize[1];
        ff_thread_await_progress(&prev_frame->tf, 1, 0);
    ff_thread_report_progress(&curframe->tf, INT_MAX, 0);
        if ((ret = av_frame_ref(data, curframe->tf.f)) < 0)
            return ret;
static av_cold int vp8_decode_free(AVCodecContext *avctx)
{
    VP8Context *s = avctx->priv_data;
    int i;

    vp8_decode_flush_impl(avctx, 1);
    for (i = 0; i < FF_ARRAY_ELEMS(s->frames); i++)
        av_frame_free(&s->frames[i].tf.f);

    return 0;
}

static av_cold int vp8_init_frames(VP8Context *s)
{
    int i;
    for (i = 0; i < FF_ARRAY_ELEMS(s->frames); i++) {
        s->frames[i].tf.f = av_frame_alloc();
        if (!s->frames[i].tf.f)
            return AVERROR(ENOMEM);
    }
    return 0;
}

    int ret;
    avctx->internal->allocate_progress = 1;
    if ((ret = vp8_init_frames(s)) < 0) {
        vp8_decode_free(avctx);
        return ret;
    }
    int ret;
    if ((ret = vp8_init_frames(s)) < 0) {
        vp8_decode_free(avctx);
        return ret;
    }

    int i;
    for (i = 0; i < FF_ARRAY_ELEMS(s_src->frames); i++) {
        if (s_src->frames[i].tf.f->data[0]) {
            int ret = vp8_ref_frame(s, &s->frames[i], &s_src->frames[i]);
            if (ret < 0)
                return ret;
        }
    }
","static int vp8_alloc_frame(VP8Context *s, AVFrame *f)
    if ((ret = ff_thread_get_buffer(s->avctx, f)) < 0)
    if (s->num_maps_to_be_freed && !s->maps_are_invalid) {
        f->ref_index[0] = s->segmentation_maps[--s->num_maps_to_be_freed];
    } else if (!(f->ref_index[0] = av_mallocz(s->mb_width * s->mb_height))) {
        ff_thread_release_buffer(s->avctx, f);
static void vp8_release_frame(VP8Context *s, AVFrame *f, int prefer_delayed_free, int can_direct_free)
    if (f->ref_index[0]) {
        if (prefer_delayed_free) {
            /* Upon a size change, we want to free the maps but other threads may still
             * be using them, so queue them. Upon a seek, all threads are inactive so
             * we want to cache one to prevent re-allocation in the next decoding
             * iteration, but the rest we can free directly. */
            int max_queued_maps = can_direct_free ? 1 : FF_ARRAY_ELEMS(s->segmentation_maps);
            if (s->num_maps_to_be_freed < max_queued_maps) {
                s->segmentation_maps[s->num_maps_to_be_freed++] = f->ref_index[0];
            } else if (can_direct_free) /* vp8_decode_flush(), but our queue is full */ {
                av_free(f->ref_index[0]);
            } /* else: MEMLEAK (should never happen, but better that than crash) */
            f->ref_index[0] = NULL;
        } else /* vp8_decode_free() */ {
            av_free(f->ref_index[0]);
        }
    ff_thread_release_buffer(s->avctx, f);
static void vp8_decode_flush_impl(AVCodecContext *avctx,
                                  int prefer_delayed_free, int can_direct_free, int free_mem)
    if (!avctx->internal->is_copy) {
        for (i = 0; i < 5; i++)
            if (s->frames[i].data[0])
                vp8_release_frame(s, &s->frames[i], prefer_delayed_free, can_direct_free);
    }
    if (free_mem) {
        s->maps_are_invalid = 1;
    }
    vp8_decode_flush_impl(avctx, 1, 1, 0);
        vp8_decode_flush_impl(s->avctx, 1, 0, 1);
                 AVFrame *ref, const VP56mv *mv,
    uint8_t *src = ref->data[0];
                   AVFrame *ref, const VP56mv *mv, int x_off, int y_off,
    uint8_t *src1 = ref->data[1], *src2 = ref->data[2];
                 AVFrame *ref_frame, int x_off, int y_off,
        uint8_t **src= s->framep[ref]->data;
    AVFrame *ref = s->framep[mb->ref_frame];
static void release_queued_segmaps(VP8Context *s, int is_close)
{
    int leave_behind = is_close ? 0 : !s->maps_are_invalid;
    while (s->num_maps_to_be_freed > leave_behind)
        av_freep(&s->segmentation_maps[--s->num_maps_to_be_freed]);
    s->maps_are_invalid = 0;
}

static void vp8_decode_mv_mb_modes(AVCodecContext *avctx, AVFrame *curframe,
                                   AVFrame *prev_frame)
            decode_mb_mode(s, mb, mb_x, mb_y, curframe->ref_index[0] + mb_xy,
                           prev_frame && prev_frame->ref_index[0] ? prev_frame->ref_index[0] + mb_xy : NULL, 1);
    AVFrame *curframe = s->curframe, *prev_frame = s->prev_frame;
        curframe->data[0] + 16*mb_y*s->linesize,
        curframe->data[1] +  8*mb_y*s->uvlinesize,
        curframe->data[2] +  8*mb_y*s->uvlinesize
                dst[i][y*curframe->linesize[i]-1] = 129;
            decode_mb_mode(s, mb, mb_x, mb_y, curframe->ref_index[0] + mb_xy,
                           prev_frame && prev_frame->ref_index[0] ? prev_frame->ref_index[0] + mb_xy : NULL, 0);
    AVFrame *curframe = s->curframe;
    AVFrame *curframe = s->curframe;
            ff_thread_report_progress(curframe, mb_y, 0);
    AVFrame *av_uninit(curframe), *prev_frame;

    release_queued_segmaps(s, 0);
        if (s->frames[i].data[0] &&
            vp8_release_frame(s, &s->frames[i], 1, 0);
    if (curframe->data[0])
        vp8_release_frame(s, curframe, 1, 0);
    curframe->key_frame = s->keyframe;
    curframe->pict_type = s->keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;
    curframe->reference = referenced ? 3 : 0;
    if ((ret = vp8_alloc_frame(s, curframe))) {
    s->linesize   = curframe->linesize[0];
    s->uvlinesize = curframe->linesize[1];
        ff_thread_await_progress(prev_frame, 1, 0);
    ff_thread_report_progress(curframe, INT_MAX, 0);
        *(AVFrame*)data = *curframe;
    return 0;
}
static av_cold int vp8_decode_free(AVCodecContext *avctx)
{
    vp8_decode_flush_impl(avctx, 0, 1, 1);
    release_queued_segmaps(avctx->priv_data, 1);
        s->maps_are_invalid = 1;
    memcpy(&s->frames, &s_src->frames, sizeof(s->frames));",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR ((VAR = VAR(VAR->VAR, &VAR->VAR, VAR ? VAR : 0)) < 0) VAR (!(VAR->VAR = VAR(VAR->VAR * VAR->VAR))) { VAR(VAR->VAR, &VAR->VAR); VAR VAR VAR(VAR *VAR, VAR *VAR) VAR(&VAR->VAR); VAR(VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR) { VAR VAR; VAR(VAR, VAR); VAR ((VAR = VAR(&VAR->VAR, &VAR->VAR)) < 0) VAR VAR; VAR (VAR->VAR && !(VAR->VAR = VAR(VAR->VAR))) { VAR(VAR, VAR); VAR VAR(VAR); VAR 0; VAR VAR VAR(VAR *VAR, VAR VAR) VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) VAR(VAR, &VAR->VAR[VAR]); VAR (VAR) VAR(VAR, 0); VAR(VAR->VAR, 1); VAR *VAR, VAR VAR *VAR, VAR *VAR = VAR->VAR->VAR[0]; VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR, VAR *VAR = VAR->VAR->VAR[1], *VAR = VAR->VAR->VAR[2]; VAR *VAR, VAR VAR, VAR VAR, VAR **VAR= VAR->VAR[VAR]->VAR.VAR->VAR; VAR *VAR = &VAR->VAR[VAR->VAR]->VAR; VAR VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR) VAR(VAR, VAR, VAR, VAR, VAR->VAR->VAR + VAR, VAR && VAR->VAR ? VAR->VAR->VAR + VAR : VAR, 1); VAR *VAR = VAR->VAR, *VAR = VAR->VAR; VAR->VAR.VAR->VAR[0] + 16*VAR*VAR->VAR, VAR->VAR.VAR->VAR[1] + 8*VAR*VAR->VAR, VAR->VAR.VAR->VAR[2] + 8*VAR*VAR->VAR VAR[VAR][VAR*VAR->VAR.VAR->VAR[VAR]-1] = 129; VAR(VAR, VAR, VAR, VAR, VAR->VAR->VAR + VAR, VAR && VAR->VAR ? VAR->VAR->VAR + VAR : VAR, 0); VAR *VAR = VAR->VAR->VAR.VAR; VAR *VAR = VAR->VAR; VAR(&VAR->VAR, VAR, 0); VAR *VAR(VAR), *VAR; VAR (VAR->VAR[VAR].VAR.VAR->VAR[0] && VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR.VAR->VAR[0]) VAR(VAR, VAR); VAR->VAR.VAR->VAR = VAR->VAR; VAR->VAR.VAR->VAR = VAR->VAR ? VAR : VAR; VAR ((VAR = VAR(VAR, VAR, VAR))) { VAR->VAR = VAR->VAR.VAR->VAR[0]; VAR->VAR = VAR->VAR.VAR->VAR[1]; VAR(&VAR->VAR, 1, 0); VAR(&VAR->VAR, VAR, 0); VAR ((VAR = VAR(VAR, VAR->VAR.VAR)) < 0) VAR VAR; VAR VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR VAR; VAR(VAR, 1); VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) VAR(&VAR->VAR[VAR].VAR.VAR); VAR 0; } VAR VAR VAR VAR(VAR *VAR) { VAR VAR; VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR->VAR[VAR].VAR.VAR = VAR(); VAR (!VAR->VAR[VAR].VAR.VAR) VAR VAR(VAR); } VAR 0; } VAR VAR; VAR->VAR->VAR = 1; VAR ((VAR = VAR(VAR)) < 0) { VAR(VAR); VAR VAR; } VAR VAR; VAR ((VAR = VAR(VAR)) < 0) { VAR(VAR); VAR VAR; } VAR VAR; VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR (VAR->VAR[VAR].VAR.VAR->VAR[0]) { VAR VAR = VAR(VAR, &VAR->VAR[VAR], &VAR->VAR[VAR]); VAR (VAR < 0) VAR VAR; } } VAR VAR VAR(VAR *VAR, VAR *VAR) VAR ((VAR = VAR(VAR->VAR, VAR)) < 0) VAR (VAR->VAR && !VAR->VAR) { VAR->VAR[0] = VAR->VAR[--VAR->VAR]; } VAR VAR (!(VAR->VAR[0] = VAR(VAR->VAR * VAR->VAR))) { VAR(VAR->VAR, VAR); VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR) VAR (VAR->VAR[0]) { VAR (VAR) { /* VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR, VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR = VAR ? 1 : VAR(VAR->VAR); VAR (VAR->VAR < VAR) { VAR->VAR[VAR->VAR++] = VAR->VAR[0]; } VAR VAR (VAR) { VAR(VAR->VAR[0]); }  VAR->VAR[0] = VAR; } VAR { VAR(VAR->VAR[0]); } VAR(VAR->VAR, VAR); VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR, VAR VAR) VAR (!VAR->VAR->VAR) { VAR (VAR = 0; VAR < 5; VAR++) VAR (VAR->VAR[VAR].VAR[0]) VAR(VAR, &VAR->VAR[VAR], VAR, VAR); } VAR (VAR) { VAR->VAR = 1; } VAR(VAR, 1, 1, 0); VAR(VAR->VAR, 1, 0, 1); VAR *VAR, VAR VAR *VAR, VAR *VAR = VAR->VAR[0]; VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR, VAR *VAR = VAR->VAR[1], *VAR = VAR->VAR[2]; VAR *VAR, VAR VAR, VAR VAR, VAR **VAR= VAR->VAR[VAR]->VAR; VAR *VAR = VAR->VAR[VAR->VAR]; VAR VAR VAR(VAR *VAR, VAR VAR) { VAR VAR = VAR ? 0 : !VAR->VAR; VAR (VAR->VAR > VAR) VAR(&VAR->VAR[--VAR->VAR]); VAR->VAR = 0; } VAR VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR) VAR(VAR, VAR, VAR, VAR, VAR->VAR[0] + VAR, VAR && VAR->VAR[0] ? VAR->VAR[0] + VAR : VAR, 1); VAR *VAR = VAR->VAR, *VAR = VAR->VAR; VAR->VAR[0] + 16*VAR*VAR->VAR, VAR->VAR[1] + 8*VAR*VAR->VAR, VAR->VAR[2] + 8*VAR*VAR->VAR VAR[VAR][VAR*VAR->VAR[VAR]-1] = 129; VAR(VAR, VAR, VAR, VAR, VAR->VAR[0] + VAR, VAR && VAR->VAR[0] ? VAR->VAR[0] + VAR : VAR, 0); VAR *VAR = VAR->VAR; VAR *VAR = VAR->VAR; VAR(VAR, VAR, 0); VAR *VAR(VAR), *VAR; VAR(VAR, 0); VAR (VAR->VAR[VAR].VAR[0] && VAR(VAR, &VAR->VAR[VAR], 1, 0); VAR (VAR->VAR[0]) VAR(VAR, VAR, 1, 0); VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR ? VAR : VAR; VAR->VAR = VAR ? 3 : 0; VAR ((VAR = VAR(VAR, VAR))) { VAR->VAR = VAR->VAR[0]; VAR->VAR = VAR->VAR[1]; VAR(VAR, 1, 0); VAR(VAR, VAR, 0); *(VAR*)VAR = *VAR; VAR 0; } VAR VAR VAR VAR(VAR *VAR) { VAR(VAR, 0, 1, 1); VAR(VAR->VAR, 1); VAR->VAR = 1; VAR(&VAR->VAR, &VAR->VAR, VAR(VAR->VAR));",1
FFmpeg_821a5938d100458f4d09d634041b05c860554ce0,libavcodec/g2meet.c,"        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;","        c->tile_stride = FFALIGN(c->tile_width * 3, 16);",821a5938d100458f4d09d634041b05c860554ce0,CVE-2013-7013,821a5938d100458f4d09d634041b05c860554ce0,https://github.com/FFmpeg/FFmpeg,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR->VAR = VAR(VAR->VAR, 16) * 3; VAR->VAR = VAR(VAR->VAR * 3, 16);",1
FFmpeg_92f9b28ed84a77138105475beba16c146bdaf984,libavcodec/rpzaenc.c,"        for (x = 0; x < bi->block_width; x++) {
        for (j = 0; j < bi->block_width; j++) {
        for (j = 0; j < bi->block_width; j++) {
    const int y_size = FFMIN(4, bi->image_height - bi->row * 4);

    for (int y = 0; y < y_size; y++) {
                int y_size, rgb555;
                y_size = FFMIN(4, bi.image_height - bi.row * 4);
                for (int y = 0; y < y_size; y++) {
                    for (int x = 0; x < 4; x++) {
                for (int y = y_size; y < 4; y++) {
                    for (int x = 0; x < 4; x++)
                        put_bits(&s->pb, 16, 0);
                }
","        for (x = 0; x < bi->block_width; x++){
        for (j = 0; j < bi->block_width; j++){
        for (j = 0; j < bi->block_width; j++){
    for (int y = 0; y < 4; y++) {
                int rgb555;
                for (int y = 0; y < 4; y++) {
                    for (int x = 0; x < 4; x++){",92f9b28ed84a77138105475beba16c146bdaf984,CVE-2022-3964,92f9b28ed84a77138105475beba16c146bdaf984,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,80,COMPLETED,"VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR VAR VAR = VAR(4, VAR->VAR - VAR->VAR * 4); VAR (VAR VAR = 0; VAR < VAR; VAR++) { VAR VAR, VAR; VAR = VAR(4, VAR.VAR - VAR.VAR * 4); VAR (VAR VAR = 0; VAR < VAR; VAR++) { VAR (VAR VAR = 0; VAR < 4; VAR++) { VAR (VAR VAR = VAR; VAR < 4; VAR++) { VAR (VAR VAR = 0; VAR < 4; VAR++) VAR(&VAR->VAR, 16, 0); } VAR (VAR = 0; VAR < VAR->VAR; VAR++){ VAR (VAR = 0; VAR < VAR->VAR; VAR++){ VAR (VAR = 0; VAR < VAR->VAR; VAR++){ VAR (VAR VAR = 0; VAR < 4; VAR++) { VAR VAR; VAR (VAR VAR = 0; VAR < 4; VAR++) { VAR (VAR VAR = 0; VAR < 4; VAR++){",1
FFmpeg_9c0beaf0d3bb72f6e83b3b155a598a9ec28c8468,libavcodec/aacdec_template.c,"    // The previous checks would end up at 8 at this point for 22.2
    if (tags == 16 && i == 8) {
        e2c_vec[i] = (struct elem_to_channel) {
            .av_position  = AV_CH_TOP_FRONT_CENTER,
            .syn_ele      = layout_map[i][0],
            .elem_id      = layout_map[i][1],
            .aac_position = layout_map[i][2]
        }; i++;
        i += assign_pair(e2c_vec, layout_map, i,
                         AV_CH_TOP_FRONT_LEFT,
                         AV_CH_TOP_FRONT_RIGHT,
                         AAC_CHANNEL_FRONT);
        i += assign_pair(e2c_vec, layout_map, i,
                         AV_CH_TOP_SIDE_LEFT,
                         AV_CH_TOP_SIDE_RIGHT,
                         AAC_CHANNEL_SIDE);
        e2c_vec[i] = (struct elem_to_channel) {
            .av_position  = AV_CH_TOP_CENTER,
            .syn_ele      = layout_map[i][0],
            .elem_id      = layout_map[i][1],
            .aac_position = layout_map[i][2]
        }; i++;
        i += assign_pair(e2c_vec, layout_map, i,
                         AV_CH_TOP_BACK_LEFT,
                         AV_CH_TOP_BACK_RIGHT,
                         AAC_CHANNEL_BACK);
        e2c_vec[i] = (struct elem_to_channel) {
            .av_position  = AV_CH_TOP_BACK_CENTER,
            .syn_ele      = layout_map[i][0],
            .elem_id      = layout_map[i][1],
            .aac_position = layout_map[i][2]
        }; i++;
        e2c_vec[i] = (struct elem_to_channel) {
            .av_position  = AV_CH_BOTTOM_FRONT_CENTER,
            .syn_ele      = layout_map[i][0],
            .elem_id      = layout_map[i][1],
            .aac_position = layout_map[i][2]
        }; i++;
        i += assign_pair(e2c_vec, layout_map, i,
                         AV_CH_BOTTOM_FRONT_LEFT,
                         AV_CH_BOTTOM_FRONT_RIGHT,
                         AAC_CHANNEL_FRONT);
    }


    if (tags == 16 && total_non_cc_elements == 16) {
        // For 22.2 reorder the result as needed
        FFSWAP(struct elem_to_channel, e2c_vec[2], e2c_vec[0]);   // FL & FR first (final), FC third
        FFSWAP(struct elem_to_channel, e2c_vec[2], e2c_vec[1]);   // FC second (final), FLc & FRc third
        FFSWAP(struct elem_to_channel, e2c_vec[6], e2c_vec[2]);   // LFE1 third (final), FLc & FRc seventh
        FFSWAP(struct elem_to_channel, e2c_vec[4], e2c_vec[3]);   // BL & BR fourth (final), SiL & SiR fifth
        FFSWAP(struct elem_to_channel, e2c_vec[6], e2c_vec[4]);   // FLc & FRc fifth (final), SiL & SiR seventh
        FFSWAP(struct elem_to_channel, e2c_vec[7], e2c_vec[6]);   // LFE2 seventh (final), SiL & SiR eight (final)
        FFSWAP(struct elem_to_channel, e2c_vec[9], e2c_vec[8]);   // TpFL & TpFR ninth (final), TFC tenth (final)
        FFSWAP(struct elem_to_channel, e2c_vec[11], e2c_vec[10]); // TC eleventh (final), TpSiL & TpSiR twelth
        FFSWAP(struct elem_to_channel, e2c_vec[12], e2c_vec[11]); // TpBL & TpBR twelth (final), TpSiL & TpSiR thirteenth (final)
    } else {
        // For everything else, utilize the AV channel position define as a
        // stable sort.
        do {
            int next_n = 0;
            for (i = 1; i < n; i++)
                if (e2c_vec[i - 1].av_position > e2c_vec[i].av_position) {
                    FFSWAP(struct elem_to_channel, e2c_vec[i - 1], e2c_vec[i]);
                    next_n = i;
                }
            n = next_n;
        } while (n > 0);

    }
        channel_config > 13) {
    case 13:
        if (ac->tags_mapped > 3 && ((type == TYPE_CPE && elem_id < 8) ||
                                    (type == TYPE_SCE && elem_id < 6) ||
                                    (type == TYPE_LFE && elem_id < 2))) {
            ac->tags_mapped++;
            return ac->tag_che_map[type][elem_id] = ac->che[type][elem_id];
        }","    // Must choose a stable sort
    do {
        int next_n = 0;
        for (i = 1; i < n; i++)
            if (e2c_vec[i - 1].av_position > e2c_vec[i].av_position) {
                FFSWAP(struct elem_to_channel, e2c_vec[i - 1], e2c_vec[i]);
                next_n = i;
            }
        n = next_n;
    } while (n > 0);
        channel_config > 12) {",9c0beaf0d3bb72f6e83b3b155a598a9ec28c8468,CVE-2020-24995,9c0beaf0d3bb72f6e83b3b155a598a9ec28c8468,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,88,COMPLETED," VAR (VAR == 16 && VAR == 8) { VAR[VAR] = (VAR VAR) { .VAR = VAR, .VAR = VAR[VAR][0], .VAR = VAR[VAR][1], .VAR = VAR[VAR][2] }; VAR++; VAR += VAR(VAR, VAR, VAR, VAR, VAR, VAR); VAR += VAR(VAR, VAR, VAR, VAR, VAR, VAR); VAR[VAR] = (VAR VAR) { .VAR = VAR, .VAR = VAR[VAR][0], .VAR = VAR[VAR][1], .VAR = VAR[VAR][2] }; VAR++; VAR += VAR(VAR, VAR, VAR, VAR, VAR, VAR); VAR[VAR] = (VAR VAR) { .VAR = VAR, .VAR = VAR[VAR][0], .VAR = VAR[VAR][1], .VAR = VAR[VAR][2] }; VAR++; VAR[VAR] = (VAR VAR) { .VAR = VAR, .VAR = VAR[VAR][0], .VAR = VAR[VAR][1], .VAR = VAR[VAR][2] }; VAR++; VAR += VAR(VAR, VAR, VAR, VAR, VAR, VAR); } VAR (VAR == 16 && VAR == 16) {  VAR(VAR VAR, VAR[2], VAR[0]);  VAR(VAR VAR, VAR[2], VAR[1]);  VAR(VAR VAR, VAR[6], VAR[2]);  VAR(VAR VAR, VAR[4], VAR[3]);  VAR(VAR VAR, VAR[6], VAR[4]);  VAR(VAR VAR, VAR[7], VAR[6]);  VAR(VAR VAR, VAR[9], VAR[8]);  VAR(VAR VAR, VAR[11], VAR[10]);  VAR(VAR VAR, VAR[12], VAR[11]);  } VAR {   VAR { VAR VAR = 0; VAR (VAR = 1; VAR < VAR; VAR++) VAR (VAR[VAR - 1].VAR > VAR[VAR].VAR) { VAR(VAR VAR, VAR[VAR - 1], VAR[VAR]); VAR = VAR; } VAR = VAR; } VAR (VAR > 0); } VAR > 13) { VAR 13: VAR (VAR->VAR > 3 && ((VAR == VAR && VAR < 8) || (VAR == VAR && VAR < 6) || (VAR == VAR && VAR < 2))) { VAR->VAR++; VAR VAR->VAR[VAR][VAR] = VAR->VAR[VAR][VAR]; }  VAR { VAR VAR = 0; VAR (VAR = 1; VAR < VAR; VAR++) VAR (VAR[VAR - 1].VAR > VAR[VAR].VAR) { VAR(VAR VAR, VAR[VAR - 1], VAR[VAR]); VAR = VAR; } VAR = VAR; } VAR (VAR > 0); VAR > 12) {",1
FFmpeg_e07ac727c1cc9eed39e7f9117c97006f719864bd,libavcodec/g2meet.c,"        c->framebuf_stride = FFALIGN(c->width + 15, 16) * 3;
        aligned_height     = c->height + 15;","        c->framebuf_stride = FFALIGN(c->width * 3, 16);
        aligned_height     = FFALIGN(c->height,    16);",e07ac727c1cc9eed39e7f9117c97006f719864bd,CVE-2013-7022,e07ac727c1cc9eed39e7f9117c97006f719864bd,https://github.com/FFmpeg/FFmpeg,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR->VAR = VAR(VAR->VAR + 15, 16) * 3; VAR = VAR->VAR + 15; VAR->VAR = VAR(VAR->VAR * 3, 16); VAR = VAR(VAR->VAR, 16);",1
FreeRDP_b8beb55913471952f92770c90c372139d78c16c0,libfreerdp/core/orders.c,"static BYTE get_cbr2_bpp(UINT32 bpp, BOOL* pValid)
{
	if (pValid)
		*pValid = TRUE;
	switch (bpp)
	{
		case 3:
			return 8;
		case 4:
			return 16;
		case 5:
			return 24;
		case 6:
			return 32;
		default:
			WLog_WARN(TAG, ""Invalid bpp %"" PRIu32, bpp);
			if (pValid)
				*pValid = FALSE;
			return 0;
	}
}
static BYTE get_bmf_bpp(UINT32 bmf, BOOL* pValid)
{
	if (pValid)
		*pValid = TRUE;
	switch (bmf)
	{
		case 1:
			return 1;
		case 3:
			return 8;
		case 4:
			return 16;
		case 5:
			return 24;
		case 6:
			return 32;
		default:
			WLog_WARN(TAG, ""Invalid bmf %"" PRIu32, bmf);
			if (pValid)
				*pValid = FALSE;
			return 0;
	}
}
static BYTE get_bpp_bmf(UINT32 bpp, BOOL* pValid)
{
	if (pValid)
		*pValid = TRUE;
	switch (bpp)
	{
		case 1:
			return 1;
		case 8:
			return 3;
		case 16:
			return 4;
		case 24:
			return 5;
		case 32:
			return 6;
		default:
			WLog_WARN(TAG, ""Invalid color depth %"" PRIu32, bpp);
			if (pValid)
				*pValid = FALSE;
			return 0;
	}
}
		BOOL rc;
		brush->bpp = get_bmf_bpp(brush->style, &rc);
		if (!rc)
			return FALSE;
		BOOL rc;
		brush->bpp = get_bmf_bpp(brush->style, &rc);
		if (!rc)
			return FALSE;
	BOOL rc;
	cache_bitmap_v2->bitmapBpp = get_cbr2_bpp(bitsPerPixelId, &rc);
	if (!rc)
		goto fail;
	BOOL rc;
	bitsPerPixelId = get_bpp_bmf(cache_bitmap_v2->bitmapBpp, &rc);
	if (!rc)
		return FALSE;
	BOOL rc;
	cache_bitmap_v3->bpp = get_cbr2_bpp(bitsPerPixelId, &rc);
	if (!rc)
		goto fail;
	BOOL rc;
	bitsPerPixelId = get_bpp_bmf(cache_bitmap_v3->bpp, &rc);
	if (!rc)
		return FALSE;
	BOOL rc;
	cache_brush->bpp = get_bmf_bpp(iBitmapFormat, &rc);
	if (!rc)
	BOOL rc;
	iBitmapFormat = get_bpp_bmf(cache_brush->bpp, &rc);
	if (!rc)
		return FALSE;","static const BYTE CBR2_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };

static const BYTE BPP_CBR2[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
	                             0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };

static const BYTE CBR23_BPP[] = { 0, 0, 0, 8, 16, 24, 32 };

static const BYTE BPP_CBR23[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
	                              0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };

static const BYTE BMF_BPP[] = { 0, 1, 0, 8, 16, 24, 32, 0 };
static const BYTE BPP_BMF[] = { 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0,
	                            0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 };
		brush->bpp = BMF_BPP[brush->style & 0x07];

		brush->bpp = BMF_BPP[brush->style & 0x07];

	cache_bitmap_v2->bitmapBpp = CBR2_BPP[bitsPerPixelId];
	bitsPerPixelId = BPP_CBR2[cache_bitmap_v2->bitmapBpp];
	cache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];
	bitsPerPixelId = BPP_CBR23[cache_bitmap_v3->bpp];
	if (iBitmapFormat >= ARRAYSIZE(BMF_BPP))
	cache_brush->bpp = BMF_BPP[iBitmapFormat];
	iBitmapFormat = BPP_BMF[cache_brush->bpp];",b8beb55913471952f92770c90c372139d78c16c0,CVE-2020-11096,b8beb55913471952f92770c90c372139d78c16c0,https://github.com/FreeRDP/FreeRDP,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR VAR, VAR* VAR) { VAR (VAR) *VAR = VAR; VAR (VAR) { VAR 3: VAR 8; VAR 4: VAR 16; VAR 5: VAR 24; VAR 6: VAR 32; VAR: VAR(VAR, ""VAR VAR %"" VAR, VAR); VAR (VAR) *VAR = VAR; VAR 0; } } VAR VAR VAR(VAR VAR, VAR* VAR) { VAR (VAR) *VAR = VAR; VAR (VAR) { VAR 1: VAR 1; VAR 3: VAR 8; VAR 4: VAR 16; VAR 5: VAR 24; VAR 6: VAR 32; VAR: VAR(VAR, ""VAR VAR %"" VAR, VAR); VAR (VAR) *VAR = VAR; VAR 0; } } VAR VAR VAR(VAR VAR, VAR* VAR) { VAR (VAR) *VAR = VAR; VAR (VAR) { VAR 1: VAR 1; VAR 8: VAR 3; VAR 16: VAR 4; VAR 24: VAR 5; VAR 32: VAR 6; VAR: VAR(VAR, ""VAR VAR VAR %"" VAR, VAR); VAR (VAR) *VAR = VAR; VAR 0; } } VAR VAR; VAR->VAR = VAR(VAR->VAR, &VAR); VAR (!VAR) VAR VAR; VAR VAR; VAR->VAR = VAR(VAR->VAR, &VAR); VAR (!VAR) VAR VAR; VAR VAR; VAR->VAR = VAR(VAR, &VAR); VAR (!VAR) VAR VAR; VAR VAR; VAR = VAR(VAR->VAR, &VAR); VAR (!VAR) VAR VAR; VAR VAR; VAR->VAR = VAR(VAR, &VAR); VAR (!VAR) VAR VAR; VAR VAR; VAR = VAR(VAR->VAR, &VAR); VAR (!VAR) VAR VAR; VAR VAR; VAR->VAR = VAR(VAR, &VAR); VAR (!VAR) VAR VAR; VAR = VAR(VAR->VAR, &VAR); VAR (!VAR) VAR VAR; VAR VAR VAR VAR[] = { 0, 0, 0, 8, 16, 24, 32 }; VAR VAR VAR VAR[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 }; VAR VAR VAR VAR[] = { 0, 0, 0, 8, 16, 24, 32 }; VAR VAR VAR VAR[] = { 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 }; VAR VAR VAR VAR[] = { 0, 1, 0, 8, 16, 24, 32, 0 }; VAR VAR VAR VAR[] = { 0, 1, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0 }; VAR->VAR = VAR[VAR->VAR & 0x07]; VAR->VAR = VAR[VAR->VAR & 0x07]; VAR->VAR = VAR[VAR]; VAR = VAR[VAR->VAR]; VAR->VAR = VAR[VAR]; VAR = VAR[VAR->VAR]; VAR (VAR >= VAR(VAR)) VAR->VAR = VAR[VAR]; VAR = VAR[VAR->VAR];",1
FreeRDP_c098f21fdaadca57ff649eee1674f6cc321a2ec4,winpr/libwinpr/sspi/NTLM/ntlm_compute.c,"	if (Stream_GetRemainingLength(s) < 28)
		return -1;

	if (Stream_GetRemainingLength(s) < 16)
		return -1;",,c098f21fdaadca57ff649eee1674f6cc321a2ec4,CVE-2020-11086,c098f21fdaadca57ff649eee1674f6cc321a2ec4,https://github.com/FreeRDP/FreeRDP,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR (VAR(VAR) < 28) VAR -1; VAR (VAR(VAR) < 16) VAR -1; ,1
go_6446af942e2e2b161c4ec1b60d9703a2b55dc4dd,src/net/http/internal/chunked.go,"	checkEnd bool  // whether need to check for \r\n chunk footer
	excess   int64 // ""excessive"" chunk overhead, for malicious sender detection
	cr.excess += int64(len(line)) + 2 // header, plus \r\n after the chunk data
	line = trimTrailingWhitespace(line)
	line, cr.err = removeChunkExtension(line)
	if cr.err != nil {
		return
	}
	// A sender who sends one byte per chunk will send 5 bytes of overhead
	// for every byte of data. (""1\r\nX\r\n"" to send ""X"".)
	// We want to allow this, since streaming a byte at a time can be legitimate.
	//
	// A sender can use chunk extensions to add arbitrary amounts of additional
	// data per byte read. (""1;very long extension\r\nX\r\n"" to send ""X"".)
	// We don't want to disallow extensions (although we discard them),
	// but we also don't want to allow a sender to reduce the signal/noise ratio
	// arbitrarily.
	//
	// We track the amount of excess overhead read,
	// and produce an error if it grows too large.
	//
	// Currently, we say that we're willing to accept 16 bytes of overhead per chunk,
	// plus twice the amount of real data in the chunk.
	cr.excess -= 16 + (2 * int64(cr.n))
	if cr.excess < 0 {
		cr.excess = 0
	}
	if cr.excess > 16*1024 {
		cr.err = errors.New(""chunked encoding contains too much non-data"")
	}","	checkEnd bool // whether need to check for \r\n chunk footer
	p = trimTrailingWhitespace(p)
	p, err = removeChunkExtension(p)
	if err != nil {
		return nil, err
	}",6446af942e2e2b161c4ec1b60d9703a2b55dc4dd,CVE-2023-39326,6446af942e2e2b161c4ec1b60d9703a2b55dc4dd,https://github.com/golang/go,CPE_GIT_REPOBASED,150,COMPLETED,"VAR VAR  VAR VAR  VAR.VAR += VAR(VAR(VAR)) + 2  VAR = VAR(VAR) VAR, VAR.VAR = VAR(VAR) VAR VAR.VAR != VAR { VAR }                VAR.VAR -= 16 + (2 * VAR(VAR.VAR)) VAR VAR.VAR < 0 { VAR.VAR = 0 } VAR VAR.VAR > 16*1024 { VAR.VAR = VAR.VAR(""VAR VAR VAR VAR VAR VAR-VAR"") } VAR VAR  VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR VAR != VAR { VAR VAR, VAR }",1
gpac_3d17f9524b48e8564bba50055c3502e660c41a64,src/isomedia/box_code_base.c,"	if (ptr->original_4cc) {
		u32 t = s->type;
		s->type=ptr->original_4cc;
		e = gf_isom_box_write_header(s, bs);
		s->type=t;
	} else {
		e = gf_isom_box_write_header(s, bs);
	}
	if (p->grouping_type_parameter) p->version=1;

	GF_DefaultSampleGroupDescriptionEntry *ptr;
	case GF_4CC('l','i','n','f'):
	{
		GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();
		u32 s = (u32) gf_bs_get_position(bs);
		gf_isom_linf_read_entry(ptr, bs);
		*total_bytes = (u32) gf_bs_get_position(bs) - s;
		return ptr;
	}
		break;
	case GF_4CC( 'n', 'a', 'l', 'm' ):
		u64 start = gf_bs_get_position(bs);
		Bool rle, large_size;
		u32 entry_count;
		gf_bs_read_int(bs, 6);
		large_size = gf_bs_read_int(bs, 1);
		rle = gf_bs_read_int(bs, 1);
		entry_count = gf_bs_read_int(bs, large_size ? 16 : 8);
		gf_bs_seek(bs, start);
		entry_size = 1 + large_size ? 2 : 1;
		entry_size += entry_count * 2;
		if (rle) entry_size += entry_count * (large_size ? 2 : 1);

		break;
	default:
		break;

	if (!entry_size) return NULL;
	GF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry);
	if (!ptr) return NULL;
	ptr->length = entry_size;
	ptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length);
	gf_bs_read_data(bs, (char *) ptr->data, ptr->length);
	*total_bytes = entry_size;
	return ptr;
	case GF_4CC( 'l', 'i', 'n', 'f' ):
		gf_isom_linf_del_entry(entry);
		return;
	case GF_4CC( 'l', 'i', 'n', 'f' ):
		gf_isom_linf_write_entry(entry, bs);
		return;
	case GF_4CC( 'l', 'i', 'n', 'f' ):
		return gf_isom_linf_size_entry(entry);","	e = gf_isom_box_write_header(s, bs);
	default:
		GF_DefaultSampleGroupDescriptionEntry *ptr;
		if (!entry_size) return NULL;
		GF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry);
		if (!ptr) return NULL;
		ptr->length = entry_size;
		ptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length);
		gf_bs_read_data(bs, (char *) ptr->data, ptr->length);
		*total_bytes = entry_size;
		return ptr;
	return NULL;",3d17f9524b48e8564bba50055c3502e660c41a64,CVE-2018-1000100,3d17f9524b48e8564bba50055c3502e660c41a64,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,76,COMPLETED,"VAR (VAR->VAR) { VAR VAR = VAR->VAR; VAR->VAR=VAR->VAR; VAR = VAR(VAR, VAR); VAR->VAR=VAR; } VAR { VAR = VAR(VAR, VAR); } VAR (VAR->VAR) VAR->VAR=1; VAR *VAR; VAR VAR('VAR','VAR','VAR','VAR'): { VAR *VAR = VAR(); VAR VAR = (VAR) VAR(VAR); VAR(VAR, VAR); *VAR = (VAR) VAR(VAR) - VAR; VAR VAR; } VAR; VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR' ): VAR VAR = VAR(VAR); VAR VAR, VAR; VAR VAR; VAR(VAR, 6); VAR = VAR(VAR, 1); VAR = VAR(VAR, 1); VAR = VAR(VAR, VAR ? 16 : 8); VAR(VAR, VAR); VAR = 1 + VAR ? 2 : 1; VAR += VAR * 2; VAR (VAR) VAR += VAR * (VAR ? 2 : 1); VAR; VAR: VAR; VAR (!VAR) VAR VAR; VAR(VAR, VAR); VAR (!VAR) VAR VAR; VAR->VAR = VAR; VAR->VAR = (VAR *) VAR(VAR(VAR)*VAR->VAR); VAR(VAR, (VAR *) VAR->VAR, VAR->VAR); *VAR = VAR; VAR VAR; VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR' ): VAR(VAR); VAR; VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR' ): VAR(VAR, VAR); VAR; VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR' ): VAR VAR(VAR); VAR = VAR(VAR, VAR); VAR: VAR *VAR; VAR (!VAR) VAR VAR; VAR(VAR, VAR); VAR (!VAR) VAR VAR; VAR->VAR = VAR; VAR->VAR = (VAR *) VAR(VAR(VAR)*VAR->VAR); VAR(VAR, (VAR *) VAR->VAR, VAR->VAR); *VAR = VAR; VAR VAR; VAR VAR;",1
gpac_3d17f9524b48e8564bba50055c3502e660c41a64,src/isomedia/box_dump.c,"	if (ptr->version==1) {
		if (isalnum(ptr->grouping_type_parameter&0xFF)) {
			fprintf(trace, "" grouping_type_parameter=\""%s\"""", gf_4cc_to_str(ptr->grouping_type_parameter) );
		} else {
			fprintf(trace, "" grouping_type_parameter=\""%d\"""", ptr->grouping_type_parameter);
		}
	}
static void linf_dump(GF_LHVCLayerInformation *ptr, FILE * trace)
{
	u32 i, count;

	count = gf_list_count(ptr->num_layers_in_track);
	fprintf(trace, ""<LayerInformation num_layers=\""%d\"">\n"", count );
	for (i = 0; i < count; i++) {
		LHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);
		fprintf(trace, ""<LayerInfoItem layer_id=\""%d\"" min_temporalId=\""%d\"" max_temporalId=\""%d\"" sub_layer_presence_flags=\""%d\""/>\n"", li->layer_id, li->min_TemporalId, li->max_TemporalId, li->sub_layer_presence_flags);
	}
	fprintf(trace, ""</LayerInformation>\n"");
	return;
}

static void trif_dump(FILE * trace, char *data, u32 data_size)
{
	GF_BitStream *bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);
	u32 x,y,w,h, id, independent, filter_disabled;
	Bool full_picture, has_dep, tile_group;

	id = gf_bs_read_u16(bs);
	tile_group = gf_bs_read_int(bs, 1);
	fprintf(trace, ""<TileRegionGroupEntry ID=\""%d\"" tileGroup=\""%d\"" "", id, tile_group);
	if (tile_group) {
		independent = gf_bs_read_int(bs, 2);
		full_picture = (Bool)gf_bs_read_int(bs, 1);
		filter_disabled = gf_bs_read_int(bs, 1);
		has_dep = gf_bs_read_int(bs, 1);
		gf_bs_read_int(bs, 2);
		fprintf(trace, ""independent=\""%d\"" full_picture=\""%d\"" filter_disabled=\""%d\"" "", independent, full_picture, filter_disabled);

		if (!full_picture) {
			fprintf(trace, ""x=\""%d\"" y=\""%d\"" "", gf_bs_read_u16(bs), gf_bs_read_u16(bs));
		}
		fprintf(trace, ""w=\""%d\"" h=\""%d\"" "", gf_bs_read_u16(bs), gf_bs_read_u16(bs));
		if (!has_dep) {
			fprintf(trace, ""/>\n"");
		}else {
			u32 count = gf_bs_read_u16(bs);
			fprintf(trace, "">\n"");
			while (count) {
				count--;
				fprintf(trace, ""<TileRegionDependency tileID=\""%d\""/>\n"", gf_bs_read_u16(bs) );
			}
			fprintf(trace, ""</TileRegionGroupEntry>\n"");
		}
	}
	gf_bs_del(bs);
}

static void nalm_dump(FILE * trace, char *data, u32 data_size)
{
	GF_BitStream *bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);
	Bool rle, large_size;
	u32 entry_count;
	gf_bs_read_int(bs, 6);
	large_size = gf_bs_read_int(bs, 1);
	rle = gf_bs_read_int(bs, 1);
	entry_count = gf_bs_read_int(bs, large_size ? 16 : 8);
	fprintf(trace, ""<NALUMap rle=\""%d\"" large_size=\""%d\"">\n"", rle, large_size);

	while (entry_count) {
		u32 ID;
		fprintf(trace, ""<NALUMapEntry "");
		if (rle) {
			u32 start_num = gf_bs_read_int(bs, large_size ? 16 : 8);
			fprintf(trace, ""NALU_startNumber=\""%d\"" "", start_num);
		}
		ID = gf_bs_read_u16(bs);
		fprintf(trace, ""groupID=\""%d\""/>\n"", ID);
		entry_count--;
	}
	gf_bs_del(bs);
	fprintf(trace, ""</NALUMap>\n"");
	return;
}

		case GF_4CC( 'l', 'i', 'n', 'f'):
			linf_dump(entry, trace);
			break;
			trif_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);
			break;

		case GF_4CC( 'n', 'a', 'l', 'm'):
			nalm_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);","	if (ptr->version==1) fprintf(trace, "" grouping_type_parameter=\""%d\"""", ptr->grouping_type_parameter);
		{
			u32 x,y,w,h, id, independent;
			Bool full_picture;

			gf_isom_parse_trif_info( (const char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data, ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length, &id, &independent, &full_picture, &x, &y, &w, &h);
			fprintf(trace, ""<TileRegionGroupEntry ID=\""%d\"" independent=\""%d\"""", id, independent);
			if (!full_picture) fprintf(trace, "" horizontal_offset=\""%d\"" vertical_offset=\""%d\"""", x, y);
			fprintf(trace, "" region_width=\""%d\"" region_height=\""%d\""/>\n"", w, h);
		}",3d17f9524b48e8564bba50055c3502e660c41a64,CVE-2018-1000100,3d17f9524b48e8564bba50055c3502e660c41a64,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,76,COMPLETED,"VAR (VAR->VAR==1) { VAR (VAR(VAR->VAR&0xFF)) { VAR(VAR, "" VAR=\""%VAR\"""", VAR(VAR->VAR) ); } VAR { VAR(VAR, "" VAR=\""%VAR\"""", VAR->VAR); } } VAR VAR VAR(VAR *VAR, VAR * VAR) { VAR VAR, VAR; VAR = VAR(VAR->VAR); VAR(VAR, ""<VAR VAR=\""%VAR\"">\VAR"", VAR ); VAR (VAR = 0; VAR < VAR; VAR++) { VAR *VAR = (VAR *)VAR(VAR->VAR, VAR); VAR(VAR, ""<VAR VAR=\""%VAR\"" VAR=\""%VAR\"" VAR=\""%VAR\"" VAR=\""%VAR\""/>\VAR"", VAR->VAR, VAR->VAR, VAR->VAR, VAR->VAR); } VAR(VAR, ""</VAR>\VAR""); VAR; } VAR VAR VAR(VAR * VAR, VAR *VAR, VAR VAR) { VAR *VAR = VAR(VAR, VAR, VAR); VAR VAR,VAR,VAR,VAR, VAR, VAR, VAR; VAR VAR, VAR, VAR; VAR = VAR(VAR); VAR = VAR(VAR, 1); VAR(VAR, ""<VAR VAR=\""%VAR\"" VAR=\""%VAR\"" "", VAR, VAR); VAR (VAR) { VAR = VAR(VAR, 2); VAR = (VAR)VAR(VAR, 1); VAR = VAR(VAR, 1); VAR = VAR(VAR, 1); VAR(VAR, 2); VAR(VAR, ""VAR=\""%VAR\"" VAR=\""%VAR\"" VAR=\""%VAR\"" "", VAR, VAR, VAR); VAR (!VAR) { VAR(VAR, ""VAR=\""%VAR\"" VAR=\""%VAR\"" "", VAR(VAR), VAR(VAR)); } VAR(VAR, ""VAR=\""%VAR\"" VAR=\""%VAR\"" "", VAR(VAR), VAR(VAR)); VAR (!VAR) { VAR(VAR, ""/>\VAR""); } VAR { VAR VAR = VAR(VAR); VAR(VAR, "">\VAR""); VAR (VAR) { VAR--; VAR(VAR, ""<VAR VAR=\""%VAR\""/>\VAR"", VAR(VAR) ); } VAR(VAR, ""</VAR>\VAR""); } } VAR(VAR); } VAR VAR VAR(VAR * VAR, VAR *VAR, VAR VAR) { VAR *VAR = VAR(VAR, VAR, VAR); VAR VAR, VAR; VAR VAR; VAR(VAR, 6); VAR = VAR(VAR, 1); VAR = VAR(VAR, 1); VAR = VAR(VAR, VAR ? 16 : 8); VAR(VAR, ""<VAR VAR=\""%VAR\"" VAR=\""%VAR\"">\VAR"", VAR, VAR); VAR (VAR) { VAR VAR; VAR(VAR, ""<VAR ""); VAR (VAR) { VAR VAR = VAR(VAR, VAR ? 16 : 8); VAR(VAR, ""VAR=\""%VAR\"" "", VAR); } VAR = VAR(VAR); VAR(VAR, ""VAR=\""%VAR\""/>\VAR"", VAR); VAR--; } VAR(VAR); VAR(VAR, ""</VAR>\VAR""); VAR; } VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR'): VAR(VAR, VAR); VAR; VAR(VAR, (VAR *) ((VAR*)VAR)->VAR, ((VAR*)VAR)->VAR); VAR; VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR'): VAR(VAR, (VAR *) ((VAR*)VAR)->VAR, ((VAR*)VAR)->VAR); VAR (VAR->VAR==1) VAR(VAR, "" VAR=\""%VAR\"""", VAR->VAR); { VAR VAR,VAR,VAR,VAR, VAR, VAR; VAR VAR; VAR( (VAR VAR *) ((VAR*)VAR)->VAR, ((VAR*)VAR)->VAR, &VAR, &VAR, &VAR, &VAR, &VAR, &VAR, &VAR); VAR(VAR, ""<VAR VAR=\""%VAR\"" VAR=\""%VAR\"""", VAR, VAR); VAR (!VAR) VAR(VAR, "" VAR=\""%VAR\"" VAR=\""%VAR\"""", VAR, VAR); VAR(VAR, "" VAR=\""%VAR\"" VAR=\""%VAR\""/>\VAR"", VAR, VAR); }",1
gpac_3d17f9524b48e8564bba50055c3502e660c41a64,src/media_tools/isom_tools.c,"typedef struct{
	u8 layer_id_plus_one;
	u8 min_temporal_id;
	u8 max_temporal_id;
} LInfo;

	u32 temporal_id_sample, max_temporal_id_sample;
	LInfo layers[64];
	//purge all linf sample groups
	gf_isom_remove_sample_group(file, track, GF_4CC('l','i','n','f'));
			sti[layer_id].layers[layer_id].layer_id_plus_one = layer_id+1;
			sti[layer_id].temporal_id_sample = temporal_id;

			if (!sti[layer_id].layers[layer_id].min_temporal_id || (sti[layer_id].layers[layer_id].min_temporal_id > temporal_id)) {
				sti[layer_id].layers[layer_id].min_temporal_id = temporal_id;
			}
			if (!sti[layer_id].layers[layer_id].max_temporal_id || (sti[layer_id].layers[layer_id].max_temporal_id < temporal_id)) {
				sti[layer_id].layers[layer_id].max_temporal_id = temporal_id;

			if (!sti[layer_id].max_temporal_id_sample || (sti[layer_id].max_temporal_id_sample < temporal_id)) {
				sti[layer_id].max_temporal_id_sample = temporal_id;
				//purge all linf sample groups
				gf_isom_remove_sample_group(file, sti[j].track_num, GF_4CC('l','i','n','f'));
					u8 trefidx, tid;
					gf_bs_write_int(xbs, sti[k].max_temporal_id_sample, 3);

					tid = sti[k].temporal_id_sample;
					sti[j].layers[k].layer_id_plus_one = sti[k].layer_id+1;
					if (!sti[j].layers[k].min_temporal_id || (sti[j].layers[k].min_temporal_id > tid)) {
						sti[j].layers[k].min_temporal_id = tid;
					}
					if (!sti[j].layers[k].max_temporal_id || (sti[j].layers[k].max_temporal_id < tid)) {
						sti[j].layers[k].max_temporal_id = tid;
					}

			sti[j].max_temporal_id_sample = 0;
			sti[j].temporal_id_sample = 0;
		GF_BitStream *bs;
		u32 count, data_size;
		char *data=NULL;
		//set linf group
		bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
		gf_bs_write_int(bs, 0, 2);
		count = 0;
		for (k=0; k<=max_layer_id; k++) {
			if (sti[j].layers[k].layer_id_plus_one) count++;
		}
		gf_bs_write_int(bs, count, 6);

		for (k=0; k<=max_layer_id; k++) {
			if (! sti[j].layers[k].layer_id_plus_one) continue;
			gf_bs_write_int(bs, 0, 4);
			gf_bs_write_int(bs, sti[j].layers[k].layer_id_plus_one - 1, 6);
			gf_bs_write_int(bs, sti[j].layers[k].min_temporal_id, 3);
			gf_bs_write_int(bs, sti[j].layers[k].max_temporal_id, 3);
			gf_bs_write_int(bs, 0, 1);
			//track carries the NALUs
			if (k==j) {
				gf_bs_write_int(bs, 0xFF, 7);
			}
			//otherwise referenced through extractors, not present natively
			else {
				gf_bs_write_int(bs, 0, 7);
			}
		}
		gf_bs_get_content(bs, &data, &data_size);
		gf_bs_del(bs);
		gf_isom_add_sample_group_info(file, sti[j].track_num, GF_4CC( 'l', 'i', 'n', 'f'), data, data_size, GF_TRUE, &count);
		gf_free(data);
	u32 nb_nalus_in_sample;
static void hevc_add_trif(GF_ISOFile *file, u32 track, u32 id, Bool full_picture, u32 independent, Bool filtering_disable, u32 tx, u32 ty, u32 tw, u32 th, Bool is_default)
{
	char *data[11];
	u32 di, data_size=7;
	GF_BitStream *bs;
	//write TRIF sample group description
	bs = gf_bs_new(data, 11, GF_BITSTREAM_WRITE);
	gf_bs_write_u16(bs, id);	//groupID
	gf_bs_write_int(bs, 1, 1); //tile Region flag always true for us
	gf_bs_write_int(bs, independent, 2); //independentIDC: set to 1 (motion-constrained tiles but not all tiles RAP)
	gf_bs_write_int(bs, full_picture, 1);//full picture: false since we don't do L-HEVC tiles
	gf_bs_write_int(bs, filtering_disable, 1); //filtering disabled: set to 1 (always true on our bitstreams for now) - Check xPS to be sure ...
	gf_bs_write_int(bs, 0, 1);//has dependency list: false since we don't do L-HEVC tiles
	gf_bs_write_int(bs, 0, 2); //reserved
	if (!full_picture) {
		gf_bs_write_u16(bs, tx);
		gf_bs_write_u16(bs, ty);
		data_size+=4;
	}
	gf_bs_write_u16(bs, tw);
	gf_bs_write_u16(bs, th);
	gf_bs_del(bs);

	gf_isom_add_sample_group_info(file, track, GF_4CC('t','r','i','f'), data, data_size, is_default, &di);
}

GF_Err gf_media_split_hevc_tiles(GF_ISOFile *file, Bool signal_only)
	u32 i, j, cur_tile, count, stype, track, nb_tiles, di, nalu_size_length, tx, ty, tw, th;
	s32 pps_idx=-1, sps_idx=-1, ret;
	Bool filter_disabled=GF_TRUE;
				sps_idx = gf_media_hevc_read_sps(sl->data, sl->size, &hevc);
				gf_media_hevc_read_vps(sl->data, sl->size, &hevc);
	if (sps_idx==-1) return GF_BAD_PARAM;

	if (hevc.pps[pps_idx].loop_filter_across_tiles_enabled_flag)
		filter_disabled=GF_FALSE;

	if (! hevc.pps[pps_idx].tiles_enabled_flag) {
		hevc_add_trif(file, track, gf_isom_get_track_id(file, track), GF_TRUE, 1, filter_disabled, 0, 0, hevc.sps[pps_idx].width, hevc.sps[pps_idx].width, GF_TRUE);

		GF_LOG(GF_LOG_WARNING, GF_LOG_AUTHOR, (""[HEVC Tiles] Tiles not enabled, cannot signal them\n""));
		return GF_OK;
	}

	nb_tiles = hevc.pps[pps_idx].num_tile_columns * hevc.pps[pps_idx].num_tile_rows;
	tiles = gf_malloc(sizeof(HEVCTileImport) * nb_tiles);
	memset(tiles, 0, sizeof(HEVCTileImport) * nb_tiles);
	for (i=0; i<nb_tiles; i++) {
		if (! signal_only) {
			//first clone tracks
			e = gf_isom_clone_track(file, track, file, GF_FALSE, &tiles[i].track );
			if (e) goto err_exit;
			tiles[i].track_id = gf_isom_get_track_id(file, tiles[i].track);
			gf_isom_hevc_set_tile_config(file, tiles[i].track, 1, NULL, GF_FALSE);
			// setup track references from tile track to base
			gf_isom_set_track_reference(file, tiles[i].track, GF_ISOM_REF_TBAS, gf_isom_get_track_id(file, track) );
		} else {
			tiles[i].track_id = gf_isom_get_track_id(file, track) + i+1;
		}
	}

		u32 size, nb_nalus=0;
		GF_BitStream *bs=NULL;
		if (!signal_only) {
			bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
			sample->data = NULL;
			sample->dataLength = 0;

			for (j=0; j<nb_tiles; j++) {
				tiles[j].data_offset = 0;
				tiles[j].sample_data = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
			}
		} else {
			for (j=0; j<nb_tiles; j++) {
				tiles[j].nb_nalus_in_sample = 0;
			}
			bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
			//write start of nalm group
			gf_bs_write_u8(bs, 0);//flags
			gf_bs_write_u8(bs, 0);//entry_count - will be set at the end

				if (cur_tile>=nb_tiles) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[HEVC Tiles] Tile index %d is greater than number of tiles %d in PPS\n"", cur_tile, nb_tiles));

				tiles[cur_tile].tx = tx;
				tiles[cur_tile].ty = ty;
				tiles[cur_tile].tw = tw;
				tiles[cur_tile].th = th;

				if (signal_only) {
					tiles[cur_tile].nb_nalus_in_sample++;
					gf_bs_write_u16(bs, tiles[cur_tile].track_id);
					nb_nalus++;
				} else {
					gf_bs_write_data(tiles[cur_tile].sample_data, (char *) data, nalu_size + nalu_size_length);
					if (! gf_isom_has_track_reference(file, track, GF_ISOM_REF_SABT, tiles[cur_tile].track_id)) {
						gf_isom_set_track_reference(file, track, GF_ISOM_REF_SABT, tiles[cur_tile].track_id);
					}
					tiles[cur_tile].data_offset += nalu_size + nalu_size_length;
				if (! signal_only) {
					gf_bs_write_data(bs, (char *) data, nalu_size + nalu_size_length);
				} else {
					gf_bs_write_u16(bs, 0);
					nb_nalus++;
				}

		if (! signal_only) {
			gf_free(sample->data);
			gf_bs_get_content(bs, &sample->data, &sample->dataLength);
			gf_bs_del(bs);
			e = gf_isom_update_sample(file, track, i+1, sample, 1);

			for (j=0; j<nb_tiles; j++) {
				sample->dataLength = 0;
				gf_bs_get_content(tiles[j].sample_data, &sample->data, &sample->dataLength);
				if (!sample->data)
					continue;

				e = gf_isom_add_sample(file, tiles[j].track, 1, sample);
				if (e) goto err_exit;
				tiles[j].sample_count ++;

				gf_bs_del(tiles[j].sample_data);
				tiles[j].sample_data = NULL;
				gf_free(sample->data);
				sample->data = NULL;

				e = gf_isom_copy_sample_info(file, tiles[j].track, file, track, i+1);
				if (e) goto err_exit;
			}
		} else {
			char *data=NULL;
			u32 size=0;
			u32 sdesc;
			gf_bs_get_content(bs, &data, &size);
			gf_bs_del(bs);
			data[1] = nb_nalus;
			e = gf_isom_add_sample_group_info(file, track, GF_4CC('n','a','l','m'), data, size, 0, &sdesc);
			if (e) {
				GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[ISOBMF] Error defining NALM group description entry\n"" ));
			} else {
				e = gf_isom_add_sample_info(file, track, i+1, GF_4CC('n','a','l','m'), sdesc, GF_4CC('t','r','i','f'));
				if (e) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[ISOBMF] Error associating NALM group description to sample\n"" ));
				}
			}
			gf_free(data);
	for (i=0; i<nb_tiles; i++) {
		if (! signal_only) {
			tiles[i].track = gf_isom_get_track_by_id(file, tiles[i].track_id);
			if (!tiles[i].sample_count) {
				gf_isom_remove_track(file, tiles[i].track);
				continue;
			}
			hevc_add_trif(file, tiles[i].track, tiles[i].track_id, GF_FALSE, 1, filter_disabled, tiles[i].tx, tiles[i].ty, tiles[i].tw, tiles[i].th, GF_TRUE);
			gf_isom_set_visual_info(file, tiles[i].track, 1, tiles[i].tw, tiles[i].th);
			gf_isom_get_track_layout_info(file, track, &width, &height, &translation_x, &translation_y, &layer);
			gf_isom_set_track_layout_info(file, tiles[i].track, width<<16, height<<16, translation_x, translation_y, layer);
		} else {
			hevc_add_trif(file, track, tiles[i].track_id, GF_FALSE, 1, filter_disabled, tiles[i].tx, tiles[i].ty, tiles[i].tw, tiles[i].th, GF_FALSE);
		}","	u32 min_temporal_id, max_temporal_id;
			if (!sti[layer_id].min_temporal_id || (sti[layer_id].min_temporal_id > temporal_id)) {
				sti[layer_id].min_temporal_id = temporal_id;
			if (!sti[layer_id].max_temporal_id || (sti[layer_id].max_temporal_id < temporal_id)) {
				sti[layer_id].max_temporal_id = temporal_id;
					u8 trefidx;
					gf_bs_write_int(xbs, sti[k].max_temporal_id, 3);
			sti[j].max_temporal_id = 0;
GF_Err gf_media_split_hevc_tiles(GF_ISOFile *file)
	u32 i, j, cur_tile, count, stype, track, nb_tracks, di, nalu_size_length, tx, ty, tw, th;
	s32 pps_idx=-1, ret;
				pps_idx = gf_media_hevc_read_sps(sl->data, sl->size, &hevc);
				pps_idx = gf_media_hevc_read_vps(sl->data, sl->size, &hevc);
	if (! hevc.pps[pps_idx].tiles_enabled_flag) return GF_OK;
	nb_tracks = hevc.pps[pps_idx].num_tile_columns * hevc.pps[pps_idx].num_tile_rows;
	tiles = gf_malloc(sizeof(HEVCTileImport) * nb_tracks);
	memset(tiles, 0, sizeof(HEVCTileImport) * nb_tracks);
	//first clone tracks
	for (i=0; i<nb_tracks; i++) {
		e = gf_isom_clone_track(file, track, file, GF_FALSE, &tiles[i].track );
		if (e) goto err_exit;
		tiles[i].track_id = gf_isom_get_track_id(file, tiles[i].track);
		gf_isom_hevc_set_tile_config(file, tiles[i].track, 1, NULL, GF_FALSE);
	}
	//then setup track references (done in two pass otherwise we would clone the tref box ...)
	for (i=0; i<nb_tracks; i++) {
		gf_isom_set_track_reference(file, tiles[i].track, GF_ISOM_REF_TBAS, gf_isom_get_track_id(file, track) );
	}
		u32 size;
		GF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
		sample->data = NULL;
		sample->dataLength = 0;

		for (j=0; j<nb_tracks; j++) {
			tiles[j].data_offset = 0;
			tiles[j].sample_data = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);
			tiles[j].data_offset = 0;
				if (cur_tile>=nb_tracks) {
					GF_LOG(GF_LOG_ERROR, GF_LOG_AUTHOR, (""[HEVC Tiles] Tile index %d is greater than number of tiles %d in PPS\n"", cur_tile, nb_tracks));
				} else {
					gf_bs_write_data(tiles[cur_tile].sample_data, (char *) data, nalu_size + nalu_size_length);
					tiles[cur_tile].tx = tx;
					tiles[cur_tile].ty = ty;
					tiles[cur_tile].tw = tw;
					tiles[cur_tile].th = th;
				if (! gf_isom_has_track_reference(file, track, GF_ISOM_REF_SABT, tiles[cur_tile].track_id)) {
					gf_isom_set_track_reference(file, track, GF_ISOM_REF_SABT, tiles[cur_tile].track_id);
				tiles[cur_tile].data_offset += nalu_size + nalu_size_length;
				gf_bs_write_data(bs, (char *) data, nalu_size + nalu_size_length);
		gf_free(sample->data);
		gf_bs_get_content(bs, &sample->data, &sample->dataLength);
		gf_bs_del(bs);

		e = gf_isom_update_sample(file, track, i+1, sample, 1);
		if (e) goto err_exit;

		gf_free(sample->data);
		sample->data = NULL;

		for (j=0; j<nb_tracks; j++) {
			sample->dataLength = 0;
			gf_bs_get_content(tiles[j].sample_data, &sample->data, &sample->dataLength);
			if (!sample->data)
				continue;
			e = gf_isom_add_sample(file, tiles[j].track, 1, sample);
			tiles[j].sample_count ++;
			gf_bs_del(tiles[j].sample_data);
			tiles[j].sample_data = NULL;
			e = gf_isom_copy_sample_info(file, tiles[j].track, file, track, i+1);
	for (i=0; i<nb_tracks; i++) {
		char data[11];
		tiles[i].track = gf_isom_get_track_by_id(file, tiles[i].track_id);
		if (!tiles[i].sample_count) {
			gf_isom_remove_track(file, tiles[i].track);
			continue;
		}
		//write TRIF sample group description
		bs = gf_bs_new(data, 11, GF_BITSTREAM_WRITE);
		gf_bs_write_u16(bs, tiles[i].track);	//groupID
		gf_bs_write_int(bs, 1, 1); //tile Region flag always true for us
		gf_bs_write_int(bs, 1, 2); //independentIDC: set to 1 (motion-constrained tiles but not all tiles RAP)
		gf_bs_write_int(bs, 0, 1);//full picture: false since we don't do L-HEVC tiles
		gf_bs_write_int(bs, 1, 1); //filtering disabled: set to 1 (always true on our bitstreams for now) - Check xPS to be sure ...
		gf_bs_write_int(bs, 0, 1);//has dependency list: false since we don't do L-HEVC tiles
		gf_bs_write_int(bs, 0, 2); //reserved

		gf_bs_write_u16(bs, tiles[i].tx);
		gf_bs_write_u16(bs, tiles[i].ty);
		gf_bs_write_u16(bs, tiles[i].tw);
		gf_bs_write_u16(bs, tiles[i].th);
		gf_bs_del(bs);
		gf_isom_add_sample_group_info(file, tiles[i].track, GF_4CC('t','r','i','f'), data, 11, 1, &di);
		gf_isom_set_visual_info(file, tiles[i].track, 1, tiles[i].tw, tiles[i].th);
		gf_isom_get_track_layout_info(file, track, &width, &height, &translation_x, &translation_y, &layer);
		gf_isom_set_track_layout_info(file, tiles[i].track, width<<16, height<<16, translation_x, translation_y, layer);",3d17f9524b48e8564bba50055c3502e660c41a64,CVE-2018-1000100,3d17f9524b48e8564bba50055c3502e660c41a64,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,76,COMPLETED,"VAR VAR{ VAR VAR; VAR VAR; VAR VAR; } VAR; VAR VAR, VAR; VAR VAR[64];  VAR(VAR, VAR, VAR('VAR','VAR','VAR','VAR')); VAR[VAR].VAR[VAR].VAR = VAR+1; VAR[VAR].VAR = VAR; VAR (!VAR[VAR].VAR[VAR].VAR || (VAR[VAR].VAR[VAR].VAR > VAR)) { VAR[VAR].VAR[VAR].VAR = VAR; } VAR (!VAR[VAR].VAR[VAR].VAR || (VAR[VAR].VAR[VAR].VAR < VAR)) { VAR[VAR].VAR[VAR].VAR = VAR; VAR (!VAR[VAR].VAR || (VAR[VAR].VAR < VAR)) { VAR[VAR].VAR = VAR;  VAR(VAR, VAR[VAR].VAR, VAR('VAR','VAR','VAR','VAR')); VAR VAR, VAR; VAR(VAR, VAR[VAR].VAR, 3); VAR = VAR[VAR].VAR; VAR[VAR].VAR[VAR].VAR = VAR[VAR].VAR+1; VAR (!VAR[VAR].VAR[VAR].VAR || (VAR[VAR].VAR[VAR].VAR > VAR)) { VAR[VAR].VAR[VAR].VAR = VAR; } VAR (!VAR[VAR].VAR[VAR].VAR || (VAR[VAR].VAR[VAR].VAR < VAR)) { VAR[VAR].VAR[VAR].VAR = VAR; } VAR[VAR].VAR = 0; VAR[VAR].VAR = 0; VAR *VAR; VAR VAR, VAR; VAR *VAR=VAR;  VAR = VAR(VAR, 0, VAR); VAR(VAR, 0, 2); VAR = 0; VAR (VAR=0; VAR<=VAR; VAR++) { VAR (VAR[VAR].VAR[VAR].VAR) VAR++; } VAR(VAR, VAR, 6); VAR (VAR=0; VAR<=VAR; VAR++) { VAR (! VAR[VAR].VAR[VAR].VAR) VAR; VAR(VAR, 0, 4); VAR(VAR, VAR[VAR].VAR[VAR].VAR - 1, 6); VAR(VAR, VAR[VAR].VAR[VAR].VAR, 3); VAR(VAR, VAR[VAR].VAR[VAR].VAR, 3); VAR(VAR, 0, 1);  VAR (VAR==VAR) { VAR(VAR, 0xFF, 7); }  VAR { VAR(VAR, 0, 7); } } VAR(VAR, &VAR, &VAR); VAR(VAR); VAR(VAR, VAR[VAR].VAR, VAR( 'VAR', 'VAR', 'VAR', 'VAR'), VAR, VAR, VAR, &VAR); VAR(VAR); VAR VAR; VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR) { VAR *VAR[11]; VAR VAR, VAR=7; VAR *VAR;  VAR = VAR(VAR, 11, VAR); VAR(VAR, VAR);  VAR(VAR, 1, 1);  VAR(VAR, VAR, 2);  VAR(VAR, VAR, 1); VAR(VAR, VAR, 1);  VAR(VAR, 0, 1); VAR(VAR, 0, 2);  VAR (!VAR) { VAR(VAR, VAR); VAR(VAR, VAR); VAR+=4; } VAR(VAR, VAR); VAR(VAR, VAR); VAR(VAR); VAR(VAR, VAR, VAR('VAR','VAR','VAR','VAR'), VAR, VAR, VAR, &VAR); } VAR VAR(VAR *VAR, VAR VAR) VAR VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR; VAR VAR=-1, VAR=-1, VAR; VAR VAR=VAR; VAR = VAR(VAR->VAR, VAR->VAR, &VAR); VAR(VAR->VAR, VAR->VAR, &VAR); VAR (VAR==-1) VAR VAR; VAR (VAR.VAR[VAR].VAR) VAR=VAR; VAR (! VAR.VAR[VAR].VAR) { VAR(VAR, VAR, VAR(VAR, VAR), VAR, 1, VAR, 0, 0, VAR.VAR[VAR].VAR, VAR.VAR[VAR].VAR, VAR); VAR(VAR, VAR, (""[VAR VAR] VAR VAR VAR, VAR VAR VAR\VAR"")); VAR VAR; } VAR = VAR.VAR[VAR].VAR * VAR.VAR[VAR].VAR; VAR = VAR(VAR(VAR) * VAR); VAR(VAR, 0, VAR(VAR) * VAR); VAR (VAR=0; VAR<VAR; VAR++) { VAR (! VAR) {  VAR = VAR(VAR, VAR, VAR, VAR, &VAR[VAR].VAR ); VAR (VAR) VAR VAR; VAR[VAR].VAR = VAR(VAR, VAR[VAR].VAR); VAR(VAR, VAR[VAR].VAR, 1, VAR, VAR);  VAR(VAR, VAR[VAR].VAR, VAR, VAR(VAR, VAR) ); } VAR { VAR[VAR].VAR = VAR(VAR, VAR) + VAR+1; } } VAR VAR, VAR=0; VAR *VAR=VAR; VAR (!VAR) { VAR = VAR(VAR, 0, VAR); VAR->VAR = VAR; VAR->VAR = 0; VAR (VAR=0; VAR<VAR; VAR++) { VAR[VAR].VAR = 0; VAR[VAR].VAR = VAR(VAR, 0, VAR); } } VAR { VAR (VAR=0; VAR<VAR; VAR++) { VAR[VAR].VAR = 0; } VAR = VAR(VAR, 0, VAR);  VAR(VAR, 0); VAR(VAR, 0); VAR (VAR>=VAR) { VAR(VAR, VAR, (""[VAR VAR] VAR VAR %VAR VAR VAR VAR VAR VAR VAR %VAR VAR VAR\VAR"", VAR, VAR)); VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR (VAR) { VAR[VAR].VAR++; VAR(VAR, VAR[VAR].VAR); VAR++; } VAR { VAR(VAR[VAR].VAR, (VAR *) VAR, VAR + VAR); VAR (! VAR(VAR, VAR, VAR, VAR[VAR].VAR)) { VAR(VAR, VAR, VAR, VAR[VAR].VAR); } VAR[VAR].VAR += VAR + VAR; VAR (! VAR) { VAR(VAR, (VAR *) VAR, VAR + VAR); } VAR { VAR(VAR, 0); VAR++; } VAR (! VAR) { VAR(VAR->VAR); VAR(VAR, &VAR->VAR, &VAR->VAR); VAR(VAR); VAR = VAR(VAR, VAR, VAR+1, VAR, 1); VAR (VAR=0; VAR<VAR; VAR++) { VAR->VAR = 0; VAR(VAR[VAR].VAR, &VAR->VAR, &VAR->VAR); VAR (!VAR->VAR) VAR; VAR = VAR(VAR, VAR[VAR].VAR, 1, VAR); VAR (VAR) VAR VAR; VAR[VAR].VAR ++; VAR(VAR[VAR].VAR); VAR[VAR].VAR = VAR; VAR(VAR->VAR); VAR->VAR = VAR; VAR = VAR(VAR, VAR[VAR].VAR, VAR, VAR, VAR+1); VAR (VAR) VAR VAR; } } VAR { VAR *VAR=VAR; VAR VAR=0; VAR VAR; VAR(VAR, &VAR, &VAR); VAR(VAR); VAR[1] = VAR; VAR = VAR(VAR, VAR, VAR('VAR','VAR','VAR','VAR'), VAR, VAR, 0, &VAR); VAR (VAR) { VAR(VAR, VAR, (""[VAR] VAR VAR VAR VAR VAR VAR\VAR"" )); } VAR { VAR = VAR(VAR, VAR, VAR+1, VAR('VAR','VAR','VAR','VAR'), VAR, VAR('VAR','VAR','VAR','VAR')); VAR (VAR) { VAR(VAR, VAR, (""[VAR] VAR VAR VAR VAR VAR VAR VAR\VAR"" )); } } VAR(VAR); VAR (VAR=0; VAR<VAR; VAR++) { VAR (! VAR) { VAR[VAR].VAR = VAR(VAR, VAR[VAR].VAR); VAR (!VAR[VAR].VAR) { VAR(VAR, VAR[VAR].VAR); VAR; } VAR(VAR, VAR[VAR].VAR, VAR[VAR].VAR, VAR, 1, VAR, VAR[VAR].VAR, VAR[VAR].VAR, VAR[VAR].VAR, VAR[VAR].VAR, VAR); VAR(VAR, VAR[VAR].VAR, 1, VAR[VAR].VAR, VAR[VAR].VAR); VAR(VAR, VAR, &VAR, &VAR, &VAR, &VAR, &VAR); VAR(VAR, VAR[VAR].VAR, VAR<<16, VAR<<16, VAR, VAR, VAR); } VAR { VAR(VAR, VAR, VAR[VAR].VAR, VAR, 1, VAR, VAR[VAR].VAR, VAR[VAR].VAR, VAR[VAR].VAR, VAR[VAR].VAR, VAR); } VAR VAR, VAR; VAR (!VAR[VAR].VAR || (VAR[VAR].VAR > VAR)) { VAR[VAR].VAR = VAR; VAR (!VAR[VAR].VAR || (VAR[VAR].VAR < VAR)) { VAR[VAR].VAR = VAR; VAR VAR; VAR(VAR, VAR[VAR].VAR, 3); VAR[VAR].VAR = 0; VAR VAR(VAR *VAR) VAR VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR; VAR VAR=-1, VAR; VAR = VAR(VAR->VAR, VAR->VAR, &VAR); VAR = VAR(VAR->VAR, VAR->VAR, &VAR); VAR (! VAR.VAR[VAR].VAR) VAR VAR; VAR = VAR.VAR[VAR].VAR * VAR.VAR[VAR].VAR; VAR = VAR(VAR(VAR) * VAR); VAR(VAR, 0, VAR(VAR) * VAR);  VAR (VAR=0; VAR<VAR; VAR++) { VAR = VAR(VAR, VAR, VAR, VAR, &VAR[VAR].VAR ); VAR (VAR) VAR VAR; VAR[VAR].VAR = VAR(VAR, VAR[VAR].VAR); VAR(VAR, VAR[VAR].VAR, 1, VAR, VAR); }  VAR (VAR=0; VAR<VAR; VAR++) { VAR(VAR, VAR[VAR].VAR, VAR, VAR(VAR, VAR) ); } VAR VAR; VAR *VAR = VAR(VAR, 0, VAR); VAR->VAR = VAR; VAR->VAR = 0; VAR (VAR=0; VAR<VAR; VAR++) { VAR[VAR].VAR = 0; VAR[VAR].VAR = VAR(VAR, 0, VAR); VAR[VAR].VAR = 0; VAR (VAR>=VAR) { VAR(VAR, VAR, (""[VAR VAR] VAR VAR %VAR VAR VAR VAR VAR VAR VAR %VAR VAR VAR\VAR"", VAR, VAR)); } VAR { VAR(VAR[VAR].VAR, (VAR *) VAR, VAR + VAR); VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR (! VAR(VAR, VAR, VAR, VAR[VAR].VAR)) { VAR(VAR, VAR, VAR, VAR[VAR].VAR); VAR[VAR].VAR += VAR + VAR; VAR(VAR, (VAR *) VAR, VAR + VAR); VAR(VAR->VAR); VAR(VAR, &VAR->VAR, &VAR->VAR); VAR(VAR); VAR = VAR(VAR, VAR, VAR+1, VAR, 1); VAR (VAR) VAR VAR; VAR(VAR->VAR); VAR->VAR = VAR; VAR (VAR=0; VAR<VAR; VAR++) { VAR->VAR = 0; VAR(VAR[VAR].VAR, &VAR->VAR, &VAR->VAR); VAR (!VAR->VAR) VAR; VAR = VAR(VAR, VAR[VAR].VAR, 1, VAR); VAR[VAR].VAR ++; VAR(VAR[VAR].VAR); VAR[VAR].VAR = VAR; VAR = VAR(VAR, VAR[VAR].VAR, VAR, VAR, VAR+1); VAR (VAR=0; VAR<VAR; VAR++) { VAR VAR[11]; VAR[VAR].VAR = VAR(VAR, VAR[VAR].VAR); VAR (!VAR[VAR].VAR) { VAR(VAR, VAR[VAR].VAR); VAR; }  VAR = VAR(VAR, 11, VAR); VAR(VAR, VAR[VAR].VAR);  VAR(VAR, 1, 1);  VAR(VAR, 1, 2);  VAR(VAR, 0, 1); VAR(VAR, 1, 1);  VAR(VAR, 0, 1); VAR(VAR, 0, 2);  VAR(VAR, VAR[VAR].VAR); VAR(VAR, VAR[VAR].VAR); VAR(VAR, VAR[VAR].VAR); VAR(VAR, VAR[VAR].VAR); VAR(VAR); VAR(VAR, VAR[VAR].VAR, VAR('VAR','VAR','VAR','VAR'), VAR, 11, 1, &VAR); VAR(VAR, VAR[VAR].VAR, 1, VAR[VAR].VAR, VAR[VAR].VAR); VAR(VAR, VAR, &VAR, &VAR, &VAR, &VAR, &VAR); VAR(VAR, VAR[VAR].VAR, VAR<<16, VAR<<16, VAR, VAR, VAR);",1
gpac_51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,src/media_tools/av_parsers.c,"	if ((sps_id < 0) || (sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 255)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 64))
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((sps_id<0) || (sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((pps_id<0) || (pps_id >= 64))","	if (sps_id >= 32) {
		return -1;
	}
	if (sps_id < 0) {
	if (pps_id >= 255) {
	if (pps->sps_id >= 32) {
	if (pps_id >= 64)
	if (vps_id >= 16) return -1;
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (vps_id >= 16) return -1;
	if (sps_id >= 16) {
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (pps_id >= 64)",51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,CVE-2021-30020,51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR ((VAR < 0) || (VAR >= 32)) { VAR ((VAR<0) || (VAR >= 255)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 32)) { VAR ((VAR<0) || (VAR >= 64)) VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 64)) VAR (VAR >= 32) { VAR -1; } VAR (VAR < 0) { VAR (VAR >= 255) { VAR (VAR->VAR >= 32) { VAR (VAR >= 64) VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 64),1
gpac_51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,src/media_tools/av_parsers.c,"	if ((sps_id < 0) || (sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 255)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 64))
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((sps_id<0) || (sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((pps_id<0) || (pps_id >= 64))","	if (sps_id >= 32) {
		return -1;
	}
	if (sps_id < 0) {
	if (pps_id >= 255) {
	if (pps->sps_id >= 32) {
	if (pps_id >= 64)
	if (vps_id >= 16) return -1;
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (vps_id >= 16) return -1;
	if (sps_id >= 16) {
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (pps_id >= 64)",51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,CVE-2021-30022,51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR ((VAR < 0) || (VAR >= 32)) { VAR ((VAR<0) || (VAR >= 255)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 32)) { VAR ((VAR<0) || (VAR >= 64)) VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 64)) VAR (VAR >= 32) { VAR -1; } VAR (VAR < 0) { VAR (VAR >= 255) { VAR (VAR->VAR >= 32) { VAR (VAR >= 64) VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 64),1
gpac_51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,src/media_tools/av_parsers.c,"	if ((sps_id < 0) || (sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 255)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 64))
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((sps_id<0) || (sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((pps_id<0) || (pps_id >= 64))","	if (sps_id >= 32) {
		return -1;
	}
	if (sps_id < 0) {
	if (pps_id >= 255) {
	if (pps->sps_id >= 32) {
	if (pps_id >= 64)
	if (vps_id >= 16) return -1;
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (vps_id >= 16) return -1;
	if (sps_id >= 16) {
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (pps_id >= 64)",51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,CVE-2021-30014,51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR ((VAR < 0) || (VAR >= 32)) { VAR ((VAR<0) || (VAR >= 255)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 32)) { VAR ((VAR<0) || (VAR >= 64)) VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 64)) VAR (VAR >= 32) { VAR -1; } VAR (VAR < 0) { VAR (VAR >= 255) { VAR (VAR->VAR >= 32) { VAR (VAR >= 64) VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 64),1
gpac_8986422c21fbd9a7bf6561cae65aae42077447e8,src/isomedia/box_code_drm.c,"		if ((iv_size!=8) && (iv_size!=16)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Invalid constant IV size %d, must be 8 or 16\n"", (u32) iv_size));
			ptr->key_info[20] = 16;
			return GF_NON_COMPLIANT_BITSTREAM;
		}
	else if ((iv_size!=0) && (iv_size!=8) && (iv_size!=16)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Invalid IV size %d, must be 0, 8 or 16\n"", (u32) iv_size));
		return GF_NON_COMPLIANT_BITSTREAM;
	}",,8986422c21fbd9a7bf6561cae65aae42077447e8,CVE-2021-31254,8986422c21fbd9a7bf6561cae65aae42077447e8,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ((VAR!=8) && (VAR!=16)) { VAR(VAR, VAR, (""[VAR VAR] VAR VAR VAR VAR %VAR, VAR VAR 8 VAR 16\VAR"", (VAR) VAR)); VAR->VAR[20] = 16; VAR VAR; } VAR VAR ((VAR!=0) && (VAR!=8) && (VAR!=16)) { VAR(VAR, VAR, (""[VAR VAR] VAR VAR VAR %VAR, VAR VAR 0, 8 VAR 16\VAR"", (VAR) VAR)); VAR VAR; } ",1
gpac_c26b0aa605aaea1f0ebe8d21fe1398d94680adf7,src/odf/odf_code.c,			if (nbBytes + 16 > DescSize) return GF_ODF_INVALID_DESCRIPTOR;,			if (nbBytes>DescSize) break;,c26b0aa605aaea1f0ebe8d21fe1398d94680adf7,CVE-2020-19751,c26b0aa605aaea1f0ebe8d21fe1398d94680adf7,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,110,COMPLETED,VAR (VAR + 16 > VAR) VAR VAR; VAR (VAR>VAR) VAR;,1
gpac_d7c2bb5cc3c67566f506f51cbefbf66f8169ea85,src/media_tools/av_parsers.c,"	state->equal_picture_interval = gf_bs_read_int(bs, 3);
	if (state->equal_picture_interval) {
	u8 operating_points_cnt_minus_1, buffer_delay_length_minus_1 = 0;
	Bool timing_info_present_flag, initial_display_delay_present_flag;
			state->decoder_model_info_present_flag = gf_bs_read_int(bs, 1);
			if (state->decoder_model_info_present_flag) {
			state->decoder_model_info_present_flag = GF_FALSE;
			if (state->decoder_model_info_present_flag) {
	state->frame_width_bits_minus_1 = gf_bs_read_int(bs, 4);
	state->frame_height_bits_minus_1 = gf_bs_read_int(bs, 4);
	state->width = gf_bs_read_int(bs,  state->frame_width_bits_minus_1  + 1) + 1;
	state->height = gf_bs_read_int(bs, state->frame_height_bits_minus_1 + 1) + 1;
		state->delta_frame_id_length_minus_2 = gf_bs_read_int(bs, 4);
		state->additional_frame_id_length_minus_1 = gf_bs_read_int(bs, 3);
		enable_ref_frame_mvs = 0;*/
		state->enable_order_hint = GF_FALSE;
		state->OrderHintBits = 0;
		state->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;
		state->seq_force_screen_content_tools = 2/*SELECT_SCREEN_CONTENT_TOOLS*/;
		Bool seq_choose_screen_content_tools;
		state->enable_order_hint = gf_bs_read_int(bs, 1);
		if (state->enable_order_hint) {
			state->enable_ref_frame_mvs = gf_bs_read_int(bs, 1);
		state->seq_force_screen_content_tools = 0;
			state->seq_force_screen_content_tools = 2/*SELECT_SCREEN_CONTENT_TOOLS*/;
			state->seq_force_screen_content_tools = gf_bs_read_int(bs, 1);
		state->seq_force_integer_mv = 0;
		if (state->seq_force_screen_content_tools > 0) {
				state->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;
				state->seq_force_integer_mv = gf_bs_read_int(bs, 1);
			state->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;
		if (state->enable_order_hint) {
			u8 order_hint_bits_minus_1 = gf_bs_read_int(bs, 3);
			state->OrderHintBits = order_hint_bits_minus_1 + 1;
			state->OrderHintBits = 0;
	state->enable_superres = gf_bs_read_int(bs, 1);
	AV1_KEY_FRAME = 0,
	AV1_INTER_FRAME = 1,
	AV1_INTRA_ONLY_FRAME = 2,
	AV1_SWITCH_FRAME = 3,
#define AV1_NUM_REF_FRAMES 8
#define AV1_ALL_FRAMES ((1 << AV1_NUM_REF_FRAMES) - 1)

#define AV1_SUPERRES_DENOM_MIN 9
#define AV1_SUPERRES_DENOM_BITS 3
#define AV1_SUPERRES_NUM 8

#define AV1_REFS_PER_FRAME 7
#define AV1_PRIMARY_REF_NONE 7

static u64 aom_av1_le(GF_BitStream *bs, u32 n) {
	u32 i = 0;
	u64 t = 0;
	for (i = 0; i < n; i++) {
		u8 byte = gf_bs_read_int(bs, 8);
		t += (byte << (i * 8));
	}
	return t;
}

static void av1_parse_tile_info(GF_BitStream *bs, AV1State *state)
		minLog2tileRows = MAX((int)(minLog2Tiles - state->tileColsLog2), 0);
			u32 maxWidth = MIN((int)(sbCols - startSb), maxTileWidthSb);
			u32 maxHeight = MIN((int)(sbRows - startSb), maxTileHeightSb);
		/*context_update_tile_id = */gf_bs_read_int(bs, state->tileRowsLog2 + state->tileColsLog2);
		state->tile_size_bytes = gf_bs_read_int(bs, 2) + 1;
	}
}

static void superres_params(GF_BitStream *bs, AV1State *state)
{
	u32 SuperresDenom;
	Bool use_superres;

	if (state->enable_superres) {
		use_superres = gf_bs_read_int(bs, 1);
	} else {
		use_superres = GF_FALSE;
	}
	if (use_superres) {
		u8 coded_denom = gf_bs_read_int(bs, AV1_SUPERRES_DENOM_BITS);
		SuperresDenom = coded_denom + AV1_SUPERRES_DENOM_MIN;
	} else {
		SuperresDenom = AV1_SUPERRES_NUM;
	}
	state->UpscaledWidth = state->width;
	state->width = (state->UpscaledWidth * AV1_SUPERRES_NUM + (SuperresDenom / 2)) / SuperresDenom;
}

static void frame_size(GF_BitStream *bs, AV1State *state, Bool frame_size_override_flag)
{
	if (frame_size_override_flag) {
		u32 frame_width_minus_1, frame_height_minus_1;
		u8 n = state->frame_width_bits_minus_1 + 1;
		frame_width_minus_1 = gf_bs_read_int(bs, n);
		n = state->frame_height_bits_minus_1 + 1;
		frame_height_minus_1 = gf_bs_read_int(bs, n);
		state->width = frame_width_minus_1 + 1;
		state->height = frame_height_minus_1 + 1;
	}
	superres_params(bs, state);
	//compute_image_size();
}

static void render_size(GF_BitStream *bs)
{
	Bool render_and_frame_size_different = gf_bs_read_int(bs, 1);
	if (render_and_frame_size_different == GF_TRUE) {
		/*render_width_minus_1 =*/ gf_bs_read_int(bs, 16);
		/*render_height_minus_1 =*/ gf_bs_read_int(bs, 16);
		//RenderWidth = render_width_minus_1 + 1;
		//RenderHeight = render_height_minus_1 + 1;
	} else {
		//RenderWidth = UpscaledWidth;
		//RenderHeight = FrameHeight;
	}
}

static void read_interpolation_filter(GF_BitStream *bs)
{
	Bool is_filter_switchable = gf_bs_read_int(bs, 1);
	if (!is_filter_switchable) {
		/*interpolation_filter =*/ gf_bs_read_int(bs, 2);
	}
}

static void frame_size_with_refs(GF_BitStream *bs, AV1State *state, Bool frame_size_override_flag)
{
	Bool found_ref = GF_FALSE;
	u32 i = 0;
	for (i = 0; i < AV1_REFS_PER_FRAME; i++) {
		found_ref = gf_bs_read_int(bs, 1);
		if (found_ref == 1) {
#if 0
			UpscaledWidth = RefUpscaledWidth[ref_frame_idx[i]];
			FrameWidth = UpscaledWidth;
			FrameHeight = RefFrameHeight[ref_frame_idx[i]];
			RenderWidth = RefRenderWidth[ref_frame_idx[i]];
			RenderHeight = RefRenderHeight[ref_frame_idx[i]];
#endif
			break;
		}
	}
	if (found_ref == 0) {
		frame_size(bs, state, frame_size_override_flag);
		render_size(bs);
	} else {
		superres_params(bs, state);
		//compute_image_size();
	Bool error_resilient_mode = GF_FALSE, allow_screen_content_tools = GF_FALSE, force_integer_mv = GF_FALSE;
	Bool use_ref_frame_mvs = GF_FALSE, FrameIsIntra = GF_FALSE, frame_size_override_flag = GF_FALSE;
	Bool disable_cdf_update = GF_FALSE, refresh_frame_flags = GF_FALSE;
	u8 primary_ref_frame;
	u16 idLen = 0;
	AV1FrameType frame_type;


		idLen = (state->additional_frame_id_length_minus_1 + state->delta_frame_id_length_minus_2 + 3);

		FrameIsIntra = GF_TRUE;
		frame_type = AV1_KEY_FRAME;
		frame_state->show_frame = GF_TRUE;
			/*frame_to_show_map_idx = gf_bs_read_int(bs, 3);
			if (state->decoder_model_info_present_flag && !state->equal_picture_interval) {
				temporal_point_info();
			refresh_frame_flags = 0;
				display_frame_id = gf_bs_read_int(bs, idLen);
			if (frame_type == AV1_KEY_FRAME) {
				refresh_frame_flags = AV1_ALL_FRAMES;
		FrameIsIntra = (frame_type == AV1_INTRA_ONLY_FRAME || frame_type == AV1_KEY_FRAME);
		frame_state->show_frame = gf_bs_read_int(bs, 1);
		frame_state->key_frame = frame_state->seen_seq_header && frame_state->show_frame && frame_type == AV1_KEY_FRAME && frame_state->seen_frame_header;
		if (frame_state->show_frame && state->decoder_model_info_present_flag && !state->equal_picture_interval) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[AV1] temporal_point_info() not implemented (1)\n""));
			assert(0);
			return;
		}
		if (!frame_state->show_frame) {
			/*showable_frame = */gf_bs_read_int(bs, 1);
		}
		if (frame_type == AV1_SWITCH_FRAME || (frame_type == AV1_KEY_FRAME && frame_state->show_frame))
			error_resilient_mode = GF_TRUE;
		else
			error_resilient_mode = gf_bs_read_int(bs, 1);
	}

	disable_cdf_update = gf_bs_read_int(bs, 1);
	if (state->seq_force_screen_content_tools == 2/*SELECT_SCREEN_CONTENT_TOOLS*/) {
		allow_screen_content_tools = gf_bs_read_int(bs, 1);
	} else {
		allow_screen_content_tools = state->seq_force_screen_content_tools;
	}
	if (allow_screen_content_tools) {
		if (state->seq_force_integer_mv == 2/*SELECT_INTEGER_MV*/) {
			force_integer_mv = gf_bs_read_int(bs, 1);
		} else {
			force_integer_mv = state->seq_force_integer_mv;
		}
	} else {
		force_integer_mv = 0;
	}
	if (FrameIsIntra) {
		force_integer_mv = 1;
	}
	if (state->frame_id_numbers_present_flag) {
		/*current_frame_id = */gf_bs_read_int(bs, idLen);
	}
	if (frame_type == AV1_SWITCH_FRAME)
		frame_size_override_flag =  GF_TRUE;
	else if (state->reduced_still_picture_header)
		frame_size_override_flag = GF_FALSE;
	else
		frame_size_override_flag = gf_bs_read_int(bs, 1);

	/*order_hint = */gf_bs_read_int(bs, state->OrderHintBits);
	if (FrameIsIntra || error_resilient_mode) {
		primary_ref_frame = AV1_PRIMARY_REF_NONE;
	} else {
		primary_ref_frame = gf_bs_read_int(bs, 3);
	}

	if (state->decoder_model_info_present_flag) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[AV1] decoder model info present parsing\n""));
		assert(0);
		return;
#if 0
		buffer_removal_time_present_flag = gf_bs_read_int(bs, 1);
		if (buffer_removal_time_present_flag) {
			for (opNum = 0; opNum <= operating_points_cnt_minus_1; opNum++) {
				if (decoder_model_present_for_this_op[opNum]) {
					opPtIdc = operating_point_idc[opNum];
					inTemporalLayer = (opPtIdc >> temporal_id) & 1;
					inSpatialLayer = (opPtIdc >> (spatial_id + 8)) & 1;
					if (opPtIdc == 0 || (inTemporalLayer && inSpatialLayer)) {
						n = buffer_removal_time_length_minus_1 + 1;
						buffer_removal_time[opNum] = gf_bs_read_int(bs, n);
					}
				}
			}
		}
#endif
	}
	if (frame_type == AV1_SWITCH_FRAME || (frame_type == AV1_KEY_FRAME && frame_state->show_frame)) {
		refresh_frame_flags  = AV1_ALL_FRAMES;
	} else {
		refresh_frame_flags = gf_bs_read_int(bs, 8);
	}
	if (!FrameIsIntra || refresh_frame_flags != AV1_ALL_FRAMES) {
		if (error_resilient_mode && state->enable_order_hint) {
			u32 i = 0;
			for (i = 0; i < AV1_NUM_REF_FRAMES; i++) {
				/*ref_order_hint[i] = */gf_bs_read_int(bs, state->OrderHintBits);
			}
		}

	if (frame_type == AV1_KEY_FRAME) {
		frame_size(bs, state, frame_size_override_flag);
		render_size(bs);
		if (allow_screen_content_tools && state->UpscaledWidth == state->width) {
			/*allow_intrabc = */gf_bs_read_int(bs, 1);
		}
	} else {
		if (frame_type == AV1_INTRA_ONLY_FRAME) {
			frame_size(bs, state, frame_size_override_flag);
			render_size(bs);
			if (allow_screen_content_tools && state->UpscaledWidth == state->width) {
				/*allow_intrabc = */gf_bs_read_int(bs, 1);
			}
		} else {
			u32 i = 0;
			Bool frame_refs_short_signaling = GF_FALSE;
			if (state->enable_order_hint) {
				frame_refs_short_signaling = gf_bs_read_int(bs, 1);
				if (frame_refs_short_signaling) {
					/*last_frame_idx =*/ gf_bs_read_int(bs, 3);
					/*gold_frame_idx =*/ gf_bs_read_int(bs, 3);
					//set_frame_refs();
				}
			}
			for (i = 0; i < AV1_REFS_PER_FRAME; i++) {
				if (!frame_refs_short_signaling)
					/*ref_frame_idx[i] =*/ gf_bs_read_int(bs, 3);
					if (state->frame_id_numbers_present_flag) {
						u32 n = state->delta_frame_id_length_minus_2 + 2;
						/*delta_frame_id_minus_1 =*/ gf_bs_read_int(bs, n);
						//DeltaFrameId = delta_frame_id_minus_1 + 1;
						//expectedFrameId[i] = ((current_frame_id + (1 << idLen) - DeltaFrameId) % (1 << idLen));
					}
			}
			if (frame_size_override_flag && !error_resilient_mode) {
				frame_size_with_refs(bs, state, frame_size_override_flag);
			} else {
				frame_size(bs, state, frame_size_override_flag);
				render_size(bs);
			}
			if (!force_integer_mv) {
				/*allow_high_precision_mv = */gf_bs_read_int(bs, 1);
			}

			read_interpolation_filter(bs);

			/*is_motion_mode_switchable =*/ gf_bs_read_int(bs, 1);
			if (! (error_resilient_mode || !state->enable_ref_frame_mvs) ) {
				use_ref_frame_mvs = gf_bs_read_int(bs, 1);
			}
		}
	}

	if ( !(state->reduced_still_picture_header || disable_cdf_update) )
		/*disable_frame_end_update_cdf = */gf_bs_read_int(bs, 1);

	if (primary_ref_frame == AV1_PRIMARY_REF_NONE) {
		//init_non_coeff_cdfs();
		//setup_past_independence();
	} else {
		//load_cdfs(ref_frame_idx[primary_ref_frame]);
		//load_previous();
	}

	av1_parse_tile_info(bs, state);

	//incomplete parsing
static void av1_parse_tile_group(GF_BitStream *bs, AV1State *state, u64 bs_end_of_obu_position)
	u32 TileNum, tg_start, tg_end;
		/*state->frame_state.tg[0].start_idx = 0;
		state->frame_state.tg[0].end_idx = numTiles - 1;*/
		/*state->frame_state.tg[state->frame_state.tg_idx].start_idx*/ tg_start = gf_bs_read_int(bs, tileBits);
		/*state->frame_state.tg[state->frame_state.tg_idx].end_idx*/ tg_end = gf_bs_read_int(bs, tileBits);
	/*state->frame_state.tg_idx++;*/

	gf_bs_align(bs);
	for (TileNum = tg_start; TileNum <= tg_end; TileNum++) {
		u32 tileRow = TileNum / state->tileCols;
		u32 tileCol = TileNum % state->tileCols;
		Bool lastTile = TileNum == tg_end;
		u64 pos = gf_bs_get_position(bs);
		if (lastTile) {
			state->frame_state.tg[state->frame_state.tile_idx].bs_start = pos;
			state->frame_state.tg[state->frame_state.tile_idx].size = (u32)(bs_end_of_obu_position - pos);
		} else {
			u64 tile_size_minus_1 = aom_av1_le(bs, state->tile_size_bytes);
			pos = gf_bs_get_position(bs);
			state->frame_state.tg[state->frame_state.tile_idx].bs_start = pos;
			state->frame_state.tg[state->frame_state.tile_idx].size = (u32)(tile_size_minus_1 + 1/* + state->tile_size_bytes*/);
		}
		gf_bs_seek(bs, pos + state->frame_state.tg[state->frame_state.tile_idx].size);
		state->frame_state.tile_idx++;
	}
		const ObuMetadataType metadata_type = (u32)read_leb128(bs, NULL); we should check for 16 bits limit (AV1MetadataSampleGroupEntry) for ISOBMFF bindings, see https ://github.com/AOMediaCodec/av1-isobmff/pull/86#issuecomment-416659538
		av1_parse_tile_group(bs, state, pos + *obu_size);
		break;","	if (gf_bs_read_int(bs, 3) /*equal_picture_interval*/) {
	u8 operating_points_cnt_minus_1, frame_width_bits_minus_1, frame_height_bits_minus_1, buffer_delay_length_minus_1 = 0;
	Bool timing_info_present_flag, decoder_model_info_present_flag, initial_display_delay_present_flag;
		decoder_model_info_present_flag = GF_FALSE;
			decoder_model_info_present_flag = gf_bs_read_int(bs, 1);
			if (decoder_model_info_present_flag) {
			decoder_model_info_present_flag = 0;
			if (decoder_model_info_present_flag) {
	frame_width_bits_minus_1 = gf_bs_read_int(bs, 4);
	frame_height_bits_minus_1 = gf_bs_read_int(bs, 4);
	state->width = gf_bs_read_int(bs, frame_width_bits_minus_1 + 1) + 1;
	state->height = gf_bs_read_int(bs, frame_height_bits_minus_1 + 1) + 1;
		/*delta_frame_id_length_minus_2 =*/ gf_bs_read_int(bs, 4);
		/*additional_frame_id_length_minus_1 =*/ gf_bs_read_int(bs, 3);
		enable_order_hint = 0;
		enable_ref_frame_mvs = 0;
		seq_force_screen_content_tools = SELECT_SCREEN_CONTENT_TOOLS;
		seq_force_integer_mv = SELECT_INTEGER_MV;
		OrderHintBits = 0;*/
		Bool enable_order_hint, seq_choose_screen_content_tools;
		u8 seq_force_screen_content_tools/*, seq_force_integer_mv*/;
		enable_order_hint = gf_bs_read_int(bs, 1);
		if (enable_order_hint) {
			/*enable_ref_frame_mvs =*/ gf_bs_read_int(bs, 1);
		seq_force_screen_content_tools = 0;
			seq_force_screen_content_tools = 2/*SELECT_SCREEN_CONTENT_TOOLS*/;
			seq_force_screen_content_tools = gf_bs_read_int(bs, 1);
		/*seq_force_integer_mv = 0;*/
		if (seq_force_screen_content_tools > 0) {
				/*seq_force_integer_mv = 2*//*SELECT_INTEGER_MV*/;
				/*seq_force_integer_mv = */gf_bs_read_int(bs, 1);
			/*seq_force_integer_mv = 2*//*SELECT_INTEGER_MV*/;
		if (enable_order_hint) {
			/*u8 order_hint_bits_minus_1 = */gf_bs_read_int(bs, 3);
			/*OrderHintBits = order_hint_bits_minus_1 + 1*/;
			/*OrderHintBits = 0*/;
	/*enable_superres = */gf_bs_read_int(bs, 1);
	KEY_FRAME = 0,
	INTER_FRAME = 1,
	INTRA_ONLY_FRAME = 2,
	SWITCH_FRAME = 3,
static void tile_info(GF_BitStream *bs, AV1State *state)
		minLog2tileRows = MAX(minLog2Tiles - state->tileColsLog2, 0);
			u32 maxWidth = MIN(sbCols - startSb, maxTileWidthSb);
			u32 maxHeight = MIN(sbRows - startSb, maxTileHeightSb);
		/*context_update_tile_idcontext_update_tile_id = */gf_bs_read_int(bs, state->tileRowsLog2 + state->tileColsLog2);
		/*tile_size_bytes_minus_1tile_size_bytes_minus_1 = */gf_bs_read_int(bs, 2);
		//idLen = (additional_frame_id_length_minus_1 + delta_frame_id_length_minus_2 + 3);
	//allFrames = (1 << NUM_REF_FRAMES) - 1;
		AV1FrameType frame_type;
		Bool show_frame = GF_FALSE;
			/*frame_to_show_map_idx	f(3)
			if (decoder_model_info_present_flag && !equal_picture_interval) {
				temporal_point_info()
			refresh_frame_flags = 0
				display_frame_id	f(idLen)
			if (frame_type == KEY_FRAME) {
				refresh_frame_flags = allFrames
		show_frame = gf_bs_read_int(bs, 1);
		frame_state->key_frame = frame_state->seen_seq_header && show_frame && frame_type == KEY_FRAME && frame_state->seen_frame_header;
static void av1_parse_tile_group(GF_BitStream *bs, AV1State *state)
		state->frame_state.tg[0].start = 0;
		state->frame_state.tg[0].end = numTiles - 1;
		state->frame_state.tg[state->frame_state.tg_idx].start = gf_bs_read_int(bs, tileBits);
		state->frame_state.tg[state->frame_state.tg_idx].end = gf_bs_read_int(bs, tileBits);
	state->frame_state.tg_idx++;
	//incomplete parsing
		const ObuMetadataType metadata_type = (u32)read_leb128(bs, NULL); we should check for 16 bits limit for ISOBMFF bindings, see https ://github.com/AOMediaCodec/av1-isobmff/pull/86#issuecomment-416659538
		av1_parse_tile_group(bs, state);",d7c2bb5cc3c67566f506f51cbefbf66f8169ea85,CVE-2019-20160,d7c2bb5cc3c67566f506f51cbefbf66f8169ea85,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,80,COMPLETED,"VAR->VAR = VAR(VAR, 3); VAR (VAR->VAR) { VAR VAR, VAR = 0; VAR VAR, VAR; VAR->VAR = VAR(VAR, 1); VAR (VAR->VAR) { VAR->VAR = VAR; VAR (VAR->VAR) { VAR->VAR = VAR(VAR, 4); VAR->VAR = VAR(VAR, 4); VAR->VAR = VAR(VAR, VAR->VAR + 1) + 1; VAR->VAR = VAR(VAR, VAR->VAR + 1) + 1; VAR->VAR = VAR(VAR, 4); VAR->VAR = VAR(VAR, 3); VAR = 0;*/ VAR->VAR = VAR; VAR->VAR = 0; VAR->VAR = 2; VAR->VAR = 2; VAR VAR; VAR->VAR = VAR(VAR, 1); VAR (VAR->VAR) { VAR->VAR = VAR(VAR, 1); VAR->VAR = 0; VAR->VAR = 2; VAR->VAR = VAR(VAR, 1); VAR->VAR = 0; VAR (VAR->VAR > 0) { VAR->VAR = 2; VAR->VAR = VAR(VAR, 1); VAR->VAR = 2; VAR (VAR->VAR) { VAR VAR = VAR(VAR, 3); VAR->VAR = VAR + 1; VAR->VAR = 0; VAR->VAR = VAR(VAR, 1); VAR = 0, VAR = 1, VAR = 2, VAR = 3,        VAR VAR VAR(VAR *VAR, VAR VAR) { VAR VAR = 0; VAR VAR = 0; VAR (VAR = 0; VAR < VAR; VAR++) { VAR VAR = VAR(VAR, 8); VAR += (VAR << (VAR * 8)); } VAR VAR; } VAR VAR VAR(VAR *VAR, VAR *VAR) VAR = VAR((VAR)(VAR - VAR->VAR), 0); VAR VAR = VAR((VAR)(VAR - VAR), VAR); VAR VAR = VAR((VAR)(VAR - VAR), VAR); VAR(VAR, VAR->VAR + VAR->VAR); VAR->VAR = VAR(VAR, 2) + 1; } } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR; VAR VAR; VAR (VAR->VAR) { VAR = VAR(VAR, 1); } VAR { VAR = VAR; } VAR (VAR) { VAR VAR = VAR(VAR, VAR); VAR = VAR + VAR; } VAR { VAR = VAR; } VAR->VAR = VAR->VAR; VAR->VAR = (VAR->VAR * VAR + (VAR / 2)) / VAR; } VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) { VAR (VAR) { VAR VAR, VAR; VAR VAR = VAR->VAR + 1; VAR = VAR(VAR, VAR); VAR = VAR->VAR + 1; VAR = VAR(VAR, VAR); VAR->VAR = VAR + 1; VAR->VAR = VAR + 1; } VAR(VAR, VAR);  } VAR VAR VAR(VAR *VAR) { VAR VAR = VAR(VAR, 1); VAR (VAR == VAR) {  VAR(VAR, 16);  VAR(VAR, 16);   } VAR {   } } VAR VAR VAR(VAR *VAR) { VAR VAR = VAR(VAR, 1); VAR (!VAR) {  VAR(VAR, 2); } } VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) { VAR VAR = VAR; VAR VAR = 0; VAR (VAR = 0; VAR < VAR; VAR++) { VAR = VAR(VAR, 1); VAR (VAR == 1) {  VAR = VAR[VAR[VAR]]; VAR = VAR; VAR = VAR[VAR[VAR]]; VAR = VAR[VAR[VAR]]; VAR = VAR[VAR[VAR]];  VAR; } } VAR (VAR == 0) { VAR(VAR, VAR, VAR); VAR(VAR); } VAR { VAR(VAR, VAR);  VAR VAR = VAR, VAR = VAR, VAR = VAR; VAR VAR = VAR, VAR = VAR, VAR = VAR; VAR VAR = VAR, VAR = VAR; VAR VAR; VAR VAR = 0; VAR VAR; VAR = (VAR->VAR + VAR->VAR + 3); VAR = VAR; VAR = VAR; VAR->VAR = VAR; /*VAR = VAR(VAR, 3); VAR (VAR->VAR && !VAR->VAR) { VAR(); VAR = 0; VAR = VAR(VAR, VAR); VAR (VAR == VAR) { VAR = VAR; VAR = (VAR == VAR || VAR == VAR); VAR->VAR = VAR(VAR, 1); VAR->VAR = VAR->VAR && VAR->VAR && VAR == VAR && VAR->VAR; VAR (VAR->VAR && VAR->VAR && !VAR->VAR) { VAR(VAR, VAR, (""[VAR] VAR() VAR VAR (1)\VAR"")); VAR(0); VAR; } VAR (!VAR->VAR) { VAR(VAR, 1); } VAR (VAR == VAR || (VAR == VAR && VAR->VAR)) VAR = VAR; VAR VAR = VAR(VAR, 1); } VAR = VAR(VAR, 1); VAR (VAR->VAR == 2) { VAR = VAR(VAR, 1); } VAR { VAR = VAR->VAR; } VAR (VAR) { VAR (VAR->VAR == 2) { VAR = VAR(VAR, 1); } VAR { VAR = VAR->VAR; } } VAR { VAR = 0; } VAR (VAR) { VAR = 1; } VAR (VAR->VAR) { VAR(VAR, VAR); } VAR (VAR == VAR) VAR = VAR; VAR VAR (VAR->VAR) VAR = VAR; VAR VAR = VAR(VAR, 1); VAR(VAR, VAR->VAR); VAR (VAR || VAR) { VAR = VAR; } VAR { VAR = VAR(VAR, 3); } VAR (VAR->VAR) { VAR(VAR, VAR, (""[VAR] VAR VAR VAR VAR VAR\VAR"")); VAR(0); VAR;  VAR = VAR(VAR, 1); VAR (VAR) { VAR (VAR = 0; VAR <= VAR; VAR++) { VAR (VAR[VAR]) { VAR = VAR[VAR]; VAR = (VAR >> VAR) & 1; VAR = (VAR >> (VAR + 8)) & 1; VAR (VAR == 0 || (VAR && VAR)) { VAR = VAR + 1; VAR[VAR] = VAR(VAR, VAR); } } } }  } VAR (VAR == VAR || (VAR == VAR && VAR->VAR)) { VAR = VAR; } VAR { VAR = VAR(VAR, 8); } VAR (!VAR || VAR != VAR) { VAR (VAR && VAR->VAR) { VAR VAR = 0; VAR (VAR = 0; VAR < VAR; VAR++) { VAR(VAR, VAR->VAR); } } VAR (VAR == VAR) { VAR(VAR, VAR, VAR); VAR(VAR); VAR (VAR && VAR->VAR == VAR->VAR) { VAR(VAR, 1); } } VAR { VAR (VAR == VAR) { VAR(VAR, VAR, VAR); VAR(VAR); VAR (VAR && VAR->VAR == VAR->VAR) { VAR(VAR, 1); } } VAR { VAR VAR = 0; VAR VAR = VAR; VAR (VAR->VAR) { VAR = VAR(VAR, 1); VAR (VAR) {  VAR(VAR, 3);  VAR(VAR, 3);  } } VAR (VAR = 0; VAR < VAR; VAR++) { VAR (!VAR)  VAR(VAR, 3); VAR (VAR->VAR) { VAR VAR = VAR->VAR + 2;  VAR(VAR, VAR);   } } VAR (VAR && !VAR) { VAR(VAR, VAR, VAR); } VAR { VAR(VAR, VAR, VAR); VAR(VAR); } VAR (!VAR) { VAR(VAR, 1); } VAR(VAR);  VAR(VAR, 1); VAR (! (VAR || !VAR->VAR) ) { VAR = VAR(VAR, 1); } } } VAR ( !(VAR->VAR || VAR) ) VAR(VAR, 1); VAR (VAR == VAR) {   } VAR {   } VAR(VAR, VAR);  VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR VAR, VAR, VAR; /*VAR->VAR.VAR[0].VAR = 0; VAR->VAR.VAR[0].VAR = VAR - 1;*/  VAR = VAR(VAR, VAR);  VAR = VAR(VAR, VAR);  VAR(VAR); VAR (VAR = VAR; VAR <= VAR; VAR++) { VAR VAR = VAR / VAR->VAR; VAR VAR = VAR % VAR->VAR; VAR VAR = VAR == VAR; VAR VAR = VAR(VAR); VAR (VAR) { VAR->VAR.VAR[VAR->VAR.VAR].VAR = VAR; VAR->VAR.VAR[VAR->VAR.VAR].VAR = (VAR)(VAR - VAR); } VAR { VAR VAR = VAR(VAR, VAR->VAR); VAR = VAR(VAR); VAR->VAR.VAR[VAR->VAR.VAR].VAR = VAR; VAR->VAR.VAR[VAR->VAR.VAR].VAR = (VAR)(VAR + 1); } VAR(VAR, VAR + VAR->VAR.VAR[VAR->VAR.VAR].VAR); VAR->VAR.VAR++; } VAR VAR VAR = (VAR)VAR(VAR, VAR); VAR VAR VAR VAR 16 VAR VAR (VAR) VAR VAR VAR, VAR VAR : VAR(VAR, VAR, VAR + *VAR); VAR; VAR (VAR(VAR, 3) ) { VAR VAR, VAR, VAR, VAR = 0; VAR VAR, VAR, VAR; VAR = VAR; VAR = VAR(VAR, 1); VAR (VAR) { VAR = 0; VAR (VAR) { VAR = VAR(VAR, 4); VAR = VAR(VAR, 4); VAR->VAR = VAR(VAR, VAR + 1) + 1; VAR->VAR = VAR(VAR, VAR + 1) + 1;  VAR(VAR, 4);  VAR(VAR, 3); VAR = 0; VAR = 0; VAR = VAR; VAR = VAR; VAR = 0;*/ VAR VAR, VAR; VAR VAR; VAR = VAR(VAR, 1); VAR (VAR) {  VAR(VAR, 1); VAR = 0; VAR = 2; VAR = VAR(VAR, 1);  VAR (VAR > 0) { /*VAR = 2* VAR(VAR, 1); /*VAR = 2* VAR (VAR) { VAR(VAR, 3); ; ; VAR(VAR, 1); VAR = 0, VAR = 1, VAR = 2, VAR = 3, VAR VAR VAR(VAR *VAR, VAR *VAR) VAR = VAR(VAR - VAR->VAR, 0); VAR VAR = VAR(VAR - VAR, VAR); VAR VAR = VAR(VAR - VAR, VAR); VAR(VAR, VAR->VAR + VAR->VAR); VAR(VAR, 2);   VAR VAR; VAR VAR = VAR; /*VAR VAR(3) VAR (VAR && !VAR) { VAR() VAR = 0 VAR VAR(VAR) VAR (VAR == VAR) { VAR = VAR VAR = VAR(VAR, 1); VAR->VAR = VAR->VAR && VAR && VAR == VAR && VAR->VAR; VAR VAR VAR(VAR *VAR, VAR *VAR) VAR->VAR.VAR[0].VAR = 0; VAR->VAR.VAR[0].VAR = VAR - 1; VAR->VAR.VAR[VAR->VAR.VAR].VAR = VAR(VAR, VAR); VAR->VAR.VAR[VAR->VAR.VAR].VAR = VAR(VAR, VAR); VAR->VAR.VAR++;  VAR VAR VAR = (VAR)VAR(VAR, VAR); VAR VAR VAR VAR 16 VAR VAR VAR VAR VAR, VAR VAR : VAR(VAR, VAR);",1
gpac_e79b0cf7e72404750630bc01340e999f3940dbc4,src/isomedia/isom_read.c,"		if ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && UUID && !memcmp(map->uuid, UUID, 16)) goto found;","		if ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;",e79b0cf7e72404750630bc01340e999f3940dbc4,CVE-2023-46001,e79b0cf7e72404750630bc01340e999f3940dbc4,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ((VAR->VAR == VAR) && VAR && !VAR(VAR->VAR, VAR, 16)) VAR VAR; VAR ((VAR->VAR == VAR) && !VAR(VAR->VAR, VAR, 16)) VAR VAR;",1
libarchive_f0b1dbbc325a2d922015eee402b72edd422cb9ea,libarchive/archive_read_support_filter_compress.c,"	/* Shortest valid compress file is 3 bytes. */
	buffer = __archive_read_filter_ahead(filter, 3, &avail);
	/* First two bytes are the magic value */
	/* Third byte holds compression parameters. */
	if (buffer[2] & 0x20) /* Reserved bit, must be zero. */
		return (0);
	if (buffer[2] & 0x40) /* Reserved bit, must be zero. */
		return (0);
	bits_checked += 18;
	/* Get compression parameters. */
	if ((code & 0x1f) > 16) {
		archive_set_error(&self->archive->archive, -1,
		    ""Invalid compressed data"");
		return (ARCHIVE_FATAL);
	}","	buffer = __archive_read_filter_ahead(filter, 2, &avail);
	bits_checked += 16;

	/*
	 * TODO: Verify more.
	 */",f0b1dbbc325a2d922015eee402b72edd422cb9ea,CVE-2015-8932,f0b1dbbc325a2d922015eee402b72edd422cb9ea,https://github.com/libarchive/libarchive,NVD_GIT_REPOBASED,84,COMPLETED," VAR = VAR(VAR, 3, &VAR);   VAR (VAR[2] & 0x20)  VAR (0); VAR (VAR[2] & 0x40)  VAR (0); VAR += 18;  VAR ((VAR & 0x1f) > 16) { VAR(&VAR->VAR->VAR, -1, ""VAR VAR VAR""); VAR (VAR); } VAR = VAR(VAR, 2, &VAR); VAR += 16; /* * VAR: VAR VAR. */",1
linux_1202cdd665315c525b5237e96e0bedc76d7e754f,include/net/dn_fib.h,,"/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _NET_DN_FIB_H
#define _NET_DN_FIB_H

#include <linux/netlink.h>
#include <linux/refcount.h>
#include <linux/rtnetlink.h>
#include <net/fib_rules.h>

extern const struct nla_policy rtm_dn_policy[];

struct dn_fib_res {
	struct fib_rule *r;
	struct dn_fib_info *fi;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
};

struct dn_fib_nh {
	struct net_device	*nh_dev;
	unsigned int		nh_flags;
	unsigned char		nh_scope;
	int			nh_weight;
	int			nh_power;
	int			nh_oif;
	__le16			nh_gw;
};

struct dn_fib_info {
	struct dn_fib_info	*fib_next;
	struct dn_fib_info	*fib_prev;
	refcount_t		fib_treeref;
	refcount_t		fib_clntref;
	int			fib_dead;
	unsigned int		fib_flags;
	int			fib_protocol;
	__le16			fib_prefsrc;
	__u32			fib_priority;
	__u32			fib_metrics[RTAX_MAX];
	int			fib_nhs;
	int			fib_power;
	struct dn_fib_nh	fib_nh[0];
#define dn_fib_dev		fib_nh[0].nh_dev
};


#define DN_FIB_RES_RESET(res)	((res).nh_sel = 0)
#define DN_FIB_RES_NH(res)	((res).fi->fib_nh[(res).nh_sel])

#define DN_FIB_RES_PREFSRC(res)	((res).fi->fib_prefsrc ? : __dn_fib_res_prefsrc(&res))
#define DN_FIB_RES_GW(res)	(DN_FIB_RES_NH(res).nh_gw)
#define DN_FIB_RES_DEV(res)	(DN_FIB_RES_NH(res).nh_dev)
#define DN_FIB_RES_OIF(res)	(DN_FIB_RES_NH(res).nh_oif)

typedef struct {
	__le16	datum;
} dn_fib_key_t;

typedef struct {
	__le16	datum;
} dn_fib_hash_t;

typedef struct {
	__u16	datum;
} dn_fib_idx_t;

struct dn_fib_node {
	struct dn_fib_node *fn_next;
	struct dn_fib_info *fn_info;
#define DN_FIB_INFO(f) ((f)->fn_info)
	dn_fib_key_t	fn_key;
	u8		fn_type;
	u8		fn_scope;
	u8		fn_state;
};


struct dn_fib_table {
	struct hlist_node hlist;
	u32 n;

	int (*insert)(struct dn_fib_table *t, struct rtmsg *r,
			struct nlattr *attrs[], struct nlmsghdr *n,
			struct netlink_skb_parms *req);
	int (*delete)(struct dn_fib_table *t, struct rtmsg *r,
			struct nlattr *attrs[], struct nlmsghdr *n,
			struct netlink_skb_parms *req);
	int (*lookup)(struct dn_fib_table *t, const struct flowidn *fld,
			struct dn_fib_res *res);
	int (*flush)(struct dn_fib_table *t);
	int (*dump)(struct dn_fib_table *t, struct sk_buff *skb, struct netlink_callback *cb);

	unsigned char data[];
};

#ifdef CONFIG_DECNET_ROUTER
/*
 * dn_fib.c
 */
void dn_fib_init(void);
void dn_fib_cleanup(void);

int dn_fib_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
struct dn_fib_info *dn_fib_create_info(const struct rtmsg *r,
				       struct nlattr *attrs[],
				       const struct nlmsghdr *nlh, int *errp);
int dn_fib_semantic_match(int type, struct dn_fib_info *fi,
			  const struct flowidn *fld, struct dn_fib_res *res);
void dn_fib_release_info(struct dn_fib_info *fi);
void dn_fib_flush(void);
void dn_fib_select_multipath(const struct flowidn *fld, struct dn_fib_res *res);

/*
 * dn_tables.c
 */
struct dn_fib_table *dn_fib_get_table(u32 n, int creat);
struct dn_fib_table *dn_fib_empty_table(void);
void dn_fib_table_init(void);
void dn_fib_table_cleanup(void);

/*
 * dn_rules.c
 */
void dn_fib_rules_init(void);
void dn_fib_rules_cleanup(void);
unsigned int dnet_addr_type(__le16 addr);
int dn_fib_lookup(struct flowidn *fld, struct dn_fib_res *res);

int dn_fib_dump(struct sk_buff *skb, struct netlink_callback *cb);

void dn_fib_free_info(struct dn_fib_info *fi);

static inline void dn_fib_info_put(struct dn_fib_info *fi)
{
	if (refcount_dec_and_test(&fi->fib_clntref))
		dn_fib_free_info(fi);
}

static inline void dn_fib_res_put(struct dn_fib_res *res)
{
	if (res->fi)
		dn_fib_info_put(res->fi);
	if (res->r)
		fib_rule_put(res->r);
}

#else /* Endnode */

#define dn_fib_init()  do { } while(0)
#define dn_fib_cleanup() do { } while(0)

#define dn_fib_lookup(fl, res) (-ESRCH)
#define dn_fib_info_put(fi) do { } while(0)
#define dn_fib_select_multipath(fl, res) do { } while(0)
#define dn_fib_rules_policy(saddr,res,flags) (0)
#define dn_fib_res_put(res) do { } while(0)

#endif /* CONFIG_DECNET_ROUTER */

static inline __le16 dnet_make_mask(int n)
{
	if (n)
		return cpu_to_le16(~((1 << (16 - n)) - 1));
	return cpu_to_le16(0);
}

#endif /* _NET_DN_FIB_H */",1202cdd665315c525b5237e96e0bedc76d7e754f,CVE-2023-3338,1202cdd665315c525b5237e96e0bedc76d7e754f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,"        VAR VAR VAR VAR VAR[]; VAR VAR { VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; }; VAR VAR { VAR VAR *VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR { VAR VAR *VAR; VAR VAR *VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR[VAR]; VAR VAR; VAR VAR; VAR VAR VAR[0];  };       VAR VAR { VAR VAR; } VAR; VAR VAR { VAR VAR; } VAR; VAR VAR { VAR VAR; } VAR; VAR VAR { VAR VAR *VAR; VAR VAR *VAR;  VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR { VAR VAR VAR; VAR VAR; VAR (*VAR)(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR[], VAR VAR *VAR, VAR VAR *VAR); VAR (*VAR)(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR[], VAR VAR *VAR, VAR VAR *VAR); VAR (*VAR)(VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR *VAR); VAR (*VAR)(VAR VAR *VAR); VAR (*VAR)(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR); VAR VAR VAR[]; };  /* * VAR.VAR */ VAR VAR(VAR); VAR VAR(VAR); VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR VAR); VAR VAR *VAR(VAR VAR VAR *VAR, VAR VAR *VAR[], VAR VAR VAR *VAR, VAR *VAR); VAR VAR(VAR VAR, VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR *VAR); VAR VAR(VAR VAR *VAR); VAR VAR(VAR); VAR VAR(VAR VAR VAR *VAR, VAR VAR *VAR); /* * VAR.VAR */ VAR VAR *VAR(VAR VAR, VAR VAR); VAR VAR *VAR(VAR); VAR VAR(VAR); VAR VAR(VAR); /* * VAR.VAR */ VAR VAR(VAR); VAR VAR(VAR); VAR VAR VAR(VAR VAR); VAR VAR(VAR VAR *VAR, VAR VAR *VAR); VAR VAR(VAR VAR *VAR, VAR VAR *VAR); VAR VAR(VAR VAR *VAR); VAR VAR VAR VAR(VAR VAR *VAR) { VAR (VAR(&VAR->VAR)) VAR(VAR); } VAR VAR VAR VAR(VAR VAR *VAR) { VAR (VAR->VAR) VAR(VAR->VAR); VAR (VAR->VAR) VAR(VAR->VAR); }          VAR VAR VAR VAR(VAR VAR) { VAR (VAR) VAR VAR(~((1 << (16 - VAR)) - 1)); VAR VAR(0); } ",1
linux_1202cdd665315c525b5237e96e0bedc76d7e754f,include/uapi/linux/dn.h,,"/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
#ifndef _LINUX_DN_H
#define _LINUX_DN_H

#include <linux/ioctl.h>
#include <linux/types.h>
#include <linux/if_ether.h>

/*

	DECnet Data Structures and Constants

*/

/*
 * DNPROTO_NSP can't be the same as SOL_SOCKET,
 * so increment each by one (compared to ULTRIX)
 */
#define DNPROTO_NSP     2                       /* NSP protocol number       */
#define DNPROTO_ROU     3                       /* Routing protocol number   */
#define DNPROTO_NML     4                       /* Net mgt protocol number   */
#define DNPROTO_EVL     5                       /* Evl protocol number (usr) */
#define DNPROTO_EVR     6                       /* Evl protocol number (evl) */
#define DNPROTO_NSPT    7                       /* NSP trace protocol number */


#define DN_ADDL		2
#define DN_MAXADDL	2 /* ULTRIX headers have 20 here, but pathworks has 2 */
#define DN_MAXOPTL	16
#define DN_MAXOBJL	16
#define DN_MAXACCL	40
#define DN_MAXALIASL	128
#define DN_MAXNODEL	256
#define DNBUFSIZE	65023

/*
 * SET/GET Socket options  - must match the DSO_ numbers below
 */
#define SO_CONDATA      1
#define SO_CONACCESS    2
#define SO_PROXYUSR     3
#define SO_LINKINFO     7

#define DSO_CONDATA     1        /* Set/Get connect data                */
#define DSO_DISDATA     10       /* Set/Get disconnect data             */
#define DSO_CONACCESS   2        /* Set/Get connect access data         */
#define DSO_ACCEPTMODE  4        /* Set/Get accept mode                 */
#define DSO_CONACCEPT   5        /* Accept deferred connection          */
#define DSO_CONREJECT   6        /* Reject deferred connection          */
#define DSO_LINKINFO    7        /* Set/Get link information            */
#define DSO_STREAM      8        /* Set socket type to stream           */
#define DSO_SEQPACKET   9        /* Set socket type to sequenced packet */
#define DSO_MAXWINDOW   11       /* Maximum window size allowed         */
#define DSO_NODELAY	12       /* Turn off nagle                      */
#define DSO_CORK        13       /* Wait for more data!                 */
#define DSO_SERVICES	14       /* NSP Services field                  */
#define DSO_INFO	15       /* NSP Info field                      */
#define DSO_MAX         15       /* Maximum option number               */


/* LINK States */
#define LL_INACTIVE	0
#define LL_CONNECTING	1
#define LL_RUNNING	2
#define LL_DISCONNECTING 3

#define ACC_IMMED 0
#define ACC_DEFER 1

#define SDF_WILD        1                  /* Wild card object          */
#define SDF_PROXY       2                  /* Addr eligible for proxy   */
#define SDF_UICPROXY    4                  /* Use uic-based proxy       */

/* Structures */


struct dn_naddr {
	__le16		a_len;
	__u8 a_addr[DN_MAXADDL]; /* Two bytes little endian */
};

struct sockaddr_dn {
	__u16		sdn_family;
	__u8		sdn_flags;
	__u8		sdn_objnum;
	__le16		sdn_objnamel;
	__u8		sdn_objname[DN_MAXOBJL];
	struct   dn_naddr	sdn_add;
};
#define sdn_nodeaddrl   sdn_add.a_len   /* Node address length  */
#define sdn_nodeaddr    sdn_add.a_addr  /* Node address         */



/*
 * DECnet set/get DSO_CONDATA, DSO_DISDATA (optional data) structure
 */
struct optdata_dn {
        __le16  opt_status;     /* Extended status return */
#define opt_sts opt_status
        __le16  opt_optl;       /* Length of user data    */
        __u8   opt_data[16];   /* User data              */
};

struct accessdata_dn {
	__u8		acc_accl;
	__u8		acc_acc[DN_MAXACCL];
	__u8 		acc_passl;
	__u8		acc_pass[DN_MAXACCL];
	__u8 		acc_userl;
	__u8		acc_user[DN_MAXACCL];
};

/*
 * DECnet logical link information structure
 */
struct linkinfo_dn {
        __u16  idn_segsize;    /* Segment size for link */
        __u8   idn_linkstate;  /* Logical link state    */
};

/*
 * Ethernet address format (for DECnet)
 */
union etheraddress {
        __u8 dne_addr[ETH_ALEN];      /* Full ethernet address */
  struct {
                __u8 dne_hiord[4];    /* DECnet HIORD prefix   */
                __u8 dne_nodeaddr[2]; /* DECnet node address   */
  } dne_remote;
};


/*
 * DECnet physical socket address format
 */
struct dn_addr {
        __le16 dna_family;      /* AF_DECnet               */
        union etheraddress dna_netaddr; /* DECnet ethernet address */
};

#define DECNET_IOCTL_BASE 0x89 /* PROTOPRIVATE range */

#define SIOCSNETADDR  _IOW(DECNET_IOCTL_BASE, 0xe0, struct dn_naddr)
#define SIOCGNETADDR  _IOR(DECNET_IOCTL_BASE, 0xe1, struct dn_naddr)
#define OSIOCSNETADDR _IOW(DECNET_IOCTL_BASE, 0xe0, int)
#define OSIOCGNETADDR _IOR(DECNET_IOCTL_BASE, 0xe1, int)

#endif /* _LINUX_DN_H */",1202cdd665315c525b5237e96e0bedc76d7e754f,CVE-2023-3338,1202cdd665315c525b5237e96e0bedc76d7e754f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,"       /* VAR VAR VAR VAR VAR */ /* * VAR VAR'VAR VAR VAR VAR VAR VAR, * VAR VAR VAR VAR VAR (VAR VAR VAR) */               /* * VAR/VAR VAR VAR - VAR VAR VAR VAR VAR VAR */                               VAR VAR { VAR VAR; VAR VAR[VAR];  }; VAR VAR { VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR[VAR]; VAR VAR VAR; };   /* * VAR VAR/VAR VAR, VAR (VAR VAR) VAR */ VAR VAR { VAR VAR;   VAR VAR;  VAR VAR[16];  }; VAR VAR { VAR VAR; VAR VAR[VAR]; VAR VAR; VAR VAR[VAR]; VAR VAR; VAR VAR[VAR]; }; /* * VAR VAR VAR VAR VAR */ VAR VAR { VAR VAR;  VAR VAR;  }; /* * VAR VAR VAR (VAR VAR) */ VAR VAR { VAR VAR[VAR];  VAR { VAR VAR[4];  VAR VAR[2];  } VAR; }; /* * VAR VAR VAR VAR VAR */ VAR VAR { VAR VAR;  VAR VAR VAR;  };      ",1
linux_1202cdd665315c525b5237e96e0bedc76d7e754f,net/decnet/af_decnet.c,,"// SPDX-License-Identifier: GPL-2.0-or-later

/*
 * DECnet       An implementation of the DECnet protocol suite for the LINUX
 *              operating system.  DECnet is implemented using the  BSD Socket
 *              interface as the means of communication with the user level.
 *
 *              DECnet Socket Layer Interface
 *
 * Authors:     Eduardo Marcelo Serrat <emserrat@geocities.com>
 *              Patrick Caulfield <patrick@pandh.demon.co.uk>
 *
 * Changes:
 *        Steve Whitehouse: Copied from Eduardo Serrat and Patrick Caulfield's
 *                          version of the code. Original copyright preserved
 *                          below.
 *        Steve Whitehouse: Some bug fixes, cleaning up some code to make it
 *                          compatible with my routing layer.
 *        Steve Whitehouse: Merging changes from Eduardo Serrat and Patrick
 *                          Caulfield.
 *        Steve Whitehouse: Further bug fixes, checking module code still works
 *                          with new routing layer.
 *        Steve Whitehouse: Additional set/get_sockopt() calls.
 *        Steve Whitehouse: Fixed TIOCINQ ioctl to be same as Eduardo's new
 *                          code.
 *        Steve Whitehouse: recvmsg() changed to try and behave in a POSIX like
 *                          way. Didn't manage it entirely, but its better.
 *        Steve Whitehouse: ditto for sendmsg().
 *        Steve Whitehouse: A selection of bug fixes to various things.
 *        Steve Whitehouse: Added TIOCOUTQ ioctl.
 *        Steve Whitehouse: Fixes to username2sockaddr & sockaddr2username.
 *        Steve Whitehouse: Fixes to connect() error returns.
 *       Patrick Caulfield: Fixes to delayed acceptance logic.
 *         David S. Miller: New socket locking
 *        Steve Whitehouse: Socket list hashing/locking
 *         Arnaldo C. Melo: use capable, not suser
 *        Steve Whitehouse: Removed unused code. Fix to use sk->allocation
 *                          when required.
 *       Patrick Caulfield: /proc/net/decnet now has object name/number
 *        Steve Whitehouse: Fixed local port allocation, hashed sk list
 *          Matthew Wilcox: Fixes for dn_ioctl()
 *        Steve Whitehouse: New connect/accept logic to allow timeouts and
 *                          prepare for sendpage etc.
 */


/******************************************************************************
    (c) 1995-1998 E.M. Serrat		emserrat@geocities.com


HISTORY:

Version           Kernel     Date       Author/Comments
Version 0.0.1     2.0.30    01-dic-97	Eduardo Marcelo Serrat
					(emserrat@geocities.com)

					First Development of DECnet Socket La-
					yer for Linux. Only supports outgoing
					connections.

Version 0.0.2	  2.1.105   20-jun-98   Patrick J. Caulfield
					(patrick@pandh.demon.co.uk)

					Port to new kernel development version.

Version 0.0.3     2.1.106   25-jun-98   Eduardo Marcelo Serrat
					(emserrat@geocities.com)
					_
					Added support for incoming connections
					so we can start developing server apps
					on Linux.
					-
					Module Support
Version 0.0.4     2.1.109   21-jul-98   Eduardo Marcelo Serrat
				       (emserrat@geocities.com)
				       _
					Added support for X11R6.4. Now we can
					use DECnet transport for X on Linux!!!
				       -
Version 0.0.5    2.1.110   01-aug-98   Eduardo Marcelo Serrat
				       (emserrat@geocities.com)
				       Removed bugs on flow control
				       Removed bugs on incoming accessdata
				       order
				       -
Version 0.0.6    2.1.110   07-aug-98   Eduardo Marcelo Serrat
				       dn_recvmsg fixes

					Patrick J. Caulfield
				       dn_bind fixes
*******************************************************************************/

#include <linux/module.h>
#include <linux/errno.h>
#include <linux/types.h>
#include <linux/slab.h>
#include <linux/socket.h>
#include <linux/in.h>
#include <linux/kernel.h>
#include <linux/sched/signal.h>
#include <linux/timer.h>
#include <linux/string.h>
#include <linux/sockios.h>
#include <linux/net.h>
#include <linux/netdevice.h>
#include <linux/inet.h>
#include <linux/route.h>
#include <linux/netfilter.h>
#include <linux/seq_file.h>
#include <net/sock.h>
#include <net/tcp_states.h>
#include <net/flow.h>
#include <asm/ioctls.h>
#include <linux/capability.h>
#include <linux/mm.h>
#include <linux/interrupt.h>
#include <linux/proc_fs.h>
#include <linux/stat.h>
#include <linux/init.h>
#include <linux/poll.h>
#include <linux/jiffies.h>
#include <net/net_namespace.h>
#include <net/neighbour.h>
#include <net/dst.h>
#include <net/fib_rules.h>
#include <net/tcp.h>
#include <net/dn.h>
#include <net/dn_nsp.h>
#include <net/dn_dev.h>
#include <net/dn_route.h>
#include <net/dn_fib.h>
#include <net/dn_neigh.h>

struct dn_sock {
	struct sock sk;
	struct dn_scp scp;
};

static void dn_keepalive(struct sock *sk);

#define DN_SK_HASH_SHIFT 8
#define DN_SK_HASH_SIZE (1 << DN_SK_HASH_SHIFT)
#define DN_SK_HASH_MASK (DN_SK_HASH_SIZE - 1)


static const struct proto_ops dn_proto_ops;
static DEFINE_RWLOCK(dn_hash_lock);
static struct hlist_head dn_sk_hash[DN_SK_HASH_SIZE];
static struct hlist_head dn_wild_sk;
static atomic_long_t decnet_memory_allocated;
static DEFINE_PER_CPU(int, decnet_memory_per_cpu_fw_alloc);

static int __dn_setsockopt(struct socket *sock, int level, int optname,
		sockptr_t optval, unsigned int optlen, int flags);
static int __dn_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen, int flags);

static struct hlist_head *dn_find_list(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);

	if (scp->addr.sdn_flags & SDF_WILD)
		return hlist_empty(&dn_wild_sk) ? &dn_wild_sk : NULL;

	return &dn_sk_hash[le16_to_cpu(scp->addrloc) & DN_SK_HASH_MASK];
}

/*
 * Valid ports are those greater than zero and not already in use.
 */
static int check_port(__le16 port)
{
	struct sock *sk;

	if (port == 0)
		return -1;

	sk_for_each(sk, &dn_sk_hash[le16_to_cpu(port) & DN_SK_HASH_MASK]) {
		struct dn_scp *scp = DN_SK(sk);
		if (scp->addrloc == port)
			return -1;
	}
	return 0;
}

static unsigned short port_alloc(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);
	static unsigned short port = 0x2000;
	unsigned short i_port = port;

	while(check_port(cpu_to_le16(++port)) != 0) {
		if (port == i_port)
			return 0;
	}

	scp->addrloc = cpu_to_le16(port);

	return 1;
}

/*
 * Since this is only ever called from user
 * level, we don't need a write_lock() version
 * of this.
 */
static int dn_hash_sock(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);
	struct hlist_head *list;
	int rv = -EUSERS;

	BUG_ON(sk_hashed(sk));

	write_lock_bh(&dn_hash_lock);

	if (!scp->addrloc && !port_alloc(sk))
		goto out;

	rv = -EADDRINUSE;
	if ((list = dn_find_list(sk)) == NULL)
		goto out;

	sk_add_node(sk, list);
	rv = 0;
out:
	write_unlock_bh(&dn_hash_lock);
	return rv;
}

static void dn_unhash_sock(struct sock *sk)
{
	write_lock(&dn_hash_lock);
	sk_del_node_init(sk);
	write_unlock(&dn_hash_lock);
}

static void dn_unhash_sock_bh(struct sock *sk)
{
	write_lock_bh(&dn_hash_lock);
	sk_del_node_init(sk);
	write_unlock_bh(&dn_hash_lock);
}

static struct hlist_head *listen_hash(struct sockaddr_dn *addr)
{
	int i;
	unsigned int hash = addr->sdn_objnum;

	if (hash == 0) {
		hash = addr->sdn_objnamel;
		for(i = 0; i < le16_to_cpu(addr->sdn_objnamel); i++) {
			hash ^= addr->sdn_objname[i];
			hash ^= (hash << 3);
		}
	}

	return &dn_sk_hash[hash & DN_SK_HASH_MASK];
}

/*
 * Called to transform a socket from bound (i.e. with a local address)
 * into a listening socket (doesn't need a local port number) and rehashes
 * based upon the object name/number.
 */
static void dn_rehash_sock(struct sock *sk)
{
	struct hlist_head *list;
	struct dn_scp *scp = DN_SK(sk);

	if (scp->addr.sdn_flags & SDF_WILD)
		return;

	write_lock_bh(&dn_hash_lock);
	sk_del_node_init(sk);
	DN_SK(sk)->addrloc = 0;
	list = listen_hash(&DN_SK(sk)->addr);
	sk_add_node(sk, list);
	write_unlock_bh(&dn_hash_lock);
}

int dn_sockaddr2username(struct sockaddr_dn *sdn, unsigned char *buf, unsigned char type)
{
	int len = 2;

	*buf++ = type;

	switch (type) {
	case 0:
		*buf++ = sdn->sdn_objnum;
		break;
	case 1:
		*buf++ = 0;
		*buf++ = le16_to_cpu(sdn->sdn_objnamel);
		memcpy(buf, sdn->sdn_objname, le16_to_cpu(sdn->sdn_objnamel));
		len = 3 + le16_to_cpu(sdn->sdn_objnamel);
		break;
	case 2:
		memset(buf, 0, 5);
		buf += 5;
		*buf++ = le16_to_cpu(sdn->sdn_objnamel);
		memcpy(buf, sdn->sdn_objname, le16_to_cpu(sdn->sdn_objnamel));
		len = 7 + le16_to_cpu(sdn->sdn_objnamel);
		break;
	}

	return len;
}

/*
 * On reception of usernames, we handle types 1 and 0 for destination
 * addresses only. Types 2 and 4 are used for source addresses, but the
 * UIC, GIC are ignored and they are both treated the same way. Type 3
 * is never used as I've no idea what its purpose might be or what its
 * format is.
 */
int dn_username2sockaddr(unsigned char *data, int len, struct sockaddr_dn *sdn, unsigned char *fmt)
{
	unsigned char type;
	int size = len;
	int namel = 12;

	sdn->sdn_objnum = 0;
	sdn->sdn_objnamel = cpu_to_le16(0);
	memset(sdn->sdn_objname, 0, DN_MAXOBJL);

	if (len < 2)
		return -1;

	len -= 2;
	*fmt = *data++;
	type = *data++;

	switch (*fmt) {
	case 0:
		sdn->sdn_objnum = type;
		return 2;
	case 1:
		namel = 16;
		break;
	case 2:
		len  -= 4;
		data += 4;
		break;
	case 4:
		len  -= 8;
		data += 8;
		break;
	default:
		return -1;
	}

	len -= 1;

	if (len < 0)
		return -1;

	sdn->sdn_objnamel = cpu_to_le16(*data++);
	len -= le16_to_cpu(sdn->sdn_objnamel);

	if ((len < 0) || (le16_to_cpu(sdn->sdn_objnamel) > namel))
		return -1;

	memcpy(sdn->sdn_objname, data, le16_to_cpu(sdn->sdn_objnamel));

	return size - len;
}

struct sock *dn_sklist_find_listener(struct sockaddr_dn *addr)
{
	struct hlist_head *list = listen_hash(addr);
	struct sock *sk;

	read_lock(&dn_hash_lock);
	sk_for_each(sk, list) {
		struct dn_scp *scp = DN_SK(sk);
		if (sk->sk_state != TCP_LISTEN)
			continue;
		if (scp->addr.sdn_objnum) {
			if (scp->addr.sdn_objnum != addr->sdn_objnum)
				continue;
		} else {
			if (addr->sdn_objnum)
				continue;
			if (scp->addr.sdn_objnamel != addr->sdn_objnamel)
				continue;
			if (memcmp(scp->addr.sdn_objname, addr->sdn_objname, le16_to_cpu(addr->sdn_objnamel)) != 0)
				continue;
		}
		sock_hold(sk);
		read_unlock(&dn_hash_lock);
		return sk;
	}

	sk = sk_head(&dn_wild_sk);
	if (sk) {
		if (sk->sk_state == TCP_LISTEN)
			sock_hold(sk);
		else
			sk = NULL;
	}

	read_unlock(&dn_hash_lock);
	return sk;
}

struct sock *dn_find_by_skb(struct sk_buff *skb)
{
	struct dn_skb_cb *cb = DN_SKB_CB(skb);
	struct sock *sk;
	struct dn_scp *scp;

	read_lock(&dn_hash_lock);
	sk_for_each(sk, &dn_sk_hash[le16_to_cpu(cb->dst_port) & DN_SK_HASH_MASK]) {
		scp = DN_SK(sk);
		if (cb->src != dn_saddr2dn(&scp->peer))
			continue;
		if (cb->dst_port != scp->addrloc)
			continue;
		if (scp->addrrem && (cb->src_port != scp->addrrem))
			continue;
		sock_hold(sk);
		goto found;
	}
	sk = NULL;
found:
	read_unlock(&dn_hash_lock);
	return sk;
}



static void dn_destruct(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);

	skb_queue_purge(&scp->data_xmit_queue);
	skb_queue_purge(&scp->other_xmit_queue);
	skb_queue_purge(&scp->other_receive_queue);

	dst_release(rcu_dereference_protected(sk->sk_dst_cache, 1));
}

static unsigned long dn_memory_pressure;

static void dn_enter_memory_pressure(struct sock *sk)
{
	if (!dn_memory_pressure) {
		dn_memory_pressure = 1;
	}
}

static struct proto dn_proto = {
	.name			= ""NSP"",
	.owner			= THIS_MODULE,
	.enter_memory_pressure	= dn_enter_memory_pressure,
	.memory_pressure	= &dn_memory_pressure,

	.memory_allocated	= &decnet_memory_allocated,
	.per_cpu_fw_alloc	= &decnet_memory_per_cpu_fw_alloc,

	.sysctl_mem		= sysctl_decnet_mem,
	.sysctl_wmem		= sysctl_decnet_wmem,
	.sysctl_rmem		= sysctl_decnet_rmem,
	.max_header		= DN_MAX_NSP_DATA_HEADER + 64,
	.obj_size		= sizeof(struct dn_sock),
};

static struct sock *dn_alloc_sock(struct net *net, struct socket *sock, gfp_t gfp, int kern)
{
	struct dn_scp *scp;
	struct sock *sk = sk_alloc(net, PF_DECnet, gfp, &dn_proto, kern);

	if  (!sk)
		goto out;

	if (sock)
		sock->ops = &dn_proto_ops;
	sock_init_data(sock, sk);

	sk->sk_backlog_rcv = dn_nsp_backlog_rcv;
	sk->sk_destruct    = dn_destruct;
	sk->sk_no_check_tx = 1;
	sk->sk_family      = PF_DECnet;
	sk->sk_protocol    = 0;
	sk->sk_allocation  = gfp;
	sk->sk_sndbuf	   = READ_ONCE(sysctl_decnet_wmem[1]);
	sk->sk_rcvbuf	   = READ_ONCE(sysctl_decnet_rmem[1]);

	/* Initialization of DECnet Session Control Port		*/
	scp = DN_SK(sk);
	scp->state	= DN_O;		/* Open			*/
	scp->numdat	= 1;		/* Next data seg to tx	*/
	scp->numoth	= 1;		/* Next oth data to tx  */
	scp->ackxmt_dat = 0;		/* Last data seg ack'ed */
	scp->ackxmt_oth = 0;		/* Last oth data ack'ed */
	scp->ackrcv_dat = 0;		/* Highest data ack recv*/
	scp->ackrcv_oth = 0;		/* Last oth data ack rec*/
	scp->flowrem_sw = DN_SEND;
	scp->flowloc_sw = DN_SEND;
	scp->flowrem_dat = 0;
	scp->flowrem_oth = 1;
	scp->flowloc_dat = 0;
	scp->flowloc_oth = 1;
	scp->services_rem = 0;
	scp->services_loc = 1 | NSP_FC_NONE;
	scp->info_rem = 0;
	scp->info_loc = 0x03; /* NSP version 4.1 */
	scp->segsize_rem = 230 - DN_MAX_NSP_DATA_HEADER; /* Default: Updated by remote segsize */
	scp->nonagle = 0;
	scp->multi_ireq = 1;
	scp->accept_mode = ACC_IMMED;
	scp->addr.sdn_family    = AF_DECnet;
	scp->peer.sdn_family    = AF_DECnet;
	scp->accessdata.acc_accl = 5;
	memcpy(scp->accessdata.acc_acc, ""LINUX"", 5);

	scp->max_window   = NSP_MAX_WINDOW;
	scp->snd_window   = NSP_MIN_WINDOW;
	scp->nsp_srtt     = NSP_INITIAL_SRTT;
	scp->nsp_rttvar   = NSP_INITIAL_RTTVAR;
	scp->nsp_rxtshift = 0;

	skb_queue_head_init(&scp->data_xmit_queue);
	skb_queue_head_init(&scp->other_xmit_queue);
	skb_queue_head_init(&scp->other_receive_queue);

	scp->persist = 0;
	scp->persist_fxn = NULL;
	scp->keepalive = 10 * HZ;
	scp->keepalive_fxn = dn_keepalive;

	dn_start_slow_timer(sk);
out:
	return sk;
}

/*
 * Keepalive timer.
 * FIXME: Should respond to SO_KEEPALIVE etc.
 */
static void dn_keepalive(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);

	/*
	 * By checking the other_data transmit queue is empty
	 * we are double checking that we are not sending too
	 * many of these keepalive frames.
	 */
	if (skb_queue_empty(&scp->other_xmit_queue))
		dn_nsp_send_link(sk, DN_NOCHANGE, 0);
}


/*
 * Timer for shutdown/destroyed sockets.
 * When socket is dead & no packets have been sent for a
 * certain amount of time, they are removed by this
 * routine. Also takes care of sending out DI & DC
 * frames at correct times.
 */
int dn_destroy_timer(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);

	scp->persist = dn_nsp_persist(sk);

	switch (scp->state) {
	case DN_DI:
		dn_nsp_send_disc(sk, NSP_DISCINIT, 0, GFP_ATOMIC);
		if (scp->nsp_rxtshift >= decnet_di_count)
			scp->state = DN_CN;
		return 0;

	case DN_DR:
		dn_nsp_send_disc(sk, NSP_DISCINIT, 0, GFP_ATOMIC);
		if (scp->nsp_rxtshift >= decnet_dr_count)
			scp->state = DN_DRC;
		return 0;

	case DN_DN:
		if (scp->nsp_rxtshift < decnet_dn_count) {
			/* printk(KERN_DEBUG ""dn_destroy_timer: DN\n""); */
			dn_nsp_send_disc(sk, NSP_DISCCONF, NSP_REASON_DC,
					 GFP_ATOMIC);
			return 0;
		}
	}

	scp->persist = (HZ * decnet_time_wait);

	if (sk->sk_socket)
		return 0;

	if (time_after_eq(jiffies, scp->stamp + HZ * decnet_time_wait)) {
		dn_unhash_sock(sk);
		sock_put(sk);
		return 1;
	}

	return 0;
}

static void dn_destroy_sock(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);

	scp->nsp_rxtshift = 0; /* reset back off */

	if (sk->sk_socket) {
		if (sk->sk_socket->state != SS_UNCONNECTED)
			sk->sk_socket->state = SS_DISCONNECTING;
	}

	sk->sk_state = TCP_CLOSE;

	switch (scp->state) {
	case DN_DN:
		dn_nsp_send_disc(sk, NSP_DISCCONF, NSP_REASON_DC,
				 sk->sk_allocation);
		scp->persist_fxn = dn_destroy_timer;
		scp->persist = dn_nsp_persist(sk);
		break;
	case DN_CR:
		scp->state = DN_DR;
		goto disc_reject;
	case DN_RUN:
		scp->state = DN_DI;
		fallthrough;
	case DN_DI:
	case DN_DR:
disc_reject:
		dn_nsp_send_disc(sk, NSP_DISCINIT, 0, sk->sk_allocation);
		fallthrough;
	case DN_NC:
	case DN_NR:
	case DN_RJ:
	case DN_DIC:
	case DN_CN:
	case DN_DRC:
	case DN_CI:
	case DN_CD:
		scp->persist_fxn = dn_destroy_timer;
		scp->persist = dn_nsp_persist(sk);
		break;
	default:
		printk(KERN_DEBUG ""DECnet: dn_destroy_sock passed socket in invalid state\n"");
		fallthrough;
	case DN_O:
		dn_stop_slow_timer(sk);

		dn_unhash_sock_bh(sk);
		sock_put(sk);

		break;
	}
}

char *dn_addr2asc(__u16 addr, char *buf)
{
	unsigned short node, area;

	node = addr & 0x03ff;
	area = addr >> 10;
	sprintf(buf, ""%hd.%hd"", area, node);

	return buf;
}



static int dn_create(struct net *net, struct socket *sock, int protocol,
		     int kern)
{
	struct sock *sk;

	if (protocol < 0 || protocol > U8_MAX)
		return -EINVAL;

	if (!net_eq(net, &init_net))
		return -EAFNOSUPPORT;

	switch (sock->type) {
	case SOCK_SEQPACKET:
		if (protocol != DNPROTO_NSP)
			return -EPROTONOSUPPORT;
		break;
	case SOCK_STREAM:
		break;
	default:
		return -ESOCKTNOSUPPORT;
	}


	if ((sk = dn_alloc_sock(net, sock, GFP_KERNEL, kern)) == NULL)
		return -ENOBUFS;

	sk->sk_protocol = protocol;

	return 0;
}


static int
dn_release(struct socket *sock)
{
	struct sock *sk = sock->sk;

	if (sk) {
		sock_orphan(sk);
		sock_hold(sk);
		lock_sock(sk);
		dn_destroy_sock(sk);
		release_sock(sk);
		sock_put(sk);
	}

	return 0;
}

static int dn_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
{
	struct sock *sk = sock->sk;
	struct dn_scp *scp = DN_SK(sk);
	struct sockaddr_dn *saddr = (struct sockaddr_dn *)uaddr;
	struct net_device *dev, *ldev;
	int rv;

	if (addr_len != sizeof(struct sockaddr_dn))
		return -EINVAL;

	if (saddr->sdn_family != AF_DECnet)
		return -EINVAL;

	if (le16_to_cpu(saddr->sdn_nodeaddrl) && (le16_to_cpu(saddr->sdn_nodeaddrl) != 2))
		return -EINVAL;

	if (le16_to_cpu(saddr->sdn_objnamel) > DN_MAXOBJL)
		return -EINVAL;

	if (saddr->sdn_flags & ~SDF_WILD)
		return -EINVAL;

	if (!capable(CAP_NET_BIND_SERVICE) && (saddr->sdn_objnum ||
	    (saddr->sdn_flags & SDF_WILD)))
		return -EACCES;

	if (!(saddr->sdn_flags & SDF_WILD)) {
		if (le16_to_cpu(saddr->sdn_nodeaddrl)) {
			rcu_read_lock();
			ldev = NULL;
			for_each_netdev_rcu(&init_net, dev) {
				if (!dev->dn_ptr)
					continue;
				if (dn_dev_islocal(dev, dn_saddr2dn(saddr))) {
					ldev = dev;
					break;
				}
			}
			rcu_read_unlock();
			if (ldev == NULL)
				return -EADDRNOTAVAIL;
		}
	}

	rv = -EINVAL;
	lock_sock(sk);
	if (sock_flag(sk, SOCK_ZAPPED)) {
		memcpy(&scp->addr, saddr, addr_len);
		sock_reset_flag(sk, SOCK_ZAPPED);

		rv = dn_hash_sock(sk);
		if (rv)
			sock_set_flag(sk, SOCK_ZAPPED);
	}
	release_sock(sk);

	return rv;
}


static int dn_auto_bind(struct socket *sock)
{
	struct sock *sk = sock->sk;
	struct dn_scp *scp = DN_SK(sk);
	int rv;

	sock_reset_flag(sk, SOCK_ZAPPED);

	scp->addr.sdn_flags  = 0;
	scp->addr.sdn_objnum = 0;

	/*
	 * This stuff is to keep compatibility with Eduardo's
	 * patch. I hope I can dispense with it shortly...
	 */
	if ((scp->accessdata.acc_accl != 0) &&
		(scp->accessdata.acc_accl <= 12)) {

		scp->addr.sdn_objnamel = cpu_to_le16(scp->accessdata.acc_accl);
		memcpy(scp->addr.sdn_objname, scp->accessdata.acc_acc, le16_to_cpu(scp->addr.sdn_objnamel));

		scp->accessdata.acc_accl = 0;
		memset(scp->accessdata.acc_acc, 0, 40);
	}
	/* End of compatibility stuff */

	scp->addr.sdn_add.a_len = cpu_to_le16(2);
	rv = dn_dev_bind_default((__le16 *)scp->addr.sdn_add.a_addr);
	if (rv == 0) {
		rv = dn_hash_sock(sk);
		if (rv)
			sock_set_flag(sk, SOCK_ZAPPED);
	}

	return rv;
}

static int dn_confirm_accept(struct sock *sk, long *timeo, gfp_t allocation)
{
	struct dn_scp *scp = DN_SK(sk);
	DEFINE_WAIT_FUNC(wait, woken_wake_function);
	int err;

	if (scp->state != DN_CR)
		return -EINVAL;

	scp->state = DN_CC;
	scp->segsize_loc = dst_metric_advmss(__sk_dst_get(sk));
	dn_send_conn_conf(sk, allocation);

	add_wait_queue(sk_sleep(sk), &wait);
	for(;;) {
		release_sock(sk);
		if (scp->state == DN_CC)
			*timeo = wait_woken(&wait, TASK_INTERRUPTIBLE, *timeo);
		lock_sock(sk);
		err = 0;
		if (scp->state == DN_RUN)
			break;
		err = sock_error(sk);
		if (err)
			break;
		err = sock_intr_errno(*timeo);
		if (signal_pending(current))
			break;
		err = -EAGAIN;
		if (!*timeo)
			break;
	}
	remove_wait_queue(sk_sleep(sk), &wait);
	if (err == 0) {
		sk->sk_socket->state = SS_CONNECTED;
	} else if (scp->state != DN_CC) {
		sk->sk_socket->state = SS_UNCONNECTED;
	}
	return err;
}

static int dn_wait_run(struct sock *sk, long *timeo)
{
	struct dn_scp *scp = DN_SK(sk);
	DEFINE_WAIT_FUNC(wait, woken_wake_function);
	int err = 0;

	if (scp->state == DN_RUN)
		goto out;

	if (!*timeo)
		return -EALREADY;

	add_wait_queue(sk_sleep(sk), &wait);
	for(;;) {
		release_sock(sk);
		if (scp->state == DN_CI || scp->state == DN_CC)
			*timeo = wait_woken(&wait, TASK_INTERRUPTIBLE, *timeo);
		lock_sock(sk);
		err = 0;
		if (scp->state == DN_RUN)
			break;
		err = sock_error(sk);
		if (err)
			break;
		err = sock_intr_errno(*timeo);
		if (signal_pending(current))
			break;
		err = -ETIMEDOUT;
		if (!*timeo)
			break;
	}
	remove_wait_queue(sk_sleep(sk), &wait);
out:
	if (err == 0) {
		sk->sk_socket->state = SS_CONNECTED;
	} else if (scp->state != DN_CI && scp->state != DN_CC) {
		sk->sk_socket->state = SS_UNCONNECTED;
	}
	return err;
}

static int __dn_connect(struct sock *sk, struct sockaddr_dn *addr, int addrlen, long *timeo, int flags)
{
	struct socket *sock = sk->sk_socket;
	struct dn_scp *scp = DN_SK(sk);
	int err = -EISCONN;
	struct flowidn fld;
	struct dst_entry *dst;

	if (sock->state == SS_CONNECTED)
		goto out;

	if (sock->state == SS_CONNECTING) {
		err = 0;
		if (scp->state == DN_RUN) {
			sock->state = SS_CONNECTED;
			goto out;
		}
		err = -ECONNREFUSED;
		if (scp->state != DN_CI && scp->state != DN_CC) {
			sock->state = SS_UNCONNECTED;
			goto out;
		}
		return dn_wait_run(sk, timeo);
	}

	err = -EINVAL;
	if (scp->state != DN_O)
		goto out;

	if (addr == NULL || addrlen != sizeof(struct sockaddr_dn))
		goto out;
	if (addr->sdn_family != AF_DECnet)
		goto out;
	if (addr->sdn_flags & SDF_WILD)
		goto out;

	if (sock_flag(sk, SOCK_ZAPPED)) {
		err = dn_auto_bind(sk->sk_socket);
		if (err)
			goto out;
	}

	memcpy(&scp->peer, addr, sizeof(struct sockaddr_dn));

	err = -EHOSTUNREACH;
	memset(&fld, 0, sizeof(fld));
	fld.flowidn_oif = sk->sk_bound_dev_if;
	fld.daddr = dn_saddr2dn(&scp->peer);
	fld.saddr = dn_saddr2dn(&scp->addr);
	dn_sk_ports_copy(&fld, scp);
	fld.flowidn_proto = DNPROTO_NSP;
	if (dn_route_output_sock(&sk->sk_dst_cache, &fld, sk, flags) < 0)
		goto out;
	dst = __sk_dst_get(sk);
	sk->sk_route_caps = dst->dev->features;
	sock->state = SS_CONNECTING;
	scp->state = DN_CI;
	scp->segsize_loc = dst_metric_advmss(dst);

	dn_nsp_send_conninit(sk, NSP_CI);
	err = -EINPROGRESS;
	if (*timeo) {
		err = dn_wait_run(sk, timeo);
	}
out:
	return err;
}

static int dn_connect(struct socket *sock, struct sockaddr *uaddr, int addrlen, int flags)
{
	struct sockaddr_dn *addr = (struct sockaddr_dn *)uaddr;
	struct sock *sk = sock->sk;
	int err;
	long timeo = sock_sndtimeo(sk, flags & O_NONBLOCK);

	lock_sock(sk);
	err = __dn_connect(sk, addr, addrlen, &timeo, 0);
	release_sock(sk);

	return err;
}

static inline int dn_check_state(struct sock *sk, struct sockaddr_dn *addr, int addrlen, long *timeo, int flags)
{
	struct dn_scp *scp = DN_SK(sk);

	switch (scp->state) {
	case DN_RUN:
		return 0;
	case DN_CR:
		return dn_confirm_accept(sk, timeo, sk->sk_allocation);
	case DN_CI:
	case DN_CC:
		return dn_wait_run(sk, timeo);
	case DN_O:
		return __dn_connect(sk, addr, addrlen, timeo, flags);
	}

	return -EINVAL;
}


static void dn_access_copy(struct sk_buff *skb, struct accessdata_dn *acc)
{
	unsigned char *ptr = skb->data;

	acc->acc_userl = *ptr++;
	memcpy(&acc->acc_user, ptr, acc->acc_userl);
	ptr += acc->acc_userl;

	acc->acc_passl = *ptr++;
	memcpy(&acc->acc_pass, ptr, acc->acc_passl);
	ptr += acc->acc_passl;

	acc->acc_accl = *ptr++;
	memcpy(&acc->acc_acc, ptr, acc->acc_accl);

	skb_pull(skb, acc->acc_accl + acc->acc_passl + acc->acc_userl + 3);

}

static void dn_user_copy(struct sk_buff *skb, struct optdata_dn *opt)
{
	unsigned char *ptr = skb->data;
	u16 len = *ptr++; /* yes, it's 8bit on the wire */

	BUG_ON(len > 16); /* we've checked the contents earlier */
	opt->opt_optl   = cpu_to_le16(len);
	opt->opt_status = 0;
	memcpy(opt->opt_data, ptr, len);
	skb_pull(skb, len + 1);
}

static struct sk_buff *dn_wait_for_connect(struct sock *sk, long *timeo)
{
	DEFINE_WAIT_FUNC(wait, woken_wake_function);
	struct sk_buff *skb = NULL;
	int err = 0;

	add_wait_queue(sk_sleep(sk), &wait);
	for(;;) {
		release_sock(sk);
		skb = skb_dequeue(&sk->sk_receive_queue);
		if (skb == NULL) {
			*timeo = wait_woken(&wait, TASK_INTERRUPTIBLE, *timeo);
			skb = skb_dequeue(&sk->sk_receive_queue);
		}
		lock_sock(sk);
		if (skb != NULL)
			break;
		err = -EINVAL;
		if (sk->sk_state != TCP_LISTEN)
			break;
		err = sock_intr_errno(*timeo);
		if (signal_pending(current))
			break;
		err = -EAGAIN;
		if (!*timeo)
			break;
	}
	remove_wait_queue(sk_sleep(sk), &wait);

	return skb == NULL ? ERR_PTR(err) : skb;
}

static int dn_accept(struct socket *sock, struct socket *newsock, int flags,
		     bool kern)
{
	struct sock *sk = sock->sk, *newsk;
	struct sk_buff *skb = NULL;
	struct dn_skb_cb *cb;
	unsigned char menuver;
	int err = 0;
	unsigned char type;
	long timeo = sock_rcvtimeo(sk, flags & O_NONBLOCK);
	struct dst_entry *dst;

	lock_sock(sk);

	if (sk->sk_state != TCP_LISTEN || DN_SK(sk)->state != DN_O) {
		release_sock(sk);
		return -EINVAL;
	}

	skb = skb_dequeue(&sk->sk_receive_queue);
	if (skb == NULL) {
		skb = dn_wait_for_connect(sk, &timeo);
		if (IS_ERR(skb)) {
			release_sock(sk);
			return PTR_ERR(skb);
		}
	}

	cb = DN_SKB_CB(skb);
	sk_acceptq_removed(sk);
	newsk = dn_alloc_sock(sock_net(sk), newsock, sk->sk_allocation, kern);
	if (newsk == NULL) {
		release_sock(sk);
		kfree_skb(skb);
		return -ENOBUFS;
	}
	release_sock(sk);

	dst = skb_dst(skb);
	sk_dst_set(newsk, dst);
	skb_dst_set(skb, NULL);

	DN_SK(newsk)->state        = DN_CR;
	DN_SK(newsk)->addrrem      = cb->src_port;
	DN_SK(newsk)->services_rem = cb->services;
	DN_SK(newsk)->info_rem     = cb->info;
	DN_SK(newsk)->segsize_rem  = cb->segsize;
	DN_SK(newsk)->accept_mode  = DN_SK(sk)->accept_mode;

	if (DN_SK(newsk)->segsize_rem < 230)
		DN_SK(newsk)->segsize_rem = 230;

	if ((DN_SK(newsk)->services_rem & NSP_FC_MASK) == NSP_FC_NONE)
		DN_SK(newsk)->max_window = decnet_no_fc_max_cwnd;

	newsk->sk_state  = TCP_LISTEN;
	memcpy(&(DN_SK(newsk)->addr), &(DN_SK(sk)->addr), sizeof(struct sockaddr_dn));

	/*
	 * If we are listening on a wild socket, we don't want
	 * the newly created socket on the wrong hash queue.
	 */
	DN_SK(newsk)->addr.sdn_flags &= ~SDF_WILD;

	skb_pull(skb, dn_username2sockaddr(skb->data, skb->len, &(DN_SK(newsk)->addr), &type));
	skb_pull(skb, dn_username2sockaddr(skb->data, skb->len, &(DN_SK(newsk)->peer), &type));
	*(__le16 *)(DN_SK(newsk)->peer.sdn_add.a_addr) = cb->src;
	*(__le16 *)(DN_SK(newsk)->addr.sdn_add.a_addr) = cb->dst;

	menuver = *skb->data;
	skb_pull(skb, 1);

	if (menuver & DN_MENUVER_ACC)
		dn_access_copy(skb, &(DN_SK(newsk)->accessdata));

	if (menuver & DN_MENUVER_USR)
		dn_user_copy(skb, &(DN_SK(newsk)->conndata_in));

	if (menuver & DN_MENUVER_PRX)
		DN_SK(newsk)->peer.sdn_flags |= SDF_PROXY;

	if (menuver & DN_MENUVER_UIC)
		DN_SK(newsk)->peer.sdn_flags |= SDF_UICPROXY;

	kfree_skb(skb);

	memcpy(&(DN_SK(newsk)->conndata_out), &(DN_SK(sk)->conndata_out),
		sizeof(struct optdata_dn));
	memcpy(&(DN_SK(newsk)->discdata_out), &(DN_SK(sk)->discdata_out),
		sizeof(struct optdata_dn));

	lock_sock(newsk);
	err = dn_hash_sock(newsk);
	if (err == 0) {
		sock_reset_flag(newsk, SOCK_ZAPPED);
		dn_send_conn_ack(newsk);

		/*
		 * Here we use sk->sk_allocation since although the conn conf is
		 * for the newsk, the context is the old socket.
		 */
		if (DN_SK(newsk)->accept_mode == ACC_IMMED)
			err = dn_confirm_accept(newsk, &timeo,
						sk->sk_allocation);
	}
	release_sock(newsk);
	return err;
}


static int dn_getname(struct socket *sock, struct sockaddr *uaddr,int peer)
{
	struct sockaddr_dn *sa = (struct sockaddr_dn *)uaddr;
	struct sock *sk = sock->sk;
	struct dn_scp *scp = DN_SK(sk);

	lock_sock(sk);

	if (peer) {
		if ((sock->state != SS_CONNECTED &&
		     sock->state != SS_CONNECTING) &&
		    scp->accept_mode == ACC_IMMED) {
			release_sock(sk);
			return -ENOTCONN;
		}

		memcpy(sa, &scp->peer, sizeof(struct sockaddr_dn));
	} else {
		memcpy(sa, &scp->addr, sizeof(struct sockaddr_dn));
	}

	release_sock(sk);

	return sizeof(struct sockaddr_dn);
}


static __poll_t dn_poll(struct file *file, struct socket *sock, poll_table  *wait)
{
	struct sock *sk = sock->sk;
	struct dn_scp *scp = DN_SK(sk);
	__poll_t mask = datagram_poll(file, sock, wait);

	if (!skb_queue_empty_lockless(&scp->other_receive_queue))
		mask |= EPOLLRDBAND;

	return mask;
}

static int dn_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)
{
	struct sock *sk = sock->sk;
	struct dn_scp *scp = DN_SK(sk);
	int err = -EOPNOTSUPP;
	long amount = 0;
	struct sk_buff *skb;
	int val;

	switch(cmd)
	{
	case SIOCGIFADDR:
	case SIOCSIFADDR:
		return dn_dev_ioctl(cmd, (void __user *)arg);

	case SIOCATMARK:
		lock_sock(sk);
		val = !skb_queue_empty(&scp->other_receive_queue);
		if (scp->state != DN_RUN)
			val = -ENOTCONN;
		release_sock(sk);
		return val;

	case TIOCOUTQ:
		amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);
		if (amount < 0)
			amount = 0;
		err = put_user(amount, (int __user *)arg);
		break;

	case TIOCINQ:
		lock_sock(sk);
		skb = skb_peek(&scp->other_receive_queue);
		if (skb) {
			amount = skb->len;
		} else {
			skb_queue_walk(&sk->sk_receive_queue, skb)
				amount += skb->len;
		}
		release_sock(sk);
		err = put_user(amount, (int __user *)arg);
		break;

	default:
		err = -ENOIOCTLCMD;
		break;
	}

	return err;
}

static int dn_listen(struct socket *sock, int backlog)
{
	struct sock *sk = sock->sk;
	int err = -EINVAL;

	lock_sock(sk);

	if (sock_flag(sk, SOCK_ZAPPED))
		goto out;

	if ((DN_SK(sk)->state != DN_O) || (sk->sk_state == TCP_LISTEN))
		goto out;

	sk->sk_max_ack_backlog = backlog;
	sk->sk_ack_backlog     = 0;
	sk->sk_state           = TCP_LISTEN;
	err                 = 0;
	dn_rehash_sock(sk);

out:
	release_sock(sk);

	return err;
}


static int dn_shutdown(struct socket *sock, int how)
{
	struct sock *sk = sock->sk;
	struct dn_scp *scp = DN_SK(sk);
	int err = -ENOTCONN;

	lock_sock(sk);

	if (sock->state == SS_UNCONNECTED)
		goto out;

	err = 0;
	if (sock->state == SS_DISCONNECTING)
		goto out;

	err = -EINVAL;
	if (scp->state == DN_O)
		goto out;

	if (how != SHUT_RDWR)
		goto out;

	sk->sk_shutdown = SHUTDOWN_MASK;
	dn_destroy_sock(sk);
	err = 0;

out:
	release_sock(sk);

	return err;
}

static int dn_setsockopt(struct socket *sock, int level, int optname,
		sockptr_t optval, unsigned int optlen)
{
	struct sock *sk = sock->sk;
	int err;

	lock_sock(sk);
	err = __dn_setsockopt(sock, level, optname, optval, optlen, 0);
	release_sock(sk);
#ifdef CONFIG_NETFILTER
	/* we need to exclude all possible ENOPROTOOPTs except default case */
	if (err == -ENOPROTOOPT && optname != DSO_LINKINFO &&
	    optname != DSO_STREAM && optname != DSO_SEQPACKET)
		err = nf_setsockopt(sk, PF_DECnet, optname, optval, optlen);
#endif

	return err;
}

static int __dn_setsockopt(struct socket *sock, int level, int optname,
		sockptr_t optval, unsigned int optlen, int flags)
{
	struct	sock *sk = sock->sk;
	struct dn_scp *scp = DN_SK(sk);
	long timeo;
	union {
		struct optdata_dn opt;
		struct accessdata_dn acc;
		int mode;
		unsigned long win;
		int val;
		unsigned char services;
		unsigned char info;
	} u;
	int err;

	if (optlen && sockptr_is_null(optval))
		return -EINVAL;

	if (optlen > sizeof(u))
		return -EINVAL;

	if (copy_from_sockptr(&u, optval, optlen))
		return -EFAULT;

	switch (optname) {
	case DSO_CONDATA:
		if (sock->state == SS_CONNECTED)
			return -EISCONN;
		if ((scp->state != DN_O) && (scp->state != DN_CR))
			return -EINVAL;

		if (optlen != sizeof(struct optdata_dn))
			return -EINVAL;

		if (le16_to_cpu(u.opt.opt_optl) > 16)
			return -EINVAL;

		memcpy(&scp->conndata_out, &u.opt, optlen);
		break;

	case DSO_DISDATA:
		if (sock->state != SS_CONNECTED &&
		    scp->accept_mode == ACC_IMMED)
			return -ENOTCONN;

		if (optlen != sizeof(struct optdata_dn))
			return -EINVAL;

		if (le16_to_cpu(u.opt.opt_optl) > 16)
			return -EINVAL;

		memcpy(&scp->discdata_out, &u.opt, optlen);
		break;

	case DSO_CONACCESS:
		if (sock->state == SS_CONNECTED)
			return -EISCONN;
		if (scp->state != DN_O)
			return -EINVAL;

		if (optlen != sizeof(struct accessdata_dn))
			return -EINVAL;

		if ((u.acc.acc_accl > DN_MAXACCL) ||
		    (u.acc.acc_passl > DN_MAXACCL) ||
		    (u.acc.acc_userl > DN_MAXACCL))
			return -EINVAL;

		memcpy(&scp->accessdata, &u.acc, optlen);
		break;

	case DSO_ACCEPTMODE:
		if (sock->state == SS_CONNECTED)
			return -EISCONN;
		if (scp->state != DN_O)
			return -EINVAL;

		if (optlen != sizeof(int))
			return -EINVAL;

		if ((u.mode != ACC_IMMED) && (u.mode != ACC_DEFER))
			return -EINVAL;

		scp->accept_mode = (unsigned char)u.mode;
		break;

	case DSO_CONACCEPT:
		if (scp->state != DN_CR)
			return -EINVAL;
		timeo = sock_rcvtimeo(sk, 0);
		err = dn_confirm_accept(sk, &timeo, sk->sk_allocation);
		return err;

	case DSO_CONREJECT:
		if (scp->state != DN_CR)
			return -EINVAL;

		scp->state = DN_DR;
		sk->sk_shutdown = SHUTDOWN_MASK;
		dn_nsp_send_disc(sk, 0x38, 0, sk->sk_allocation);
		break;

	case DSO_MAXWINDOW:
		if (optlen != sizeof(unsigned long))
			return -EINVAL;
		if (u.win > NSP_MAX_WINDOW)
			u.win = NSP_MAX_WINDOW;
		if (u.win == 0)
			return -EINVAL;
		scp->max_window = u.win;
		if (scp->snd_window > u.win)
			scp->snd_window = u.win;
		break;

	case DSO_NODELAY:
		if (optlen != sizeof(int))
			return -EINVAL;
		if (scp->nonagle == TCP_NAGLE_CORK)
			return -EINVAL;
		scp->nonagle = (u.val == 0) ? 0 : TCP_NAGLE_OFF;
		/* if (scp->nonagle == 1) { Push pending frames } */
		break;

	case DSO_CORK:
		if (optlen != sizeof(int))
			return -EINVAL;
		if (scp->nonagle == TCP_NAGLE_OFF)
			return -EINVAL;
		scp->nonagle = (u.val == 0) ? 0 : TCP_NAGLE_CORK;
		/* if (scp->nonagle == 0) { Push pending frames } */
		break;

	case DSO_SERVICES:
		if (optlen != sizeof(unsigned char))
			return -EINVAL;
		if ((u.services & ~NSP_FC_MASK) != 0x01)
			return -EINVAL;
		if ((u.services & NSP_FC_MASK) == NSP_FC_MASK)
			return -EINVAL;
		scp->services_loc = u.services;
		break;

	case DSO_INFO:
		if (optlen != sizeof(unsigned char))
			return -EINVAL;
		if (u.info & 0xfc)
			return -EINVAL;
		scp->info_loc = u.info;
		break;

	case DSO_LINKINFO:
	case DSO_STREAM:
	case DSO_SEQPACKET:
	default:
		return -ENOPROTOOPT;
	}

	return 0;
}

static int dn_getsockopt(struct socket *sock, int level, int optname, char __user *optval, int __user *optlen)
{
	struct sock *sk = sock->sk;
	int err;

	lock_sock(sk);
	err = __dn_getsockopt(sock, level, optname, optval, optlen, 0);
	release_sock(sk);
#ifdef CONFIG_NETFILTER
	if (err == -ENOPROTOOPT && optname != DSO_STREAM &&
	    optname != DSO_SEQPACKET && optname != DSO_CONACCEPT &&
	    optname != DSO_CONREJECT) {
		int len;

		if (get_user(len, optlen))
			return -EFAULT;

		err = nf_getsockopt(sk, PF_DECnet, optname, optval, &len);
		if (err >= 0)
			err = put_user(len, optlen);
	}
#endif

	return err;
}

static int __dn_getsockopt(struct socket *sock, int level,int optname, char __user *optval,int __user *optlen, int flags)
{
	struct	sock *sk = sock->sk;
	struct dn_scp *scp = DN_SK(sk);
	struct linkinfo_dn link;
	unsigned int r_len;
	void *r_data = NULL;
	unsigned int val;

	if(get_user(r_len , optlen))
		return -EFAULT;

	switch (optname) {
	case DSO_CONDATA:
		if (r_len > sizeof(struct optdata_dn))
			r_len = sizeof(struct optdata_dn);
		r_data = &scp->conndata_in;
		break;

	case DSO_DISDATA:
		if (r_len > sizeof(struct optdata_dn))
			r_len = sizeof(struct optdata_dn);
		r_data = &scp->discdata_in;
		break;

	case DSO_CONACCESS:
		if (r_len > sizeof(struct accessdata_dn))
			r_len = sizeof(struct accessdata_dn);
		r_data = &scp->accessdata;
		break;

	case DSO_ACCEPTMODE:
		if (r_len > sizeof(unsigned char))
			r_len = sizeof(unsigned char);
		r_data = &scp->accept_mode;
		break;

	case DSO_LINKINFO:
		if (r_len > sizeof(struct linkinfo_dn))
			r_len = sizeof(struct linkinfo_dn);

		memset(&link, 0, sizeof(link));

		switch (sock->state) {
		case SS_CONNECTING:
			link.idn_linkstate = LL_CONNECTING;
			break;
		case SS_DISCONNECTING:
			link.idn_linkstate = LL_DISCONNECTING;
			break;
		case SS_CONNECTED:
			link.idn_linkstate = LL_RUNNING;
			break;
		default:
			link.idn_linkstate = LL_INACTIVE;
		}

		link.idn_segsize = scp->segsize_rem;
		r_data = &link;
		break;

	case DSO_MAXWINDOW:
		if (r_len > sizeof(unsigned long))
			r_len = sizeof(unsigned long);
		r_data = &scp->max_window;
		break;

	case DSO_NODELAY:
		if (r_len > sizeof(int))
			r_len = sizeof(int);
		val = (scp->nonagle == TCP_NAGLE_OFF);
		r_data = &val;
		break;

	case DSO_CORK:
		if (r_len > sizeof(int))
			r_len = sizeof(int);
		val = (scp->nonagle == TCP_NAGLE_CORK);
		r_data = &val;
		break;

	case DSO_SERVICES:
		if (r_len > sizeof(unsigned char))
			r_len = sizeof(unsigned char);
		r_data = &scp->services_rem;
		break;

	case DSO_INFO:
		if (r_len > sizeof(unsigned char))
			r_len = sizeof(unsigned char);
		r_data = &scp->info_rem;
		break;

	case DSO_STREAM:
	case DSO_SEQPACKET:
	case DSO_CONACCEPT:
	case DSO_CONREJECT:
	default:
		return -ENOPROTOOPT;
	}

	if (r_data) {
		if (copy_to_user(optval, r_data, r_len))
			return -EFAULT;
		if (put_user(r_len, optlen))
			return -EFAULT;
	}

	return 0;
}


static int dn_data_ready(struct sock *sk, struct sk_buff_head *q, int flags, int target)
{
	struct sk_buff *skb;
	int len = 0;

	if (flags & MSG_OOB)
		return !skb_queue_empty(q) ? 1 : 0;

	skb_queue_walk(q, skb) {
		struct dn_skb_cb *cb = DN_SKB_CB(skb);
		len += skb->len;

		if (cb->nsp_flags & 0x40) {
			/* SOCK_SEQPACKET reads to EOM */
			if (sk->sk_type == SOCK_SEQPACKET)
				return 1;
			/* so does SOCK_STREAM unless WAITALL is specified */
			if (!(flags & MSG_WAITALL))
				return 1;
		}

		/* minimum data length for read exceeded */
		if (len >= target)
			return 1;
	}

	return 0;
}


static int dn_recvmsg(struct socket *sock, struct msghdr *msg, size_t size,
		      int flags)
{
	struct sock *sk = sock->sk;
	struct dn_scp *scp = DN_SK(sk);
	struct sk_buff_head *queue = &sk->sk_receive_queue;
	size_t target = size > 1 ? 1 : 0;
	size_t copied = 0;
	int rv = 0;
	struct sk_buff *skb, *n;
	struct dn_skb_cb *cb = NULL;
	unsigned char eor = 0;
	long timeo = sock_rcvtimeo(sk, flags & MSG_DONTWAIT);

	lock_sock(sk);

	if (sock_flag(sk, SOCK_ZAPPED)) {
		rv = -EADDRNOTAVAIL;
		goto out;
	}

	if (sk->sk_shutdown & RCV_SHUTDOWN) {
		rv = 0;
		goto out;
	}

	rv = dn_check_state(sk, NULL, 0, &timeo, flags);
	if (rv)
		goto out;

	if (flags & ~(MSG_CMSG_COMPAT|MSG_PEEK|MSG_OOB|MSG_WAITALL|MSG_DONTWAIT|MSG_NOSIGNAL)) {
		rv = -EOPNOTSUPP;
		goto out;
	}

	if (flags & MSG_OOB)
		queue = &scp->other_receive_queue;

	if (flags & MSG_WAITALL)
		target = size;


	/*
	 * See if there is data ready to read, sleep if there isn't
	 */
	for(;;) {
		DEFINE_WAIT_FUNC(wait, woken_wake_function);

		if (sk->sk_err)
			goto out;

		if (!skb_queue_empty(&scp->other_receive_queue)) {
			if (!(flags & MSG_OOB)) {
				msg->msg_flags |= MSG_OOB;
				if (!scp->other_report) {
					scp->other_report = 1;
					goto out;
				}
			}
		}

		if (scp->state != DN_RUN)
			goto out;

		if (signal_pending(current)) {
			rv = sock_intr_errno(timeo);
			goto out;
		}

		if (dn_data_ready(sk, queue, flags, target))
			break;

		if (flags & MSG_DONTWAIT) {
			rv = -EWOULDBLOCK;
			goto out;
		}

		add_wait_queue(sk_sleep(sk), &wait);
		sk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);
		sk_wait_event(sk, &timeo, dn_data_ready(sk, queue, flags, target), &wait);
		sk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);
		remove_wait_queue(sk_sleep(sk), &wait);
	}

	skb_queue_walk_safe(queue, skb, n) {
		unsigned int chunk = skb->len;
		cb = DN_SKB_CB(skb);

		if ((chunk + copied) > size)
			chunk = size - copied;

		if (memcpy_to_msg(msg, skb->data, chunk)) {
			rv = -EFAULT;
			break;
		}
		copied += chunk;

		if (!(flags & MSG_PEEK))
			skb_pull(skb, chunk);

		eor = cb->nsp_flags & 0x40;

		if (skb->len == 0) {
			skb_unlink(skb, queue);
			kfree_skb(skb);
			/*
			 * N.B. Don't refer to skb or cb after this point
			 * in loop.
			 */
			if ((scp->flowloc_sw == DN_DONTSEND) && !dn_congested(sk)) {
				scp->flowloc_sw = DN_SEND;
				dn_nsp_send_link(sk, DN_SEND, 0);
			}
		}

		if (eor) {
			if (sk->sk_type == SOCK_SEQPACKET)
				break;
			if (!(flags & MSG_WAITALL))
				break;
		}

		if (flags & MSG_OOB)
			break;

		if (copied >= target)
			break;
	}

	rv = copied;


	if (eor && (sk->sk_type == SOCK_SEQPACKET))
		msg->msg_flags |= MSG_EOR;

out:
	if (rv == 0)
		rv = (flags & MSG_PEEK) ? -sk->sk_err : sock_error(sk);

	if ((rv >= 0) && msg->msg_name) {
		__sockaddr_check_size(sizeof(struct sockaddr_dn));
		memcpy(msg->msg_name, &scp->peer, sizeof(struct sockaddr_dn));
		msg->msg_namelen = sizeof(struct sockaddr_dn);
	}

	release_sock(sk);

	return rv;
}


static inline int dn_queue_too_long(struct dn_scp *scp, struct sk_buff_head *queue, int flags)
{
	unsigned char fctype = scp->services_rem & NSP_FC_MASK;
	if (skb_queue_len(queue) >= scp->snd_window)
		return 1;
	if (fctype != NSP_FC_NONE) {
		if (flags & MSG_OOB) {
			if (scp->flowrem_oth == 0)
				return 1;
		} else {
			if (scp->flowrem_dat == 0)
				return 1;
		}
	}
	return 0;
}

/*
 * The DECnet spec requires that the ""routing layer"" accepts packets which
 * are at least 230 bytes in size. This excludes any headers which the NSP
 * layer might add, so we always assume that we'll be using the maximal
 * length header on data packets. The variation in length is due to the
 * inclusion (or not) of the two 16 bit acknowledgement fields so it doesn't
 * make much practical difference.
 */
unsigned int dn_mss_from_pmtu(struct net_device *dev, int mtu)
{
	unsigned int mss = 230 - DN_MAX_NSP_DATA_HEADER;
	if (dev) {
		struct dn_dev *dn_db = rcu_dereference_raw(dev->dn_ptr);
		mtu -= LL_RESERVED_SPACE(dev);
		if (dn_db->use_long)
			mtu -= 21;
		else
			mtu -= 6;
		mtu -= DN_MAX_NSP_DATA_HEADER;
	} else {
		/*
		 * 21 = long header, 16 = guess at MAC header length
		 */
		mtu -= (21 + DN_MAX_NSP_DATA_HEADER + 16);
	}
	if (mtu > mss)
		mss = mtu;
	return mss;
}

static inline unsigned int dn_current_mss(struct sock *sk, int flags)
{
	struct dst_entry *dst = __sk_dst_get(sk);
	struct dn_scp *scp = DN_SK(sk);
	int mss_now = min_t(int, scp->segsize_loc, scp->segsize_rem);

	/* Other data messages are limited to 16 bytes per packet */
	if (flags & MSG_OOB)
		return 16;

	/* This works out the maximum size of segment we can send out */
	if (dst) {
		u32 mtu = dst_mtu(dst);
		mss_now = min_t(int, dn_mss_from_pmtu(dst->dev, mtu), mss_now);
	}

	return mss_now;
}

/*
 * N.B. We get the timeout wrong here, but then we always did get it
 * wrong before and this is another step along the road to correcting
 * it. It ought to get updated each time we pass through the routine,
 * but in practise it probably doesn't matter too much for now.
 */
static inline struct sk_buff *dn_alloc_send_pskb(struct sock *sk,
			      unsigned long datalen, int noblock,
			      int *errcode)
{
	struct sk_buff *skb = sock_alloc_send_skb(sk, datalen,
						   noblock, errcode);
	if (skb) {
		skb->protocol = htons(ETH_P_DNA_RT);
		skb->pkt_type = PACKET_OUTGOING;
	}
	return skb;
}

static int dn_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)
{
	struct sock *sk = sock->sk;
	struct dn_scp *scp = DN_SK(sk);
	size_t mss;
	struct sk_buff_head *queue = &scp->data_xmit_queue;
	int flags = msg->msg_flags;
	int err = 0;
	size_t sent = 0;
	int addr_len = msg->msg_namelen;
	DECLARE_SOCKADDR(struct sockaddr_dn *, addr, msg->msg_name);
	struct sk_buff *skb = NULL;
	struct dn_skb_cb *cb;
	size_t len;
	unsigned char fctype;
	long timeo;

	if (flags & ~(MSG_TRYHARD|MSG_OOB|MSG_DONTWAIT|MSG_EOR|MSG_NOSIGNAL|MSG_MORE|MSG_CMSG_COMPAT))
		return -EOPNOTSUPP;

	if (addr_len && (addr_len != sizeof(struct sockaddr_dn)))
		return -EINVAL;

	lock_sock(sk);
	timeo = sock_sndtimeo(sk, flags & MSG_DONTWAIT);
	/*
	 * The only difference between stream sockets and sequenced packet
	 * sockets is that the stream sockets always behave as if MSG_EOR
	 * has been set.
	 */
	if (sock->type == SOCK_STREAM) {
		if (flags & MSG_EOR) {
			err = -EINVAL;
			goto out;
		}
		flags |= MSG_EOR;
	}


	err = dn_check_state(sk, addr, addr_len, &timeo, flags);
	if (err)
		goto out_err;

	if (sk->sk_shutdown & SEND_SHUTDOWN) {
		err = -EPIPE;
		if (!(flags & MSG_NOSIGNAL))
			send_sig(SIGPIPE, current, 0);
		goto out_err;
	}

	if ((flags & MSG_TRYHARD) && sk->sk_dst_cache)
		dst_negative_advice(sk);

	mss = scp->segsize_rem;
	fctype = scp->services_rem & NSP_FC_MASK;

	mss = dn_current_mss(sk, flags);

	if (flags & MSG_OOB) {
		queue = &scp->other_xmit_queue;
		if (size > mss) {
			err = -EMSGSIZE;
			goto out;
		}
	}

	scp->persist_fxn = dn_nsp_xmit_timeout;

	while(sent < size) {
		err = sock_error(sk);
		if (err)
			goto out;

		if (signal_pending(current)) {
			err = sock_intr_errno(timeo);
			goto out;
		}

		/*
		 * Calculate size that we wish to send.
		 */
		len = size - sent;

		if (len > mss)
			len = mss;

		/*
		 * Wait for queue size to go down below the window
		 * size.
		 */
		if (dn_queue_too_long(scp, queue, flags)) {
			DEFINE_WAIT_FUNC(wait, woken_wake_function);

			if (flags & MSG_DONTWAIT) {
				err = -EWOULDBLOCK;
				goto out;
			}

			add_wait_queue(sk_sleep(sk), &wait);
			sk_set_bit(SOCKWQ_ASYNC_WAITDATA, sk);
			sk_wait_event(sk, &timeo,
				      !dn_queue_too_long(scp, queue, flags), &wait);
			sk_clear_bit(SOCKWQ_ASYNC_WAITDATA, sk);
			remove_wait_queue(sk_sleep(sk), &wait);
			continue;
		}

		/*
		 * Get a suitably sized skb.
		 * 64 is a bit of a hack really, but its larger than any
		 * link-layer headers and has served us well as a good
		 * guess as to their real length.
		 */
		skb = dn_alloc_send_pskb(sk, len + 64 + DN_MAX_NSP_DATA_HEADER,
					 flags & MSG_DONTWAIT, &err);

		if (err)
			break;

		if (!skb)
			continue;

		cb = DN_SKB_CB(skb);

		skb_reserve(skb, 64 + DN_MAX_NSP_DATA_HEADER);

		if (memcpy_from_msg(skb_put(skb, len), msg, len)) {
			err = -EFAULT;
			goto out;
		}

		if (flags & MSG_OOB) {
			cb->nsp_flags = 0x30;
			if (fctype != NSP_FC_NONE)
				scp->flowrem_oth--;
		} else {
			cb->nsp_flags = 0x00;
			if (scp->seg_total == 0)
				cb->nsp_flags |= 0x20;

			scp->seg_total += len;

			if (((sent + len) == size) && (flags & MSG_EOR)) {
				cb->nsp_flags |= 0x40;
				scp->seg_total = 0;
				if (fctype == NSP_FC_SCMC)
					scp->flowrem_dat--;
			}
			if (fctype == NSP_FC_SRC)
				scp->flowrem_dat--;
		}

		sent += len;
		dn_nsp_queue_xmit(sk, skb, sk->sk_allocation, flags & MSG_OOB);
		skb = NULL;

		scp->persist = dn_nsp_persist(sk);

	}
out:

	kfree_skb(skb);

	release_sock(sk);

	return sent ? sent : err;

out_err:
	err = sk_stream_error(sk, flags, err);
	release_sock(sk);
	return err;
}

static int dn_device_event(struct notifier_block *this, unsigned long event,
			   void *ptr)
{
	struct net_device *dev = netdev_notifier_info_to_dev(ptr);

	if (!net_eq(dev_net(dev), &init_net))
		return NOTIFY_DONE;

	switch (event) {
	case NETDEV_UP:
		dn_dev_up(dev);
		break;
	case NETDEV_DOWN:
		dn_dev_down(dev);
		break;
	default:
		break;
	}

	return NOTIFY_DONE;
}

static struct notifier_block dn_dev_notifier = {
	.notifier_call = dn_device_event,
};

static struct packet_type dn_dix_packet_type __read_mostly = {
	.type =		cpu_to_be16(ETH_P_DNA_RT),
	.func =		dn_route_rcv,
};

#ifdef CONFIG_PROC_FS
struct dn_iter_state {
	int bucket;
};

static struct sock *dn_socket_get_first(struct seq_file *seq)
{
	struct dn_iter_state *state = seq->private;
	struct sock *n = NULL;

	for(state->bucket = 0;
	    state->bucket < DN_SK_HASH_SIZE;
	    ++state->bucket) {
		n = sk_head(&dn_sk_hash[state->bucket]);
		if (n)
			break;
	}

	return n;
}

static struct sock *dn_socket_get_next(struct seq_file *seq,
				       struct sock *n)
{
	struct dn_iter_state *state = seq->private;

	n = sk_next(n);
	while (!n) {
		if (++state->bucket >= DN_SK_HASH_SIZE)
			break;
		n = sk_head(&dn_sk_hash[state->bucket]);
	}
	return n;
}

static struct sock *socket_get_idx(struct seq_file *seq, loff_t *pos)
{
	struct sock *sk = dn_socket_get_first(seq);

	if (sk) {
		while(*pos && (sk = dn_socket_get_next(seq, sk)))
			--*pos;
	}
	return *pos ? NULL : sk;
}

static void *dn_socket_get_idx(struct seq_file *seq, loff_t pos)
{
	void *rc;
	read_lock_bh(&dn_hash_lock);
	rc = socket_get_idx(seq, &pos);
	if (!rc) {
		read_unlock_bh(&dn_hash_lock);
	}
	return rc;
}

static void *dn_socket_seq_start(struct seq_file *seq, loff_t *pos)
{
	return *pos ? dn_socket_get_idx(seq, *pos - 1) : SEQ_START_TOKEN;
}

static void *dn_socket_seq_next(struct seq_file *seq, void *v, loff_t *pos)
{
	void *rc;

	if (v == SEQ_START_TOKEN) {
		rc = dn_socket_get_idx(seq, 0);
		goto out;
	}

	rc = dn_socket_get_next(seq, v);
	if (rc)
		goto out;
	read_unlock_bh(&dn_hash_lock);
out:
	++*pos;
	return rc;
}

static void dn_socket_seq_stop(struct seq_file *seq, void *v)
{
	if (v && v != SEQ_START_TOKEN)
		read_unlock_bh(&dn_hash_lock);
}

#define IS_NOT_PRINTABLE(x) ((x) < 32 || (x) > 126)

static void dn_printable_object(struct sockaddr_dn *dn, unsigned char *buf)
{
	int i;

	switch (le16_to_cpu(dn->sdn_objnamel)) {
	case 0:
		sprintf(buf, ""%d"", dn->sdn_objnum);
		break;
	default:
		for (i = 0; i < le16_to_cpu(dn->sdn_objnamel); i++) {
			buf[i] = dn->sdn_objname[i];
			if (IS_NOT_PRINTABLE(buf[i]))
				buf[i] = '.';
		}
		buf[i] = 0;
	}
}

static char *dn_state2asc(unsigned char state)
{
	switch (state) {
	case DN_O:
		return ""OPEN"";
	case DN_CR:
		return ""  CR"";
	case DN_DR:
		return ""  DR"";
	case DN_DRC:
		return "" DRC"";
	case DN_CC:
		return ""  CC"";
	case DN_CI:
		return ""  CI"";
	case DN_NR:
		return ""  NR"";
	case DN_NC:
		return ""  NC"";
	case DN_CD:
		return ""  CD"";
	case DN_RJ:
		return ""  RJ"";
	case DN_RUN:
		return "" RUN"";
	case DN_DI:
		return ""  DI"";
	case DN_DIC:
		return "" DIC"";
	case DN_DN:
		return ""  DN"";
	case DN_CL:
		return ""  CL"";
	case DN_CN:
		return ""  CN"";
	}

	return ""????"";
}

static inline void dn_socket_format_entry(struct seq_file *seq, struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);
	char buf1[DN_ASCBUF_LEN];
	char buf2[DN_ASCBUF_LEN];
	char local_object[DN_MAXOBJL+3];
	char remote_object[DN_MAXOBJL+3];

	dn_printable_object(&scp->addr, local_object);
	dn_printable_object(&scp->peer, remote_object);

	seq_printf(seq,
		   ""%6s/%04X %04d:%04d %04d:%04d %01d %-16s ""
		   ""%6s/%04X %04d:%04d %04d:%04d %01d %-16s %4s %s\n"",
		   dn_addr2asc(le16_to_cpu(dn_saddr2dn(&scp->addr)), buf1),
		   scp->addrloc,
		   scp->numdat,
		   scp->numoth,
		   scp->ackxmt_dat,
		   scp->ackxmt_oth,
		   scp->flowloc_sw,
		   local_object,
		   dn_addr2asc(le16_to_cpu(dn_saddr2dn(&scp->peer)), buf2),
		   scp->addrrem,
		   scp->numdat_rcv,
		   scp->numoth_rcv,
		   scp->ackrcv_dat,
		   scp->ackrcv_oth,
		   scp->flowrem_sw,
		   remote_object,
		   dn_state2asc(scp->state),
		   ((scp->accept_mode == ACC_IMMED) ? ""IMMED"" : ""DEFER""));
}

static int dn_socket_seq_show(struct seq_file *seq, void *v)
{
	if (v == SEQ_START_TOKEN) {
		seq_puts(seq, ""Local                                              Remote\n"");
	} else {
		dn_socket_format_entry(seq, v);
	}
	return 0;
}

static const struct seq_operations dn_socket_seq_ops = {
	.start	= dn_socket_seq_start,
	.next	= dn_socket_seq_next,
	.stop	= dn_socket_seq_stop,
	.show	= dn_socket_seq_show,
};
#endif

static const struct net_proto_family	dn_family_ops = {
	.family =	AF_DECnet,
	.create =	dn_create,
	.owner	=	THIS_MODULE,
};

static const struct proto_ops dn_proto_ops = {
	.family =	AF_DECnet,
	.owner =	THIS_MODULE,
	.release =	dn_release,
	.bind =		dn_bind,
	.connect =	dn_connect,
	.socketpair =	sock_no_socketpair,
	.accept =	dn_accept,
	.getname =	dn_getname,
	.poll =		dn_poll,
	.ioctl =	dn_ioctl,
	.listen =	dn_listen,
	.shutdown =	dn_shutdown,
	.setsockopt =	dn_setsockopt,
	.getsockopt =	dn_getsockopt,
	.sendmsg =	dn_sendmsg,
	.recvmsg =	dn_recvmsg,
	.mmap =		sock_no_mmap,
	.sendpage =	sock_no_sendpage,
};

MODULE_DESCRIPTION(""The Linux DECnet Network Protocol"");
MODULE_AUTHOR(""Linux DECnet Project Team"");
MODULE_LICENSE(""GPL"");
MODULE_ALIAS_NETPROTO(PF_DECnet);

static const char banner[] __initconst = KERN_INFO
""NET4: DECnet for Linux: V.2.5.68s (C) 1995-2003 Linux DECnet Project Team\n"";

static int __init decnet_init(void)
{
	int rc;

	printk(banner);

	rc = proto_register(&dn_proto, 1);
	if (rc != 0)
		goto out;

	dn_neigh_init();
	dn_dev_init();
	dn_route_init();
	dn_fib_init();

	sock_register(&dn_family_ops);
	dev_add_pack(&dn_dix_packet_type);
	register_netdevice_notifier(&dn_dev_notifier);

	proc_create_seq_private(""decnet"", 0444, init_net.proc_net,
			&dn_socket_seq_ops, sizeof(struct dn_iter_state),
			NULL);
	dn_register_sysctl();
out:
	return rc;

}
module_init(decnet_init);

/*
 * Prevent DECnet module unloading until its fixed properly.
 * Requires an audit of the code to check for memory leaks and
 * initialisation problems etc.
 */
#if 0
static void __exit decnet_exit(void)
{
	sock_unregister(AF_DECnet);
	rtnl_unregister_all(PF_DECnet);
	dev_remove_pack(&dn_dix_packet_type);

	dn_unregister_sysctl();

	unregister_netdevice_notifier(&dn_dev_notifier);

	dn_route_cleanup();
	dn_dev_cleanup();
	dn_neigh_cleanup();
	dn_fib_cleanup();

	remove_proc_entry(""decnet"", init_net.proc_net);

	proto_unregister(&dn_proto);

	rcu_barrier(); /* Wait for completion of call_rcu()'s */
}
module_exit(decnet_exit);
#endif",1202cdd665315c525b5237e96e0bedc76d7e754f,CVE-2023-3338,1202cdd665315c525b5237e96e0bedc76d7e754f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,"  /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR * * VAR: VAR VAR VAR <VAR@VAR.VAR> * VAR VAR <VAR@VAR.VAR.VAR.VAR> * * VAR: * VAR VAR: VAR VAR VAR VAR VAR VAR VAR'VAR * VAR VAR VAR VAR. VAR VAR VAR * VAR. * VAR VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. * VAR VAR: VAR VAR VAR VAR VAR VAR VAR * VAR. * VAR VAR: VAR VAR VAR, VAR VAR VAR VAR VAR * VAR VAR VAR VAR. * VAR VAR: VAR VAR/VAR() VAR. * VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR * VAR. * VAR VAR: VAR() VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. VAR'VAR VAR VAR VAR, VAR VAR VAR. * VAR VAR: VAR VAR VAR(). * VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR: VAR VAR VAR. * VAR VAR: VAR VAR VAR & VAR. * VAR VAR: VAR VAR VAR() VAR VAR. * VAR VAR: VAR VAR VAR VAR VAR. * VAR VAR. VAR: VAR VAR VAR * VAR VAR: VAR VAR VAR/VAR * VAR VAR. VAR: VAR VAR, VAR VAR * VAR VAR: VAR VAR VAR. VAR VAR VAR VAR->VAR * VAR VAR. * VAR VAR: /VAR/VAR/VAR VAR VAR VAR VAR/VAR * VAR VAR: VAR VAR VAR VAR, VAR VAR VAR * VAR VAR: VAR VAR VAR() * VAR VAR: VAR VAR/VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR. */ /****************************************************************************** (VAR) 1995-1998 VAR.VAR. VAR VAR@VAR.VAR VAR: VAR VAR VAR VAR/VAR VAR 0.0.1 2.0.30 01-VAR-97 VAR VAR VAR (VAR@VAR.VAR) VAR VAR VAR VAR VAR VAR- VAR VAR VAR. VAR VAR VAR VAR. VAR 0.0.2 2.1.105 20-VAR-98 VAR VAR. VAR (VAR@VAR.VAR.VAR.VAR) VAR VAR VAR VAR VAR VAR. VAR 0.0.3 2.1.106 25-VAR-98 VAR VAR VAR (VAR@VAR.VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. - VAR VAR VAR 0.0.4 2.1.109 21-VAR-98 VAR VAR VAR (VAR@VAR.VAR) VAR VAR VAR VAR VAR.4. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR!!! - VAR 0.0.5 2.1.110 01-VAR-98 VAR VAR VAR (VAR@VAR.VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR - VAR 0.0.6 2.1.110 07-VAR-98 VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR *******************************************************************************/                                         VAR VAR { VAR VAR VAR; VAR VAR VAR; }; VAR VAR VAR(VAR VAR *VAR);    VAR VAR VAR VAR VAR; VAR VAR(VAR); VAR VAR VAR VAR[VAR]; VAR VAR VAR VAR; VAR VAR VAR; VAR VAR(VAR, VAR); VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR VAR, VAR VAR); VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR); VAR VAR VAR *VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR->VAR.VAR & VAR) VAR VAR(&VAR) ? &VAR : VAR; VAR &VAR[VAR(VAR->VAR) & VAR]; } /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR VAR(VAR VAR) { VAR VAR *VAR; VAR (VAR == 0) VAR -1; VAR(VAR, &VAR[VAR(VAR) & VAR]) { VAR VAR *VAR = VAR(VAR); VAR (VAR->VAR == VAR) VAR -1; } VAR 0; } VAR VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR VAR VAR = 0x2000; VAR VAR VAR = VAR; VAR(VAR(VAR(++VAR)) != 0) { VAR (VAR == VAR) VAR 0; } VAR->VAR = VAR(VAR); VAR 1; } /* * VAR VAR VAR VAR VAR VAR VAR VAR * VAR, VAR VAR'VAR VAR VAR VAR() VAR * VAR VAR. */ VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR; VAR VAR = -VAR; VAR(VAR(VAR)); VAR(&VAR); VAR (!VAR->VAR && !VAR(VAR)) VAR VAR; VAR = -VAR; VAR ((VAR = VAR(VAR)) == VAR) VAR VAR; VAR(VAR, VAR); VAR = 0; VAR: VAR(&VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR(&VAR); VAR(VAR); VAR(&VAR); } VAR VAR VAR(VAR VAR *VAR) { VAR(&VAR); VAR(VAR); VAR(&VAR); } VAR VAR VAR *VAR(VAR VAR *VAR) { VAR VAR; VAR VAR VAR = VAR->VAR; VAR (VAR == 0) { VAR = VAR->VAR; VAR(VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR ^= VAR->VAR[VAR]; VAR ^= (VAR << 3); } } VAR &VAR[VAR & VAR]; } /* * VAR VAR VAR VAR VAR VAR VAR (VAR.VAR. VAR VAR VAR VAR) * VAR VAR VAR VAR (VAR'VAR VAR VAR VAR VAR VAR) VAR VAR * VAR VAR VAR VAR VAR/VAR. */ VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR; VAR VAR *VAR = VAR(VAR); VAR (VAR->VAR.VAR & VAR) VAR; VAR(&VAR); VAR(VAR); VAR(VAR)->VAR = 0; VAR = VAR(&VAR(VAR)->VAR); VAR(VAR, VAR); VAR(&VAR); } VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR VAR) { VAR VAR = 2; *VAR++ = VAR; VAR (VAR) { VAR 0: *VAR++ = VAR->VAR; VAR; VAR 1: *VAR++ = 0; *VAR++ = VAR(VAR->VAR); VAR(VAR, VAR->VAR, VAR(VAR->VAR)); VAR = 3 + VAR(VAR->VAR); VAR; VAR 2: VAR(VAR, 0, 5); VAR += 5; *VAR++ = VAR(VAR->VAR); VAR(VAR, VAR->VAR, VAR(VAR->VAR)); VAR = 7 + VAR(VAR->VAR); VAR; } VAR VAR; } /* * VAR VAR VAR VAR, VAR VAR VAR 1 VAR 0 VAR VAR * VAR VAR. VAR 2 VAR 4 VAR VAR VAR VAR VAR, VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR 3 * VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. */ VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR VAR; VAR VAR = VAR; VAR VAR = 12; VAR->VAR = 0; VAR->VAR = VAR(0); VAR(VAR->VAR, 0, VAR); VAR (VAR < 2) VAR -1; VAR -= 2; *VAR = *VAR++; VAR = *VAR++; VAR (*VAR) { VAR 0: VAR->VAR = VAR; VAR 2; VAR 1: VAR = 16; VAR; VAR 2: VAR -= 4; VAR += 4; VAR; VAR 4: VAR -= 8; VAR += 8; VAR; VAR: VAR -1; } VAR -= 1; VAR (VAR < 0) VAR -1; VAR->VAR = VAR(*VAR++); VAR -= VAR(VAR->VAR); VAR ((VAR < 0) || (VAR(VAR->VAR) > VAR)) VAR -1; VAR(VAR->VAR, VAR, VAR(VAR->VAR)); VAR VAR - VAR; } VAR VAR *VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR; VAR(&VAR); VAR(VAR, VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR->VAR != VAR) VAR; VAR (VAR->VAR.VAR) { VAR (VAR->VAR.VAR != VAR->VAR) VAR; } VAR { VAR (VAR->VAR) VAR; VAR (VAR->VAR.VAR != VAR->VAR) VAR; VAR (VAR(VAR->VAR.VAR, VAR->VAR, VAR(VAR->VAR)) != 0) VAR; } VAR(VAR); VAR(&VAR); VAR VAR; } VAR = VAR(&VAR); VAR (VAR) { VAR (VAR->VAR == VAR) VAR(VAR); VAR VAR = VAR; } VAR(&VAR); VAR VAR; } VAR VAR *VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR; VAR VAR *VAR; VAR(&VAR); VAR(VAR, &VAR[VAR(VAR->VAR) & VAR]) { VAR = VAR(VAR); VAR (VAR->VAR != VAR(&VAR->VAR)) VAR; VAR (VAR->VAR != VAR->VAR) VAR; VAR (VAR->VAR && (VAR->VAR != VAR->VAR)) VAR; VAR(VAR); VAR VAR; } VAR = VAR; VAR: VAR(&VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(VAR(VAR->VAR, 1)); } VAR VAR VAR VAR; VAR VAR VAR(VAR VAR *VAR) { VAR (!VAR) { VAR = 1; } } VAR VAR VAR VAR = { .VAR = ""VAR"", .VAR = VAR, .VAR = VAR, .VAR = &VAR, .VAR = &VAR, .VAR = &VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR + 64, .VAR = VAR(VAR VAR), }; VAR VAR VAR *VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR *VAR; VAR VAR *VAR = VAR(VAR, VAR, VAR, &VAR, VAR); VAR (!VAR) VAR VAR; VAR (VAR) VAR->VAR = &VAR; VAR(VAR, VAR); VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = 1; VAR->VAR = VAR; VAR->VAR = 0; VAR->VAR = VAR; VAR->VAR = VAR(VAR[1]); VAR->VAR = VAR(VAR[1]);  VAR = VAR(VAR); VAR->VAR = VAR;  VAR->VAR = 1;  VAR->VAR = 1;  VAR->VAR = 0;  VAR->VAR = 0;  VAR->VAR = 0;  VAR->VAR = 0;  VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = 0; VAR->VAR = 1; VAR->VAR = 0; VAR->VAR = 1; VAR->VAR = 0; VAR->VAR = 1 | VAR; VAR->VAR = 0; VAR->VAR = 0x03;  VAR->VAR = 230 - VAR;  VAR->VAR = 0; VAR->VAR = 1; VAR->VAR = VAR; VAR->VAR.VAR = VAR; VAR->VAR.VAR = VAR; VAR->VAR.VAR = 5; VAR(VAR->VAR.VAR, ""VAR"", 5); VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = 0; VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR->VAR = 0; VAR->VAR = VAR; VAR->VAR = 10 * VAR; VAR->VAR = VAR; VAR(VAR); VAR: VAR VAR; } /* * VAR VAR. * VAR: VAR VAR VAR VAR VAR. */ VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); /* * VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. */ VAR (VAR(&VAR->VAR)) VAR(VAR, VAR, 0); } /* * VAR VAR VAR/VAR VAR. * VAR VAR VAR VAR & VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR, VAR VAR VAR VAR VAR * VAR. VAR VAR VAR VAR VAR VAR VAR & VAR * VAR VAR VAR VAR. */ VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR->VAR = VAR(VAR); VAR (VAR->VAR) { VAR VAR: VAR(VAR, VAR, 0, VAR); VAR (VAR->VAR >= VAR) VAR->VAR = VAR; VAR 0; VAR VAR: VAR(VAR, VAR, 0, VAR); VAR (VAR->VAR >= VAR) VAR->VAR = VAR; VAR 0; VAR VAR: VAR (VAR->VAR < VAR) {  VAR(VAR, VAR, VAR, VAR); VAR 0; } } VAR->VAR = (VAR * VAR); VAR (VAR->VAR) VAR 0; VAR (VAR(VAR, VAR->VAR + VAR * VAR)) { VAR(VAR); VAR(VAR); VAR 1; } VAR 0; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR->VAR = 0;  VAR (VAR->VAR) { VAR (VAR->VAR->VAR != VAR) VAR->VAR->VAR = VAR; } VAR->VAR = VAR; VAR (VAR->VAR) { VAR VAR: VAR(VAR, VAR, VAR, VAR->VAR); VAR->VAR = VAR; VAR->VAR = VAR(VAR); VAR; VAR VAR: VAR->VAR = VAR; VAR VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR VAR: VAR: VAR(VAR, VAR, 0, VAR->VAR); VAR; VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR->VAR = VAR; VAR->VAR = VAR(VAR); VAR; VAR: VAR(VAR ""VAR: VAR VAR VAR VAR VAR VAR\VAR""); VAR; VAR VAR: VAR(VAR); VAR(VAR); VAR(VAR); VAR; } } VAR *VAR(VAR VAR, VAR *VAR) { VAR VAR VAR, VAR; VAR = VAR & 0x03ff; VAR = VAR >> 10; VAR(VAR, ""%VAR.%VAR"", VAR, VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR *VAR; VAR (VAR < 0 || VAR > VAR) VAR -VAR; VAR (!VAR(VAR, &VAR)) VAR -VAR; VAR (VAR->VAR) { VAR VAR: VAR (VAR != VAR) VAR -VAR; VAR; VAR VAR: VAR; VAR: VAR -VAR; } VAR ((VAR = VAR(VAR, VAR, VAR, VAR)) == VAR) VAR -VAR; VAR->VAR = VAR; VAR 0; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR (VAR) { VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); } VAR 0; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR *VAR = (VAR VAR *)VAR; VAR VAR *VAR, *VAR; VAR VAR; VAR (VAR != VAR(VAR VAR)) VAR -VAR; VAR (VAR->VAR != VAR) VAR -VAR; VAR (VAR(VAR->VAR) && (VAR(VAR->VAR) != 2)) VAR -VAR; VAR (VAR(VAR->VAR) > VAR) VAR -VAR; VAR (VAR->VAR & ~VAR) VAR -VAR; VAR (!VAR(VAR) && (VAR->VAR || (VAR->VAR & VAR))) VAR -VAR; VAR (!(VAR->VAR & VAR)) { VAR (VAR(VAR->VAR)) { VAR(); VAR = VAR; VAR(&VAR, VAR) { VAR (!VAR->VAR) VAR; VAR (VAR(VAR, VAR(VAR))) { VAR = VAR; VAR; } } VAR(); VAR (VAR == VAR) VAR -VAR; } } VAR = -VAR; VAR(VAR); VAR (VAR(VAR, VAR)) { VAR(&VAR->VAR, VAR, VAR); VAR(VAR, VAR); VAR = VAR(VAR); VAR (VAR) VAR(VAR, VAR); } VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR; VAR(VAR, VAR); VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; /* * VAR VAR VAR VAR VAR VAR VAR VAR'VAR * VAR. VAR VAR VAR VAR VAR VAR VAR VAR... */ VAR ((VAR->VAR.VAR != 0) && (VAR->VAR.VAR <= 12)) { VAR->VAR.VAR = VAR(VAR->VAR.VAR); VAR(VAR->VAR.VAR, VAR->VAR.VAR, VAR(VAR->VAR.VAR)); VAR->VAR.VAR = 0; VAR(VAR->VAR.VAR, 0, 40); }  VAR->VAR.VAR.VAR = VAR(2); VAR = VAR((VAR *)VAR->VAR.VAR.VAR); VAR (VAR == 0) { VAR = VAR(VAR); VAR (VAR) VAR(VAR, VAR); } VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR(VAR, VAR); VAR VAR; VAR (VAR->VAR != VAR) VAR -VAR; VAR->VAR = VAR; VAR->VAR = VAR(VAR(VAR)); VAR(VAR, VAR); VAR(VAR(VAR), &VAR); VAR(;;) { VAR(VAR); VAR (VAR->VAR == VAR) *VAR = VAR(&VAR, VAR, *VAR); VAR(VAR); VAR = 0; VAR (VAR->VAR == VAR) VAR; VAR = VAR(VAR); VAR (VAR) VAR; VAR = VAR(*VAR); VAR (VAR(VAR)) VAR; VAR = -VAR; VAR (!*VAR) VAR; } VAR(VAR(VAR), &VAR); VAR (VAR == 0) { VAR->VAR->VAR = VAR; } VAR VAR (VAR->VAR != VAR) { VAR->VAR->VAR = VAR; } VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR(VAR, VAR); VAR VAR = 0; VAR (VAR->VAR == VAR) VAR VAR; VAR (!*VAR) VAR -VAR; VAR(VAR(VAR), &VAR); VAR(;;) { VAR(VAR); VAR (VAR->VAR == VAR || VAR->VAR == VAR) *VAR = VAR(&VAR, VAR, *VAR); VAR(VAR); VAR = 0; VAR (VAR->VAR == VAR) VAR; VAR = VAR(VAR); VAR (VAR) VAR; VAR = VAR(*VAR); VAR (VAR(VAR)) VAR; VAR = -VAR; VAR (!*VAR) VAR; } VAR(VAR(VAR), &VAR); VAR: VAR (VAR == 0) { VAR->VAR->VAR = VAR; } VAR VAR (VAR->VAR != VAR && VAR->VAR != VAR) { VAR->VAR->VAR = VAR; } VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR = -VAR; VAR VAR VAR; VAR VAR *VAR; VAR (VAR->VAR == VAR) VAR VAR; VAR (VAR->VAR == VAR) { VAR = 0; VAR (VAR->VAR == VAR) { VAR->VAR = VAR; VAR VAR; } VAR = -VAR; VAR (VAR->VAR != VAR && VAR->VAR != VAR) { VAR->VAR = VAR; VAR VAR; } VAR VAR(VAR, VAR); } VAR = -VAR; VAR (VAR->VAR != VAR) VAR VAR; VAR (VAR == VAR || VAR != VAR(VAR VAR)) VAR VAR; VAR (VAR->VAR != VAR) VAR VAR; VAR (VAR->VAR & VAR) VAR VAR; VAR (VAR(VAR, VAR)) { VAR = VAR(VAR->VAR); VAR (VAR) VAR VAR; } VAR(&VAR->VAR, VAR, VAR(VAR VAR)); VAR = -VAR; VAR(&VAR, 0, VAR(VAR)); VAR.VAR = VAR->VAR; VAR.VAR = VAR(&VAR->VAR); VAR.VAR = VAR(&VAR->VAR); VAR(&VAR, VAR); VAR.VAR = VAR; VAR (VAR(&VAR->VAR, &VAR, VAR, VAR) < 0) VAR VAR; VAR = VAR(VAR); VAR->VAR = VAR->VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR(VAR); VAR(VAR, VAR); VAR = -VAR; VAR (*VAR) { VAR = VAR(VAR, VAR); } VAR: VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR *VAR = (VAR VAR *)VAR; VAR VAR *VAR = VAR->VAR; VAR VAR; VAR VAR = VAR(VAR, VAR & VAR); VAR(VAR); VAR = VAR(VAR, VAR, VAR, &VAR, 0); VAR(VAR); VAR VAR; } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR->VAR) { VAR VAR: VAR 0; VAR VAR: VAR VAR(VAR, VAR, VAR->VAR); VAR VAR: VAR VAR: VAR VAR(VAR, VAR); VAR VAR: VAR VAR(VAR, VAR, VAR, VAR, VAR); } VAR -VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR->VAR = *VAR++; VAR(&VAR->VAR, VAR, VAR->VAR); VAR += VAR->VAR; VAR->VAR = *VAR++; VAR(&VAR->VAR, VAR, VAR->VAR); VAR += VAR->VAR; VAR->VAR = *VAR++; VAR(&VAR->VAR, VAR, VAR->VAR); VAR(VAR, VAR->VAR + VAR->VAR + VAR->VAR + 3); } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR = *VAR++;  VAR(VAR > 16);  VAR->VAR = VAR(VAR); VAR->VAR = 0; VAR(VAR->VAR, VAR, VAR); VAR(VAR, VAR + 1); } VAR VAR VAR *VAR(VAR VAR *VAR, VAR *VAR) { VAR(VAR, VAR); VAR VAR *VAR = VAR; VAR VAR = 0; VAR(VAR(VAR), &VAR); VAR(;;) { VAR(VAR); VAR = VAR(&VAR->VAR); VAR (VAR == VAR) { *VAR = VAR(&VAR, VAR, *VAR); VAR = VAR(&VAR->VAR); } VAR(VAR); VAR (VAR != VAR) VAR; VAR = -VAR; VAR (VAR->VAR != VAR) VAR; VAR = VAR(*VAR); VAR (VAR(VAR)) VAR; VAR = -VAR; VAR (!*VAR) VAR; } VAR(VAR(VAR), &VAR); VAR VAR == VAR ? VAR(VAR) : VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR *VAR = VAR->VAR, *VAR; VAR VAR *VAR = VAR; VAR VAR *VAR; VAR VAR VAR; VAR VAR = 0; VAR VAR VAR; VAR VAR = VAR(VAR, VAR & VAR); VAR VAR *VAR; VAR(VAR); VAR (VAR->VAR != VAR || VAR(VAR)->VAR != VAR) { VAR(VAR); VAR -VAR; } VAR = VAR(&VAR->VAR); VAR (VAR == VAR) { VAR = VAR(VAR, &VAR); VAR (VAR(VAR)) { VAR(VAR); VAR VAR(VAR); } } VAR = VAR(VAR); VAR(VAR); VAR = VAR(VAR(VAR), VAR, VAR->VAR, VAR); VAR (VAR == VAR) { VAR(VAR); VAR(VAR); VAR -VAR; } VAR(VAR); VAR = VAR(VAR); VAR(VAR, VAR); VAR(VAR, VAR); VAR(VAR)->VAR = VAR; VAR(VAR)->VAR = VAR->VAR; VAR(VAR)->VAR = VAR->VAR; VAR(VAR)->VAR = VAR->VAR; VAR(VAR)->VAR = VAR->VAR; VAR(VAR)->VAR = VAR(VAR)->VAR; VAR (VAR(VAR)->VAR < 230) VAR(VAR)->VAR = 230; VAR ((VAR(VAR)->VAR & VAR) == VAR) VAR(VAR)->VAR = VAR; VAR->VAR = VAR; VAR(&(VAR(VAR)->VAR), &(VAR(VAR)->VAR), VAR(VAR VAR)); /* * VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR'VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR(VAR)->VAR.VAR &= ~VAR; VAR(VAR, VAR(VAR->VAR, VAR->VAR, &(VAR(VAR)->VAR), &VAR)); VAR(VAR, VAR(VAR->VAR, VAR->VAR, &(VAR(VAR)->VAR), &VAR)); *(VAR *)(VAR(VAR)->VAR.VAR.VAR) = VAR->VAR; *(VAR *)(VAR(VAR)->VAR.VAR.VAR) = VAR->VAR; VAR = *VAR->VAR; VAR(VAR, 1); VAR (VAR & VAR) VAR(VAR, &(VAR(VAR)->VAR)); VAR (VAR & VAR) VAR(VAR, &(VAR(VAR)->VAR)); VAR (VAR & VAR) VAR(VAR)->VAR.VAR |= VAR; VAR (VAR & VAR) VAR(VAR)->VAR.VAR |= VAR; VAR(VAR); VAR(&(VAR(VAR)->VAR), &(VAR(VAR)->VAR), VAR(VAR VAR)); VAR(&(VAR(VAR)->VAR), &(VAR(VAR)->VAR), VAR(VAR VAR)); VAR(VAR); VAR = VAR(VAR); VAR (VAR == 0) { VAR(VAR, VAR); VAR(VAR); /* * VAR VAR VAR VAR->VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR, VAR VAR VAR VAR VAR VAR. */ VAR (VAR(VAR)->VAR == VAR) VAR = VAR(VAR, &VAR, VAR->VAR); } VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR,VAR VAR) { VAR VAR *VAR = (VAR VAR *)VAR; VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR(VAR); VAR (VAR) { VAR ((VAR->VAR != VAR && VAR->VAR != VAR) && VAR->VAR == VAR) { VAR(VAR); VAR -VAR; } VAR(VAR, &VAR->VAR, VAR(VAR VAR)); } VAR { VAR(VAR, &VAR->VAR, VAR(VAR VAR)); } VAR(VAR); VAR VAR(VAR VAR); } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR = VAR(VAR, VAR, VAR); VAR (!VAR(&VAR->VAR)) VAR |= VAR; VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR = -VAR; VAR VAR = 0; VAR VAR *VAR; VAR VAR; VAR(VAR) { VAR VAR: VAR VAR: VAR VAR(VAR, (VAR VAR *)VAR); VAR VAR: VAR(VAR); VAR = !VAR(&VAR->VAR); VAR (VAR->VAR != VAR) VAR = -VAR; VAR(VAR); VAR VAR; VAR VAR: VAR = VAR->VAR - VAR(VAR); VAR (VAR < 0) VAR = 0; VAR = VAR(VAR, (VAR VAR *)VAR); VAR; VAR VAR: VAR(VAR); VAR = VAR(&VAR->VAR); VAR (VAR) { VAR = VAR->VAR; } VAR { VAR(&VAR->VAR, VAR) VAR += VAR->VAR; } VAR(VAR); VAR = VAR(VAR, (VAR VAR *)VAR); VAR; VAR: VAR = -VAR; VAR; } VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR = -VAR; VAR(VAR); VAR (VAR(VAR, VAR)) VAR VAR; VAR ((VAR(VAR)->VAR != VAR) || (VAR->VAR == VAR)) VAR VAR; VAR->VAR = VAR; VAR->VAR = 0; VAR->VAR = VAR; VAR = 0; VAR(VAR); VAR: VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR = -VAR; VAR(VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR = 0; VAR (VAR->VAR == VAR) VAR VAR; VAR = -VAR; VAR (VAR->VAR == VAR) VAR VAR; VAR (VAR != VAR) VAR VAR; VAR->VAR = VAR; VAR(VAR); VAR = 0; VAR: VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR; VAR(VAR); VAR = VAR(VAR, VAR, VAR, VAR, VAR, 0); VAR(VAR);   VAR (VAR == -VAR && VAR != VAR && VAR != VAR && VAR != VAR) VAR = VAR(VAR, VAR, VAR, VAR, VAR);  VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR VAR, VAR VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR; VAR { VAR VAR VAR; VAR VAR VAR; VAR VAR; VAR VAR VAR; VAR VAR; VAR VAR VAR; VAR VAR VAR; } VAR; VAR VAR; VAR (VAR && VAR(VAR)) VAR -VAR; VAR (VAR > VAR(VAR)) VAR -VAR; VAR (VAR(&VAR, VAR, VAR)) VAR -VAR; VAR (VAR) { VAR VAR: VAR (VAR->VAR == VAR) VAR -VAR; VAR ((VAR->VAR != VAR) && (VAR->VAR != VAR)) VAR -VAR; VAR (VAR != VAR(VAR VAR)) VAR -VAR; VAR (VAR(VAR.VAR.VAR) > 16) VAR -VAR; VAR(&VAR->VAR, &VAR.VAR, VAR); VAR; VAR VAR: VAR (VAR->VAR != VAR && VAR->VAR == VAR) VAR -VAR; VAR (VAR != VAR(VAR VAR)) VAR -VAR; VAR (VAR(VAR.VAR.VAR) > 16) VAR -VAR; VAR(&VAR->VAR, &VAR.VAR, VAR); VAR; VAR VAR: VAR (VAR->VAR == VAR) VAR -VAR; VAR (VAR->VAR != VAR) VAR -VAR; VAR (VAR != VAR(VAR VAR)) VAR -VAR; VAR ((VAR.VAR.VAR > VAR) || (VAR.VAR.VAR > VAR) || (VAR.VAR.VAR > VAR)) VAR -VAR; VAR(&VAR->VAR, &VAR.VAR, VAR); VAR; VAR VAR: VAR (VAR->VAR == VAR) VAR -VAR; VAR (VAR->VAR != VAR) VAR -VAR; VAR (VAR != VAR(VAR)) VAR -VAR; VAR ((VAR.VAR != VAR) && (VAR.VAR != VAR)) VAR -VAR; VAR->VAR = (VAR VAR)VAR.VAR; VAR; VAR VAR: VAR (VAR->VAR != VAR) VAR -VAR; VAR = VAR(VAR, 0); VAR = VAR(VAR, &VAR, VAR->VAR); VAR VAR; VAR VAR: VAR (VAR->VAR != VAR) VAR -VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR(VAR, 0x38, 0, VAR->VAR); VAR; VAR VAR: VAR (VAR != VAR(VAR VAR)) VAR -VAR; VAR (VAR.VAR > VAR) VAR.VAR = VAR; VAR (VAR.VAR == 0) VAR -VAR; VAR->VAR = VAR.VAR; VAR (VAR->VAR > VAR.VAR) VAR->VAR = VAR.VAR; VAR; VAR VAR: VAR (VAR != VAR(VAR)) VAR -VAR; VAR (VAR->VAR == VAR) VAR -VAR; VAR->VAR = (VAR.VAR == 0) ? 0 : VAR;  VAR; VAR VAR: VAR (VAR != VAR(VAR)) VAR -VAR; VAR (VAR->VAR == VAR) VAR -VAR; VAR->VAR = (VAR.VAR == 0) ? 0 : VAR;  VAR; VAR VAR: VAR (VAR != VAR(VAR VAR)) VAR -VAR; VAR ((VAR.VAR & ~VAR) != 0x01) VAR -VAR; VAR ((VAR.VAR & VAR) == VAR) VAR -VAR; VAR->VAR = VAR.VAR; VAR; VAR VAR: VAR (VAR != VAR(VAR VAR)) VAR -VAR; VAR (VAR.VAR & 0xfc) VAR -VAR; VAR->VAR = VAR.VAR; VAR; VAR VAR: VAR VAR: VAR VAR: VAR: VAR -VAR; } VAR 0; } VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR; VAR(VAR); VAR = VAR(VAR, VAR, VAR, VAR, VAR, 0); VAR(VAR);  VAR (VAR == -VAR && VAR != VAR && VAR != VAR && VAR != VAR && VAR != VAR) { VAR VAR; VAR (VAR(VAR, VAR)) VAR -VAR; VAR = VAR(VAR, VAR, VAR, VAR, &VAR); VAR (VAR >= 0) VAR = VAR(VAR, VAR); }  VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR,VAR VAR, VAR VAR *VAR,VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR VAR; VAR VAR VAR; VAR *VAR = VAR; VAR VAR VAR; VAR(VAR(VAR , VAR)) VAR -VAR; VAR (VAR) { VAR VAR: VAR (VAR > VAR(VAR VAR)) VAR = VAR(VAR VAR); VAR = &VAR->VAR; VAR; VAR VAR: VAR (VAR > VAR(VAR VAR)) VAR = VAR(VAR VAR); VAR = &VAR->VAR; VAR; VAR VAR: VAR (VAR > VAR(VAR VAR)) VAR = VAR(VAR VAR); VAR = &VAR->VAR; VAR; VAR VAR: VAR (VAR > VAR(VAR VAR)) VAR = VAR(VAR VAR); VAR = &VAR->VAR; VAR; VAR VAR: VAR (VAR > VAR(VAR VAR)) VAR = VAR(VAR VAR); VAR(&VAR, 0, VAR(VAR)); VAR (VAR->VAR) { VAR VAR: VAR.VAR = VAR; VAR; VAR VAR: VAR.VAR = VAR; VAR; VAR VAR: VAR.VAR = VAR; VAR; VAR: VAR.VAR = VAR; } VAR.VAR = VAR->VAR; VAR = &VAR; VAR; VAR VAR: VAR (VAR > VAR(VAR VAR)) VAR = VAR(VAR VAR); VAR = &VAR->VAR; VAR; VAR VAR: VAR (VAR > VAR(VAR)) VAR = VAR(VAR); VAR = (VAR->VAR == VAR); VAR = &VAR; VAR; VAR VAR: VAR (VAR > VAR(VAR)) VAR = VAR(VAR); VAR = (VAR->VAR == VAR); VAR = &VAR; VAR; VAR VAR: VAR (VAR > VAR(VAR VAR)) VAR = VAR(VAR VAR); VAR = &VAR->VAR; VAR; VAR VAR: VAR (VAR > VAR(VAR VAR)) VAR = VAR(VAR VAR); VAR = &VAR->VAR; VAR; VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR: VAR -VAR; } VAR (VAR) { VAR (VAR(VAR, VAR, VAR)) VAR -VAR; VAR (VAR(VAR, VAR)) VAR -VAR; } VAR 0; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR *VAR; VAR VAR = 0; VAR (VAR & VAR) VAR !VAR(VAR) ? 1 : 0; VAR(VAR, VAR) { VAR VAR *VAR = VAR(VAR); VAR += VAR->VAR; VAR (VAR->VAR & 0x40) {  VAR (VAR->VAR == VAR) VAR 1;  VAR (!(VAR & VAR)) VAR 1; }  VAR (VAR >= VAR) VAR 1; } VAR 0; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR *VAR = &VAR->VAR; VAR VAR = VAR > 1 ? 1 : 0; VAR VAR = 0; VAR VAR = 0; VAR VAR *VAR, *VAR; VAR VAR *VAR = VAR; VAR VAR VAR = 0; VAR VAR = VAR(VAR, VAR & VAR); VAR(VAR); VAR (VAR(VAR, VAR)) { VAR = -VAR; VAR VAR; } VAR (VAR->VAR & VAR) { VAR = 0; VAR VAR; } VAR = VAR(VAR, VAR, 0, &VAR, VAR); VAR (VAR) VAR VAR; VAR (VAR & ~(VAR|VAR|VAR|VAR|VAR|VAR)) { VAR = -VAR; VAR VAR; } VAR (VAR & VAR) VAR = &VAR->VAR; VAR (VAR & VAR) VAR = VAR; /* * VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR'VAR */ VAR(;;) { VAR(VAR, VAR); VAR (VAR->VAR) VAR VAR; VAR (!VAR(&VAR->VAR)) { VAR (!(VAR & VAR)) { VAR->VAR |= VAR; VAR (!VAR->VAR) { VAR->VAR = 1; VAR VAR; } } } VAR (VAR->VAR != VAR) VAR VAR; VAR (VAR(VAR)) { VAR = VAR(VAR); VAR VAR; } VAR (VAR(VAR, VAR, VAR, VAR)) VAR; VAR (VAR & VAR) { VAR = -VAR; VAR VAR; } VAR(VAR(VAR), &VAR); VAR(VAR, VAR); VAR(VAR, &VAR, VAR(VAR, VAR, VAR, VAR), &VAR); VAR(VAR, VAR); VAR(VAR(VAR), &VAR); } VAR(VAR, VAR, VAR) { VAR VAR VAR = VAR->VAR; VAR = VAR(VAR); VAR ((VAR + VAR) > VAR) VAR = VAR - VAR; VAR (VAR(VAR, VAR->VAR, VAR)) { VAR = -VAR; VAR; } VAR += VAR; VAR (!(VAR & VAR)) VAR(VAR, VAR); VAR = VAR->VAR & 0x40; VAR (VAR->VAR == 0) { VAR(VAR, VAR); VAR(VAR); /* * VAR.VAR. VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. */ VAR ((VAR->VAR == VAR) && !VAR(VAR)) { VAR->VAR = VAR; VAR(VAR, VAR, 0); } } VAR (VAR) { VAR (VAR->VAR == VAR) VAR; VAR (!(VAR & VAR)) VAR; } VAR (VAR & VAR) VAR; VAR (VAR >= VAR) VAR; } VAR = VAR; VAR (VAR && (VAR->VAR == VAR)) VAR->VAR |= VAR; VAR: VAR (VAR == 0) VAR = (VAR & VAR) ? -VAR->VAR : VAR(VAR); VAR ((VAR >= 0) && VAR->VAR) { VAR(VAR(VAR VAR)); VAR(VAR->VAR, &VAR->VAR, VAR(VAR VAR)); VAR->VAR = VAR(VAR VAR); } VAR(VAR); VAR VAR; } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR VAR = VAR->VAR & VAR; VAR (VAR(VAR) >= VAR->VAR) VAR 1; VAR (VAR != VAR) { VAR (VAR & VAR) { VAR (VAR->VAR == 0) VAR 1; } VAR { VAR (VAR->VAR == 0) VAR 1; } } VAR 0; } /* * VAR VAR VAR VAR VAR VAR ""VAR VAR"" VAR VAR VAR * VAR VAR VAR 230 VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR * VAR (VAR VAR) VAR VAR VAR 16 VAR VAR VAR VAR VAR VAR'VAR * VAR VAR VAR VAR. */ VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR VAR VAR = 230 - VAR; VAR (VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR -= VAR(VAR); VAR (VAR->VAR) VAR -= 21; VAR VAR -= 6; VAR -= VAR; } VAR { /* * 21 = VAR VAR, 16 = VAR VAR VAR VAR VAR */ VAR -= (21 + VAR + 16); } VAR (VAR > VAR) VAR = VAR; VAR VAR; } VAR VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR = VAR(VAR); VAR VAR = VAR(VAR, VAR->VAR, VAR->VAR);  VAR (VAR & VAR) VAR 16;  VAR (VAR) { VAR VAR = VAR(VAR); VAR = VAR(VAR, VAR(VAR->VAR, VAR), VAR); } VAR VAR; } /* * VAR.VAR. VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, * VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR. */ VAR VAR VAR VAR *VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR, VAR *VAR) { VAR VAR *VAR = VAR(VAR, VAR, VAR, VAR); VAR (VAR) { VAR->VAR = VAR(VAR); VAR->VAR = VAR; } VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR; VAR VAR *VAR = &VAR->VAR; VAR VAR = VAR->VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR = VAR->VAR; VAR(VAR VAR *, VAR, VAR->VAR); VAR VAR *VAR = VAR; VAR VAR *VAR; VAR VAR; VAR VAR VAR; VAR VAR; VAR (VAR & ~(VAR|VAR|VAR|VAR|VAR|VAR|VAR)) VAR -VAR; VAR (VAR && (VAR != VAR(VAR VAR))) VAR -VAR; VAR(VAR); VAR = VAR(VAR, VAR & VAR); /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR. */ VAR (VAR->VAR == VAR) { VAR (VAR & VAR) { VAR = -VAR; VAR VAR; } VAR |= VAR; } VAR = VAR(VAR, VAR, VAR, &VAR, VAR); VAR (VAR) VAR VAR; VAR (VAR->VAR & VAR) { VAR = -VAR; VAR (!(VAR & VAR)) VAR(VAR, VAR, 0); VAR VAR; } VAR ((VAR & VAR) && VAR->VAR) VAR(VAR); VAR = VAR->VAR; VAR = VAR->VAR & VAR; VAR = VAR(VAR, VAR); VAR (VAR & VAR) { VAR = &VAR->VAR; VAR (VAR > VAR) { VAR = -VAR; VAR VAR; } } VAR->VAR = VAR; VAR(VAR < VAR) { VAR = VAR(VAR); VAR (VAR) VAR VAR; VAR (VAR(VAR)) { VAR = VAR(VAR); VAR VAR; } /* * VAR VAR VAR VAR VAR VAR VAR. */ VAR = VAR - VAR; VAR (VAR > VAR) VAR = VAR; /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. */ VAR (VAR(VAR, VAR, VAR)) { VAR(VAR, VAR); VAR (VAR & VAR) { VAR = -VAR; VAR VAR; } VAR(VAR(VAR), &VAR); VAR(VAR, VAR); VAR(VAR, &VAR, !VAR(VAR, VAR, VAR), &VAR); VAR(VAR, VAR); VAR(VAR(VAR), &VAR); VAR; } /* * VAR VAR VAR VAR VAR. * 64 VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR * VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR. */ VAR = VAR(VAR, VAR + 64 + VAR, VAR & VAR, &VAR); VAR (VAR) VAR; VAR (!VAR) VAR; VAR = VAR(VAR); VAR(VAR, 64 + VAR); VAR (VAR(VAR(VAR, VAR), VAR, VAR)) { VAR = -VAR; VAR VAR; } VAR (VAR & VAR) { VAR->VAR = 0x30; VAR (VAR != VAR) VAR->VAR--; } VAR { VAR->VAR = 0x00; VAR (VAR->VAR == 0) VAR->VAR |= 0x20; VAR->VAR += VAR; VAR (((VAR + VAR) == VAR) && (VAR & VAR)) { VAR->VAR |= 0x40; VAR->VAR = 0; VAR (VAR == VAR) VAR->VAR--; } VAR (VAR == VAR) VAR->VAR--; } VAR += VAR; VAR(VAR, VAR, VAR->VAR, VAR & VAR); VAR = VAR; VAR->VAR = VAR(VAR); } VAR: VAR(VAR); VAR(VAR); VAR VAR ? VAR : VAR; VAR: VAR = VAR(VAR, VAR, VAR); VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR (!VAR(VAR(VAR), &VAR)) VAR VAR; VAR (VAR) { VAR VAR: VAR(VAR); VAR; VAR VAR: VAR(VAR); VAR; VAR: VAR; } VAR VAR; } VAR VAR VAR VAR = { .VAR = VAR, }; VAR VAR VAR VAR VAR = { .VAR = VAR(VAR), .VAR = VAR, };  VAR VAR { VAR VAR; }; VAR VAR VAR *VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR; VAR(VAR->VAR = 0; VAR->VAR < VAR; ++VAR->VAR) { VAR = VAR(&VAR[VAR->VAR]); VAR (VAR) VAR; } VAR VAR; } VAR VAR VAR *VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR = VAR(VAR); VAR (!VAR) { VAR (++VAR->VAR >= VAR) VAR; VAR = VAR(&VAR[VAR->VAR]); } VAR VAR; } VAR VAR VAR *VAR(VAR VAR *VAR, VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR) { VAR(*VAR && (VAR = VAR(VAR, VAR))) --*VAR; } VAR *VAR ? VAR : VAR; } VAR VAR *VAR(VAR VAR *VAR, VAR VAR) { VAR *VAR; VAR(&VAR); VAR = VAR(VAR, &VAR); VAR (!VAR) { VAR(&VAR); } VAR VAR; } VAR VAR *VAR(VAR VAR *VAR, VAR *VAR) { VAR *VAR ? VAR(VAR, *VAR - 1) : VAR; } VAR VAR *VAR(VAR VAR *VAR, VAR *VAR, VAR *VAR) { VAR *VAR; VAR (VAR == VAR) { VAR = VAR(VAR, 0); VAR VAR; } VAR = VAR(VAR, VAR); VAR (VAR) VAR VAR; VAR(&VAR); VAR: ++*VAR; VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR *VAR) { VAR (VAR && VAR != VAR) VAR(&VAR); }  VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR VAR; VAR (VAR(VAR->VAR)) { VAR 0: VAR(VAR, ""%VAR"", VAR->VAR); VAR; VAR: VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR[VAR] = VAR->VAR[VAR]; VAR (VAR(VAR[VAR])) VAR[VAR] = '.'; } VAR[VAR] = 0; } } VAR VAR *VAR(VAR VAR VAR) { VAR (VAR) { VAR VAR: VAR ""VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; VAR VAR: VAR "" VAR""; } VAR ""????""; } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR[VAR]; VAR VAR[VAR]; VAR VAR[VAR+3]; VAR VAR[VAR+3]; VAR(&VAR->VAR, VAR); VAR(&VAR->VAR, VAR); VAR(VAR, ""%6s/%04X %04d:%04d %04d:%04d %01d %-16s "" ""%6s/%04X %04d:%04d %04d:%04d %01d %-16s %4s %VAR\VAR"", VAR(VAR(VAR(&VAR->VAR)), VAR), VAR->VAR, VAR->VAR, VAR->VAR, VAR->VAR, VAR->VAR, VAR->VAR, VAR, VAR(VAR(VAR(&VAR->VAR)), VAR), VAR->VAR, VAR->VAR, VAR->VAR, VAR->VAR, VAR->VAR, VAR->VAR, VAR, VAR(VAR->VAR), ((VAR->VAR == VAR) ? ""VAR"" : ""VAR"")); } VAR VAR VAR(VAR VAR *VAR, VAR *VAR) { VAR (VAR == VAR) { VAR(VAR, ""VAR VAR\VAR""); } VAR { VAR(VAR, VAR); } VAR 0; } VAR VAR VAR VAR VAR = { .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, };  VAR VAR VAR VAR VAR = { .VAR = VAR, .VAR = VAR, .VAR = VAR, }; VAR VAR VAR VAR VAR = { .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, }; VAR(""VAR VAR VAR VAR VAR""); VAR(""VAR VAR VAR VAR""); VAR(""VAR""); VAR(VAR); VAR VAR VAR VAR[] VAR = VAR ""VAR: VAR VAR VAR: VAR.2.5.68s (VAR) 1995-2003 VAR VAR VAR VAR\VAR""; VAR VAR VAR VAR(VAR) { VAR VAR; VAR(VAR); VAR = VAR(&VAR, 1); VAR (VAR != 0) VAR VAR; VAR(); VAR(); VAR(); VAR(); VAR(&VAR); VAR(&VAR); VAR(&VAR); VAR(""VAR"", 0444, VAR.VAR, &VAR, VAR(VAR VAR), VAR); VAR(); VAR: VAR VAR; } VAR(VAR); /* * VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR. */  VAR VAR VAR VAR(VAR) { VAR(VAR); VAR(VAR); VAR(&VAR); VAR(); VAR(&VAR); VAR(); VAR(); VAR(); VAR(); VAR(""VAR"", VAR.VAR); VAR(&VAR); VAR();  } VAR(VAR); ",1
linux_1202cdd665315c525b5237e96e0bedc76d7e754f,net/decnet/dn_fib.c,,"// SPDX-License-Identifier: GPL-2.0
/*
 * DECnet       An implementation of the DECnet protocol suite for the LINUX
 *              operating system.  DECnet is implemented using the  BSD Socket
 *              interface as the means of communication with the user level.
 *
 *              DECnet Routing Forwarding Information Base (Glue/Info List)
 *
 * Author:      Steve Whitehouse <SteveW@ACM.org>
 *
 *
 * Changes:
 *              Alexey Kuznetsov : SMP locking changes
 *              Steve Whitehouse : Rewrote it... Well to be more correct, I
 *                                 copied most of it from the ipv4 fib code.
 *              Steve Whitehouse : Updated it in style and fixed a few bugs
 *                                 which were fixed in the ipv4 code since
 *                                 this code was copied from it.
 *
 */
#include <linux/string.h>
#include <linux/net.h>
#include <linux/socket.h>
#include <linux/slab.h>
#include <linux/sockios.h>
#include <linux/init.h>
#include <linux/skbuff.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/proc_fs.h>
#include <linux/netdevice.h>
#include <linux/timer.h>
#include <linux/spinlock.h>
#include <linux/atomic.h>
#include <linux/uaccess.h>
#include <net/neighbour.h>
#include <net/dst.h>
#include <net/flow.h>
#include <net/fib_rules.h>
#include <net/dn.h>
#include <net/dn_route.h>
#include <net/dn_fib.h>
#include <net/dn_neigh.h>
#include <net/dn_dev.h>
#include <net/rtnh.h>

#define RT_MIN_TABLE 1

#define for_fib_info() { struct dn_fib_info *fi;\
	for(fi = dn_fib_info_list; fi; fi = fi->fib_next)
#define endfor_fib_info() }

#define for_nexthops(fi) { int nhsel; const struct dn_fib_nh *nh;\
	for(nhsel = 0, nh = (fi)->fib_nh; nhsel < (fi)->fib_nhs; nh++, nhsel++)

#define change_nexthops(fi) { int nhsel; struct dn_fib_nh *nh;\
	for(nhsel = 0, nh = (struct dn_fib_nh *)((fi)->fib_nh); nhsel < (fi)->fib_nhs; nh++, nhsel++)

#define endfor_nexthops(fi) }

static DEFINE_SPINLOCK(dn_fib_multipath_lock);
static struct dn_fib_info *dn_fib_info_list;
static DEFINE_SPINLOCK(dn_fib_info_lock);

static struct
{
	int error;
	u8 scope;
} dn_fib_props[RTN_MAX+1] = {
	[RTN_UNSPEC] =      { .error = 0,       .scope = RT_SCOPE_NOWHERE },
	[RTN_UNICAST] =     { .error = 0,       .scope = RT_SCOPE_UNIVERSE },
	[RTN_LOCAL] =       { .error = 0,       .scope = RT_SCOPE_HOST },
	[RTN_BROADCAST] =   { .error = -EINVAL, .scope = RT_SCOPE_NOWHERE },
	[RTN_ANYCAST] =     { .error = -EINVAL, .scope = RT_SCOPE_NOWHERE },
	[RTN_MULTICAST] =   { .error = -EINVAL, .scope = RT_SCOPE_NOWHERE },
	[RTN_BLACKHOLE] =   { .error = -EINVAL, .scope = RT_SCOPE_UNIVERSE },
	[RTN_UNREACHABLE] = { .error = -EHOSTUNREACH, .scope = RT_SCOPE_UNIVERSE },
	[RTN_PROHIBIT] =    { .error = -EACCES, .scope = RT_SCOPE_UNIVERSE },
	[RTN_THROW] =       { .error = -EAGAIN, .scope = RT_SCOPE_UNIVERSE },
	[RTN_NAT] =         { .error = 0,       .scope = RT_SCOPE_NOWHERE },
	[RTN_XRESOLVE] =    { .error = -EINVAL, .scope = RT_SCOPE_NOWHERE },
};

static int dn_fib_sync_down(__le16 local, struct net_device *dev, int force);
static int dn_fib_sync_up(struct net_device *dev);

void dn_fib_free_info(struct dn_fib_info *fi)
{
	if (fi->fib_dead == 0) {
		printk(KERN_DEBUG ""DECnet: BUG! Attempt to free alive dn_fib_info\n"");
		return;
	}

	change_nexthops(fi) {
		dev_put(nh->nh_dev);
		nh->nh_dev = NULL;
	} endfor_nexthops(fi);
	kfree(fi);
}

void dn_fib_release_info(struct dn_fib_info *fi)
{
	spin_lock(&dn_fib_info_lock);
	if (fi && refcount_dec_and_test(&fi->fib_treeref)) {
		if (fi->fib_next)
			fi->fib_next->fib_prev = fi->fib_prev;
		if (fi->fib_prev)
			fi->fib_prev->fib_next = fi->fib_next;
		if (fi == dn_fib_info_list)
			dn_fib_info_list = fi->fib_next;
		fi->fib_dead = 1;
		dn_fib_info_put(fi);
	}
	spin_unlock(&dn_fib_info_lock);
}

static inline int dn_fib_nh_comp(const struct dn_fib_info *fi, const struct dn_fib_info *ofi)
{
	const struct dn_fib_nh *onh = ofi->fib_nh;

	for_nexthops(fi) {
		if (nh->nh_oif != onh->nh_oif ||
			nh->nh_gw != onh->nh_gw ||
			nh->nh_scope != onh->nh_scope ||
			nh->nh_weight != onh->nh_weight ||
			((nh->nh_flags^onh->nh_flags)&~RTNH_F_DEAD))
				return -1;
		onh++;
	} endfor_nexthops(fi);
	return 0;
}

static inline struct dn_fib_info *dn_fib_find_info(const struct dn_fib_info *nfi)
{
	for_fib_info() {
		if (fi->fib_nhs != nfi->fib_nhs)
			continue;
		if (nfi->fib_protocol == fi->fib_protocol &&
			nfi->fib_prefsrc == fi->fib_prefsrc &&
			nfi->fib_priority == fi->fib_priority &&
			memcmp(nfi->fib_metrics, fi->fib_metrics, sizeof(fi->fib_metrics)) == 0 &&
			((nfi->fib_flags^fi->fib_flags)&~RTNH_F_DEAD) == 0 &&
			(nfi->fib_nhs == 0 || dn_fib_nh_comp(fi, nfi) == 0))
				return fi;
	} endfor_fib_info();
	return NULL;
}

static int dn_fib_count_nhs(const struct nlattr *attr)
{
	struct rtnexthop *nhp = nla_data(attr);
	int nhs = 0, nhlen = nla_len(attr);

	while (rtnh_ok(nhp, nhlen)) {
		nhs++;
		nhp = rtnh_next(nhp, &nhlen);
	}

	/* leftover implies invalid nexthop configuration, discard it */
	return nhlen > 0 ? 0 : nhs;
}

static int dn_fib_get_nhs(struct dn_fib_info *fi, const struct nlattr *attr,
			  const struct rtmsg *r)
{
	struct rtnexthop *nhp = nla_data(attr);
	int nhlen = nla_len(attr);

	change_nexthops(fi) {
		int attrlen;

		if (!rtnh_ok(nhp, nhlen))
			return -EINVAL;

		nh->nh_flags  = (r->rtm_flags&~0xFF) | nhp->rtnh_flags;
		nh->nh_oif    = nhp->rtnh_ifindex;
		nh->nh_weight = nhp->rtnh_hops + 1;

		attrlen = rtnh_attrlen(nhp);
		if (attrlen > 0) {
			struct nlattr *gw_attr;

			gw_attr = nla_find((struct nlattr *) (nhp + 1), attrlen, RTA_GATEWAY);
			nh->nh_gw = gw_attr ? nla_get_le16(gw_attr) : 0;
		}

		nhp = rtnh_next(nhp, &nhlen);
	} endfor_nexthops(fi);

	return 0;
}


static int dn_fib_check_nh(const struct rtmsg *r, struct dn_fib_info *fi, struct dn_fib_nh *nh)
{
	int err;

	if (nh->nh_gw) {
		struct flowidn fld;
		struct dn_fib_res res;

		if (nh->nh_flags&RTNH_F_ONLINK) {
			struct net_device *dev;

			if (r->rtm_scope >= RT_SCOPE_LINK)
				return -EINVAL;
			if (dnet_addr_type(nh->nh_gw) != RTN_UNICAST)
				return -EINVAL;
			if ((dev = __dev_get_by_index(&init_net, nh->nh_oif)) == NULL)
				return -ENODEV;
			if (!(dev->flags&IFF_UP))
				return -ENETDOWN;
			nh->nh_dev = dev;
			dev_hold(dev);
			nh->nh_scope = RT_SCOPE_LINK;
			return 0;
		}

		memset(&fld, 0, sizeof(fld));
		fld.daddr = nh->nh_gw;
		fld.flowidn_oif = nh->nh_oif;
		fld.flowidn_scope = r->rtm_scope + 1;

		if (fld.flowidn_scope < RT_SCOPE_LINK)
			fld.flowidn_scope = RT_SCOPE_LINK;

		if ((err = dn_fib_lookup(&fld, &res)) != 0)
			return err;

		err = -EINVAL;
		if (res.type != RTN_UNICAST && res.type != RTN_LOCAL)
			goto out;
		nh->nh_scope = res.scope;
		nh->nh_oif = DN_FIB_RES_OIF(res);
		nh->nh_dev = DN_FIB_RES_DEV(res);
		if (nh->nh_dev == NULL)
			goto out;
		dev_hold(nh->nh_dev);
		err = -ENETDOWN;
		if (!(nh->nh_dev->flags & IFF_UP))
			goto out;
		err = 0;
out:
		dn_fib_res_put(&res);
		return err;
	} else {
		struct net_device *dev;

		if (nh->nh_flags&(RTNH_F_PERVASIVE|RTNH_F_ONLINK))
			return -EINVAL;

		dev = __dev_get_by_index(&init_net, nh->nh_oif);
		if (dev == NULL || dev->dn_ptr == NULL)
			return -ENODEV;
		if (!(dev->flags&IFF_UP))
			return -ENETDOWN;
		nh->nh_dev = dev;
		dev_hold(nh->nh_dev);
		nh->nh_scope = RT_SCOPE_HOST;
	}

	return 0;
}


struct dn_fib_info *dn_fib_create_info(const struct rtmsg *r, struct nlattr *attrs[],
				       const struct nlmsghdr *nlh, int *errp)
{
	int err;
	struct dn_fib_info *fi = NULL;
	struct dn_fib_info *ofi;
	int nhs = 1;

	if (r->rtm_type > RTN_MAX)
		goto err_inval;

	if (dn_fib_props[r->rtm_type].scope > r->rtm_scope)
		goto err_inval;

	if (attrs[RTA_MULTIPATH] &&
	    (nhs = dn_fib_count_nhs(attrs[RTA_MULTIPATH])) == 0)
		goto err_inval;

	fi = kzalloc(struct_size(fi, fib_nh, nhs), GFP_KERNEL);
	err = -ENOBUFS;
	if (fi == NULL)
		goto failure;

	fi->fib_protocol = r->rtm_protocol;
	fi->fib_nhs = nhs;
	fi->fib_flags = r->rtm_flags;

	if (attrs[RTA_PRIORITY])
		fi->fib_priority = nla_get_u32(attrs[RTA_PRIORITY]);

	if (attrs[RTA_METRICS]) {
		struct nlattr *attr;
		int rem;

		nla_for_each_nested(attr, attrs[RTA_METRICS], rem) {
			int type = nla_type(attr);

			if (type) {
				if (type > RTAX_MAX || type == RTAX_CC_ALGO ||
				    nla_len(attr) < 4)
					goto err_inval;

				fi->fib_metrics[type-1] = nla_get_u32(attr);
			}
		}
	}

	if (attrs[RTA_PREFSRC])
		fi->fib_prefsrc = nla_get_le16(attrs[RTA_PREFSRC]);

	if (attrs[RTA_MULTIPATH]) {
		if ((err = dn_fib_get_nhs(fi, attrs[RTA_MULTIPATH], r)) != 0)
			goto failure;

		if (attrs[RTA_OIF] &&
		    fi->fib_nh->nh_oif != nla_get_u32(attrs[RTA_OIF]))
			goto err_inval;

		if (attrs[RTA_GATEWAY] &&
		    fi->fib_nh->nh_gw != nla_get_le16(attrs[RTA_GATEWAY]))
			goto err_inval;
	} else {
		struct dn_fib_nh *nh = fi->fib_nh;

		if (attrs[RTA_OIF])
			nh->nh_oif = nla_get_u32(attrs[RTA_OIF]);

		if (attrs[RTA_GATEWAY])
			nh->nh_gw = nla_get_le16(attrs[RTA_GATEWAY]);

		nh->nh_flags = r->rtm_flags;
		nh->nh_weight = 1;
	}

	if (r->rtm_type == RTN_NAT) {
		if (!attrs[RTA_GATEWAY] || nhs != 1 || attrs[RTA_OIF])
			goto err_inval;

		fi->fib_nh->nh_gw = nla_get_le16(attrs[RTA_GATEWAY]);
		goto link_it;
	}

	if (dn_fib_props[r->rtm_type].error) {
		if (attrs[RTA_GATEWAY] || attrs[RTA_OIF] || attrs[RTA_MULTIPATH])
			goto err_inval;

		goto link_it;
	}

	if (r->rtm_scope > RT_SCOPE_HOST)
		goto err_inval;

	if (r->rtm_scope == RT_SCOPE_HOST) {
		struct dn_fib_nh *nh = fi->fib_nh;

		/* Local address is added */
		if (nhs != 1 || nh->nh_gw)
			goto err_inval;
		nh->nh_scope = RT_SCOPE_NOWHERE;
		nh->nh_dev = dev_get_by_index(&init_net, fi->fib_nh->nh_oif);
		err = -ENODEV;
		if (nh->nh_dev == NULL)
			goto failure;
	} else {
		change_nexthops(fi) {
			if ((err = dn_fib_check_nh(r, fi, nh)) != 0)
				goto failure;
		} endfor_nexthops(fi)
	}

	if (fi->fib_prefsrc) {
		if (r->rtm_type != RTN_LOCAL || !attrs[RTA_DST] ||
		    fi->fib_prefsrc != nla_get_le16(attrs[RTA_DST]))
			if (dnet_addr_type(fi->fib_prefsrc) != RTN_LOCAL)
				goto err_inval;
	}

link_it:
	if ((ofi = dn_fib_find_info(fi)) != NULL) {
		fi->fib_dead = 1;
		dn_fib_free_info(fi);
		refcount_inc(&ofi->fib_treeref);
		return ofi;
	}

	refcount_set(&fi->fib_treeref, 1);
	refcount_set(&fi->fib_clntref, 1);
	spin_lock(&dn_fib_info_lock);
	fi->fib_next = dn_fib_info_list;
	fi->fib_prev = NULL;
	if (dn_fib_info_list)
		dn_fib_info_list->fib_prev = fi;
	dn_fib_info_list = fi;
	spin_unlock(&dn_fib_info_lock);
	return fi;

err_inval:
	err = -EINVAL;

failure:
	*errp = err;
	if (fi) {
		fi->fib_dead = 1;
		dn_fib_free_info(fi);
	}

	return NULL;
}

int dn_fib_semantic_match(int type, struct dn_fib_info *fi, const struct flowidn *fld, struct dn_fib_res *res)
{
	int err = dn_fib_props[type].error;

	if (err == 0) {
		if (fi->fib_flags & RTNH_F_DEAD)
			return 1;

		res->fi = fi;

		switch (type) {
		case RTN_NAT:
			DN_FIB_RES_RESET(*res);
			refcount_inc(&fi->fib_clntref);
			return 0;
		case RTN_UNICAST:
		case RTN_LOCAL:
			for_nexthops(fi) {
				if (nh->nh_flags & RTNH_F_DEAD)
					continue;
				if (!fld->flowidn_oif ||
				    fld->flowidn_oif == nh->nh_oif)
					break;
			}
			if (nhsel < fi->fib_nhs) {
				res->nh_sel = nhsel;
				refcount_inc(&fi->fib_clntref);
				return 0;
			}
			endfor_nexthops(fi);
			res->fi = NULL;
			return 1;
		default:
			net_err_ratelimited(""DECnet: impossible routing event : dn_fib_semantic_match type=%d\n"",
					    type);
			res->fi = NULL;
			return -EINVAL;
		}
	}
	return err;
}

void dn_fib_select_multipath(const struct flowidn *fld, struct dn_fib_res *res)
{
	struct dn_fib_info *fi = res->fi;
	int w;

	spin_lock_bh(&dn_fib_multipath_lock);
	if (fi->fib_power <= 0) {
		int power = 0;
		change_nexthops(fi) {
			if (!(nh->nh_flags&RTNH_F_DEAD)) {
				power += nh->nh_weight;
				nh->nh_power = nh->nh_weight;
			}
		} endfor_nexthops(fi);
		fi->fib_power = power;
		if (power < 0) {
			spin_unlock_bh(&dn_fib_multipath_lock);
			res->nh_sel = 0;
			return;
		}
	}

	w = jiffies % fi->fib_power;

	change_nexthops(fi) {
		if (!(nh->nh_flags&RTNH_F_DEAD) && nh->nh_power) {
			if ((w -= nh->nh_power) <= 0) {
				nh->nh_power--;
				fi->fib_power--;
				res->nh_sel = nhsel;
				spin_unlock_bh(&dn_fib_multipath_lock);
				return;
			}
		}
	} endfor_nexthops(fi);
	res->nh_sel = 0;
	spin_unlock_bh(&dn_fib_multipath_lock);
}

static inline u32 rtm_get_table(struct nlattr *attrs[], u8 table)
{
	if (attrs[RTA_TABLE])
		table = nla_get_u32(attrs[RTA_TABLE]);

	return table;
}

static int dn_fib_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh,
			       struct netlink_ext_ack *extack)
{
	struct net *net = sock_net(skb->sk);
	struct dn_fib_table *tb;
	struct rtmsg *r = nlmsg_data(nlh);
	struct nlattr *attrs[RTA_MAX+1];
	int err;

	if (!netlink_capable(skb, CAP_NET_ADMIN))
		return -EPERM;

	if (!net_eq(net, &init_net))
		return -EINVAL;

	err = nlmsg_parse_deprecated(nlh, sizeof(*r), attrs, RTA_MAX,
				     rtm_dn_policy, extack);
	if (err < 0)
		return err;

	tb = dn_fib_get_table(rtm_get_table(attrs, r->rtm_table), 0);
	if (!tb)
		return -ESRCH;

	return tb->delete(tb, r, attrs, nlh, &NETLINK_CB(skb));
}

static int dn_fib_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,
			       struct netlink_ext_ack *extack)
{
	struct net *net = sock_net(skb->sk);
	struct dn_fib_table *tb;
	struct rtmsg *r = nlmsg_data(nlh);
	struct nlattr *attrs[RTA_MAX+1];
	int err;

	if (!netlink_capable(skb, CAP_NET_ADMIN))
		return -EPERM;

	if (!net_eq(net, &init_net))
		return -EINVAL;

	err = nlmsg_parse_deprecated(nlh, sizeof(*r), attrs, RTA_MAX,
				     rtm_dn_policy, extack);
	if (err < 0)
		return err;

	tb = dn_fib_get_table(rtm_get_table(attrs, r->rtm_table), 1);
	if (!tb)
		return -ENOBUFS;

	return tb->insert(tb, r, attrs, nlh, &NETLINK_CB(skb));
}

static void fib_magic(int cmd, int type, __le16 dst, int dst_len, struct dn_ifaddr *ifa)
{
	struct dn_fib_table *tb;
	struct {
		struct nlmsghdr nlh;
		struct rtmsg rtm;
	} req;
	struct {
		struct nlattr hdr;
		__le16 dst;
	} dst_attr = {
		.dst = dst,
	};
	struct {
		struct nlattr hdr;
		__le16 prefsrc;
	} prefsrc_attr = {
		.prefsrc = ifa->ifa_local,
	};
	struct {
		struct nlattr hdr;
		u32 oif;
	} oif_attr = {
		.oif = ifa->ifa_dev->dev->ifindex,
	};
	struct nlattr *attrs[RTA_MAX+1] = {
		[RTA_DST] = (struct nlattr *) &dst_attr,
		[RTA_PREFSRC] = (struct nlattr * ) &prefsrc_attr,
		[RTA_OIF] = (struct nlattr *) &oif_attr,
	};

	memset(&req.rtm, 0, sizeof(req.rtm));

	if (type == RTN_UNICAST)
		tb = dn_fib_get_table(RT_MIN_TABLE, 1);
	else
		tb = dn_fib_get_table(RT_TABLE_LOCAL, 1);

	if (tb == NULL)
		return;

	req.nlh.nlmsg_len = sizeof(req);
	req.nlh.nlmsg_type = cmd;
	req.nlh.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_APPEND;
	req.nlh.nlmsg_pid = 0;
	req.nlh.nlmsg_seq = 0;

	req.rtm.rtm_dst_len = dst_len;
	req.rtm.rtm_table = tb->n;
	req.rtm.rtm_protocol = RTPROT_KERNEL;
	req.rtm.rtm_scope = (type != RTN_LOCAL ? RT_SCOPE_LINK : RT_SCOPE_HOST);
	req.rtm.rtm_type = type;

	if (cmd == RTM_NEWROUTE)
		tb->insert(tb, &req.rtm, attrs, &req.nlh, NULL);
	else
		tb->delete(tb, &req.rtm, attrs, &req.nlh, NULL);
}

static void dn_fib_add_ifaddr(struct dn_ifaddr *ifa)
{

	fib_magic(RTM_NEWROUTE, RTN_LOCAL, ifa->ifa_local, 16, ifa);

#if 0
	if (!(dev->flags&IFF_UP))
		return;
	/* In the future, we will want to add default routes here */

#endif
}

static void dn_fib_del_ifaddr(struct dn_ifaddr *ifa)
{
	int found_it = 0;
	struct net_device *dev;
	struct dn_dev *dn_db;
	struct dn_ifaddr *ifa2;

	ASSERT_RTNL();

	/* Scan device list */
	rcu_read_lock();
	for_each_netdev_rcu(&init_net, dev) {
		dn_db = rcu_dereference(dev->dn_ptr);
		if (dn_db == NULL)
			continue;
		for (ifa2 = rcu_dereference(dn_db->ifa_list);
		     ifa2 != NULL;
		     ifa2 = rcu_dereference(ifa2->ifa_next)) {
			if (ifa2->ifa_local == ifa->ifa_local) {
				found_it = 1;
				break;
			}
		}
	}
	rcu_read_unlock();

	if (found_it == 0) {
		fib_magic(RTM_DELROUTE, RTN_LOCAL, ifa->ifa_local, 16, ifa);

		if (dnet_addr_type(ifa->ifa_local) != RTN_LOCAL) {
			if (dn_fib_sync_down(ifa->ifa_local, NULL, 0))
				dn_fib_flush();
		}
	}
}

static void dn_fib_disable_addr(struct net_device *dev, int force)
{
	if (dn_fib_sync_down(0, dev, force))
		dn_fib_flush();
	dn_rt_cache_flush(0);
	neigh_ifdown(&dn_neigh_table, dev);
}

static int dn_fib_dnaddr_event(struct notifier_block *this, unsigned long event, void *ptr)
{
	struct dn_ifaddr *ifa = (struct dn_ifaddr *)ptr;

	switch (event) {
	case NETDEV_UP:
		dn_fib_add_ifaddr(ifa);
		dn_fib_sync_up(ifa->ifa_dev->dev);
		dn_rt_cache_flush(-1);
		break;
	case NETDEV_DOWN:
		dn_fib_del_ifaddr(ifa);
		if (ifa->ifa_dev && ifa->ifa_dev->ifa_list == NULL) {
			dn_fib_disable_addr(ifa->ifa_dev->dev, 1);
		} else {
			dn_rt_cache_flush(-1);
		}
		break;
	}
	return NOTIFY_DONE;
}

static int dn_fib_sync_down(__le16 local, struct net_device *dev, int force)
{
	int ret = 0;
	int scope = RT_SCOPE_NOWHERE;

	if (force)
		scope = -1;

	for_fib_info() {
		/*
		 * This makes no sense for DECnet.... we will almost
		 * certainly have more than one local address the same
		 * over all our interfaces. It needs thinking about
		 * some more.
		 */
		if (local && fi->fib_prefsrc == local) {
			fi->fib_flags |= RTNH_F_DEAD;
			ret++;
		} else if (dev && fi->fib_nhs) {
			int dead = 0;

			change_nexthops(fi) {
				if (nh->nh_flags&RTNH_F_DEAD)
					dead++;
				else if (nh->nh_dev == dev &&
						nh->nh_scope != scope) {
					spin_lock_bh(&dn_fib_multipath_lock);
					nh->nh_flags |= RTNH_F_DEAD;
					fi->fib_power -= nh->nh_power;
					nh->nh_power = 0;
					spin_unlock_bh(&dn_fib_multipath_lock);
					dead++;
				}
			} endfor_nexthops(fi)
			if (dead == fi->fib_nhs) {
				fi->fib_flags |= RTNH_F_DEAD;
				ret++;
			}
		}
	} endfor_fib_info();
	return ret;
}


static int dn_fib_sync_up(struct net_device *dev)
{
	int ret = 0;

	if (!(dev->flags&IFF_UP))
		return 0;

	for_fib_info() {
		int alive = 0;

		change_nexthops(fi) {
			if (!(nh->nh_flags&RTNH_F_DEAD)) {
				alive++;
				continue;
			}
			if (nh->nh_dev == NULL || !(nh->nh_dev->flags&IFF_UP))
				continue;
			if (nh->nh_dev != dev || dev->dn_ptr == NULL)
				continue;
			alive++;
			spin_lock_bh(&dn_fib_multipath_lock);
			nh->nh_power = 0;
			nh->nh_flags &= ~RTNH_F_DEAD;
			spin_unlock_bh(&dn_fib_multipath_lock);
		} endfor_nexthops(fi);

		if (alive > 0) {
			fi->fib_flags &= ~RTNH_F_DEAD;
			ret++;
		}
	} endfor_fib_info();
	return ret;
}

static struct notifier_block dn_fib_dnaddr_notifier = {
	.notifier_call = dn_fib_dnaddr_event,
};

void __exit dn_fib_cleanup(void)
{
	dn_fib_table_cleanup();
	dn_fib_rules_cleanup();

	unregister_dnaddr_notifier(&dn_fib_dnaddr_notifier);
}


void __init dn_fib_init(void)
{
	dn_fib_table_init();
	dn_fib_rules_init();

	register_dnaddr_notifier(&dn_fib_dnaddr_notifier);

	rtnl_register_module(THIS_MODULE, PF_DECnet, RTM_NEWROUTE,
			     dn_fib_rtm_newroute, NULL, 0);
	rtnl_register_module(THIS_MODULE, PF_DECnet, RTM_DELROUTE,
			     dn_fib_rtm_delroute, NULL, 0);
}",1202cdd665315c525b5237e96e0bedc76d7e754f,CVE-2023-3338,1202cdd665315c525b5237e96e0bedc76d7e754f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,"  /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR (VAR/VAR VAR) * * VAR: VAR VAR <VAR@VAR.VAR> * * * VAR: * VAR VAR : VAR VAR VAR * VAR VAR : VAR VAR... VAR VAR VAR VAR VAR, VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR : VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR. * */                            VAR(VAR = VAR; VAR; VAR = VAR->VAR)   VAR(VAR = 0, VAR = (VAR)->VAR; VAR < (VAR)->VAR; VAR++, VAR++)  VAR(VAR = 0, VAR = (VAR VAR *)((VAR)->VAR); VAR < (VAR)->VAR; VAR++, VAR++)  VAR VAR(VAR); VAR VAR VAR *VAR; VAR VAR(VAR); VAR VAR { VAR VAR; VAR VAR; } VAR[VAR+1] = { [VAR] = { .VAR = 0, .VAR = VAR }, [VAR] = { .VAR = 0, .VAR = VAR }, [VAR] = { .VAR = 0, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = 0, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, }; VAR VAR VAR(VAR VAR, VAR VAR *VAR, VAR VAR); VAR VAR VAR(VAR VAR *VAR); VAR VAR(VAR VAR *VAR) { VAR (VAR->VAR == 0) { VAR(VAR ""VAR: VAR! VAR VAR VAR VAR VAR\VAR""); VAR; } VAR(VAR) { VAR(VAR->VAR); VAR->VAR = VAR; } VAR(VAR); VAR(VAR); } VAR VAR(VAR VAR *VAR) { VAR(&VAR); VAR (VAR && VAR(&VAR->VAR)) { VAR (VAR->VAR) VAR->VAR->VAR = VAR->VAR; VAR (VAR->VAR) VAR->VAR->VAR = VAR->VAR; VAR (VAR == VAR) VAR = VAR->VAR; VAR->VAR = 1; VAR(VAR); } VAR(&VAR); } VAR VAR VAR VAR(VAR VAR VAR *VAR, VAR VAR VAR *VAR) { VAR VAR VAR *VAR = VAR->VAR; VAR(VAR) { VAR (VAR->VAR != VAR->VAR || VAR->VAR != VAR->VAR || VAR->VAR != VAR->VAR || VAR->VAR != VAR->VAR || ((VAR->VAR^VAR->VAR)&~VAR)) VAR -1; VAR++; } VAR(VAR); VAR 0; } VAR VAR VAR VAR *VAR(VAR VAR VAR *VAR) { VAR() { VAR (VAR->VAR != VAR->VAR) VAR; VAR (VAR->VAR == VAR->VAR && VAR->VAR == VAR->VAR && VAR->VAR == VAR->VAR && VAR(VAR->VAR, VAR->VAR, VAR(VAR->VAR)) == 0 && ((VAR->VAR^VAR->VAR)&~VAR) == 0 && (VAR->VAR == 0 || VAR(VAR, VAR) == 0)) VAR VAR; } VAR(); VAR VAR; } VAR VAR VAR(VAR VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR = 0, VAR = VAR(VAR); VAR (VAR(VAR, VAR)) { VAR++; VAR = VAR(VAR, &VAR); }  VAR VAR > 0 ? 0 : VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR = VAR(VAR); VAR(VAR) { VAR VAR; VAR (!VAR(VAR, VAR)) VAR -VAR; VAR->VAR = (VAR->VAR&~0xFF) | VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR + 1; VAR = VAR(VAR); VAR (VAR > 0) { VAR VAR *VAR; VAR = VAR((VAR VAR *) (VAR + 1), VAR, VAR); VAR->VAR = VAR ? VAR(VAR) : 0; } VAR = VAR(VAR, &VAR); } VAR(VAR); VAR 0; } VAR VAR VAR(VAR VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR; VAR (VAR->VAR) { VAR VAR VAR; VAR VAR VAR; VAR (VAR->VAR&VAR) { VAR VAR *VAR; VAR (VAR->VAR >= VAR) VAR -VAR; VAR (VAR(VAR->VAR) != VAR) VAR -VAR; VAR ((VAR = VAR(&VAR, VAR->VAR)) == VAR) VAR -VAR; VAR (!(VAR->VAR&VAR)) VAR -VAR; VAR->VAR = VAR; VAR(VAR); VAR->VAR = VAR; VAR 0; } VAR(&VAR, 0, VAR(VAR)); VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR + 1; VAR (VAR.VAR < VAR) VAR.VAR = VAR; VAR ((VAR = VAR(&VAR, &VAR)) != 0) VAR VAR; VAR = -VAR; VAR (VAR.VAR != VAR && VAR.VAR != VAR) VAR VAR; VAR->VAR = VAR.VAR; VAR->VAR = VAR(VAR); VAR->VAR = VAR(VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR); VAR = -VAR; VAR (!(VAR->VAR->VAR & VAR)) VAR VAR; VAR = 0; VAR: VAR(&VAR); VAR VAR; } VAR { VAR VAR *VAR; VAR (VAR->VAR&(VAR|VAR)) VAR -VAR; VAR = VAR(&VAR, VAR->VAR); VAR (VAR == VAR || VAR->VAR == VAR) VAR -VAR; VAR (!(VAR->VAR&VAR)) VAR -VAR; VAR->VAR = VAR; VAR(VAR->VAR); VAR->VAR = VAR; } VAR 0; } VAR VAR *VAR(VAR VAR VAR *VAR, VAR VAR *VAR[], VAR VAR VAR *VAR, VAR *VAR) { VAR VAR; VAR VAR *VAR = VAR; VAR VAR *VAR; VAR VAR = 1; VAR (VAR->VAR > VAR) VAR VAR; VAR (VAR[VAR->VAR].VAR > VAR->VAR) VAR VAR; VAR (VAR[VAR] && (VAR = VAR(VAR[VAR])) == 0) VAR VAR; VAR = VAR(VAR(VAR, VAR, VAR), VAR); VAR = -VAR; VAR (VAR == VAR) VAR VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR (VAR[VAR]) VAR->VAR = VAR(VAR[VAR]); VAR (VAR[VAR]) { VAR VAR *VAR; VAR VAR; VAR(VAR, VAR[VAR], VAR) { VAR VAR = VAR(VAR); VAR (VAR) { VAR (VAR > VAR || VAR == VAR || VAR(VAR) < 4) VAR VAR; VAR->VAR[VAR-1] = VAR(VAR); } } } VAR (VAR[VAR]) VAR->VAR = VAR(VAR[VAR]); VAR (VAR[VAR]) { VAR ((VAR = VAR(VAR, VAR[VAR], VAR)) != 0) VAR VAR; VAR (VAR[VAR] && VAR->VAR->VAR != VAR(VAR[VAR])) VAR VAR; VAR (VAR[VAR] && VAR->VAR->VAR != VAR(VAR[VAR])) VAR VAR; } VAR { VAR VAR *VAR = VAR->VAR; VAR (VAR[VAR]) VAR->VAR = VAR(VAR[VAR]); VAR (VAR[VAR]) VAR->VAR = VAR(VAR[VAR]); VAR->VAR = VAR->VAR; VAR->VAR = 1; } VAR (VAR->VAR == VAR) { VAR (!VAR[VAR] || VAR != 1 || VAR[VAR]) VAR VAR; VAR->VAR->VAR = VAR(VAR[VAR]); VAR VAR; } VAR (VAR[VAR->VAR].VAR) { VAR (VAR[VAR] || VAR[VAR] || VAR[VAR]) VAR VAR; VAR VAR; } VAR (VAR->VAR > VAR) VAR VAR; VAR (VAR->VAR == VAR) { VAR VAR *VAR = VAR->VAR;  VAR (VAR != 1 || VAR->VAR) VAR VAR; VAR->VAR = VAR; VAR->VAR = VAR(&VAR, VAR->VAR->VAR); VAR = -VAR; VAR (VAR->VAR == VAR) VAR VAR; } VAR { VAR(VAR) { VAR ((VAR = VAR(VAR, VAR, VAR)) != 0) VAR VAR; } VAR(VAR) } VAR (VAR->VAR) { VAR (VAR->VAR != VAR || !VAR[VAR] || VAR->VAR != VAR(VAR[VAR])) VAR (VAR(VAR->VAR) != VAR) VAR VAR; } VAR: VAR ((VAR = VAR(VAR)) != VAR) { VAR->VAR = 1; VAR(VAR); VAR(&VAR->VAR); VAR VAR; } VAR(&VAR->VAR, 1); VAR(&VAR->VAR, 1); VAR(&VAR); VAR->VAR = VAR; VAR->VAR = VAR; VAR (VAR) VAR->VAR = VAR; VAR = VAR; VAR(&VAR); VAR VAR; VAR: VAR = -VAR; VAR: *VAR = VAR; VAR (VAR) { VAR->VAR = 1; VAR(VAR); } VAR VAR; } VAR VAR(VAR VAR, VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR *VAR) { VAR VAR = VAR[VAR].VAR; VAR (VAR == 0) { VAR (VAR->VAR & VAR) VAR 1; VAR->VAR = VAR; VAR (VAR) { VAR VAR: VAR(*VAR); VAR(&VAR->VAR); VAR 0; VAR VAR: VAR VAR: VAR(VAR) { VAR (VAR->VAR & VAR) VAR; VAR (!VAR->VAR || VAR->VAR == VAR->VAR) VAR; } VAR (VAR < VAR->VAR) { VAR->VAR = VAR; VAR(&VAR->VAR); VAR 0; } VAR(VAR); VAR->VAR = VAR; VAR 1; VAR: VAR(""VAR: VAR VAR VAR : VAR VAR=%VAR\VAR"", VAR); VAR->VAR = VAR; VAR -VAR; } } VAR VAR; } VAR VAR(VAR VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR; VAR(&VAR); VAR (VAR->VAR <= 0) { VAR VAR = 0; VAR(VAR) { VAR (!(VAR->VAR&VAR)) { VAR += VAR->VAR; VAR->VAR = VAR->VAR; } } VAR(VAR); VAR->VAR = VAR; VAR (VAR < 0) { VAR(&VAR); VAR->VAR = 0; VAR; } } VAR = VAR % VAR->VAR; VAR(VAR) { VAR (!(VAR->VAR&VAR) && VAR->VAR) { VAR ((VAR -= VAR->VAR) <= 0) { VAR->VAR--; VAR->VAR--; VAR->VAR = VAR; VAR(&VAR); VAR; } } } VAR(VAR); VAR->VAR = 0; VAR(&VAR); } VAR VAR VAR VAR(VAR VAR *VAR[], VAR VAR) { VAR (VAR[VAR]) VAR = VAR(VAR[VAR]); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR; VAR VAR *VAR = VAR(VAR); VAR VAR *VAR[VAR+1]; VAR VAR; VAR (!VAR(VAR, VAR)) VAR -VAR; VAR (!VAR(VAR, &VAR)) VAR -VAR; VAR = VAR(VAR, VAR(*VAR), VAR, VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR(VAR, VAR->VAR), 0); VAR (!VAR) VAR -VAR; VAR VAR->VAR(VAR, VAR, VAR, VAR, &VAR(VAR)); } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR; VAR VAR *VAR = VAR(VAR); VAR VAR *VAR[VAR+1]; VAR VAR; VAR (!VAR(VAR, VAR)) VAR -VAR; VAR (!VAR(VAR, &VAR)) VAR -VAR; VAR = VAR(VAR, VAR(*VAR), VAR, VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR(VAR, VAR->VAR), 1); VAR (!VAR) VAR -VAR; VAR VAR->VAR(VAR, VAR, VAR, VAR, &VAR(VAR)); } VAR VAR VAR(VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR *VAR) { VAR VAR *VAR; VAR { VAR VAR VAR; VAR VAR VAR; } VAR; VAR { VAR VAR VAR; VAR VAR; } VAR = { .VAR = VAR, }; VAR { VAR VAR VAR; VAR VAR; } VAR = { .VAR = VAR->VAR, }; VAR { VAR VAR VAR; VAR VAR; } VAR = { .VAR = VAR->VAR->VAR->VAR, }; VAR VAR *VAR[VAR+1] = { [VAR] = (VAR VAR *) &VAR, [VAR] = (VAR VAR * ) &VAR, [VAR] = (VAR VAR *) &VAR, }; VAR(&VAR.VAR, 0, VAR(VAR.VAR)); VAR (VAR == VAR) VAR = VAR(VAR, 1); VAR VAR = VAR(VAR, 1); VAR (VAR == VAR) VAR; VAR.VAR.VAR = VAR(VAR); VAR.VAR.VAR = VAR; VAR.VAR.VAR = VAR|VAR|VAR; VAR.VAR.VAR = 0; VAR.VAR.VAR = 0; VAR.VAR.VAR = VAR; VAR.VAR.VAR = VAR->VAR; VAR.VAR.VAR = VAR; VAR.VAR.VAR = (VAR != VAR ? VAR : VAR); VAR.VAR.VAR = VAR; VAR (VAR == VAR) VAR->VAR(VAR, &VAR.VAR, VAR, &VAR.VAR, VAR); VAR VAR->VAR(VAR, &VAR.VAR, VAR, &VAR.VAR, VAR); } VAR VAR VAR(VAR VAR *VAR) { VAR(VAR, VAR, VAR->VAR, 16, VAR);  VAR (!(VAR->VAR&VAR)) VAR;   } VAR VAR VAR(VAR VAR *VAR) { VAR VAR = 0; VAR VAR *VAR; VAR VAR *VAR; VAR VAR *VAR; VAR();  VAR(); VAR(&VAR, VAR) { VAR = VAR(VAR->VAR); VAR (VAR == VAR) VAR; VAR (VAR = VAR(VAR->VAR); VAR != VAR; VAR = VAR(VAR->VAR)) { VAR (VAR->VAR == VAR->VAR) { VAR = 1; VAR; } } } VAR(); VAR (VAR == 0) { VAR(VAR, VAR, VAR->VAR, 16, VAR); VAR (VAR(VAR->VAR) != VAR) { VAR (VAR(VAR->VAR, VAR, 0)) VAR(); } } } VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR (VAR(0, VAR, VAR)) VAR(); VAR(0); VAR(&VAR, VAR); } VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR *VAR) { VAR VAR *VAR = (VAR VAR *)VAR; VAR (VAR) { VAR VAR: VAR(VAR); VAR(VAR->VAR->VAR); VAR(-1); VAR; VAR VAR: VAR(VAR); VAR (VAR->VAR && VAR->VAR->VAR == VAR) { VAR(VAR->VAR->VAR, 1); } VAR { VAR(-1); } VAR; } VAR VAR; } VAR VAR VAR(VAR VAR, VAR VAR *VAR, VAR VAR) { VAR VAR = 0; VAR VAR = VAR; VAR (VAR) VAR = -1; VAR() { /* * VAR VAR VAR VAR VAR VAR.... VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR. VAR VAR VAR VAR * VAR VAR. */ VAR (VAR && VAR->VAR == VAR) { VAR->VAR |= VAR; VAR++; } VAR VAR (VAR && VAR->VAR) { VAR VAR = 0; VAR(VAR) { VAR (VAR->VAR&VAR) VAR++; VAR VAR (VAR->VAR == VAR && VAR->VAR != VAR) { VAR(&VAR); VAR->VAR |= VAR; VAR->VAR -= VAR->VAR; VAR->VAR = 0; VAR(&VAR); VAR++; } } VAR(VAR) VAR (VAR == VAR->VAR) { VAR->VAR |= VAR; VAR++; } } } VAR(); VAR VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR = 0; VAR (!(VAR->VAR&VAR)) VAR 0; VAR() { VAR VAR = 0; VAR(VAR) { VAR (!(VAR->VAR&VAR)) { VAR++; VAR; } VAR (VAR->VAR == VAR || !(VAR->VAR->VAR&VAR)) VAR; VAR (VAR->VAR != VAR || VAR->VAR == VAR) VAR; VAR++; VAR(&VAR); VAR->VAR = 0; VAR->VAR &= ~VAR; VAR(&VAR); } VAR(VAR); VAR (VAR > 0) { VAR->VAR &= ~VAR; VAR++; } } VAR(); VAR VAR; } VAR VAR VAR VAR = { .VAR = VAR, }; VAR VAR VAR(VAR) { VAR(); VAR(); VAR(&VAR); } VAR VAR VAR(VAR) { VAR(); VAR(); VAR(&VAR); VAR(VAR, VAR, VAR, VAR, VAR, 0); VAR(VAR, VAR, VAR, VAR, VAR, 0); }",1
linux_1202cdd665315c525b5237e96e0bedc76d7e754f,net/decnet/dn_table.c,,"// SPDX-License-Identifier: GPL-2.0
/*
 * DECnet       An implementation of the DECnet protocol suite for the LINUX
 *              operating system.  DECnet is implemented using the  BSD Socket
 *              interface as the means of communication with the user level.
 *
 *              DECnet Routing Forwarding Information Base (Routing Tables)
 *
 * Author:      Steve Whitehouse <SteveW@ACM.org>
 *              Mostly copied from the IPv4 routing code
 *
 *
 * Changes:
 *
 */
#include <linux/string.h>
#include <linux/net.h>
#include <linux/socket.h>
#include <linux/slab.h>
#include <linux/sockios.h>
#include <linux/init.h>
#include <linux/skbuff.h>
#include <linux/rtnetlink.h>
#include <linux/proc_fs.h>
#include <linux/netdevice.h>
#include <linux/timer.h>
#include <linux/spinlock.h>
#include <linux/atomic.h>
#include <linux/uaccess.h>
#include <linux/route.h> /* RTF_xxx */
#include <net/neighbour.h>
#include <net/netlink.h>
#include <net/tcp.h>
#include <net/dst.h>
#include <net/flow.h>
#include <net/fib_rules.h>
#include <net/dn.h>
#include <net/dn_route.h>
#include <net/dn_fib.h>
#include <net/dn_neigh.h>
#include <net/dn_dev.h>

struct dn_zone
{
	struct dn_zone		*dz_next;
	struct dn_fib_node 	**dz_hash;
	int			dz_nent;
	int			dz_divisor;
	u32			dz_hashmask;
#define DZ_HASHMASK(dz)	((dz)->dz_hashmask)
	int			dz_order;
	__le16			dz_mask;
#define DZ_MASK(dz)	((dz)->dz_mask)
};

struct dn_hash
{
	struct dn_zone	*dh_zones[17];
	struct dn_zone	*dh_zone_list;
};

#define dz_key_0(key)		((key).datum = 0)

#define for_nexthops(fi) { int nhsel; const struct dn_fib_nh *nh;\
	for(nhsel = 0, nh = (fi)->fib_nh; nhsel < (fi)->fib_nhs; nh++, nhsel++)

#define endfor_nexthops(fi) }

#define DN_MAX_DIVISOR 1024
#define DN_S_ZOMBIE 1
#define DN_S_ACCESSED 2

#define DN_FIB_SCAN(f, fp) \
for( ; ((f) = *(fp)) != NULL; (fp) = &(f)->fn_next)

#define DN_FIB_SCAN_KEY(f, fp, key) \
for( ; ((f) = *(fp)) != NULL && dn_key_eq((f)->fn_key, (key)); (fp) = &(f)->fn_next)

#define RT_TABLE_MIN 1
#define DN_FIB_TABLE_HASHSZ 256
static struct hlist_head dn_fib_table_hash[DN_FIB_TABLE_HASHSZ];
static DEFINE_RWLOCK(dn_fib_tables_lock);

static struct kmem_cache *dn_hash_kmem __read_mostly;
static int dn_fib_hash_zombies;

static inline dn_fib_idx_t dn_hash(dn_fib_key_t key, struct dn_zone *dz)
{
	u16 h = le16_to_cpu(key.datum)>>(16 - dz->dz_order);
	h ^= (h >> 10);
	h ^= (h >> 6);
	h &= DZ_HASHMASK(dz);
	return *(dn_fib_idx_t *)&h;
}

static inline dn_fib_key_t dz_key(__le16 dst, struct dn_zone *dz)
{
	dn_fib_key_t k;
	k.datum = dst & DZ_MASK(dz);
	return k;
}

static inline struct dn_fib_node **dn_chain_p(dn_fib_key_t key, struct dn_zone *dz)
{
	return &dz->dz_hash[dn_hash(key, dz).datum];
}

static inline struct dn_fib_node *dz_chain(dn_fib_key_t key, struct dn_zone *dz)
{
	return dz->dz_hash[dn_hash(key, dz).datum];
}

static inline int dn_key_eq(dn_fib_key_t a, dn_fib_key_t b)
{
	return a.datum == b.datum;
}

static inline int dn_key_leq(dn_fib_key_t a, dn_fib_key_t b)
{
	return a.datum <= b.datum;
}

static inline void dn_rebuild_zone(struct dn_zone *dz,
				   struct dn_fib_node **old_ht,
				   int old_divisor)
{
	struct dn_fib_node *f, **fp, *next;
	int i;

	for(i = 0; i < old_divisor; i++) {
		for(f = old_ht[i]; f; f = next) {
			next = f->fn_next;
			for(fp = dn_chain_p(f->fn_key, dz);
				*fp && dn_key_leq((*fp)->fn_key, f->fn_key);
				fp = &(*fp)->fn_next)
				/* NOTHING */;
			f->fn_next = *fp;
			*fp = f;
		}
	}
}

static void dn_rehash_zone(struct dn_zone *dz)
{
	struct dn_fib_node **ht, **old_ht;
	int old_divisor, new_divisor;
	u32 new_hashmask;

	old_divisor = dz->dz_divisor;

	switch (old_divisor) {
	case 16:
		new_divisor = 256;
		new_hashmask = 0xFF;
		break;
	default:
		printk(KERN_DEBUG ""DECnet: dn_rehash_zone: BUG! %d\n"",
		       old_divisor);
		fallthrough;
	case 256:
		new_divisor = 1024;
		new_hashmask = 0x3FF;
		break;
	}

	ht = kcalloc(new_divisor, sizeof(struct dn_fib_node*), GFP_KERNEL);
	if (ht == NULL)
		return;

	write_lock_bh(&dn_fib_tables_lock);
	old_ht = dz->dz_hash;
	dz->dz_hash = ht;
	dz->dz_hashmask = new_hashmask;
	dz->dz_divisor = new_divisor;
	dn_rebuild_zone(dz, old_ht, old_divisor);
	write_unlock_bh(&dn_fib_tables_lock);
	kfree(old_ht);
}

static void dn_free_node(struct dn_fib_node *f)
{
	dn_fib_release_info(DN_FIB_INFO(f));
	kmem_cache_free(dn_hash_kmem, f);
}


static struct dn_zone *dn_new_zone(struct dn_hash *table, int z)
{
	int i;
	struct dn_zone *dz = kzalloc(sizeof(struct dn_zone), GFP_KERNEL);
	if (!dz)
		return NULL;

	if (z) {
		dz->dz_divisor = 16;
		dz->dz_hashmask = 0x0F;
	} else {
		dz->dz_divisor = 1;
		dz->dz_hashmask = 0;
	}

	dz->dz_hash = kcalloc(dz->dz_divisor, sizeof(struct dn_fib_node *), GFP_KERNEL);
	if (!dz->dz_hash) {
		kfree(dz);
		return NULL;
	}

	dz->dz_order = z;
	dz->dz_mask = dnet_make_mask(z);

	for(i = z + 1; i <= 16; i++)
		if (table->dh_zones[i])
			break;

	write_lock_bh(&dn_fib_tables_lock);
	if (i>16) {
		dz->dz_next = table->dh_zone_list;
		table->dh_zone_list = dz;
	} else {
		dz->dz_next = table->dh_zones[i]->dz_next;
		table->dh_zones[i]->dz_next = dz;
	}
	table->dh_zones[z] = dz;
	write_unlock_bh(&dn_fib_tables_lock);
	return dz;
}


static int dn_fib_nh_match(struct rtmsg *r, struct nlmsghdr *nlh, struct nlattr *attrs[], struct dn_fib_info *fi)
{
	struct rtnexthop *nhp;
	int nhlen;

	if (attrs[RTA_PRIORITY] &&
	    nla_get_u32(attrs[RTA_PRIORITY]) != fi->fib_priority)
		return 1;

	if (attrs[RTA_OIF] || attrs[RTA_GATEWAY]) {
		if ((!attrs[RTA_OIF] || nla_get_u32(attrs[RTA_OIF]) == fi->fib_nh->nh_oif) &&
		    (!attrs[RTA_GATEWAY]  || nla_get_le16(attrs[RTA_GATEWAY]) != fi->fib_nh->nh_gw))
			return 0;
		return 1;
	}

	if (!attrs[RTA_MULTIPATH])
		return 0;

	nhp = nla_data(attrs[RTA_MULTIPATH]);
	nhlen = nla_len(attrs[RTA_MULTIPATH]);

	for_nexthops(fi) {
		int attrlen = nhlen - sizeof(struct rtnexthop);
		__le16 gw;

		if (attrlen < 0 || (nhlen -= nhp->rtnh_len) < 0)
			return -EINVAL;
		if (nhp->rtnh_ifindex && nhp->rtnh_ifindex != nh->nh_oif)
			return 1;
		if (attrlen) {
			struct nlattr *gw_attr;

			gw_attr = nla_find((struct nlattr *) (nhp + 1), attrlen, RTA_GATEWAY);
			gw = gw_attr ? nla_get_le16(gw_attr) : 0;

			if (gw && gw != nh->nh_gw)
				return 1;
		}
		nhp = RTNH_NEXT(nhp);
	} endfor_nexthops(fi);

	return 0;
}

static inline size_t dn_fib_nlmsg_size(struct dn_fib_info *fi)
{
	size_t payload = NLMSG_ALIGN(sizeof(struct rtmsg))
			 + nla_total_size(4) /* RTA_TABLE */
			 + nla_total_size(2) /* RTA_DST */
			 + nla_total_size(4) /* RTA_PRIORITY */
			 + nla_total_size(TCP_CA_NAME_MAX); /* RTAX_CC_ALGO */

	/* space for nested metrics */
	payload += nla_total_size((RTAX_MAX * nla_total_size(4)));

	if (fi->fib_nhs) {
		/* Also handles the special case fib_nhs == 1 */

		/* each nexthop is packed in an attribute */
		size_t nhsize = nla_total_size(sizeof(struct rtnexthop));

		/* may contain a gateway attribute */
		nhsize += nla_total_size(4);

		/* all nexthops are packed in a nested attribute */
		payload += nla_total_size(fi->fib_nhs * nhsize);
	}

	return payload;
}

static int dn_fib_dump_info(struct sk_buff *skb, u32 portid, u32 seq, int event,
			u32 tb_id, u8 type, u8 scope, void *dst, int dst_len,
			struct dn_fib_info *fi, unsigned int flags)
{
	struct rtmsg *rtm;
	struct nlmsghdr *nlh;

	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);
	if (!nlh)
		return -EMSGSIZE;

	rtm = nlmsg_data(nlh);
	rtm->rtm_family = AF_DECnet;
	rtm->rtm_dst_len = dst_len;
	rtm->rtm_src_len = 0;
	rtm->rtm_tos = 0;
	rtm->rtm_table = tb_id;
	rtm->rtm_flags = fi->fib_flags;
	rtm->rtm_scope = scope;
	rtm->rtm_type  = type;
	rtm->rtm_protocol = fi->fib_protocol;

	if (nla_put_u32(skb, RTA_TABLE, tb_id) < 0)
		goto errout;

	if (rtm->rtm_dst_len &&
	    nla_put(skb, RTA_DST, 2, dst) < 0)
		goto errout;

	if (fi->fib_priority &&
	    nla_put_u32(skb, RTA_PRIORITY, fi->fib_priority) < 0)
		goto errout;

	if (rtnetlink_put_metrics(skb, fi->fib_metrics) < 0)
		goto errout;

	if (fi->fib_nhs == 1) {
		if (fi->fib_nh->nh_gw &&
		    nla_put_le16(skb, RTA_GATEWAY, fi->fib_nh->nh_gw) < 0)
			goto errout;

		if (fi->fib_nh->nh_oif &&
		    nla_put_u32(skb, RTA_OIF, fi->fib_nh->nh_oif) < 0)
			goto errout;
	}

	if (fi->fib_nhs > 1) {
		struct rtnexthop *nhp;
		struct nlattr *mp_head;

		mp_head = nla_nest_start_noflag(skb, RTA_MULTIPATH);
		if (!mp_head)
			goto errout;

		for_nexthops(fi) {
			if (!(nhp = nla_reserve_nohdr(skb, sizeof(*nhp))))
				goto errout;

			nhp->rtnh_flags = nh->nh_flags & 0xFF;
			nhp->rtnh_hops = nh->nh_weight - 1;
			nhp->rtnh_ifindex = nh->nh_oif;

			if (nh->nh_gw &&
			    nla_put_le16(skb, RTA_GATEWAY, nh->nh_gw) < 0)
				goto errout;

			nhp->rtnh_len = skb_tail_pointer(skb) - (unsigned char *)nhp;
		} endfor_nexthops(fi);

		nla_nest_end(skb, mp_head);
	}

	nlmsg_end(skb, nlh);
	return 0;

errout:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}


static void dn_rtmsg_fib(int event, struct dn_fib_node *f, int z, u32 tb_id,
			struct nlmsghdr *nlh, struct netlink_skb_parms *req)
{
	struct sk_buff *skb;
	u32 portid = req ? req->portid : 0;
	int err = -ENOBUFS;

	skb = nlmsg_new(dn_fib_nlmsg_size(DN_FIB_INFO(f)), GFP_KERNEL);
	if (skb == NULL)
		goto errout;

	err = dn_fib_dump_info(skb, portid, nlh->nlmsg_seq, event, tb_id,
			       f->fn_type, f->fn_scope, &f->fn_key, z,
			       DN_FIB_INFO(f), 0);
	if (err < 0) {
		/* -EMSGSIZE implies BUG in dn_fib_nlmsg_size() */
		WARN_ON(err == -EMSGSIZE);
		kfree_skb(skb);
		goto errout;
	}
	rtnl_notify(skb, &init_net, portid, RTNLGRP_DECnet_ROUTE, nlh, GFP_KERNEL);
	return;
errout:
	if (err < 0)
		rtnl_set_sk_err(&init_net, RTNLGRP_DECnet_ROUTE, err);
}

static __inline__ int dn_hash_dump_bucket(struct sk_buff *skb,
				struct netlink_callback *cb,
				struct dn_fib_table *tb,
				struct dn_zone *dz,
				struct dn_fib_node *f)
{
	int i, s_i;

	s_i = cb->args[4];
	for(i = 0; f; i++, f = f->fn_next) {
		if (i < s_i)
			continue;
		if (f->fn_state & DN_S_ZOMBIE)
			continue;
		if (dn_fib_dump_info(skb, NETLINK_CB(cb->skb).portid,
				cb->nlh->nlmsg_seq,
				RTM_NEWROUTE,
				tb->n,
				(f->fn_state & DN_S_ZOMBIE) ? 0 : f->fn_type,
				f->fn_scope, &f->fn_key, dz->dz_order,
				f->fn_info, NLM_F_MULTI) < 0) {
			cb->args[4] = i;
			return -1;
		}
	}
	cb->args[4] = i;
	return skb->len;
}

static __inline__ int dn_hash_dump_zone(struct sk_buff *skb,
				struct netlink_callback *cb,
				struct dn_fib_table *tb,
				struct dn_zone *dz)
{
	int h, s_h;

	s_h = cb->args[3];
	for(h = 0; h < dz->dz_divisor; h++) {
		if (h < s_h)
			continue;
		if (h > s_h)
			memset(&cb->args[4], 0, sizeof(cb->args) - 4*sizeof(cb->args[0]));
		if (dz->dz_hash == NULL || dz->dz_hash[h] == NULL)
			continue;
		if (dn_hash_dump_bucket(skb, cb, tb, dz, dz->dz_hash[h]) < 0) {
			cb->args[3] = h;
			return -1;
		}
	}
	cb->args[3] = h;
	return skb->len;
}

static int dn_fib_table_dump(struct dn_fib_table *tb, struct sk_buff *skb,
				struct netlink_callback *cb)
{
	int m, s_m;
	struct dn_zone *dz;
	struct dn_hash *table = (struct dn_hash *)tb->data;

	s_m = cb->args[2];
	read_lock(&dn_fib_tables_lock);
	for(dz = table->dh_zone_list, m = 0; dz; dz = dz->dz_next, m++) {
		if (m < s_m)
			continue;
		if (m > s_m)
			memset(&cb->args[3], 0, sizeof(cb->args) - 3*sizeof(cb->args[0]));

		if (dn_hash_dump_zone(skb, cb, tb, dz) < 0) {
			cb->args[2] = m;
			read_unlock(&dn_fib_tables_lock);
			return -1;
		}
	}
	read_unlock(&dn_fib_tables_lock);
	cb->args[2] = m;

	return skb->len;
}

int dn_fib_dump(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct net *net = sock_net(skb->sk);
	unsigned int h, s_h;
	unsigned int e = 0, s_e;
	struct dn_fib_table *tb;
	int dumped = 0;

	if (!net_eq(net, &init_net))
		return 0;

	if (nlmsg_len(cb->nlh) >= sizeof(struct rtmsg) &&
		((struct rtmsg *)nlmsg_data(cb->nlh))->rtm_flags&RTM_F_CLONED)
			return dn_cache_dump(skb, cb);

	s_h = cb->args[0];
	s_e = cb->args[1];

	for (h = s_h; h < DN_FIB_TABLE_HASHSZ; h++, s_h = 0) {
		e = 0;
		hlist_for_each_entry(tb, &dn_fib_table_hash[h], hlist) {
			if (e < s_e)
				goto next;
			if (dumped)
				memset(&cb->args[2], 0, sizeof(cb->args) -
						 2 * sizeof(cb->args[0]));
			if (tb->dump(tb, skb, cb) < 0)
				goto out;
			dumped = 1;
next:
			e++;
		}
	}
out:
	cb->args[1] = e;
	cb->args[0] = h;

	return skb->len;
}

static int dn_fib_table_insert(struct dn_fib_table *tb, struct rtmsg *r, struct nlattr *attrs[],
			       struct nlmsghdr *n, struct netlink_skb_parms *req)
{
	struct dn_hash *table = (struct dn_hash *)tb->data;
	struct dn_fib_node *new_f, *f, **fp, **del_fp;
	struct dn_zone *dz;
	struct dn_fib_info *fi;
	int z = r->rtm_dst_len;
	int type = r->rtm_type;
	dn_fib_key_t key;
	int err;

	if (z > 16)
		return -EINVAL;

	dz = table->dh_zones[z];
	if (!dz && !(dz = dn_new_zone(table, z)))
		return -ENOBUFS;

	dz_key_0(key);
	if (attrs[RTA_DST]) {
		__le16 dst = nla_get_le16(attrs[RTA_DST]);
		if (dst & ~DZ_MASK(dz))
			return -EINVAL;
		key = dz_key(dst, dz);
	}

	if ((fi = dn_fib_create_info(r, attrs, n, &err)) == NULL)
		return err;

	if (dz->dz_nent > (dz->dz_divisor << 2) &&
			dz->dz_divisor > DN_MAX_DIVISOR &&
			(z==16 || (1<<z) > dz->dz_divisor))
		dn_rehash_zone(dz);

	fp = dn_chain_p(key, dz);

	DN_FIB_SCAN(f, fp) {
		if (dn_key_leq(key, f->fn_key))
			break;
	}

	del_fp = NULL;

	if (f && (f->fn_state & DN_S_ZOMBIE) &&
			dn_key_eq(f->fn_key, key)) {
		del_fp = fp;
		fp = &f->fn_next;
		f = *fp;
		goto create;
	}

	DN_FIB_SCAN_KEY(f, fp, key) {
		if (fi->fib_priority <= DN_FIB_INFO(f)->fib_priority)
			break;
	}

	if (f && dn_key_eq(f->fn_key, key) &&
			fi->fib_priority == DN_FIB_INFO(f)->fib_priority) {
		struct dn_fib_node **ins_fp;

		err = -EEXIST;
		if (n->nlmsg_flags & NLM_F_EXCL)
			goto out;

		if (n->nlmsg_flags & NLM_F_REPLACE) {
			del_fp = fp;
			fp = &f->fn_next;
			f = *fp;
			goto replace;
		}

		ins_fp = fp;
		err = -EEXIST;

		DN_FIB_SCAN_KEY(f, fp, key) {
			if (fi->fib_priority != DN_FIB_INFO(f)->fib_priority)
				break;
			if (f->fn_type == type &&
			    f->fn_scope == r->rtm_scope &&
			    DN_FIB_INFO(f) == fi)
				goto out;
		}

		if (!(n->nlmsg_flags & NLM_F_APPEND)) {
			fp = ins_fp;
			f = *fp;
		}
	}

create:
	err = -ENOENT;
	if (!(n->nlmsg_flags & NLM_F_CREATE))
		goto out;

replace:
	err = -ENOBUFS;
	new_f = kmem_cache_zalloc(dn_hash_kmem, GFP_KERNEL);
	if (new_f == NULL)
		goto out;

	new_f->fn_key = key;
	new_f->fn_type = type;
	new_f->fn_scope = r->rtm_scope;
	DN_FIB_INFO(new_f) = fi;

	new_f->fn_next = f;
	write_lock_bh(&dn_fib_tables_lock);
	*fp = new_f;
	write_unlock_bh(&dn_fib_tables_lock);
	dz->dz_nent++;

	if (del_fp) {
		f = *del_fp;
		write_lock_bh(&dn_fib_tables_lock);
		*del_fp = f->fn_next;
		write_unlock_bh(&dn_fib_tables_lock);

		if (!(f->fn_state & DN_S_ZOMBIE))
			dn_rtmsg_fib(RTM_DELROUTE, f, z, tb->n, n, req);
		if (f->fn_state & DN_S_ACCESSED)
			dn_rt_cache_flush(-1);
		dn_free_node(f);
		dz->dz_nent--;
	} else {
		dn_rt_cache_flush(-1);
	}

	dn_rtmsg_fib(RTM_NEWROUTE, new_f, z, tb->n, n, req);

	return 0;
out:
	dn_fib_release_info(fi);
	return err;
}


static int dn_fib_table_delete(struct dn_fib_table *tb, struct rtmsg *r, struct nlattr *attrs[],
			       struct nlmsghdr *n, struct netlink_skb_parms *req)
{
	struct dn_hash *table = (struct dn_hash*)tb->data;
	struct dn_fib_node **fp, **del_fp, *f;
	int z = r->rtm_dst_len;
	struct dn_zone *dz;
	dn_fib_key_t key;
	int matched;


	if (z > 16)
		return -EINVAL;

	if ((dz = table->dh_zones[z]) == NULL)
		return -ESRCH;

	dz_key_0(key);
	if (attrs[RTA_DST]) {
		__le16 dst = nla_get_le16(attrs[RTA_DST]);
		if (dst & ~DZ_MASK(dz))
			return -EINVAL;
		key = dz_key(dst, dz);
	}

	fp = dn_chain_p(key, dz);

	DN_FIB_SCAN(f, fp) {
		if (dn_key_eq(f->fn_key, key))
			break;
		if (dn_key_leq(key, f->fn_key))
			return -ESRCH;
	}

	matched = 0;
	del_fp = NULL;
	DN_FIB_SCAN_KEY(f, fp, key) {
		struct dn_fib_info *fi = DN_FIB_INFO(f);

		if (f->fn_state & DN_S_ZOMBIE)
			return -ESRCH;

		matched++;

		if (del_fp == NULL &&
				(!r->rtm_type || f->fn_type == r->rtm_type) &&
				(r->rtm_scope == RT_SCOPE_NOWHERE || f->fn_scope == r->rtm_scope) &&
				(!r->rtm_protocol ||
					fi->fib_protocol == r->rtm_protocol) &&
				dn_fib_nh_match(r, n, attrs, fi) == 0)
			del_fp = fp;
	}

	if (del_fp) {
		f = *del_fp;
		dn_rtmsg_fib(RTM_DELROUTE, f, z, tb->n, n, req);

		if (matched != 1) {
			write_lock_bh(&dn_fib_tables_lock);
			*del_fp = f->fn_next;
			write_unlock_bh(&dn_fib_tables_lock);

			if (f->fn_state & DN_S_ACCESSED)
				dn_rt_cache_flush(-1);
			dn_free_node(f);
			dz->dz_nent--;
		} else {
			f->fn_state |= DN_S_ZOMBIE;
			if (f->fn_state & DN_S_ACCESSED) {
				f->fn_state &= ~DN_S_ACCESSED;
				dn_rt_cache_flush(-1);
			}
			if (++dn_fib_hash_zombies > 128)
				dn_fib_flush();
		}

		return 0;
	}

	return -ESRCH;
}

static inline int dn_flush_list(struct dn_fib_node **fp, int z, struct dn_hash *table)
{
	int found = 0;
	struct dn_fib_node *f;

	while((f = *fp) != NULL) {
		struct dn_fib_info *fi = DN_FIB_INFO(f);

		if (fi && ((f->fn_state & DN_S_ZOMBIE) || (fi->fib_flags & RTNH_F_DEAD))) {
			write_lock_bh(&dn_fib_tables_lock);
			*fp = f->fn_next;
			write_unlock_bh(&dn_fib_tables_lock);

			dn_free_node(f);
			found++;
			continue;
		}
		fp = &f->fn_next;
	}

	return found;
}

static int dn_fib_table_flush(struct dn_fib_table *tb)
{
	struct dn_hash *table = (struct dn_hash *)tb->data;
	struct dn_zone *dz;
	int found = 0;

	dn_fib_hash_zombies = 0;
	for(dz = table->dh_zone_list; dz; dz = dz->dz_next) {
		int i;
		int tmp = 0;
		for(i = dz->dz_divisor-1; i >= 0; i--)
			tmp += dn_flush_list(&dz->dz_hash[i], dz->dz_order, table);
		dz->dz_nent -= tmp;
		found += tmp;
	}

	return found;
}

static int dn_fib_table_lookup(struct dn_fib_table *tb, const struct flowidn *flp, struct dn_fib_res *res)
{
	int err;
	struct dn_zone *dz;
	struct dn_hash *t = (struct dn_hash *)tb->data;

	read_lock(&dn_fib_tables_lock);
	for(dz = t->dh_zone_list; dz; dz = dz->dz_next) {
		struct dn_fib_node *f;
		dn_fib_key_t k = dz_key(flp->daddr, dz);

		for(f = dz_chain(k, dz); f; f = f->fn_next) {
			if (!dn_key_eq(k, f->fn_key)) {
				if (dn_key_leq(k, f->fn_key))
					break;
				else
					continue;
			}

			f->fn_state |= DN_S_ACCESSED;

			if (f->fn_state&DN_S_ZOMBIE)
				continue;

			if (f->fn_scope < flp->flowidn_scope)
				continue;

			err = dn_fib_semantic_match(f->fn_type, DN_FIB_INFO(f), flp, res);

			if (err == 0) {
				res->type = f->fn_type;
				res->scope = f->fn_scope;
				res->prefixlen = dz->dz_order;
				goto out;
			}
			if (err < 0)
				goto out;
		}
	}
	err = 1;
out:
	read_unlock(&dn_fib_tables_lock);
	return err;
}


struct dn_fib_table *dn_fib_get_table(u32 n, int create)
{
	struct dn_fib_table *t;
	unsigned int h;

	if (n < RT_TABLE_MIN)
		return NULL;

	if (n > RT_TABLE_MAX)
		return NULL;

	h = n & (DN_FIB_TABLE_HASHSZ - 1);
	rcu_read_lock();
	hlist_for_each_entry_rcu(t, &dn_fib_table_hash[h], hlist) {
		if (t->n == n) {
			rcu_read_unlock();
			return t;
		}
	}
	rcu_read_unlock();

	if (!create)
		return NULL;

	if (in_interrupt()) {
		net_dbg_ratelimited(""DECnet: BUG! Attempt to create routing table from interrupt\n"");
		return NULL;
	}

	t = kzalloc(sizeof(struct dn_fib_table) + sizeof(struct dn_hash),
		    GFP_KERNEL);
	if (t == NULL)
		return NULL;

	t->n = n;
	t->insert = dn_fib_table_insert;
	t->delete = dn_fib_table_delete;
	t->lookup = dn_fib_table_lookup;
	t->flush  = dn_fib_table_flush;
	t->dump = dn_fib_table_dump;
	hlist_add_head_rcu(&t->hlist, &dn_fib_table_hash[h]);

	return t;
}

struct dn_fib_table *dn_fib_empty_table(void)
{
	u32 id;

	for(id = RT_TABLE_MIN; id <= RT_TABLE_MAX; id++)
		if (dn_fib_get_table(id, 0) == NULL)
			return dn_fib_get_table(id, 1);
	return NULL;
}

void dn_fib_flush(void)
{
	int flushed = 0;
	struct dn_fib_table *tb;
	unsigned int h;

	for (h = 0; h < DN_FIB_TABLE_HASHSZ; h++) {
		hlist_for_each_entry(tb, &dn_fib_table_hash[h], hlist)
			flushed += tb->flush(tb);
	}

	if (flushed)
		dn_rt_cache_flush(-1);
}

void __init dn_fib_table_init(void)
{
	dn_hash_kmem = kmem_cache_create(""dn_fib_info_cache"",
					sizeof(struct dn_fib_info),
					0, SLAB_HWCACHE_ALIGN,
					NULL);
}

void __exit dn_fib_table_cleanup(void)
{
	struct dn_fib_table *t;
	struct hlist_node *next;
	unsigned int h;

	write_lock(&dn_fib_tables_lock);
	for (h = 0; h < DN_FIB_TABLE_HASHSZ; h++) {
		hlist_for_each_entry_safe(t, next, &dn_fib_table_hash[h],
					  hlist) {
			hlist_del(&t->hlist);
			kfree(t);
		}
	}
	write_unlock(&dn_fib_tables_lock);
}",1202cdd665315c525b5237e96e0bedc76d7e754f,CVE-2023-3338,1202cdd665315c525b5237e96e0bedc76d7e754f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,"  /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR (VAR VAR) * * VAR: VAR VAR <VAR@VAR.VAR> * VAR VAR VAR VAR VAR VAR VAR * * * VAR: * */                           VAR VAR { VAR VAR *VAR; VAR VAR **VAR; VAR VAR; VAR VAR; VAR VAR;  VAR VAR; VAR VAR;  }; VAR VAR { VAR VAR *VAR[17]; VAR VAR *VAR; };   VAR(VAR = 0, VAR = (VAR)->VAR; VAR < (VAR)->VAR; VAR++, VAR++)      VAR( ; ((VAR) = *(VAR)) != VAR; (VAR) = &(VAR)->VAR)  VAR( ; ((VAR) = *(VAR)) != VAR && VAR((VAR)->VAR, (VAR)); (VAR) = &(VAR)->VAR)   VAR VAR VAR VAR[VAR]; VAR VAR(VAR); VAR VAR VAR *VAR VAR; VAR VAR VAR; VAR VAR VAR VAR(VAR VAR, VAR VAR *VAR) { VAR VAR = VAR(VAR.VAR)>>(16 - VAR->VAR); VAR ^= (VAR >> 10); VAR ^= (VAR >> 6); VAR &= VAR(VAR); VAR *(VAR *)&VAR; } VAR VAR VAR VAR(VAR VAR, VAR VAR *VAR) { VAR VAR; VAR.VAR = VAR & VAR(VAR); VAR VAR; } VAR VAR VAR VAR **VAR(VAR VAR, VAR VAR *VAR) { VAR &VAR->VAR[VAR(VAR, VAR).VAR]; } VAR VAR VAR VAR *VAR(VAR VAR, VAR VAR *VAR) { VAR VAR->VAR[VAR(VAR, VAR).VAR]; } VAR VAR VAR VAR(VAR VAR, VAR VAR) { VAR VAR.VAR == VAR.VAR; } VAR VAR VAR VAR(VAR VAR, VAR VAR) { VAR VAR.VAR <= VAR.VAR; } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR **VAR, VAR VAR) { VAR VAR *VAR, **VAR, *VAR; VAR VAR; VAR(VAR = 0; VAR < VAR; VAR++) { VAR(VAR = VAR[VAR]; VAR; VAR = VAR) { VAR = VAR->VAR; VAR(VAR = VAR(VAR->VAR, VAR); *VAR && VAR((*VAR)->VAR, VAR->VAR); VAR = &(*VAR)->VAR) ; VAR->VAR = *VAR; *VAR = VAR; } } } VAR VAR VAR(VAR VAR *VAR) { VAR VAR **VAR, **VAR; VAR VAR, VAR; VAR VAR; VAR = VAR->VAR; VAR (VAR) { VAR 16: VAR = 256; VAR = 0xFF; VAR; VAR: VAR(VAR ""VAR: VAR: VAR! %VAR\VAR"", VAR); VAR; VAR 256: VAR = 1024; VAR = 0x3FF; VAR; } VAR = VAR(VAR, VAR(VAR VAR*), VAR); VAR (VAR == VAR) VAR; VAR(&VAR); VAR = VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR(VAR, VAR, VAR); VAR(&VAR); VAR(VAR); } VAR VAR VAR(VAR VAR *VAR) { VAR(VAR(VAR)); VAR(VAR, VAR); } VAR VAR VAR *VAR(VAR VAR *VAR, VAR VAR) { VAR VAR; VAR VAR *VAR = VAR(VAR(VAR VAR), VAR); VAR (!VAR) VAR VAR; VAR (VAR) { VAR->VAR = 16; VAR->VAR = 0x0F; } VAR { VAR->VAR = 1; VAR->VAR = 0; } VAR->VAR = VAR(VAR->VAR, VAR(VAR VAR *), VAR); VAR (!VAR->VAR) { VAR(VAR); VAR VAR; } VAR->VAR = VAR; VAR->VAR = VAR(VAR); VAR(VAR = VAR + 1; VAR <= 16; VAR++) VAR (VAR->VAR[VAR]) VAR; VAR(&VAR); VAR (VAR>16) { VAR->VAR = VAR->VAR; VAR->VAR = VAR; } VAR { VAR->VAR = VAR->VAR[VAR]->VAR; VAR->VAR[VAR]->VAR = VAR; } VAR->VAR[VAR] = VAR; VAR(&VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR[], VAR VAR *VAR) { VAR VAR *VAR; VAR VAR; VAR (VAR[VAR] && VAR(VAR[VAR]) != VAR->VAR) VAR 1; VAR (VAR[VAR] || VAR[VAR]) { VAR ((!VAR[VAR] || VAR(VAR[VAR]) == VAR->VAR->VAR) && (!VAR[VAR] || VAR(VAR[VAR]) != VAR->VAR->VAR)) VAR 0; VAR 1; } VAR (!VAR[VAR]) VAR 0; VAR = VAR(VAR[VAR]); VAR = VAR(VAR[VAR]); VAR(VAR) { VAR VAR = VAR - VAR(VAR VAR); VAR VAR; VAR (VAR < 0 || (VAR -= VAR->VAR) < 0) VAR -VAR; VAR (VAR->VAR && VAR->VAR != VAR->VAR) VAR 1; VAR (VAR) { VAR VAR *VAR; VAR = VAR((VAR VAR *) (VAR + 1), VAR, VAR); VAR = VAR ? VAR(VAR) : 0; VAR (VAR && VAR != VAR->VAR) VAR 1; } VAR = VAR(VAR); } VAR(VAR); VAR 0; } VAR VAR VAR VAR(VAR VAR *VAR) { VAR VAR = VAR(VAR(VAR VAR)) + VAR(4)  + VAR(2)  + VAR(4)  + VAR(VAR);   VAR += VAR((VAR * VAR(4))); VAR (VAR->VAR) {   VAR VAR = VAR(VAR(VAR VAR));  VAR += VAR(4);  VAR += VAR(VAR->VAR * VAR); } VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR *VAR, VAR VAR, VAR VAR *VAR, VAR VAR VAR) { VAR VAR *VAR; VAR VAR *VAR; VAR = VAR(VAR, VAR, VAR, VAR, VAR(*VAR), VAR); VAR (!VAR) VAR -VAR; VAR = VAR(VAR); VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = 0; VAR->VAR = 0; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR (VAR(VAR, VAR, VAR) < 0) VAR VAR; VAR (VAR->VAR && VAR(VAR, VAR, 2, VAR) < 0) VAR VAR; VAR (VAR->VAR && VAR(VAR, VAR, VAR->VAR) < 0) VAR VAR; VAR (VAR(VAR, VAR->VAR) < 0) VAR VAR; VAR (VAR->VAR == 1) { VAR (VAR->VAR->VAR && VAR(VAR, VAR, VAR->VAR->VAR) < 0) VAR VAR; VAR (VAR->VAR->VAR && VAR(VAR, VAR, VAR->VAR->VAR) < 0) VAR VAR; } VAR (VAR->VAR > 1) { VAR VAR *VAR; VAR VAR *VAR; VAR = VAR(VAR, VAR); VAR (!VAR) VAR VAR; VAR(VAR) { VAR (!(VAR = VAR(VAR, VAR(*VAR)))) VAR VAR; VAR->VAR = VAR->VAR & 0xFF; VAR->VAR = VAR->VAR - 1; VAR->VAR = VAR->VAR; VAR (VAR->VAR && VAR(VAR, VAR, VAR->VAR) < 0) VAR VAR; VAR->VAR = VAR(VAR) - (VAR VAR *)VAR; } VAR(VAR); VAR(VAR, VAR); } VAR(VAR, VAR); VAR 0; VAR: VAR(VAR, VAR); VAR -VAR; } VAR VAR VAR(VAR VAR, VAR VAR *VAR, VAR VAR, VAR VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR; VAR VAR = VAR ? VAR->VAR : 0; VAR VAR = -VAR; VAR = VAR(VAR(VAR(VAR)), VAR); VAR (VAR == VAR) VAR VAR; VAR = VAR(VAR, VAR, VAR->VAR, VAR, VAR, VAR->VAR, VAR->VAR, &VAR->VAR, VAR, VAR(VAR), 0); VAR (VAR < 0) {  VAR(VAR == -VAR); VAR(VAR); VAR VAR; } VAR(VAR, &VAR, VAR, VAR, VAR, VAR); VAR; VAR: VAR (VAR < 0) VAR(&VAR, VAR, VAR); } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR, VAR; VAR = VAR->VAR[4]; VAR(VAR = 0; VAR; VAR++, VAR = VAR->VAR) { VAR (VAR < VAR) VAR; VAR (VAR->VAR & VAR) VAR; VAR (VAR(VAR, VAR(VAR->VAR).VAR, VAR->VAR->VAR, VAR, VAR->VAR, (VAR->VAR & VAR) ? 0 : VAR->VAR, VAR->VAR, &VAR->VAR, VAR->VAR, VAR->VAR, VAR) < 0) { VAR->VAR[4] = VAR; VAR -1; } } VAR->VAR[4] = VAR; VAR VAR->VAR; } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR, VAR; VAR = VAR->VAR[3]; VAR(VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR < VAR) VAR; VAR (VAR > VAR) VAR(&VAR->VAR[4], 0, VAR(VAR->VAR) - 4*VAR(VAR->VAR[0])); VAR (VAR->VAR == VAR || VAR->VAR[VAR] == VAR) VAR; VAR (VAR(VAR, VAR, VAR, VAR, VAR->VAR[VAR]) < 0) { VAR->VAR[3] = VAR; VAR -1; } } VAR->VAR[3] = VAR; VAR VAR->VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR, VAR; VAR VAR *VAR; VAR VAR *VAR = (VAR VAR *)VAR->VAR; VAR = VAR->VAR[2]; VAR(&VAR); VAR(VAR = VAR->VAR, VAR = 0; VAR; VAR = VAR->VAR, VAR++) { VAR (VAR < VAR) VAR; VAR (VAR > VAR) VAR(&VAR->VAR[3], 0, VAR(VAR->VAR) - 3*VAR(VAR->VAR[0])); VAR (VAR(VAR, VAR, VAR, VAR) < 0) { VAR->VAR[2] = VAR; VAR(&VAR); VAR -1; } } VAR(&VAR); VAR->VAR[2] = VAR; VAR VAR->VAR; } VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR VAR, VAR; VAR VAR VAR = 0, VAR; VAR VAR *VAR; VAR VAR = 0; VAR (!VAR(VAR, &VAR)) VAR 0; VAR (VAR(VAR->VAR) >= VAR(VAR VAR) && ((VAR VAR *)VAR(VAR->VAR))->VAR&VAR) VAR VAR(VAR, VAR); VAR = VAR->VAR[0]; VAR = VAR->VAR[1]; VAR (VAR = VAR; VAR < VAR; VAR++, VAR = 0) { VAR = 0; VAR(VAR, &VAR[VAR], VAR) { VAR (VAR < VAR) VAR VAR; VAR (VAR) VAR(&VAR->VAR[2], 0, VAR(VAR->VAR) - 2 * VAR(VAR->VAR[0])); VAR (VAR->VAR(VAR, VAR, VAR) < 0) VAR VAR; VAR = 1; VAR: VAR++; } } VAR: VAR->VAR[1] = VAR; VAR->VAR[0] = VAR; VAR VAR->VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR[], VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = (VAR VAR *)VAR->VAR; VAR VAR *VAR, *VAR, **VAR, **VAR; VAR VAR *VAR; VAR VAR *VAR; VAR VAR = VAR->VAR; VAR VAR = VAR->VAR; VAR VAR; VAR VAR; VAR (VAR > 16) VAR -VAR; VAR = VAR->VAR[VAR]; VAR (!VAR && !(VAR = VAR(VAR, VAR))) VAR -VAR; VAR(VAR); VAR (VAR[VAR]) { VAR VAR = VAR(VAR[VAR]); VAR (VAR & ~VAR(VAR)) VAR -VAR; VAR = VAR(VAR, VAR); } VAR ((VAR = VAR(VAR, VAR, VAR, &VAR)) == VAR) VAR VAR; VAR (VAR->VAR > (VAR->VAR << 2) && VAR->VAR > VAR && (VAR==16 || (1<<VAR) > VAR->VAR)) VAR(VAR); VAR = VAR(VAR, VAR); VAR(VAR, VAR) { VAR (VAR(VAR, VAR->VAR)) VAR; } VAR = VAR; VAR (VAR && (VAR->VAR & VAR) && VAR(VAR->VAR, VAR)) { VAR = VAR; VAR = &VAR->VAR; VAR = *VAR; VAR VAR; } VAR(VAR, VAR, VAR) { VAR (VAR->VAR <= VAR(VAR)->VAR) VAR; } VAR (VAR && VAR(VAR->VAR, VAR) && VAR->VAR == VAR(VAR)->VAR) { VAR VAR **VAR; VAR = -VAR; VAR (VAR->VAR & VAR) VAR VAR; VAR (VAR->VAR & VAR) { VAR = VAR; VAR = &VAR->VAR; VAR = *VAR; VAR VAR; } VAR = VAR; VAR = -VAR; VAR(VAR, VAR, VAR) { VAR (VAR->VAR != VAR(VAR)->VAR) VAR; VAR (VAR->VAR == VAR && VAR->VAR == VAR->VAR && VAR(VAR) == VAR) VAR VAR; } VAR (!(VAR->VAR & VAR)) { VAR = VAR; VAR = *VAR; } } VAR: VAR = -VAR; VAR (!(VAR->VAR & VAR)) VAR VAR; VAR: VAR = -VAR; VAR = VAR(VAR, VAR); VAR (VAR == VAR) VAR VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR(VAR) = VAR; VAR->VAR = VAR; VAR(&VAR); *VAR = VAR; VAR(&VAR); VAR->VAR++; VAR (VAR) { VAR = *VAR; VAR(&VAR); *VAR = VAR->VAR; VAR(&VAR); VAR (!(VAR->VAR & VAR)) VAR(VAR, VAR, VAR, VAR->VAR, VAR, VAR); VAR (VAR->VAR & VAR) VAR(-1); VAR(VAR); VAR->VAR--; } VAR { VAR(-1); } VAR(VAR, VAR, VAR, VAR->VAR, VAR, VAR); VAR 0; VAR: VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR[], VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = (VAR VAR*)VAR->VAR; VAR VAR **VAR, **VAR, *VAR; VAR VAR = VAR->VAR; VAR VAR *VAR; VAR VAR; VAR VAR; VAR (VAR > 16) VAR -VAR; VAR ((VAR = VAR->VAR[VAR]) == VAR) VAR -VAR; VAR(VAR); VAR (VAR[VAR]) { VAR VAR = VAR(VAR[VAR]); VAR (VAR & ~VAR(VAR)) VAR -VAR; VAR = VAR(VAR, VAR); } VAR = VAR(VAR, VAR); VAR(VAR, VAR) { VAR (VAR(VAR->VAR, VAR)) VAR; VAR (VAR(VAR, VAR->VAR)) VAR -VAR; } VAR = 0; VAR = VAR; VAR(VAR, VAR, VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR->VAR & VAR) VAR -VAR; VAR++; VAR (VAR == VAR && (!VAR->VAR || VAR->VAR == VAR->VAR) && (VAR->VAR == VAR || VAR->VAR == VAR->VAR) && (!VAR->VAR || VAR->VAR == VAR->VAR) && VAR(VAR, VAR, VAR, VAR) == 0) VAR = VAR; } VAR (VAR) { VAR = *VAR; VAR(VAR, VAR, VAR, VAR->VAR, VAR, VAR); VAR (VAR != 1) { VAR(&VAR); *VAR = VAR->VAR; VAR(&VAR); VAR (VAR->VAR & VAR) VAR(-1); VAR(VAR); VAR->VAR--; } VAR { VAR->VAR |= VAR; VAR (VAR->VAR & VAR) { VAR->VAR &= ~VAR; VAR(-1); } VAR (++VAR > 128) VAR(); } VAR 0; } VAR -VAR; } VAR VAR VAR VAR(VAR VAR **VAR, VAR VAR, VAR VAR *VAR) { VAR VAR = 0; VAR VAR *VAR; VAR((VAR = *VAR) != VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR && ((VAR->VAR & VAR) || (VAR->VAR & VAR))) { VAR(&VAR); *VAR = VAR->VAR; VAR(&VAR); VAR(VAR); VAR++; VAR; } VAR = &VAR->VAR; } VAR VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = (VAR VAR *)VAR->VAR; VAR VAR *VAR; VAR VAR = 0; VAR = 0; VAR(VAR = VAR->VAR; VAR; VAR = VAR->VAR) { VAR VAR; VAR VAR = 0; VAR(VAR = VAR->VAR-1; VAR >= 0; VAR--) VAR += VAR(&VAR->VAR[VAR], VAR->VAR, VAR); VAR->VAR -= VAR; VAR += VAR; } VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR *VAR) { VAR VAR; VAR VAR *VAR; VAR VAR *VAR = (VAR VAR *)VAR->VAR; VAR(&VAR); VAR(VAR = VAR->VAR; VAR; VAR = VAR->VAR) { VAR VAR *VAR; VAR VAR = VAR(VAR->VAR, VAR); VAR(VAR = VAR(VAR, VAR); VAR; VAR = VAR->VAR) { VAR (!VAR(VAR, VAR->VAR)) { VAR (VAR(VAR, VAR->VAR)) VAR; VAR VAR; } VAR->VAR |= VAR; VAR (VAR->VAR&VAR) VAR; VAR (VAR->VAR < VAR->VAR) VAR; VAR = VAR(VAR->VAR, VAR(VAR), VAR, VAR); VAR (VAR == 0) { VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR VAR; } VAR (VAR < 0) VAR VAR; } } VAR = 1; VAR: VAR(&VAR); VAR VAR; } VAR VAR *VAR(VAR VAR, VAR VAR) { VAR VAR *VAR; VAR VAR VAR; VAR (VAR < VAR) VAR VAR; VAR (VAR > VAR) VAR VAR; VAR = VAR & (VAR - 1); VAR(); VAR(VAR, &VAR[VAR], VAR) { VAR (VAR->VAR == VAR) { VAR(); VAR VAR; } } VAR(); VAR (!VAR) VAR VAR; VAR (VAR()) { VAR(""VAR: VAR! VAR VAR VAR VAR VAR VAR VAR\VAR""); VAR VAR; } VAR = VAR(VAR(VAR VAR) + VAR(VAR VAR), VAR); VAR (VAR == VAR) VAR VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR(&VAR->VAR, &VAR[VAR]); VAR VAR; } VAR VAR *VAR(VAR) { VAR VAR; VAR(VAR = VAR; VAR <= VAR; VAR++) VAR (VAR(VAR, 0) == VAR) VAR VAR(VAR, 1); VAR VAR; } VAR VAR(VAR) { VAR VAR = 0; VAR VAR *VAR; VAR VAR VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR(VAR, &VAR[VAR], VAR) VAR += VAR->VAR(VAR); } VAR (VAR) VAR(-1); } VAR VAR VAR(VAR) { VAR = VAR(""VAR"", VAR(VAR VAR), 0, VAR, VAR); } VAR VAR VAR(VAR) { VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR; VAR(&VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR(VAR, VAR, &VAR[VAR], VAR) { VAR(&VAR->VAR); VAR(VAR); } } VAR(&VAR); }",1
linux_265b4da82dbf5df04bee5a5d46b7474b1aaf326a,net/sched/cls_rsvp.h,,"/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * net/sched/cls_rsvp.h	Template file for RSVPv[46] classifiers.
 *
 * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
 */

/*
   Comparing to general packet classification problem,
   RSVP needs only several relatively simple rules:

   * (dst, protocol) are always specified,
     so that we are able to hash them.
   * src may be exact, or may be wildcard, so that
     we can keep a hash table plus one wildcard entry.
   * source port (or flow label) is important only if src is given.

   IMPLEMENTATION.

   We use a two level hash table: The top level is keyed by
   destination address and protocol ID, every bucket contains a list
   of ""rsvp sessions"", identified by destination address, protocol and
   DPI(=""Destination Port ID""): triple (key, mask, offset).

   Every bucket has a smaller hash table keyed by source address
   (cf. RSVP flowspec) and one wildcard entry for wildcard reservations.
   Every bucket is again a list of ""RSVP flows"", selected by
   source address and SPI(=""Source Port ID"" here rather than
   ""security parameter index""): triple (key, mask, offset).


   NOTE 1. All the packets with IPv6 extension headers (but AH and ESP)
   and all fragmented packets go to the best-effort traffic class.


   NOTE 2. Two ""port id""'s seems to be redundant, rfc2207 requires
   only one ""Generalized Port Identifier"". So that for classic
   ah, esp (and udp,tcp) both *pi should coincide or one of them
   should be wildcard.

   At first sight, this redundancy is just a waste of CPU
   resources. But DPI and SPI add the possibility to assign different
   priorities to GPIs. Look also at note 4 about tunnels below.


   NOTE 3. One complication is the case of tunneled packets.
   We implement it as following: if the first lookup
   matches a special session with ""tunnelhdr"" value not zero,
   flowid doesn't contain the true flow ID, but the tunnel ID (1...255).
   In this case, we pull tunnelhdr bytes and restart lookup
   with tunnel ID added to the list of keys. Simple and stupid 8)8)
   It's enough for PIMREG and IPIP.


   NOTE 4. Two GPIs make it possible to parse even GRE packets.
   F.e. DPI can select ETH_P_IP (and necessary flags to make
   tunnelhdr correct) in GRE protocol field and SPI matches
   GRE key. Is it not nice? 8)8)


   Well, as result, despite its simplicity, we get a pretty
   powerful classification engine.  */


struct rsvp_head {
	u32			tmap[256/32];
	u32			hgenerator;
	u8			tgenerator;
	struct rsvp_session __rcu *ht[256];
	struct rcu_head		rcu;
};

struct rsvp_session {
	struct rsvp_session __rcu	*next;
	__be32				dst[RSVP_DST_LEN];
	struct tc_rsvp_gpi		dpi;
	u8				protocol;
	u8				tunnelid;
	/* 16 (src,sport) hash slots, and one wildcard source slot */
	struct rsvp_filter __rcu	*ht[16 + 1];
	struct rcu_head			rcu;
};


struct rsvp_filter {
	struct rsvp_filter __rcu	*next;
	__be32				src[RSVP_DST_LEN];
	struct tc_rsvp_gpi		spi;
	u8				tunnelhdr;

	struct tcf_result		res;
	struct tcf_exts			exts;

	u32				handle;
	struct rsvp_session		*sess;
	struct rcu_work			rwork;
};

static inline unsigned int hash_dst(__be32 *dst, u8 protocol, u8 tunnelid)
{
	unsigned int h = (__force __u32)dst[RSVP_DST_LEN - 1];

	h ^= h>>16;
	h ^= h>>8;
	return (h ^ protocol ^ tunnelid) & 0xFF;
}

static inline unsigned int hash_src(__be32 *src)
{
	unsigned int h = (__force __u32)src[RSVP_DST_LEN-1];

	h ^= h>>16;
	h ^= h>>8;
	h ^= h>>4;
	return h & 0xF;
}

#define RSVP_APPLY_RESULT()				\
{							\
	int r = tcf_exts_exec(skb, &f->exts, res);	\
	if (r < 0)					\
		continue;				\
	else if (r > 0)					\
		return r;				\
}

TC_INDIRECT_SCOPE int RSVP_CLS(struct sk_buff *skb, const struct tcf_proto *tp,
			       struct tcf_result *res)
{
	struct rsvp_head *head = rcu_dereference_bh(tp->root);
	struct rsvp_session *s;
	struct rsvp_filter *f;
	unsigned int h1, h2;
	__be32 *dst, *src;
	u8 protocol;
	u8 tunnelid = 0;
	u8 *xprt;
#if RSVP_DST_LEN == 4
	struct ipv6hdr *nhptr;

	if (!pskb_network_may_pull(skb, sizeof(*nhptr)))
		return -1;
	nhptr = ipv6_hdr(skb);
#else
	struct iphdr *nhptr;

	if (!pskb_network_may_pull(skb, sizeof(*nhptr)))
		return -1;
	nhptr = ip_hdr(skb);
#endif
restart:

#if RSVP_DST_LEN == 4
	src = &nhptr->saddr.s6_addr32[0];
	dst = &nhptr->daddr.s6_addr32[0];
	protocol = nhptr->nexthdr;
	xprt = ((u8 *)nhptr) + sizeof(struct ipv6hdr);
#else
	src = &nhptr->saddr;
	dst = &nhptr->daddr;
	protocol = nhptr->protocol;
	xprt = ((u8 *)nhptr) + (nhptr->ihl<<2);
	if (ip_is_fragment(nhptr))
		return -1;
#endif

	h1 = hash_dst(dst, protocol, tunnelid);
	h2 = hash_src(src);

	for (s = rcu_dereference_bh(head->ht[h1]); s;
	     s = rcu_dereference_bh(s->next)) {
		if (dst[RSVP_DST_LEN-1] == s->dst[RSVP_DST_LEN - 1] &&
		    protocol == s->protocol &&
		    !(s->dpi.mask &
		      (*(u32 *)(xprt + s->dpi.offset) ^ s->dpi.key)) &&
#if RSVP_DST_LEN == 4
		    dst[0] == s->dst[0] &&
		    dst[1] == s->dst[1] &&
		    dst[2] == s->dst[2] &&
#endif
		    tunnelid == s->tunnelid) {

			for (f = rcu_dereference_bh(s->ht[h2]); f;
			     f = rcu_dereference_bh(f->next)) {
				if (src[RSVP_DST_LEN-1] == f->src[RSVP_DST_LEN - 1] &&
				    !(f->spi.mask & (*(u32 *)(xprt + f->spi.offset) ^ f->spi.key))
#if RSVP_DST_LEN == 4
				    &&
				    src[0] == f->src[0] &&
				    src[1] == f->src[1] &&
				    src[2] == f->src[2]
#endif
				    ) {
					*res = f->res;
					RSVP_APPLY_RESULT();

matched:
					if (f->tunnelhdr == 0)
						return 0;

					tunnelid = f->res.classid;
					nhptr = (void *)(xprt + f->tunnelhdr - sizeof(*nhptr));
					goto restart;
				}
			}

			/* And wildcard bucket... */
			for (f = rcu_dereference_bh(s->ht[16]); f;
			     f = rcu_dereference_bh(f->next)) {
				*res = f->res;
				RSVP_APPLY_RESULT();
				goto matched;
			}
			return -1;
		}
	}
	return -1;
}

static void rsvp_replace(struct tcf_proto *tp, struct rsvp_filter *n, u32 h)
{
	struct rsvp_head *head = rtnl_dereference(tp->root);
	struct rsvp_session *s;
	struct rsvp_filter __rcu **ins;
	struct rsvp_filter *pins;
	unsigned int h1 = h & 0xFF;
	unsigned int h2 = (h >> 8) & 0xFF;

	for (s = rtnl_dereference(head->ht[h1]); s;
	     s = rtnl_dereference(s->next)) {
		for (ins = &s->ht[h2], pins = rtnl_dereference(*ins); ;
		     ins = &pins->next, pins = rtnl_dereference(*ins)) {
			if (pins->handle == h) {
				RCU_INIT_POINTER(n->next, pins->next);
				rcu_assign_pointer(*ins, n);
				return;
			}
		}
	}

	/* Something went wrong if we are trying to replace a non-existent
	 * node. Mind as well halt instead of silently failing.
	 */
	BUG_ON(1);
}

static void *rsvp_get(struct tcf_proto *tp, u32 handle)
{
	struct rsvp_head *head = rtnl_dereference(tp->root);
	struct rsvp_session *s;
	struct rsvp_filter *f;
	unsigned int h1 = handle & 0xFF;
	unsigned int h2 = (handle >> 8) & 0xFF;

	if (h2 > 16)
		return NULL;

	for (s = rtnl_dereference(head->ht[h1]); s;
	     s = rtnl_dereference(s->next)) {
		for (f = rtnl_dereference(s->ht[h2]); f;
		     f = rtnl_dereference(f->next)) {
			if (f->handle == handle)
				return f;
		}
	}
	return NULL;
}

static int rsvp_init(struct tcf_proto *tp)
{
	struct rsvp_head *data;

	data = kzalloc(sizeof(struct rsvp_head), GFP_KERNEL);
	if (data) {
		rcu_assign_pointer(tp->root, data);
		return 0;
	}
	return -ENOBUFS;
}

static void __rsvp_delete_filter(struct rsvp_filter *f)
{
	tcf_exts_destroy(&f->exts);
	tcf_exts_put_net(&f->exts);
	kfree(f);
}

static void rsvp_delete_filter_work(struct work_struct *work)
{
	struct rsvp_filter *f = container_of(to_rcu_work(work),
					     struct rsvp_filter,
					     rwork);
	rtnl_lock();
	__rsvp_delete_filter(f);
	rtnl_unlock();
}

static void rsvp_delete_filter(struct tcf_proto *tp, struct rsvp_filter *f)
{
	tcf_unbind_filter(tp, &f->res);
	/* all classifiers are required to call tcf_exts_destroy() after rcu
	 * grace period, since converted-to-rcu actions are relying on that
	 * in cleanup() callback
	 */
	if (tcf_exts_get_net(&f->exts))
		tcf_queue_work(&f->rwork, rsvp_delete_filter_work);
	else
		__rsvp_delete_filter(f);
}

static void rsvp_destroy(struct tcf_proto *tp, bool rtnl_held,
			 struct netlink_ext_ack *extack)
{
	struct rsvp_head *data = rtnl_dereference(tp->root);
	int h1, h2;

	if (data == NULL)
		return;

	for (h1 = 0; h1 < 256; h1++) {
		struct rsvp_session *s;

		while ((s = rtnl_dereference(data->ht[h1])) != NULL) {
			RCU_INIT_POINTER(data->ht[h1], s->next);

			for (h2 = 0; h2 <= 16; h2++) {
				struct rsvp_filter *f;

				while ((f = rtnl_dereference(s->ht[h2])) != NULL) {
					rcu_assign_pointer(s->ht[h2], f->next);
					rsvp_delete_filter(tp, f);
				}
			}
			kfree_rcu(s, rcu);
		}
	}
	kfree_rcu(data, rcu);
}

static int rsvp_delete(struct tcf_proto *tp, void *arg, bool *last,
		       bool rtnl_held, struct netlink_ext_ack *extack)
{
	struct rsvp_head *head = rtnl_dereference(tp->root);
	struct rsvp_filter *nfp, *f = arg;
	struct rsvp_filter __rcu **fp;
	unsigned int h = f->handle;
	struct rsvp_session __rcu **sp;
	struct rsvp_session *nsp, *s = f->sess;
	int i, h1;

	fp = &s->ht[(h >> 8) & 0xFF];
	for (nfp = rtnl_dereference(*fp); nfp;
	     fp = &nfp->next, nfp = rtnl_dereference(*fp)) {
		if (nfp == f) {
			RCU_INIT_POINTER(*fp, f->next);
			rsvp_delete_filter(tp, f);

			/* Strip tree */

			for (i = 0; i <= 16; i++)
				if (s->ht[i])
					goto out;

			/* OK, session has no flows */
			sp = &head->ht[h & 0xFF];
			for (nsp = rtnl_dereference(*sp); nsp;
			     sp = &nsp->next, nsp = rtnl_dereference(*sp)) {
				if (nsp == s) {
					RCU_INIT_POINTER(*sp, s->next);
					kfree_rcu(s, rcu);
					goto out;
				}
			}

			break;
		}
	}

out:
	*last = true;
	for (h1 = 0; h1 < 256; h1++) {
		if (rcu_access_pointer(head->ht[h1])) {
			*last = false;
			break;
		}
	}

	return 0;
}

static unsigned int gen_handle(struct tcf_proto *tp, unsigned salt)
{
	struct rsvp_head *data = rtnl_dereference(tp->root);
	int i = 0xFFFF;

	while (i-- > 0) {
		u32 h;

		if ((data->hgenerator += 0x10000) == 0)
			data->hgenerator = 0x10000;
		h = data->hgenerator|salt;
		if (!rsvp_get(tp, h))
			return h;
	}
	return 0;
}

static int tunnel_bts(struct rsvp_head *data)
{
	int n = data->tgenerator >> 5;
	u32 b = 1 << (data->tgenerator & 0x1F);

	if (data->tmap[n] & b)
		return 0;
	data->tmap[n] |= b;
	return 1;
}

static void tunnel_recycle(struct rsvp_head *data)
{
	struct rsvp_session __rcu **sht = data->ht;
	u32 tmap[256/32];
	int h1, h2;

	memset(tmap, 0, sizeof(tmap));

	for (h1 = 0; h1 < 256; h1++) {
		struct rsvp_session *s;
		for (s = rtnl_dereference(sht[h1]); s;
		     s = rtnl_dereference(s->next)) {
			for (h2 = 0; h2 <= 16; h2++) {
				struct rsvp_filter *f;

				for (f = rtnl_dereference(s->ht[h2]); f;
				     f = rtnl_dereference(f->next)) {
					if (f->tunnelhdr == 0)
						continue;
					data->tgenerator = f->res.classid;
					tunnel_bts(data);
				}
			}
		}
	}

	memcpy(data->tmap, tmap, sizeof(tmap));
}

static u32 gen_tunnel(struct rsvp_head *data)
{
	int i, k;

	for (k = 0; k < 2; k++) {
		for (i = 255; i > 0; i--) {
			if (++data->tgenerator == 0)
				data->tgenerator = 1;
			if (tunnel_bts(data))
				return data->tgenerator;
		}
		tunnel_recycle(data);
	}
	return 0;
}

static const struct nla_policy rsvp_policy[TCA_RSVP_MAX + 1] = {
	[TCA_RSVP_CLASSID]	= { .type = NLA_U32 },
	[TCA_RSVP_DST]		= { .len = RSVP_DST_LEN * sizeof(u32) },
	[TCA_RSVP_SRC]		= { .len = RSVP_DST_LEN * sizeof(u32) },
	[TCA_RSVP_PINFO]	= { .len = sizeof(struct tc_rsvp_pinfo) },
};

static int rsvp_change(struct net *net, struct sk_buff *in_skb,
		       struct tcf_proto *tp, unsigned long base,
		       u32 handle, struct nlattr **tca,
		       void **arg, u32 flags,
		       struct netlink_ext_ack *extack)
{
	struct rsvp_head *data = rtnl_dereference(tp->root);
	struct rsvp_filter *f, *nfp;
	struct rsvp_filter __rcu **fp;
	struct rsvp_session *nsp, *s;
	struct rsvp_session __rcu **sp;
	struct tc_rsvp_pinfo *pinfo = NULL;
	struct nlattr *opt = tca[TCA_OPTIONS];
	struct nlattr *tb[TCA_RSVP_MAX + 1];
	struct tcf_exts e;
	unsigned int h1, h2;
	__be32 *dst;
	int err;

	if (opt == NULL)
		return handle ? -EINVAL : 0;

	err = nla_parse_nested_deprecated(tb, TCA_RSVP_MAX, opt, rsvp_policy,
					  NULL);
	if (err < 0)
		return err;

	err = tcf_exts_init(&e, net, TCA_RSVP_ACT, TCA_RSVP_POLICE);
	if (err < 0)
		return err;
	err = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &e, flags,
				extack);
	if (err < 0)
		goto errout2;

	f = *arg;
	if (f) {
		/* Node exists: adjust only classid */
		struct rsvp_filter *n;

		if (f->handle != handle && handle)
			goto errout2;

		n = kmemdup(f, sizeof(*f), GFP_KERNEL);
		if (!n) {
			err = -ENOMEM;
			goto errout2;
		}

		err = tcf_exts_init(&n->exts, net, TCA_RSVP_ACT,
				    TCA_RSVP_POLICE);
		if (err < 0) {
			kfree(n);
			goto errout2;
		}

		if (tb[TCA_RSVP_CLASSID]) {
			n->res.classid = nla_get_u32(tb[TCA_RSVP_CLASSID]);
			tcf_bind_filter(tp, &n->res, base);
		}

		tcf_exts_change(&n->exts, &e);
		rsvp_replace(tp, n, handle);
		return 0;
	}

	/* Now more serious part... */
	err = -EINVAL;
	if (handle)
		goto errout2;
	if (tb[TCA_RSVP_DST] == NULL)
		goto errout2;

	err = -ENOBUFS;
	f = kzalloc(sizeof(struct rsvp_filter), GFP_KERNEL);
	if (f == NULL)
		goto errout2;

	err = tcf_exts_init(&f->exts, net, TCA_RSVP_ACT, TCA_RSVP_POLICE);
	if (err < 0)
		goto errout;
	h2 = 16;
	if (tb[TCA_RSVP_SRC]) {
		memcpy(f->src, nla_data(tb[TCA_RSVP_SRC]), sizeof(f->src));
		h2 = hash_src(f->src);
	}
	if (tb[TCA_RSVP_PINFO]) {
		pinfo = nla_data(tb[TCA_RSVP_PINFO]);
		f->spi = pinfo->spi;
		f->tunnelhdr = pinfo->tunnelhdr;
	}
	if (tb[TCA_RSVP_CLASSID])
		f->res.classid = nla_get_u32(tb[TCA_RSVP_CLASSID]);

	dst = nla_data(tb[TCA_RSVP_DST]);
	h1 = hash_dst(dst, pinfo ? pinfo->protocol : 0, pinfo ? pinfo->tunnelid : 0);

	err = -ENOMEM;
	if ((f->handle = gen_handle(tp, h1 | (h2<<8))) == 0)
		goto errout;

	if (f->tunnelhdr) {
		err = -EINVAL;
		if (f->res.classid > 255)
			goto errout;

		err = -ENOMEM;
		if (f->res.classid == 0 &&
		    (f->res.classid = gen_tunnel(data)) == 0)
			goto errout;
	}

	for (sp = &data->ht[h1];
	     (s = rtnl_dereference(*sp)) != NULL;
	     sp = &s->next) {
		if (dst[RSVP_DST_LEN-1] == s->dst[RSVP_DST_LEN-1] &&
		    pinfo && pinfo->protocol == s->protocol &&
		    memcmp(&pinfo->dpi, &s->dpi, sizeof(s->dpi)) == 0 &&
#if RSVP_DST_LEN == 4
		    dst[0] == s->dst[0] &&
		    dst[1] == s->dst[1] &&
		    dst[2] == s->dst[2] &&
#endif
		    pinfo->tunnelid == s->tunnelid) {

insert:
			/* OK, we found appropriate session */

			fp = &s->ht[h2];

			f->sess = s;
			if (f->tunnelhdr == 0)
				tcf_bind_filter(tp, &f->res, base);

			tcf_exts_change(&f->exts, &e);

			fp = &s->ht[h2];
			for (nfp = rtnl_dereference(*fp); nfp;
			     fp = &nfp->next, nfp = rtnl_dereference(*fp)) {
				__u32 mask = nfp->spi.mask & f->spi.mask;

				if (mask != f->spi.mask)
					break;
			}
			RCU_INIT_POINTER(f->next, nfp);
			rcu_assign_pointer(*fp, f);

			*arg = f;
			return 0;
		}
	}

	/* No session found. Create new one. */

	err = -ENOBUFS;
	s = kzalloc(sizeof(struct rsvp_session), GFP_KERNEL);
	if (s == NULL)
		goto errout;
	memcpy(s->dst, dst, sizeof(s->dst));

	if (pinfo) {
		s->dpi = pinfo->dpi;
		s->protocol = pinfo->protocol;
		s->tunnelid = pinfo->tunnelid;
	}
	sp = &data->ht[h1];
	for (nsp = rtnl_dereference(*sp); nsp;
	     sp = &nsp->next, nsp = rtnl_dereference(*sp)) {
		if ((nsp->dpi.mask & s->dpi.mask) != s->dpi.mask)
			break;
	}
	RCU_INIT_POINTER(s->next, nsp);
	rcu_assign_pointer(*sp, s);

	goto insert;

errout:
	tcf_exts_destroy(&f->exts);
	kfree(f);
errout2:
	tcf_exts_destroy(&e);
	return err;
}

static void rsvp_walk(struct tcf_proto *tp, struct tcf_walker *arg,
		      bool rtnl_held)
{
	struct rsvp_head *head = rtnl_dereference(tp->root);
	unsigned int h, h1;

	if (arg->stop)
		return;

	for (h = 0; h < 256; h++) {
		struct rsvp_session *s;

		for (s = rtnl_dereference(head->ht[h]); s;
		     s = rtnl_dereference(s->next)) {
			for (h1 = 0; h1 <= 16; h1++) {
				struct rsvp_filter *f;

				for (f = rtnl_dereference(s->ht[h1]); f;
				     f = rtnl_dereference(f->next)) {
					if (!tc_cls_stats_dump(tp, arg, f))
						return;
				}
			}
		}
	}
}

static int rsvp_dump(struct net *net, struct tcf_proto *tp, void *fh,
		     struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)
{
	struct rsvp_filter *f = fh;
	struct rsvp_session *s;
	struct nlattr *nest;
	struct tc_rsvp_pinfo pinfo;

	if (f == NULL)
		return skb->len;
	s = f->sess;

	t->tcm_handle = f->handle;

	nest = nla_nest_start_noflag(skb, TCA_OPTIONS);
	if (nest == NULL)
		goto nla_put_failure;

	if (nla_put(skb, TCA_RSVP_DST, sizeof(s->dst), &s->dst))
		goto nla_put_failure;
	pinfo.dpi = s->dpi;
	pinfo.spi = f->spi;
	pinfo.protocol = s->protocol;
	pinfo.tunnelid = s->tunnelid;
	pinfo.tunnelhdr = f->tunnelhdr;
	pinfo.pad = 0;
	if (nla_put(skb, TCA_RSVP_PINFO, sizeof(pinfo), &pinfo))
		goto nla_put_failure;
	if (f->res.classid &&
	    nla_put_u32(skb, TCA_RSVP_CLASSID, f->res.classid))
		goto nla_put_failure;
	if (((f->handle >> 8) & 0xFF) != 16 &&
	    nla_put(skb, TCA_RSVP_SRC, sizeof(f->src), f->src))
		goto nla_put_failure;

	if (tcf_exts_dump(skb, &f->exts) < 0)
		goto nla_put_failure;

	nla_nest_end(skb, nest);

	if (tcf_exts_dump_stats(skb, &f->exts) < 0)
		goto nla_put_failure;
	return skb->len;

nla_put_failure:
	nla_nest_cancel(skb, nest);
	return -1;
}

static void rsvp_bind_class(void *fh, u32 classid, unsigned long cl, void *q,
			    unsigned long base)
{
	struct rsvp_filter *f = fh;

	tc_cls_bind_class(classid, cl, q, &f->res, base);
}

static struct tcf_proto_ops RSVP_OPS __read_mostly = {
	.kind		=	RSVP_ID,
	.classify	=	RSVP_CLS,
	.init		=	rsvp_init,
	.destroy	=	rsvp_destroy,
	.get		=	rsvp_get,
	.change		=	rsvp_change,
	.delete		=	rsvp_delete,
	.walk		=	rsvp_walk,
	.dump		=	rsvp_dump,
	.bind_class	=	rsvp_bind_class,
	.owner		=	THIS_MODULE,
};

static int __init init_rsvp(void)
{
	return register_tcf_proto_ops(&RSVP_OPS);
}

static void __exit exit_rsvp(void)
{
	unregister_tcf_proto_ops(&RSVP_OPS);
}

module_init(init_rsvp)
module_exit(exit_rsvp)",265b4da82dbf5df04bee5a5d46b7474b1aaf326a,CVE-2023-42755,265b4da82dbf5df04bee5a5d46b7474b1aaf326a,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,"  /* * VAR/VAR/VAR.VAR VAR VAR VAR VAR[46] VAR. * * VAR: VAR VAR, <VAR@VAR.VAR.VAR.VAR> */ /* VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR: * (VAR, VAR) VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR (VAR VAR VAR) VAR VAR VAR VAR VAR VAR VAR. VAR. VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR ""VAR VAR"", VAR VAR VAR VAR, VAR VAR VAR(=""VAR VAR VAR""): VAR (VAR, VAR, VAR). VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR. VAR VAR) VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR ""VAR VAR"", VAR VAR VAR VAR VAR VAR(=""VAR VAR VAR"" VAR VAR VAR ""VAR VAR VAR""): VAR (VAR, VAR, VAR). VAR 1. VAR VAR VAR VAR VAR VAR VAR (VAR VAR VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR. VAR 2. VAR ""VAR VAR""'VAR VAR VAR VAR VAR, VAR VAR VAR VAR ""VAR VAR VAR"". VAR VAR VAR VAR VAR, VAR (VAR VAR,VAR) VAR *VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR 4 VAR VAR VAR. VAR 3. VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR ""VAR"" VAR VAR VAR, VAR VAR'VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR (1...255). VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR 8)8) VAR'VAR VAR VAR VAR VAR VAR. VAR 4. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR.VAR. VAR VAR VAR VAR (VAR VAR VAR VAR VAR VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR? 8)8) VAR, VAR VAR, VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR { VAR VAR[256/32]; VAR VAR; VAR VAR; VAR VAR VAR *VAR[256]; VAR VAR VAR; }; VAR VAR { VAR VAR VAR *VAR; VAR VAR[VAR]; VAR VAR VAR; VAR VAR; VAR VAR;  VAR VAR VAR *VAR[16 + 1]; VAR VAR VAR; }; VAR VAR { VAR VAR VAR *VAR; VAR VAR[VAR]; VAR VAR VAR; VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR; VAR VAR *VAR; VAR VAR VAR; }; VAR VAR VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR) { VAR VAR VAR = (VAR VAR)VAR[VAR - 1]; VAR ^= VAR>>16; VAR ^= VAR>>8; VAR (VAR ^ VAR ^ VAR) & 0xFF; } VAR VAR VAR VAR VAR(VAR *VAR) { VAR VAR VAR = (VAR VAR)VAR[VAR-1]; VAR ^= VAR>>16; VAR ^= VAR>>8; VAR ^= VAR>>4; VAR VAR & 0xF; }  { \ VAR VAR = VAR(VAR, &VAR->VAR, VAR); \ VAR (VAR < 0) \ VAR; \ VAR VAR (VAR > 0) \ VAR VAR; \ } VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR, VAR; VAR *VAR, *VAR; VAR VAR; VAR VAR = 0; VAR *VAR;  VAR VAR *VAR; VAR (!VAR(VAR, VAR(*VAR))) VAR -1; VAR = VAR(VAR);  VAR VAR *VAR; VAR (!VAR(VAR, VAR(*VAR))) VAR -1; VAR = VAR(VAR);  VAR:  VAR = &VAR->VAR.VAR[0]; VAR = &VAR->VAR.VAR[0]; VAR = VAR->VAR; VAR = ((VAR *)VAR) + VAR(VAR VAR);  VAR = &VAR->VAR; VAR = &VAR->VAR; VAR = VAR->VAR; VAR = ((VAR *)VAR) + (VAR->VAR<<2); VAR (VAR(VAR)) VAR -1;  VAR = VAR(VAR, VAR, VAR); VAR = VAR(VAR); VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR[VAR-1] == VAR->VAR[VAR - 1] && VAR == VAR->VAR && !(VAR->VAR.VAR & (*(VAR *)(VAR + VAR->VAR.VAR) ^ VAR->VAR.VAR)) &&  VAR[0] == VAR->VAR[0] && VAR[1] == VAR->VAR[1] && VAR[2] == VAR->VAR[2] &&  VAR == VAR->VAR) { VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR[VAR-1] == VAR->VAR[VAR - 1] && !(VAR->VAR.VAR & (*(VAR *)(VAR + VAR->VAR.VAR) ^ VAR->VAR.VAR))  && VAR[0] == VAR->VAR[0] && VAR[1] == VAR->VAR[1] && VAR[2] == VAR->VAR[2]  ) { *VAR = VAR->VAR; VAR(); VAR: VAR (VAR->VAR == 0) VAR 0; VAR = VAR->VAR.VAR; VAR = (VAR *)(VAR + VAR->VAR - VAR(*VAR)); VAR VAR; } }  VAR (VAR = VAR(VAR->VAR[16]); VAR; VAR = VAR(VAR->VAR)) { *VAR = VAR->VAR; VAR(); VAR VAR; } VAR -1; } } VAR -1; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR; VAR VAR VAR **VAR; VAR VAR *VAR; VAR VAR VAR = VAR & 0xFF; VAR VAR VAR = (VAR >> 8) & 0xFF; VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR = &VAR->VAR[VAR], VAR = VAR(*VAR); ; VAR = &VAR->VAR, VAR = VAR(*VAR)) { VAR (VAR->VAR == VAR) { VAR(VAR->VAR, VAR->VAR); VAR(*VAR, VAR); VAR; } } } /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR * VAR. VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR(1); } VAR VAR *VAR(VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR = VAR & 0xFF; VAR VAR VAR = (VAR >> 8) & 0xFF; VAR (VAR > 16) VAR VAR; VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR->VAR == VAR) VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR; VAR = VAR(VAR(VAR VAR), VAR); VAR (VAR) { VAR(VAR->VAR, VAR); VAR 0; } VAR -VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(VAR); } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR(VAR), VAR VAR, VAR); VAR(); VAR(VAR); VAR(); } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR(VAR, &VAR->VAR); /* VAR VAR VAR VAR VAR VAR VAR() VAR VAR * VAR VAR, VAR VAR-VAR-VAR VAR VAR VAR VAR VAR * VAR VAR() VAR */ VAR (VAR(&VAR->VAR)) VAR(&VAR->VAR, VAR); VAR VAR(VAR); } VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR, VAR; VAR (VAR == VAR) VAR; VAR (VAR = 0; VAR < 256; VAR++) { VAR VAR *VAR; VAR ((VAR = VAR(VAR->VAR[VAR])) != VAR) { VAR(VAR->VAR[VAR], VAR->VAR); VAR (VAR = 0; VAR <= 16; VAR++) { VAR VAR *VAR; VAR ((VAR = VAR(VAR->VAR[VAR])) != VAR) { VAR(VAR->VAR[VAR], VAR->VAR); VAR(VAR, VAR); } } VAR(VAR, VAR); } } VAR(VAR, VAR); } VAR VAR VAR(VAR VAR *VAR, VAR *VAR, VAR *VAR, VAR VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR, *VAR = VAR; VAR VAR VAR **VAR; VAR VAR VAR = VAR->VAR; VAR VAR VAR **VAR; VAR VAR *VAR, *VAR = VAR->VAR; VAR VAR, VAR; VAR = &VAR->VAR[(VAR >> 8) & 0xFF]; VAR (VAR = VAR(*VAR); VAR; VAR = &VAR->VAR, VAR = VAR(*VAR)) { VAR (VAR == VAR) { VAR(*VAR, VAR->VAR); VAR(VAR, VAR);  VAR (VAR = 0; VAR <= 16; VAR++) VAR (VAR->VAR[VAR]) VAR VAR;  VAR = &VAR->VAR[VAR & 0xFF]; VAR (VAR = VAR(*VAR); VAR; VAR = &VAR->VAR, VAR = VAR(*VAR)) { VAR (VAR == VAR) { VAR(*VAR, VAR->VAR); VAR(VAR, VAR); VAR VAR; } } VAR; } } VAR: *VAR = VAR; VAR (VAR = 0; VAR < 256; VAR++) { VAR (VAR(VAR->VAR[VAR])) { *VAR = VAR; VAR; } } VAR 0; } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR = 0xFFFF; VAR (VAR-- > 0) { VAR VAR; VAR ((VAR->VAR += 0x10000) == 0) VAR->VAR = 0x10000; VAR = VAR->VAR|VAR; VAR (!VAR(VAR, VAR)) VAR VAR; } VAR 0; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR = VAR->VAR >> 5; VAR VAR = 1 << (VAR->VAR & 0x1F); VAR (VAR->VAR[VAR] & VAR) VAR 0; VAR->VAR[VAR] |= VAR; VAR 1; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR VAR **VAR = VAR->VAR; VAR VAR[256/32]; VAR VAR, VAR; VAR(VAR, 0, VAR(VAR)); VAR (VAR = 0; VAR < 256; VAR++) { VAR VAR *VAR; VAR (VAR = VAR(VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR = 0; VAR <= 16; VAR++) { VAR VAR *VAR; VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR->VAR == 0) VAR; VAR->VAR = VAR->VAR.VAR; VAR(VAR); } } } } VAR(VAR->VAR, VAR, VAR(VAR)); } VAR VAR VAR(VAR VAR *VAR) { VAR VAR, VAR; VAR (VAR = 0; VAR < 2; VAR++) { VAR (VAR = 255; VAR > 0; VAR--) { VAR (++VAR->VAR == 0) VAR->VAR = 1; VAR (VAR(VAR)) VAR VAR->VAR; } VAR(VAR); } VAR 0; } VAR VAR VAR VAR VAR[VAR + 1] = { [VAR] = { .VAR = VAR }, [VAR] = { .VAR = VAR * VAR(VAR) }, [VAR] = { .VAR = VAR * VAR(VAR) }, [VAR] = { .VAR = VAR(VAR VAR) }, }; VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR VAR, VAR VAR, VAR VAR **VAR, VAR **VAR, VAR VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR, *VAR; VAR VAR VAR **VAR; VAR VAR *VAR, *VAR; VAR VAR VAR **VAR; VAR VAR *VAR = VAR; VAR VAR *VAR = VAR[VAR]; VAR VAR *VAR[VAR + 1]; VAR VAR VAR; VAR VAR VAR, VAR; VAR *VAR; VAR VAR; VAR (VAR == VAR) VAR VAR ? -VAR : 0; VAR = VAR(VAR, VAR, VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(&VAR, VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR, VAR, VAR, VAR[VAR], &VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = *VAR; VAR (VAR) {  VAR VAR *VAR; VAR (VAR->VAR != VAR && VAR) VAR VAR; VAR = VAR(VAR, VAR(*VAR), VAR); VAR (!VAR) { VAR = -VAR; VAR VAR; } VAR = VAR(&VAR->VAR, VAR, VAR, VAR); VAR (VAR < 0) { VAR(VAR); VAR VAR; } VAR (VAR[VAR]) { VAR->VAR.VAR = VAR(VAR[VAR]); VAR(VAR, &VAR->VAR, VAR); } VAR(&VAR->VAR, &VAR); VAR(VAR, VAR, VAR); VAR 0; }  VAR = -VAR; VAR (VAR) VAR VAR; VAR (VAR[VAR] == VAR) VAR VAR; VAR = -VAR; VAR = VAR(VAR(VAR VAR), VAR); VAR (VAR == VAR) VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = 16; VAR (VAR[VAR]) { VAR(VAR->VAR, VAR(VAR[VAR]), VAR(VAR->VAR)); VAR = VAR(VAR->VAR); } VAR (VAR[VAR]) { VAR = VAR(VAR[VAR]); VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; } VAR (VAR[VAR]) VAR->VAR.VAR = VAR(VAR[VAR]); VAR = VAR(VAR[VAR]); VAR = VAR(VAR, VAR ? VAR->VAR : 0, VAR ? VAR->VAR : 0); VAR = -VAR; VAR ((VAR->VAR = VAR(VAR, VAR | (VAR<<8))) == 0) VAR VAR; VAR (VAR->VAR) { VAR = -VAR; VAR (VAR->VAR.VAR > 255) VAR VAR; VAR = -VAR; VAR (VAR->VAR.VAR == 0 && (VAR->VAR.VAR = VAR(VAR)) == 0) VAR VAR; } VAR (VAR = &VAR->VAR[VAR]; (VAR = VAR(*VAR)) != VAR; VAR = &VAR->VAR) { VAR (VAR[VAR-1] == VAR->VAR[VAR-1] && VAR && VAR->VAR == VAR->VAR && VAR(&VAR->VAR, &VAR->VAR, VAR(VAR->VAR)) == 0 &&  VAR[0] == VAR->VAR[0] && VAR[1] == VAR->VAR[1] && VAR[2] == VAR->VAR[2] &&  VAR->VAR == VAR->VAR) { VAR:  VAR = &VAR->VAR[VAR]; VAR->VAR = VAR; VAR (VAR->VAR == 0) VAR(VAR, &VAR->VAR, VAR); VAR(&VAR->VAR, &VAR); VAR = &VAR->VAR[VAR]; VAR (VAR = VAR(*VAR); VAR; VAR = &VAR->VAR, VAR = VAR(*VAR)) { VAR VAR = VAR->VAR.VAR & VAR->VAR.VAR; VAR (VAR != VAR->VAR.VAR) VAR; } VAR(VAR->VAR, VAR); VAR(*VAR, VAR); *VAR = VAR; VAR 0; } }  VAR = -VAR; VAR = VAR(VAR(VAR VAR), VAR); VAR (VAR == VAR) VAR VAR; VAR(VAR->VAR, VAR, VAR(VAR->VAR)); VAR (VAR) { VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; } VAR = &VAR->VAR[VAR]; VAR (VAR = VAR(*VAR); VAR; VAR = &VAR->VAR, VAR = VAR(*VAR)) { VAR ((VAR->VAR.VAR & VAR->VAR.VAR) != VAR->VAR.VAR) VAR; } VAR(VAR->VAR, VAR); VAR(*VAR, VAR); VAR VAR; VAR: VAR(&VAR->VAR); VAR(VAR); VAR: VAR(&VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR VAR, VAR; VAR (VAR->VAR) VAR; VAR (VAR = 0; VAR < 256; VAR++) { VAR VAR *VAR; VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR = 0; VAR <= 16; VAR++) { VAR VAR *VAR; VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (!VAR(VAR, VAR, VAR)) VAR; } } } } } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR; VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR; VAR (VAR == VAR) VAR VAR->VAR; VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR = VAR(VAR, VAR); VAR (VAR == VAR) VAR VAR; VAR (VAR(VAR, VAR, VAR(VAR->VAR), &VAR->VAR)) VAR VAR; VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR; VAR.VAR = 0; VAR (VAR(VAR, VAR, VAR(VAR), &VAR)) VAR VAR; VAR (VAR->VAR.VAR && VAR(VAR, VAR, VAR->VAR.VAR)) VAR VAR; VAR (((VAR->VAR >> 8) & 0xFF) != 16 && VAR(VAR, VAR, VAR(VAR->VAR), VAR->VAR)) VAR VAR; VAR (VAR(VAR, &VAR->VAR) < 0) VAR VAR; VAR(VAR, VAR); VAR (VAR(VAR, &VAR->VAR) < 0) VAR VAR; VAR VAR->VAR; VAR: VAR(VAR, VAR); VAR -1; } VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR VAR, VAR *VAR, VAR VAR VAR) { VAR VAR *VAR = VAR; VAR(VAR, VAR, VAR, &VAR->VAR, VAR); } VAR VAR VAR VAR VAR = { .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, }; VAR VAR VAR VAR(VAR) { VAR VAR(&VAR); } VAR VAR VAR VAR(VAR) { VAR(&VAR); } VAR(VAR) VAR(VAR)",1
linux_3b30460c5b0ed762be75a004e924ec3f8711e032,crypto/ccm.c,"	u8 idata[16];
	u8 *odata = pctx->odata;
	u8 *idata = pctx->idata;","	u8 odata[16];
	u8 idata[16];",3b30460c5b0ed762be75a004e924ec3f8711e032,CVE-2017-8065,3b30460c5b0ed762be75a004e924ec3f8711e032,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR VAR[16]; VAR *VAR = VAR->VAR; VAR *VAR = VAR->VAR; VAR VAR[16]; VAR VAR[16];,1
linux_41bdc78544b8a93a9c6814b8bbbfef966272abbe,arch/x86/kernel/tls.c,"static bool tls_desc_okay(const struct user_desc *info)
{
	if (LDT_empty(info))
		return true;

	/*
	 * espfix is required for 16-bit data segments, but espfix
	 * only works for LDT segments.
	 */
	if (!info->seg_32bit)
		return false;

	return true;
}

	if (!tls_desc_okay(&info))
		return -EINVAL;

	int i;
	for (i = 0; i < count / sizeof(struct user_desc); i++)
		if (!tls_desc_okay(info + i))
			return -EINVAL;
",,41bdc78544b8a93a9c6814b8bbbfef966272abbe,CVE-2014-8133,41bdc78544b8a93a9c6814b8bbbfef966272abbe,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR VAR VAR *VAR) { VAR (VAR(VAR)) VAR VAR; /* * VAR VAR VAR VAR 16-VAR VAR VAR, VAR VAR * VAR VAR VAR VAR VAR. */ VAR (!VAR->VAR) VAR VAR; VAR VAR; } VAR (!VAR(&VAR)) VAR -VAR; VAR VAR; VAR (VAR = 0; VAR < VAR / VAR(VAR VAR); VAR++) VAR (!VAR(VAR + VAR)) VAR -VAR; ",1
linux_4b842e4e25b12951fa10dedb4bc16bc47e3b850c,arch/x86/include/asm/uaccess_64.h,"	return copy_user_generic(dst, (__force void *)src, size);
	return copy_user_generic((__force void *)dst, src, size);","	int ret = 0;

	if (!__builtin_constant_p(size))
		return copy_user_generic(dst, (__force void *)src, size);
	switch (size) {
	case 1:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u8 *)dst, (u8 __user *)src,
			      ret, ""b"", ""b"", ""=q"", 1);
		__uaccess_end();
		return ret;
	case 2:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u16 *)dst, (u16 __user *)src,
			      ret, ""w"", ""w"", ""=r"", 2);
		__uaccess_end();
		return ret;
	case 4:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u32 *)dst, (u32 __user *)src,
			      ret, ""l"", ""k"", ""=r"", 4);
		__uaccess_end();
		return ret;
	case 8:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,
			      ret, ""q"", """", ""=r"", 8);
		__uaccess_end();
		return ret;
	case 10:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,
			       ret, ""q"", """", ""=r"", 10);
		if (likely(!ret))
			__get_user_asm_nozero(*(u16 *)(8 + (char *)dst),
				       (u16 __user *)(8 + (char __user *)src),
				       ret, ""w"", ""w"", ""=r"", 2);
		__uaccess_end();
		return ret;
	case 16:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,
			       ret, ""q"", """", ""=r"", 16);
		if (likely(!ret))
			__get_user_asm_nozero(*(u64 *)(8 + (char *)dst),
				       (u64 __user *)(8 + (char __user *)src),
				       ret, ""q"", """", ""=r"", 8);
		__uaccess_end();
		return ret;
	default:
		return copy_user_generic(dst, (__force void *)src, size);
	}
	int ret = 0;

	if (!__builtin_constant_p(size))
		return copy_user_generic((__force void *)dst, src, size);
	switch (size) {
	case 1:
		__uaccess_begin();
		__put_user_asm(*(u8 *)src, (u8 __user *)dst,
			      ret, ""b"", ""b"", ""iq"", 1);
		__uaccess_end();
		return ret;
	case 2:
		__uaccess_begin();
		__put_user_asm(*(u16 *)src, (u16 __user *)dst,
			      ret, ""w"", ""w"", ""ir"", 2);
		__uaccess_end();
		return ret;
	case 4:
		__uaccess_begin();
		__put_user_asm(*(u32 *)src, (u32 __user *)dst,
			      ret, ""l"", ""k"", ""ir"", 4);
		__uaccess_end();
		return ret;
	case 8:
		__uaccess_begin();
		__put_user_asm(*(u64 *)src, (u64 __user *)dst,
			      ret, ""q"", """", ""er"", 8);
		__uaccess_end();
		return ret;
	case 10:
		__uaccess_begin();
		__put_user_asm(*(u64 *)src, (u64 __user *)dst,
			       ret, ""q"", """", ""er"", 10);
		if (likely(!ret)) {
			asm("""":::""memory"");
			__put_user_asm(4[(u16 *)src], 4 + (u16 __user *)dst,
				       ret, ""w"", ""w"", ""ir"", 2);
		}
		__uaccess_end();
		return ret;
	case 16:
		__uaccess_begin();
		__put_user_asm(*(u64 *)src, (u64 __user *)dst,
			       ret, ""q"", """", ""er"", 16);
		if (likely(!ret)) {
			asm("""":::""memory"");
			__put_user_asm(1[(u64 *)src], 1 + (u64 __user *)dst,
				       ret, ""q"", """", ""er"", 8);
		}
		__uaccess_end();
		return ret;
	default:
		return copy_user_generic((__force void *)dst, src, size);
	}",4b842e4e25b12951fa10dedb4bc16bc47e3b850c,CVE-2023-0459,4b842e4e25b12951fa10dedb4bc16bc47e3b850c,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR(VAR, (VAR VAR *)VAR, VAR); VAR VAR((VAR VAR *)VAR, VAR, VAR); VAR VAR = 0; VAR (!VAR(VAR)) VAR VAR(VAR, (VAR VAR *)VAR, VAR); VAR (VAR) { VAR 1: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""=VAR"", 1); VAR(); VAR VAR; VAR 2: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""=VAR"", 2); VAR(); VAR VAR; VAR 4: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""=VAR"", 4); VAR(); VAR VAR; VAR 8: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""=VAR"", 8); VAR(); VAR VAR; VAR 10: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""=VAR"", 10); VAR (VAR(!VAR)) VAR(*(VAR *)(8 + (VAR *)VAR), (VAR VAR *)(8 + (VAR VAR *)VAR), VAR, ""VAR"", ""VAR"", ""=VAR"", 2); VAR(); VAR VAR; VAR 16: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""=VAR"", 16); VAR (VAR(!VAR)) VAR(*(VAR *)(8 + (VAR *)VAR), (VAR VAR *)(8 + (VAR VAR *)VAR), VAR, ""VAR"", """", ""=VAR"", 8); VAR(); VAR VAR; VAR: VAR VAR(VAR, (VAR VAR *)VAR, VAR); } VAR VAR = 0; VAR (!VAR(VAR)) VAR VAR((VAR VAR *)VAR, VAR, VAR); VAR (VAR) { VAR 1: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""VAR"", 1); VAR(); VAR VAR; VAR 2: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""VAR"", 2); VAR(); VAR VAR; VAR 4: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""VAR"", 4); VAR(); VAR VAR; VAR 8: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""VAR"", 8); VAR(); VAR VAR; VAR 10: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""VAR"", 10); VAR (VAR(!VAR)) { VAR("""":::""VAR""); VAR(4[(VAR *)VAR], 4 + (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""VAR"", 2); } VAR(); VAR VAR; VAR 16: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""VAR"", 16); VAR (VAR(!VAR)) { VAR("""":::""VAR""); VAR(1[(VAR *)VAR], 1 + (VAR VAR *)VAR, VAR, ""VAR"", """", ""VAR"", 8); } VAR(); VAR VAR; VAR: VAR VAR((VAR VAR *)VAR, VAR, VAR); }",1
linux_4dcc29e1574d88f4465ba865ed82800032f76418,arch/ia64/kernel/patch.c,"/*
 * Disable the RSE workaround by turning the conditional branch
 * that we tagged in each place the workaround was used into an
 * unconditional branch.
 */
void __init
ia64_patch_rse (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip, *b;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		b = (u64 *)(ip & -16);
		b[1] &= ~0xf800000L;
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}
",,4dcc29e1574d88f4465ba865ed82800032f76418,CVE-2006-3635,4dcc29e1574d88f4465ba865ed82800032f76418,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"/* * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. */ VAR VAR VAR (VAR VAR VAR, VAR VAR VAR) { VAR *VAR = (VAR *) VAR; VAR VAR, *VAR; VAR (VAR < (VAR *) VAR) { VAR = (VAR) VAR + *VAR; VAR = (VAR *)(VAR & -16); VAR[1] &= ~0xf800000L; VAR((VAR *) VAR); ++VAR; } VAR(); VAR(); } ",1
linux_5146f95df782b0ac61abde36567e718692725c89,drivers/net/ushso.c,"	/* check if we have a valid interface */
	if (if_num > 16) {
		kfree(config_data);
		return -EINVAL;
	}

	if (id->driver_info) {
		/* if_num is controlled by the device, driver_info is a 0 terminated
		 * array. Make sure, the access is in bounds! */
		for (i = 0; i <= if_num; ++i)
			if (((u32 *)(id->driver_info))[i] == 0)
				goto exit;
	} else {
		if (port_spec < 0)
			goto exit;
	}","	if (id->driver_info)
	else",5146f95df782b0ac61abde36567e718692725c89,CVE-2019-9857,5146f95df782b0ac61abde36567e718692725c89,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,68,COMPLETED," VAR (VAR > 16) { VAR(VAR); VAR -VAR; } VAR (VAR->VAR) { /* VAR VAR VAR VAR VAR VAR, VAR VAR VAR 0 VAR * VAR. VAR VAR, VAR VAR VAR VAR VAR! */ VAR (VAR = 0; VAR <= VAR; ++VAR) VAR (((VAR *)(VAR->VAR))[VAR] == 0) VAR VAR; } VAR { VAR (VAR < 0) VAR VAR; } VAR (VAR->VAR) VAR",1
linux_5146f95df782b0ac61abde36567e718692725c89,drivers/net/ushso.c,"	/* check if we have a valid interface */
	if (if_num > 16) {
		kfree(config_data);
		return -EINVAL;
	}

	if (id->driver_info) {
		/* if_num is controlled by the device, driver_info is a 0 terminated
		 * array. Make sure, the access is in bounds! */
		for (i = 0; i <= if_num; ++i)
			if (((u32 *)(id->driver_info))[i] == 0)
				goto exit;
	} else {
		if (port_spec < 0)
			goto exit;
	}","	if (id->driver_info)
	else",5146f95df782b0ac61abde36567e718692725c89,CVE-2018-20669,5146f95df782b0ac61abde36567e718692725c89,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,72,COMPLETED," VAR (VAR > 16) { VAR(VAR); VAR -VAR; } VAR (VAR->VAR) { /* VAR VAR VAR VAR VAR VAR, VAR VAR VAR 0 VAR * VAR. VAR VAR, VAR VAR VAR VAR VAR! */ VAR (VAR = 0; VAR <= VAR; ++VAR) VAR (((VAR *)(VAR->VAR))[VAR] == 0) VAR VAR; } VAR { VAR (VAR < 0) VAR VAR; } VAR (VAR->VAR) VAR",1
linux_5146f95df782b0ac61abde36567e718692725c89,drivers/net/ushso.c,"	/* check if we have a valid interface */
	if (if_num > 16) {
		kfree(config_data);
		return -EINVAL;
	}

	if (id->driver_info) {
		/* if_num is controlled by the device, driver_info is a 0 terminated
		 * array. Make sure, the access is in bounds! */
		for (i = 0; i <= if_num; ++i)
			if (((u32 *)(id->driver_info))[i] == 0)
				goto exit;
	} else {
		if (port_spec < 0)
			goto exit;
	}","	if (id->driver_info)
	else",5146f95df782b0ac61abde36567e718692725c89,CVE-2018-19985,5146f95df782b0ac61abde36567e718692725c89,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,152,COMPLETED," VAR (VAR > 16) { VAR(VAR); VAR -VAR; } VAR (VAR->VAR) { /* VAR VAR VAR VAR VAR VAR, VAR VAR VAR 0 VAR * VAR. VAR VAR, VAR VAR VAR VAR VAR! */ VAR (VAR = 0; VAR <= VAR; ++VAR) VAR (((VAR *)(VAR->VAR))[VAR] == 0) VAR VAR; } VAR { VAR (VAR < 0) VAR VAR; } VAR (VAR->VAR) VAR",1
linux_57e734423adda83f3b05505875343284efe3b39c,livsprintf.c,"int kptr_restrict __read_mostly;

static noinline_for_stack
char *restricted_pointer(char *buf, char *end, const void *ptr,
			 struct printf_spec spec)
{
	spec.base = 16;
	spec.flags |= SMALL;
	if (spec.field_width == -1) {
		spec.field_width = 2 * sizeof(ptr);
		spec.flags |= ZEROPAD;
	}

	switch (kptr_restrict) {
	case 0:
		/* Always print %pK values */
		break;
	case 1: {
		const struct cred *cred;

		/*
		 * kptr_restrict==1 cannot be used in IRQ context
		 * because its test for CAP_SYSLOG would be meaningless.
		 */
		if (in_irq() || in_serving_softirq() || in_nmi())
			return string(buf, end, ""pK-error"", spec);

		/*
		 * Only print the real pointer value if the current
		 * process has CAP_SYSLOG and is running with the
		 * same credentials it started with. This is because
		 * access to files is checked at open() time, but %pK
		 * checks permission at read() time. We don't want to
		 * leak pointer values if a binary opens a file using
		 * %pK and then elevates privileges before reading it.
		 */
		cred = current_cred();
		if (!has_capability_noaudit(current, CAP_SYSLOG) ||
		    !uid_eq(cred->euid, cred->uid) ||
		    !gid_eq(cred->egid, cred->gid))
			ptr = NULL;
		break;
	}
	case 2:
	default:
		/* Always print 0's for %pK */
		ptr = NULL;
		break;
	}

	return number(buf, end, (unsigned long)ptr, spec);
}

		return restricted_pointer(buf, end, ptr, spec);","int kptr_restrict __read_mostly;

		switch (kptr_restrict) {
		case 0:
			/* Always print %pK values */
			break;
		case 1: {
			const struct cred *cred;

			/*
			 * kptr_restrict==1 cannot be used in IRQ context
			 * because its test for CAP_SYSLOG would be meaningless.
			 */
			if (in_irq() || in_serving_softirq() || in_nmi()) {
				if (spec.field_width == -1)
					spec.field_width = default_width;
				return string(buf, end, ""pK-error"", spec);
			}

			/*
			 * Only print the real pointer value if the current
			 * process has CAP_SYSLOG and is running with the
			 * same credentials it started with. This is because
			 * access to files is checked at open() time, but %pK
			 * checks permission at read() time. We don't want to
			 * leak pointer values if a binary opens a file using
			 * %pK and then elevates privileges before reading it.
			 */
			cred = current_cred();
			if (!has_capability_noaudit(current, CAP_SYSLOG) ||
			    !uid_eq(cred->euid, cred->uid) ||
			    !gid_eq(cred->egid, cred->gid))
				ptr = NULL;
			break;
		}
		case 2:
		default:
			/* Always print 0's for %pK */
			ptr = NULL;
			break;
		}
		break;
",57e734423adda83f3b05505875343284efe3b39c,CVE-2018-7754,57e734423adda83f3b05505875343284efe3b39c,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,68,COMPLETED,"VAR VAR VAR; VAR VAR VAR *VAR(VAR *VAR, VAR *VAR, VAR VAR *VAR, VAR VAR VAR) { VAR.VAR = 16; VAR.VAR |= VAR; VAR (VAR.VAR == -1) { VAR.VAR = 2 * VAR(VAR); VAR.VAR |= VAR; } VAR (VAR) { VAR 0:  VAR; VAR 1: { VAR VAR VAR *VAR; /* * VAR==1 VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR (VAR() || VAR() || VAR()) VAR VAR(VAR, VAR, ""VAR-VAR"", VAR); /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR() VAR, VAR %VAR * VAR VAR VAR VAR() VAR. VAR VAR'VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * %VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR = VAR(); VAR (!VAR(VAR, VAR) || !VAR(VAR->VAR, VAR->VAR) || !VAR(VAR->VAR, VAR->VAR)) VAR = VAR; VAR; } VAR 2: VAR:  VAR = VAR; VAR; } VAR VAR(VAR, VAR, (VAR VAR)VAR, VAR); } VAR VAR(VAR, VAR, VAR, VAR); VAR VAR VAR; VAR (VAR) { VAR 0:  VAR; VAR 1: { VAR VAR VAR *VAR; /* * VAR==1 VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR (VAR() || VAR() || VAR()) { VAR (VAR.VAR == -1) VAR.VAR = VAR; VAR VAR(VAR, VAR, ""VAR-VAR"", VAR); } /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR() VAR, VAR %VAR * VAR VAR VAR VAR() VAR. VAR VAR'VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * %VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR = VAR(); VAR (!VAR(VAR, VAR) || !VAR(VAR->VAR, VAR->VAR) || !VAR(VAR->VAR, VAR->VAR)) VAR = VAR; VAR; } VAR 2: VAR:  VAR = VAR; VAR; } VAR;",1
linux_59140797c5817363087b0ffb46e6bb81a11fe0dc,fs/cifs/sess.c,"static void
decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifsSesInfo *ses,
		      const struct nls_table *nls_cp)
	int len;
	ses->serverOS = cifs_strndup(data, bleft, true, nls_cp);
	cFYI(1, (""serverOS=%s"", ses->serverOS));
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	ses->serverNOS = cifs_strndup(data, bleft, true, nls_cp);
	cFYI(1, (""serverNOS=%s"", ses->serverNOS));
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	ses->serverDomain = cifs_strndup(data, bleft, true, nls_cp);
	cFYI(1, (""serverDomain=%s"", ses->serverDomain));
	return;
		decode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses, nls_cp);","static int decode_unicode_ssetup(char **pbcc_area, int bleft,
				 struct cifsSesInfo *ses,
				 const struct nls_table *nls_cp)
	int rc = 0;
	int words_left, len;
	words_left = bleft / 2;

	/* save off server operating system */
	len = UniStrnlen((wchar_t *) data, words_left);

	if (len >= words_left)
		return rc;

	/* UTF-8 string will not grow more than four times as big as UCS-16 */
	ses->serverOS = kzalloc((4 * len) + 2 /* trailing null */, GFP_KERNEL);
	if (ses->serverOS != NULL) {
		cifs_strfromUCS_le(ses->serverOS, (__le16 *)data, len, nls_cp);
		cFYI(1, (""serverOS=%s"", ses->serverOS));
	}
	data += 2 * (len + 1);
	words_left -= len + 1;

	/* save off server network operating system */
	len = UniStrnlen((wchar_t *) data, words_left);

	if (len >= words_left)
		return rc;
	ses->serverNOS = kzalloc((4 * len) + 2 /* trailing null */, GFP_KERNEL);
	if (ses->serverNOS != NULL) {
		cifs_strfromUCS_le(ses->serverNOS, (__le16 *)data, len,
				   nls_cp);
		cFYI(1, (""serverNOS=%s"", ses->serverNOS));
		if (strncmp(ses->serverNOS, ""NT LAN Manager 4"", 16) == 0) {
			cFYI(1, (""NT4 server""));
			ses->flags |= CIFS_SES_NT4;
		}
	}
	data += 2 * (len + 1);
	words_left -= len + 1;

	/* save off server domain */
	len = UniStrnlen((wchar_t *) data, words_left);

	if (len > words_left)
		return rc;
	ses->serverDomain = kzalloc((4 * len) + 2, GFP_KERNEL);
	if (ses->serverDomain != NULL) {
		cifs_strfromUCS_le(ses->serverDomain, (__le16 *)data, len,
				   nls_cp);
		cFYI(1, (""serverDomain=%s"", ses->serverDomain));
	}
	data += 2 * (len + 1);
	words_left -= len + 1;
	cFYI(1, (""words left: %d"", words_left));

	return rc;
		rc = decode_unicode_ssetup(&bcc_ptr, bytes_remaining,
					   ses, nls_cp);",59140797c5817363087b0ffb46e6bb81a11fe0dc,CVE-2009-1633,59140797c5817363087b0ffb46e6bb81a11fe0dc,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,84,COMPLETED,"VAR VAR VAR(VAR **VAR, VAR VAR, VAR VAR *VAR, VAR VAR VAR *VAR) VAR VAR; VAR->VAR = VAR(VAR, VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); VAR = (VAR((VAR *) VAR, VAR / 2) * 2) + 2; VAR += VAR; VAR -= VAR; VAR (VAR <= 0) VAR; VAR->VAR = VAR(VAR, VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); VAR = (VAR((VAR *) VAR, VAR / 2) * 2) + 2; VAR += VAR; VAR -= VAR; VAR (VAR <= 0) VAR; VAR->VAR = VAR(VAR, VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); VAR; VAR(&VAR, VAR, VAR, VAR); VAR VAR VAR(VAR **VAR, VAR VAR, VAR VAR *VAR, VAR VAR VAR *VAR) VAR VAR = 0; VAR VAR, VAR; VAR = VAR / 2;  VAR = VAR((VAR *) VAR, VAR); VAR (VAR >= VAR) VAR VAR;  VAR->VAR = VAR((4 * VAR) + 2 , VAR); VAR (VAR->VAR != VAR) { VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); } VAR += 2 * (VAR + 1); VAR -= VAR + 1;  VAR = VAR((VAR *) VAR, VAR); VAR (VAR >= VAR) VAR VAR; VAR->VAR = VAR((4 * VAR) + 2 , VAR); VAR (VAR->VAR != VAR) { VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); VAR (VAR(VAR->VAR, ""VAR VAR VAR 4"", 16) == 0) { VAR(1, (""VAR VAR"")); VAR->VAR |= VAR; } } VAR += 2 * (VAR + 1); VAR -= VAR + 1;  VAR = VAR((VAR *) VAR, VAR); VAR (VAR > VAR) VAR VAR; VAR->VAR = VAR((4 * VAR) + 2, VAR); VAR (VAR->VAR != VAR) { VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); } VAR += 2 * (VAR + 1); VAR -= VAR + 1; VAR(1, (""VAR VAR: %VAR"", VAR)); VAR VAR; VAR = VAR(&VAR, VAR, VAR, VAR);",1
linux_6513a81e9325d712f1bfb9a1d7b750134e49ff18,fs/cifs/cifssmb.c,"
		/*
		 * Mask off high 16 bits when bytes written as returned by the
		 * server is greater than bytes requested by the client. Some
		 * OS/2 servers are known to set incorrect CountHigh values.
		 */
		if (*nbytes > count)
			*nbytes &= 0xFFFF;

		/*
		 * Mask off high 16 bits when bytes written as returned by the
		 * server is greater than bytes requested by the client. OS/2
		 * servers are known to set incorrect CountHigh values.
		 */
		if (*nbytes > count)
			*nbytes &= 0xFFFF;",,6513a81e9325d712f1bfb9a1d7b750134e49ff18,CVE-2010-2248,6513a81e9325d712f1bfb9a1d7b750134e49ff18,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,90,COMPLETED,/* * VAR VAR VAR 16 VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR * VAR/2 VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR (*VAR > VAR) *VAR &= 0xFFFF; /* * VAR VAR VAR 16 VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR/2 * VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR (*VAR > VAR) *VAR &= 0xFFFF; ,1
linux_6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,net/core/secure_seq.c,"#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/cryptohash.h>
#include <linux/module.h>
#include <linux/cache.h>
#include <linux/random.h>
#include <linux/hrtimer.h>
#include <linux/ktime.h>
#include <linux/string.h>

#include <net/secure_seq.h>

static u32 net_secret[MD5_MESSAGE_BYTES / 4] ____cacheline_aligned;

static int __init net_secret_init(void)
{
	get_random_bytes(net_secret, sizeof(net_secret));
	return 0;
}
late_initcall(net_secret_init);

static u32 seq_scale(u32 seq)
{
	/*
	 *	As close as possible to RFC 793, which
	 *	suggests using a 250 kHz clock.
	 *	Further reading shows this assumes 2 Mb/s networks.
	 *	For 10 Mb/s Ethernet, a 1 MHz clock is appropriate.
	 *	For 10 Gb/s Ethernet, a 1 GHz clock should be ok, but
	 *	we also need to limit the resolution so that the u32 seq
	 *	overlaps less than one time per MSL (2 minutes).
	 *	Choosing a clock of 64 ns period is OK. (period of 274 s)
	 */
	return seq + (ktime_to_ns(ktime_get_real()) >> 6);
}

#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
__u32 secure_tcpv6_sequence_number(__be32 *saddr, __be32 *daddr,
				   __be16 sport, __be16 dport)
{
	u32 secret[MD5_MESSAGE_BYTES / 4];
	u32 hash[MD5_DIGEST_WORDS];
	u32 i;

	memcpy(hash, saddr, 16);
	for (i = 0; i < 4; i++)
		secret[i] = net_secret[i] + daddr[i];
	secret[4] = net_secret[4] +
		(((__force u16)sport << 16) + (__force u16)dport);
	for (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)
		secret[i] = net_secret[i];

	md5_transform(hash, secret);

	return seq_scale(hash[0]);
}
EXPORT_SYMBOL(secure_tcpv6_sequence_number);

u32 secure_ipv6_port_ephemeral(const __be32 *saddr, const __be32 *daddr,
			       __be16 dport)
{
	u32 secret[MD5_MESSAGE_BYTES / 4];
	u32 hash[MD5_DIGEST_WORDS];
	u32 i;

	memcpy(hash, saddr, 16);
	for (i = 0; i < 4; i++)
		secret[i] = net_secret[i] + (__force u32) daddr[i];
	secret[4] = net_secret[4] + (__force u32)dport;
	for (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)
		secret[i] = net_secret[i];

	md5_transform(hash, secret);

	return hash[0];
}
#endif

#ifdef CONFIG_INET
__u32 secure_ip_id(__be32 daddr)
{
	u32 hash[MD5_DIGEST_WORDS];

	hash[0] = (__force __u32) daddr;
	hash[1] = net_secret[13];
	hash[2] = net_secret[14];
	hash[3] = net_secret[15];

	md5_transform(hash, net_secret);

	return hash[0];
}

__u32 secure_ipv6_id(const __be32 daddr[4])
{
	__u32 hash[4];

	memcpy(hash, daddr, 16);
	md5_transform(hash, net_secret);

	return hash[0];
}

__u32 secure_tcp_sequence_number(__be32 saddr, __be32 daddr,
				 __be16 sport, __be16 dport)
{
	u32 hash[MD5_DIGEST_WORDS];

	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = net_secret[15];

	md5_transform(hash, net_secret);

	return seq_scale(hash[0]);
}

u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	u32 hash[MD5_DIGEST_WORDS];

	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ net_secret[14];
	hash[3] = net_secret[15];

	md5_transform(hash, net_secret);

	return hash[0];
}
EXPORT_SYMBOL_GPL(secure_ipv4_port_ephemeral);
#endif

#if defined(CONFIG_IP_DCCP) || defined(CONFIG_IP_DCCP_MODULE)
u64 secure_dccp_sequence_number(__be32 saddr, __be32 daddr,
				__be16 sport, __be16 dport)
{
	u32 hash[MD5_DIGEST_WORDS];
	u64 seq;

	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = ((__force u16)sport << 16) + (__force u16)dport;
	hash[3] = net_secret[15];

	md5_transform(hash, net_secret);

	seq = hash[0] | (((u64)hash[1]) << 32);
	seq += ktime_to_ns(ktime_get_real());
	seq &= (1ull << 48) - 1;

	return seq;
}
EXPORT_SYMBOL(secure_dccp_sequence_number);

#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
u64 secure_dccpv6_sequence_number(__be32 *saddr, __be32 *daddr,
				  __be16 sport, __be16 dport)
{
	u32 secret[MD5_MESSAGE_BYTES / 4];
	u32 hash[MD5_DIGEST_WORDS];
	u64 seq;
	u32 i;

	memcpy(hash, saddr, 16);
	for (i = 0; i < 4; i++)
		secret[i] = net_secret[i] + daddr[i];
	secret[4] = net_secret[4] +
		(((__force u16)sport << 16) + (__force u16)dport);
	for (i = 5; i < MD5_MESSAGE_BYTES / 4; i++)
		secret[i] = net_secret[i];

	md5_transform(hash, secret);

	seq = hash[0] | (((u64)hash[1]) << 32);
	seq += ktime_to_ns(ktime_get_real());
	seq &= (1ull << 48) - 1;

	return seq;
}
EXPORT_SYMBOL(secure_dccpv6_sequence_number);
#endif
#endif",,6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,CVE-2011-3188,6e5714eaf77d79ae1c8b47e3e040ff5411b717ec,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"          VAR VAR VAR[VAR / 4] VAR; VAR VAR VAR VAR(VAR) { VAR(VAR, VAR(VAR)); VAR 0; } VAR(VAR); VAR VAR VAR(VAR VAR) { /* * VAR VAR VAR VAR VAR VAR 793, VAR * VAR VAR VAR 250 VAR VAR. * VAR VAR VAR VAR VAR 2 VAR/VAR VAR. * VAR 10 VAR/VAR VAR, VAR 1 VAR VAR VAR VAR. * VAR 10 VAR/VAR VAR, VAR 1 VAR VAR VAR VAR VAR, VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR (2 VAR). * VAR VAR VAR VAR 64 VAR VAR VAR VAR. (VAR VAR 274 VAR) */ VAR VAR + (VAR(VAR()) >> 6); }  VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR) { VAR VAR[VAR / 4]; VAR VAR[VAR]; VAR VAR; VAR(VAR, VAR, 16); VAR (VAR = 0; VAR < 4; VAR++) VAR[VAR] = VAR[VAR] + VAR[VAR]; VAR[4] = VAR[4] + (((VAR VAR)VAR << 16) + (VAR VAR)VAR); VAR (VAR = 5; VAR < VAR / 4; VAR++) VAR[VAR] = VAR[VAR]; VAR(VAR, VAR); VAR VAR(VAR[0]); } VAR(VAR); VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR[VAR / 4]; VAR VAR[VAR]; VAR VAR; VAR(VAR, VAR, 16); VAR (VAR = 0; VAR < 4; VAR++) VAR[VAR] = VAR[VAR] + (VAR VAR) VAR[VAR]; VAR[4] = VAR[4] + (VAR VAR)VAR; VAR (VAR = 5; VAR < VAR / 4; VAR++) VAR[VAR] = VAR[VAR]; VAR(VAR, VAR); VAR VAR[0]; }   VAR VAR(VAR VAR) { VAR VAR[VAR]; VAR[0] = (VAR VAR) VAR; VAR[1] = VAR[13]; VAR[2] = VAR[14]; VAR[3] = VAR[15]; VAR(VAR, VAR); VAR VAR[0]; } VAR VAR(VAR VAR VAR[4]) { VAR VAR[4]; VAR(VAR, VAR, 16); VAR(VAR, VAR); VAR VAR[0]; } VAR VAR(VAR VAR, VAR VAR, VAR VAR, VAR VAR) { VAR VAR[VAR]; VAR[0] = (VAR VAR)VAR; VAR[1] = (VAR VAR)VAR; VAR[2] = ((VAR VAR)VAR << 16) + (VAR VAR)VAR; VAR[3] = VAR[15]; VAR(VAR, VAR); VAR VAR(VAR[0]); } VAR VAR(VAR VAR, VAR VAR, VAR VAR) { VAR VAR[VAR]; VAR[0] = (VAR VAR)VAR; VAR[1] = (VAR VAR)VAR; VAR[2] = (VAR VAR)VAR ^ VAR[14]; VAR[3] = VAR[15]; VAR(VAR, VAR); VAR VAR[0]; } VAR(VAR);   VAR VAR(VAR VAR, VAR VAR, VAR VAR, VAR VAR) { VAR VAR[VAR]; VAR VAR; VAR[0] = (VAR VAR)VAR; VAR[1] = (VAR VAR)VAR; VAR[2] = ((VAR VAR)VAR << 16) + (VAR VAR)VAR; VAR[3] = VAR[15]; VAR(VAR, VAR); VAR = VAR[0] | (((VAR)VAR[1]) << 32); VAR += VAR(VAR()); VAR &= (1ull << 48) - 1; VAR VAR; } VAR(VAR);  VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR) { VAR VAR[VAR / 4]; VAR VAR[VAR]; VAR VAR; VAR VAR; VAR(VAR, VAR, 16); VAR (VAR = 0; VAR < 4; VAR++) VAR[VAR] = VAR[VAR] + VAR[VAR]; VAR[4] = VAR[4] + (((VAR VAR)VAR << 16) + (VAR VAR)VAR); VAR (VAR = 5; VAR < VAR / 4; VAR++) VAR[VAR] = VAR[VAR]; VAR(VAR, VAR); VAR = VAR[0] | (((VAR)VAR[1]) << 32); VAR += VAR(VAR()); VAR &= (1ull << 48) - 1; VAR VAR; } VAR(VAR);   ",1
linux_854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,arch/x86/include/asm/kvm_host.h,"static inline u64 get_canonical(u64 la)
{
	return ((int64_t)la << 16) >> 16;
}

static inline bool is_noncanonical_address(u64 la)
{
#ifdef CONFIG_X86_64
	return get_canonical(la) != la;
#else
	return false;
#endif
}
",,854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,CVE-2014-3610,854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR VAR VAR VAR(VAR VAR) { VAR ((VAR)VAR << 16) >> 16; } VAR VAR VAR VAR(VAR VAR) {  VAR VAR(VAR) != VAR;  VAR VAR;  } ,1
linux_9b4416c5095c20e110c82ae602c254099b83b72f,arch/powerpc/kvm/book3s_hv_rmhandlers.S,"	std	r5, 8(r1)	// Save CR in caller's frame
	std	r0, 16(r1)	// Save LR in caller's frame
	// Create frame on emergency stack
	ld	r4, PACAEMERGSP(r13)
	stdu	r1, -SWITCH_FRAME_SIZE(r4)
	// Switch to new frame on emergency stack
	mr	r1, r4
	ld	r1, 0(r1)	// Switch back to caller stack
	ld	r0, 16(r1)	// Reload LR
	ld	r5, 8(r1)	// Reload CR","	ld	r4,PACAEMERGSP(r13)
	std	r1,0(r4)
	std	r5,8(r4)
	std	r0,16(r4)
	subi	r1,r4,STACK_FRAME_OVERHEAD
	addi	r1, r1, STACK_FRAME_OVERHEAD
	ld	r0, 16(r1)
	ld	r5, 8(r1)
	ld	r1, 0(r1)",9b4416c5095c20e110c82ae602c254099b83b72f,CVE-2021-43056,9b4416c5095c20e110c82ae602c254099b83b72f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,"VAR VAR, 8(VAR)  VAR VAR, 16(VAR)   VAR VAR, VAR(VAR) VAR VAR, -VAR(VAR)  VAR VAR, VAR VAR VAR, 0(VAR)  VAR VAR, 16(VAR)  VAR VAR, 8(VAR)  VAR VAR,VAR(VAR) VAR VAR,0(VAR) VAR VAR,8(VAR) VAR VAR,16(VAR) VAR VAR,VAR,VAR VAR VAR, VAR, VAR VAR VAR, 16(VAR) VAR VAR, 8(VAR) VAR VAR, 0(VAR)",1
linux_9b6e6a8334d56354853f9c255d1395c2ba570e0a,arch/x86/entry/entry_64.S,"	 *
	 * However, espfix prevents us from directly returning to userspace
	 * with a single IRET instruction.  Similarly, IRET to user mode
	 * can fault.  We therefore handle NMIs from user space like
	 * other IST entries.
	testb	$3, CS-RIP+8(%rsp)
	jz	.Lnmi_from_kernel

	/*
	 * NMI from user mode.  We need to run on the thread stack, but we
	 * can't go through the normal entry paths: NMIs are masked, and
	 * we don't want to enable interrupts, because then we'll end
	 * up in an awkward situation in which IRQs are on but NMIs
	 * are off.
	 */

	SWAPGS
	cld
	movq	%rsp, %rdx
	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
	pushq	5*8(%rdx)	/* pt_regs->ss */
	pushq	4*8(%rdx)	/* pt_regs->rsp */
	pushq	3*8(%rdx)	/* pt_regs->flags */
	pushq	2*8(%rdx)	/* pt_regs->cs */
	pushq	1*8(%rdx)	/* pt_regs->rip */
	pushq   $-1		/* pt_regs->orig_ax */
	pushq   %rdi		/* pt_regs->di */
	pushq   %rsi		/* pt_regs->si */
	pushq   (%rdx)		/* pt_regs->dx */
	pushq   %rcx		/* pt_regs->cx */
	pushq   %rax		/* pt_regs->ax */
	pushq   %r8		/* pt_regs->r8 */
	pushq   %r9		/* pt_regs->r9 */
	pushq   %r10		/* pt_regs->r10 */
	pushq   %r11		/* pt_regs->r11 */
	pushq	%rbx		/* pt_regs->rbx */
	pushq	%rbp		/* pt_regs->rbp */
	pushq	%r12		/* pt_regs->r12 */
	pushq	%r13		/* pt_regs->r13 */
	pushq	%r14		/* pt_regs->r14 */
	pushq	%r15		/* pt_regs->r15 */

	 * At this point we no longer need to worry about stack damage
	 * due to nesting -- we're on the normal thread stack and we're
	 * done with the NMI stack.
	movq	%rsp, %rdi
	movq	$-1, %rsi
	call	do_nmi

	/*
	 * Return back to user mode.  We must *not* do the normal exit
	 * work, because we don't want to enable interrupts.  Fortunately,
	 * do_nmi doesn't modify pt_regs.
	 */
	SWAPGS
	jmp	restore_c_regs_and_iret

.Lnmi_from_kernel:","	 * If %cs was not the kernel segment, then the NMI triggered in user
	 * space, which means it is definitely not nested.
	cmpl	$__KERNEL_CS, 16(%rsp)
	jne	first_nmi",9b6e6a8334d56354853f9c255d1395c2ba570e0a,CVE-2015-5157,9b6e6a8334d56354853f9c255d1395c2ba570e0a,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"* * VAR, VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR * VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR. VAR $3, VAR-VAR+8(%VAR) VAR .VAR /* * VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR * VAR'VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR, VAR * VAR VAR'VAR VAR VAR VAR VAR, VAR VAR VAR'VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. */ VAR VAR VAR %VAR, %VAR VAR VAR(VAR), %VAR VAR 5*8(%VAR)  VAR 4*8(%VAR)  VAR 3*8(%VAR)  VAR 2*8(%VAR)  VAR 1*8(%VAR)  VAR $-1  VAR %VAR  VAR %VAR  VAR (%VAR)  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR -- VAR'VAR VAR VAR VAR VAR VAR VAR VAR'VAR * VAR VAR VAR VAR VAR. VAR %VAR, %VAR VAR $-1, %VAR VAR VAR /* * VAR VAR VAR VAR VAR. VAR VAR *VAR* VAR VAR VAR VAR * VAR, VAR VAR VAR'VAR VAR VAR VAR VAR. VAR, * VAR VAR'VAR VAR VAR. */ VAR VAR VAR .VAR: * VAR %VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR. VAR $VAR, 16(%VAR) VAR VAR",1
linux_9b6e6a8334d56354853f9c255d1395c2ba570e0a,arch/x86/entry/entry_64.S,"	 *
	 * However, espfix prevents us from directly returning to userspace
	 * with a single IRET instruction.  Similarly, IRET to user mode
	 * can fault.  We therefore handle NMIs from user space like
	 * other IST entries.
	testb	$3, CS-RIP+8(%rsp)
	jz	.Lnmi_from_kernel

	/*
	 * NMI from user mode.  We need to run on the thread stack, but we
	 * can't go through the normal entry paths: NMIs are masked, and
	 * we don't want to enable interrupts, because then we'll end
	 * up in an awkward situation in which IRQs are on but NMIs
	 * are off.
	 */

	SWAPGS
	cld
	movq	%rsp, %rdx
	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
	pushq	5*8(%rdx)	/* pt_regs->ss */
	pushq	4*8(%rdx)	/* pt_regs->rsp */
	pushq	3*8(%rdx)	/* pt_regs->flags */
	pushq	2*8(%rdx)	/* pt_regs->cs */
	pushq	1*8(%rdx)	/* pt_regs->rip */
	pushq   $-1		/* pt_regs->orig_ax */
	pushq   %rdi		/* pt_regs->di */
	pushq   %rsi		/* pt_regs->si */
	pushq   (%rdx)		/* pt_regs->dx */
	pushq   %rcx		/* pt_regs->cx */
	pushq   %rax		/* pt_regs->ax */
	pushq   %r8		/* pt_regs->r8 */
	pushq   %r9		/* pt_regs->r9 */
	pushq   %r10		/* pt_regs->r10 */
	pushq   %r11		/* pt_regs->r11 */
	pushq	%rbx		/* pt_regs->rbx */
	pushq	%rbp		/* pt_regs->rbp */
	pushq	%r12		/* pt_regs->r12 */
	pushq	%r13		/* pt_regs->r13 */
	pushq	%r14		/* pt_regs->r14 */
	pushq	%r15		/* pt_regs->r15 */

	 * At this point we no longer need to worry about stack damage
	 * due to nesting -- we're on the normal thread stack and we're
	 * done with the NMI stack.
	movq	%rsp, %rdi
	movq	$-1, %rsi
	call	do_nmi

	/*
	 * Return back to user mode.  We must *not* do the normal exit
	 * work, because we don't want to enable interrupts.  Fortunately,
	 * do_nmi doesn't modify pt_regs.
	 */
	SWAPGS
	jmp	restore_c_regs_and_iret

.Lnmi_from_kernel:","	 * If %cs was not the kernel segment, then the NMI triggered in user
	 * space, which means it is definitely not nested.
	cmpl	$__KERNEL_CS, 16(%rsp)
	jne	first_nmi",9b6e6a8334d56354853f9c255d1395c2ba570e0a,CVE-2015-3290,9b6e6a8334d56354853f9c255d1395c2ba570e0a,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"* * VAR, VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR * VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR. VAR $3, VAR-VAR+8(%VAR) VAR .VAR /* * VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR * VAR'VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR, VAR * VAR VAR'VAR VAR VAR VAR VAR, VAR VAR VAR'VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. */ VAR VAR VAR %VAR, %VAR VAR VAR(VAR), %VAR VAR 5*8(%VAR)  VAR 4*8(%VAR)  VAR 3*8(%VAR)  VAR 2*8(%VAR)  VAR 1*8(%VAR)  VAR $-1  VAR %VAR  VAR %VAR  VAR (%VAR)  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR -- VAR'VAR VAR VAR VAR VAR VAR VAR VAR'VAR * VAR VAR VAR VAR VAR. VAR %VAR, %VAR VAR $-1, %VAR VAR VAR /* * VAR VAR VAR VAR VAR. VAR VAR *VAR* VAR VAR VAR VAR * VAR, VAR VAR VAR'VAR VAR VAR VAR VAR. VAR, * VAR VAR'VAR VAR VAR. */ VAR VAR VAR .VAR: * VAR %VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR. VAR $VAR, 16(%VAR) VAR VAR",1
linux_a45f795c65b479b4ba107b6ccde29b896d51ee98,net/ceph/crypto.c,"static int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,
			  void *buf, int buf_len, int in_len, int *pout_len)
{
	struct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();
	SKCIPHER_REQUEST_ON_STACK(req, tfm);
	struct sg_table sgt;
	struct scatterlist prealloc_sg;
	char iv[AES_BLOCK_SIZE];
	int pad_byte = AES_BLOCK_SIZE - (in_len & (AES_BLOCK_SIZE - 1));
	int crypt_len = encrypt ? in_len + pad_byte : in_len;
	int ret;

	if (IS_ERR(tfm))
		return PTR_ERR(tfm);

	WARN_ON(crypt_len > buf_len);
	if (encrypt)
		memset(buf + in_len, pad_byte, pad_byte);
	ret = setup_sgtable(&sgt, &prealloc_sg, buf, crypt_len);
	if (ret)
		goto out_tfm;

	crypto_skcipher_setkey((void *)tfm, key->key, key->len);
	memcpy(iv, aes_iv, AES_BLOCK_SIZE);

	skcipher_request_set_tfm(req, tfm);
	skcipher_request_set_callback(req, 0, NULL, NULL);
	skcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);

	/*
	print_hex_dump(KERN_ERR, ""key: "", DUMP_PREFIX_NONE, 16, 1,
		       key->key, key->len, 1);
	print_hex_dump(KERN_ERR, "" in: "", DUMP_PREFIX_NONE, 16, 1,
		       buf, crypt_len, 1);
	*/
	if (encrypt)
		ret = crypto_skcipher_encrypt(req);
	else
		ret = crypto_skcipher_decrypt(req);
	skcipher_request_zero(req);
	if (ret) {
		pr_err(""%s %scrypt failed: %d\n"", __func__,
		       encrypt ? ""en"" : ""de"", ret);
		goto out_sgt;
	}
	/*
	print_hex_dump(KERN_ERR, ""out: "", DUMP_PREFIX_NONE, 16, 1,
		       buf, crypt_len, 1);
	*/

	if (encrypt) {
		*pout_len = crypt_len;
	} else {
		pad_byte = *(char *)(buf + in_len - 1);
		if (pad_byte > 0 && pad_byte <= AES_BLOCK_SIZE &&
		    in_len >= pad_byte) {
			*pout_len = in_len - pad_byte;
		} else {
			pr_err(""%s got bad padding %d on in_len %d\n"",
			       __func__, pad_byte, in_len);
			ret = -EPERM;
			goto out_sgt;
		}
	}

out_sgt:
	teardown_sgtable(&sgt);
out_tfm:
	crypto_free_skcipher(tfm);
	return ret;
}

int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,
	       void *buf, int buf_len, int in_len, int *pout_len)
{
	switch (key->type) {
	case CEPH_CRYPTO_NONE:
		*pout_len = in_len;
		return 0;
	case CEPH_CRYPTO_AES:
		return ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,
				      pout_len);
	default:
		return -ENOTSUPP;
	}
}
",,a45f795c65b479b4ba107b6ccde29b896d51ee98,CVE-2016-10153,a45f795c65b479b4ba107b6ccde29b896d51ee98,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR VAR VAR *VAR, VAR VAR, VAR *VAR, VAR VAR, VAR VAR, VAR *VAR) { VAR VAR *VAR = VAR(); VAR(VAR, VAR); VAR VAR VAR; VAR VAR VAR; VAR VAR[VAR]; VAR VAR = VAR - (VAR & (VAR - 1)); VAR VAR = VAR ? VAR + VAR : VAR; VAR VAR; VAR (VAR(VAR)) VAR VAR(VAR); VAR(VAR > VAR); VAR (VAR) VAR(VAR + VAR, VAR, VAR); VAR = VAR(&VAR, &VAR, VAR, VAR); VAR (VAR) VAR VAR; VAR((VAR *)VAR, VAR->VAR, VAR->VAR); VAR(VAR, VAR, VAR); VAR(VAR, VAR); VAR(VAR, 0, VAR, VAR); VAR(VAR, VAR.VAR, VAR.VAR, VAR, VAR); /* VAR(VAR, ""VAR: "", VAR, 16, 1, VAR->VAR, VAR->VAR, 1); VAR(VAR, "" VAR: "", VAR, 16, 1, VAR, VAR, 1); */ VAR (VAR) VAR = VAR(VAR); VAR VAR = VAR(VAR); VAR(VAR); VAR (VAR) { VAR(""%VAR %VAR VAR: %VAR\VAR"", VAR, VAR ? ""VAR"" : ""VAR"", VAR); VAR VAR; } /* VAR(VAR, ""VAR: "", VAR, 16, 1, VAR, VAR, 1); */ VAR (VAR) { *VAR = VAR; } VAR { VAR = *(VAR *)(VAR + VAR - 1); VAR (VAR > 0 && VAR <= VAR && VAR >= VAR) { *VAR = VAR - VAR; } VAR { VAR(""%VAR VAR VAR VAR %VAR VAR VAR %VAR\VAR"", VAR, VAR, VAR); VAR = -VAR; VAR VAR; } } VAR: VAR(&VAR); VAR: VAR(VAR); VAR VAR; } VAR VAR(VAR VAR VAR *VAR, VAR VAR, VAR *VAR, VAR VAR, VAR VAR, VAR *VAR) { VAR (VAR->VAR) { VAR VAR: *VAR = VAR; VAR 0; VAR VAR: VAR VAR(VAR, VAR, VAR, VAR, VAR, VAR); VAR: VAR -VAR; } } ",1
linux_aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba,net/ipv4/route.c,"#include <linux/memblock.h>
/* Hash tables of size 2048..262144 depending on RAM size.
 * Each bucket uses 8 bytes.
 */
static u32 ip_idents_mask __read_mostly;
	u32 bucket, old, now = (u32)jiffies;
	atomic_t *p_id;
	u32 *p_tstamp;
	bucket = hash & ip_idents_mask;
	p_tstamp = ip_tstamps + bucket;
	p_id = ip_idents + bucket;
	old = READ_ONCE(*p_tstamp);

	void *idents_hash;
	/* For modern hosts, this will use 2 MB of memory */
	idents_hash = alloc_large_system_hash(""IP idents"",
					      sizeof(*ip_idents) + sizeof(*ip_tstamps),
					      0,
					      16, /* one bucket per 64 KB */
					      HASH_ZERO,
					      NULL,
					      &ip_idents_mask,
					      2048,
					      256*1024);

	ip_idents = idents_hash;
	prandom_bytes(ip_idents, (ip_idents_mask + 1) * sizeof(*ip_idents));
	ip_tstamps = idents_hash + (ip_idents_mask + 1) * sizeof(*ip_idents);","#define IP_IDENTS_SZ 2048u

	u32 *p_tstamp = ip_tstamps + hash % IP_IDENTS_SZ;
	atomic_t *p_id = ip_idents + hash % IP_IDENTS_SZ;
	u32 old = READ_ONCE(*p_tstamp);
	u32 now = (u32)jiffies;
	ip_idents = kmalloc_array(IP_IDENTS_SZ, sizeof(*ip_idents),
				  GFP_KERNEL);
	if (!ip_idents)
		panic(""IP: failed to allocate ip_idents\n"");
	prandom_bytes(ip_idents, IP_IDENTS_SZ * sizeof(*ip_idents));
	ip_tstamps = kcalloc(IP_IDENTS_SZ, sizeof(*ip_tstamps), GFP_KERNEL);
	if (!ip_tstamps)
		panic(""IP: failed to allocate ip_tstamps\n"");",aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba,CVE-2021-45486,aa6dd211e4b1dde9d5dc25d699d35f789ae7eeba,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,84,COMPLETED," /* VAR VAR VAR VAR 2048..262144 VAR VAR VAR VAR. * VAR VAR VAR 8 VAR. */ VAR VAR VAR VAR; VAR VAR, VAR, VAR = (VAR)VAR; VAR *VAR; VAR *VAR; VAR = VAR & VAR; VAR = VAR + VAR; VAR = VAR + VAR; VAR = VAR(*VAR); VAR *VAR;  VAR = VAR(""VAR VAR"", VAR(*VAR) + VAR(*VAR), 0, 16,  VAR, VAR, &VAR, 2048, 256*1024); VAR = VAR; VAR(VAR, (VAR + 1) * VAR(*VAR)); VAR = VAR + (VAR + 1) * VAR(*VAR);  VAR *VAR = VAR + VAR % VAR; VAR *VAR = VAR + VAR % VAR; VAR VAR = VAR(*VAR); VAR VAR = (VAR)VAR; VAR = VAR(VAR, VAR(*VAR), VAR); VAR (!VAR) VAR(""VAR: VAR VAR VAR VAR\VAR""); VAR(VAR, VAR * VAR(*VAR)); VAR = VAR(VAR, VAR(*VAR), VAR); VAR (!VAR) VAR(""VAR: VAR VAR VAR VAR\VAR"");",1
linux_ad67b74d2469d9b82aaa572d76474c95bc484d57,livsprintf.c,"#include <linux/siphash.h>
#include <linux/compiler.h>
static bool have_filled_random_ptr_key __read_mostly;
static siphash_key_t ptr_key __read_mostly;

static void fill_random_ptr_key(struct random_ready_callback *unused)
{
	get_random_bytes(&ptr_key, sizeof(ptr_key));
	/*
	 * have_filled_random_ptr_key==true is dependent on get_random_bytes().
	 * ptr_to_id() needs to see have_filled_random_ptr_key==true
	 * after get_random_bytes() returns.
	 */
	smp_mb();
	WRITE_ONCE(have_filled_random_ptr_key, true);
}

static struct random_ready_callback random_ready = {
	.func = fill_random_ptr_key
};

static int __init initialize_ptr_random(void)
{
	int ret = add_random_ready_callback(&random_ready);

	if (!ret) {
		return 0;
	} else if (ret == -EALREADY) {
		fill_random_ptr_key(&random_ready);
		return 0;
	}

	return ret;
}
early_initcall(initialize_ptr_random);

/* Maps a pointer to a 32 bit unique identifier. */
static char *ptr_to_id(char *buf, char *end, void *ptr, struct printf_spec spec)
{
	unsigned long hashval;
	const int default_width = 2 * sizeof(ptr);

	if (unlikely(!have_filled_random_ptr_key)) {
		spec.field_width = default_width;
		/* string length must be less than default_width */
		return string(buf, end, ""(ptrval)"", spec);
	}

#ifdef CONFIG_64BIT
	hashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);
	/*
	 * Mask off the first 32 bits, this makes explicit that we have
	 * modified the address (and 32 bits is plenty for a unique ID).
	 */
	hashval = hashval & 0xffffffff;
#else
	hashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);
#endif

	spec.flags |= SMALL;
	if (spec.field_width == -1) {
		spec.field_width = default_width;
		spec.flags |= ZEROPAD;
	}
	spec.base = 16;

	return number(buf, end, hashval, spec);
}

 *
 * Note: The default behaviour (unadorned %p) is to hash the address,
 * rendering it useful as a unique identifier.
	/* default is to _not_ leak addresses, hash before printing */
	return ptr_to_id(buf, end, ptr, spec);","	spec.flags |= SMALL;
	if (spec.field_width == -1) {
		spec.field_width = default_width;
		spec.flags |= ZEROPAD;
	}
	spec.base = 16;
	return number(buf, end, (unsigned long) ptr, spec);",ad67b74d2469d9b82aaa572d76474c95bc484d57,CVE-2018-5995,ad67b74d2469d9b82aaa572d76474c95bc484d57,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,76,COMPLETED,"  VAR VAR VAR VAR; VAR VAR VAR VAR; VAR VAR VAR(VAR VAR *VAR) { VAR(&VAR, VAR(VAR)); /* * VAR==VAR VAR VAR VAR VAR(). * VAR() VAR VAR VAR VAR==VAR * VAR VAR() VAR. */ VAR(); VAR(VAR, VAR); } VAR VAR VAR VAR = { .VAR = VAR }; VAR VAR VAR VAR(VAR) { VAR VAR = VAR(&VAR); VAR (!VAR) { VAR 0; } VAR VAR (VAR == -VAR) { VAR(&VAR); VAR 0; } VAR VAR; } VAR(VAR);  VAR VAR *VAR(VAR *VAR, VAR *VAR, VAR *VAR, VAR VAR VAR) { VAR VAR VAR; VAR VAR VAR = 2 * VAR(VAR); VAR (VAR(!VAR)) { VAR.VAR = VAR;  VAR VAR(VAR, VAR, ""(VAR)"", VAR); }  VAR = (VAR VAR)VAR((VAR)VAR, &VAR); /* * VAR VAR VAR VAR 32 VAR, VAR VAR VAR VAR VAR VAR * VAR VAR VAR (VAR 32 VAR VAR VAR VAR VAR VAR VAR). */ VAR = VAR & 0xffffffff;  VAR = (VAR VAR)VAR((VAR)VAR, &VAR);  VAR.VAR |= VAR; VAR (VAR.VAR == -1) { VAR.VAR = VAR; VAR.VAR |= VAR; } VAR.VAR = 16; VAR VAR(VAR, VAR, VAR, VAR); } * * VAR: VAR VAR VAR (VAR %VAR) VAR VAR VAR VAR VAR, * VAR VAR VAR VAR VAR VAR VAR.  VAR VAR(VAR, VAR, VAR, VAR); VAR.VAR |= VAR; VAR (VAR.VAR == -1) { VAR.VAR = VAR; VAR.VAR |= VAR; } VAR.VAR = 16; VAR VAR(VAR, VAR, (VAR VAR) VAR, VAR);",1
linux_ad67b74d2469d9b82aaa572d76474c95bc484d57,livsprintf.c,"#include <linux/siphash.h>
#include <linux/compiler.h>
static bool have_filled_random_ptr_key __read_mostly;
static siphash_key_t ptr_key __read_mostly;

static void fill_random_ptr_key(struct random_ready_callback *unused)
{
	get_random_bytes(&ptr_key, sizeof(ptr_key));
	/*
	 * have_filled_random_ptr_key==true is dependent on get_random_bytes().
	 * ptr_to_id() needs to see have_filled_random_ptr_key==true
	 * after get_random_bytes() returns.
	 */
	smp_mb();
	WRITE_ONCE(have_filled_random_ptr_key, true);
}

static struct random_ready_callback random_ready = {
	.func = fill_random_ptr_key
};

static int __init initialize_ptr_random(void)
{
	int ret = add_random_ready_callback(&random_ready);

	if (!ret) {
		return 0;
	} else if (ret == -EALREADY) {
		fill_random_ptr_key(&random_ready);
		return 0;
	}

	return ret;
}
early_initcall(initialize_ptr_random);

/* Maps a pointer to a 32 bit unique identifier. */
static char *ptr_to_id(char *buf, char *end, void *ptr, struct printf_spec spec)
{
	unsigned long hashval;
	const int default_width = 2 * sizeof(ptr);

	if (unlikely(!have_filled_random_ptr_key)) {
		spec.field_width = default_width;
		/* string length must be less than default_width */
		return string(buf, end, ""(ptrval)"", spec);
	}

#ifdef CONFIG_64BIT
	hashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);
	/*
	 * Mask off the first 32 bits, this makes explicit that we have
	 * modified the address (and 32 bits is plenty for a unique ID).
	 */
	hashval = hashval & 0xffffffff;
#else
	hashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);
#endif

	spec.flags |= SMALL;
	if (spec.field_width == -1) {
		spec.field_width = default_width;
		spec.flags |= ZEROPAD;
	}
	spec.base = 16;

	return number(buf, end, hashval, spec);
}

 *
 * Note: The default behaviour (unadorned %p) is to hash the address,
 * rendering it useful as a unique identifier.
	/* default is to _not_ leak addresses, hash before printing */
	return ptr_to_id(buf, end, ptr, spec);","	spec.flags |= SMALL;
	if (spec.field_width == -1) {
		spec.field_width = default_width;
		spec.flags |= ZEROPAD;
	}
	spec.base = 16;
	return number(buf, end, (unsigned long) ptr, spec);",ad67b74d2469d9b82aaa572d76474c95bc484d57,CVE-2018-5953,ad67b74d2469d9b82aaa572d76474c95bc484d57,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,76,COMPLETED,"  VAR VAR VAR VAR; VAR VAR VAR VAR; VAR VAR VAR(VAR VAR *VAR) { VAR(&VAR, VAR(VAR)); /* * VAR==VAR VAR VAR VAR VAR(). * VAR() VAR VAR VAR VAR==VAR * VAR VAR() VAR. */ VAR(); VAR(VAR, VAR); } VAR VAR VAR VAR = { .VAR = VAR }; VAR VAR VAR VAR(VAR) { VAR VAR = VAR(&VAR); VAR (!VAR) { VAR 0; } VAR VAR (VAR == -VAR) { VAR(&VAR); VAR 0; } VAR VAR; } VAR(VAR);  VAR VAR *VAR(VAR *VAR, VAR *VAR, VAR *VAR, VAR VAR VAR) { VAR VAR VAR; VAR VAR VAR = 2 * VAR(VAR); VAR (VAR(!VAR)) { VAR.VAR = VAR;  VAR VAR(VAR, VAR, ""(VAR)"", VAR); }  VAR = (VAR VAR)VAR((VAR)VAR, &VAR); /* * VAR VAR VAR VAR 32 VAR, VAR VAR VAR VAR VAR VAR * VAR VAR VAR (VAR 32 VAR VAR VAR VAR VAR VAR VAR). */ VAR = VAR & 0xffffffff;  VAR = (VAR VAR)VAR((VAR)VAR, &VAR);  VAR.VAR |= VAR; VAR (VAR.VAR == -1) { VAR.VAR = VAR; VAR.VAR |= VAR; } VAR.VAR = 16; VAR VAR(VAR, VAR, VAR, VAR); } * * VAR: VAR VAR VAR (VAR %VAR) VAR VAR VAR VAR VAR, * VAR VAR VAR VAR VAR VAR VAR.  VAR VAR(VAR, VAR, VAR, VAR); VAR.VAR |= VAR; VAR (VAR.VAR == -1) { VAR.VAR = VAR; VAR.VAR |= VAR; } VAR.VAR = 16; VAR VAR(VAR, VAR, (VAR VAR) VAR, VAR);",1
linux_ad67b74d2469d9b82aaa572d76474c95bc484d57,livsprintf.c,"#include <linux/siphash.h>
#include <linux/compiler.h>
static bool have_filled_random_ptr_key __read_mostly;
static siphash_key_t ptr_key __read_mostly;

static void fill_random_ptr_key(struct random_ready_callback *unused)
{
	get_random_bytes(&ptr_key, sizeof(ptr_key));
	/*
	 * have_filled_random_ptr_key==true is dependent on get_random_bytes().
	 * ptr_to_id() needs to see have_filled_random_ptr_key==true
	 * after get_random_bytes() returns.
	 */
	smp_mb();
	WRITE_ONCE(have_filled_random_ptr_key, true);
}

static struct random_ready_callback random_ready = {
	.func = fill_random_ptr_key
};

static int __init initialize_ptr_random(void)
{
	int ret = add_random_ready_callback(&random_ready);

	if (!ret) {
		return 0;
	} else if (ret == -EALREADY) {
		fill_random_ptr_key(&random_ready);
		return 0;
	}

	return ret;
}
early_initcall(initialize_ptr_random);

/* Maps a pointer to a 32 bit unique identifier. */
static char *ptr_to_id(char *buf, char *end, void *ptr, struct printf_spec spec)
{
	unsigned long hashval;
	const int default_width = 2 * sizeof(ptr);

	if (unlikely(!have_filled_random_ptr_key)) {
		spec.field_width = default_width;
		/* string length must be less than default_width */
		return string(buf, end, ""(ptrval)"", spec);
	}

#ifdef CONFIG_64BIT
	hashval = (unsigned long)siphash_1u64((u64)ptr, &ptr_key);
	/*
	 * Mask off the first 32 bits, this makes explicit that we have
	 * modified the address (and 32 bits is plenty for a unique ID).
	 */
	hashval = hashval & 0xffffffff;
#else
	hashval = (unsigned long)siphash_1u32((u32)ptr, &ptr_key);
#endif

	spec.flags |= SMALL;
	if (spec.field_width == -1) {
		spec.field_width = default_width;
		spec.flags |= ZEROPAD;
	}
	spec.base = 16;

	return number(buf, end, hashval, spec);
}

 *
 * Note: The default behaviour (unadorned %p) is to hash the address,
 * rendering it useful as a unique identifier.
	/* default is to _not_ leak addresses, hash before printing */
	return ptr_to_id(buf, end, ptr, spec);","	spec.flags |= SMALL;
	if (spec.field_width == -1) {
		spec.field_width = default_width;
		spec.flags |= ZEROPAD;
	}
	spec.base = 16;
	return number(buf, end, (unsigned long) ptr, spec);",ad67b74d2469d9b82aaa572d76474c95bc484d57,CVE-2018-7754,ad67b74d2469d9b82aaa572d76474c95bc484d57,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,72,COMPLETED,"  VAR VAR VAR VAR; VAR VAR VAR VAR; VAR VAR VAR(VAR VAR *VAR) { VAR(&VAR, VAR(VAR)); /* * VAR==VAR VAR VAR VAR VAR(). * VAR() VAR VAR VAR VAR==VAR * VAR VAR() VAR. */ VAR(); VAR(VAR, VAR); } VAR VAR VAR VAR = { .VAR = VAR }; VAR VAR VAR VAR(VAR) { VAR VAR = VAR(&VAR); VAR (!VAR) { VAR 0; } VAR VAR (VAR == -VAR) { VAR(&VAR); VAR 0; } VAR VAR; } VAR(VAR);  VAR VAR *VAR(VAR *VAR, VAR *VAR, VAR *VAR, VAR VAR VAR) { VAR VAR VAR; VAR VAR VAR = 2 * VAR(VAR); VAR (VAR(!VAR)) { VAR.VAR = VAR;  VAR VAR(VAR, VAR, ""(VAR)"", VAR); }  VAR = (VAR VAR)VAR((VAR)VAR, &VAR); /* * VAR VAR VAR VAR 32 VAR, VAR VAR VAR VAR VAR VAR * VAR VAR VAR (VAR 32 VAR VAR VAR VAR VAR VAR VAR). */ VAR = VAR & 0xffffffff;  VAR = (VAR VAR)VAR((VAR)VAR, &VAR);  VAR.VAR |= VAR; VAR (VAR.VAR == -1) { VAR.VAR = VAR; VAR.VAR |= VAR; } VAR.VAR = 16; VAR VAR(VAR, VAR, VAR, VAR); } * * VAR: VAR VAR VAR (VAR %VAR) VAR VAR VAR VAR VAR, * VAR VAR VAR VAR VAR VAR VAR.  VAR VAR(VAR, VAR, VAR, VAR); VAR.VAR |= VAR; VAR (VAR.VAR == -1) { VAR.VAR = VAR; VAR.VAR |= VAR; } VAR.VAR = 16; VAR VAR(VAR, VAR, (VAR VAR) VAR, VAR);",1
linux_b04e75a4a8a81887386a0d2dbf605a48e779d2a0,drivers/scsi/dpt_i2o.c,,"// SPDX-License-Identifier: GPL-2.0-or-later
/***************************************************************************
                          dpti.c  -  description
                             -------------------
    begin                : Thu Sep 7 2000
    copyright            : (C) 2000 by Adaptec

			   July 30, 2001 First version being submitted
			   for inclusion in the kernel.  V2.4

    See Documentation/scsi/dpti.rst for history, notes, license info
    and credits
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *                                                                         *
 ***************************************************************************/
/***************************************************************************
 * Sat Dec 20 2003 Go Taniguchi <go@turbolinux.co.jp>
 - Support 2.6 kernel and DMA-mapping
 - ioctl fix for raid tools
 - use schedule_timeout in long long loop
 **************************************************************************/

/*#define DEBUG 1 */
/*#define UARTDELAY 1 */

#include <linux/module.h>
#include <linux/pgtable.h>

MODULE_AUTHOR(""Deanna Bonds, with _lots_ of help from Mark Salyzyn"");
MODULE_DESCRIPTION(""Adaptec I2O RAID Driver"");

////////////////////////////////////////////////////////////////

#include <linux/ioctl.h>	/* For SCSI-Passthrough */
#include <linux/uaccess.h>

#include <linux/stat.h>
#include <linux/slab.h>		/* for kmalloc() */
#include <linux/pci.h>		/* for PCI support */
#include <linux/proc_fs.h>
#include <linux/blkdev.h>
#include <linux/delay.h>	/* for udelay */
#include <linux/interrupt.h>
#include <linux/kernel.h>	/* for printk */
#include <linux/sched.h>
#include <linux/reboot.h>
#include <linux/spinlock.h>
#include <linux/dma-mapping.h>

#include <linux/timer.h>
#include <linux/string.h>
#include <linux/ioport.h>
#include <linux/mutex.h>

#include <asm/processor.h>	/* for boot_cpu_data */
#include <asm/io.h>		/* for virt_to_bus, etc. */

#include <scsi/scsi.h>
#include <scsi/scsi_cmnd.h>
#include <scsi/scsi_device.h>
#include <scsi/scsi_host.h>
#include <scsi/scsi_tcq.h>

#include ""dpt/dptsig.h""
#include ""dpti.h""

/*============================================================================
 * Create a binary signature - this is read by dptsig
 * Needed for our management apps
 *============================================================================
 */
static DEFINE_MUTEX(adpt_mutex);
static dpt_sig_S DPTI_sig = {
	{'d', 'P', 't', 'S', 'i', 'G'}, SIG_VERSION,
#ifdef __i386__
	PROC_INTEL, PROC_386 | PROC_486 | PROC_PENTIUM | PROC_SEXIUM,
#elif defined(__ia64__)
	PROC_INTEL, PROC_IA64,
#elif defined(__sparc__)
	PROC_ULTRASPARC, PROC_ULTRASPARC,
#elif defined(__alpha__)
	PROC_ALPHA, PROC_ALPHA,
#else
	(-1),(-1),
#endif
	 FT_HBADRVR, 0, OEM_DPT, OS_LINUX, CAP_OVERLAP, DEV_ALL,
	ADF_ALL_SC5, 0, 0, DPT_VERSION, DPT_REVISION, DPT_SUBREVISION,
	DPT_MONTH, DPT_DAY, DPT_YEAR, ""Adaptec Linux I2O RAID Driver""
};




/*============================================================================
 * Globals
 *============================================================================
 */

static DEFINE_MUTEX(adpt_configuration_lock);

static struct i2o_sys_tbl *sys_tbl;
static dma_addr_t sys_tbl_pa;
static int sys_tbl_ind;
static int sys_tbl_len;

static adpt_hba* hba_chain = NULL;
static int hba_count = 0;

static struct class *adpt_sysfs_class;

static long adpt_unlocked_ioctl(struct file *, unsigned int, unsigned long);
#ifdef CONFIG_COMPAT
static long compat_adpt_ioctl(struct file *, unsigned int, unsigned long);
#endif

static const struct file_operations adpt_fops = {
	.unlocked_ioctl	= adpt_unlocked_ioctl,
	.open		= adpt_open,
	.release	= adpt_close,
#ifdef CONFIG_COMPAT
	.compat_ioctl	= compat_adpt_ioctl,
#endif
	.llseek		= noop_llseek,
};

/* Structures and definitions for synchronous message posting.
 * See adpt_i2o_post_wait() for description
 * */
struct adpt_i2o_post_wait_data
{
	int status;
	u32 id;
	adpt_wait_queue_head_t *wq;
	struct adpt_i2o_post_wait_data *next;
};

static struct adpt_i2o_post_wait_data *adpt_post_wait_queue = NULL;
static u32 adpt_post_wait_id = 0;
static DEFINE_SPINLOCK(adpt_post_wait_lock);


/*============================================================================
 * 				Functions
 *============================================================================
 */

static inline int dpt_dma64(adpt_hba *pHba)
{
	return (sizeof(dma_addr_t) > 4 && (pHba)->dma64);
}

static inline u32 dma_high(dma_addr_t addr)
{
	return upper_32_bits(addr);
}

static inline u32 dma_low(dma_addr_t addr)
{
	return (u32)addr;
}

static u8 adpt_read_blink_led(adpt_hba* host)
{
	if (host->FwDebugBLEDflag_P) {
		if( readb(host->FwDebugBLEDflag_P) == 0xbc ){
			return readb(host->FwDebugBLEDvalue_P);
		}
	}
	return 0;
}

/*============================================================================
 * Scsi host template interface functions
 *============================================================================
 */

#ifdef MODULE
static struct pci_device_id dptids[] = {
	{ PCI_DPT_VENDOR_ID, PCI_DPT_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,},
	{ PCI_DPT_VENDOR_ID, PCI_DPT_RAPTOR_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,},
	{ 0, }
};
#endif

MODULE_DEVICE_TABLE(pci,dptids);

static int adpt_detect(struct scsi_host_template* sht)
{
	struct pci_dev *pDev = NULL;
	adpt_hba *pHba;
	adpt_hba *next;

	PINFO(""Detecting Adaptec I2O RAID controllers...\n"");

        /* search for all Adatpec I2O RAID cards */
	while ((pDev = pci_get_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
		if(pDev->device == PCI_DPT_DEVICE_ID ||
		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
			if(adpt_install_hba(sht, pDev) ){
				PERROR(""Could not Init an I2O RAID device\n"");
				PERROR(""Will not try to detect others.\n"");
				return hba_count-1;
			}
			pci_dev_get(pDev);
		}
	}

	/* In INIT state, Activate IOPs */
	for (pHba = hba_chain; pHba; pHba = next) {
		next = pHba->next;
		// Activate does get status , init outbound, and get hrt
		if (adpt_i2o_activate_hba(pHba) < 0) {
			adpt_i2o_delete_hba(pHba);
		}
	}


	/* Active IOPs in HOLD state */

rebuild_sys_tab:
	if (hba_chain == NULL)
		return 0;

	/*
	 * If build_sys_table fails, we kill everything and bail
	 * as we can't init the IOPs w/o a system table
	 */
	if (adpt_i2o_build_sys_table() < 0) {
		adpt_i2o_sys_shutdown();
		return 0;
	}

	PDEBUG(""HBA's in HOLD state\n"");

	/* If IOP don't get online, we need to rebuild the System table */
	for (pHba = hba_chain; pHba; pHba = pHba->next) {
		if (adpt_i2o_online_hba(pHba) < 0) {
			adpt_i2o_delete_hba(pHba);
			goto rebuild_sys_tab;
		}
	}

	/* Active IOPs now in OPERATIONAL state */
	PDEBUG(""HBA's in OPERATIONAL state\n"");

	printk(""dpti: If you have a lot of devices this could take a few minutes.\n"");
	for (pHba = hba_chain; pHba; pHba = next) {
		next = pHba->next;
		printk(KERN_INFO""%s: Reading the hardware resource table.\n"", pHba->name);
		if (adpt_i2o_lct_get(pHba) < 0){
			adpt_i2o_delete_hba(pHba);
			continue;
		}

		if (adpt_i2o_parse_lct(pHba) < 0){
			adpt_i2o_delete_hba(pHba);
			continue;
		}
		adpt_inquiry(pHba);
	}

	adpt_sysfs_class = class_create(THIS_MODULE, ""dpt_i2o"");
	if (IS_ERR(adpt_sysfs_class)) {
		printk(KERN_WARNING""dpti: unable to create dpt_i2o class\n"");
		adpt_sysfs_class = NULL;
	}

	for (pHba = hba_chain; pHba; pHba = next) {
		next = pHba->next;
		if (adpt_scsi_host_alloc(pHba, sht) < 0){
			adpt_i2o_delete_hba(pHba);
			continue;
		}
		pHba->initialized = TRUE;
		pHba->state &= ~DPTI_STATE_RESET;
		if (adpt_sysfs_class) {
			struct device *dev = device_create(adpt_sysfs_class,
				NULL, MKDEV(DPTI_I2O_MAJOR, pHba->unit), NULL,
				""dpti%d"", pHba->unit);
			if (IS_ERR(dev)) {
				printk(KERN_WARNING""dpti%d: unable to ""
					""create device in dpt_i2o class\n"",
					pHba->unit);
			}
		}
	}

	// Register our control device node
	// nodes will need to be created in /dev to access this
	// the nodes can not be created from within the driver
	if (hba_count && register_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER, &adpt_fops)) {
		adpt_i2o_sys_shutdown();
		return 0;
	}
	return hba_count;
}


static void adpt_release(adpt_hba *pHba)
{
	struct Scsi_Host *shost = pHba->host;

	scsi_remove_host(shost);
//	adpt_i2o_quiesce_hba(pHba);
	adpt_i2o_delete_hba(pHba);
	scsi_host_put(shost);
}


static void adpt_inquiry(adpt_hba* pHba)
{
	u32 msg[17];
	u32 *mptr;
	u32 *lenptr;
	int direction;
	int scsidir;
	u32 len;
	u32 reqlen;
	u8* buf;
	dma_addr_t addr;
	u8  scb[16];
	s32 rcode;

	memset(msg, 0, sizeof(msg));
	buf = dma_alloc_coherent(&pHba->pDev->dev, 80, &addr, GFP_KERNEL);
	if(!buf){
		printk(KERN_ERR""%s: Could not allocate buffer\n"",pHba->name);
		return;
	}
	memset((void*)buf, 0, 36);

	len = 36;
	direction = 0x00000000;
	scsidir  =0x40000000;	// DATA IN  (iop<--dev)

	if (dpt_dma64(pHba))
		reqlen = 17;		// SINGLE SGE, 64 bit
	else
		reqlen = 14;		// SINGLE SGE, 32 bit
	/* Stick the headers on */
	msg[0] = reqlen<<16 | SGL_OFFSET_12;
	msg[1] = (0xff<<24|HOST_TID<<12|ADAPTER_TID);
	msg[2] = 0;
	msg[3]  = 0;
	// Adaptec/DPT Private stuff
	msg[4] = I2O_CMD_SCSI_EXEC|DPT_ORGANIZATION_ID<<16;
	msg[5] = ADAPTER_TID | 1<<16 /* Interpret*/;
	/* Direction, disconnect ok | sense data | simple queue , CDBLen */
	// I2O_SCB_FLAG_ENABLE_DISCONNECT |
	// I2O_SCB_FLAG_SIMPLE_QUEUE_TAG |
	// I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;
	msg[6] = scsidir|0x20a00000| 6 /* cmd len*/;

	mptr=msg+7;

	memset(scb, 0, sizeof(scb));
	// Write SCSI command into the message - always 16 byte block
	scb[0] = INQUIRY;
	scb[1] = 0;
	scb[2] = 0;
	scb[3] = 0;
	scb[4] = 36;
	scb[5] = 0;
	// Don't care about the rest of scb

	memcpy(mptr, scb, sizeof(scb));
	mptr+=4;
	lenptr=mptr++;		/* Remember me - fill in when we know */

	/* Now fill in the SGList and command */
	*lenptr = len;
	if (dpt_dma64(pHba)) {
		*mptr++ = (0x7C<<24)+(2<<16)+0x02; /* Enable 64 bit */
		*mptr++ = 1 << PAGE_SHIFT;
		*mptr++ = 0xD0000000|direction|len;
		*mptr++ = dma_low(addr);
		*mptr++ = dma_high(addr);
	} else {
		*mptr++ = 0xD0000000|direction|len;
		*mptr++ = addr;
	}

	// Send it on it's way
	rcode = adpt_i2o_post_wait(pHba, msg, reqlen<<2, 120);
	if (rcode != 0) {
		sprintf(pHba->detail, ""Adaptec I2O RAID"");
		printk(KERN_INFO ""%s: Inquiry Error (%d)\n"",pHba->name,rcode);
		if (rcode != -ETIME && rcode != -EINTR)
			dma_free_coherent(&pHba->pDev->dev, 80, buf, addr);
	} else {
		memset(pHba->detail, 0, sizeof(pHba->detail));
		memcpy(&(pHba->detail), ""Vendor: Adaptec "", 16);
		memcpy(&(pHba->detail[16]), "" Model: "", 8);
		memcpy(&(pHba->detail[24]), (u8*) &buf[16], 16);
		memcpy(&(pHba->detail[40]), "" FW: "", 4);
		memcpy(&(pHba->detail[44]), (u8*) &buf[32], 4);
		pHba->detail[48] = '\0';	/* precautionary */
		dma_free_coherent(&pHba->pDev->dev, 80, buf, addr);
	}
	adpt_i2o_status_get(pHba);
	return ;
}


static int adpt_slave_configure(struct scsi_device * device)
{
	struct Scsi_Host *host = device->host;

	if (host->can_queue && device->tagged_supported) {
		scsi_change_queue_depth(device,
				host->can_queue - 1);
	}
	return 0;
}

static int adpt_queue_lck(struct scsi_cmnd *cmd)
{
	adpt_hba* pHba = NULL;
	struct adpt_device* pDev = NULL;	/* dpt per device information */

	/*
	 * SCSI REQUEST_SENSE commands will be executed automatically by the
	 * Host Adapter for any errors, so they should not be executed
	 * explicitly unless the Sense Data is zero indicating that no error
	 * occurred.
	 */

	if ((cmd->cmnd[0] == REQUEST_SENSE) && (cmd->sense_buffer[0] != 0)) {
		cmd->result = (DID_OK << 16);
		scsi_done(cmd);
		return 0;
	}

	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
	if (!pHba) {
		return FAILED;
	}

	rmb();
	if ((pHba->state) & DPTI_STATE_RESET)
		return SCSI_MLQUEUE_HOST_BUSY;

	// TODO if the cmd->device if offline then I may need to issue a bus rescan
	// followed by a get_lct to see if the device is there anymore
	if((pDev = (struct adpt_device*) (cmd->device->hostdata)) == NULL) {
		/*
		 * First command request for this device.  Set up a pointer
		 * to the device structure.  This should be a TEST_UNIT_READY
		 * command from scan_scsis_single.
		 */
		if ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun)) == NULL) {
			// TODO: if any luns are at this bus, scsi id then fake a TEST_UNIT_READY and INQUIRY response
			// with type 7F (for all luns less than the max for this bus,id) so the lun scan will continue.
			cmd->result = (DID_NO_CONNECT << 16);
			scsi_done(cmd);
			return 0;
		}
		cmd->device->hostdata = pDev;
	}
	pDev->pScsi_dev = cmd->device;

	/*
	 * If we are being called from when the device is being reset,
	 * delay processing of the command until later.
	 */
	if (pDev->state & DPTI_DEV_RESET ) {
		return FAILED;
	}
	return adpt_scsi_to_i2o(pHba, cmd, pDev);
}

static DEF_SCSI_QCMD(adpt_queue)

static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,
		sector_t capacity, int geom[])
{
	int heads=-1;
	int sectors=-1;
	int cylinders=-1;

	// *** First lets set the default geometry ****

	// If the capacity is less than ox2000
	if (capacity < 0x2000 ) {	// floppy
		heads = 18;
		sectors = 2;
	}
	// else if between 0x2000 and 0x20000
	else if (capacity < 0x20000) {
		heads = 64;
		sectors = 32;
	}
	// else if between 0x20000 and 0x40000
	else if (capacity < 0x40000) {
		heads = 65;
		sectors = 63;
	}
	// else if between 0x4000 and 0x80000
	else if (capacity < 0x80000) {
		heads = 128;
		sectors = 63;
	}
	// else if greater than 0x80000
	else {
		heads = 255;
		sectors = 63;
	}
	cylinders = sector_div(capacity, heads * sectors);

	// Special case if CDROM
	if(sdev->type == 5) {  // CDROM
		heads = 252;
		sectors = 63;
		cylinders = 1111;
	}

	geom[0] = heads;
	geom[1] = sectors;
	geom[2] = cylinders;

	PDEBUG(""adpt_bios_param: exit\n"");
	return 0;
}


static const char *adpt_info(struct Scsi_Host *host)
{
	adpt_hba* pHba;

	pHba = (adpt_hba *) host->hostdata[0];
	return (char *) (pHba->detail);
}

static int adpt_show_info(struct seq_file *m, struct Scsi_Host *host)
{
	struct adpt_device* d;
	int id;
	int chan;
	adpt_hba* pHba;
	int unit;

	// Find HBA (host bus adapter) we are looking for
	mutex_lock(&adpt_configuration_lock);
	for (pHba = hba_chain; pHba; pHba = pHba->next) {
		if (pHba->host == host) {
			break;	/* found adapter */
		}
	}
	mutex_unlock(&adpt_configuration_lock);
	if (pHba == NULL) {
		return 0;
	}
	host = pHba->host;

	seq_printf(m, ""Adaptec I2O RAID Driver Version: %s\n\n"", DPT_I2O_VERSION);
	seq_printf(m, ""%s\n"", pHba->detail);
	seq_printf(m, ""SCSI Host=scsi%d  Control Node=/dev/%s  irq=%d\n"",
			pHba->host->host_no, pHba->name, host->irq);
	seq_printf(m, ""\tpost fifo size  = %d\n\treply fifo size = %d\n\tsg table size   = %d\n\n"",
			host->can_queue, (int) pHba->reply_fifo_size , host->sg_tablesize);

	seq_puts(m, ""Devices:\n"");
	for(chan = 0; chan < MAX_CHANNEL; chan++) {
		for(id = 0; id < MAX_ID; id++) {
			d = pHba->channel[chan].device[id];
			while(d) {
				seq_printf(m,""\t%-24.24s"", d->pScsi_dev->vendor);
				seq_printf(m,"" Rev: %-8.8s\n"", d->pScsi_dev->rev);

				unit = d->pI2o_dev->lct_data.tid;
				seq_printf(m, ""\tTID=%d, (Channel=%d, Target=%d, Lun=%llu)  (%s)\n\n"",
					       unit, (int)d->scsi_channel, (int)d->scsi_id, d->scsi_lun,
					       scsi_device_online(d->pScsi_dev)? ""online"":""offline"");
				d = d->next_lun;
			}
		}
	}
	return 0;
}

/*
 *	Turn a pointer to ioctl reply data into an u32 'context'
 */
static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)
{
#if BITS_PER_LONG == 32
	return (u32)(unsigned long)reply;
#else
	ulong flags = 0;
	u32 nr, i;

	spin_lock_irqsave(pHba->host->host_lock, flags);
	nr = ARRAY_SIZE(pHba->ioctl_reply_context);
	for (i = 0; i < nr; i++) {
		if (pHba->ioctl_reply_context[i] == NULL) {
			pHba->ioctl_reply_context[i] = reply;
			break;
		}
	}
	spin_unlock_irqrestore(pHba->host->host_lock, flags);
	if (i >= nr) {
		printk(KERN_WARNING""%s: Too many outstanding ""
				""ioctl commands\n"", pHba->name);
		return (u32)-1;
	}

	return i;
#endif
}

/*
 *	Go from an u32 'context' to a pointer to ioctl reply data.
 */
static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)
{
#if BITS_PER_LONG == 32
	return (void *)(unsigned long)context;
#else
	void *p = pHba->ioctl_reply_context[context];
	pHba->ioctl_reply_context[context] = NULL;

	return p;
#endif
}

/*===========================================================================
 * Error Handling routines
 *===========================================================================
 */

static int adpt_abort(struct scsi_cmnd * cmd)
{
	adpt_hba* pHba = NULL;	/* host bus adapter structure */
	struct adpt_device* dptdevice;	/* dpt per device information */
	u32 msg[5];
	int rcode;

	pHba = (adpt_hba*) cmd->device->host->hostdata[0];
	printk(KERN_INFO""%s: Trying to Abort\n"",pHba->name);
	if ((dptdevice = (void*) (cmd->device->hostdata)) == NULL) {
		printk(KERN_ERR ""%s: Unable to abort: No device in cmnd\n"",pHba->name);
		return FAILED;
	}

	memset(msg, 0, sizeof(msg));
	msg[0] = FIVE_WORD_MSG_SIZE|SGL_OFFSET_0;
	msg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;
	msg[2] = 0;
	msg[3]= 0;
	/* Add 1 to avoid firmware treating it as invalid command */
	msg[4] = scsi_cmd_to_rq(cmd)->tag + 1;
	if (pHba->host)
		spin_lock_irq(pHba->host->host_lock);
	rcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER);
	if (pHba->host)
		spin_unlock_irq(pHba->host->host_lock);
	if (rcode != 0) {
		if(rcode == -EOPNOTSUPP ){
			printk(KERN_INFO""%s: Abort cmd not supported\n"",pHba->name);
			return FAILED;
		}
		printk(KERN_INFO""%s: Abort failed.\n"",pHba->name);
		return FAILED;
	}
	printk(KERN_INFO""%s: Abort complete.\n"",pHba->name);
	return SUCCESS;
}


#define I2O_DEVICE_RESET 0x27
// This is the same for BLK and SCSI devices
// NOTE this is wrong in the i2o.h definitions
// This is not currently supported by our adapter but we issue it anyway
static int adpt_device_reset(struct scsi_cmnd* cmd)
{
	adpt_hba* pHba;
	u32 msg[4];
	u32 rcode;
	int old_state;
	struct adpt_device* d = cmd->device->hostdata;

	pHba = (void*) cmd->device->host->hostdata[0];
	printk(KERN_INFO""%s: Trying to reset device\n"",pHba->name);
	if (!d) {
		printk(KERN_INFO""%s: Reset Device: Device Not found\n"",pHba->name);
		return FAILED;
	}
	memset(msg, 0, sizeof(msg));
	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
	msg[1] = (I2O_DEVICE_RESET<<24|HOST_TID<<12|d->tid);
	msg[2] = 0;
	msg[3] = 0;

	if (pHba->host)
		spin_lock_irq(pHba->host->host_lock);
	old_state = d->state;
	d->state |= DPTI_DEV_RESET;
	rcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);
	d->state = old_state;
	if (pHba->host)
		spin_unlock_irq(pHba->host->host_lock);
	if (rcode != 0) {
		if(rcode == -EOPNOTSUPP ){
			printk(KERN_INFO""%s: Device reset not supported\n"",pHba->name);
			return FAILED;
		}
		printk(KERN_INFO""%s: Device reset failed\n"",pHba->name);
		return FAILED;
	} else {
		printk(KERN_INFO""%s: Device reset successful\n"",pHba->name);
		return SUCCESS;
	}
}


#define I2O_HBA_BUS_RESET 0x87
// This version of bus reset is called by the eh_error handler
static int adpt_bus_reset(struct scsi_cmnd* cmd)
{
	adpt_hba* pHba;
	u32 msg[4];
	u32 rcode;

	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
	memset(msg, 0, sizeof(msg));
	printk(KERN_WARNING""%s: Bus reset: SCSI Bus %d: tid: %d\n"",pHba->name, cmd->device->channel,pHba->channel[cmd->device->channel].tid );
	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
	msg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);
	msg[2] = 0;
	msg[3] = 0;
	if (pHba->host)
		spin_lock_irq(pHba->host->host_lock);
	rcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);
	if (pHba->host)
		spin_unlock_irq(pHba->host->host_lock);
	if (rcode != 0) {
		printk(KERN_WARNING""%s: Bus reset failed.\n"",pHba->name);
		return FAILED;
	} else {
		printk(KERN_WARNING""%s: Bus reset success.\n"",pHba->name);
		return SUCCESS;
	}
}

// This version of reset is called by the eh_error_handler
static int __adpt_reset(struct scsi_cmnd* cmd)
{
	adpt_hba* pHba;
	int rcode;
	char name[32];

	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
	strncpy(name, pHba->name, sizeof(name));
	printk(KERN_WARNING""%s: Hba Reset: scsi id %d: tid: %d\n"", name, cmd->device->channel, pHba->channel[cmd->device->channel].tid);
	rcode =  adpt_hba_reset(pHba);
	if(rcode == 0){
		printk(KERN_WARNING""%s: HBA reset complete\n"", name);
		return SUCCESS;
	} else {
		printk(KERN_WARNING""%s: HBA reset failed (%x)\n"", name, rcode);
		return FAILED;
	}
}

static int adpt_reset(struct scsi_cmnd* cmd)
{
	int rc;

	spin_lock_irq(cmd->device->host->host_lock);
	rc = __adpt_reset(cmd);
	spin_unlock_irq(cmd->device->host->host_lock);

	return rc;
}

// This version of reset is called by the ioctls and indirectly from eh_error_handler via adpt_reset
static int adpt_hba_reset(adpt_hba* pHba)
{
	int rcode;

	pHba->state |= DPTI_STATE_RESET;

	// Activate does get status , init outbound, and get hrt
	if ((rcode=adpt_i2o_activate_hba(pHba)) < 0) {
		printk(KERN_ERR ""%s: Could not activate\n"", pHba->name);
		adpt_i2o_delete_hba(pHba);
		return rcode;
	}

	if ((rcode=adpt_i2o_build_sys_table()) < 0) {
		adpt_i2o_delete_hba(pHba);
		return rcode;
	}
	PDEBUG(""%s: in HOLD state\n"",pHba->name);

	if ((rcode=adpt_i2o_online_hba(pHba)) < 0) {
		adpt_i2o_delete_hba(pHba);
		return rcode;
	}
	PDEBUG(""%s: in OPERATIONAL state\n"",pHba->name);

	if ((rcode=adpt_i2o_lct_get(pHba)) < 0){
		adpt_i2o_delete_hba(pHba);
		return rcode;
	}

	if ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){
		adpt_i2o_delete_hba(pHba);
		return rcode;
	}
	pHba->state &= ~DPTI_STATE_RESET;

	scsi_host_complete_all_commands(pHba->host, DID_RESET);
	return 0;	/* return success */
}

/*===========================================================================
 *
 *===========================================================================
 */


static void adpt_i2o_sys_shutdown(void)
{
	adpt_hba *pHba, *pNext;
	struct adpt_i2o_post_wait_data *p1, *old;

	printk(KERN_INFO ""Shutting down Adaptec I2O controllers.\n"");
	printk(KERN_INFO ""   This could take a few minutes if there are many devices attached\n"");
	/* Delete all IOPs from the controller chain */
	/* They should have already been released by the
	 * scsi-core
	 */
	for (pHba = hba_chain; pHba; pHba = pNext) {
		pNext = pHba->next;
		adpt_i2o_delete_hba(pHba);
	}

	/* Remove any timedout entries from the wait queue.  */
//	spin_lock_irqsave(&adpt_post_wait_lock, flags);
	/* Nothing should be outstanding at this point so just
	 * free them
	 */
	for(p1 = adpt_post_wait_queue; p1;) {
		old = p1;
		p1 = p1->next;
		kfree(old);
	}
//	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);
	adpt_post_wait_queue = NULL;

	printk(KERN_INFO ""Adaptec I2O controllers down.\n"");
}

static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev)
{

	adpt_hba* pHba = NULL;
	adpt_hba* p = NULL;
	ulong base_addr0_phys = 0;
	ulong base_addr1_phys = 0;
	u32 hba_map0_area_size = 0;
	u32 hba_map1_area_size = 0;
	void __iomem *base_addr_virt = NULL;
	void __iomem *msg_addr_virt = NULL;
	int dma64 = 0;

	int raptorFlag = FALSE;

	if(pci_enable_device(pDev)) {
		return -EINVAL;
	}

	if (pci_request_regions(pDev, ""dpt_i2o"")) {
		PERROR(""dpti: adpt_config_hba: pci request region failed\n"");
		return -EINVAL;
	}

	pci_set_master(pDev);

	/*
	 *	See if we should enable dma64 mode.
	 */
	if (sizeof(dma_addr_t) > 4 &&
	    dma_get_required_mask(&pDev->dev) > DMA_BIT_MASK(32) &&
	    dma_set_mask(&pDev->dev, DMA_BIT_MASK(64)) == 0)
		dma64 = 1;

	if (!dma64 && dma_set_mask(&pDev->dev, DMA_BIT_MASK(32)) != 0)
		return -EINVAL;

	/* adapter only supports message blocks below 4GB */
	dma_set_coherent_mask(&pDev->dev, DMA_BIT_MASK(32));

	base_addr0_phys = pci_resource_start(pDev,0);
	hba_map0_area_size = pci_resource_len(pDev,0);

	// Check if standard PCI card or single BAR Raptor
	if(pDev->device == PCI_DPT_DEVICE_ID){
		if(pDev->subsystem_device >=0xc032 && pDev->subsystem_device <= 0xc03b){
			// Raptor card with this device id needs 4M
			hba_map0_area_size = 0x400000;
		} else { // Not Raptor - it is a PCI card
			if(hba_map0_area_size > 0x100000 ){
				hba_map0_area_size = 0x100000;
			}
		}
	} else {// Raptor split BAR config
		// Use BAR1 in this configuration
		base_addr1_phys = pci_resource_start(pDev,1);
		hba_map1_area_size = pci_resource_len(pDev,1);
		raptorFlag = TRUE;
	}

#if BITS_PER_LONG == 64
	/*
	 *	The original Adaptec 64 bit driver has this comment here:
	 *	""x86_64 machines need more optimal mappings""
	 *
	 *	I assume some HBAs report ridiculously large mappings
	 *	and we need to limit them on platforms with IOMMUs.
	 */
	if (raptorFlag == TRUE) {
		if (hba_map0_area_size > 128)
			hba_map0_area_size = 128;
		if (hba_map1_area_size > 524288)
			hba_map1_area_size = 524288;
	} else {
		if (hba_map0_area_size > 524288)
			hba_map0_area_size = 524288;
	}
#endif

	base_addr_virt = ioremap(base_addr0_phys,hba_map0_area_size);
	if (!base_addr_virt) {
		pci_release_regions(pDev);
		PERROR(""dpti: adpt_config_hba: io remap failed\n"");
		return -EINVAL;
	}

        if(raptorFlag == TRUE) {
		msg_addr_virt = ioremap(base_addr1_phys, hba_map1_area_size );
		if (!msg_addr_virt) {
			PERROR(""dpti: adpt_config_hba: io remap failed on BAR1\n"");
			iounmap(base_addr_virt);
			pci_release_regions(pDev);
			return -EINVAL;
		}
	} else {
		msg_addr_virt = base_addr_virt;
	}

	// Allocate and zero the data structure
	pHba = kzalloc(sizeof(adpt_hba), GFP_KERNEL);
	if (!pHba) {
		if (msg_addr_virt != base_addr_virt)
			iounmap(msg_addr_virt);
		iounmap(base_addr_virt);
		pci_release_regions(pDev);
		return -ENOMEM;
	}

	mutex_lock(&adpt_configuration_lock);

	if(hba_chain != NULL){
		for(p = hba_chain; p->next; p = p->next);
		p->next = pHba;
	} else {
		hba_chain = pHba;
	}
	pHba->next = NULL;
	pHba->unit = hba_count;
	sprintf(pHba->name, ""dpti%d"", hba_count);
	hba_count++;

	mutex_unlock(&adpt_configuration_lock);

	pHba->pDev = pDev;
	pHba->base_addr_phys = base_addr0_phys;

	// Set up the Virtual Base Address of the I2O Device
	pHba->base_addr_virt = base_addr_virt;
	pHba->msg_addr_virt = msg_addr_virt;
	pHba->irq_mask = base_addr_virt+0x30;
	pHba->post_port = base_addr_virt+0x40;
	pHba->reply_port = base_addr_virt+0x44;

	pHba->hrt = NULL;
	pHba->lct = NULL;
	pHba->lct_size = 0;
	pHba->status_block = NULL;
	pHba->post_count = 0;
	pHba->state = DPTI_STATE_RESET;
	pHba->pDev = pDev;
	pHba->devices = NULL;
	pHba->dma64 = dma64;

	// Initializing the spinlocks
	spin_lock_init(&pHba->state_lock);

	if(raptorFlag == 0){
		printk(KERN_INFO ""Adaptec I2O RAID controller""
				 "" %d at %p size=%x irq=%d%s\n"",
			hba_count-1, base_addr_virt,
			hba_map0_area_size, pDev->irq,
			dma64 ? "" (64-bit DMA)"" : """");
	} else {
		printk(KERN_INFO""Adaptec I2O RAID controller %d irq=%d%s\n"",
			hba_count-1, pDev->irq,
			dma64 ? "" (64-bit DMA)"" : """");
		printk(KERN_INFO""     BAR0 %p - size= %x\n"",base_addr_virt,hba_map0_area_size);
		printk(KERN_INFO""     BAR1 %p - size= %x\n"",msg_addr_virt,hba_map1_area_size);
	}

	if (request_irq (pDev->irq, adpt_isr, IRQF_SHARED, pHba->name, pHba)) {
		printk(KERN_ERR""%s: Couldn't register IRQ %d\n"", pHba->name, pDev->irq);
		adpt_i2o_delete_hba(pHba);
		return -EINVAL;
	}

	return 0;
}


static void adpt_i2o_delete_hba(adpt_hba* pHba)
{
	adpt_hba* p1;
	adpt_hba* p2;
	struct i2o_device* d;
	struct i2o_device* next;
	int i;
	int j;
	struct adpt_device* pDev;
	struct adpt_device* pNext;


	mutex_lock(&adpt_configuration_lock);
	if(pHba->host){
		free_irq(pHba->host->irq, pHba);
	}
	p2 = NULL;
	for( p1 = hba_chain; p1; p2 = p1,p1=p1->next){
		if(p1 == pHba) {
			if(p2) {
				p2->next = p1->next;
			} else {
				hba_chain = p1->next;
			}
			break;
		}
	}

	hba_count--;
	mutex_unlock(&adpt_configuration_lock);

	iounmap(pHba->base_addr_virt);
	pci_release_regions(pHba->pDev);
	if(pHba->msg_addr_virt != pHba->base_addr_virt){
		iounmap(pHba->msg_addr_virt);
	}
	if(pHba->FwDebugBuffer_P)
	   	iounmap(pHba->FwDebugBuffer_P);
	if(pHba->hrt) {
		dma_free_coherent(&pHba->pDev->dev,
			pHba->hrt->num_entries * pHba->hrt->entry_len << 2,
			pHba->hrt, pHba->hrt_pa);
	}
	if(pHba->lct) {
		dma_free_coherent(&pHba->pDev->dev, pHba->lct_size,
			pHba->lct, pHba->lct_pa);
	}
	if(pHba->status_block) {
		dma_free_coherent(&pHba->pDev->dev, sizeof(i2o_status_block),
			pHba->status_block, pHba->status_block_pa);
	}
	if(pHba->reply_pool) {
		dma_free_coherent(&pHba->pDev->dev,
			pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4,
			pHba->reply_pool, pHba->reply_pool_pa);
	}

	for(d = pHba->devices; d ; d = next){
		next = d->next;
		kfree(d);
	}
	for(i = 0 ; i < pHba->top_scsi_channel ; i++){
		for(j = 0; j < MAX_ID; j++){
			if(pHba->channel[i].device[j] != NULL){
				for(pDev = pHba->channel[i].device[j]; pDev; pDev = pNext){
					pNext = pDev->next_lun;
					kfree(pDev);
				}
			}
		}
	}
	pci_dev_put(pHba->pDev);
	if (adpt_sysfs_class)
		device_destroy(adpt_sysfs_class,
				MKDEV(DPTI_I2O_MAJOR, pHba->unit));
	kfree(pHba);

	if(hba_count <= 0){
		unregister_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER);
		if (adpt_sysfs_class) {
			class_destroy(adpt_sysfs_class);
			adpt_sysfs_class = NULL;
		}
	}
}

static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u64 lun)
{
	struct adpt_device* d;

	if (chan >= MAX_CHANNEL)
		return NULL;

	d = pHba->channel[chan].device[id];
	if(!d || d->tid == 0) {
		return NULL;
	}

	/* If it is the only lun at that address then this should match*/
	if(d->scsi_lun == lun){
		return d;
	}

	/* else we need to look through all the luns */
	for(d=d->next_lun ; d ; d = d->next_lun){
		if(d->scsi_lun == lun){
			return d;
		}
	}
	return NULL;
}


static int adpt_i2o_post_wait(adpt_hba* pHba, u32* msg, int len, int timeout)
{
	// I used my own version of the WAIT_QUEUE_HEAD
	// to handle some version differences
	// When embedded in the kernel this could go back to the vanilla one
	ADPT_DECLARE_WAIT_QUEUE_HEAD(adpt_wq_i2o_post);
	int status = 0;
	ulong flags = 0;
	struct adpt_i2o_post_wait_data *p1, *p2;
	struct adpt_i2o_post_wait_data *wait_data =
		kmalloc(sizeof(struct adpt_i2o_post_wait_data), GFP_ATOMIC);
	DECLARE_WAITQUEUE(wait, current);

	if (!wait_data)
		return -ENOMEM;

	/*
	 * The spin locking is needed to keep anyone from playing
	 * with the queue pointers and id while we do the same
	 */
	spin_lock_irqsave(&adpt_post_wait_lock, flags);
       // TODO we need a MORE unique way of getting ids
       // to support async LCT get
	wait_data->next = adpt_post_wait_queue;
	adpt_post_wait_queue = wait_data;
	adpt_post_wait_id++;
	adpt_post_wait_id &= 0x7fff;
	wait_data->id =  adpt_post_wait_id;
	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);

	wait_data->wq = &adpt_wq_i2o_post;
	wait_data->status = -ETIMEDOUT;

	add_wait_queue(&adpt_wq_i2o_post, &wait);

	msg[2] |= 0x80000000 | ((u32)wait_data->id);
	timeout *= HZ;
	if((status = adpt_i2o_post_this(pHba, msg, len)) == 0){
		set_current_state(TASK_INTERRUPTIBLE);
		if(pHba->host)
			spin_unlock_irq(pHba->host->host_lock);
		if (!timeout)
			schedule();
		else{
			timeout = schedule_timeout(timeout);
			if (timeout == 0) {
				// I/O issued, but cannot get result in
				// specified time. Freeing resorces is
				// dangerous.
				status = -ETIME;
			}
		}
		if(pHba->host)
			spin_lock_irq(pHba->host->host_lock);
	}
	remove_wait_queue(&adpt_wq_i2o_post, &wait);

	if(status == -ETIMEDOUT){
		printk(KERN_INFO""dpti%d: POST WAIT TIMEOUT\n"",pHba->unit);
		// We will have to free the wait_data memory during shutdown
		return status;
	}

	/* Remove the entry from the queue.  */
	p2 = NULL;
	spin_lock_irqsave(&adpt_post_wait_lock, flags);
	for(p1 = adpt_post_wait_queue; p1; p2 = p1, p1 = p1->next) {
		if(p1 == wait_data) {
			if(p1->status == I2O_DETAIL_STATUS_UNSUPPORTED_FUNCTION ) {
				status = -EOPNOTSUPP;
			}
			if(p2) {
				p2->next = p1->next;
			} else {
				adpt_post_wait_queue = p1->next;
			}
			break;
		}
	}
	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);

	kfree(wait_data);

	return status;
}


static s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)
{

	u32 m = EMPTY_QUEUE;
	u32 __iomem *msg;
	ulong timeout = jiffies + 30*HZ;
	do {
		rmb();
		m = readl(pHba->post_port);
		if (m != EMPTY_QUEUE) {
			break;
		}
		if(time_after(jiffies,timeout)){
			printk(KERN_WARNING""dpti%d: Timeout waiting for message frame!\n"", pHba->unit);
			return -ETIMEDOUT;
		}
		schedule_timeout_uninterruptible(1);
	} while(m == EMPTY_QUEUE);

	msg = pHba->msg_addr_virt + m;
	memcpy_toio(msg, data, len);
	wmb();

	//post message
	writel(m, pHba->post_port);
	wmb();

	return 0;
}


static void adpt_i2o_post_wait_complete(u32 context, int status)
{
	struct adpt_i2o_post_wait_data *p1 = NULL;
	/*
	 * We need to search through the adpt_post_wait
	 * queue to see if the given message is still
	 * outstanding.  If not, it means that the IOP
	 * took longer to respond to the message than we
	 * had allowed and timer has already expired.
	 * Not much we can do about that except log
	 * it for debug purposes, increase timeout, and recompile
	 *
	 * Lock needed to keep anyone from moving queue pointers
	 * around while we're looking through them.
	 */

	context &= 0x7fff;

	spin_lock(&adpt_post_wait_lock);
	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
		if(p1->id == context) {
			p1->status = status;
			spin_unlock(&adpt_post_wait_lock);
			wake_up_interruptible(p1->wq);
			return;
		}
	}
	spin_unlock(&adpt_post_wait_lock);
        // If this happens we lose commands that probably really completed
	printk(KERN_DEBUG""dpti: Could Not find task %d in wait queue\n"",context);
	printk(KERN_DEBUG""      Tasks in wait queue:\n"");
	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
		printk(KERN_DEBUG""           %d\n"",p1->id);
	}
	return;
}

static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
{
	u32 msg[8];
	u8* status;
	dma_addr_t addr;
	u32 m = EMPTY_QUEUE ;
	ulong timeout = jiffies + (TMOUT_IOPRESET*HZ);

	if(pHba->initialized  == FALSE) {	// First time reset should be quick
		timeout = jiffies + (25*HZ);
	} else {
		adpt_i2o_quiesce_hba(pHba);
	}

	do {
		rmb();
		m = readl(pHba->post_port);
		if (m != EMPTY_QUEUE) {
			break;
		}
		if(time_after(jiffies,timeout)){
			printk(KERN_WARNING""Timeout waiting for message!\n"");
			return -ETIMEDOUT;
		}
		schedule_timeout_uninterruptible(1);
	} while (m == EMPTY_QUEUE);

	status = dma_alloc_coherent(&pHba->pDev->dev, 4, &addr, GFP_KERNEL);
	if(status == NULL) {
		adpt_send_nop(pHba, m);
		printk(KERN_ERR""IOP reset failed - no free memory.\n"");
		return -ENOMEM;
	}

	msg[0]=EIGHT_WORD_MSG_SIZE|SGL_OFFSET_0;
	msg[1]=I2O_CMD_ADAPTER_RESET<<24|HOST_TID<<12|ADAPTER_TID;
	msg[2]=0;
	msg[3]=0;
	msg[4]=0;
	msg[5]=0;
	msg[6]=dma_low(addr);
	msg[7]=dma_high(addr);

	memcpy_toio(pHba->msg_addr_virt+m, msg, sizeof(msg));
	wmb();
	writel(m, pHba->post_port);
	wmb();

	while(*status == 0){
		if(time_after(jiffies,timeout)){
			printk(KERN_WARNING""%s: IOP Reset Timeout\n"",pHba->name);
			/* We lose 4 bytes of ""status"" here, but we cannot
			   free these because controller may awake and corrupt
			   those bytes at any time */
			/* dma_free_coherent(&pHba->pDev->dev, 4, buf, addr); */
			return -ETIMEDOUT;
		}
		rmb();
		schedule_timeout_uninterruptible(1);
	}

	if(*status == 0x01 /*I2O_EXEC_IOP_RESET_IN_PROGRESS*/) {
		PDEBUG(""%s: Reset in progress...\n"", pHba->name);
		// Here we wait for message frame to become available
		// indicated that reset has finished
		do {
			rmb();
			m = readl(pHba->post_port);
			if (m != EMPTY_QUEUE) {
				break;
			}
			if(time_after(jiffies,timeout)){
				printk(KERN_ERR ""%s:Timeout waiting for IOP Reset.\n"",pHba->name);
				/* We lose 4 bytes of ""status"" here, but we
				   cannot free these because controller may
				   awake and corrupt those bytes at any time */
				/* dma_free_coherent(&pHba->pDev->dev, 4, buf, addr); */
				return -ETIMEDOUT;
			}
			schedule_timeout_uninterruptible(1);
		} while (m == EMPTY_QUEUE);
		// Flush the offset
		adpt_send_nop(pHba, m);
	}
	adpt_i2o_status_get(pHba);
	if(*status == 0x02 ||
			pHba->status_block->iop_state != ADAPTER_STATE_RESET) {
		printk(KERN_WARNING""%s: Reset reject, trying to clear\n"",
				pHba->name);
	} else {
		PDEBUG(""%s: Reset completed.\n"", pHba->name);
	}

	dma_free_coherent(&pHba->pDev->dev, 4, status, addr);
#ifdef UARTDELAY
	// This delay is to allow someone attached to the card through the debug UART to
	// set up the dump levels that they want before the rest of the initialization sequence
	adpt_delay(20000);
#endif
	return 0;
}


static int adpt_i2o_parse_lct(adpt_hba* pHba)
{
	int i;
	int max;
	int tid;
	struct i2o_device *d;
	i2o_lct *lct = pHba->lct;
	u8 bus_no = 0;
	s16 scsi_id;
	u64 scsi_lun;
	u32 buf[10]; // larger than 7, or 8 ...
	struct adpt_device* pDev;

	if (lct == NULL) {
		printk(KERN_ERR ""%s: LCT is empty???\n"",pHba->name);
		return -1;
	}

	max = lct->table_size;
	max -= 3;
	max /= 9;

	for(i=0;i<max;i++) {
		if( lct->lct_entry[i].user_tid != 0xfff){
			/*
			 * If we have hidden devices, we need to inform the upper layers about
			 * the possible maximum id reference to handle device access when
			 * an array is disassembled. This code has no other purpose but to
			 * allow us future access to devices that are currently hidden
			 * behind arrays, hotspares or have not been configured (JBOD mode).
			 */
			if( lct->lct_entry[i].class_id != I2O_CLASS_RANDOM_BLOCK_STORAGE &&
			    lct->lct_entry[i].class_id != I2O_CLASS_SCSI_PERIPHERAL &&
			    lct->lct_entry[i].class_id != I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
			    	continue;
			}
			tid = lct->lct_entry[i].tid;
			// I2O_DPT_DEVICE_INFO_GROUP_NO;
			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {
				continue;
			}
			bus_no = buf[0]>>16;
			scsi_id = buf[1];
			scsi_lun = scsilun_to_int((struct scsi_lun *)&buf[2]);
			if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
				printk(KERN_WARNING""%s: Channel number %d out of range \n"", pHba->name, bus_no);
				continue;
			}
			if (scsi_id >= MAX_ID){
				printk(KERN_WARNING""%s: SCSI ID %d out of range \n"", pHba->name, bus_no);
				continue;
			}
			if(bus_no > pHba->top_scsi_channel){
				pHba->top_scsi_channel = bus_no;
			}
			if(scsi_id > pHba->top_scsi_id){
				pHba->top_scsi_id = scsi_id;
			}
			if(scsi_lun > pHba->top_scsi_lun){
				pHba->top_scsi_lun = scsi_lun;
			}
			continue;
		}
		d = kmalloc(sizeof(struct i2o_device), GFP_KERNEL);
		if(d==NULL)
		{
			printk(KERN_CRIT""%s: Out of memory for I2O device data.\n"",pHba->name);
			return -ENOMEM;
		}

		d->controller = pHba;
		d->next = NULL;

		memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));

		d->flags = 0;
		tid = d->lct_data.tid;
		adpt_i2o_report_hba_unit(pHba, d);
		adpt_i2o_install_device(pHba, d);
	}
	bus_no = 0;
	for(d = pHba->devices; d ; d = d->next) {
		if(d->lct_data.class_id  == I2O_CLASS_BUS_ADAPTER_PORT ||
		   d->lct_data.class_id  == I2O_CLASS_FIBRE_CHANNEL_PORT){
			tid = d->lct_data.tid;
			// TODO get the bus_no from hrt-but for now they are in order
			//bus_no =
			if(bus_no > pHba->top_scsi_channel){
				pHba->top_scsi_channel = bus_no;
			}
			pHba->channel[bus_no].type = d->lct_data.class_id;
			pHba->channel[bus_no].tid = tid;
			if(adpt_i2o_query_scalar(pHba, tid, 0x0200, -1, buf, 28)>=0)
			{
				pHba->channel[bus_no].scsi_id = buf[1];
				PDEBUG(""Bus %d - SCSI ID %d.\n"", bus_no, buf[1]);
			}
			// TODO remove - this is just until we get from hrt
			bus_no++;
			if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
				printk(KERN_WARNING""%s: Channel number %d out of range - LCT\n"", pHba->name, bus_no);
				break;
			}
		}
	}

	// Setup adpt_device table
	for(d = pHba->devices; d ; d = d->next) {
		if(d->lct_data.class_id  == I2O_CLASS_RANDOM_BLOCK_STORAGE ||
		   d->lct_data.class_id  == I2O_CLASS_SCSI_PERIPHERAL ||
		   d->lct_data.class_id  == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){

			tid = d->lct_data.tid;
			scsi_id = -1;
			// I2O_DPT_DEVICE_INFO_GROUP_NO;
			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)>=0) {
				bus_no = buf[0]>>16;
				scsi_id = buf[1];
				scsi_lun = scsilun_to_int((struct scsi_lun *)&buf[2]);
				if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
					continue;
				}
				if (scsi_id >= MAX_ID) {
					continue;
				}
				if( pHba->channel[bus_no].device[scsi_id] == NULL){
					pDev =  kzalloc(sizeof(struct adpt_device),GFP_KERNEL);
					if(pDev == NULL) {
						return -ENOMEM;
					}
					pHba->channel[bus_no].device[scsi_id] = pDev;
				} else {
					for( pDev = pHba->channel[bus_no].device[scsi_id];
							pDev->next_lun; pDev = pDev->next_lun){
					}
					pDev->next_lun = kzalloc(sizeof(struct adpt_device),GFP_KERNEL);
					if(pDev->next_lun == NULL) {
						return -ENOMEM;
					}
					pDev = pDev->next_lun;
				}
				pDev->tid = tid;
				pDev->scsi_channel = bus_no;
				pDev->scsi_id = scsi_id;
				pDev->scsi_lun = scsi_lun;
				pDev->pI2o_dev = d;
				d->owner = pDev;
				pDev->type = (buf[0])&0xff;
				pDev->flags = (buf[0]>>8)&0xff;
				if(scsi_id > pHba->top_scsi_id){
					pHba->top_scsi_id = scsi_id;
				}
				if(scsi_lun > pHba->top_scsi_lun){
					pHba->top_scsi_lun = scsi_lun;
				}
			}
			if(scsi_id == -1){
				printk(KERN_WARNING""Could not find SCSI ID for %s\n"",
						d->lct_data.identity_tag);
			}
		}
	}
	return 0;
}


/*
 *	Each I2O controller has a chain of devices on it - these match
 *	the useful parts of the LCT of the board.
 */

static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)
{
	mutex_lock(&adpt_configuration_lock);
	d->controller=pHba;
	d->owner=NULL;
	d->next=pHba->devices;
	d->prev=NULL;
	if (pHba->devices != NULL){
		pHba->devices->prev=d;
	}
	pHba->devices=d;
	*d->dev_name = 0;

	mutex_unlock(&adpt_configuration_lock);
	return 0;
}

static int adpt_open(struct inode *inode, struct file *file)
{
	int minor;
	adpt_hba* pHba;

	mutex_lock(&adpt_mutex);
	//TODO check for root access
	//
	minor = iminor(inode);
	if (minor >= hba_count) {
		mutex_unlock(&adpt_mutex);
		return -ENXIO;
	}
	mutex_lock(&adpt_configuration_lock);
	for (pHba = hba_chain; pHba; pHba = pHba->next) {
		if (pHba->unit == minor) {
			break;	/* found adapter */
		}
	}
	if (pHba == NULL) {
		mutex_unlock(&adpt_configuration_lock);
		mutex_unlock(&adpt_mutex);
		return -ENXIO;
	}

//	if(pHba->in_use){
	//	mutex_unlock(&adpt_configuration_lock);
//		return -EBUSY;
//	}

	pHba->in_use = 1;
	mutex_unlock(&adpt_configuration_lock);
	mutex_unlock(&adpt_mutex);

	return 0;
}

static int adpt_close(struct inode *inode, struct file *file)
{
	int minor;
	adpt_hba* pHba;

	minor = iminor(inode);
	if (minor >= hba_count) {
		return -ENXIO;
	}
	mutex_lock(&adpt_configuration_lock);
	for (pHba = hba_chain; pHba; pHba = pHba->next) {
		if (pHba->unit == minor) {
			break;	/* found adapter */
		}
	}
	mutex_unlock(&adpt_configuration_lock);
	if (pHba == NULL) {
		return -ENXIO;
	}

	pHba->in_use = 0;

	return 0;
}


static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
{
	u32 msg[MAX_MESSAGE_SIZE];
	u32* reply = NULL;
	u32 size = 0;
	u32 reply_size = 0;
	u32 __user *user_msg = arg;
	u32 __user * user_reply = NULL;
	void **sg_list = NULL;
	u32 sg_offset = 0;
	u32 sg_count = 0;
	int sg_index = 0;
	u32 i = 0;
	u32 rcode = 0;
	void *p = NULL;
	dma_addr_t addr;
	ulong flags = 0;

	memset(&msg, 0, MAX_MESSAGE_SIZE*4);
	// get user msg size in u32s
	if(get_user(size, &user_msg[0])){
		return -EFAULT;
	}
	size = size>>16;

	user_reply = &user_msg[size];
	if(size > MAX_MESSAGE_SIZE){
		return -EFAULT;
	}
	size *= 4; // Convert to bytes

	/* Copy in the user's I2O command */
	if(copy_from_user(msg, user_msg, size)) {
		return -EFAULT;
	}
	get_user(reply_size, &user_reply[0]);
	reply_size = reply_size>>16;
	if(reply_size > REPLY_FRAME_SIZE){
		reply_size = REPLY_FRAME_SIZE;
	}
	reply_size *= 4;
	reply = kzalloc(REPLY_FRAME_SIZE*4, GFP_KERNEL);
	if(reply == NULL) {
		printk(KERN_WARNING""%s: Could not allocate reply buffer\n"",pHba->name);
		return -ENOMEM;
	}
	sg_offset = (msg[0]>>4)&0xf;
	msg[2] = 0x40000000; // IOCTL context
	msg[3] = adpt_ioctl_to_context(pHba, reply);
	if (msg[3] == (u32)-1) {
		rcode = -EBUSY;
		goto free;
	}

	sg_list = kcalloc(pHba->sg_tablesize, sizeof(*sg_list), GFP_KERNEL);
	if (!sg_list) {
		rcode = -ENOMEM;
		goto free;
	}
	if(sg_offset) {
		// TODO add 64 bit API
		struct sg_simple_element *sg =  (struct sg_simple_element*) (msg+sg_offset);
		sg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);
		if (sg_count > pHba->sg_tablesize){
			printk(KERN_DEBUG""%s:IOCTL SG List too large (%u)\n"", pHba->name,sg_count);
			rcode = -EINVAL;
			goto free;
		}

		for(i = 0; i < sg_count; i++) {
			int sg_size;

			if (!(sg[i].flag_count & 0x10000000 /*I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT*/)) {
				printk(KERN_DEBUG""%s:Bad SG element %d - not simple (%x)\n"",pHba->name,i,  sg[i].flag_count);
				rcode = -EINVAL;
				goto cleanup;
			}
			sg_size = sg[i].flag_count & 0xffffff;
			/* Allocate memory for the transfer */
			p = dma_alloc_coherent(&pHba->pDev->dev, sg_size, &addr, GFP_KERNEL);
			if(!p) {
				printk(KERN_DEBUG""%s: Could not allocate SG buffer - size = %d buffer number %d of %d\n"",
						pHba->name,sg_size,i,sg_count);
				rcode = -ENOMEM;
				goto cleanup;
			}
			sg_list[sg_index++] = p; // sglist indexed with input frame, not our internal frame.
			/* Copy in the user's SG buffer if necessary */
			if(sg[i].flag_count & 0x04000000 /*I2O_SGL_FLAGS_DIR*/) {
				// sg_simple_element API is 32 bit
				if (copy_from_user(p,(void __user *)(ulong)sg[i].addr_bus, sg_size)) {
					printk(KERN_DEBUG""%s: Could not copy SG buf %d FROM user\n"",pHba->name,i);
					rcode = -EFAULT;
					goto cleanup;
				}
			}
			/* sg_simple_element API is 32 bit, but addr < 4GB */
			sg[i].addr_bus = addr;
		}
	}

	do {
		/*
		 * Stop any new commands from enterring the
		 * controller while processing the ioctl
		 */
		if (pHba->host) {
			scsi_block_requests(pHba->host);
			spin_lock_irqsave(pHba->host->host_lock, flags);
		}
		rcode = adpt_i2o_post_wait(pHba, msg, size, FOREVER);
		if (rcode != 0)
			printk(""adpt_i2o_passthru: post wait failed %d %p\n"",
					rcode, reply);
		if (pHba->host) {
			spin_unlock_irqrestore(pHba->host->host_lock, flags);
			scsi_unblock_requests(pHba->host);
		}
	} while (rcode == -ETIMEDOUT);

	if(rcode){
		goto cleanup;
	}

	if(sg_offset) {
	/* Copy back the Scatter Gather buffers back to user space */
		u32 j;
		// TODO add 64 bit API
		struct sg_simple_element* sg;
		int sg_size;

		// re-acquire the original message to handle correctly the sg copy operation
		memset(&msg, 0, MAX_MESSAGE_SIZE*4);
		// get user msg size in u32s
		if(get_user(size, &user_msg[0])){
			rcode = -EFAULT;
			goto cleanup;
		}
		size = size>>16;
		size *= 4;
		if (size > MAX_MESSAGE_SIZE) {
			rcode = -EINVAL;
			goto cleanup;
		}
		/* Copy in the user's I2O command */
		if (copy_from_user (msg, user_msg, size)) {
			rcode = -EFAULT;
			goto cleanup;
		}
		sg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);

		// TODO add 64 bit API
		sg 	 = (struct sg_simple_element*)(msg + sg_offset);
		for (j = 0; j < sg_count; j++) {
			/* Copy out the SG list to user's buffer if necessary */
			if(! (sg[j].flag_count & 0x4000000 /*I2O_SGL_FLAGS_DIR*/)) {
				sg_size = sg[j].flag_count & 0xffffff;
				// sg_simple_element API is 32 bit
				if (copy_to_user((void __user *)(ulong)sg[j].addr_bus,sg_list[j], sg_size)) {
					printk(KERN_WARNING""%s: Could not copy %p TO user %x\n"",pHba->name, sg_list[j], sg[j].addr_bus);
					rcode = -EFAULT;
					goto cleanup;
				}
			}
		}
	}

	/* Copy back the reply to user space */
	if (reply_size) {
		// we wrote our own values for context - now restore the user supplied ones
		if(copy_from_user(reply+2, user_msg+2, sizeof(u32)*2)) {
			printk(KERN_WARNING""%s: Could not copy message context FROM user\n"",pHba->name);
			rcode = -EFAULT;
		}
		if(copy_to_user(user_reply, reply, reply_size)) {
			printk(KERN_WARNING""%s: Could not copy reply TO user\n"",pHba->name);
			rcode = -EFAULT;
		}
	}


cleanup:
	if (rcode != -ETIME && rcode != -EINTR) {
		struct sg_simple_element *sg =
				(struct sg_simple_element*) (msg +sg_offset);
		while(sg_index) {
			if(sg_list[--sg_index]) {
				dma_free_coherent(&pHba->pDev->dev,
					sg[sg_index].flag_count & 0xffffff,
					sg_list[sg_index],
					sg[sg_index].addr_bus);
			}
		}
	}

free:
	kfree(sg_list);
	kfree(reply);
	return rcode;
}

#if defined __ia64__
static void adpt_ia64_info(sysInfo_S* si)
{
	// This is all the info we need for now
	// We will add more info as our new
	// managmenent utility requires it
	si->processorType = PROC_IA64;
}
#endif

#if defined __sparc__
static void adpt_sparc_info(sysInfo_S* si)
{
	// This is all the info we need for now
	// We will add more info as our new
	// managmenent utility requires it
	si->processorType = PROC_ULTRASPARC;
}
#endif
#if defined __alpha__
static void adpt_alpha_info(sysInfo_S* si)
{
	// This is all the info we need for now
	// We will add more info as our new
	// managmenent utility requires it
	si->processorType = PROC_ALPHA;
}
#endif

#if defined __i386__

#include <uapi/asm/vm86.h>

static void adpt_i386_info(sysInfo_S* si)
{
	// This is all the info we need for now
	// We will add more info as our new
	// managmenent utility requires it
	switch (boot_cpu_data.x86) {
	case CPU_386:
		si->processorType = PROC_386;
		break;
	case CPU_486:
		si->processorType = PROC_486;
		break;
	case CPU_586:
		si->processorType = PROC_PENTIUM;
		break;
	default:  // Just in case
		si->processorType = PROC_PENTIUM;
		break;
	}
}
#endif

/*
 * This routine returns information about the system.  This does not effect
 * any logic and if the info is wrong - it doesn't matter.
 */

/* Get all the info we can not get from kernel services */
static int adpt_system_info(void __user *buffer)
{
	sysInfo_S si;

	memset(&si, 0, sizeof(si));

	si.osType = OS_LINUX;
	si.osMajorVersion = 0;
	si.osMinorVersion = 0;
	si.osRevision = 0;
	si.busType = SI_PCI_BUS;
	si.processorFamily = DPTI_sig.dsProcessorFamily;

#if defined __i386__
	adpt_i386_info(&si);
#elif defined (__ia64__)
	adpt_ia64_info(&si);
#elif defined(__sparc__)
	adpt_sparc_info(&si);
#elif defined (__alpha__)
	adpt_alpha_info(&si);
#else
	si.processorType = 0xff ;
#endif
	if (copy_to_user(buffer, &si, sizeof(si))){
		printk(KERN_WARNING""dpti: Could not copy buffer TO user\n"");
		return -EFAULT;
	}

	return 0;
}

static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)
{
	int minor;
	int error = 0;
	adpt_hba* pHba;
	ulong flags = 0;
	void __user *argp = (void __user *)arg;

	minor = iminor(inode);
	if (minor >= DPTI_MAX_HBA){
		return -ENXIO;
	}
	mutex_lock(&adpt_configuration_lock);
	for (pHba = hba_chain; pHba; pHba = pHba->next) {
		if (pHba->unit == minor) {
			break;	/* found adapter */
		}
	}
	mutex_unlock(&adpt_configuration_lock);
	if(pHba == NULL){
		return -ENXIO;
	}

	while((volatile u32) pHba->state & DPTI_STATE_RESET )
		schedule_timeout_uninterruptible(2);

	switch (cmd) {
	// TODO: handle 3 cases
	case DPT_SIGNATURE:
		if (copy_to_user(argp, &DPTI_sig, sizeof(DPTI_sig))) {
			return -EFAULT;
		}
		break;
	case I2OUSRCMD:
		return adpt_i2o_passthru(pHba, argp);

	case DPT_CTRLINFO:{
		drvrHBAinfo_S HbaInfo;

#define FLG_OSD_PCI_VALID 0x0001
#define FLG_OSD_DMA	  0x0002
#define FLG_OSD_I2O	  0x0004
		memset(&HbaInfo, 0, sizeof(HbaInfo));
		HbaInfo.drvrHBAnum = pHba->unit;
		HbaInfo.baseAddr = (ulong) pHba->base_addr_phys;
		HbaInfo.blinkState = adpt_read_blink_led(pHba);
		HbaInfo.pciBusNum =  pHba->pDev->bus->number;
		HbaInfo.pciDeviceNum=PCI_SLOT(pHba->pDev->devfn);
		HbaInfo.Interrupt = pHba->pDev->irq;
		HbaInfo.hbaFlags = FLG_OSD_PCI_VALID | FLG_OSD_DMA | FLG_OSD_I2O;
		if(copy_to_user(argp, &HbaInfo, sizeof(HbaInfo))){
			printk(KERN_WARNING""%s: Could not copy HbaInfo TO user\n"",pHba->name);
			return -EFAULT;
		}
		break;
		}
	case DPT_SYSINFO:
		return adpt_system_info(argp);
	case DPT_BLINKLED:{
		u32 value;
		value = (u32)adpt_read_blink_led(pHba);
		if (copy_to_user(argp, &value, sizeof(value))) {
			return -EFAULT;
		}
		break;
		}
	case I2ORESETCMD: {
		struct Scsi_Host *shost = pHba->host;

		if (shost)
			spin_lock_irqsave(shost->host_lock, flags);
		adpt_hba_reset(pHba);
		if (shost)
			spin_unlock_irqrestore(shost->host_lock, flags);
		break;
	}
	case I2ORESCANCMD:
		adpt_rescan(pHba);
		break;
	default:
		return -EINVAL;
	}

	return error;
}

static long adpt_unlocked_ioctl(struct file *file, uint cmd, ulong arg)
{
	struct inode *inode;
	long ret;

	inode = file_inode(file);

	mutex_lock(&adpt_mutex);
	ret = adpt_ioctl(inode, file, cmd, arg);
	mutex_unlock(&adpt_mutex);

	return ret;
}

#ifdef CONFIG_COMPAT
static long compat_adpt_ioctl(struct file *file,
				unsigned int cmd, unsigned long arg)
{
	struct inode *inode;
	long ret;

	inode = file_inode(file);

	mutex_lock(&adpt_mutex);

	switch(cmd) {
		case DPT_SIGNATURE:
		case I2OUSRCMD:
		case DPT_CTRLINFO:
		case DPT_SYSINFO:
		case DPT_BLINKLED:
		case I2ORESETCMD:
		case I2ORESCANCMD:
		case (DPT_TARGET_BUSY & 0xFFFF):
		case DPT_TARGET_BUSY:
			ret = adpt_ioctl(inode, file, cmd, arg);
			break;
		default:
			ret =  -ENOIOCTLCMD;
	}

	mutex_unlock(&adpt_mutex);

	return ret;
}
#endif

static irqreturn_t adpt_isr(int irq, void *dev_id)
{
	struct scsi_cmnd* cmd;
	adpt_hba* pHba = dev_id;
	u32 m;
	void __iomem *reply;
	u32 status=0;
	u32 context;
	ulong flags = 0;
	int handled = 0;

	if (pHba == NULL){
		printk(KERN_WARNING""adpt_isr: NULL dev_id\n"");
		return IRQ_NONE;
	}
	if(pHba->host)
		spin_lock_irqsave(pHba->host->host_lock, flags);

	while( readl(pHba->irq_mask) & I2O_INTERRUPT_PENDING_B) {
		m = readl(pHba->reply_port);
		if(m == EMPTY_QUEUE){
			// Try twice then give up
			rmb();
			m = readl(pHba->reply_port);
			if(m == EMPTY_QUEUE){
				// This really should not happen
				printk(KERN_ERR""dpti: Could not get reply frame\n"");
				goto out;
			}
		}
		if (pHba->reply_pool_pa <= m &&
		    m < pHba->reply_pool_pa +
			(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4)) {
			reply = (u8 *)pHba->reply_pool +
						(m - pHba->reply_pool_pa);
		} else {
			/* Ick, we should *never* be here */
			printk(KERN_ERR ""dpti: reply frame not from pool\n"");
			reply = (u8 *)bus_to_virt(m);
		}

		if (readl(reply) & MSG_FAIL) {
			u32 old_m = readl(reply+28);
			void __iomem *msg;
			u32 old_context;
			PDEBUG(""%s: Failed message\n"",pHba->name);
			if(old_m >= 0x100000){
				printk(KERN_ERR""%s: Bad preserved MFA (%x)- dropping frame\n"",pHba->name,old_m);
				writel(m,pHba->reply_port);
				continue;
			}
			// Transaction context is 0 in failed reply frame
			msg = pHba->msg_addr_virt + old_m;
			old_context = readl(msg+12);
			writel(old_context, reply+12);
			adpt_send_nop(pHba, old_m);
		}
		context = readl(reply+8);
		if(context & 0x40000000){ // IOCTL
			void *p = adpt_ioctl_from_context(pHba, readl(reply+12));
			if( p != NULL) {
				memcpy_fromio(p, reply, REPLY_FRAME_SIZE * 4);
			}
			// All IOCTLs will also be post wait
		}
		if(context & 0x80000000){ // Post wait message
			status = readl(reply+16);
			if(status  >> 24){
				status &=  0xffff; /* Get detail status */
			} else {
				status = I2O_POST_WAIT_OK;
			}
			if(!(context & 0x40000000)) {
				/*
				 * The request tag is one less than the command tag
				 * as the firmware might treat a 0 tag as invalid
				 */
				cmd = scsi_host_find_tag(pHba->host,
							 readl(reply + 12) - 1);
				if(cmd != NULL) {
					printk(KERN_WARNING""%s: Apparent SCSI cmd in Post Wait Context - cmd=%p context=%x\n"", pHba->name, cmd, context);
				}
			}
			adpt_i2o_post_wait_complete(context, status);
		} else { // SCSI message
			/*
			 * The request tag is one less than the command tag
			 * as the firmware might treat a 0 tag as invalid
			 */
			cmd = scsi_host_find_tag(pHba->host,
						 readl(reply + 12) - 1);
			if(cmd != NULL){
				scsi_dma_unmap(cmd);
				adpt_i2o_scsi_complete(reply, cmd);
			}
		}
		writel(m, pHba->reply_port);
		wmb();
		rmb();
	}
	handled = 1;
out:	if(pHba->host)
		spin_unlock_irqrestore(pHba->host->host_lock, flags);
	return IRQ_RETVAL(handled);
}

static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_device* d)
{
	int i;
	u32 msg[MAX_MESSAGE_SIZE];
	u32* mptr;
	u32* lptr;
	u32 *lenptr;
	int direction;
	int scsidir;
	int nseg;
	u32 len;
	u32 reqlen;
	s32 rcode;
	dma_addr_t addr;

	memset(msg, 0 , sizeof(msg));
	len = scsi_bufflen(cmd);
	direction = 0x00000000;

	scsidir = 0x00000000;			// DATA NO XFER
	if(len) {
		/*
		 * Set SCBFlags to indicate if data is being transferred
		 * in or out, or no data transfer
		 * Note:  Do not have to verify index is less than 0 since
		 * cmd->cmnd[0] is an unsigned char
		 */
		switch(cmd->sc_data_direction){
		case DMA_FROM_DEVICE:
			scsidir  =0x40000000;	// DATA IN  (iop<--dev)
			break;
		case DMA_TO_DEVICE:
			direction=0x04000000;	// SGL OUT
			scsidir  =0x80000000;	// DATA OUT (iop-->dev)
			break;
		case DMA_NONE:
			break;
		case DMA_BIDIRECTIONAL:
			scsidir  =0x40000000;	// DATA IN  (iop<--dev)
			// Assume In - and continue;
			break;
		default:
			printk(KERN_WARNING""%s: scsi opcode 0x%x not supported.\n"",
			     pHba->name, cmd->cmnd[0]);
			cmd->result = (DID_ERROR <<16);
			scsi_done(cmd);
			return 	0;
		}
	}
	// msg[0] is set later
	// I2O_CMD_SCSI_EXEC
	msg[1] = ((0xff<<24)|(HOST_TID<<12)|d->tid);
	msg[2] = 0;
	/* Add 1 to avoid firmware treating it as invalid command */
	msg[3] = scsi_cmd_to_rq(cmd)->tag + 1;
	// Our cards use the transaction context as the tag for queueing
	// Adaptec/DPT Private stuff
	msg[4] = I2O_CMD_SCSI_EXEC|(DPT_ORGANIZATION_ID<<16);
	msg[5] = d->tid;
	/* Direction, disconnect ok | sense data | simple queue , CDBLen */
	// I2O_SCB_FLAG_ENABLE_DISCONNECT |
	// I2O_SCB_FLAG_SIMPLE_QUEUE_TAG |
	// I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;
	msg[6] = scsidir|0x20a00000|cmd->cmd_len;

	mptr=msg+7;

	// Write SCSI command into the message - always 16 byte block
	memset(mptr, 0,  16);
	memcpy(mptr, cmd->cmnd, cmd->cmd_len);
	mptr+=4;
	lenptr=mptr++;		/* Remember me - fill in when we know */
	if (dpt_dma64(pHba)) {
		reqlen = 16;		// SINGLE SGE
		*mptr++ = (0x7C<<24)+(2<<16)+0x02; /* Enable 64 bit */
		*mptr++ = 1 << PAGE_SHIFT;
	} else {
		reqlen = 14;		// SINGLE SGE
	}
	/* Now fill in the SGList and command */

	nseg = scsi_dma_map(cmd);
	BUG_ON(nseg < 0);
	if (nseg) {
		struct scatterlist *sg;

		len = 0;
		scsi_for_each_sg(cmd, sg, nseg, i) {
			lptr = mptr;
			*mptr++ = direction|0x10000000|sg_dma_len(sg);
			len+=sg_dma_len(sg);
			addr = sg_dma_address(sg);
			*mptr++ = dma_low(addr);
			if (dpt_dma64(pHba))
				*mptr++ = dma_high(addr);
			/* Make this an end of list */
			if (i == nseg - 1)
				*lptr = direction|0xD0000000|sg_dma_len(sg);
		}
		reqlen = mptr - msg;
		*lenptr = len;

		if(cmd->underflow && len != cmd->underflow){
			printk(KERN_WARNING""Cmd len %08X Cmd underflow %08X\n"",
				len, cmd->underflow);
		}
	} else {
		*lenptr = len = 0;
		reqlen = 12;
	}

	/* Stick the headers on */
	msg[0] = reqlen<<16 | ((reqlen > 12) ? SGL_OFFSET_12 : SGL_OFFSET_0);

	// Send it on it's way
	rcode = adpt_i2o_post_this(pHba, msg, reqlen<<2);
	if (rcode == 0) {
		return 0;
	}
	return rcode;
}


static s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)
{
	struct Scsi_Host *host;

	host = scsi_host_alloc(sht, sizeof(adpt_hba*));
	if (host == NULL) {
		printk(""%s: scsi_host_alloc returned NULL\n"", pHba->name);
		return -1;
	}
	host->hostdata[0] = (unsigned long)pHba;
	pHba->host = host;

	host->irq = pHba->pDev->irq;
	/* no IO ports, so don't have to set host->io_port and
	 * host->n_io_port
	 */
	host->io_port = 0;
	host->n_io_port = 0;
				/* see comments in scsi_host.h */
	host->max_id = 16;
	host->max_lun = 256;
	host->max_channel = pHba->top_scsi_channel + 1;
	host->cmd_per_lun = 1;
	host->unique_id = (u32)sys_tbl_pa + pHba->unit;
	host->sg_tablesize = pHba->sg_tablesize;
	host->can_queue = pHba->post_fifo_size;

	return 0;
}


static void adpt_i2o_scsi_complete(void __iomem *reply, struct scsi_cmnd *cmd)
{
	adpt_hba* pHba;
	u32 hba_status;
	u32 dev_status;
	u32 reply_flags = readl(reply) & 0xff00; // Leave it shifted up 8 bits
	// I know this would look cleaner if I just read bytes
	// but the model I have been using for all the rest of the
	// io is in 4 byte words - so I keep that model
	u16 detailed_status = readl(reply+16) &0xffff;
	dev_status = (detailed_status & 0xff);
	hba_status = detailed_status >> 8;

	// calculate resid for sg
	scsi_set_resid(cmd, scsi_bufflen(cmd) - readl(reply+20));

	pHba = (adpt_hba*) cmd->device->host->hostdata[0];

	cmd->sense_buffer[0] = '\0';  // initialize sense valid flag to false

	if(!(reply_flags & MSG_FAIL)) {
		switch(detailed_status & I2O_SCSI_DSC_MASK) {
		case I2O_SCSI_DSC_SUCCESS:
			cmd->result = (DID_OK << 16);
			// handle underflow
			if (readl(reply+20) < cmd->underflow) {
				cmd->result = (DID_ERROR <<16);
				printk(KERN_WARNING""%s: SCSI CMD underflow\n"",pHba->name);
			}
			break;
		case I2O_SCSI_DSC_REQUEST_ABORTED:
			cmd->result = (DID_ABORT << 16);
			break;
		case I2O_SCSI_DSC_PATH_INVALID:
		case I2O_SCSI_DSC_DEVICE_NOT_PRESENT:
		case I2O_SCSI_DSC_SELECTION_TIMEOUT:
		case I2O_SCSI_DSC_COMMAND_TIMEOUT:
		case I2O_SCSI_DSC_NO_ADAPTER:
		case I2O_SCSI_DSC_RESOURCE_UNAVAILABLE:
			printk(KERN_WARNING""%s: SCSI Timeout-Device (%d,%d,%llu) hba status=0x%x, dev status=0x%x, cmd=0x%x\n"",
				pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun, hba_status, dev_status, cmd->cmnd[0]);
			cmd->result = (DID_TIME_OUT << 16);
			break;
		case I2O_SCSI_DSC_ADAPTER_BUSY:
		case I2O_SCSI_DSC_BUS_BUSY:
			cmd->result = (DID_BUS_BUSY << 16);
			break;
		case I2O_SCSI_DSC_SCSI_BUS_RESET:
		case I2O_SCSI_DSC_BDR_MESSAGE_SENT:
			cmd->result = (DID_RESET << 16);
			break;
		case I2O_SCSI_DSC_PARITY_ERROR_FAILURE:
			printk(KERN_WARNING""%s: SCSI CMD parity error\n"",pHba->name);
			cmd->result = (DID_PARITY << 16);
			break;
		case I2O_SCSI_DSC_UNABLE_TO_ABORT:
		case I2O_SCSI_DSC_COMPLETE_WITH_ERROR:
		case I2O_SCSI_DSC_UNABLE_TO_TERMINATE:
		case I2O_SCSI_DSC_MR_MESSAGE_RECEIVED:
		case I2O_SCSI_DSC_AUTOSENSE_FAILED:
		case I2O_SCSI_DSC_DATA_OVERRUN:
		case I2O_SCSI_DSC_UNEXPECTED_BUS_FREE:
		case I2O_SCSI_DSC_SEQUENCE_FAILURE:
		case I2O_SCSI_DSC_REQUEST_LENGTH_ERROR:
		case I2O_SCSI_DSC_PROVIDE_FAILURE:
		case I2O_SCSI_DSC_REQUEST_TERMINATED:
		case I2O_SCSI_DSC_IDE_MESSAGE_SENT:
		case I2O_SCSI_DSC_UNACKNOWLEDGED_EVENT:
		case I2O_SCSI_DSC_MESSAGE_RECEIVED:
		case I2O_SCSI_DSC_INVALID_CDB:
		case I2O_SCSI_DSC_LUN_INVALID:
		case I2O_SCSI_DSC_SCSI_TID_INVALID:
		case I2O_SCSI_DSC_FUNCTION_UNAVAILABLE:
		case I2O_SCSI_DSC_NO_NEXUS:
		case I2O_SCSI_DSC_CDB_RECEIVED:
		case I2O_SCSI_DSC_LUN_ALREADY_ENABLED:
		case I2O_SCSI_DSC_QUEUE_FROZEN:
		case I2O_SCSI_DSC_REQUEST_INVALID:
		default:
			printk(KERN_WARNING""%s: SCSI error %0x-Device(%d,%d,%llu) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n"",
				pHba->name, detailed_status & I2O_SCSI_DSC_MASK, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun,
			       hba_status, dev_status, cmd->cmnd[0]);
			cmd->result = (DID_ERROR << 16);
			break;
		}

		// copy over the request sense data if it was a check
		// condition status
		if (dev_status == SAM_STAT_CHECK_CONDITION) {
			u32 len = min(SCSI_SENSE_BUFFERSIZE, 40);
			// Copy over the sense data
			memcpy_fromio(cmd->sense_buffer, (reply+28) , len);
			if(cmd->sense_buffer[0] == 0x70 /* class 7 */ &&
			   cmd->sense_buffer[2] == DATA_PROTECT ){
				/* This is to handle an array failed */
				cmd->result = (DID_TIME_OUT << 16);
				printk(KERN_WARNING""%s: SCSI Data Protect-Device (%d,%d,%llu) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n"",
					pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun,
					hba_status, dev_status, cmd->cmnd[0]);

			}
		}
	} else {
		/* In this condtion we could not talk to the tid
		 * the card rejected it.  We should signal a retry
		 * for a limitted number of retries.
		 */
		cmd->result = (DID_TIME_OUT << 16);
		printk(KERN_WARNING""%s: I2O MSG_FAIL - Device (%d,%d,%llu) tid=%d, cmd=0x%x\n"",
			pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun,
			((struct adpt_device*)(cmd->device->hostdata))->tid, cmd->cmnd[0]);
	}

	cmd->result |= (dev_status);

	scsi_done(cmd);
}


static s32 adpt_rescan(adpt_hba* pHba)
{
	s32 rcode;
	ulong flags = 0;

	if(pHba->host)
		spin_lock_irqsave(pHba->host->host_lock, flags);
	if ((rcode=adpt_i2o_lct_get(pHba)) < 0)
		goto out;
	if ((rcode=adpt_i2o_reparse_lct(pHba)) < 0)
		goto out;
	rcode = 0;
out:	if(pHba->host)
		spin_unlock_irqrestore(pHba->host->host_lock, flags);
	return rcode;
}


static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
{
	int i;
	int max;
	int tid;
	struct i2o_device *d;
	i2o_lct *lct = pHba->lct;
	u8 bus_no = 0;
	s16 scsi_id;
	u64 scsi_lun;
	u32 buf[10]; // at least 8 u32's
	struct adpt_device* pDev = NULL;
	struct i2o_device* pI2o_dev = NULL;

	if (lct == NULL) {
		printk(KERN_ERR ""%s: LCT is empty???\n"",pHba->name);
		return -1;
	}

	max = lct->table_size;
	max -= 3;
	max /= 9;

	// Mark each drive as unscanned
	for (d = pHba->devices; d; d = d->next) {
		pDev =(struct adpt_device*) d->owner;
		if(!pDev){
			continue;
		}
		pDev->state |= DPTI_DEV_UNSCANNED;
	}

	printk(KERN_INFO ""%s: LCT has %d entries.\n"", pHba->name,max);

	for(i=0;i<max;i++) {
		if( lct->lct_entry[i].user_tid != 0xfff){
			continue;
		}

		if( lct->lct_entry[i].class_id == I2O_CLASS_RANDOM_BLOCK_STORAGE ||
		    lct->lct_entry[i].class_id == I2O_CLASS_SCSI_PERIPHERAL ||
		    lct->lct_entry[i].class_id == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
			tid = lct->lct_entry[i].tid;
			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {
				printk(KERN_ERR""%s: Could not query device\n"",pHba->name);
				continue;
			}
			bus_no = buf[0]>>16;
			if (bus_no >= MAX_CHANNEL) {	/* Something wrong skip it */
				printk(KERN_WARNING
					""%s: Channel number %d out of range\n"",
					pHba->name, bus_no);
				continue;
			}

			scsi_id = buf[1];
			scsi_lun = scsilun_to_int((struct scsi_lun *)&buf[2]);
			pDev = pHba->channel[bus_no].device[scsi_id];
			/* da lun */
			while(pDev) {
				if(pDev->scsi_lun == scsi_lun) {
					break;
				}
				pDev = pDev->next_lun;
			}
			if(!pDev ) { // Something new add it
				d = kmalloc(sizeof(struct i2o_device),
					    GFP_ATOMIC);
				if(d==NULL)
				{
					printk(KERN_CRIT ""Out of memory for I2O device data.\n"");
					return -ENOMEM;
				}

				d->controller = pHba;
				d->next = NULL;

				memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));

				d->flags = 0;
				adpt_i2o_report_hba_unit(pHba, d);
				adpt_i2o_install_device(pHba, d);

				pDev = pHba->channel[bus_no].device[scsi_id];
				if( pDev == NULL){
					pDev =
					  kzalloc(sizeof(struct adpt_device),
						  GFP_ATOMIC);
					if(pDev == NULL) {
						return -ENOMEM;
					}
					pHba->channel[bus_no].device[scsi_id] = pDev;
				} else {
					while (pDev->next_lun) {
						pDev = pDev->next_lun;
					}
					pDev = pDev->next_lun =
					  kzalloc(sizeof(struct adpt_device),
						  GFP_ATOMIC);
					if(pDev == NULL) {
						return -ENOMEM;
					}
				}
				pDev->tid = d->lct_data.tid;
				pDev->scsi_channel = bus_no;
				pDev->scsi_id = scsi_id;
				pDev->scsi_lun = scsi_lun;
				pDev->pI2o_dev = d;
				d->owner = pDev;
				pDev->type = (buf[0])&0xff;
				pDev->flags = (buf[0]>>8)&0xff;
				// Too late, SCSI system has made up it's mind, but what the hey ...
				if(scsi_id > pHba->top_scsi_id){
					pHba->top_scsi_id = scsi_id;
				}
				if(scsi_lun > pHba->top_scsi_lun){
					pHba->top_scsi_lun = scsi_lun;
				}
				continue;
			} // end of new i2o device

			// We found an old device - check it
			while(pDev) {
				if(pDev->scsi_lun == scsi_lun) {
					if(!scsi_device_online(pDev->pScsi_dev)) {
						printk(KERN_WARNING""%s: Setting device (%d,%d,%llu) back online\n"",
								pHba->name,bus_no,scsi_id,scsi_lun);
						if (pDev->pScsi_dev) {
							scsi_device_set_state(pDev->pScsi_dev, SDEV_RUNNING);
						}
					}
					d = pDev->pI2o_dev;
					if(d->lct_data.tid != tid) { // something changed
						pDev->tid = tid;
						memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));
						if (pDev->pScsi_dev) {
							pDev->pScsi_dev->changed = TRUE;
							pDev->pScsi_dev->removable = TRUE;
						}
					}
					// Found it - mark it scanned
					pDev->state = DPTI_DEV_ONLINE;
					break;
				}
				pDev = pDev->next_lun;
			}
		}
	}
	for (pI2o_dev = pHba->devices; pI2o_dev; pI2o_dev = pI2o_dev->next) {
		pDev =(struct adpt_device*) pI2o_dev->owner;
		if(!pDev){
			continue;
		}
		// Drive offline drives that previously existed but could not be found
		// in the LCT table
		if (pDev->state & DPTI_DEV_UNSCANNED){
			pDev->state = DPTI_DEV_OFFLINE;
			printk(KERN_WARNING""%s: Device (%d,%d,%llu) offline\n"",pHba->name,pDev->scsi_channel,pDev->scsi_id,pDev->scsi_lun);
			if (pDev->pScsi_dev) {
				scsi_device_set_state(pDev->pScsi_dev, SDEV_OFFLINE);
			}
		}
	}
	return 0;
}

/*============================================================================
 *  Routines from i2o subsystem
 *============================================================================
 */



/*
 *	Bring an I2O controller into HOLD state. See the spec.
 */
static int adpt_i2o_activate_hba(adpt_hba* pHba)
{
	int rcode;

	if(pHba->initialized ) {
		if (adpt_i2o_status_get(pHba) < 0) {
			if((rcode = adpt_i2o_reset_hba(pHba)) != 0){
				printk(KERN_WARNING""%s: Could NOT reset.\n"", pHba->name);
				return rcode;
			}
			if (adpt_i2o_status_get(pHba) < 0) {
				printk(KERN_INFO ""HBA not responding.\n"");
				return -1;
			}
		}

		if(pHba->status_block->iop_state == ADAPTER_STATE_FAULTED) {
			printk(KERN_CRIT ""%s: hardware fault\n"", pHba->name);
			return -1;
		}

		if (pHba->status_block->iop_state == ADAPTER_STATE_READY ||
		    pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL ||
		    pHba->status_block->iop_state == ADAPTER_STATE_HOLD ||
		    pHba->status_block->iop_state == ADAPTER_STATE_FAILED) {
			adpt_i2o_reset_hba(pHba);
			if (adpt_i2o_status_get(pHba) < 0 || pHba->status_block->iop_state != ADAPTER_STATE_RESET) {
				printk(KERN_ERR ""%s: Failed to initialize.\n"", pHba->name);
				return -1;
			}
		}
	} else {
		if((rcode = adpt_i2o_reset_hba(pHba)) != 0){
			printk(KERN_WARNING""%s: Could NOT reset.\n"", pHba->name);
			return rcode;
		}

	}

	if (adpt_i2o_init_outbound_q(pHba) < 0) {
		return -1;
	}

	/* In HOLD state */

	if (adpt_i2o_hrt_get(pHba) < 0) {
		return -1;
	}

	return 0;
}

/*
 *	Bring a controller online into OPERATIONAL state.
 */

static int adpt_i2o_online_hba(adpt_hba* pHba)
{
	if (adpt_i2o_systab_send(pHba) < 0)
		return -1;
	/* In READY state */

	if (adpt_i2o_enable_hba(pHba) < 0)
		return -1;

	/* In OPERATIONAL state  */
	return 0;
}

static s32 adpt_send_nop(adpt_hba*pHba,u32 m)
{
	u32 __iomem *msg;
	ulong timeout = jiffies + 5*HZ;

	while(m == EMPTY_QUEUE){
		rmb();
		m = readl(pHba->post_port);
		if(m != EMPTY_QUEUE){
			break;
		}
		if(time_after(jiffies,timeout)){
			printk(KERN_ERR ""%s: Timeout waiting for message frame!\n"",pHba->name);
			return 2;
		}
		schedule_timeout_uninterruptible(1);
	}
	msg = (u32 __iomem *)(pHba->msg_addr_virt + m);
	writel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);
	writel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);
	writel( 0,&msg[2]);
	wmb();

	writel(m, pHba->post_port);
	wmb();
	return 0;
}

static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
{
	u8 *status;
	dma_addr_t addr;
	u32 __iomem *msg = NULL;
	int i;
	ulong timeout = jiffies + TMOUT_INITOUTBOUND*HZ;
	u32 m;

	do {
		rmb();
		m = readl(pHba->post_port);
		if (m != EMPTY_QUEUE) {
			break;
		}

		if(time_after(jiffies,timeout)){
			printk(KERN_WARNING""%s: Timeout waiting for message frame\n"",pHba->name);
			return -ETIMEDOUT;
		}
		schedule_timeout_uninterruptible(1);
	} while(m == EMPTY_QUEUE);

	msg=(u32 __iomem *)(pHba->msg_addr_virt+m);

	status = dma_alloc_coherent(&pHba->pDev->dev, 4, &addr, GFP_KERNEL);
	if (!status) {
		adpt_send_nop(pHba, m);
		printk(KERN_WARNING""%s: IOP reset failed - no free memory.\n"",
			pHba->name);
		return -ENOMEM;
	}

	writel(EIGHT_WORD_MSG_SIZE| SGL_OFFSET_6, &msg[0]);
	writel(I2O_CMD_OUTBOUND_INIT<<24 | HOST_TID<<12 | ADAPTER_TID, &msg[1]);
	writel(0, &msg[2]);
	writel(0x0106, &msg[3]);	/* Transaction context */
	writel(4096, &msg[4]);		/* Host page frame size */
	writel((REPLY_FRAME_SIZE)<<16|0x80, &msg[5]);	/* Outbound msg frame size and Initcode */
	writel(0xD0000004, &msg[6]);		/* Simple SG LE, EOB */
	writel((u32)addr, &msg[7]);

	writel(m, pHba->post_port);
	wmb();

	// Wait for the reply status to come back
	do {
		if (*status) {
			if (*status != 0x01 /*I2O_EXEC_OUTBOUND_INIT_IN_PROGRESS*/) {
				break;
			}
		}
		rmb();
		if(time_after(jiffies,timeout)){
			printk(KERN_WARNING""%s: Timeout Initializing\n"",pHba->name);
			/* We lose 4 bytes of ""status"" here, but we
			   cannot free these because controller may
			   awake and corrupt those bytes at any time */
			/* dma_free_coherent(&pHba->pDev->dev, 4, status, addr); */
			return -ETIMEDOUT;
		}
		schedule_timeout_uninterruptible(1);
	} while (1);

	// If the command was successful, fill the fifo with our reply
	// message packets
	if(*status != 0x04 /*I2O_EXEC_OUTBOUND_INIT_COMPLETE*/) {
		dma_free_coherent(&pHba->pDev->dev, 4, status, addr);
		return -2;
	}
	dma_free_coherent(&pHba->pDev->dev, 4, status, addr);

	if(pHba->reply_pool != NULL) {
		dma_free_coherent(&pHba->pDev->dev,
			pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4,
			pHba->reply_pool, pHba->reply_pool_pa);
	}

	pHba->reply_pool = dma_alloc_coherent(&pHba->pDev->dev,
				pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4,
				&pHba->reply_pool_pa, GFP_KERNEL);
	if (!pHba->reply_pool) {
		printk(KERN_ERR ""%s: Could not allocate reply pool\n"", pHba->name);
		return -ENOMEM;
	}

	for(i = 0; i < pHba->reply_fifo_size; i++) {
		writel(pHba->reply_pool_pa + (i * REPLY_FRAME_SIZE * 4),
			pHba->reply_port);
		wmb();
	}
	adpt_i2o_status_get(pHba);
	return 0;
}


/*
 * I2O System Table.  Contains information about
 * all the IOPs in the system.  Used to inform IOPs
 * about each other's existence.
 *
 * sys_tbl_ver is the CurrentChangeIndicator that is
 * used by IOPs to track changes.
 */



static s32 adpt_i2o_status_get(adpt_hba* pHba)
{
	ulong timeout;
	u32 m;
	u32 __iomem *msg;
	u8 *status_block=NULL;

	if(pHba->status_block == NULL) {
		pHba->status_block = dma_alloc_coherent(&pHba->pDev->dev,
					sizeof(i2o_status_block),
					&pHba->status_block_pa, GFP_KERNEL);
		if(pHba->status_block == NULL) {
			printk(KERN_ERR
			""dpti%d: Get Status Block failed; Out of memory. \n"",
			pHba->unit);
			return -ENOMEM;
		}
	}
	memset(pHba->status_block, 0, sizeof(i2o_status_block));
	status_block = (u8*)(pHba->status_block);
	timeout = jiffies+TMOUT_GETSTATUS*HZ;
	do {
		rmb();
		m = readl(pHba->post_port);
		if (m != EMPTY_QUEUE) {
			break;
		}
		if(time_after(jiffies,timeout)){
			printk(KERN_ERR ""%s: Timeout waiting for message !\n"",
					pHba->name);
			return -ETIMEDOUT;
		}
		schedule_timeout_uninterruptible(1);
	} while(m==EMPTY_QUEUE);


	msg=(u32 __iomem *)(pHba->msg_addr_virt+m);

	writel(NINE_WORD_MSG_SIZE|SGL_OFFSET_0, &msg[0]);
	writel(I2O_CMD_STATUS_GET<<24|HOST_TID<<12|ADAPTER_TID, &msg[1]);
	writel(1, &msg[2]);
	writel(0, &msg[3]);
	writel(0, &msg[4]);
	writel(0, &msg[5]);
	writel( dma_low(pHba->status_block_pa), &msg[6]);
	writel( dma_high(pHba->status_block_pa), &msg[7]);
	writel(sizeof(i2o_status_block), &msg[8]); // 88 bytes

	//post message
	writel(m, pHba->post_port);
	wmb();

	while(status_block[87]!=0xff){
		if(time_after(jiffies,timeout)){
			printk(KERN_ERR""dpti%d: Get status timeout.\n"",
				pHba->unit);
			return -ETIMEDOUT;
		}
		rmb();
		schedule_timeout_uninterruptible(1);
	}

	// Set up our number of outbound and inbound messages
	pHba->post_fifo_size = pHba->status_block->max_inbound_frames;
	if (pHba->post_fifo_size > MAX_TO_IOP_MESSAGES) {
		pHba->post_fifo_size = MAX_TO_IOP_MESSAGES;
	}

	pHba->reply_fifo_size = pHba->status_block->max_outbound_frames;
	if (pHba->reply_fifo_size > MAX_FROM_IOP_MESSAGES) {
		pHba->reply_fifo_size = MAX_FROM_IOP_MESSAGES;
	}

	// Calculate the Scatter Gather list size
	if (dpt_dma64(pHba)) {
		pHba->sg_tablesize
		  = ((pHba->status_block->inbound_frame_size * 4
		  - 14 * sizeof(u32))
		  / (sizeof(struct sg_simple_element) + sizeof(u32)));
	} else {
		pHba->sg_tablesize
		  = ((pHba->status_block->inbound_frame_size * 4
		  - 12 * sizeof(u32))
		  / sizeof(struct sg_simple_element));
	}
	if (pHba->sg_tablesize > SG_LIST_ELEMENTS) {
		pHba->sg_tablesize = SG_LIST_ELEMENTS;
	}


#ifdef DEBUG
	printk(""dpti%d: State = "",pHba->unit);
	switch(pHba->status_block->iop_state) {
		case 0x01:
			printk(""INIT\n"");
			break;
		case 0x02:
			printk(""RESET\n"");
			break;
		case 0x04:
			printk(""HOLD\n"");
			break;
		case 0x05:
			printk(""READY\n"");
			break;
		case 0x08:
			printk(""OPERATIONAL\n"");
			break;
		case 0x10:
			printk(""FAILED\n"");
			break;
		case 0x11:
			printk(""FAULTED\n"");
			break;
		default:
			printk(""%x (unknown!!)\n"",pHba->status_block->iop_state);
	}
#endif
	return 0;
}

/*
 * Get the IOP's Logical Configuration Table
 */
static int adpt_i2o_lct_get(adpt_hba* pHba)
{
	u32 msg[8];
	int ret;
	u32 buf[16];

	if ((pHba->lct_size == 0) || (pHba->lct == NULL)){
		pHba->lct_size = pHba->status_block->expected_lct_size;
	}
	do {
		if (pHba->lct == NULL) {
			pHba->lct = dma_alloc_coherent(&pHba->pDev->dev,
					pHba->lct_size, &pHba->lct_pa,
					GFP_ATOMIC);
			if(pHba->lct == NULL) {
				printk(KERN_CRIT ""%s: Lct Get failed. Out of memory.\n"",
					pHba->name);
				return -ENOMEM;
			}
		}
		memset(pHba->lct, 0, pHba->lct_size);

		msg[0] = EIGHT_WORD_MSG_SIZE|SGL_OFFSET_6;
		msg[1] = I2O_CMD_LCT_NOTIFY<<24 | HOST_TID<<12 | ADAPTER_TID;
		msg[2] = 0;
		msg[3] = 0;
		msg[4] = 0xFFFFFFFF;	/* All devices */
		msg[5] = 0x00000000;	/* Report now */
		msg[6] = 0xD0000000|pHba->lct_size;
		msg[7] = (u32)pHba->lct_pa;

		if ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 360))) {
			printk(KERN_ERR ""%s: LCT Get failed (status=%#10x.\n"",
				pHba->name, ret);
			printk(KERN_ERR""Adaptec: Error Reading Hardware.\n"");
			return ret;
		}

		if ((pHba->lct->table_size << 2) > pHba->lct_size) {
			pHba->lct_size = pHba->lct->table_size << 2;
			dma_free_coherent(&pHba->pDev->dev, pHba->lct_size,
					pHba->lct, pHba->lct_pa);
			pHba->lct = NULL;
		}
	} while (pHba->lct == NULL);

	PDEBUG(""%s: Hardware resource table read.\n"", pHba->name);


	// I2O_DPT_EXEC_IOP_BUFFERS_GROUP_NO;
	if(adpt_i2o_query_scalar(pHba, 0 , 0x8000, -1, buf, sizeof(buf))>=0) {
		pHba->FwDebugBufferSize = buf[1];
		pHba->FwDebugBuffer_P = ioremap(pHba->base_addr_phys + buf[0],
						pHba->FwDebugBufferSize);
		if (pHba->FwDebugBuffer_P) {
			pHba->FwDebugFlags_P     = pHba->FwDebugBuffer_P +
							FW_DEBUG_FLAGS_OFFSET;
			pHba->FwDebugBLEDvalue_P = pHba->FwDebugBuffer_P +
							FW_DEBUG_BLED_OFFSET;
			pHba->FwDebugBLEDflag_P  = pHba->FwDebugBLEDvalue_P + 1;
			pHba->FwDebugStrLength_P = pHba->FwDebugBuffer_P +
						FW_DEBUG_STR_LENGTH_OFFSET;
			pHba->FwDebugBuffer_P += buf[2];
			pHba->FwDebugFlags = 0;
		}
	}

	return 0;
}

static int adpt_i2o_build_sys_table(void)
{
	adpt_hba* pHba = hba_chain;
	int count = 0;

	if (sys_tbl)
		dma_free_coherent(&pHba->pDev->dev, sys_tbl_len,
					sys_tbl, sys_tbl_pa);

	sys_tbl_len = sizeof(struct i2o_sys_tbl) +	// Header + IOPs
				(hba_count) * sizeof(struct i2o_sys_tbl_entry);

	sys_tbl = dma_alloc_coherent(&pHba->pDev->dev,
				sys_tbl_len, &sys_tbl_pa, GFP_KERNEL);
	if (!sys_tbl) {
		printk(KERN_WARNING ""SysTab Set failed. Out of memory.\n"");
		return -ENOMEM;
	}

	sys_tbl->num_entries = hba_count;
	sys_tbl->version = I2OVERSION;
	sys_tbl->change_ind = sys_tbl_ind++;

	for(pHba = hba_chain; pHba; pHba = pHba->next) {
		u64 addr;
		// Get updated Status Block so we have the latest information
		if (adpt_i2o_status_get(pHba)) {
			sys_tbl->num_entries--;
			continue; // try next one
		}

		sys_tbl->iops[count].org_id = pHba->status_block->org_id;
		sys_tbl->iops[count].iop_id = pHba->unit + 2;
		sys_tbl->iops[count].seg_num = 0;
		sys_tbl->iops[count].i2o_version = pHba->status_block->i2o_version;
		sys_tbl->iops[count].iop_state = pHba->status_block->iop_state;
		sys_tbl->iops[count].msg_type = pHba->status_block->msg_type;
		sys_tbl->iops[count].frame_size = pHba->status_block->inbound_frame_size;
		sys_tbl->iops[count].last_changed = sys_tbl_ind - 1; // ??
		sys_tbl->iops[count].iop_capabilities = pHba->status_block->iop_capabilities;
		addr = pHba->base_addr_phys + 0x40;
		sys_tbl->iops[count].inbound_low = dma_low(addr);
		sys_tbl->iops[count].inbound_high = dma_high(addr);

		count++;
	}

#ifdef DEBUG
{
	u32 *table = (u32*)sys_tbl;
	printk(KERN_DEBUG""sys_tbl_len=%d in 32bit words\n"",(sys_tbl_len >>2));
	for(count = 0; count < (sys_tbl_len >>2); count++) {
		printk(KERN_INFO ""sys_tbl[%d] = %0#10x\n"",
			count, table[count]);
	}
}
#endif

	return 0;
}


/*
 *	 Dump the information block associated with a given unit (TID)
 */

static void adpt_i2o_report_hba_unit(adpt_hba* pHba, struct i2o_device *d)
{
	char buf[64];
	int unit = d->lct_data.tid;

	printk(KERN_INFO ""TID %3.3d "", unit);

	if(adpt_i2o_query_scalar(pHba, unit, 0xF100, 3, buf, 16)>=0)
	{
		buf[16]=0;
		printk("" Vendor: %-12.12s"", buf);
	}
	if(adpt_i2o_query_scalar(pHba, unit, 0xF100, 4, buf, 16)>=0)
	{
		buf[16]=0;
		printk("" Device: %-12.12s"", buf);
	}
	if(adpt_i2o_query_scalar(pHba, unit, 0xF100, 6, buf, 8)>=0)
	{
		buf[8]=0;
		printk("" Rev: %-12.12s\n"", buf);
	}
#ifdef DEBUG
	 printk(KERN_INFO ""\tClass: %.21s\n"", adpt_i2o_get_class_name(d->lct_data.class_id));
	 printk(KERN_INFO ""\tSubclass: 0x%04X\n"", d->lct_data.sub_class);
	 printk(KERN_INFO ""\tFlags: "");

	 if(d->lct_data.device_flags&(1<<0))
		  printk(""C"");	     // ConfigDialog requested
	 if(d->lct_data.device_flags&(1<<1))
		  printk(""U"");	     // Multi-user capable
	 if(!(d->lct_data.device_flags&(1<<4)))
		  printk(""P"");	     // Peer service enabled!
	 if(!(d->lct_data.device_flags&(1<<5)))
		  printk(""M"");	     // Mgmt service enabled!
	 printk(""\n"");
#endif
}

#ifdef DEBUG
/*
 *	Do i2o class name lookup
 */
static const char *adpt_i2o_get_class_name(int class)
{
	int idx = 16;
	static char *i2o_class_name[] = {
		""Executive"",
		""Device Driver Module"",
		""Block Device"",
		""Tape Device"",
		""LAN Interface"",
		""WAN Interface"",
		""Fibre Channel Port"",
		""Fibre Channel Device"",
		""SCSI Device"",
		""ATE Port"",
		""ATE Device"",
		""Floppy Controller"",
		""Floppy Device"",
		""Secondary Bus Port"",
		""Peer Transport Agent"",
		""Peer Transport"",
		""Unknown""
	};

	switch(class&0xFFF) {
	case I2O_CLASS_EXECUTIVE:
		idx = 0; break;
	case I2O_CLASS_DDM:
		idx = 1; break;
	case I2O_CLASS_RANDOM_BLOCK_STORAGE:
		idx = 2; break;
	case I2O_CLASS_SEQUENTIAL_STORAGE:
		idx = 3; break;
	case I2O_CLASS_LAN:
		idx = 4; break;
	case I2O_CLASS_WAN:
		idx = 5; break;
	case I2O_CLASS_FIBRE_CHANNEL_PORT:
		idx = 6; break;
	case I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL:
		idx = 7; break;
	case I2O_CLASS_SCSI_PERIPHERAL:
		idx = 8; break;
	case I2O_CLASS_ATE_PORT:
		idx = 9; break;
	case I2O_CLASS_ATE_PERIPHERAL:
		idx = 10; break;
	case I2O_CLASS_FLOPPY_CONTROLLER:
		idx = 11; break;
	case I2O_CLASS_FLOPPY_DEVICE:
		idx = 12; break;
	case I2O_CLASS_BUS_ADAPTER_PORT:
		idx = 13; break;
	case I2O_CLASS_PEER_TRANSPORT_AGENT:
		idx = 14; break;
	case I2O_CLASS_PEER_TRANSPORT:
		idx = 15; break;
	}
	return i2o_class_name[idx];
}
#endif


static s32 adpt_i2o_hrt_get(adpt_hba* pHba)
{
	u32 msg[6];
	int ret, size = sizeof(i2o_hrt);

	do {
		if (pHba->hrt == NULL) {
			pHba->hrt = dma_alloc_coherent(&pHba->pDev->dev,
					size, &pHba->hrt_pa, GFP_KERNEL);
			if (pHba->hrt == NULL) {
				printk(KERN_CRIT ""%s: Hrt Get failed; Out of memory.\n"", pHba->name);
				return -ENOMEM;
			}
		}

		msg[0]= SIX_WORD_MSG_SIZE| SGL_OFFSET_4;
		msg[1]= I2O_CMD_HRT_GET<<24 | HOST_TID<<12 | ADAPTER_TID;
		msg[2]= 0;
		msg[3]= 0;
		msg[4]= (0xD0000000 | size);    /* Simple transaction */
		msg[5]= (u32)pHba->hrt_pa;	/* Dump it here */

		if ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg),20))) {
			printk(KERN_ERR ""%s: Unable to get HRT (status=%#10x)\n"", pHba->name, ret);
			return ret;
		}

		if (pHba->hrt->num_entries * pHba->hrt->entry_len << 2 > size) {
			int newsize = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;
			dma_free_coherent(&pHba->pDev->dev, size,
				pHba->hrt, pHba->hrt_pa);
			size = newsize;
			pHba->hrt = NULL;
		}
	} while(pHba->hrt == NULL);
	return 0;
}

/*
 *	 Query one scalar group value or a whole scalar group.
 */
static int adpt_i2o_query_scalar(adpt_hba* pHba, int tid,
			int group, int field, void *buf, int buflen)
{
	u16 opblk[] = { 1, 0, I2O_PARAMS_FIELD_GET, group, 1, field };
	u8 *opblk_va;
	dma_addr_t opblk_pa;
	u8 *resblk_va;
	dma_addr_t resblk_pa;

	int size;

	/* 8 bytes for header */
	resblk_va = dma_alloc_coherent(&pHba->pDev->dev,
			sizeof(u8) * (8 + buflen), &resblk_pa, GFP_KERNEL);
	if (resblk_va == NULL) {
		printk(KERN_CRIT ""%s: query scalar failed; Out of memory.\n"", pHba->name);
		return -ENOMEM;
	}

	opblk_va = dma_alloc_coherent(&pHba->pDev->dev,
			sizeof(opblk), &opblk_pa, GFP_KERNEL);
	if (opblk_va == NULL) {
		dma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),
			resblk_va, resblk_pa);
		printk(KERN_CRIT ""%s: query operation failed; Out of memory.\n"",
			pHba->name);
		return -ENOMEM;
	}
	if (field == -1)  		/* whole group */
			opblk[4] = -1;

	memcpy(opblk_va, opblk, sizeof(opblk));
	size = adpt_i2o_issue_params(I2O_CMD_UTIL_PARAMS_GET, pHba, tid,
		opblk_va, opblk_pa, sizeof(opblk),
		resblk_va, resblk_pa, sizeof(u8)*(8+buflen));
	dma_free_coherent(&pHba->pDev->dev, sizeof(opblk), opblk_va, opblk_pa);
	if (size == -ETIME) {
		dma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),
							resblk_va, resblk_pa);
		printk(KERN_WARNING ""%s: issue params failed; Timed out.\n"", pHba->name);
		return -ETIME;
	} else if (size == -EINTR) {
		dma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),
							resblk_va, resblk_pa);
		printk(KERN_WARNING ""%s: issue params failed; Interrupted.\n"", pHba->name);
		return -EINTR;
	}

	memcpy(buf, resblk_va+8, buflen);  /* cut off header */

	dma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),
						resblk_va, resblk_pa);
	if (size < 0)
		return size;

	return buflen;
}


/*	Issue UTIL_PARAMS_GET or UTIL_PARAMS_SET
 *
 *	This function can be used for all UtilParamsGet/Set operations.
 *	The OperationBlock is given in opblk-buffer,
 *	and results are returned in resblk-buffer.
 *	Note that the minimum sized resblk is 8 bytes and contains
 *	ResultCount, ErrorInfoSize, BlockStatus and BlockSize.
 */
static int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid,
		  void *opblk_va,  dma_addr_t opblk_pa, int oplen,
		void *resblk_va, dma_addr_t resblk_pa, int reslen)
{
	u32 msg[9];
	u32 *res = (u32 *)resblk_va;
	int wait_status;

	msg[0] = NINE_WORD_MSG_SIZE | SGL_OFFSET_5;
	msg[1] = cmd << 24 | HOST_TID << 12 | tid;
	msg[2] = 0;
	msg[3] = 0;
	msg[4] = 0;
	msg[5] = 0x54000000 | oplen;	/* OperationBlock */
	msg[6] = (u32)opblk_pa;
	msg[7] = 0xD0000000 | reslen;	/* ResultBlock */
	msg[8] = (u32)resblk_pa;

	if ((wait_status = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 20))) {
		printk(""adpt_i2o_issue_params: post_wait failed (%p)\n"", resblk_va);
   		return wait_status; 	/* -DetailedStatus */
	}

	if (res[1]&0x00FF0000) { 	/* BlockStatus != SUCCESS */
		printk(KERN_WARNING ""%s: %s - Error:\n  ErrorInfoSize = 0x%02x, ""
			""BlockStatus = 0x%02x, BlockSize = 0x%04x\n"",
			pHba->name,
			(cmd == I2O_CMD_UTIL_PARAMS_SET) ? ""PARAMS_SET""
							 : ""PARAMS_GET"",
			res[1]>>24, (res[1]>>16)&0xFF, res[1]&0xFFFF);
		return -((res[1] >> 16) & 0xFF); /* -BlockStatus */
	}

	return 4 + ((res[1] & 0x0000FFFF) << 2); /* bytes used in resblk */
}


static s32 adpt_i2o_quiesce_hba(adpt_hba* pHba)
{
	u32 msg[4];
	int ret;

	adpt_i2o_status_get(pHba);

	/* SysQuiesce discarded if IOP not in READY or OPERATIONAL state */

	if((pHba->status_block->iop_state != ADAPTER_STATE_READY) &&
   	   (pHba->status_block->iop_state != ADAPTER_STATE_OPERATIONAL)){
		return 0;
	}

	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
	msg[1] = I2O_CMD_SYS_QUIESCE<<24|HOST_TID<<12|ADAPTER_TID;
	msg[2] = 0;
	msg[3] = 0;

	if((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {
		printk(KERN_INFO""dpti%d: Unable to quiesce (status=%#x).\n"",
				pHba->unit, -ret);
	} else {
		printk(KERN_INFO""dpti%d: Quiesced.\n"",pHba->unit);
	}

	adpt_i2o_status_get(pHba);
	return ret;
}


/*
 * Enable IOP. Allows the IOP to resume external operations.
 */
static int adpt_i2o_enable_hba(adpt_hba* pHba)
{
	u32 msg[4];
	int ret;

	adpt_i2o_status_get(pHba);
	if(!pHba->status_block){
		return -ENOMEM;
	}
	/* Enable only allowed on READY state */
	if(pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL)
		return 0;

	if(pHba->status_block->iop_state != ADAPTER_STATE_READY)
		return -EINVAL;

	msg[0]=FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
	msg[1]=I2O_CMD_SYS_ENABLE<<24|HOST_TID<<12|ADAPTER_TID;
	msg[2]= 0;
	msg[3]= 0;

	if ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {
		printk(KERN_WARNING""%s: Could not enable (status=%#10x).\n"",
			pHba->name, ret);
	} else {
		PDEBUG(""%s: Enabled.\n"", pHba->name);
	}

	adpt_i2o_status_get(pHba);
	return ret;
}


static int adpt_i2o_systab_send(adpt_hba* pHba)
{
	u32 msg[12];
	int ret;

	msg[0] = I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6;
	msg[1] = I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID;
	msg[2] = 0;
	msg[3] = 0;
	msg[4] = (0<<16) | ((pHba->unit+2) << 12); /* Host 0 IOP ID (unit + 2) */
	msg[5] = 0;				   /* Segment 0 */

	/*
	 * Provide three SGL-elements:
	 * System table (SysTab), Private memory space declaration and
	 * Private i/o space declaration
	 */
	msg[6] = 0x54000000 | sys_tbl_len;
	msg[7] = (u32)sys_tbl_pa;
	msg[8] = 0x54000000 | 0;
	msg[9] = 0;
	msg[10] = 0xD4000000 | 0;
	msg[11] = 0;

	if ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 120))) {
		printk(KERN_INFO ""%s: Unable to set SysTab (status=%#10x).\n"",
			pHba->name, ret);
	}
#ifdef DEBUG
	else {
		PINFO(""%s: SysTab set.\n"", pHba->name);
	}
#endif

	return ret;
}


/*============================================================================
 *
 *============================================================================
 */


#ifdef UARTDELAY

static static void adpt_delay(int millisec)
{
	int i;
	for (i = 0; i < millisec; i++) {
		udelay(1000);	/* delay for one millisecond */
	}
}

#endif

static struct scsi_host_template driver_template = {
	.module			= THIS_MODULE,
	.name			= ""dpt_i2o"",
	.proc_name		= ""dpt_i2o"",
	.show_info		= adpt_show_info,
	.info			= adpt_info,
	.queuecommand		= adpt_queue,
	.eh_abort_handler	= adpt_abort,
	.eh_device_reset_handler = adpt_device_reset,
	.eh_bus_reset_handler	= adpt_bus_reset,
	.eh_host_reset_handler	= adpt_reset,
	.bios_param		= adpt_bios_param,
	.slave_configure	= adpt_slave_configure,
	.can_queue		= MAX_TO_IOP_MESSAGES,
	.this_id		= 7,
};

static int __init adpt_init(void)
{
	int		error;
	adpt_hba	*pHba, *next;

	printk(""Loading Adaptec I2O RAID: Version "" DPT_I2O_VERSION ""\n"");

	error = adpt_detect(&driver_template);
	if (error < 0)
		return error;
	if (hba_chain == NULL)
		return -ENODEV;

	for (pHba = hba_chain; pHba; pHba = pHba->next) {
		error = scsi_add_host(pHba->host, &pHba->pDev->dev);
		if (error)
			goto fail;
		scsi_scan_host(pHba->host);
	}
	return 0;
fail:
	for (pHba = hba_chain; pHba; pHba = next) {
		next = pHba->next;
		scsi_remove_host(pHba->host);
	}
	return error;
}

static void __exit adpt_exit(void)
{
	adpt_hba	*pHba, *next;

	for (pHba = hba_chain; pHba; pHba = next) {
		next = pHba->next;
		adpt_release(pHba);
	}
}

module_init(adpt_init);
module_exit(adpt_exit);

MODULE_LICENSE(""GPL"");",b04e75a4a8a81887386a0d2dbf605a48e779d2a0,CVE-2023-2007,b04e75a4a8a81887386a0d2dbf605a48e779d2a0,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"  /*************************************************************************** VAR.VAR - VAR ------------------- VAR : VAR VAR 7 2000 VAR : (VAR) 2000 VAR VAR VAR 30, 2001 VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR.4 VAR VAR/VAR/VAR.VAR VAR VAR, VAR, VAR VAR VAR VAR ***************************************************************************/ /*************************************************************************** * * * * ***************************************************************************/ /*************************************************************************** * VAR VAR 20 2003 VAR VAR <VAR@VAR.VAR.VAR> - VAR 2.6 VAR VAR VAR-VAR - VAR VAR VAR VAR VAR - VAR VAR VAR VAR VAR VAR **************************************************************************/ /* /*   VAR(""VAR VAR, VAR VAR VAR VAR VAR VAR VAR""); VAR(""VAR VAR VAR VAR"");                             /*============================================================================ * VAR VAR VAR VAR - VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR *============================================================================ */ VAR VAR(VAR); VAR VAR VAR = { {'VAR', 'VAR', 'VAR', 'VAR', 'VAR', 'VAR'}, VAR,  VAR, VAR | VAR | VAR | VAR,  VAR, VAR,  VAR, VAR,  VAR, VAR,  (-1),(-1),  VAR, 0, VAR, VAR, VAR, VAR, VAR, 0, 0, VAR, VAR, VAR, VAR, VAR, VAR, ""VAR VAR VAR VAR VAR"" }; /*============================================================================ * VAR *============================================================================ */ VAR VAR(VAR); VAR VAR VAR *VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR* VAR = VAR; VAR VAR VAR = 0; VAR VAR VAR *VAR; VAR VAR VAR(VAR VAR *, VAR VAR, VAR VAR);  VAR VAR VAR(VAR VAR *, VAR VAR, VAR VAR);  VAR VAR VAR VAR VAR = { .VAR = VAR, .VAR = VAR, .VAR = VAR,  .VAR = VAR,  .VAR = VAR, }; /* VAR VAR VAR VAR VAR VAR VAR. * VAR VAR() VAR VAR * */ VAR VAR { VAR VAR; VAR VAR; VAR *VAR; VAR VAR *VAR; }; VAR VAR VAR *VAR = VAR; VAR VAR VAR = 0; VAR VAR(VAR); /*============================================================================ * VAR *============================================================================ */ VAR VAR VAR VAR(VAR *VAR) { VAR (VAR(VAR) > 4 && (VAR)->VAR); } VAR VAR VAR VAR(VAR VAR) { VAR VAR(VAR); } VAR VAR VAR VAR(VAR VAR) { VAR (VAR)VAR; } VAR VAR VAR(VAR* VAR) { VAR (VAR->VAR) { VAR( VAR(VAR->VAR) == 0xbc ){ VAR VAR(VAR->VAR); } } VAR 0; } /*============================================================================ * VAR VAR VAR VAR VAR *============================================================================ */  VAR VAR VAR VAR[] = { { VAR, VAR, VAR, VAR,}, { VAR, VAR, VAR, VAR,}, { 0, } };  VAR(VAR,VAR); VAR VAR VAR(VAR VAR* VAR) { VAR VAR *VAR = VAR; VAR *VAR; VAR *VAR; VAR(""VAR VAR VAR VAR VAR...\VAR"");  VAR ((VAR = VAR( VAR, VAR, VAR))) { VAR(VAR->VAR == VAR || VAR->VAR == VAR){ VAR(VAR(VAR, VAR) ){ VAR(""VAR VAR VAR VAR VAR VAR VAR\VAR""); VAR(""VAR VAR VAR VAR VAR VAR.\VAR""); VAR VAR-1; } VAR(VAR); } }  VAR (VAR = VAR; VAR; VAR = VAR) { VAR = VAR->VAR;  VAR (VAR(VAR) < 0) { VAR(VAR); } }  VAR: VAR (VAR == VAR) VAR 0; /* * VAR VAR VAR, VAR VAR VAR VAR VAR * VAR VAR VAR'VAR VAR VAR VAR VAR/VAR VAR VAR VAR */ VAR (VAR() < 0) { VAR(); VAR 0; } VAR(""VAR'VAR VAR VAR VAR\VAR"");  VAR (VAR = VAR; VAR; VAR = VAR->VAR) { VAR (VAR(VAR) < 0) { VAR(VAR); VAR VAR; } }  VAR(""VAR'VAR VAR VAR VAR\VAR""); VAR(""VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.\VAR""); VAR (VAR = VAR; VAR; VAR = VAR) { VAR = VAR->VAR; VAR(VAR""%VAR: VAR VAR VAR VAR VAR.\VAR"", VAR->VAR); VAR (VAR(VAR) < 0){ VAR(VAR); VAR; } VAR (VAR(VAR) < 0){ VAR(VAR); VAR; } VAR(VAR); } VAR = VAR(VAR, ""VAR""); VAR (VAR(VAR)) { VAR(VAR""VAR: VAR VAR VAR VAR VAR\VAR""); VAR = VAR; } VAR (VAR = VAR; VAR; VAR = VAR) { VAR = VAR->VAR; VAR (VAR(VAR, VAR) < 0){ VAR(VAR); VAR; } VAR->VAR = VAR; VAR->VAR &= ~VAR; VAR (VAR) { VAR VAR *VAR = VAR(VAR, VAR, VAR(VAR, VAR->VAR), VAR, ""VAR%VAR"", VAR->VAR); VAR (VAR(VAR)) { VAR(VAR""VAR%VAR: VAR VAR "" ""VAR VAR VAR VAR VAR\VAR"", VAR->VAR); } } }    VAR (VAR && VAR(VAR, VAR, &VAR)) { VAR(); VAR 0; } VAR VAR; } VAR VAR VAR(VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR(VAR);  VAR(VAR); VAR(VAR); } VAR VAR VAR(VAR* VAR) { VAR VAR[17]; VAR *VAR; VAR *VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR* VAR; VAR VAR; VAR VAR[16]; VAR VAR; VAR(VAR, 0, VAR(VAR)); VAR = VAR(&VAR->VAR->VAR, 80, &VAR, VAR); VAR(!VAR){ VAR(VAR""%VAR: VAR VAR VAR VAR\VAR"",VAR->VAR); VAR; } VAR((VAR*)VAR, 0, 36); VAR = 36; VAR = 0x00000000; VAR =0x40000000;  VAR (VAR(VAR)) VAR = 17;  VAR VAR = 14;   VAR[0] = VAR<<16 | VAR; VAR[1] = (0xff<<24|VAR<<12|VAR); VAR[2] = 0; VAR[3] = 0;  VAR[4] = VAR|VAR<<16; VAR[5] = VAR | 1<<16 ;     VAR[6] = VAR|0x20a00000| 6 ; VAR=VAR+7; VAR(VAR, 0, VAR(VAR));  VAR[0] = VAR; VAR[1] = 0; VAR[2] = 0; VAR[3] = 0; VAR[4] = 36; VAR[5] = 0;  VAR(VAR, VAR, VAR(VAR)); VAR+=4; VAR=VAR++;   *VAR = VAR; VAR (VAR(VAR)) { *VAR++ = (0x7C<<24)+(2<<16)+0x02;  *VAR++ = 1 << VAR; *VAR++ = 0xD0000000|VAR|VAR; *VAR++ = VAR(VAR); *VAR++ = VAR(VAR); } VAR { *VAR++ = 0xD0000000|VAR|VAR; *VAR++ = VAR; }  VAR = VAR(VAR, VAR, VAR<<2, 120); VAR (VAR != 0) { VAR(VAR->VAR, ""VAR VAR VAR""); VAR(VAR ""%VAR: VAR VAR (%VAR)\VAR"",VAR->VAR,VAR); VAR (VAR != -VAR && VAR != -VAR) VAR(&VAR->VAR->VAR, 80, VAR, VAR); } VAR { VAR(VAR->VAR, 0, VAR(VAR->VAR)); VAR(&(VAR->VAR), ""VAR: VAR "", 16); VAR(&(VAR->VAR[16]), "" VAR: "", 8); VAR(&(VAR->VAR[24]), (VAR*) &VAR[16], 16); VAR(&(VAR->VAR[40]), "" VAR: "", 4); VAR(&(VAR->VAR[44]), (VAR*) &VAR[32], 4); VAR->VAR[48] = '\0';  VAR(&VAR->VAR->VAR, 80, VAR, VAR); } VAR(VAR); VAR ; } VAR VAR VAR(VAR VAR * VAR) { VAR VAR *VAR = VAR->VAR; VAR (VAR->VAR && VAR->VAR) { VAR(VAR, VAR->VAR - 1); } VAR 0; } VAR VAR VAR(VAR VAR *VAR) { VAR* VAR = VAR; VAR VAR* VAR = VAR;  /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. */ VAR ((VAR->VAR[0] == VAR) && (VAR->VAR[0] != 0)) { VAR->VAR = (VAR << 16); VAR(VAR); VAR 0; } VAR = (VAR*)VAR->VAR->VAR->VAR[0]; VAR (!VAR) { VAR VAR; } VAR(); VAR ((VAR->VAR) & VAR) VAR VAR;   VAR((VAR = (VAR VAR*) (VAR->VAR->VAR)) == VAR) { /* * VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR * VAR VAR VAR VAR. VAR VAR VAR VAR VAR * VAR VAR VAR. */ VAR ((VAR = VAR(VAR, (VAR)VAR->VAR->VAR, (VAR)VAR->VAR->VAR, VAR->VAR->VAR)) == VAR) {   VAR->VAR = (VAR << 16); VAR(VAR); VAR 0; } VAR->VAR->VAR = VAR; } VAR->VAR = VAR->VAR; /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, * VAR VAR VAR VAR VAR VAR VAR. */ VAR (VAR->VAR & VAR ) { VAR VAR; } VAR VAR(VAR, VAR, VAR); } VAR VAR(VAR) VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR[]) { VAR VAR=-1; VAR VAR=-1; VAR VAR=-1;   VAR (VAR < 0x2000 ) {  VAR = 18; VAR = 2; }  VAR VAR (VAR < 0x20000) { VAR = 64; VAR = 32; }  VAR VAR (VAR < 0x40000) { VAR = 65; VAR = 63; }  VAR VAR (VAR < 0x80000) { VAR = 128; VAR = 63; }  VAR { VAR = 255; VAR = 63; } VAR = VAR(VAR, VAR * VAR);  VAR(VAR->VAR == 5) {  VAR = 252; VAR = 63; VAR = 1111; } VAR[0] = VAR; VAR[1] = VAR; VAR[2] = VAR; VAR(""VAR: VAR\VAR""); VAR 0; } VAR VAR VAR *VAR(VAR VAR *VAR) { VAR* VAR; VAR = (VAR *) VAR->VAR[0]; VAR (VAR *) (VAR->VAR); } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR VAR* VAR; VAR VAR; VAR VAR; VAR* VAR; VAR VAR;  VAR(&VAR); VAR (VAR = VAR; VAR; VAR = VAR->VAR) { VAR (VAR->VAR == VAR) { VAR;  } } VAR(&VAR); VAR (VAR == VAR) { VAR 0; } VAR = VAR->VAR; VAR(VAR, ""VAR VAR VAR VAR VAR: %VAR\VAR\VAR"", VAR); VAR(VAR, ""%VAR\VAR"", VAR->VAR); VAR(VAR, ""VAR VAR=VAR%VAR VAR VAR=/VAR/%VAR VAR=%VAR\VAR"", VAR->VAR->VAR, VAR->VAR, VAR->VAR); VAR(VAR, ""\VAR VAR VAR = %VAR\VAR\VAR VAR VAR = %VAR\VAR\VAR VAR VAR = %VAR\VAR\VAR"", VAR->VAR, (VAR) VAR->VAR , VAR->VAR); VAR(VAR, ""VAR:\VAR""); VAR(VAR = 0; VAR < VAR; VAR++) { VAR(VAR = 0; VAR < VAR; VAR++) { VAR = VAR->VAR[VAR].VAR[VAR]; VAR(VAR) { VAR(VAR,""\VAR%-24.24s"", VAR->VAR->VAR); VAR(VAR,"" VAR: %-8.8s\VAR"", VAR->VAR->VAR); VAR = VAR->VAR->VAR.VAR; VAR(VAR, ""\VAR=%VAR, (VAR=%VAR, VAR=%VAR, VAR=%VAR) (%VAR)\VAR\VAR"", VAR, (VAR)VAR->VAR, (VAR)VAR->VAR, VAR->VAR, VAR(VAR->VAR)? ""VAR"":""VAR""); VAR = VAR->VAR; } } } VAR 0; } /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR' */ VAR VAR VAR(VAR * VAR, VAR *VAR) {  VAR (VAR)(VAR VAR)VAR;  VAR VAR = 0; VAR VAR, VAR; VAR(VAR->VAR->VAR, VAR); VAR = VAR(VAR->VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR (VAR->VAR[VAR] == VAR) { VAR->VAR[VAR] = VAR; VAR; } } VAR(VAR->VAR->VAR, VAR); VAR (VAR >= VAR) { VAR(VAR""%VAR: VAR VAR VAR "" ""VAR VAR\VAR"", VAR->VAR); VAR (VAR)-1; } VAR VAR;  } /* * VAR VAR VAR VAR 'VAR' VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR *VAR(VAR *VAR, VAR VAR) {  VAR (VAR *)(VAR VAR)VAR;  VAR *VAR = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR; VAR VAR;  } /*=========================================================================== * VAR VAR VAR *=========================================================================== */ VAR VAR VAR(VAR VAR * VAR) { VAR* VAR = VAR;  VAR VAR* VAR;  VAR VAR[5]; VAR VAR; VAR = (VAR*) VAR->VAR->VAR->VAR[0]; VAR(VAR""%VAR: VAR VAR VAR\VAR"",VAR->VAR); VAR ((VAR = (VAR*) (VAR->VAR->VAR)) == VAR) { VAR(VAR ""%VAR: VAR VAR VAR: VAR VAR VAR VAR\VAR"",VAR->VAR); VAR VAR; } VAR(VAR, 0, VAR(VAR)); VAR[0] = VAR|VAR; VAR[1] = VAR<<24|VAR<<12|VAR->VAR; VAR[2] = 0; VAR[3]= 0;  VAR[4] = VAR(VAR)->VAR + 1; VAR (VAR->VAR) VAR(VAR->VAR->VAR); VAR = VAR(VAR, VAR, VAR(VAR), VAR); VAR (VAR->VAR) VAR(VAR->VAR->VAR); VAR (VAR != 0) { VAR(VAR == -VAR ){ VAR(VAR""%VAR: VAR VAR VAR VAR\VAR"",VAR->VAR); VAR VAR; } VAR(VAR""%VAR: VAR VAR.\VAR"",VAR->VAR); VAR VAR; } VAR(VAR""%VAR: VAR VAR.\VAR"",VAR->VAR); VAR VAR; }     VAR VAR VAR(VAR VAR* VAR) { VAR* VAR; VAR VAR[4]; VAR VAR; VAR VAR; VAR VAR* VAR = VAR->VAR->VAR; VAR = (VAR*) VAR->VAR->VAR->VAR[0]; VAR(VAR""%VAR: VAR VAR VAR VAR\VAR"",VAR->VAR); VAR (!VAR) { VAR(VAR""%VAR: VAR VAR: VAR VAR VAR\VAR"",VAR->VAR); VAR VAR; } VAR(VAR, 0, VAR(VAR)); VAR[0] = VAR|VAR; VAR[1] = (VAR<<24|VAR<<12|VAR->VAR); VAR[2] = 0; VAR[3] = 0; VAR (VAR->VAR) VAR(VAR->VAR->VAR); VAR = VAR->VAR; VAR->VAR |= VAR; VAR = VAR(VAR, VAR,VAR(VAR), VAR); VAR->VAR = VAR; VAR (VAR->VAR) VAR(VAR->VAR->VAR); VAR (VAR != 0) { VAR(VAR == -VAR ){ VAR(VAR""%VAR: VAR VAR VAR VAR\VAR"",VAR->VAR); VAR VAR; } VAR(VAR""%VAR: VAR VAR VAR\VAR"",VAR->VAR); VAR VAR; } VAR { VAR(VAR""%VAR: VAR VAR VAR\VAR"",VAR->VAR); VAR VAR; } }   VAR VAR VAR(VAR VAR* VAR) { VAR* VAR; VAR VAR[4]; VAR VAR; VAR = (VAR*)VAR->VAR->VAR->VAR[0]; VAR(VAR, 0, VAR(VAR)); VAR(VAR""%VAR: VAR VAR: VAR VAR %VAR: VAR: %VAR\VAR"",VAR->VAR, VAR->VAR->VAR,VAR->VAR[VAR->VAR->VAR].VAR ); VAR[0] = VAR|VAR; VAR[1] = (VAR<<24|VAR<<12|VAR->VAR[VAR->VAR->VAR].VAR); VAR[2] = 0; VAR[3] = 0; VAR (VAR->VAR) VAR(VAR->VAR->VAR); VAR = VAR(VAR, VAR,VAR(VAR), VAR); VAR (VAR->VAR) VAR(VAR->VAR->VAR); VAR (VAR != 0) { VAR(VAR""%VAR: VAR VAR VAR.\VAR"",VAR->VAR); VAR VAR; } VAR { VAR(VAR""%VAR: VAR VAR VAR.\VAR"",VAR->VAR); VAR VAR; } }  VAR VAR VAR(VAR VAR* VAR) { VAR* VAR; VAR VAR; VAR VAR[32]; VAR = (VAR*)VAR->VAR->VAR->VAR[0]; VAR(VAR, VAR->VAR, VAR(VAR)); VAR(VAR""%VAR: VAR VAR: VAR VAR %VAR: VAR: %VAR\VAR"", VAR, VAR->VAR->VAR, VAR->VAR[VAR->VAR->VAR].VAR); VAR = VAR(VAR); VAR(VAR == 0){ VAR(VAR""%VAR: VAR VAR VAR\VAR"", VAR); VAR VAR; } VAR { VAR(VAR""%VAR: VAR VAR VAR (%VAR)\VAR"", VAR, VAR); VAR VAR; } } VAR VAR VAR(VAR VAR* VAR) { VAR VAR; VAR(VAR->VAR->VAR->VAR); VAR = VAR(VAR); VAR(VAR->VAR->VAR->VAR); VAR VAR; }  VAR VAR VAR(VAR* VAR) { VAR VAR; VAR->VAR |= VAR;  VAR ((VAR=VAR(VAR)) < 0) { VAR(VAR ""%VAR: VAR VAR VAR\VAR"", VAR->VAR); VAR(VAR); VAR VAR; } VAR ((VAR=VAR()) < 0) { VAR(VAR); VAR VAR; } VAR(""%VAR: VAR VAR VAR\VAR"",VAR->VAR); VAR ((VAR=VAR(VAR)) < 0) { VAR(VAR); VAR VAR; } VAR(""%VAR: VAR VAR VAR\VAR"",VAR->VAR); VAR ((VAR=VAR(VAR)) < 0){ VAR(VAR); VAR VAR; } VAR ((VAR=VAR(VAR)) < 0){ VAR(VAR); VAR VAR; } VAR->VAR &= ~VAR; VAR(VAR->VAR, VAR); VAR 0;  } /*=========================================================================== * *=========================================================================== */ VAR VAR VAR(VAR) { VAR *VAR, *VAR; VAR VAR *VAR, *VAR; VAR(VAR ""VAR VAR VAR VAR VAR.\VAR""); VAR(VAR "" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR\VAR"");  /* VAR VAR VAR VAR VAR VAR VAR VAR * VAR-VAR */ VAR (VAR = VAR; VAR; VAR = VAR) { VAR = VAR->VAR; VAR(VAR); }   /* VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR */ VAR(VAR = VAR; VAR;) { VAR = VAR; VAR = VAR->VAR; VAR(VAR); }  VAR = VAR; VAR(VAR ""VAR VAR VAR VAR.\VAR""); } VAR VAR VAR(VAR VAR* VAR, VAR VAR* VAR) { VAR* VAR = VAR; VAR* VAR = VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR VAR *VAR = VAR; VAR VAR *VAR = VAR; VAR VAR = 0; VAR VAR = VAR; VAR(VAR(VAR)) { VAR -VAR; } VAR (VAR(VAR, ""VAR"")) { VAR(""VAR: VAR: VAR VAR VAR VAR\VAR""); VAR -VAR; } VAR(VAR); /* * VAR VAR VAR VAR VAR VAR VAR. */ VAR (VAR(VAR) > 4 && VAR(&VAR->VAR) > VAR(32) && VAR(&VAR->VAR, VAR(64)) == 0) VAR = 1; VAR (!VAR && VAR(&VAR->VAR, VAR(32)) != 0) VAR -VAR;  VAR(&VAR->VAR, VAR(32)); VAR = VAR(VAR,0); VAR = VAR(VAR,0);  VAR(VAR->VAR == VAR){ VAR(VAR->VAR >=0xc032 && VAR->VAR <= 0xc03b){  VAR = 0x400000; } VAR {  VAR(VAR > 0x100000 ){ VAR = 0x100000; } } } VAR {  VAR = VAR(VAR,1); VAR = VAR(VAR,1); VAR = VAR; }  /* * VAR VAR VAR 64 VAR VAR VAR VAR VAR VAR: * ""VAR VAR VAR VAR VAR VAR"" * * VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR (VAR == VAR) { VAR (VAR > 128) VAR = 128; VAR (VAR > 524288) VAR = 524288; } VAR { VAR (VAR > 524288) VAR = 524288; }  VAR = VAR(VAR,VAR); VAR (!VAR) { VAR(VAR); VAR(""VAR: VAR: VAR VAR VAR\VAR""); VAR -VAR; } VAR(VAR == VAR) { VAR = VAR(VAR, VAR ); VAR (!VAR) { VAR(""VAR: VAR: VAR VAR VAR VAR VAR\VAR""); VAR(VAR); VAR(VAR); VAR -VAR; } } VAR { VAR = VAR; }  VAR = VAR(VAR(VAR), VAR); VAR (!VAR) { VAR (VAR != VAR) VAR(VAR); VAR(VAR); VAR(VAR); VAR -VAR; } VAR(&VAR); VAR(VAR != VAR){ VAR(VAR = VAR; VAR->VAR; VAR = VAR->VAR); VAR->VAR = VAR; } VAR { VAR = VAR; } VAR->VAR = VAR; VAR->VAR = VAR; VAR(VAR->VAR, ""VAR%VAR"", VAR); VAR++; VAR(&VAR); VAR->VAR = VAR; VAR->VAR = VAR;  VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR+0x30; VAR->VAR = VAR+0x40; VAR->VAR = VAR+0x44; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = 0; VAR->VAR = VAR; VAR->VAR = 0; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR;  VAR(&VAR->VAR); VAR(VAR == 0){ VAR(VAR ""VAR VAR VAR VAR"" "" %VAR VAR %VAR VAR=%VAR VAR=%VAR%VAR\VAR"", VAR-1, VAR, VAR, VAR->VAR, VAR ? "" (64-VAR VAR)"" : """"); } VAR { VAR(VAR""VAR VAR VAR VAR %VAR VAR=%VAR%VAR\VAR"", VAR-1, VAR->VAR, VAR ? "" (64-VAR VAR)"" : """"); VAR(VAR"" VAR %VAR - VAR= %VAR\VAR"",VAR,VAR); VAR(VAR"" VAR %VAR - VAR= %VAR\VAR"",VAR,VAR); } VAR (VAR (VAR->VAR, VAR, VAR, VAR->VAR, VAR)) { VAR(VAR""%VAR: VAR'VAR VAR VAR %VAR\VAR"", VAR->VAR, VAR->VAR); VAR(VAR); VAR -VAR; } VAR 0; } VAR VAR VAR(VAR* VAR) { VAR* VAR; VAR* VAR; VAR VAR* VAR; VAR VAR* VAR; VAR VAR; VAR VAR; VAR VAR* VAR; VAR VAR* VAR; VAR(&VAR); VAR(VAR->VAR){ VAR(VAR->VAR->VAR, VAR); } VAR = VAR; VAR( VAR = VAR; VAR; VAR = VAR,VAR=VAR->VAR){ VAR(VAR == VAR) { VAR(VAR) { VAR->VAR = VAR->VAR; } VAR { VAR = VAR->VAR; } VAR; } } VAR--; VAR(&VAR); VAR(VAR->VAR); VAR(VAR->VAR); VAR(VAR->VAR != VAR->VAR){ VAR(VAR->VAR); } VAR(VAR->VAR) VAR(VAR->VAR); VAR(VAR->VAR) { VAR(&VAR->VAR->VAR, VAR->VAR->VAR * VAR->VAR->VAR << 2, VAR->VAR, VAR->VAR); } VAR(VAR->VAR) { VAR(&VAR->VAR->VAR, VAR->VAR, VAR->VAR, VAR->VAR); } VAR(VAR->VAR) { VAR(&VAR->VAR->VAR, VAR(VAR), VAR->VAR, VAR->VAR); } VAR(VAR->VAR) { VAR(&VAR->VAR->VAR, VAR->VAR * VAR * 4, VAR->VAR, VAR->VAR); } VAR(VAR = VAR->VAR; VAR ; VAR = VAR){ VAR = VAR->VAR; VAR(VAR); } VAR(VAR = 0 ; VAR < VAR->VAR ; VAR++){ VAR(VAR = 0; VAR < VAR; VAR++){ VAR(VAR->VAR[VAR].VAR[VAR] != VAR){ VAR(VAR = VAR->VAR[VAR].VAR[VAR]; VAR; VAR = VAR){ VAR = VAR->VAR; VAR(VAR); } } } } VAR(VAR->VAR); VAR (VAR) VAR(VAR, VAR(VAR, VAR->VAR)); VAR(VAR); VAR(VAR <= 0){ VAR(VAR, VAR); VAR (VAR) { VAR(VAR); VAR = VAR; } } } VAR VAR VAR* VAR(VAR* VAR, VAR VAR, VAR VAR, VAR VAR) { VAR VAR* VAR; VAR (VAR >= VAR) VAR VAR; VAR = VAR->VAR[VAR].VAR[VAR]; VAR(!VAR || VAR->VAR == 0) { VAR VAR; }  VAR(VAR->VAR == VAR){ VAR VAR; }  VAR(VAR=VAR->VAR ; VAR ; VAR = VAR->VAR){ VAR(VAR->VAR == VAR){ VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR, VAR VAR) {    VAR(VAR); VAR VAR = 0; VAR VAR = 0; VAR VAR *VAR, *VAR; VAR VAR *VAR = VAR(VAR(VAR VAR), VAR); VAR(VAR, VAR); VAR (!VAR) VAR -VAR; /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(&VAR, VAR);   VAR->VAR = VAR; VAR = VAR; VAR++; VAR &= 0x7fff; VAR->VAR = VAR; VAR(&VAR, VAR); VAR->VAR = &VAR; VAR->VAR = -VAR; VAR(&VAR, &VAR); VAR[2] |= 0x80000000 | ((VAR)VAR->VAR); VAR *= VAR; VAR((VAR = VAR(VAR, VAR, VAR)) == 0){ VAR(VAR); VAR(VAR->VAR) VAR(VAR->VAR->VAR); VAR (!VAR) VAR(); VAR{ VAR = VAR(VAR); VAR (VAR == 0) {    VAR = -VAR; } } VAR(VAR->VAR) VAR(VAR->VAR->VAR); } VAR(&VAR, &VAR); VAR(VAR == -VAR){ VAR(VAR""VAR%VAR: VAR VAR VAR\VAR"",VAR->VAR);  VAR VAR; }  VAR = VAR; VAR(&VAR, VAR); VAR(VAR = VAR; VAR; VAR = VAR, VAR = VAR->VAR) { VAR(VAR == VAR) { VAR(VAR->VAR == VAR ) { VAR = -VAR; } VAR(VAR) { VAR->VAR = VAR->VAR; } VAR { VAR = VAR->VAR; } VAR; } } VAR(&VAR, VAR); VAR(VAR); VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) { VAR VAR = VAR; VAR VAR *VAR; VAR VAR = VAR + 30*VAR; VAR { VAR(); VAR = VAR(VAR->VAR); VAR (VAR != VAR) { VAR; } VAR(VAR(VAR,VAR)){ VAR(VAR""VAR%VAR: VAR VAR VAR VAR VAR!\VAR"", VAR->VAR); VAR -VAR; } VAR(1); } VAR(VAR == VAR); VAR = VAR->VAR + VAR; VAR(VAR, VAR, VAR); VAR();  VAR(VAR, VAR->VAR); VAR(); VAR 0; } VAR VAR VAR(VAR VAR, VAR VAR) { VAR VAR *VAR = VAR; /* * VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. VAR VAR, VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR, VAR VAR, VAR VAR * * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR'VAR VAR VAR VAR. */ VAR &= 0x7fff; VAR(&VAR); VAR(VAR = VAR; VAR; VAR = VAR->VAR) { VAR(VAR->VAR == VAR) { VAR->VAR = VAR; VAR(&VAR); VAR(VAR->VAR); VAR; } } VAR(&VAR);  VAR(VAR""VAR: VAR VAR VAR VAR %VAR VAR VAR VAR\VAR"",VAR); VAR(VAR"" VAR VAR VAR VAR:\VAR""); VAR(VAR = VAR; VAR; VAR = VAR->VAR) { VAR(VAR"" %VAR\VAR"",VAR->VAR); } VAR; } VAR VAR VAR(VAR* VAR) { VAR VAR[8]; VAR* VAR; VAR VAR; VAR VAR = VAR ; VAR VAR = VAR + (VAR*VAR); VAR(VAR->VAR == VAR) {  VAR = VAR + (25*VAR); } VAR { VAR(VAR); } VAR { VAR(); VAR = VAR(VAR->VAR); VAR (VAR != VAR) { VAR; } VAR(VAR(VAR,VAR)){ VAR(VAR""VAR VAR VAR VAR!\VAR""); VAR -VAR; } VAR(1); } VAR (VAR == VAR); VAR = VAR(&VAR->VAR->VAR, 4, &VAR, VAR); VAR(VAR == VAR) { VAR(VAR, VAR); VAR(VAR""VAR VAR VAR - VAR VAR VAR.\VAR""); VAR -VAR; } VAR[0]=VAR|VAR; VAR[1]=VAR<<24|VAR<<12|VAR; VAR[2]=0; VAR[3]=0; VAR[4]=0; VAR[5]=0; VAR[6]=VAR(VAR); VAR[7]=VAR(VAR); VAR(VAR->VAR+VAR, VAR, VAR(VAR)); VAR(); VAR(VAR, VAR->VAR); VAR(); VAR(*VAR == 0){ VAR(VAR(VAR,VAR)){ VAR(VAR""%VAR: VAR VAR VAR\VAR"",VAR->VAR); /* VAR VAR 4 VAR VAR ""VAR"" VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */  VAR -VAR; } VAR(); VAR(1); } VAR(*VAR == 0x01 ) { VAR(""%VAR: VAR VAR VAR...\VAR"", VAR->VAR);   VAR { VAR(); VAR = VAR(VAR->VAR); VAR (VAR != VAR) { VAR; } VAR(VAR(VAR,VAR)){ VAR(VAR ""%VAR:VAR VAR VAR VAR VAR.\VAR"",VAR->VAR); /* VAR VAR 4 VAR VAR ""VAR"" VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */  VAR -VAR; } VAR(1); } VAR (VAR == VAR);  VAR(VAR, VAR); } VAR(VAR); VAR(*VAR == 0x02 || VAR->VAR->VAR != VAR) { VAR(VAR""%VAR: VAR VAR, VAR VAR VAR\VAR"", VAR->VAR); } VAR { VAR(""%VAR: VAR VAR.\VAR"", VAR->VAR); } VAR(&VAR->VAR->VAR, 4, VAR, VAR);    VAR(20000);  VAR 0; } VAR VAR VAR(VAR* VAR) { VAR VAR; VAR VAR; VAR VAR; VAR VAR *VAR; VAR *VAR = VAR->VAR; VAR VAR = 0; VAR VAR; VAR VAR; VAR VAR[10];  VAR VAR* VAR; VAR (VAR == VAR) { VAR(VAR ""%VAR: VAR VAR VAR???\VAR"",VAR->VAR); VAR -1; } VAR = VAR->VAR; VAR -= 3; VAR /= 9; VAR(VAR=0;VAR<VAR;VAR++) { VAR( VAR->VAR[VAR].VAR != 0xfff){ /* * VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR, VAR VAR VAR VAR VAR VAR (VAR VAR). */ VAR( VAR->VAR[VAR].VAR != VAR && VAR->VAR[VAR].VAR != VAR && VAR->VAR[VAR].VAR != VAR ){ VAR; } VAR = VAR->VAR[VAR].VAR;  VAR(VAR(VAR, VAR, 0x8000, -1, VAR, 32)<0) { VAR; } VAR = VAR[0]>>16; VAR = VAR[1]; VAR = VAR((VAR VAR *)&VAR[2]); VAR(VAR >= VAR) {  VAR(VAR""%VAR: VAR VAR %VAR VAR VAR VAR \VAR"", VAR->VAR, VAR); VAR; } VAR (VAR >= VAR){ VAR(VAR""%VAR: VAR VAR %VAR VAR VAR VAR \VAR"", VAR->VAR, VAR); VAR; } VAR(VAR > VAR->VAR){ VAR->VAR = VAR; } VAR(VAR > VAR->VAR){ VAR->VAR = VAR; } VAR(VAR > VAR->VAR){ VAR->VAR = VAR; } VAR; } VAR = VAR(VAR(VAR VAR), VAR); VAR(VAR==VAR) { VAR(VAR""%VAR: VAR VAR VAR VAR VAR VAR VAR.\VAR"",VAR->VAR); VAR -VAR; } VAR->VAR = VAR; VAR->VAR = VAR; VAR(&VAR->VAR, &VAR->VAR[VAR], VAR(VAR)); VAR->VAR = 0; VAR = VAR->VAR.VAR; VAR(VAR, VAR); VAR(VAR, VAR); } VAR = 0; VAR(VAR = VAR->VAR; VAR ; VAR = VAR->VAR) { VAR(VAR->VAR.VAR == VAR || VAR->VAR.VAR == VAR){ VAR = VAR->VAR.VAR;   VAR(VAR > VAR->VAR){ VAR->VAR = VAR; } VAR->VAR[VAR].VAR = VAR->VAR.VAR; VAR->VAR[VAR].VAR = VAR; VAR(VAR(VAR, VAR, 0x0200, -1, VAR, 28)>=0) { VAR->VAR[VAR].VAR = VAR[1]; VAR(""VAR %VAR - VAR VAR %VAR.\VAR"", VAR, VAR[1]); }  VAR++; VAR(VAR >= VAR) {  VAR(VAR""%VAR: VAR VAR %VAR VAR VAR VAR - VAR\VAR"", VAR->VAR, VAR); VAR; } } }  VAR(VAR = VAR->VAR; VAR ; VAR = VAR->VAR) { VAR(VAR->VAR.VAR == VAR || VAR->VAR.VAR == VAR || VAR->VAR.VAR == VAR ){ VAR = VAR->VAR.VAR; VAR = -1;  VAR(VAR(VAR, VAR, 0x8000, -1, VAR, 32)>=0) { VAR = VAR[0]>>16; VAR = VAR[1]; VAR = VAR((VAR VAR *)&VAR[2]); VAR(VAR >= VAR) {  VAR; } VAR (VAR >= VAR) { VAR; } VAR( VAR->VAR[VAR].VAR[VAR] == VAR){ VAR = VAR(VAR(VAR VAR),VAR); VAR(VAR == VAR) { VAR -VAR; } VAR->VAR[VAR].VAR[VAR] = VAR; } VAR { VAR( VAR = VAR->VAR[VAR].VAR[VAR]; VAR->VAR; VAR = VAR->VAR){ } VAR->VAR = VAR(VAR(VAR VAR),VAR); VAR(VAR->VAR == VAR) { VAR -VAR; } VAR = VAR->VAR; } VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = (VAR[0])&0xff; VAR->VAR = (VAR[0]>>8)&0xff; VAR(VAR > VAR->VAR){ VAR->VAR = VAR; } VAR(VAR > VAR->VAR){ VAR->VAR = VAR; } } VAR(VAR == -1){ VAR(VAR""VAR VAR VAR VAR VAR VAR %VAR\VAR"", VAR->VAR.VAR); } } } VAR 0; } /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR - VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR VAR(VAR* VAR, VAR VAR *VAR) { VAR(&VAR); VAR->VAR=VAR; VAR->VAR=VAR; VAR->VAR=VAR->VAR; VAR->VAR=VAR; VAR (VAR->VAR != VAR){ VAR->VAR->VAR=VAR; } VAR->VAR=VAR; *VAR->VAR = 0; VAR(&VAR); VAR 0; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR VAR; VAR* VAR; VAR(&VAR);   VAR = VAR(VAR); VAR (VAR >= VAR) { VAR(&VAR); VAR -VAR; } VAR(&VAR); VAR (VAR = VAR; VAR; VAR = VAR->VAR) { VAR (VAR->VAR == VAR) { VAR;  } } VAR (VAR == VAR) { VAR(&VAR); VAR(&VAR); VAR -VAR; }     VAR->VAR = 1; VAR(&VAR); VAR(&VAR); VAR 0; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR VAR; VAR* VAR; VAR = VAR(VAR); VAR (VAR >= VAR) { VAR -VAR; } VAR(&VAR); VAR (VAR = VAR; VAR; VAR = VAR->VAR) { VAR (VAR->VAR == VAR) { VAR;  } } VAR(&VAR); VAR (VAR == VAR) { VAR -VAR; } VAR->VAR = 0; VAR 0; } VAR VAR VAR(VAR* VAR, VAR VAR *VAR) { VAR VAR[VAR]; VAR* VAR = VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR *VAR = VAR; VAR VAR * VAR = VAR; VAR **VAR = VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR *VAR = VAR; VAR VAR; VAR VAR = 0; VAR(&VAR, 0, VAR*4);  VAR(VAR(VAR, &VAR[0])){ VAR -VAR; } VAR = VAR>>16; VAR = &VAR[VAR]; VAR(VAR > VAR){ VAR -VAR; } VAR *= 4;   VAR(VAR(VAR, VAR, VAR)) { VAR -VAR; } VAR(VAR, &VAR[0]); VAR = VAR>>16; VAR(VAR > VAR){ VAR = VAR; } VAR *= 4; VAR = VAR(VAR*4, VAR); VAR(VAR == VAR) { VAR(VAR""%VAR: VAR VAR VAR VAR VAR\VAR"",VAR->VAR); VAR -VAR; } VAR = (VAR[0]>>4)&0xf; VAR[2] = 0x40000000;  VAR[3] = VAR(VAR, VAR); VAR (VAR[3] == (VAR)-1) { VAR = -VAR; VAR VAR; } VAR = VAR(VAR->VAR, VAR(*VAR), VAR); VAR (!VAR) { VAR = -VAR; VAR VAR; } VAR(VAR) {  VAR VAR *VAR = (VAR VAR*) (VAR+VAR); VAR = (VAR - VAR*4) / VAR(VAR VAR); VAR (VAR > VAR->VAR){ VAR(VAR""%VAR:VAR VAR VAR VAR VAR (%VAR)\VAR"", VAR->VAR,VAR); VAR = -VAR; VAR VAR; } VAR(VAR = 0; VAR < VAR; VAR++) { VAR VAR; VAR (!(VAR[VAR].VAR & 0x10000000 )) { VAR(VAR""%VAR:VAR VAR VAR %VAR - VAR VAR (%VAR)\VAR"",VAR->VAR,VAR, VAR[VAR].VAR); VAR = -VAR; VAR VAR; } VAR = VAR[VAR].VAR & 0xffffff;  VAR = VAR(&VAR->VAR->VAR, VAR, &VAR, VAR); VAR(!VAR) { VAR(VAR""%VAR: VAR VAR VAR VAR VAR - VAR = %VAR VAR VAR %VAR VAR %VAR\VAR"", VAR->VAR,VAR,VAR,VAR); VAR = -VAR; VAR VAR; } VAR[VAR++] = VAR;   VAR(VAR[VAR].VAR & 0x04000000 ) {  VAR (VAR(VAR,(VAR VAR *)(VAR)VAR[VAR].VAR, VAR)) { VAR(VAR""%VAR: VAR VAR VAR VAR VAR %VAR VAR VAR\VAR"",VAR->VAR,VAR); VAR = -VAR; VAR VAR; } }  VAR[VAR].VAR = VAR; } } VAR { /* * VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR */ VAR (VAR->VAR) { VAR(VAR->VAR); VAR(VAR->VAR->VAR, VAR); } VAR = VAR(VAR, VAR, VAR, VAR); VAR (VAR != 0) VAR(""VAR: VAR VAR VAR %VAR %VAR\VAR"", VAR, VAR); VAR (VAR->VAR) { VAR(VAR->VAR->VAR, VAR); VAR(VAR->VAR); } } VAR (VAR == -VAR); VAR(VAR){ VAR VAR; } VAR(VAR) {  VAR VAR;  VAR VAR* VAR; VAR VAR;  VAR(&VAR, 0, VAR*4);  VAR(VAR(VAR, &VAR[0])){ VAR = -VAR; VAR VAR; } VAR = VAR>>16; VAR *= 4; VAR (VAR > VAR) { VAR = -VAR; VAR VAR; }  VAR (VAR (VAR, VAR, VAR)) { VAR = -VAR; VAR VAR; } VAR = (VAR - VAR*4) / VAR(VAR VAR);  VAR = (VAR VAR*)(VAR + VAR); VAR (VAR = 0; VAR < VAR; VAR++) {  VAR(! (VAR[VAR].VAR & 0x4000000 )) { VAR = VAR[VAR].VAR & 0xffffff;  VAR (VAR((VAR VAR *)(VAR)VAR[VAR].VAR,VAR[VAR], VAR)) { VAR(VAR""%VAR: VAR VAR VAR %VAR VAR VAR %VAR\VAR"",VAR->VAR, VAR[VAR], VAR[VAR].VAR); VAR = -VAR; VAR VAR; } } } }  VAR (VAR) {  VAR(VAR(VAR+2, VAR+2, VAR(VAR)*2)) { VAR(VAR""%VAR: VAR VAR VAR VAR VAR VAR VAR\VAR"",VAR->VAR); VAR = -VAR; } VAR(VAR(VAR, VAR, VAR)) { VAR(VAR""%VAR: VAR VAR VAR VAR VAR VAR\VAR"",VAR->VAR); VAR = -VAR; } } VAR: VAR (VAR != -VAR && VAR != -VAR) { VAR VAR *VAR = (VAR VAR*) (VAR +VAR); VAR(VAR) { VAR(VAR[--VAR]) { VAR(&VAR->VAR->VAR, VAR[VAR].VAR & 0xffffff, VAR[VAR], VAR[VAR].VAR); } } } VAR: VAR(VAR); VAR(VAR); VAR VAR; }  VAR VAR VAR(VAR* VAR) {    VAR->VAR = VAR; }   VAR VAR VAR(VAR* VAR) {    VAR->VAR = VAR; }   VAR VAR VAR(VAR* VAR) {    VAR->VAR = VAR; }    VAR VAR VAR(VAR* VAR) {    VAR (VAR.VAR) { VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR:  VAR->VAR = VAR; VAR; } }  /* * VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR - VAR VAR'VAR VAR. */  VAR VAR VAR(VAR VAR *VAR) { VAR VAR; VAR(&VAR, 0, VAR(VAR)); VAR.VAR = VAR; VAR.VAR = 0; VAR.VAR = 0; VAR.VAR = 0; VAR.VAR = VAR; VAR.VAR = VAR.VAR;  VAR(&VAR);  VAR(&VAR);  VAR(&VAR);  VAR(&VAR);  VAR.VAR = 0xff ;  VAR (VAR(VAR, &VAR, VAR(VAR))){ VAR(VAR""VAR: VAR VAR VAR VAR VAR VAR\VAR""); VAR -VAR; } VAR 0; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR; VAR VAR = 0; VAR* VAR; VAR VAR = 0; VAR VAR *VAR = (VAR VAR *)VAR; VAR = VAR(VAR); VAR (VAR >= VAR){ VAR -VAR; } VAR(&VAR); VAR (VAR = VAR; VAR; VAR = VAR->VAR) { VAR (VAR->VAR == VAR) { VAR;  } } VAR(&VAR); VAR(VAR == VAR){ VAR -VAR; } VAR((VAR VAR) VAR->VAR & VAR ) VAR(2); VAR (VAR) {  VAR VAR: VAR (VAR(VAR, &VAR, VAR(VAR))) { VAR -VAR; } VAR; VAR VAR: VAR VAR(VAR, VAR); VAR VAR:{ VAR VAR;    VAR(&VAR, 0, VAR(VAR)); VAR.VAR = VAR->VAR; VAR.VAR = (VAR) VAR->VAR; VAR.VAR = VAR(VAR); VAR.VAR = VAR->VAR->VAR->VAR; VAR.VAR=VAR(VAR->VAR->VAR); VAR.VAR = VAR->VAR->VAR; VAR.VAR = VAR | VAR | VAR; VAR(VAR(VAR, &VAR, VAR(VAR))){ VAR(VAR""%VAR: VAR VAR VAR VAR VAR VAR\VAR"",VAR->VAR); VAR -VAR; } VAR; } VAR VAR: VAR VAR(VAR); VAR VAR:{ VAR VAR; VAR = (VAR)VAR(VAR); VAR (VAR(VAR, &VAR, VAR(VAR))) { VAR -VAR; } VAR; } VAR VAR: { VAR VAR *VAR = VAR->VAR; VAR (VAR) VAR(VAR->VAR, VAR); VAR(VAR); VAR (VAR) VAR(VAR->VAR, VAR); VAR; } VAR VAR: VAR(VAR); VAR; VAR: VAR -VAR; } VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR *VAR; VAR VAR; VAR = VAR(VAR); VAR(&VAR); VAR = VAR(VAR, VAR, VAR, VAR); VAR(&VAR); VAR VAR; }  VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR VAR) { VAR VAR *VAR; VAR VAR; VAR = VAR(VAR); VAR(&VAR); VAR(VAR) { VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR (VAR & 0xFFFF): VAR VAR: VAR = VAR(VAR, VAR, VAR, VAR); VAR; VAR: VAR = -VAR; } VAR(&VAR); VAR VAR; }  VAR VAR VAR(VAR VAR, VAR *VAR) { VAR VAR* VAR; VAR* VAR = VAR; VAR VAR; VAR VAR *VAR; VAR VAR=0; VAR VAR; VAR VAR = 0; VAR VAR = 0; VAR (VAR == VAR){ VAR(VAR""VAR: VAR VAR\VAR""); VAR VAR; } VAR(VAR->VAR) VAR(VAR->VAR->VAR, VAR); VAR( VAR(VAR->VAR) & VAR) { VAR = VAR(VAR->VAR); VAR(VAR == VAR){  VAR(); VAR = VAR(VAR->VAR); VAR(VAR == VAR){  VAR(VAR""VAR: VAR VAR VAR VAR VAR\VAR""); VAR VAR; } } VAR (VAR->VAR <= VAR && VAR < VAR->VAR + (VAR->VAR * VAR * 4)) { VAR = (VAR *)VAR->VAR + (VAR - VAR->VAR); } VAR {  VAR(VAR ""VAR: VAR VAR VAR VAR VAR\VAR""); VAR = (VAR *)VAR(VAR); } VAR (VAR(VAR) & VAR) { VAR VAR = VAR(VAR+28); VAR VAR *VAR; VAR VAR; VAR(""%VAR: VAR VAR\VAR"",VAR->VAR); VAR(VAR >= 0x100000){ VAR(VAR""%VAR: VAR VAR VAR (%VAR)- VAR VAR\VAR"",VAR->VAR,VAR); VAR(VAR,VAR->VAR); VAR; }  VAR = VAR->VAR + VAR; VAR = VAR(VAR+12); VAR(VAR, VAR+12); VAR(VAR, VAR); } VAR = VAR(VAR+8); VAR(VAR & 0x40000000){  VAR *VAR = VAR(VAR, VAR(VAR+12)); VAR( VAR != VAR) { VAR(VAR, VAR, VAR * 4); }  } VAR(VAR & 0x80000000){  VAR = VAR(VAR+16); VAR(VAR >> 24){ VAR &= 0xffff;  } VAR { VAR = VAR; } VAR(!(VAR & 0x40000000)) { /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR 0 VAR VAR VAR */ VAR = VAR(VAR->VAR, VAR(VAR + 12) - 1); VAR(VAR != VAR) { VAR(VAR""%VAR: VAR VAR VAR VAR VAR VAR VAR - VAR=%VAR VAR=%VAR\VAR"", VAR->VAR, VAR, VAR); } } VAR(VAR, VAR); } VAR {  /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR 0 VAR VAR VAR */ VAR = VAR(VAR->VAR, VAR(VAR + 12) - 1); VAR(VAR != VAR){ VAR(VAR); VAR(VAR, VAR); } } VAR(VAR, VAR->VAR); VAR(); VAR(); } VAR = 1; VAR: VAR(VAR->VAR) VAR(VAR->VAR->VAR, VAR); VAR VAR(VAR); } VAR VAR VAR(VAR* VAR, VAR VAR* VAR, VAR VAR* VAR) { VAR VAR; VAR VAR[VAR]; VAR* VAR; VAR* VAR; VAR *VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR(VAR, 0 , VAR(VAR)); VAR = VAR(VAR); VAR = 0x00000000; VAR = 0x00000000;  VAR(VAR) { /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR, VAR VAR VAR VAR * VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR 0 VAR * VAR->VAR[0] VAR VAR VAR VAR */ VAR(VAR->VAR){ VAR VAR: VAR =0x40000000;  VAR; VAR VAR: VAR=0x04000000;  VAR =0x80000000;  VAR; VAR VAR: VAR; VAR VAR: VAR =0x40000000;   VAR; VAR: VAR(VAR""%VAR: VAR VAR 0x%VAR VAR VAR.\VAR"", VAR->VAR, VAR->VAR[0]); VAR->VAR = (VAR <<16); VAR(VAR); VAR 0; } }   VAR[1] = ((0xff<<24)|(VAR<<12)|VAR->VAR); VAR[2] = 0;  VAR[3] = VAR(VAR)->VAR + 1;   VAR[4] = VAR|(VAR<<16); VAR[5] = VAR->VAR;     VAR[6] = VAR|0x20a00000|VAR->VAR; VAR=VAR+7;  VAR(VAR, 0, 16); VAR(VAR, VAR->VAR, VAR->VAR); VAR+=4; VAR=VAR++;  VAR (VAR(VAR)) { VAR = 16;  *VAR++ = (0x7C<<24)+(2<<16)+0x02;  *VAR++ = 1 << VAR; } VAR { VAR = 14;  }  VAR = VAR(VAR); VAR(VAR < 0); VAR (VAR) { VAR VAR *VAR; VAR = 0; VAR(VAR, VAR, VAR, VAR) { VAR = VAR; *VAR++ = VAR|0x10000000|VAR(VAR); VAR+=VAR(VAR); VAR = VAR(VAR); *VAR++ = VAR(VAR); VAR (VAR(VAR)) *VAR++ = VAR(VAR);  VAR (VAR == VAR - 1) *VAR = VAR|0xD0000000|VAR(VAR); } VAR = VAR - VAR; *VAR = VAR; VAR(VAR->VAR && VAR != VAR->VAR){ VAR(VAR""VAR VAR %08X VAR VAR %08X\VAR"", VAR, VAR->VAR); } } VAR { *VAR = VAR = 0; VAR = 12; }  VAR[0] = VAR<<16 | ((VAR > 12) ? VAR : VAR);  VAR = VAR(VAR, VAR, VAR<<2); VAR (VAR == 0) { VAR 0; } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR *VAR) { VAR VAR *VAR; VAR = VAR(VAR, VAR(VAR*)); VAR (VAR == VAR) { VAR(""%VAR: VAR VAR VAR\VAR"", VAR->VAR); VAR -1; } VAR->VAR[0] = (VAR VAR)VAR; VAR->VAR = VAR; VAR->VAR = VAR->VAR->VAR; /* VAR VAR VAR, VAR VAR'VAR VAR VAR VAR VAR->VAR VAR * VAR->VAR */ VAR->VAR = 0; VAR->VAR = 0;  VAR->VAR = 16; VAR->VAR = 256; VAR->VAR = VAR->VAR + 1; VAR->VAR = 1; VAR->VAR = (VAR)VAR + VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR 0; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR* VAR; VAR VAR; VAR VAR; VAR VAR = VAR(VAR) & 0xff00;     VAR VAR = VAR(VAR+16) &0xffff; VAR = (VAR & 0xff); VAR = VAR >> 8;  VAR(VAR, VAR(VAR) - VAR(VAR+20)); VAR = (VAR*) VAR->VAR->VAR->VAR[0]; VAR->VAR[0] = '\0';  VAR(!(VAR & VAR)) { VAR(VAR & VAR) { VAR VAR: VAR->VAR = (VAR << 16);  VAR (VAR(VAR+20) < VAR->VAR) { VAR->VAR = (VAR <<16); VAR(VAR""%VAR: VAR VAR VAR\VAR"",VAR->VAR); } VAR; VAR VAR: VAR->VAR = (VAR << 16); VAR; VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR(VAR""%VAR: VAR VAR-VAR (%VAR,%VAR,%VAR) VAR VAR=0x%VAR, VAR VAR=0x%VAR, VAR=0x%VAR\VAR"", VAR->VAR, (VAR)VAR->VAR->VAR, (VAR)VAR->VAR->VAR, VAR->VAR->VAR, VAR, VAR, VAR->VAR[0]); VAR->VAR = (VAR << 16); VAR; VAR VAR: VAR VAR: VAR->VAR = (VAR << 16); VAR; VAR VAR: VAR VAR: VAR->VAR = (VAR << 16); VAR; VAR VAR: VAR(VAR""%VAR: VAR VAR VAR VAR\VAR"",VAR->VAR); VAR->VAR = (VAR << 16); VAR; VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR: VAR(VAR""%VAR: VAR VAR %0x-VAR(%VAR,%VAR,%VAR) VAR=0x%VAR, VAR=0x%VAR, VAR=0x%VAR\VAR"", VAR->VAR, VAR & VAR, (VAR)VAR->VAR->VAR, (VAR)VAR->VAR->VAR, VAR->VAR->VAR, VAR, VAR, VAR->VAR[0]); VAR->VAR = (VAR << 16); VAR; }   VAR (VAR == VAR) { VAR VAR = VAR(VAR, 40);  VAR(VAR->VAR, (VAR+28) , VAR); VAR(VAR->VAR[0] == 0x70 && VAR->VAR[2] == VAR ){  VAR->VAR = (VAR << 16); VAR(VAR""%VAR: VAR VAR VAR-VAR (%VAR,%VAR,%VAR) VAR=0x%VAR, VAR=0x%VAR, VAR=0x%VAR\VAR"", VAR->VAR, (VAR)VAR->VAR->VAR, (VAR)VAR->VAR->VAR, VAR->VAR->VAR, VAR, VAR, VAR->VAR[0]); } } } VAR { /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR. VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR. */ VAR->VAR = (VAR << 16); VAR(VAR""%VAR: VAR VAR - VAR (%VAR,%VAR,%VAR) VAR=%VAR, VAR=0x%VAR\VAR"", VAR->VAR, (VAR)VAR->VAR->VAR, (VAR)VAR->VAR->VAR, VAR->VAR->VAR, ((VAR VAR*)(VAR->VAR->VAR))->VAR, VAR->VAR[0]); } VAR->VAR |= (VAR); VAR(VAR); } VAR VAR VAR(VAR* VAR) { VAR VAR; VAR VAR = 0; VAR(VAR->VAR) VAR(VAR->VAR->VAR, VAR); VAR ((VAR=VAR(VAR)) < 0) VAR VAR; VAR ((VAR=VAR(VAR)) < 0) VAR VAR; VAR = 0; VAR: VAR(VAR->VAR) VAR(VAR->VAR->VAR, VAR); VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR VAR; VAR VAR; VAR VAR; VAR VAR *VAR; VAR *VAR = VAR->VAR; VAR VAR = 0; VAR VAR; VAR VAR; VAR VAR[10];  VAR VAR* VAR = VAR; VAR VAR* VAR = VAR; VAR (VAR == VAR) { VAR(VAR ""%VAR: VAR VAR VAR???\VAR"",VAR->VAR); VAR -1; } VAR = VAR->VAR; VAR -= 3; VAR /= 9;  VAR (VAR = VAR->VAR; VAR; VAR = VAR->VAR) { VAR =(VAR VAR*) VAR->VAR; VAR(!VAR){ VAR; } VAR->VAR |= VAR; } VAR(VAR ""%VAR: VAR VAR %VAR VAR.\VAR"", VAR->VAR,VAR); VAR(VAR=0;VAR<VAR;VAR++) { VAR( VAR->VAR[VAR].VAR != 0xfff){ VAR; } VAR( VAR->VAR[VAR].VAR == VAR || VAR->VAR[VAR].VAR == VAR || VAR->VAR[VAR].VAR == VAR ){ VAR = VAR->VAR[VAR].VAR; VAR(VAR(VAR, VAR, 0x8000, -1, VAR, 32)<0) { VAR(VAR""%VAR: VAR VAR VAR VAR\VAR"",VAR->VAR); VAR; } VAR = VAR[0]>>16; VAR (VAR >= VAR) {  VAR(VAR ""%VAR: VAR VAR %VAR VAR VAR VAR\VAR"", VAR->VAR, VAR); VAR; } VAR = VAR[1]; VAR = VAR((VAR VAR *)&VAR[2]); VAR = VAR->VAR[VAR].VAR[VAR];  VAR(VAR) { VAR(VAR->VAR == VAR) { VAR; } VAR = VAR->VAR; } VAR(!VAR ) {  VAR = VAR(VAR(VAR VAR), VAR); VAR(VAR==VAR) { VAR(VAR ""VAR VAR VAR VAR VAR VAR VAR.\VAR""); VAR -VAR; } VAR->VAR = VAR; VAR->VAR = VAR; VAR(&VAR->VAR, &VAR->VAR[VAR], VAR(VAR)); VAR->VAR = 0; VAR(VAR, VAR); VAR(VAR, VAR); VAR = VAR->VAR[VAR].VAR[VAR]; VAR( VAR == VAR){ VAR = VAR(VAR(VAR VAR), VAR); VAR(VAR == VAR) { VAR -VAR; } VAR->VAR[VAR].VAR[VAR] = VAR; } VAR { VAR (VAR->VAR) { VAR = VAR->VAR; } VAR = VAR->VAR = VAR(VAR(VAR VAR), VAR); VAR(VAR == VAR) { VAR -VAR; } } VAR->VAR = VAR->VAR.VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = (VAR[0])&0xff; VAR->VAR = (VAR[0]>>8)&0xff;  VAR(VAR > VAR->VAR){ VAR->VAR = VAR; } VAR(VAR > VAR->VAR){ VAR->VAR = VAR; } VAR; }   VAR(VAR) { VAR(VAR->VAR == VAR) { VAR(!VAR(VAR->VAR)) { VAR(VAR""%VAR: VAR VAR (%VAR,%VAR,%VAR) VAR VAR\VAR"", VAR->VAR,VAR,VAR,VAR); VAR (VAR->VAR) { VAR(VAR->VAR, VAR); } } VAR = VAR->VAR; VAR(VAR->VAR.VAR != VAR) {  VAR->VAR = VAR; VAR(&VAR->VAR, &VAR->VAR[VAR], VAR(VAR)); VAR (VAR->VAR) { VAR->VAR->VAR = VAR; VAR->VAR->VAR = VAR; } }  VAR->VAR = VAR; VAR; } VAR = VAR->VAR; } } } VAR (VAR = VAR->VAR; VAR; VAR = VAR->VAR) { VAR =(VAR VAR*) VAR->VAR; VAR(!VAR){ VAR; }   VAR (VAR->VAR & VAR){ VAR->VAR = VAR; VAR(VAR""%VAR: VAR (%VAR,%VAR,%VAR) VAR\VAR"",VAR->VAR,VAR->VAR,VAR->VAR,VAR->VAR); VAR (VAR->VAR) { VAR(VAR->VAR, VAR); } } } VAR 0; } /*============================================================================ * VAR VAR VAR VAR *============================================================================ */ /* * VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR. */ VAR VAR VAR(VAR* VAR) { VAR VAR; VAR(VAR->VAR ) { VAR (VAR(VAR) < 0) { VAR((VAR = VAR(VAR)) != 0){ VAR(VAR""%VAR: VAR VAR VAR.\VAR"", VAR->VAR); VAR VAR; } VAR (VAR(VAR) < 0) { VAR(VAR ""VAR VAR VAR.\VAR""); VAR -1; } } VAR(VAR->VAR->VAR == VAR) { VAR(VAR ""%VAR: VAR VAR\VAR"", VAR->VAR); VAR -1; } VAR (VAR->VAR->VAR == VAR || VAR->VAR->VAR == VAR || VAR->VAR->VAR == VAR || VAR->VAR->VAR == VAR) { VAR(VAR); VAR (VAR(VAR) < 0 || VAR->VAR->VAR != VAR) { VAR(VAR ""%VAR: VAR VAR VAR.\VAR"", VAR->VAR); VAR -1; } } } VAR { VAR((VAR = VAR(VAR)) != 0){ VAR(VAR""%VAR: VAR VAR VAR.\VAR"", VAR->VAR); VAR VAR; } } VAR (VAR(VAR) < 0) { VAR -1; }  VAR (VAR(VAR) < 0) { VAR -1; } VAR 0; } /* * VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR VAR(VAR* VAR) { VAR (VAR(VAR) < 0) VAR -1;  VAR (VAR(VAR) < 0) VAR -1;  VAR 0; } VAR VAR VAR(VAR*VAR,VAR VAR) { VAR VAR *VAR; VAR VAR = VAR + 5*VAR; VAR(VAR == VAR){ VAR(); VAR = VAR(VAR->VAR); VAR(VAR != VAR){ VAR; } VAR(VAR(VAR,VAR)){ VAR(VAR ""%VAR: VAR VAR VAR VAR VAR!\VAR"",VAR->VAR); VAR 2; } VAR(1); } VAR = (VAR VAR *)(VAR->VAR + VAR); VAR( VAR | VAR,&VAR[0]); VAR( VAR << 24 | VAR << 12 | 0,&VAR[1]); VAR( 0,&VAR[2]); VAR(); VAR(VAR, VAR->VAR); VAR(); VAR 0; } VAR VAR VAR(VAR* VAR) { VAR *VAR; VAR VAR; VAR VAR *VAR = VAR; VAR VAR; VAR VAR = VAR + VAR*VAR; VAR VAR; VAR { VAR(); VAR = VAR(VAR->VAR); VAR (VAR != VAR) { VAR; } VAR(VAR(VAR,VAR)){ VAR(VAR""%VAR: VAR VAR VAR VAR VAR\VAR"",VAR->VAR); VAR -VAR; } VAR(1); } VAR(VAR == VAR); VAR=(VAR VAR *)(VAR->VAR+VAR); VAR = VAR(&VAR->VAR->VAR, 4, &VAR, VAR); VAR (!VAR) { VAR(VAR, VAR); VAR(VAR""%VAR: VAR VAR VAR - VAR VAR VAR.\VAR"", VAR->VAR); VAR -VAR; } VAR(VAR| VAR, &VAR[0]); VAR(VAR<<24 | VAR<<12 | VAR, &VAR[1]); VAR(0, &VAR[2]); VAR(0x0106, &VAR[3]);  VAR(4096, &VAR[4]);  VAR((VAR)<<16|0x80, &VAR[5]);  VAR(0xD0000004, &VAR[6]);  VAR((VAR)VAR, &VAR[7]); VAR(VAR, VAR->VAR); VAR();  VAR { VAR (*VAR) { VAR (*VAR != 0x01 ) { VAR; } } VAR(); VAR(VAR(VAR,VAR)){ VAR(VAR""%VAR: VAR VAR\VAR"",VAR->VAR); /* VAR VAR 4 VAR VAR ""VAR"" VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */  VAR -VAR; } VAR(1); } VAR (1);   VAR(*VAR != 0x04 ) { VAR(&VAR->VAR->VAR, 4, VAR, VAR); VAR -2; } VAR(&VAR->VAR->VAR, 4, VAR, VAR); VAR(VAR->VAR != VAR) { VAR(&VAR->VAR->VAR, VAR->VAR * VAR * 4, VAR->VAR, VAR->VAR); } VAR->VAR = VAR(&VAR->VAR->VAR, VAR->VAR * VAR * 4, &VAR->VAR, VAR); VAR (!VAR->VAR) { VAR(VAR ""%VAR: VAR VAR VAR VAR VAR\VAR"", VAR->VAR); VAR -VAR; } VAR(VAR = 0; VAR < VAR->VAR; VAR++) { VAR(VAR->VAR + (VAR * VAR * 4), VAR->VAR); VAR(); } VAR(VAR); VAR 0; } /* * VAR VAR VAR. VAR VAR VAR * VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR * VAR VAR VAR'VAR VAR. * * VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR. */ VAR VAR VAR(VAR* VAR) { VAR VAR; VAR VAR; VAR VAR *VAR; VAR *VAR=VAR; VAR(VAR->VAR == VAR) { VAR->VAR = VAR(&VAR->VAR->VAR, VAR(VAR), &VAR->VAR, VAR); VAR(VAR->VAR == VAR) { VAR(VAR ""VAR%VAR: VAR VAR VAR VAR; VAR VAR VAR. \VAR"", VAR->VAR); VAR -VAR; } } VAR(VAR->VAR, 0, VAR(VAR)); VAR = (VAR*)(VAR->VAR); VAR = VAR+VAR*VAR; VAR { VAR(); VAR = VAR(VAR->VAR); VAR (VAR != VAR) { VAR; } VAR(VAR(VAR,VAR)){ VAR(VAR ""%VAR: VAR VAR VAR VAR !\VAR"", VAR->VAR); VAR -VAR; } VAR(1); } VAR(VAR==VAR); VAR=(VAR VAR *)(VAR->VAR+VAR); VAR(VAR|VAR, &VAR[0]); VAR(VAR<<24|VAR<<12|VAR, &VAR[1]); VAR(1, &VAR[2]); VAR(0, &VAR[3]); VAR(0, &VAR[4]); VAR(0, &VAR[5]); VAR( VAR(VAR->VAR), &VAR[6]); VAR( VAR(VAR->VAR), &VAR[7]); VAR(VAR(VAR), &VAR[8]);   VAR(VAR, VAR->VAR); VAR(); VAR(VAR[87]!=0xff){ VAR(VAR(VAR,VAR)){ VAR(VAR""VAR%VAR: VAR VAR VAR.\VAR"", VAR->VAR); VAR -VAR; } VAR(); VAR(1); }  VAR->VAR = VAR->VAR->VAR; VAR (VAR->VAR > VAR) { VAR->VAR = VAR; } VAR->VAR = VAR->VAR->VAR; VAR (VAR->VAR > VAR) { VAR->VAR = VAR; }  VAR (VAR(VAR)) { VAR->VAR = ((VAR->VAR->VAR * 4 - 14 * VAR(VAR)) / (VAR(VAR VAR) + VAR(VAR))); } VAR { VAR->VAR = ((VAR->VAR->VAR * 4 - 12 * VAR(VAR)) / VAR(VAR VAR)); } VAR (VAR->VAR > VAR) { VAR->VAR = VAR; }  VAR(""VAR%VAR: VAR = "",VAR->VAR); VAR(VAR->VAR->VAR) { VAR 0x01: VAR(""VAR\VAR""); VAR; VAR 0x02: VAR(""VAR\VAR""); VAR; VAR 0x04: VAR(""VAR\VAR""); VAR; VAR 0x05: VAR(""VAR\VAR""); VAR; VAR 0x08: VAR(""VAR\VAR""); VAR; VAR 0x10: VAR(""VAR\VAR""); VAR; VAR 0x11: VAR(""VAR\VAR""); VAR; VAR: VAR(""%VAR (VAR!!)\VAR"",VAR->VAR->VAR); }  VAR 0; } /* * VAR VAR VAR'VAR VAR VAR VAR */ VAR VAR VAR(VAR* VAR) { VAR VAR[8]; VAR VAR; VAR VAR[16]; VAR ((VAR->VAR == 0) || (VAR->VAR == VAR)){ VAR->VAR = VAR->VAR->VAR; } VAR { VAR (VAR->VAR == VAR) { VAR->VAR = VAR(&VAR->VAR->VAR, VAR->VAR, &VAR->VAR, VAR); VAR(VAR->VAR == VAR) { VAR(VAR ""%VAR: VAR VAR VAR. VAR VAR VAR.\VAR"", VAR->VAR); VAR -VAR; } } VAR(VAR->VAR, 0, VAR->VAR); VAR[0] = VAR|VAR; VAR[1] = VAR<<24 | VAR<<12 | VAR; VAR[2] = 0; VAR[3] = 0; VAR[4] = 0xFFFFFFFF;  VAR[5] = 0x00000000;  VAR[6] = 0xD0000000|VAR->VAR; VAR[7] = (VAR)VAR->VAR; VAR ((VAR=VAR(VAR, VAR, VAR(VAR), 360))) { VAR(VAR ""%VAR: VAR VAR VAR (VAR=% VAR->VAR, VAR); VAR(VAR""VAR: VAR VAR VAR.\VAR""); VAR VAR; } VAR ((VAR->VAR->VAR << 2) > VAR->VAR) { VAR->VAR = VAR->VAR->VAR << 2; VAR(&VAR->VAR->VAR, VAR->VAR, VAR->VAR, VAR->VAR); VAR->VAR = VAR; } } VAR (VAR->VAR == VAR); VAR(""%VAR: VAR VAR VAR VAR.\VAR"", VAR->VAR);  VAR(VAR(VAR, 0 , 0x8000, -1, VAR, VAR(VAR))>=0) { VAR->VAR = VAR[1]; VAR->VAR = VAR(VAR->VAR + VAR[0], VAR->VAR); VAR (VAR->VAR) { VAR->VAR = VAR->VAR + VAR; VAR->VAR = VAR->VAR + VAR; VAR->VAR = VAR->VAR + 1; VAR->VAR = VAR->VAR + VAR; VAR->VAR += VAR[2]; VAR->VAR = 0; } } VAR 0; } VAR VAR VAR(VAR) { VAR* VAR = VAR; VAR VAR = 0; VAR (VAR) VAR(&VAR->VAR->VAR, VAR, VAR, VAR); VAR = VAR(VAR VAR) +  (VAR) * VAR(VAR VAR); VAR = VAR(&VAR->VAR->VAR, VAR, &VAR, VAR); VAR (!VAR) { VAR(VAR ""VAR VAR VAR. VAR VAR VAR.\VAR""); VAR -VAR; } VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR++; VAR(VAR = VAR; VAR; VAR = VAR->VAR) { VAR VAR;  VAR (VAR(VAR)) { VAR->VAR--; VAR;  } VAR->VAR[VAR].VAR = VAR->VAR->VAR; VAR->VAR[VAR].VAR = VAR->VAR + 2; VAR->VAR[VAR].VAR = 0; VAR->VAR[VAR].VAR = VAR->VAR->VAR; VAR->VAR[VAR].VAR = VAR->VAR->VAR; VAR->VAR[VAR].VAR = VAR->VAR->VAR; VAR->VAR[VAR].VAR = VAR->VAR->VAR; VAR->VAR[VAR].VAR = VAR - 1;  VAR->VAR[VAR].VAR = VAR->VAR->VAR; VAR = VAR->VAR + 0x40; VAR->VAR[VAR].VAR = VAR(VAR); VAR->VAR[VAR].VAR = VAR(VAR); VAR++; }  { VAR *VAR = (VAR*)VAR; VAR(VAR""VAR=%VAR VAR 32bit VAR\VAR"",(VAR >>2)); VAR(VAR = 0; VAR < (VAR >>2); VAR++) { VAR(VAR ""VAR[%VAR] = %0 VAR, VAR[VAR]); } }  VAR 0; } /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR) */ VAR VAR VAR(VAR* VAR, VAR VAR *VAR) { VAR VAR[64]; VAR VAR = VAR->VAR.VAR; VAR(VAR ""VAR %3.3d "", VAR); VAR(VAR(VAR, VAR, 0xF100, 3, VAR, 16)>=0) { VAR[16]=0; VAR("" VAR: %-12.12s"", VAR); } VAR(VAR(VAR, VAR, 0xF100, 4, VAR, 16)>=0) { VAR[16]=0; VAR("" VAR: %-12.12s"", VAR); } VAR(VAR(VAR, VAR, 0xF100, 6, VAR, 8)>=0) { VAR[8]=0; VAR("" VAR: %-12.12s\VAR"", VAR); }  VAR(VAR ""\VAR: %.21s\VAR"", VAR(VAR->VAR.VAR)); VAR(VAR ""\VAR: 0x%04X\VAR"", VAR->VAR.VAR); VAR(VAR ""\VAR: ""); VAR(VAR->VAR.VAR&(1<<0)) VAR(""VAR"");  VAR(VAR->VAR.VAR&(1<<1)) VAR(""VAR"");  VAR(!(VAR->VAR.VAR&(1<<4))) VAR(""VAR"");  VAR(!(VAR->VAR.VAR&(1<<5))) VAR(""VAR"");  VAR(""\VAR"");  }  /* * VAR VAR VAR VAR VAR */ VAR VAR VAR *VAR(VAR VAR) { VAR VAR = 16; VAR VAR *VAR[] = { ""VAR"", ""VAR VAR VAR"", ""VAR VAR"", ""VAR VAR"", ""VAR VAR"", ""VAR VAR"", ""VAR VAR VAR"", ""VAR VAR VAR"", ""VAR VAR"", ""VAR VAR"", ""VAR VAR"", ""VAR VAR"", ""VAR VAR"", ""VAR VAR VAR"", ""VAR VAR VAR"", ""VAR VAR"", ""VAR"" }; VAR(VAR&0xFFF) { VAR VAR: VAR = 0; VAR; VAR VAR: VAR = 1; VAR; VAR VAR: VAR = 2; VAR; VAR VAR: VAR = 3; VAR; VAR VAR: VAR = 4; VAR; VAR VAR: VAR = 5; VAR; VAR VAR: VAR = 6; VAR; VAR VAR: VAR = 7; VAR; VAR VAR: VAR = 8; VAR; VAR VAR: VAR = 9; VAR; VAR VAR: VAR = 10; VAR; VAR VAR: VAR = 11; VAR; VAR VAR: VAR = 12; VAR; VAR VAR: VAR = 13; VAR; VAR VAR: VAR = 14; VAR; VAR VAR: VAR = 15; VAR; } VAR VAR[VAR]; }  VAR VAR VAR(VAR* VAR) { VAR VAR[6]; VAR VAR, VAR = VAR(VAR); VAR { VAR (VAR->VAR == VAR) { VAR->VAR = VAR(&VAR->VAR->VAR, VAR, &VAR->VAR, VAR); VAR (VAR->VAR == VAR) { VAR(VAR ""%VAR: VAR VAR VAR; VAR VAR VAR.\VAR"", VAR->VAR); VAR -VAR; } } VAR[0]= VAR| VAR; VAR[1]= VAR<<24 | VAR<<12 | VAR; VAR[2]= 0; VAR[3]= 0; VAR[4]= (0xD0000000 | VAR);  VAR[5]= (VAR)VAR->VAR;  VAR ((VAR = VAR(VAR, VAR, VAR(VAR),20))) { VAR(VAR ""%VAR: VAR VAR VAR VAR (VAR=% VAR VAR; } VAR (VAR->VAR->VAR * VAR->VAR->VAR << 2 > VAR) { VAR VAR = VAR->VAR->VAR * VAR->VAR->VAR << 2; VAR(&VAR->VAR->VAR, VAR, VAR->VAR, VAR->VAR); VAR = VAR; VAR->VAR = VAR; } } VAR(VAR->VAR == VAR); VAR 0; } /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR VAR(VAR* VAR, VAR VAR, VAR VAR, VAR VAR, VAR *VAR, VAR VAR) { VAR VAR[] = { 1, 0, VAR, VAR, 1, VAR }; VAR *VAR; VAR VAR; VAR *VAR; VAR VAR; VAR VAR;  VAR = VAR(&VAR->VAR->VAR, VAR(VAR) * (8 + VAR), &VAR, VAR); VAR (VAR == VAR) { VAR(VAR ""%VAR: VAR VAR VAR; VAR VAR VAR.\VAR"", VAR->VAR); VAR -VAR; } VAR = VAR(&VAR->VAR->VAR, VAR(VAR), &VAR, VAR); VAR (VAR == VAR) { VAR(&VAR->VAR->VAR, VAR(VAR) * (8+VAR), VAR, VAR); VAR(VAR ""%VAR: VAR VAR VAR; VAR VAR VAR.\VAR"", VAR->VAR); VAR -VAR; } VAR (VAR == -1)  VAR[4] = -1; VAR(VAR, VAR, VAR(VAR)); VAR = VAR(VAR, VAR, VAR, VAR, VAR, VAR(VAR), VAR, VAR, VAR(VAR)*(8+VAR)); VAR(&VAR->VAR->VAR, VAR(VAR), VAR, VAR); VAR (VAR == -VAR) { VAR(&VAR->VAR->VAR, VAR(VAR) * (8+VAR), VAR, VAR); VAR(VAR ""%VAR: VAR VAR VAR; VAR VAR.\VAR"", VAR->VAR); VAR -VAR; } VAR VAR (VAR == -VAR) { VAR(&VAR->VAR->VAR, VAR(VAR) * (8+VAR), VAR, VAR); VAR(VAR ""%VAR: VAR VAR VAR; VAR.\VAR"", VAR->VAR); VAR -VAR; } VAR(VAR, VAR+8, VAR);  VAR(&VAR->VAR->VAR, VAR(VAR) * (8+VAR), VAR, VAR); VAR (VAR < 0) VAR VAR; VAR VAR; } /* VAR VAR VAR VAR * * VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR. * VAR VAR VAR VAR VAR VAR-VAR, * VAR VAR VAR VAR VAR VAR-VAR. * VAR VAR VAR VAR VAR VAR VAR 8 VAR VAR VAR * VAR, VAR, VAR VAR VAR. */ VAR VAR VAR(VAR VAR, VAR* VAR, VAR VAR, VAR *VAR, VAR VAR, VAR VAR, VAR *VAR, VAR VAR, VAR VAR) { VAR VAR[9]; VAR *VAR = (VAR *)VAR; VAR VAR; VAR[0] = VAR | VAR; VAR[1] = VAR << 24 | VAR << 12 | VAR; VAR[2] = 0; VAR[3] = 0; VAR[4] = 0; VAR[5] = 0x54000000 | VAR;  VAR[6] = (VAR)VAR; VAR[7] = 0xD0000000 | VAR;  VAR[8] = (VAR)VAR; VAR ((VAR = VAR(VAR, VAR, VAR(VAR), 20))) { VAR(""VAR: VAR VAR (%VAR)\VAR"", VAR); VAR VAR;  } VAR (VAR[1]&0x00FF0000) {  VAR(VAR ""%VAR: %VAR - VAR:\VAR VAR = 0x%02x, "" ""VAR = 0x%02x, VAR = 0x%04x\VAR"", VAR->VAR, (VAR == VAR) ? ""VAR"" : ""VAR"", VAR[1]>>24, (VAR[1]>>16)&0xFF, VAR[1]&0xFFFF); VAR -((VAR[1] >> 16) & 0xFF);  } VAR 4 + ((VAR[1] & 0x0000FFFF) << 2);  } VAR VAR VAR(VAR* VAR) { VAR VAR[4]; VAR VAR; VAR(VAR);  VAR((VAR->VAR->VAR != VAR) && (VAR->VAR->VAR != VAR)){ VAR 0; } VAR[0] = VAR|VAR; VAR[1] = VAR<<24|VAR<<12|VAR; VAR[2] = 0; VAR[3] = 0; VAR((VAR = VAR(VAR, VAR, VAR(VAR), 240))) { VAR(VAR""VAR%VAR: VAR VAR VAR (VAR=% VAR->VAR, -VAR); } VAR { VAR(VAR""VAR%VAR: VAR.\VAR"",VAR->VAR); } VAR(VAR); VAR VAR; } /* * VAR VAR. VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR VAR(VAR* VAR) { VAR VAR[4]; VAR VAR; VAR(VAR); VAR(!VAR->VAR){ VAR -VAR; }  VAR(VAR->VAR->VAR == VAR) VAR 0; VAR(VAR->VAR->VAR != VAR) VAR -VAR; VAR[0]=VAR|VAR; VAR[1]=VAR<<24|VAR<<12|VAR; VAR[2]= 0; VAR[3]= 0; VAR ((VAR = VAR(VAR, VAR, VAR(VAR), 240))) { VAR(VAR""%VAR: VAR VAR VAR (VAR=% VAR->VAR, VAR); } VAR { VAR(""%VAR: VAR.\VAR"", VAR->VAR); } VAR(VAR); VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR VAR[12]; VAR VAR; VAR[0] = VAR(12) | VAR; VAR[1] = VAR<<24 | VAR<<12 | VAR; VAR[2] = 0; VAR[3] = 0; VAR[4] = (0<<16) | ((VAR->VAR+2) << 12);  VAR[5] = 0;  /* * VAR VAR VAR-VAR: * VAR VAR (VAR), VAR VAR VAR VAR VAR * VAR VAR/VAR VAR VAR */ VAR[6] = 0x54000000 | VAR; VAR[7] = (VAR)VAR; VAR[8] = 0x54000000 | 0; VAR[9] = 0; VAR[10] = 0xD4000000 | 0; VAR[11] = 0; VAR ((VAR=VAR(VAR, VAR, VAR(VAR), 120))) { VAR(VAR ""%VAR: VAR VAR VAR VAR (VAR=% VAR->VAR, VAR); }  VAR { VAR(""%VAR: VAR VAR.\VAR"", VAR->VAR); }  VAR VAR; } /*============================================================================ * *============================================================================ */  VAR VAR VAR VAR(VAR VAR) { VAR VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR(1000);  } }  VAR VAR VAR VAR = { .VAR = VAR, .VAR = ""VAR"", .VAR = ""VAR"", .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = 7, }; VAR VAR VAR VAR(VAR) { VAR VAR; VAR *VAR, *VAR; VAR(""VAR VAR VAR VAR: VAR "" VAR ""\VAR""); VAR = VAR(&VAR); VAR (VAR < 0) VAR VAR; VAR (VAR == VAR) VAR -VAR; VAR (VAR = VAR; VAR; VAR = VAR->VAR) { VAR = VAR(VAR->VAR, &VAR->VAR->VAR); VAR (VAR) VAR VAR; VAR(VAR->VAR); } VAR 0; VAR: VAR (VAR = VAR; VAR; VAR = VAR) { VAR = VAR->VAR; VAR(VAR->VAR); } VAR VAR; } VAR VAR VAR VAR(VAR) { VAR *VAR, *VAR; VAR (VAR = VAR; VAR; VAR = VAR) { VAR = VAR->VAR; VAR(VAR); } } VAR(VAR); VAR(VAR); VAR(""VAR"");",1
linux_b9dd46188edc2f0d1f37328637860bb65a771124,include/linux/f2fs_fs.h,"/*
 * F2FS uses 4 bytes to represent block address. As a result, supported size of
 * disk is 16 TB and it equals to 16 * 1024 * 1024 / 2 segments.
 */
#define F2FS_MAX_SEGMENT       ((16 * 1024 * 1024) / 2)
",,b9dd46188edc2f0d1f37328637860bb65a771124,CVE-2017-10662,b9dd46188edc2f0d1f37328637860bb65a771124,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"/* * VAR VAR 4 VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR * VAR VAR 16 VAR VAR VAR VAR VAR 16 * 1024 * 1024 / 2 VAR. */  ",1
linux_c25b2ae136039ffa820c26138ed4a5e5f3ab3841,kernel/bpf/verifier.c,"	return base_type(type) == PTR_TO_SOCKET ||
		base_type(type) == PTR_TO_TCP_SOCK ||
		base_type(type) == PTR_TO_MEM;
/* string representation of 'enum bpf_reg_type'
 *
 * Note that reg_type_str() can not appear more than once in a single verbose()
 * statement.
 */
static const char *reg_type_str(struct bpf_verifier_env *env,
				enum bpf_reg_type type)
{
	char postfix[16] = {0};
	static const char * const str[] = {
		[NOT_INIT]		= ""?"",
		[SCALAR_VALUE]		= ""inv"",
		[PTR_TO_CTX]		= ""ctx"",
		[CONST_PTR_TO_MAP]	= ""map_ptr"",
		[PTR_TO_MAP_VALUE]	= ""map_value"",
		[PTR_TO_STACK]		= ""fp"",
		[PTR_TO_PACKET]		= ""pkt"",
		[PTR_TO_PACKET_META]	= ""pkt_meta"",
		[PTR_TO_PACKET_END]	= ""pkt_end"",
		[PTR_TO_FLOW_KEYS]	= ""flow_keys"",
		[PTR_TO_SOCKET]		= ""sock"",
		[PTR_TO_SOCK_COMMON]	= ""sock_common"",
		[PTR_TO_TCP_SOCK]	= ""tcp_sock"",
		[PTR_TO_TP_BUFFER]	= ""tp_buffer"",
		[PTR_TO_XDP_SOCK]	= ""xdp_sock"",
		[PTR_TO_BTF_ID]		= ""ptr_"",
		[PTR_TO_PERCPU_BTF_ID]	= ""percpu_ptr_"",
		[PTR_TO_MEM]		= ""mem"",
		[PTR_TO_RDONLY_BUF]	= ""rdonly_buf"",
		[PTR_TO_RDWR_BUF]	= ""rdwr_buf"",
		[PTR_TO_FUNC]		= ""func"",
		[PTR_TO_MAP_KEY]	= ""map_key"",
	};

	if (type & PTR_MAYBE_NULL) {
		if (base_type(type) == PTR_TO_BTF_ID ||
		    base_type(type) == PTR_TO_PERCPU_BTF_ID)
			strncpy(postfix, ""or_null_"", 16);
		else
			strncpy(postfix, ""_or_null"", 16);
	}

	snprintf(env->type_str_buf, TYPE_STR_BUF_LEN, ""%s%s"",
		 str[base_type(type)], postfix);
	return env->type_str_buf;
}
		verbose(env, ""=%s"", reg_type_str(env, t));
			if (base_type(t) == PTR_TO_BTF_ID ||
			    base_type(t) == PTR_TO_PERCPU_BTF_ID)
			else if (base_type(t) == CONST_PTR_TO_MAP ||
				 base_type(t) == PTR_TO_MAP_KEY ||
				 base_type(t) == PTR_TO_MAP_VALUE)
			verbose(env, ""=%s"", reg_type_str(env, t));
	if (base_type(reg->type) == PTR_TO_MAP_VALUE) {
		return;

	reg->type &= ~PTR_MAYBE_NULL;
				reg_type_str(env, parent->type),
	switch (base_type(type)) {
		if (base_type(*reg_type) == PTR_TO_BTF_ID) {
		regno, reg_type_str(env, reg->type), off, size);
				if (type_may_be_null(reg_type))
				if (base_type(reg_type) == PTR_TO_BTF_ID) {
				regno, reg_type_str(env, reg->type));
				regno, reg_type_str(env, reg->type));
			reg_type_str(env, reg->type));
			reg_type_str(env, reg_state(env, insn->dst_reg)->type));
		verbose(env, ""R%d type=%s "", regno,
			reg_type_str(env, reg->type));
		verbose(env, ""expected=%s\n"", reg_type_str(env, PTR_TO_STACK));
	if (type_may_be_null(reg->type)) {
	verbose(env, ""R%d type=%s expected="", regno, reg_type_str(env, type));
		verbose(env, ""%s, "", reg_type_str(env, compatible->types[j]));
	verbose(env, ""%s\n"", reg_type_str(env, compatible->types[j]));
	enum bpf_type_flag ret_flag;
	ret_flag = type_flag(fn->ret_type);
		regs[BPF_REG_0].type = PTR_TO_MAP_VALUE | ret_flag;
		if (!type_may_be_null(ret_type) &&
		    map_value_has_spin_lock(meta.map_ptr)) {
			regs[BPF_REG_0].id = ++env->id_gen;
		regs[BPF_REG_0].type = PTR_TO_SOCKET | ret_flag;
		regs[BPF_REG_0].type = PTR_TO_SOCK_COMMON | ret_flag;
		regs[BPF_REG_0].type = PTR_TO_TCP_SOCK | ret_flag;
		regs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;
			regs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;
			regs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;
		regs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;
	if (type_may_be_null(regs[BPF_REG_0].type))
			reg_type_str(env, type), val);
			reg_type_str(env, type), reg->off);
			reg_type_str(env, type));
			smin, reg_type_str(env, type));
	if (ptr_reg->type & PTR_MAYBE_NULL) {
			dst, reg_type_str(env, ptr_reg->type));
	}

	switch (base_type(ptr_reg->type)) {
			dst, reg_type_str(env, ptr_reg->type));
	if (type_may_be_null(reg->type) && reg->id == id &&
	    type_may_be_null(dst_reg->type)) {
				reg_type_str(env, reg->type));
				reg_type_str(env, reg->type));
			reg_type_str(env, reg->type));
	switch (base_type(rold->type)) {
		/* a PTR_TO_MAP_VALUE could be safe to use as a
		 * PTR_TO_MAP_VALUE_OR_NULL into the same map.
		 * However, if the old PTR_TO_MAP_VALUE_OR_NULL then got NULL-
		 * checked, doing so could have affected others with the same
		 * id, and we can't check for that because we lost the id when
		 * we converted to a PTR_TO_MAP_VALUE.
		 */
		if (type_may_be_null(rold->type)) {
			if (!type_may_be_null(rcur->type))
				return false;
			if (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))
				return false;
			/* Check our ids match any regs they're supposed to */
			return check_ids(rold->id, rcur->id, idmap);
		}

	switch (base_type(type)) {
					reg_type_str(env, reg_state(env, insn->dst_reg)->type));","static bool reg_type_may_be_null(enum bpf_reg_type type)
{
	return type == PTR_TO_MAP_VALUE_OR_NULL ||
	       type == PTR_TO_SOCKET_OR_NULL ||
	       type == PTR_TO_SOCK_COMMON_OR_NULL ||
	       type == PTR_TO_TCP_SOCK_OR_NULL ||
	       type == PTR_TO_BTF_ID_OR_NULL ||
	       type == PTR_TO_MEM_OR_NULL ||
	       type == PTR_TO_RDONLY_BUF_OR_NULL ||
	       type == PTR_TO_RDWR_BUF_OR_NULL;
}

	return type == PTR_TO_SOCKET ||
		type == PTR_TO_SOCKET_OR_NULL ||
		type == PTR_TO_TCP_SOCK ||
		type == PTR_TO_TCP_SOCK_OR_NULL ||
		type == PTR_TO_MEM ||
		type == PTR_TO_MEM_OR_NULL;
/* string representation of 'enum bpf_reg_type' */
static const char * const reg_type_str[] = {
	[NOT_INIT]		= ""?"",
	[SCALAR_VALUE]		= ""inv"",
	[PTR_TO_CTX]		= ""ctx"",
	[CONST_PTR_TO_MAP]	= ""map_ptr"",
	[PTR_TO_MAP_VALUE]	= ""map_value"",
	[PTR_TO_MAP_VALUE_OR_NULL] = ""map_value_or_null"",
	[PTR_TO_STACK]		= ""fp"",
	[PTR_TO_PACKET]		= ""pkt"",
	[PTR_TO_PACKET_META]	= ""pkt_meta"",
	[PTR_TO_PACKET_END]	= ""pkt_end"",
	[PTR_TO_FLOW_KEYS]	= ""flow_keys"",
	[PTR_TO_SOCKET]		= ""sock"",
	[PTR_TO_SOCKET_OR_NULL] = ""sock_or_null"",
	[PTR_TO_SOCK_COMMON]	= ""sock_common"",
	[PTR_TO_SOCK_COMMON_OR_NULL] = ""sock_common_or_null"",
	[PTR_TO_TCP_SOCK]	= ""tcp_sock"",
	[PTR_TO_TCP_SOCK_OR_NULL] = ""tcp_sock_or_null"",
	[PTR_TO_TP_BUFFER]	= ""tp_buffer"",
	[PTR_TO_XDP_SOCK]	= ""xdp_sock"",
	[PTR_TO_BTF_ID]		= ""ptr_"",
	[PTR_TO_BTF_ID_OR_NULL]	= ""ptr_or_null_"",
	[PTR_TO_PERCPU_BTF_ID]	= ""percpu_ptr_"",
	[PTR_TO_MEM]		= ""mem"",
	[PTR_TO_MEM_OR_NULL]	= ""mem_or_null"",
	[PTR_TO_RDONLY_BUF]	= ""rdonly_buf"",
	[PTR_TO_RDONLY_BUF_OR_NULL] = ""rdonly_buf_or_null"",
	[PTR_TO_RDWR_BUF]	= ""rdwr_buf"",
	[PTR_TO_RDWR_BUF_OR_NULL] = ""rdwr_buf_or_null"",
	[PTR_TO_FUNC]		= ""func"",
	[PTR_TO_MAP_KEY]	= ""map_key"",
};
		verbose(env, ""=%s"", reg_type_str[t]);
			if (t == PTR_TO_BTF_ID ||
			    t == PTR_TO_BTF_ID_OR_NULL ||
			    t == PTR_TO_PERCPU_BTF_ID)
			else if (t == CONST_PTR_TO_MAP ||
				 t == PTR_TO_MAP_KEY ||
				 t == PTR_TO_MAP_VALUE ||
				 t == PTR_TO_MAP_VALUE_OR_NULL)
			verbose(env, ""=%s"", reg_type_str[t]);
	switch (reg->type) {
	case PTR_TO_MAP_VALUE_OR_NULL: {
		break;
	}
	case PTR_TO_SOCKET_OR_NULL:
		reg->type = PTR_TO_SOCKET;
		break;
	case PTR_TO_SOCK_COMMON_OR_NULL:
		reg->type = PTR_TO_SOCK_COMMON;
		break;
	case PTR_TO_TCP_SOCK_OR_NULL:
		reg->type = PTR_TO_TCP_SOCK;
		break;
	case PTR_TO_BTF_ID_OR_NULL:
		reg->type = PTR_TO_BTF_ID;
		break;
	case PTR_TO_MEM_OR_NULL:
		reg->type = PTR_TO_MEM;
		break;
	case PTR_TO_RDONLY_BUF_OR_NULL:
		reg->type = PTR_TO_RDONLY_BUF;
		break;
	case PTR_TO_RDWR_BUF_OR_NULL:
		reg->type = PTR_TO_RDWR_BUF;
		break;
	default:
		WARN_ONCE(1, ""unknown nullable register type"");
				reg_type_str[parent->type],
	switch (type) {
	case PTR_TO_MAP_VALUE_OR_NULL:
	case PTR_TO_SOCKET_OR_NULL:
	case PTR_TO_SOCK_COMMON_OR_NULL:
	case PTR_TO_TCP_SOCK_OR_NULL:
	case PTR_TO_BTF_ID_OR_NULL:
	case PTR_TO_RDONLY_BUF_OR_NULL:
	case PTR_TO_RDWR_BUF_OR_NULL:
	case PTR_TO_MEM_OR_NULL:
		if (*reg_type == PTR_TO_BTF_ID || *reg_type == PTR_TO_BTF_ID_OR_NULL) {
		regno, reg_type_str[reg->type], off, size);
				if (reg_type_may_be_null(reg_type))
				if (reg_type == PTR_TO_BTF_ID ||
				    reg_type == PTR_TO_BTF_ID_OR_NULL) {
				regno, reg_type_str[reg->type]);
				regno, reg_type_str[reg->type]);
			reg_type_str[reg->type]);
			reg_type_str[reg_state(env, insn->dst_reg)->type]);
		verbose(env, ""R%d type=%s expected=%s\n"", regno,
			reg_type_str[reg->type],
			reg_type_str[PTR_TO_STACK]);
	if (reg_type_may_be_null(reg->type)) {
	verbose(env, ""R%d type=%s expected="", regno, reg_type_str[type]);
		verbose(env, ""%s, "", reg_type_str[compatible->types[j]]);
	verbose(env, ""%s\n"", reg_type_str[compatible->types[j]]);
		if (type_may_be_null(ret_type)) {
			regs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;
		} else {
			regs[BPF_REG_0].type = PTR_TO_MAP_VALUE;
			if (map_value_has_spin_lock(meta.map_ptr))
				regs[BPF_REG_0].id = ++env->id_gen;
		regs[BPF_REG_0].type = PTR_TO_SOCKET_OR_NULL;
		regs[BPF_REG_0].type = PTR_TO_SOCK_COMMON_OR_NULL;
		regs[BPF_REG_0].type = PTR_TO_TCP_SOCK_OR_NULL;
		regs[BPF_REG_0].type = PTR_TO_MEM_OR_NULL;
			regs[BPF_REG_0].type =
				(ret_type & PTR_MAYBE_NULL) ?
				PTR_TO_MEM_OR_NULL : PTR_TO_MEM;
			regs[BPF_REG_0].type =
				(ret_type & PTR_MAYBE_NULL) ?
				PTR_TO_BTF_ID_OR_NULL : PTR_TO_BTF_ID;
		regs[BPF_REG_0].type = (ret_type & PTR_MAYBE_NULL) ?
						     PTR_TO_BTF_ID_OR_NULL :
						     PTR_TO_BTF_ID;
	if (reg_type_may_be_null(regs[BPF_REG_0].type))
			reg_type_str[type], val);
			reg_type_str[type], reg->off);
			reg_type_str[type]);
			smin, reg_type_str[type]);
	switch (ptr_reg->type) {
	case PTR_TO_MAP_VALUE_OR_NULL:
			dst, reg_type_str[ptr_reg->type]);
	case PTR_TO_SOCKET_OR_NULL:
	case PTR_TO_SOCK_COMMON_OR_NULL:
	case PTR_TO_TCP_SOCK_OR_NULL:
			dst, reg_type_str[ptr_reg->type]);
	if (reg_type_may_be_null(reg->type) && reg->id == id &&
	    reg_type_may_be_null(dst_reg->type)) {
				reg_type_str[reg->type]);
				reg_type_str[reg->type]);
			reg_type_str[reg->type]);
	switch (rold->type) {
	case PTR_TO_MAP_VALUE_OR_NULL:
		/* a PTR_TO_MAP_VALUE could be safe to use as a
		 * PTR_TO_MAP_VALUE_OR_NULL into the same map.
		 * However, if the old PTR_TO_MAP_VALUE_OR_NULL then got NULL-
		 * checked, doing so could have affected others with the same
		 * id, and we can't check for that because we lost the id when
		 * we converted to a PTR_TO_MAP_VALUE.
		 */
		if (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)
			return false;
		if (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))
			return false;
		/* Check our ids match any regs they're supposed to */
		return check_ids(rold->id, rcur->id, idmap);
	case PTR_TO_SOCKET_OR_NULL:
	case PTR_TO_SOCK_COMMON_OR_NULL:
	case PTR_TO_TCP_SOCK_OR_NULL:
	switch (type) {
	case PTR_TO_SOCKET_OR_NULL:
	case PTR_TO_SOCK_COMMON_OR_NULL:
	case PTR_TO_TCP_SOCK_OR_NULL:
	case PTR_TO_BTF_ID_OR_NULL:
					reg_type_str[reg_state(env, insn->dst_reg)->type]);",c25b2ae136039ffa820c26138ed4a5e5f3ab3841,CVE-2022-0500,c25b2ae136039ffa820c26138ed4a5e5f3ab3841,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,80,COMPLETED,"VAR VAR(VAR) == VAR || VAR(VAR) == VAR || VAR(VAR) == VAR; /* VAR VAR VAR 'VAR VAR' * * VAR VAR VAR() VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR() * VAR. */ VAR VAR VAR *VAR(VAR VAR *VAR, VAR VAR VAR) { VAR VAR[16] = {0}; VAR VAR VAR * VAR VAR[] = { [VAR] = ""?"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", }; VAR (VAR & VAR) { VAR (VAR(VAR) == VAR || VAR(VAR) == VAR) VAR(VAR, ""VAR"", 16); VAR VAR(VAR, ""VAR"", 16); } VAR(VAR->VAR, VAR, ""%VAR%VAR"", VAR[VAR(VAR)], VAR); VAR VAR->VAR; } VAR(VAR, ""=%VAR"", VAR(VAR, VAR)); VAR (VAR(VAR) == VAR || VAR(VAR) == VAR) VAR VAR (VAR(VAR) == VAR || VAR(VAR) == VAR || VAR(VAR) == VAR) VAR(VAR, ""=%VAR"", VAR(VAR, VAR)); VAR (VAR(VAR->VAR) == VAR) { VAR; VAR->VAR &= ~VAR; VAR(VAR, VAR->VAR), VAR (VAR(VAR)) { VAR (VAR(*VAR) == VAR) { VAR, VAR(VAR, VAR->VAR), VAR, VAR); VAR (VAR(VAR)) VAR (VAR(VAR) == VAR) { VAR, VAR(VAR, VAR->VAR)); VAR, VAR(VAR, VAR->VAR)); VAR(VAR, VAR->VAR)); VAR(VAR, VAR(VAR, VAR->VAR)->VAR)); VAR(VAR, ""VAR%VAR VAR=%VAR "", VAR, VAR(VAR, VAR->VAR)); VAR(VAR, ""VAR=%VAR\VAR"", VAR(VAR, VAR)); VAR (VAR(VAR->VAR)) { VAR(VAR, ""VAR%VAR VAR=%VAR VAR="", VAR, VAR(VAR, VAR)); VAR(VAR, ""%VAR, "", VAR(VAR, VAR->VAR[VAR])); VAR(VAR, ""%VAR\VAR"", VAR(VAR, VAR->VAR[VAR])); VAR VAR VAR; VAR = VAR(VAR->VAR); VAR[VAR].VAR = VAR | VAR; VAR (!VAR(VAR) && VAR(VAR.VAR)) { VAR[VAR].VAR = ++VAR->VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR (VAR(VAR[VAR].VAR)) VAR(VAR, VAR), VAR); VAR(VAR, VAR), VAR->VAR); VAR(VAR, VAR)); VAR, VAR(VAR, VAR)); VAR (VAR->VAR & VAR) { VAR, VAR(VAR, VAR->VAR)); } VAR (VAR(VAR->VAR)) { VAR, VAR(VAR, VAR->VAR)); VAR (VAR(VAR->VAR) && VAR->VAR == VAR && VAR(VAR->VAR)) { VAR(VAR, VAR->VAR)); VAR(VAR, VAR->VAR)); VAR(VAR, VAR->VAR)); VAR (VAR(VAR->VAR)) { /* VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. * VAR, VAR VAR VAR VAR VAR VAR VAR- * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. */ VAR (VAR(VAR->VAR)) { VAR (!VAR(VAR->VAR)) VAR VAR; VAR (VAR(VAR, VAR, VAR(VAR VAR, VAR))) VAR VAR;  VAR VAR(VAR->VAR, VAR->VAR, VAR); } VAR (VAR(VAR)) { VAR(VAR, VAR(VAR, VAR->VAR)->VAR)); VAR VAR VAR(VAR VAR VAR) { VAR VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR; } VAR VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR;  VAR VAR VAR * VAR VAR[] = { [VAR] = ""?"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", }; VAR(VAR, ""=%VAR"", VAR[VAR]); VAR (VAR == VAR || VAR == VAR || VAR == VAR) VAR VAR (VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR) VAR(VAR, ""=%VAR"", VAR[VAR]); VAR (VAR->VAR) { VAR VAR: { VAR; } VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR: VAR(1, ""VAR VAR VAR VAR""); VAR[VAR->VAR], VAR (VAR) { VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR (*VAR == VAR || *VAR == VAR) { VAR, VAR[VAR->VAR], VAR, VAR); VAR (VAR(VAR)) VAR (VAR == VAR || VAR == VAR) { VAR, VAR[VAR->VAR]); VAR, VAR[VAR->VAR]); VAR[VAR->VAR]); VAR[VAR(VAR, VAR->VAR)->VAR]); VAR(VAR, ""VAR%VAR VAR=%VAR VAR=%VAR\VAR"", VAR, VAR[VAR->VAR], VAR[VAR]); VAR (VAR(VAR->VAR)) { VAR(VAR, ""VAR%VAR VAR=%VAR VAR="", VAR, VAR[VAR]); VAR(VAR, ""%VAR, "", VAR[VAR->VAR[VAR]]); VAR(VAR, ""%VAR\VAR"", VAR[VAR->VAR[VAR]]); VAR (VAR(VAR)) { VAR[VAR].VAR = VAR; } VAR { VAR[VAR].VAR = VAR; VAR (VAR(VAR.VAR)) VAR[VAR].VAR = ++VAR->VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = (VAR & VAR) ? VAR : VAR; VAR[VAR].VAR = (VAR & VAR) ? VAR : VAR; VAR[VAR].VAR = (VAR & VAR) ? VAR : VAR; VAR (VAR(VAR[VAR].VAR)) VAR[VAR], VAR); VAR[VAR], VAR->VAR); VAR[VAR]); VAR, VAR[VAR]); VAR (VAR->VAR) { VAR VAR: VAR, VAR[VAR->VAR]); VAR VAR: VAR VAR: VAR VAR: VAR, VAR[VAR->VAR]); VAR (VAR(VAR->VAR) && VAR->VAR == VAR && VAR(VAR->VAR)) { VAR[VAR->VAR]); VAR[VAR->VAR]); VAR[VAR->VAR]); VAR (VAR->VAR) { VAR VAR: /* VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. * VAR, VAR VAR VAR VAR VAR VAR VAR- * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. */ VAR (VAR->VAR != VAR) VAR VAR; VAR (VAR(VAR, VAR, VAR(VAR VAR, VAR))) VAR VAR;  VAR VAR(VAR->VAR, VAR->VAR, VAR); VAR VAR: VAR VAR: VAR VAR: VAR (VAR) { VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR[VAR(VAR, VAR->VAR)->VAR]);",1
linux_ca59d5a51690d5b9340343dc36792a252e9414ae,drivers/spi/spi-fsl-dspi.c,"		/* Write the CMD FIFO entry first, and then the two
		 * corresponding TX FIFO entries.
		tx_fifo_write(dspi, data & 0xFFFF);
		tx_fifo_write(dspi, data >> 16);","		/* Write two TX FIFO entries first, and then the corresponding
		 * CMD FIFO entry.
		if (dspi->cur_chip->ctar_val & SPI_CTAR_LSBFE) {
			/* LSB */
			tx_fifo_write(dspi, data & 0xFFFF);
			tx_fifo_write(dspi, data >> 16);
		} else {
			/* MSB */
			tx_fifo_write(dspi, data >> 16);
			tx_fifo_write(dspi, data & 0xFFFF);
		}",ca59d5a51690d5b9340343dc36792a252e9414ae,CVE-2020-12769,ca59d5a51690d5b9340343dc36792a252e9414ae,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,72,COMPLETED,"/* VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR * VAR VAR VAR VAR. VAR(VAR, VAR & 0xFFFF); VAR(VAR, VAR >> 16); /* VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR * VAR VAR VAR. VAR (VAR->VAR->VAR & VAR) {  VAR(VAR, VAR & 0xFFFF); VAR(VAR, VAR >> 16); } VAR {  VAR(VAR, VAR >> 16); VAR(VAR, VAR & 0xFFFF); }",1
linux_dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,include/linux/hrtimer.h,," * @start_pid:  timer statistics field to store the pid of the task which
 *		started the timer
 * @start_site:	timer statistics field to store the site where the timer
 *		was started
 * @start_comm: timer statistics field to store the name of the process which
 *		started the timer
#ifdef CONFIG_TIMER_STATS
	int				start_pid;
	void				*start_site;
	char				start_comm[16];
#endif",dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,CVE-2017-5967,dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,98,COMPLETED, * @VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR * @VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR * @VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR  VAR VAR; VAR *VAR; VAR VAR[16]; ,1
linux_dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,include/linux/timer.h,,"#ifdef CONFIG_TIMER_STATS
	int			start_pid;
	void			*start_site;
	char			start_comm[16];
#endif
/*
 * Timer-statistics info:
 */
#ifdef CONFIG_TIMER_STATS

extern int timer_stats_active;

extern void init_timer_stats(void);

extern void timer_stats_update_stats(void *timer, pid_t pid, void *startf,
				     void *timerf, char *comm, u32 flags);

extern void __timer_stats_timer_set_start_info(struct timer_list *timer,
					       void *addr);

static inline void timer_stats_timer_set_start_info(struct timer_list *timer)
{
	if (likely(!timer_stats_active))
		return;
	__timer_stats_timer_set_start_info(timer, __builtin_return_address(0));
}

static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	timer->start_site = NULL;
}
#else
static inline void init_timer_stats(void)
{
}

static inline void timer_stats_timer_set_start_info(struct timer_list *timer)
{
}

static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
}
#endif
",dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,CVE-2017-5967,dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,98,COMPLETED,"  VAR VAR; VAR *VAR; VAR VAR[16];  /* * VAR-VAR VAR: */  VAR VAR VAR; VAR VAR VAR(VAR); VAR VAR VAR(VAR *VAR, VAR VAR, VAR *VAR, VAR *VAR, VAR *VAR, VAR VAR); VAR VAR VAR(VAR VAR *VAR, VAR *VAR); VAR VAR VAR VAR(VAR VAR *VAR) { VAR (VAR(!VAR)) VAR; VAR(VAR, VAR(0)); } VAR VAR VAR VAR(VAR VAR *VAR) { VAR->VAR = VAR; }  VAR VAR VAR VAR(VAR) { } VAR VAR VAR VAR(VAR VAR *VAR) { } VAR VAR VAR VAR(VAR VAR *VAR) { } ",1
linux_e783362eb54cd99b2cac8b3a9aeac942e6f6ac07,Makefile,"PATCHLEVEL = 17
EXTRAVERSION = -rc1","PATCHLEVEL = 16
EXTRAVERSION =",e783362eb54cd99b2cac8b3a9aeac942e6f6ac07,CVE-2022-0847,e783362eb54cd99b2cac8b3a9aeac942e6f6ac07,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,68,COMPLETED,VAR = 17 VAR = -VAR VAR = 16 VAR =,1
linux_f58841666bc22e827ca0dcef7b71c7bc2758ce82,fs/cifs/misc.c,,"/* Convert 16 bit Unicode pathname from wire format to string in current code
   page.  Conversion may involve remapping up the seven characters that are
   only legal in POSIX-like OS (if they are present in the string). Path
   names are little endian 16 bit Unicode on the wire */
int
cifs_convertUCSpath(char *target, const __le16 *source, int maxlen,
		    const struct nls_table *cp)
{
	int i, j, len;
	__u16 src_char;

	for (i = 0, j = 0; i < maxlen; i++) {
		src_char = le16_to_cpu(source[i]);
		switch (src_char) {
			case 0:
				goto cUCS_out; /* BB check this BB */
			case UNI_COLON:
				target[j] = ':';
				break;
			case UNI_ASTERIK:
				target[j] = '*';
				break;
			case UNI_QUESTION:
				target[j] = '?';
				break;
			/* BB We can not handle remapping slash until
			   all the calls to build_path_from_dentry
			   are modified, as they use slash as separator BB */
			/* case UNI_SLASH:
				target[j] = '\\';
				break;*/
			case UNI_PIPE:
				target[j] = '|';
				break;
			case UNI_GRTRTHAN:
				target[j] = '>';
				break;
			case UNI_LESSTHAN:
				target[j] = '<';
				break;
			default:
				len = cp->uni2char(src_char, &target[j],
						NLS_MAX_CHARSET_SIZE);
				if (len > 0) {
					j += len;
					continue;
				} else {
					target[j] = '?';
				}
		}
		j++;
		/* make sure we do not overrun callers allocated temp buffer */
		if (j >= (2 * NAME_MAX))
			break;
	}
cUCS_out:
	target[j] = 0;
	return j;
}
",f58841666bc22e827ca0dcef7b71c7bc2758ce82,CVE-2009-1633,f58841666bc22e827ca0dcef7b71c7bc2758ce82,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,92,COMPLETED," /* VAR 16 VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR (VAR VAR VAR VAR VAR VAR VAR). VAR VAR VAR VAR VAR 16 VAR VAR VAR VAR VAR */ VAR VAR(VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR VAR *VAR) { VAR VAR, VAR, VAR; VAR VAR; VAR (VAR = 0, VAR = 0; VAR < VAR; VAR++) { VAR = VAR(VAR[VAR]); VAR (VAR) { VAR 0: VAR VAR;  VAR VAR: VAR[VAR] = ':'; VAR; VAR VAR: VAR[VAR] = '*'; VAR; VAR VAR: VAR[VAR] = '?'; VAR; /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR */ /* VAR VAR: VAR[VAR] = '\\'; VAR;*/ VAR VAR: VAR[VAR] = '|'; VAR; VAR VAR: VAR[VAR] = '>'; VAR; VAR VAR: VAR[VAR] = '<'; VAR; VAR: VAR = VAR->VAR(VAR, &VAR[VAR], VAR); VAR (VAR > 0) { VAR += VAR; VAR; } VAR { VAR[VAR] = '?'; } } VAR++;  VAR (VAR >= (2 * VAR)) VAR; } VAR: VAR[VAR] = 0; VAR VAR; }",1
moodle_c73f6d03e5037729097bb9f5f5a55be15f3cab18,liflowplayer/flowplayer.controls-3.2.16.swf.php,"<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Flowplayer audio controls handling.
 *
 * @package core
 * @copyright  Petr Skoda <petr.skoda@totaralms.com>
 * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

define('NO_DEBUG_DISPLAY', true);
define('NO_MOODLE_COOKIES', true);
define('NO_UPGRADE_CHECK', true);

require('../../config.php');
require('../../lib/flowplayer/lib.php');

flowplayer_send_flash_content('flowplayer.controls-3.2.16.swf');",,c73f6d03e5037729097bb9f5f5a55be15f3cab18,CVE-2015-5337,c73f6d03e5037729097bb9f5f5a55be15f3cab18,https://github.com/moodle/moodle,GHSD_DIRECT_COMMIT,1337,COMPLETED,"<?VAR               /** * VAR VAR VAR VAR. * * @VAR VAR * @VAR VAR VAR <VAR.VAR@VAR.VAR> * @VAR VAR: */ VAR('VAR', VAR); VAR('VAR', VAR); VAR('VAR', VAR); VAR('../../VAR.VAR'); VAR('../../VAR/VAR/VAR.VAR'); VAR('VAR.VAR-3.2.16.VAR'); ",1
openssl_43e6a58d4991a451daf4891ff05a48735df871ac,crypto/dsa/dsa_ossl.c,    q_bits = BN_num_bits(dsa->q) + sizeof(dsa->q->d[0]) * 16;,    q_bits = BN_num_bits(dsa->q);,43e6a58d4991a451daf4891ff05a48735df871ac,CVE-2018-0734,43e6a58d4991a451daf4891ff05a48735df871ac,https://github.com/openssl/openssl,CPE_GIT_REPOBASED,148,COMPLETED,VAR = VAR(VAR->VAR) + VAR(VAR->VAR->VAR[0]) * 16; VAR = VAR(VAR->VAR);,1
openssl_4443cf7aa0099e5ce615c18cee249fff77fb0871,crypto/bn/asm/x86_64-mont5.pl,"	xor	$zero,$zero
	sub	16+8(%rsp),%rbx		# mov 16(%rsp),%cf
	adcx	$zero,%r8
	adcx	$zero,%r9
	adc	\$0,%r10
	adc	\$0,%r11
	adc	\$0,%r12
	adc	\$0,%r13
	adc	\$0,%r14
	adc	\$0,%r15","	sub	16+8(%rsp),%r8		# consume last carry
	xor	%ebp,%ebp		# xor	$zero,$zero",4443cf7aa0099e5ce615c18cee249fff77fb0871,CVE-2017-3736,4443cf7aa0099e5ce615c18cee249fff77fb0871,https://github.com/openssl/openssl,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR $VAR,$VAR VAR 16+8(%VAR),%VAR  VAR $VAR,%VAR VAR $VAR,%VAR VAR \$0,%VAR VAR \$0,%VAR VAR \$0,%VAR VAR \$0,%VAR VAR \$0,%VAR VAR \$0,%VAR VAR 16+8(%VAR),%VAR  VAR %VAR,%VAR ",1
tomcat_c8acd2ab7371e39aeca7c306f3b5380f00afe552,test/org/apache/coyote/http2/TestHttp2Section_5_1.java,"        doTestImplicitClose(5);
    }


    // https://bz.apache.org/bugzilla/show_bug.cgi?id=64467
    @Test
    public void testImplicitCloseLargeId() throws Exception {
        doTestImplicitClose(Integer.MAX_VALUE - 8);
    }


    private void doTestImplicitClose(int lastStreamId) throws Exception {

        long startFirst = System.nanoTime();
        long durationFirst = System.nanoTime() - startFirst;
        sendPriority(lastStreamId, 0, 16);
        long startSecond = System.nanoTime();
        sendSimpleGetRequest(lastStreamId);
        long durationSecond = System.nanoTime() - startSecond;

        Assert.assertEquals(getSimpleResponseTrace(lastStreamId), output.getTrace());
        // Allow second request to take up to 5 times first request or up to 1 second - whichever is the larger - mainly
        // to allow for CI systems under load that can exhibit significant timing variation.
        Assert.assertTrue(""First request took ["" + durationFirst/1000000 + ""ms], second request took ["" +
                durationSecond/1000000 + ""ms]"", durationSecond < 1000000000 || durationSecond < durationFirst * 3);

        handleGoAwayResponse(lastStreamId);","        sendPriority(5, 0, 16);
        sendSimpleGetRequest(5);
        Assert.assertEquals(getSimpleResponseTrace(5), output.getTrace());
        handleGoAwayResponse(5);",c8acd2ab7371e39aeca7c306f3b5380f00afe552,CVE-2020-11996,c8acd2ab7371e39aeca7c306f3b5380f00afe552,https://github.com/apache/tomcat,CPE_GIT_REPOBASED,66,COMPLETED,"VAR(5); }  @VAR VAR VAR VAR() VAR VAR { VAR(VAR.VAR - 8); } VAR VAR VAR(VAR VAR) VAR VAR { VAR VAR = VAR.VAR(); VAR VAR = VAR.VAR() - VAR; VAR(VAR, 0, 16); VAR VAR = VAR.VAR(); VAR(VAR); VAR VAR = VAR.VAR() - VAR; VAR.VAR(VAR(VAR), VAR.VAR());   VAR.VAR(""VAR VAR VAR ["" + VAR/1000000 + ""VAR], VAR VAR VAR ["" + VAR/1000000 + ""VAR]"", VAR < 1000000000 || VAR < VAR * 3); VAR(VAR); VAR(5, 0, 16); VAR(5); VAR.VAR(VAR(5), VAR.VAR()); VAR(5);",1
trafficserver_6e5070118a20772a30c3fccee2cf1c44f0a21fc0,tests/gold_tests/chunked_encoding/replays/chunked_in_http_1_0.replay.yaml,"#  Licensed to the Apache Software Foundation (ASF) under one
#  or more contributor license agreements.  See the NOTICE file
#  distributed with this work for additional information
#  regarding copyright ownership.  The ASF licenses this file
#  to you under the Apache License, Version 2.0 (the
#  ""License""); you may not use this file except in compliance
#  with the License.  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an ""AS IS"" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

meta:
  version: ""1.0""

sessions:
- transactions:
  - client-request:
      method: ""POST""
      # HTTP/1.0 does not support Transfer-Encoding. ATS should therefore
      # reject it with a 4xx response.
      version: ""1.0""
      url: /unexpected/chunk/header
      headers:
        fields:
        - [ Host, example.com ]
        - [ Transfer-Encoding, chunked ]
        - [ uuid, 51 ]
      content:
        size: 32

    # This request should not make it to the server, but if it does reply with
    # a 200 response so that we detect the non-4xx response we expect.
    server-response:
      status: 200
      reason: OK
      headers:
        fields:
        - [ Content-Length, 16 ]
        - [ X-Response, ""Unexpected origin response."" ]

    proxy-response:
      status: 406
      reason: ""Transcoding Not Available""",,6e5070118a20772a30c3fccee2cf1c44f0a21fc0,CVE-2021-37148,6e5070118a20772a30c3fccee2cf1c44f0a21fc0,https://github.com/apache/trafficserver,CPE_GIT_REPOBASED,72,COMPLETED,"               VAR: VAR: ""1.0"" VAR: - VAR: - VAR-VAR: VAR: ""VAR""   VAR: ""1.0"" VAR: /VAR/VAR/VAR VAR: VAR: - [ VAR, VAR.VAR ] - [ VAR-VAR, VAR ] - [ VAR, 51 ] VAR: VAR: 32   VAR-VAR: VAR: 200 VAR: VAR VAR: VAR: - [ VAR-VAR, 16 ] - [ VAR-VAR, ""VAR VAR VAR."" ] VAR-VAR: VAR: 406 VAR: ""VAR VAR VAR"" ",1
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,docs/requirements.txt,"-r ../dev-requirements.txt
ndg-httpsclient
sphinx
alabaster
requests>=2.0,<2.16",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"-VAR ../VAR-VAR.VAR VAR-VAR VAR VAR VAR>=2.0,<2.16 ",1
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,src/urllib3/contripyopenssl.py,"""""""
SSL with SNI_-support for Python 2. Follow these instructions if you would
like to verify SSL certificates in Python 2. Note, the default libraries do
*not* do certificate checking; you need to do additional work to validate
certificates yourself.

This needs the following packages installed:

* pyOpenSSL (tested with 16.0.0)
* cryptography (minimum 1.3.4, from pyopenssl)
* idna (minimum 2.0, from cryptography)

However, pyopenssl depends on cryptography, which depends on idna, so while we
use all three directly here we end up having relatively few packages required.

You can install them with the following command:

    pip install pyopenssl cryptography idna

To activate certificate checking, call
:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code
before you begin making HTTP requests. This can be done in a ``sitecustomize``
module, or at any other time before your application begins using ``urllib3``,
like this::

    try:
        import urllib3.contrib.pyopenssl
        urllib3.contrib.pyopenssl.inject_into_urllib3()
    except ImportError:
        pass

Now you can use :mod:`urllib3` as you normally would, and it will support SNI
when the required modules are installed.

Activating this module also has the positive side effect of disabling SSL/TLS
compression in Python 2 (see `CRIME attack`_).

If you want to configure the default list of supported cipher suites, you can
set the ``urllib3.contrib.pyopenssl.DEFAULT_SSL_CIPHER_LIST`` variable.

.. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication
.. _crime attack: https://en.wikipedia.org/wiki/CRIME_(security_exploit)
""""""
from __future__ import absolute_import

import OpenSSL.SSL
from cryptography import x509
from cryptography.hazmat.backends.openssl import backend as openssl_backend
from cryptography.hazmat.backends.openssl.x509 import _Certificate
try:
    from cryptography.x509 import UnsupportedExtension
except ImportError:
    # UnsupportedExtension is gone in cryptography >= 2.1.0
    class UnsupportedExtension(Exception):
        pass

from socket import timeout, error as SocketError
from io import BytesIO

try:  # Platform-specific: Python 2
    from socket import _fileobject
except ImportError:  # Platform-specific: Python 3
    _fileobject = None
    from ..packages.backports.makefile import backport_makefile

import logging
import ssl
from ..packages import six
import sys

from .. import util

__all__ = ['inject_into_urllib3', 'extract_from_urllib3']

# SNI always works.
HAS_SNI = True

# Map from urllib3 to PyOpenSSL compatible parameter-values.
_openssl_versions = {
    ssl.PROTOCOL_SSLv23: OpenSSL.SSL.SSLv23_METHOD,
    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,
}

if hasattr(ssl, 'PROTOCOL_TLSv1_1') and hasattr(OpenSSL.SSL, 'TLSv1_1_METHOD'):
    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD

if hasattr(ssl, 'PROTOCOL_TLSv1_2') and hasattr(OpenSSL.SSL, 'TLSv1_2_METHOD'):
    _openssl_versions[ssl.PROTOCOL_TLSv1_2] = OpenSSL.SSL.TLSv1_2_METHOD

try:
    _openssl_versions.update({ssl.PROTOCOL_SSLv3: OpenSSL.SSL.SSLv3_METHOD})
except AttributeError:
    pass

_stdlib_to_openssl_verify = {
    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,
    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,
    ssl.CERT_REQUIRED:
        OpenSSL.SSL.VERIFY_PEER + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,
}
_openssl_to_stdlib_verify = dict(
    (v, k) for k, v in _stdlib_to_openssl_verify.items()
)

# OpenSSL will only write 16K at a time
SSL_WRITE_BLOCKSIZE = 16384

orig_util_HAS_SNI = util.HAS_SNI
orig_util_SSLContext = util.ssl_.SSLContext


log = logging.getLogger(__name__)


def inject_into_urllib3():
    'Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.'

    _validate_dependencies_met()

    util.ssl_.SSLContext = PyOpenSSLContext
    util.HAS_SNI = HAS_SNI
    util.ssl_.HAS_SNI = HAS_SNI
    util.IS_PYOPENSSL = True
    util.ssl_.IS_PYOPENSSL = True


def extract_from_urllib3():
    'Undo monkey-patching by :func:`inject_into_urllib3`.'

    util.ssl_.SSLContext = orig_util_SSLContext
    util.HAS_SNI = orig_util_HAS_SNI
    util.ssl_.HAS_SNI = orig_util_HAS_SNI
    util.IS_PYOPENSSL = False
    util.ssl_.IS_PYOPENSSL = False


def _validate_dependencies_met():
    """"""
    Verifies that PyOpenSSL's package-level dependencies have been met.
    Throws `ImportError` if they are not met.
    """"""
    # Method added in `cryptography==1.1`; not available in older versions
    from cryptography.x509.extensions import Extensions
    if getattr(Extensions, ""get_extension_for_class"", None) is None:
        raise ImportError(""'cryptography' module missing required functionality.  ""
                          ""Try upgrading to v1.3.4 or newer."")

    # pyOpenSSL 0.14 and above use cryptography for OpenSSL bindings. The _x509
    # attribute is only present on those versions.
    from OpenSSL.crypto import X509
    x509 = X509()
    if getattr(x509, ""_x509"", None) is None:
        raise ImportError(""'pyOpenSSL' module missing required functionality. ""
                          ""Try upgrading to v0.14 or newer."")


def _dnsname_to_stdlib(name):
    """"""
    Converts a dNSName SubjectAlternativeName field to the form used by the
    standard library on the given Python version.

    Cryptography produces a dNSName as a unicode string that was idna-decoded
    from ASCII bytes. We need to idna-encode that string to get it back, and
    then on Python 3 we also need to convert to unicode via UTF-8 (the stdlib
    uses PyUnicode_FromStringAndSize on it, which decodes via UTF-8).

    If the name cannot be idna-encoded then we return None signalling that
    the name given should be skipped.
    """"""
    def idna_encode(name):
        """"""
        Borrowed wholesale from the Python Cryptography Project. It turns out
        that we can't just safely call `idna.encode`: it can explode for
        wildcard names. This avoids that problem.
        """"""
        import idna

        try:
            for prefix in [u'*.', u'.']:
                if name.startswith(prefix):
                    name = name[len(prefix):]
                    return prefix.encode('ascii') + idna.encode(name)
            return idna.encode(name)
        except idna.core.IDNAError:
            return None

    name = idna_encode(name)
    if name is None:
        return None
    elif sys.version_info >= (3, 0):
        name = name.decode('utf-8')
    return name


def get_subj_alt_name(peer_cert):
    """"""
    Given an PyOpenSSL certificate, provides all the subject alternative names.
    """"""
    # Pass the cert to cryptography, which has much better APIs for this.
    if hasattr(peer_cert, ""to_cryptography""):
        cert = peer_cert.to_cryptography()
    else:
        # This is technically using private APIs, but should work across all
        # relevant versions before PyOpenSSL got a proper API for this.
        cert = _Certificate(openssl_backend, peer_cert._x509)

    # We want to find the SAN extension. Ask Cryptography to locate it (it's
    # faster than looping in Python)
    try:
        ext = cert.extensions.get_extension_for_class(
            x509.SubjectAlternativeName
        ).value
    except x509.ExtensionNotFound:
        # No such extension, return the empty list.
        return []
    except (x509.DuplicateExtension, UnsupportedExtension,
            x509.UnsupportedGeneralNameType, UnicodeError) as e:
        # A problem has been found with the quality of the certificate. Assume
        # no SAN field is present.
        log.warning(
            ""A problem was encountered with the certificate that prevented ""
            ""urllib3 from finding the SubjectAlternativeName field. This can ""
            ""affect certificate validation. The error was %s"",
            e,
        )
        return []

    # We want to return dNSName and iPAddress fields. We need to cast the IPs
    # back to strings because the match_hostname function wants them as
    # strings.
    # Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8
    # decoded. This is pretty frustrating, but that's what the standard library
    # does with certificates, and so we need to attempt to do the same.
    # We also want to skip over names which cannot be idna encoded.
    names = [
        ('DNS', name) for name in map(_dnsname_to_stdlib, ext.get_values_for_type(x509.DNSName))
        if name is not None
    ]
    names.extend(
        ('IP Address', str(name))
        for name in ext.get_values_for_type(x509.IPAddress)
    )

    return names


class WrappedSocket(object):
    '''API-compatibility wrapper for Python OpenSSL's Connection-class.

    Note: _makefile_refs, _drop() and _reuse() are needed for the garbage
    collector of pypy.
    '''

    def __init__(self, connection, socket, suppress_ragged_eofs=True):
        self.connection = connection
        self.socket = socket
        self.suppress_ragged_eofs = suppress_ragged_eofs
        self._makefile_refs = 0
        self._closed = False

    def fileno(self):
        return self.socket.fileno()

    # Copy-pasted from Python 3.5 source code
    def _decref_socketios(self):
        if self._makefile_refs > 0:
            self._makefile_refs -= 1
        if self._closed:
            self.close()

    def recv(self, *args, **kwargs):
        try:
            data = self.connection.recv(*args, **kwargs)
        except OpenSSL.SSL.SysCallError as e:
            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):
                return b''
            else:
                raise SocketError(str(e))
        except OpenSSL.SSL.ZeroReturnError:
            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
                return b''
            else:
                raise
        except OpenSSL.SSL.WantReadError:
            if not util.wait_for_read(self.socket, self.socket.gettimeout()):
                raise timeout('The read operation timed out')
            else:
                return self.recv(*args, **kwargs)
        else:
            return data

    def recv_into(self, *args, **kwargs):
        try:
            return self.connection.recv_into(*args, **kwargs)
        except OpenSSL.SSL.SysCallError as e:
            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):
                return 0
            else:
                raise SocketError(str(e))
        except OpenSSL.SSL.ZeroReturnError:
            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
                return 0
            else:
                raise
        except OpenSSL.SSL.WantReadError:
            if not util.wait_for_read(self.socket, self.socket.gettimeout()):
                raise timeout('The read operation timed out')
            else:
                return self.recv_into(*args, **kwargs)

    def settimeout(self, timeout):
        return self.socket.settimeout(timeout)

    def _send_until_done(self, data):
        while True:
            try:
                return self.connection.send(data)
            except OpenSSL.SSL.WantWriteError:
                if not util.wait_for_write(self.socket, self.socket.gettimeout()):
                    raise timeout()
                continue
            except OpenSSL.SSL.SysCallError as e:
                raise SocketError(str(e))

    def sendall(self, data):
        total_sent = 0
        while total_sent < len(data):
            sent = self._send_until_done(data[total_sent:total_sent + SSL_WRITE_BLOCKSIZE])
            total_sent += sent

    def shutdown(self):
        # FIXME rethrow compatible exceptions should we ever use this
        self.connection.shutdown()

    def close(self):
        if self._makefile_refs < 1:
            try:
                self._closed = True
                return self.connection.close()
            except OpenSSL.SSL.Error:
                return
        else:
            self._makefile_refs -= 1

    def getpeercert(self, binary_form=False):
        x509 = self.connection.get_peer_certificate()

        if not x509:
            return x509

        if binary_form:
            return OpenSSL.crypto.dump_certificate(
                OpenSSL.crypto.FILETYPE_ASN1,
                x509)

        return {
            'subject': (
                (('commonName', x509.get_subject().CN),),
            ),
            'subjectAltName': get_subj_alt_name(x509)
        }

    def _reuse(self):
        self._makefile_refs += 1

    def _drop(self):
        if self._makefile_refs < 1:
            self.close()
        else:
            self._makefile_refs -= 1


if _fileobject:  # Platform-specific: Python 2
    def makefile(self, mode, bufsize=-1):
        self._makefile_refs += 1
        return _fileobject(self, mode, bufsize, close=True)
else:  # Platform-specific: Python 3
    makefile = backport_makefile

WrappedSocket.makefile = makefile


class PyOpenSSLContext(object):
    """"""
    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible
    for translating the interface of the standard library ``SSLContext`` object
    to calls into PyOpenSSL.
    """"""
    def __init__(self, protocol):
        self.protocol = _openssl_versions[protocol]
        self._ctx = OpenSSL.SSL.Context(self.protocol)
        self._options = 0
        self.check_hostname = False

    @property
    def options(self):
        return self._options

    @options.setter
    def options(self, value):
        self._options = value
        self._ctx.set_options(value)

    @property
    def verify_mode(self):
        return _openssl_to_stdlib_verify[self._ctx.get_verify_mode()]

    @verify_mode.setter
    def verify_mode(self, value):
        self._ctx.set_verify(
            _stdlib_to_openssl_verify[value],
            _verify_callback
        )

    def set_default_verify_paths(self):
        self._ctx.set_default_verify_paths()

    def set_ciphers(self, ciphers):
        if isinstance(ciphers, six.text_type):
            ciphers = ciphers.encode('utf-8')
        self._ctx.set_cipher_list(ciphers)

    def load_verify_locations(self, cafile=None, capath=None, cadata=None):
        if cafile is not None:
            cafile = cafile.encode('utf-8')
        if capath is not None:
            capath = capath.encode('utf-8')
        self._ctx.load_verify_locations(cafile, capath)
        if cadata is not None:
            self._ctx.load_verify_locations(BytesIO(cadata))

    def load_cert_chain(self, certfile, keyfile=None, password=None):
        self._ctx.use_certificate_chain_file(certfile)
        if password is not None:
            self._ctx.set_passwd_cb(lambda max_length, prompt_twice, userdata: password)
        self._ctx.use_privatekey_file(keyfile or certfile)

    def wrap_socket(self, sock, server_side=False,
                    do_handshake_on_connect=True, suppress_ragged_eofs=True,
                    server_hostname=None):
        cnx = OpenSSL.SSL.Connection(self._ctx, sock)

        if isinstance(server_hostname, six.text_type):  # Platform-specific: Python 3
            server_hostname = server_hostname.encode('utf-8')

        if server_hostname is not None:
            cnx.set_tlsext_host_name(server_hostname)

        cnx.set_connect_state()

        while True:
            try:
                cnx.do_handshake()
            except OpenSSL.SSL.WantReadError:
                if not util.wait_for_read(sock, sock.gettimeout()):
                    raise timeout('select timed out')
                continue
            except OpenSSL.SSL.Error as e:
                raise ssl.SSLError('bad handshake: %r' % e)
            break

        return WrappedSocket(cnx, sock)


def _verify_callback(cnx, x509, err_no, err_depth, return_code):
    return err_no == 0",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,""""""" VAR VAR VAR-VAR VAR VAR 2. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 2. VAR, VAR VAR VAR VAR *VAR* VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR: * VAR (VAR VAR 16.0.0) * VAR (VAR 1.3.4, VAR VAR) * VAR (VAR 2.0, VAR VAR) VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR ``VAR`` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR``, VAR VAR:: VAR: VAR VAR.VAR.VAR VAR.VAR.VAR.VAR() VAR VAR: VAR VAR VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR VAR 2 (VAR `VAR VAR`VAR). VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR ``VAR.VAR.VAR.VAR`` VAR. .. VAR: VAR: .. VAR VAR: VAR: """""" VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR: VAR VAR.VAR VAR VAR VAR VAR:  VAR VAR(VAR): VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR:  VAR VAR VAR VAR VAR VAR:  VAR = VAR VAR ..VAR.VAR.VAR VAR VAR VAR VAR VAR VAR VAR ..VAR VAR VAR VAR VAR VAR .. VAR VAR VAR = ['VAR', 'VAR']  VAR = VAR  VAR = { VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR, } VAR VAR(VAR, 'VAR') VAR VAR(VAR.VAR, 'VAR'): VAR[VAR.VAR] = VAR.VAR.VAR VAR VAR(VAR, 'VAR') VAR VAR(VAR.VAR, 'VAR'): VAR[VAR.VAR] = VAR.VAR.VAR VAR: VAR.VAR({VAR.VAR: VAR.VAR.VAR}) VAR VAR: VAR VAR = { VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR + VAR.VAR.VAR, } VAR = VAR( (VAR, VAR) VAR VAR, VAR VAR VAR.VAR() )  VAR = 16384 VAR = VAR.VAR VAR = VAR.VAR.VAR VAR = VAR.VAR(VAR) VAR VAR(): 'VAR-VAR VAR VAR VAR-VAR VAR-VAR.' VAR() VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR VAR(): 'VAR VAR-VAR VAR :VAR:`VAR`.' VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR VAR(): """""" VAR VAR VAR'VAR VAR-VAR VAR VAR VAR VAR. VAR `VAR` VAR VAR VAR VAR VAR. """"""  VAR VAR.VAR.VAR VAR VAR VAR VAR(VAR, ""VAR"", VAR) VAR VAR: VAR VAR(""'VAR' VAR VAR VAR VAR. "" ""VAR VAR VAR VAR.3.4 VAR VAR."")   VAR VAR.VAR VAR VAR VAR = VAR() VAR VAR(VAR, ""VAR"", VAR) VAR VAR: VAR VAR(""'VAR' VAR VAR VAR VAR. "" ""VAR VAR VAR VAR.14 VAR VAR."") VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR. VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR 3 VAR VAR VAR VAR VAR VAR VAR VAR VAR-8 (VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR-8). VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR `VAR.VAR`: VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR. """""" VAR VAR VAR: VAR VAR VAR [VAR'*.', VAR'.']: VAR VAR.VAR(VAR): VAR = VAR[VAR(VAR):] VAR VAR.VAR('VAR') + VAR.VAR(VAR) VAR VAR.VAR(VAR) VAR VAR.VAR.VAR: VAR VAR VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR VAR VAR.VAR >= (3, 0): VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR(VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. """"""  VAR VAR(VAR, ""VAR""): VAR = VAR.VAR() VAR:   VAR = VAR(VAR, VAR.VAR)   VAR: VAR = VAR.VAR.VAR( VAR.VAR ).VAR VAR VAR.VAR:  VAR [] VAR (VAR.VAR, VAR, VAR.VAR, VAR) VAR VAR:   VAR.VAR( ""VAR VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR VAR. VAR VAR "" ""VAR VAR VAR. VAR VAR VAR %VAR"", VAR, ) VAR []        VAR = [ ('VAR', VAR) VAR VAR VAR VAR(VAR, VAR.VAR(VAR.VAR)) VAR VAR VAR VAR VAR ] VAR.VAR( ('VAR VAR', VAR(VAR)) VAR VAR VAR VAR.VAR(VAR.VAR) ) VAR VAR VAR VAR(VAR): '''VAR-VAR VAR VAR VAR VAR'VAR VAR-VAR. VAR: VAR, VAR() VAR VAR() VAR VAR VAR VAR VAR VAR VAR VAR. ''' VAR VAR(VAR, VAR, VAR, VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR VAR(VAR): VAR VAR.VAR.VAR()  VAR VAR(VAR): VAR VAR.VAR > 0: VAR.VAR -= 1 VAR VAR.VAR: VAR.VAR() VAR VAR(VAR, *VAR, **VAR): VAR: VAR = VAR.VAR.VAR(*VAR, **VAR) VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR == (-1, 'VAR VAR'): VAR VAR'' VAR: VAR VAR(VAR(VAR)) VAR VAR.VAR.VAR: VAR VAR.VAR.VAR() == VAR.VAR.VAR: VAR VAR'' VAR: VAR VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR('VAR VAR VAR VAR VAR') VAR: VAR VAR.VAR(*VAR, **VAR) VAR: VAR VAR VAR VAR(VAR, *VAR, **VAR): VAR: VAR VAR.VAR.VAR(*VAR, **VAR) VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR == (-1, 'VAR VAR'): VAR 0 VAR: VAR VAR(VAR(VAR)) VAR VAR.VAR.VAR: VAR VAR.VAR.VAR() == VAR.VAR.VAR: VAR 0 VAR: VAR VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR('VAR VAR VAR VAR VAR') VAR: VAR VAR.VAR(*VAR, **VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR(VAR) VAR VAR(VAR, VAR): VAR VAR: VAR: VAR VAR.VAR.VAR(VAR) VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR() VAR VAR VAR.VAR.VAR VAR VAR: VAR VAR(VAR(VAR)) VAR VAR(VAR, VAR): VAR = 0 VAR VAR < VAR(VAR): VAR = VAR.VAR(VAR[VAR:VAR + VAR]) VAR += VAR VAR VAR(VAR):  VAR.VAR.VAR() VAR VAR(VAR): VAR VAR.VAR < 1: VAR: VAR.VAR = VAR VAR VAR.VAR.VAR() VAR VAR.VAR.VAR: VAR VAR: VAR.VAR -= 1 VAR VAR(VAR, VAR=VAR): VAR = VAR.VAR.VAR() VAR VAR VAR: VAR VAR VAR VAR: VAR VAR.VAR.VAR( VAR.VAR.VAR, VAR) VAR { 'VAR': ( (('VAR', VAR.VAR().VAR),), ), 'VAR': VAR(VAR) } VAR VAR(VAR): VAR.VAR += 1 VAR VAR(VAR): VAR VAR.VAR < 1: VAR.VAR() VAR: VAR.VAR -= 1 VAR VAR:  VAR VAR(VAR, VAR, VAR=-1): VAR.VAR += 1 VAR VAR(VAR, VAR, VAR, VAR=VAR) VAR:  VAR = VAR VAR.VAR = VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = VAR[VAR] VAR.VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR = 0 VAR.VAR = VAR @VAR VAR VAR(VAR): VAR VAR.VAR @VAR.VAR VAR VAR(VAR, VAR): VAR.VAR = VAR VAR.VAR.VAR(VAR) @VAR VAR VAR(VAR): VAR VAR[VAR.VAR.VAR()] @VAR.VAR VAR VAR(VAR, VAR): VAR.VAR.VAR( VAR[VAR], VAR ) VAR VAR(VAR): VAR.VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR, VAR.VAR): VAR = VAR.VAR('VAR-8') VAR.VAR.VAR(VAR) VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR VAR VAR VAR VAR: VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR VAR: VAR = VAR.VAR('VAR-8') VAR.VAR.VAR(VAR, VAR) VAR VAR VAR VAR VAR: VAR.VAR.VAR(VAR(VAR)) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): VAR.VAR.VAR(VAR) VAR VAR VAR VAR VAR: VAR.VAR.VAR(VAR VAR, VAR, VAR: VAR) VAR.VAR.VAR(VAR VAR VAR) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR = VAR.VAR.VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR.VAR):  VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR VAR: VAR.VAR(VAR) VAR.VAR() VAR VAR: VAR: VAR.VAR() VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR, VAR.VAR()): VAR VAR('VAR VAR VAR') VAR VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR('VAR VAR: %VAR' % VAR) VAR VAR VAR(VAR, VAR) VAR VAR(VAR, VAR, VAR, VAR, VAR): VAR VAR == 0 ",1
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,src/urllib3/filepost.py,"from __future__ import absolute_import
import binascii
import codecs
import os

from io import BytesIO

from .packages import six
from .packages.six import b
from .fields import RequestField

writer = codecs.lookup('utf-8')[3]


def choose_boundary():
    """"""
    Our embarrassingly-simple replacement for mimetools.choose_boundary.
    """"""
    boundary = binascii.hexlify(os.urandom(16))
    if six.PY3:
        boundary = boundary.decode('ascii')
    return boundary


def iter_field_objects(fields):
    """"""
    Iterate over fields.

    Supports list of (k, v) tuples and dicts, and lists of
    :class:`~urllib3.fields.RequestField`.

    """"""
    if isinstance(fields, dict):
        i = six.iteritems(fields)
    else:
        i = iter(fields)

    for field in i:
        if isinstance(field, RequestField):
            yield field
        else:
            yield RequestField.from_tuples(*field)


def iter_fields(fields):
    """"""
    .. deprecated:: 1.6

    Iterate over fields.

    The addition of :class:`~urllib3.fields.RequestField` makes this function
    obsolete. Instead, use :func:`iter_field_objects`, which returns
    :class:`~urllib3.fields.RequestField` objects.

    Supports list of (k, v) tuples and dicts.
    """"""
    if isinstance(fields, dict):
        return ((k, v) for k, v in six.iteritems(fields))

    return ((k, v) for k, v in fields)


def encode_multipart_formdata(fields, boundary=None):
    """"""
    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.

    :param fields:
        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).

    :param boundary:
        If not specified, then a random boundary will be generated using
        :func:`urllib3.filepost.choose_boundary`.
    """"""
    body = BytesIO()
    if boundary is None:
        boundary = choose_boundary()

    for field in iter_field_objects(fields):
        body.write(b('--%s\r\n' % (boundary)))

        writer(body).write(field.render_headers())
        data = field.data

        if isinstance(data, int):
            data = str(data)  # Backwards compatibility

        if isinstance(data, six.text_type):
            writer(body).write(data)
        else:
            body.write(data)

        body.write(b'\r\n')

    body.write(b('--%s--\r\n' % (boundary)))

    content_type = str('multipart/form-data; boundary=%s' % boundary)

    return body.getvalue(), content_type",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR.VAR VAR VAR VAR .VAR VAR VAR VAR = VAR.VAR('VAR-8')[3] VAR VAR(): """""" VAR VAR-VAR VAR VAR VAR.VAR. """""" VAR = VAR.VAR(VAR.VAR(16)) VAR VAR.VAR: VAR = VAR.VAR('VAR') VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR, VAR VAR VAR :VAR:`~VAR.VAR.VAR`. """""" VAR VAR(VAR, VAR): VAR = VAR.VAR(VAR) VAR: VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR.VAR(*VAR) VAR VAR(VAR): """""" .. VAR:: 1.6 VAR VAR VAR. VAR VAR VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR VAR. VAR, VAR :VAR:`VAR`, VAR VAR :VAR:`~VAR.VAR.VAR` VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR ((VAR, VAR) VAR VAR, VAR VAR VAR.VAR(VAR)) VAR ((VAR, VAR) VAR VAR, VAR VAR VAR) VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR ``VAR`` VAR VAR VAR/VAR-VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR (VAR, :VAR:`~VAR.VAR.VAR`). :VAR VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR`. """""" VAR = VAR() VAR VAR VAR VAR: VAR = VAR() VAR VAR VAR VAR(VAR): VAR.VAR(VAR('--%VAR\VAR\VAR' % (VAR))) VAR(VAR).VAR(VAR.VAR()) VAR = VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR)  VAR VAR(VAR, VAR.VAR): VAR(VAR).VAR(VAR) VAR: VAR.VAR(VAR) VAR.VAR(VAR'\VAR\VAR') VAR.VAR(VAR('--%VAR--\VAR\VAR' % (VAR))) VAR = VAR('VAR/VAR-VAR; VAR=%VAR' % VAR) VAR VAR.VAR(), VAR ",1
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,src/urllib3/response.py,"from __future__ import absolute_import
from contextlib import contextmanager
import zlib
import io
import logging
from socket import timeout as SocketTimeout
from socket import error as SocketError

from ._collections import HTTPHeaderDict
from .exceptions import (
    BodyNotHttplibCompatible, ProtocolError, DecodeError, ReadTimeoutError,
    ResponseNotChunked, IncompleteRead, InvalidHeader
)
from .packages.six import string_types as basestring, PY3
from .packages.six.moves import http_client as httplib
from .connection import HTTPException, BaseSSLError
from .util.response import is_fp_closed, is_response_to_head

log = logging.getLogger(__name__)


class DeflateDecoder(object):

    def __init__(self):
        self._first_try = True
        self._data = b''
        self._obj = zlib.decompressobj()

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        if not data:
            return data

        if not self._first_try:
            return self._obj.decompress(data)

        self._data += data
        try:
            decompressed = self._obj.decompress(data)
            if decompressed:
                self._first_try = False
                self._data = None
            return decompressed
        except zlib.error:
            self._first_try = False
            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
            try:
                return self.decompress(self._data)
            finally:
                self._data = None


class GzipDecoderState(object):

    FIRST_MEMBER = 0
    OTHER_MEMBERS = 1
    SWALLOW_DATA = 2


class GzipDecoder(object):

    def __init__(self):
        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
        self._state = GzipDecoderState.FIRST_MEMBER

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        ret = bytearray()
        if self._state == GzipDecoderState.SWALLOW_DATA or not data:
            return bytes(ret)
        while True:
            try:
                ret += self._obj.decompress(data)
            except zlib.error:
                previous_state = self._state
                # Ignore data after the first error
                self._state = GzipDecoderState.SWALLOW_DATA
                if previous_state == GzipDecoderState.OTHER_MEMBERS:
                    # Allow trailing garbage acceptable in other gzip clients
                    return bytes(ret)
                raise
            data = self._obj.unused_data
            if not data:
                return bytes(ret)
            self._state = GzipDecoderState.OTHER_MEMBERS
            self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)


class MultiDecoder(object):
    """"""
    From RFC7231:
        If one or more encodings have been applied to a representation, the
        sender that applied the encodings MUST generate a Content-Encoding
        header field that lists the content codings in the order in which
        they were applied.
    """"""

    def __init__(self, modes):
        self._decoders = [_get_decoder(m.strip()) for m in modes.split(',')]

    def flush(self):
        return self._decoders[0].flush()

    def decompress(self, data):
        for d in reversed(self._decoders):
            data = d.decompress(data)
        return data


def _get_decoder(mode):
    if ',' in mode:
        return MultiDecoder(mode)

    if mode == 'gzip':
        return GzipDecoder()

    return DeflateDecoder()


class HTTPResponse(io.IOBase):
    """"""
    HTTP Response container.

    Backwards-compatible to httplib's HTTPResponse but the response ``body`` is
    loaded and decoded on-demand when the ``data`` property is accessed.  This
    class is also compatible with the Python standard library's :mod:`io`
    module, and can hence be treated as a readable object in the context of that
    framework.

    Extra parameters for behaviour not present in httplib.HTTPResponse:

    :param preload_content:
        If True, the response's body will be preloaded during construction.

    :param decode_content:
        If True, will attempt to decode the body based on the
        'content-encoding' header.

    :param original_response:
        When this HTTPResponse wrapper is generated from an httplib.HTTPResponse
        object, it's convenient to include the original for debug purposes. It's
        otherwise unused.

    :param retries:
        The retries contains the last :class:`~urllib3.util.retry.Retry` that
        was used during the request.

    :param enforce_content_length:
        Enforce content length checking. Body returned by server must match
        value of Content-Length header, if present. Otherwise, raise error.
    """"""

    CONTENT_DECODERS = ['gzip', 'deflate']
    REDIRECT_STATUSES = [301, 302, 303, 307, 308]

    def __init__(self, body='', headers=None, status=0, version=0, reason=None,
                 strict=0, preload_content=True, decode_content=True,
                 original_response=None, pool=None, connection=None, msg=None,
                 retries=None, enforce_content_length=False,
                 request_method=None, request_url=None):

        if isinstance(headers, HTTPHeaderDict):
            self.headers = headers
        else:
            self.headers = HTTPHeaderDict(headers)
        self.status = status
        self.version = version
        self.reason = reason
        self.strict = strict
        self.decode_content = decode_content
        self.retries = retries
        self.enforce_content_length = enforce_content_length

        self._decoder = None
        self._body = None
        self._fp = None
        self._original_response = original_response
        self._fp_bytes_read = 0
        self.msg = msg
        self._request_url = request_url

        if body and isinstance(body, (basestring, bytes)):
            self._body = body

        self._pool = pool
        self._connection = connection

        if hasattr(body, 'read'):
            self._fp = body

        # Are we using the chunked-style of transfer encoding?
        self.chunked = False
        self.chunk_left = None
        tr_enc = self.headers.get('transfer-encoding', '').lower()
        # Don't incur the penalty of creating a list and then discarding it
        encodings = (enc.strip() for enc in tr_enc.split("",""))
        if ""chunked"" in encodings:
            self.chunked = True

        # Determine length of response
        self.length_remaining = self._init_length(request_method)

        # If requested, preload the body.
        if preload_content and not self._body:
            self._body = self.read(decode_content=decode_content)

    def get_redirect_location(self):
        """"""
        Should we redirect and where to?

        :returns: Truthy redirect location string if we got a redirect status
            code and valid location. ``None`` if redirect status and no
            location. ``False`` if not a redirect status code.
        """"""
        if self.status in self.REDIRECT_STATUSES:
            return self.headers.get('location')

        return False

    def release_conn(self):
        if not self._pool or not self._connection:
            return

        self._pool._put_conn(self._connection)
        self._connection = None

    @property
    def data(self):
        # For backwords-compat with earlier urllib3 0.4 and earlier.
        if self._body:
            return self._body

        if self._fp:
            return self.read(cache_content=True)

    @property
    def connection(self):
        return self._connection

    def isclosed(self):
        return is_fp_closed(self._fp)

    def tell(self):
        """"""
        Obtain the number of bytes pulled over the wire so far. May differ from
        the amount of content returned by :meth:``HTTPResponse.read`` if bytes
        are encoded on the wire (e.g, compressed).
        """"""
        return self._fp_bytes_read

    def _init_length(self, request_method):
        """"""
        Set initial length value for Response content if available.
        """"""
        length = self.headers.get('content-length')

        if length is not None:
            if self.chunked:
                # This Response will fail with an IncompleteRead if it can't be
                # received as chunked. This method falls back to attempt reading
                # the response before raising an exception.
                log.warning(""Received response with both Content-Length and ""
                            ""Transfer-Encoding set. This is expressly forbidden ""
                            ""by RFC 7230 sec 3.3.2. Ignoring Content-Length and ""
                            ""attempting to process response as Transfer-Encoding: ""
                            ""chunked."")
                return None

            try:
                # RFC 7230 section 3.3.2 specifies multiple content lengths can
                # be sent in a single Content-Length header
                # (e.g. Content-Length: 42, 42). This line ensures the values
                # are all valid ints and that as long as the `set` length is 1,
                # all values are the same. Otherwise, the header is invalid.
                lengths = set([int(val) for val in length.split(',')])
                if len(lengths) > 1:
                    raise InvalidHeader(""Content-Length contained multiple ""
                                        ""unmatching values (%s)"" % length)
                length = lengths.pop()
            except ValueError:
                length = None
            else:
                if length < 0:
                    length = None

        # Convert status to int for comparison
        # In some cases, httplib returns a status of ""_UNKNOWN""
        try:
            status = int(self.status)
        except ValueError:
            status = 0

        # Check for responses that shouldn't include a body
        if status in (204, 304) or 100 <= status < 200 or request_method == 'HEAD':
            length = 0

        return length

    def _init_decoder(self):
        """"""
        Set-up the _decoder attribute if necessary.
        """"""
        # Note: content-encoding value should be case-insensitive, per RFC 7230
        # Section 3.2
        content_encoding = self.headers.get('content-encoding', '').lower()
        if self._decoder is None:
            if content_encoding in self.CONTENT_DECODERS:
                self._decoder = _get_decoder(content_encoding)
            elif ',' in content_encoding:
                encodings = [
                    e.strip() for e in content_encoding.split(',')
                    if e.strip() in self.CONTENT_DECODERS]
                if len(encodings):
                    self._decoder = _get_decoder(content_encoding)

    def _decode(self, data, decode_content, flush_decoder):
        """"""
        Decode the data passed in and potentially flush the decoder.
        """"""
        try:
            if decode_content and self._decoder:
                data = self._decoder.decompress(data)
        except (IOError, zlib.error) as e:
            content_encoding = self.headers.get('content-encoding', '').lower()
            raise DecodeError(
                ""Received response with content-encoding: %s, but ""
                ""failed to decode it."" % content_encoding, e)

        if flush_decoder and decode_content:
            data += self._flush_decoder()

        return data

    def _flush_decoder(self):
        """"""
        Flushes the decoder. Should only be called if the decoder is actually
        being used.
        """"""
        if self._decoder:
            buf = self._decoder.decompress(b'')
            return buf + self._decoder.flush()

        return b''

    @contextmanager
    def _error_catcher(self):
        """"""
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.

        On exit, release the connection back to the pool.
        """"""
        clean_exit = False

        try:
            try:
                yield

            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if 'read operation timed out' not in str(e):  # Defensive:
                    # This shouldn't happen but just in case we're missing an edge
                    # case, let's avoid swallowing SSL errors.
                    raise

                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
                raise ProtocolError('Connection broken: %r' % e, e)

            # If no exception is thrown, we should avoid cleaning up
            # unnecessarily.
            clean_exit = True
        finally:
            # If we didn't terminate cleanly, we need to throw away our
            # connection.
            if not clean_exit:
                # The response may not be closed but we're not going to use it
                # anymore so close it now to ensure that the connection is
                # released back to the pool.
                if self._original_response:
                    self._original_response.close()

                # Closing the response may not actually be sufficient to close
                # everything, so if we have a hold of the connection close that
                # too.
                if self._connection:
                    self._connection.close()

            # If we hold the original response but it's closed now, we should
            # return the connection back to the pool.
            if self._original_response and self._original_response.isclosed():
                self.release_conn()

    def read(self, amt=None, decode_content=None, cache_content=False):
        """"""
        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional
        parameters: ``decode_content`` and ``cache_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.

        :param cache_content:
            If True, will save the returned data such that the same result is
            returned despite of the state of the underlying file object. This
            is useful if you want the ``.data`` property to continue working
            after having ``.read()`` the file object. (Overridden if ``amt`` is
            set.)
        """"""
        self._init_decoder()
        if decode_content is None:
            decode_content = self.decode_content

        if self._fp is None:
            return

        flush_decoder = False
        data = None

        with self._error_catcher():
            if amt is None:
                # cStringIO doesn't like amt=None
                data = self._fp.read()
                flush_decoder = True
            else:
                cache_content = False
                data = self._fp.read(amt)
                if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.
                    # Close the connection when no data is returned
                    #
                    # This is redundant to what httplib/http.client _should_
                    # already do.  However, versions of python released before
                    # December 15, 2012 (http://bugs.python.org/issue16298) do
                    # not properly close the connection in all cases. There is
                    # no harm in redundantly calling close.
                    self._fp.close()
                    flush_decoder = True
                    if self.enforce_content_length and self.length_remaining not in (0, None):
                        # This is an edge case that httplib failed to cover due
                        # to concerns of backward compatibility. We're
                        # addressing it here to make sure IncompleteRead is
                        # raised during streaming, so all calls with incorrect
                        # Content-Length are caught.
                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)

        if data:
            self._fp_bytes_read += len(data)
            if self.length_remaining is not None:
                self.length_remaining -= len(data)

            data = self._decode(data, decode_content, flush_decoder)

            if cache_content:
                self._body = data

        return data

    def stream(self, amt=2**16, decode_content=None):
        """"""
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.

        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        if self.chunked and self.supports_chunked_reads():
            for line in self.read_chunked(amt, decode_content=decode_content):
                yield line
        else:
            while not is_fp_closed(self._fp):
                data = self.read(amt=amt, decode_content=decode_content)

                if data:
                    yield data

    @classmethod
    def from_httplib(ResponseCls, r, **response_kw):
        """"""
        Given an :class:`httplib.HTTPResponse` instance ``r``, return a
        corresponding :class:`urllib3.response.HTTPResponse` object.

        Remaining parameters are passed to the HTTPResponse constructor, along
        with ``original_response=r``.
        """"""
        headers = r.msg

        if not isinstance(headers, HTTPHeaderDict):
            if PY3:  # Python 3
                headers = HTTPHeaderDict(headers.items())
            else:  # Python 2
                headers = HTTPHeaderDict.from_httplib(headers)

        # HTTPResponse objects in Python 3 don't have a .strict attribute
        strict = getattr(r, 'strict', 0)
        resp = ResponseCls(body=r,
                           headers=headers,
                           status=r.status,
                           version=r.version,
                           reason=r.reason,
                           strict=strict,
                           original_response=r,
                           **response_kw)
        return resp

    # Backwards-compatibility methods for httplib.HTTPResponse
    def getheaders(self):
        return self.headers

    def getheader(self, name, default=None):
        return self.headers.get(name, default)

    # Backwards compatibility for http.cookiejar
    def info(self):
        return self.headers

    # Overrides from io.IOBase
    def close(self):
        if not self.closed:
            self._fp.close()

        if self._connection:
            self._connection.close()

    @property
    def closed(self):
        if self._fp is None:
            return True
        elif hasattr(self._fp, 'isclosed'):
            return self._fp.isclosed()
        elif hasattr(self._fp, 'closed'):
            return self._fp.closed
        else:
            return True

    def fileno(self):
        if self._fp is None:
            raise IOError(""HTTPResponse has no file to get a fileno from"")
        elif hasattr(self._fp, ""fileno""):
            return self._fp.fileno()
        else:
            raise IOError(""The file-like object this HTTPResponse is wrapped ""
                          ""around has no file descriptor"")

    def flush(self):
        if self._fp is not None and hasattr(self._fp, 'flush'):
            return self._fp.flush()

    def readable(self):
        # This method is required for `io` module compatibility.
        return True

    def readinto(self, b):
        # This method is required for `io` module compatibility.
        temp = self.read(len(b))
        if len(temp) == 0:
            return 0
        else:
            b[:len(temp)] = temp
            return len(temp)

    def supports_chunked_reads(self):
        """"""
        Checks if the underlying file-like object looks like a
        httplib.HTTPResponse object. We do this by testing for the fp
        attribute. If it is present we assume it returns raw chunks as
        processed by read_chunked().
        """"""
        return hasattr(self._fp, 'fp')

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b';', 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
            raise httplib.IncompleteRead(line)

    def _handle_chunk(self, amt):
        returned_chunk = None
        if amt is None:
            chunk = self._fp._safe_read(self.chunk_left)
            returned_chunk = chunk
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        elif amt < self.chunk_left:
            value = self._fp._safe_read(amt)
            self.chunk_left = self.chunk_left - amt
            returned_chunk = value
        elif amt == self.chunk_left:
            value = self._fp._safe_read(amt)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
            returned_chunk = value
        else:  # amt > self.chunk_left
            returned_chunk = self._fp._safe_read(self.chunk_left)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        return returned_chunk

    def read_chunked(self, amt=None, decode_content=None):
        """"""
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                ""Response is not chunked. ""
                ""Header 'transfer-encoding: chunked' is missing."")
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                ""Body should be httplib.HTTPResponse like. ""
                ""It should have have an fp attribute which returns raw chunks."")

        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return

            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return

            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(chunk, decode_content=decode_content,
                                       flush_decoder=False)
                if decoded:
                    yield decoded

            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded

            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b'\r\n':
                    break

            # We read everything; close the ""file"".
            if self._original_response:
                self._original_response.close()

    def geturl(self):
        """"""
        Returns the URL that was the source of this response.
        If the request that generated this response redirected, this method
        will return the final redirect location.
        """"""
        if self.retries is not None and len(self.retries.history):
            return self.retries.history[-1].redirect_location
        else:
            return self._request_url

    def __iter__(self):
        buffer = [b""""]
        for chunk in self.stream(decode_content=True):
            if b""\n"" in chunk:
                chunk = chunk.split(b""\n"")
                yield b"""".join(buffer) + chunk[0] + b""\n""
                for x in chunk[1:-1]:
                    yield x + b""\n""
                if chunk[-1]:
                    buffer = [chunk[-1]]
                else:
                    buffer = []
            else:
                buffer.append(chunk)
        if buffer:
            yield b"""".join(buffer)",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR ) VAR .VAR.VAR VAR VAR VAR VAR, VAR VAR .VAR.VAR.VAR VAR VAR VAR VAR VAR .VAR VAR VAR, VAR VAR .VAR.VAR VAR VAR, VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR) VAR.VAR += VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR: VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR VAR.VAR = VAR.VAR(-VAR.VAR) VAR: VAR VAR.VAR(VAR.VAR) VAR: VAR.VAR = VAR VAR VAR(VAR): VAR = 0 VAR = 1 VAR = 2 VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR.VAR = VAR.VAR VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR = VAR() VAR VAR.VAR == VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR VAR: VAR: VAR += VAR.VAR.VAR(VAR) VAR VAR.VAR: VAR = VAR.VAR  VAR.VAR = VAR.VAR VAR VAR == VAR.VAR:  VAR VAR(VAR) VAR VAR = VAR.VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR.VAR = VAR.VAR VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR VAR(VAR): """""" VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = [VAR(VAR.VAR()) VAR VAR VAR VAR.VAR(',')] VAR VAR(VAR): VAR VAR.VAR[0].VAR() VAR VAR(VAR, VAR): VAR VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR ',' VAR VAR: VAR VAR(VAR) VAR VAR == 'VAR': VAR VAR() VAR VAR() VAR VAR(VAR.VAR): """""" VAR VAR VAR. VAR-VAR VAR VAR'VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR-VAR VAR VAR ``VAR`` VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR :VAR:`VAR` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR.VAR: :VAR VAR: VAR VAR, VAR VAR'VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR'VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR, VAR VAR. VAR, VAR VAR. """""" VAR = ['VAR', 'VAR'] VAR = [301, 302, 303, 307, 308] VAR VAR(VAR, VAR='', VAR=VAR, VAR=0, VAR=0, VAR=VAR, VAR=0, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR VAR(VAR, VAR): VAR.VAR = VAR VAR: VAR.VAR = VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR(VAR, (VAR, VAR)): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, 'VAR'): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR VAR = VAR.VAR.VAR('VAR-VAR', '').VAR()  VAR = (VAR.VAR() VAR VAR VAR VAR.VAR("","")) VAR ""VAR"" VAR VAR: VAR.VAR = VAR  VAR.VAR = VAR.VAR(VAR)  VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR.VAR(VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR? :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR.VAR('VAR') VAR VAR VAR VAR(VAR): VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR.VAR) VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR VAR.VAR: VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR(VAR=VAR) @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:``VAR.VAR`` VAR VAR VAR VAR VAR VAR VAR (VAR.VAR, VAR). """""" VAR VAR.VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR') VAR VAR VAR VAR VAR: VAR VAR.VAR:    VAR.VAR(""VAR VAR VAR VAR VAR-VAR VAR "" ""VAR-VAR VAR. VAR VAR VAR VAR "" ""VAR VAR 7230 VAR 3.3.2. VAR VAR-VAR VAR "" ""VAR VAR VAR VAR VAR VAR-VAR: "" ""VAR."") VAR VAR VAR:      VAR = VAR([VAR(VAR) VAR VAR VAR VAR.VAR(',')]) VAR VAR(VAR) > 1: VAR VAR(""VAR-VAR VAR VAR "" ""VAR VAR (%VAR)"" % VAR) VAR = VAR.VAR() VAR VAR: VAR = VAR VAR: VAR VAR < 0: VAR = VAR   VAR: VAR = VAR(VAR.VAR) VAR VAR: VAR = 0  VAR VAR VAR (204, 304) VAR 100 <= VAR < 200 VAR VAR == 'VAR': VAR = 0 VAR VAR VAR VAR(VAR): """""" VAR-VAR VAR VAR VAR VAR VAR. """"""   VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR.VAR VAR VAR: VAR VAR VAR VAR.VAR: VAR.VAR = VAR(VAR) VAR ',' VAR VAR: VAR = [ VAR.VAR() VAR VAR VAR VAR.VAR(',') VAR VAR.VAR() VAR VAR.VAR] VAR VAR(VAR): VAR.VAR = VAR(VAR) VAR VAR(VAR, VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR: VAR VAR VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR (VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR( ""VAR VAR VAR VAR-VAR: %VAR, VAR "" ""VAR VAR VAR VAR."" % VAR, VAR) VAR VAR VAR VAR: VAR += VAR.VAR() VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR'') VAR VAR + VAR.VAR.VAR() VAR VAR'' @VAR VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR, VAR VAR-VAR VAR VAR, VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR VAR: VAR: VAR VAR VAR:   VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR VAR VAR VAR:  VAR 'VAR VAR VAR VAR' VAR VAR VAR(VAR):    VAR VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR (VAR, VAR) VAR VAR:  VAR VAR('VAR VAR: %VAR' % VAR, VAR)   VAR = VAR VAR:   VAR VAR VAR:    VAR VAR.VAR: VAR.VAR.VAR()    VAR VAR.VAR: VAR.VAR.VAR()   VAR VAR.VAR VAR VAR.VAR.VAR(): VAR.VAR() VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR`` VAR ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR ``.VAR`` VAR VAR VAR VAR VAR VAR ``.VAR()`` VAR VAR VAR. (VAR VAR ``VAR`` VAR VAR.) """""" VAR.VAR() VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR.VAR VAR VAR: VAR VAR = VAR VAR = VAR VAR VAR.VAR(): VAR VAR VAR VAR:  VAR = VAR.VAR.VAR() VAR = VAR VAR: VAR = VAR VAR = VAR.VAR.VAR(VAR) VAR VAR != 0 VAR VAR VAR:         VAR.VAR.VAR() VAR = VAR VAR VAR.VAR VAR VAR.VAR VAR VAR (0, VAR):      VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR += VAR(VAR) VAR VAR.VAR VAR VAR VAR: VAR.VAR -= VAR(VAR) VAR = VAR.VAR(VAR, VAR, VAR) VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=2**16, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR() VAR. VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR VAR.VAR VAR VAR.VAR(): VAR VAR VAR VAR.VAR(VAR, VAR=VAR): VAR VAR VAR: VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR=VAR, VAR=VAR) VAR VAR: VAR VAR @VAR VAR VAR(VAR, VAR, **VAR): """""" VAR VAR :VAR:`VAR.VAR` VAR ``VAR``, VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR ``VAR=VAR``. """""" VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR VAR:  VAR = VAR(VAR.VAR()) VAR:  VAR = VAR.VAR(VAR)  VAR = VAR(VAR, 'VAR', 0) VAR = VAR(VAR=VAR, VAR=VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR, **VAR) VAR VAR  VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR, VAR, VAR=VAR): VAR VAR.VAR.VAR(VAR, VAR)  VAR VAR(VAR): VAR VAR.VAR  VAR VAR(VAR): VAR VAR VAR.VAR: VAR.VAR.VAR() VAR VAR.VAR: VAR.VAR.VAR() @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR VAR: VAR VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR: VAR VAR(""VAR VAR-VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR"") VAR VAR(VAR): VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR):  VAR VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR(VAR(VAR)) VAR VAR(VAR) == 0: VAR 0 VAR: VAR[:VAR(VAR)] = VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR.VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR(). """""" VAR VAR(VAR.VAR, 'VAR') VAR VAR(VAR):   VAR VAR.VAR VAR VAR VAR: VAR VAR = VAR.VAR.VAR.VAR() VAR = VAR.VAR(VAR';', 1)[0] VAR: VAR.VAR = VAR(VAR, 16) VAR VAR:  VAR.VAR() VAR VAR.VAR(VAR) VAR VAR(VAR, VAR): VAR = VAR VAR VAR VAR VAR: VAR = VAR.VAR.VAR(VAR.VAR) VAR = VAR VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR < VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR = VAR.VAR - VAR VAR = VAR VAR VAR == VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR = VAR VAR:  VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR.VAR()  VAR VAR VAR.VAR: VAR VAR( ""VAR VAR VAR VAR. "" ""VAR 'VAR-VAR: VAR' VAR VAR."") VAR VAR VAR.VAR(): VAR VAR( ""VAR VAR VAR VAR.VAR VAR. "" ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR.VAR():  VAR VAR.VAR VAR VAR(VAR.VAR): VAR.VAR.VAR() VAR   VAR VAR.VAR.VAR VAR VAR: VAR VAR VAR: VAR.VAR() VAR VAR.VAR == 0: VAR VAR = VAR.VAR(VAR) VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR: VAR VAR VAR VAR:    VAR = VAR.VAR() VAR VAR:  VAR VAR  VAR VAR: VAR = VAR.VAR.VAR.VAR() VAR VAR VAR:  VAR VAR VAR == VAR'\VAR\VAR': VAR  VAR VAR.VAR: VAR.VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR.VAR): VAR VAR.VAR.VAR[-1].VAR VAR: VAR VAR.VAR VAR VAR(VAR): VAR = [VAR""""] VAR VAR VAR VAR.VAR(VAR=VAR): VAR VAR""\VAR"" VAR VAR: VAR = VAR.VAR(VAR""\VAR"") VAR VAR"""".VAR(VAR) + VAR[0] + VAR""\VAR"" VAR VAR VAR VAR[1:-1]: VAR VAR + VAR""\VAR"" VAR VAR[-1]: VAR = [VAR[-1]] VAR: VAR = [] VAR: VAR.VAR(VAR) VAR VAR: VAR VAR"""".VAR(VAR) ",1
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/test_response.py,"import socket
import zlib

from io import BytesIO, BufferedReader

import pytest
import mock

from urllib3.response import HTTPResponse
from urllib3.exceptions import (
    DecodeError, ResponseNotChunked, ProtocolError, InvalidHeader
)
from urllib3.packages.six.moves import http_client as httplib
from urllib3.util.retry import Retry, RequestHistory
from urllib3.util.response import is_fp_closed

from base64 import b64decode

# A known random (i.e, not-too-compressible) payload generated with:
#    """".join(random.choice(string.printable) for i in xrange(512))
#    .encode(""zlib"").encode(""base64"")
# Randomness in tests == bad, and fixing a seed may not be sufficient.
ZLIB_PAYLOAD = b64decode(b""""""\
eJwFweuaoQAAANDfineQhiKLUiaiCzvuTEmNNlJGiL5QhnGpZ99z8luQfe1AHoMioB+QSWHQu/L+
lzd7W5CipqYmeVTBjdgSATdg4l4Z2zhikbuF+EKn69Q0DTpdmNJz8S33odfJoVEexw/l2SS9nFdi
pis7KOwXzfSqarSo9uJYgbDGrs1VNnQpT9f8zAorhYCEZronZQF9DuDFfNK3Hecc+WHLnZLQptwk
nufw8S9I43sEwxsT71BiqedHo0QeIrFE01F/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/nNvDGKZ
Khe5TF36JbnKVjdcL1EUNpwrWVfQpFYJ/WWm2b74qNeSZeQv5/xBhRdOmKTJFYgO96PwrHBlsnLn
a3l0LwJsloWpMbzByU5WLbRE6X5INFqjQOtIwYz5BAlhkn+kVqJvWM5vBlfrwP42ifonM5yF4ciJ
auHVks62997mNGOsM7WXNG3P98dBHPo2NhbTvHleL0BI5dus2JY81MUOnK3SGWLH8HeWPa1t5KcW
S5moAj5HexY/g/F8TctpxwsvyZp38dXeLDjSQvEQIkF7XR3YXbeZgKk3V34KGCPOAeeuQDIgyVhV
nP4HF2uWHA=="""""")


@pytest.fixture
def sock():
    s = socket.socket()
    yield s
    s.close()


class TestLegacyResponse(object):
    def test_getheaders(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheaders() == headers

    def test_getheader(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheader('host') == 'example.com'


class TestResponse(object):
    def test_cache_content(self):
        r = HTTPResponse('foo')
        assert r.data == 'foo'
        assert r._body == 'foo'

    def test_default(self):
        r = HTTPResponse()
        assert r.data is None

    def test_none(self):
        r = HTTPResponse(None)
        assert r.data is None

    def test_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=True)

        assert fp.tell() == len(b'foo')
        assert r.data == b'foo'

    def test_no_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=False)

        assert fp.tell() == 0
        assert r.data == b'foo'
        assert fp.tell() == len(b'foo')

    def test_decode_bad_data(self):
        fp = BytesIO(b'\x00' * 10)
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'deflate'})

    def test_reference_read(self):
        fp = BytesIO(b'foo')
        r = HTTPResponse(fp, preload_content=False)

        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'})

        assert r.data == b'foo'

    def test_decode_deflate_case_insensitve(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'DeFlAtE'})

        assert r.data == b'foo'

    def test_chunked_decoding_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(3) == b''
        # Buffer in case we need to switch to the raw stream
        assert r._decoder._data is not None
        assert r.read(1) == b'f'
        # Now that we've decoded data, we just stream through the decoder
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_deflate2(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(1) == b''
        assert r.read(1) == b'f'
        # Once we've decoded data, we just stream to the decoder; no buffering
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                         preload_content=False)

        assert r.read(11) == b''
        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_gzip_multi_member(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    def test_decode_gzip_error(self):
        fp = BytesIO(b'foo')
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'gzip'})

    def test_decode_gzip_swallow_garbage(self):
        # When data comes from multiple calls to read(), data after
        # the first zlib error (here triggered by garbage) should be
        # ignored.
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={'content-encoding': 'gzip'}, preload_content=False)
        ret = b''
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break

        assert ret == b'foofoofoo'

    def test_chunked_decoding_gzip_swallow_garbage(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    def test_multi_decoding_deflate_deflate(self):
        data = zlib.compress(zlib.compress(b'foo'))

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, deflate'})

        assert r.data == b'foo'

    def test_multi_decoding_deflate_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(zlib.compress(b'foo'))
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, gzip'})

        assert r.data == b'foo'

    def test_multi_decoding_gzip_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(data)
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip, gzip'})

        assert r.data == b'foo'

    def test_body_blob(self):
        resp = HTTPResponse(b'foo')
        assert resp.data == b'foo'
        assert resp.closed

    def test_io(self, sock):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)

        assert not resp.closed
        assert resp.readable()
        assert not resp.writable()
        with pytest.raises(IOError):
            resp.fileno()

        resp.close()
        assert resp.closed

        # Try closing with an `httplib.HTTPResponse`, because it has an
        # `isclosed` method.
        try:
            hlr = httplib.HTTPResponse(sock)
            resp2 = HTTPResponse(hlr, preload_content=False)
            assert not resp2.closed
            resp2.close()
            assert resp2.closed
        finally:
            hlr.close()

        # also try when only data is present.
        resp3 = HTTPResponse('foodata')
        with pytest.raises(IOError):
            resp3.fileno()

        resp3._fp = 2
        # A corner case where _fp is present but doesn't have `closed`,
        # `isclosed`, or `fileno`.  Unlikely, but possible.
        assert resp3.closed
        with pytest.raises(IOError):
            resp3.fileno()

    def test_io_closed_consistently(self, sock):
        try:
            hlr = httplib.HTTPResponse(sock)
            hlr.fp = BytesIO(b'foo')
            hlr.chunked = 0
            hlr.length = 3
            with HTTPResponse(hlr, preload_content=False) as resp:
                assert not resp.closed
                assert not resp._fp.isclosed()
                assert not is_fp_closed(resp._fp)
                assert not resp.isclosed()
                resp.read()
                assert resp.closed
                assert resp._fp.isclosed()
                assert is_fp_closed(resp._fp)
                assert resp.isclosed()
        finally:
            hlr.close()

    def test_io_bufferedreader(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp)

        assert br.read() == b'foo'

        br.close()
        assert resp.closed

        b = b'fooandahalf'
        fp = BytesIO(b)
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp, 5)

        br.read(1)  # sets up the buffer, reading 5
        assert len(fp.read()) == (len(b) - 5)

        # This is necessary to make sure the ""no bytes left"" part of `readinto`
        # gets tested.
        while not br.closed:
            br.read(5)

    def test_streaming(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_streaming_tell(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        position = 0

        position += len(next(stream))
        assert 2 == position
        assert position == resp.tell()

        position += len(next(stream))
        assert 3 == position
        assert position == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming_tell(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        uncompressed_data = b'foo'
        data = compress.compress(uncompressed_data)
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream()

        # Read everything
        payload = next(stream)
        assert payload == uncompressed_data

        assert len(data) == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate_streaming_tell_intermediate_point(self):
        # Ensure that ``tell()`` returns the correct number of bytes when
        # part-way through streaming compressed content.
        NUMBER_OF_READS = 10

        class MockCompressedDataReading(BytesIO):
            """"""
            A ByteIO-like reader returning ``payload`` in ``NUMBER_OF_READS``
            calls to ``read``.
            """"""

            def __init__(self, payload, payload_part_size):
                self.payloads = [
                    payload[i*payload_part_size:(i+1)*payload_part_size]
                    for i in range(NUMBER_OF_READS+1)]

                assert b"""".join(self.payloads) == payload

            def read(self, _):
                # Amount is unused.
                if len(self.payloads) > 0:
                    return self.payloads.pop(0)
                return b""""

        uncompressed_data = zlib.decompress(ZLIB_PAYLOAD)

        payload_part_size = len(ZLIB_PAYLOAD) // NUMBER_OF_READS
        fp = MockCompressedDataReading(ZLIB_PAYLOAD, payload_part_size)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream()

        parts_positions = [(part, resp.tell()) for part in stream]
        end_of_stream = resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

        parts, positions = zip(*parts_positions)

        # Check that the payload is equal to the uncompressed data
        payload = b"""".join(parts)
        assert uncompressed_data == payload

        # Check that the positions in the stream are correct
        expected = [(i+1)*payload_part_size for i in range(NUMBER_OF_READS)]
        assert expected == list(positions)

        # Check that the end of the stream is in the correct place
        assert len(ZLIB_PAYLOAD) == end_of_stream

    def test_deflate_streaming(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate2_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_empty_stream(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        with pytest.raises(StopIteration):
            next(stream)

    def test_length_no_header(self):
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        assert resp.length_remaining is None

    def test_length_w_valid_header(self):
        headers = {""content-length"": ""5""}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

    def test_length_w_bad_header(self):
        garbage = {'content-length': 'foo'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

        garbage['content-length'] = ""-10""
        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

    def test_length_when_chunked(self):
        # This is expressly forbidden in RFC 7230 sec 3.3.2
        # We fall back to chunked in this case and try to
        # handle response ignoring content length.
        headers = {'content-length': '5',
                   'transfer-encoding': 'chunked'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining is None

    def test_length_with_multiple_content_lengths(self):
        headers = {'content-length': '5, 5, 5'}
        garbage = {'content-length': '5, 42'}
        fp = BytesIO(b'abcde')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

        with pytest.raises(InvalidHeader):
            HTTPResponse(fp, headers=garbage, preload_content=False)

    def test_length_after_read(self):
        headers = {""content-length"": ""5""}

        # Test no defined length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        resp.read()
        assert resp.length_remaining is None

        # Test our update from content-length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        resp.read()
        assert resp.length_remaining == 0

        # Test partial read
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        data = resp.stream(2)
        next(data)
        assert resp.length_remaining == 3

    def test_mock_httpresponse_stream(self):
        # Mock out a HTTP Request that does enough to make it through urllib3's
        # read() and close() calls, and also exhausts and underlying file
        # object.
        class MockHTTPRequest(object):
            self.fp = None

            def read(self, amt):
                data = self.fp.read(amt)
                if not data:
                    self.fp = None

                return data

            def close(self):
                self.fp = None

        bio = BytesIO(b'foo')
        fp = MockHTTPRequest()
        fp.fp = bio
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_mock_transfer_encoding_chunked(self):
        stream = [b""fo"", b""o"", b""bar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})

        for i, c in enumerate(resp.stream()):
            assert c == stream[i]

    def test_mock_gzipped_transfer_encoding_chunked_decoded(self):
        """"""Show that we can decode the gizpped and chunked body.""""""
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b'foobar')
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i:i+2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {'transfer-encoding': 'chunked', 'content-encoding': 'gzip'}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b''
        for c in resp.stream(decode_content=True):
            data += c

        assert b'foobar' == data

    def test_mock_transfer_encoding_chunked_custom_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        expected_response = [b'fo', b'oo', b'o', b'bb', b'bb', b'aa', b'aa', b'ar']
        response = list(resp.read_chunked(2))
        assert expected_response == response

    def test_mock_transfer_encoding_chunked_unlmtd_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.read_chunked())

    def test_read_not_chunked_response_as_chunks(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        r = resp.read_chunked()
        with pytest.raises(ResponseNotChunked):
            next(r)

    def test_invalid_chunks(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedInvalidEncoding(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        with pytest.raises(ProtocolError):
            next(resp.read_chunked())

    def test_chunked_response_without_crlf_on_end(self):
        stream = [b""foo"", b""bar"", b""baz""]
        fp = MockChunkedEncodingWithoutCRLFOnEnd(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_response_with_extensions(self):
        stream = [b""foo"", b""bar""]
        fp = MockChunkedEncodingWithExtensions(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_head_response(self):
        r = httplib.HTTPResponse(MockSock, method='HEAD')
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse('',
                            preload_content=False,
                            headers={'transfer-encoding': 'chunked'},
                            original_response=r)
        assert resp.chunked is True

        resp.supports_chunked_reads = lambda: True
        resp.release_conn = mock.Mock()
        for _ in resp.stream():
            continue
        resp.release_conn.assert_called_once_with()

    def test_get_case_insensitive_headers(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.headers.get('host') == 'example.com'
        assert r.headers.get('Host') == 'example.com'

    def test_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp)
        assert resp.retries is None
        retry = Retry()
        resp = HTTPResponse(fp, retries=retry)
        assert resp.retries == retry

    def test_geturl(self):
        fp = BytesIO(b'')
        request_url = 'https://example.com'
        resp = HTTPResponse(fp, request_url=request_url)
        assert resp.geturl() == request_url

    def test_geturl_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, request_url='http://example.com')
        request_histories = [
            RequestHistory(method='GET', url='http://example.com', error=None,
                           status=301, redirect_location='https://example.com/'),
            RequestHistory(method='GET', url='https://example.com/', error=None,
                           status=301, redirect_location='https://www.example.com')]
        retry = Retry(history=request_histories)
        resp = HTTPResponse(fp, retries=retry)
        assert resp.geturl() == 'https://www.example.com'

    @pytest.mark.parametrize(
        [""payload"", ""expected_stream""],
        [(b"""", [b""""]),
         (b""\n"", [b""\n""]),
         (b""abc\ndef"", [b""abc\n"", b""def""]),
         (b""Hello\nworld\n\n\n!"", [b""Hello\n"", b""world\n"", b""\n"", b""\n"", b""!""])]
    )
    def test__iter__(self, payload, expected_stream):
        actual_stream = []
        for chunk in HTTPResponse(BytesIO(payload), preload_content=False):
            actual_stream.append(chunk)

        assert actual_stream == expected_stream

    def test__iter__decode_content(self):
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b'foo\nbar')
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i:i + 2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {'transfer-encoding': 'chunked', 'content-encoding': 'gzip'}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b''
        for c in resp:
            data += c

        assert b'foo\nbar' == data


class MockChunkedEncodingResponse(object):

    def __init__(self, content):
        """"""
        content: collection of str, each str is a chunk in response
        """"""
        self.content = content
        self.index = 0  # This class iterates over self.content.
        self.closed = False
        self.cur_chunk = b''
        self.chunks_exhausted = False

    @staticmethod
    def _encode_chunk(chunk):
        # In the general case, we can't decode the chunk to unicode
        length = '%X\r\n' % len(chunk)
        return length.encode() + chunk + b'\r\n'

    def _pop_new_chunk(self):
        if self.chunks_exhausted:
            return b""""
        try:
            chunk = self.content[self.index]
        except IndexError:
            chunk = b''
            self.chunks_exhausted = True
        else:
            self.index += 1
        chunk = self._encode_chunk(chunk)
        if not isinstance(chunk, bytes):
            chunk = chunk.encode()
        return chunk

    def pop_current_chunk(self, amt=-1, till_crlf=False):
        if amt > 0 and till_crlf:
            raise ValueError(""Can't specify amt and till_crlf."")
        if len(self.cur_chunk) <= 0:
            self.cur_chunk = self._pop_new_chunk()
        if till_crlf:
            try:
                i = self.cur_chunk.index(b""\r\n"")
            except ValueError:
                # No CRLF in current chunk -- probably caused by encoder.
                self.cur_chunk = b""""
                return b""""
            else:
                chunk_part = self.cur_chunk[:i+2]
                self.cur_chunk = self.cur_chunk[i+2:]
                return chunk_part
        elif amt <= -1:
            chunk_part = self.cur_chunk
            self.cur_chunk = b''
            return chunk_part
        else:
            try:
                chunk_part = self.cur_chunk[:amt]
            except IndexError:
                chunk_part = self.cur_chunk
                self.cur_chunk = b''
            else:
                self.cur_chunk = self.cur_chunk[amt:]
            return chunk_part

    def readline(self):
        return self.pop_current_chunk(till_crlf=True)

    def read(self, amt=-1):
        return self.pop_current_chunk(amt)

    def flush(self):
        # Python 3 wants this method.
        pass

    def close(self):
        self.closed = True


class MockChunkedInvalidEncoding(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return 'ZZZ\r\n%s\r\n' % chunk.decode()


class MockChunkedEncodingWithoutCRLFOnEnd(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X\r\n%s%s' % (len(chunk), chunk.decode(),
                               ""\r\n"" if len(chunk) > 0 else """")


class MockChunkedEncodingWithExtensions(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X;asd=qwe\r\n%s\r\n' % (len(chunk), chunk.decode())


class MockSock(object):
    @classmethod
    def makefile(cls, *args, **kwargs):
        return",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR ) VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR VAR VAR     VAR = VAR(VAR""""""\ VAR+VAR/VAR+ VAR+VAR/VAR VAR+VAR VAR/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/VAR VAR/VAR/VAR VAR+VAR VAR VAR/VAR/VAR VAR=="""""") @VAR.VAR VAR VAR(): VAR = VAR.VAR() VAR VAR VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR VAR(VAR): VAR = VAR('VAR') VAR VAR.VAR == 'VAR' VAR VAR.VAR == 'VAR' VAR VAR(VAR): VAR = VAR() VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 0 VAR VAR.VAR == VAR'VAR' VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR(VAR): VAR = VAR(VAR'\VAR' * 10) VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(3) == VAR''  VAR VAR.VAR.VAR VAR VAR VAR VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(1) == VAR'' VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(11) == VAR'' VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR):    VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR( VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR VAR.VAR() VAR VAR VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR.VAR   VAR: VAR = VAR.VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR.VAR() VAR VAR.VAR VAR: VAR.VAR()  VAR = VAR('VAR') VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR = 2   VAR VAR.VAR VAR VAR.VAR(VAR): VAR.VAR() VAR VAR(VAR, VAR): VAR: VAR = VAR.VAR(VAR) VAR.VAR = VAR(VAR'VAR') VAR.VAR = 0 VAR.VAR = 3 VAR VAR(VAR, VAR=VAR) VAR VAR: VAR VAR VAR.VAR VAR VAR VAR.VAR.VAR() VAR VAR VAR(VAR.VAR) VAR VAR VAR.VAR() VAR.VAR() VAR VAR.VAR VAR VAR.VAR.VAR() VAR VAR(VAR.VAR) VAR VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR) VAR VAR.VAR() == VAR'VAR' VAR.VAR() VAR VAR.VAR VAR = VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR, 5) VAR.VAR(1)  VAR VAR(VAR.VAR()) == (VAR(VAR) - 5)   VAR VAR VAR.VAR: VAR.VAR(5) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR = 0 VAR += VAR(VAR(VAR)) VAR 2 == VAR VAR VAR == VAR.VAR() VAR += VAR(VAR(VAR)) VAR 3 == VAR VAR VAR == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR'VAR' VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR()  VAR = VAR(VAR) VAR VAR == VAR VAR VAR(VAR) == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR):   VAR = 10 VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR ``VAR`` VAR ``VAR`` VAR VAR ``VAR``. """""" VAR VAR(VAR, VAR, VAR): VAR.VAR = [ VAR[VAR*VAR:(VAR+1)*VAR] VAR VAR VAR VAR(VAR+1)] VAR VAR"""".VAR(VAR.VAR) == VAR VAR VAR(VAR, VAR):  VAR VAR(VAR.VAR) > 0: VAR VAR.VAR.VAR(0) VAR VAR"""" VAR = VAR.VAR(VAR) VAR = VAR(VAR)  VAR = VAR(VAR, VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR() VAR = [(VAR, VAR.VAR()) VAR VAR VAR VAR] VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR, VAR = VAR(*VAR)  VAR = VAR"""".VAR(VAR) VAR VAR == VAR  VAR = [(VAR+1)*VAR VAR VAR VAR VAR(VAR)] VAR VAR == VAR(VAR)  VAR VAR(VAR) == VAR VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR['VAR-VAR'] = ""-10"" VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR):    VAR = {'VAR-VAR': '5', 'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {'VAR-VAR': '5, 5, 5'} VAR = {'VAR-VAR': '5, 42'} VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR.VAR(VAR): VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""}  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR VAR VAR  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR == 0  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR(2) VAR(VAR) VAR VAR.VAR == 3 VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(VAR) VAR VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR): VAR.VAR = VAR VAR = VAR(VAR'VAR') VAR = VAR() VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR, VAR VAR VAR(VAR.VAR()): VAR VAR == VAR[VAR] VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR:VAR+2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': 'VAR'} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR.VAR(VAR=VAR): VAR += VAR VAR VAR'VAR' == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR = [VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR'] VAR = VAR(VAR.VAR(2)) VAR VAR == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR = VAR VAR.VAR = VAR VAR = VAR('', VAR=VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR VAR VAR VAR.VAR = VAR: VAR VAR.VAR = VAR.VAR() VAR VAR VAR VAR.VAR(): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR = VAR() VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = 'VAR: VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR='VAR: VAR = [ VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR = VAR(VAR=VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 'VAR: @VAR.VAR.VAR( [""VAR"", ""VAR""], [(VAR"""", [VAR""""]), (VAR""\VAR"", [VAR""\VAR""]), (VAR""VAR\VAR"", [VAR""VAR\VAR"", VAR""VAR""]), (VAR""VAR\VAR\VAR\VAR\VAR!"", [VAR""VAR\VAR"", VAR""VAR\VAR"", VAR""\VAR"", VAR""\VAR"", VAR""!""])] ) VAR VAR(VAR, VAR, VAR): VAR = [] VAR VAR VAR VAR(VAR(VAR), VAR=VAR): VAR.VAR(VAR) VAR VAR == VAR VAR VAR(VAR): VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR\VAR') VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR:VAR + 2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': 'VAR'} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR: VAR += VAR VAR VAR'VAR\VAR' == VAR VAR VAR(VAR): VAR VAR(VAR, VAR): """""" VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR """""" VAR.VAR = VAR VAR.VAR = 0  VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR = '%VAR\VAR\VAR' % VAR(VAR) VAR VAR.VAR() + VAR + VAR'\VAR\VAR' VAR VAR(VAR): VAR VAR.VAR: VAR VAR"""" VAR: VAR = VAR.VAR[VAR.VAR] VAR VAR: VAR = VAR'' VAR.VAR = VAR VAR: VAR.VAR += 1 VAR = VAR.VAR(VAR) VAR VAR VAR(VAR, VAR): VAR = VAR.VAR() VAR VAR VAR VAR(VAR, VAR=-1, VAR=VAR): VAR VAR > 0 VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR."") VAR VAR(VAR.VAR) <= 0: VAR.VAR = VAR.VAR() VAR VAR: VAR: VAR = VAR.VAR.VAR(VAR""\VAR\VAR"") VAR VAR:  VAR.VAR = VAR"""" VAR VAR"""" VAR: VAR = VAR.VAR[:VAR+2] VAR.VAR = VAR.VAR[VAR+2:] VAR VAR VAR VAR <= -1: VAR = VAR.VAR VAR.VAR = VAR'' VAR VAR VAR: VAR: VAR = VAR.VAR[:VAR] VAR VAR: VAR = VAR.VAR VAR.VAR = VAR'' VAR: VAR.VAR = VAR.VAR[VAR:] VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR=VAR) VAR VAR(VAR, VAR=-1): VAR VAR.VAR(VAR) VAR VAR(VAR):  VAR VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR): VAR VAR(VAR, VAR): VAR 'VAR\VAR\VAR%VAR\VAR\VAR' % VAR.VAR() VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR\VAR\VAR%VAR%VAR' % (VAR(VAR), VAR.VAR(), ""\VAR\VAR"" VAR VAR(VAR) > 0 VAR """") VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR;VAR=VAR\VAR\VAR%VAR\VAR\VAR' % (VAR(VAR), VAR.VAR()) VAR VAR(VAR): @VAR VAR VAR(VAR, *VAR, **VAR): VAR ",1
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/with_dummyserver/test_chunked_transfer.py,"# -*- coding: utf-8 -*-

from urllib3 import HTTPConnectionPool
from dummyserver.testcase import SocketDummyServerTestCase


class TestChunkedTransfer(SocketDummyServerTestCase):
    def start_chunked_handler(self):
        self.buffer = b''

        def socket_handler(listener):
            sock = listener.accept()[0]

            while not self.buffer.endswith(b'\r\n0\r\n\r\n'):
                self.buffer += sock.recv(65536)

            sock.send(
               b'HTTP/1.1 200 OK\r\n'
               b'Content-type: text/plain\r\n'
               b'Content-Length: 0\r\n'
               b'\r\n')
            sock.close()

        self._start_server(socket_handler)

    def test_chunks(self):
        self.start_chunked_handler()
        chunks = ['foo', 'bar', '', 'bazzzzzzzzzzzzzzzzzzzzzz']
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        pool.urlopen('GET', '/', chunks, headers=dict(DNT='1'), chunked=True)
        self.addCleanup(pool.close)

        self.assertIn(b'Transfer-Encoding', self.buffer)
        body = self.buffer.split(b'\r\n\r\n', 1)[1]
        lines = body.split(b'\r\n')
        # Empty chunks should have been skipped, as this could not be distinguished
        # from terminating the transmission
        for i, chunk in enumerate([c for c in chunks if c]):
            self.assertEqual(lines[i * 2], hex(len(chunk))[2:].encode('utf-8'))
            self.assertEqual(lines[i * 2 + 1], chunk.encode('utf-8'))

    def _test_body(self, data):
        self.start_chunked_handler()
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)

        pool.urlopen('GET', '/', data, chunked=True)
        header, body = self.buffer.split(b'\r\n\r\n', 1)

        self.assertIn(b'Transfer-Encoding: chunked', header.split(b'\r\n'))
        if data:
            bdata = data if isinstance(data, bytes) else data.encode('utf-8')
            self.assertIn(b'\r\n' + bdata + b'\r\n', body)
            self.assertTrue(body.endswith(b'\r\n0\r\n\r\n'))

            len_str = body.split(b'\r\n', 1)[0]
            stated_len = int(len_str, 16)
            self.assertEqual(stated_len, len(bdata))
        else:
            self.assertEqual(body, b'0\r\n\r\n')

    def test_bytestring_body(self):
        self._test_body(b'thisshouldbeonechunk\r\nasdf')

    def test_unicode_body(self):
        # Define u'thisshouldbeonechunk\r\n' in a way, so that python3.1
        # does not suffer a syntax error
        chunk = b'thisshouldbeonechunk\r\n\xc3\xa4\xc3\xb6\xc3\xbc\xc3\x9f'.decode('utf-8')
        self._test_body(chunk)

    def test_empty_body(self):
        self._test_body(None)

    def test_empty_string_body(self):
        self._test_body('')

    def test_empty_iterable_body(self):
        self._test_body([])

    def test_removes_duplicate_host_header(self):
        self.start_chunked_handler()
        chunks = ['foo', 'bar', '', 'bazzzzzzzzzzzzzzzzzzzzzz']
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.urlopen(
            'GET', '/', chunks, headers={'Host': 'test.org'}, chunked=True
        )

        header_block = self.buffer.split(b'\r\n\r\n', 1)[0].lower()
        header_lines = header_block.split(b'\r\n')[1:]

        host_headers = [x for x in header_lines if x.startswith(b'host')]
        self.assertEqual(len(host_headers), 1)

    def test_provides_default_host_header(self):
        self.start_chunked_handler()
        chunks = ['foo', 'bar', '', 'bazzzzzzzzzzzzzzzzzzzzzz']
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.urlopen('GET', '/', chunks, chunked=True)

        header_block = self.buffer.split(b'\r\n\r\n', 1)[0].lower()
        header_lines = header_block.split(b'\r\n')[1:]

        host_headers = [x for x in header_lines if x.startswith(b'host')]
        self.assertEqual(len(host_headers), 1)",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED," VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR'' VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR'): VAR.VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR() VAR = ['VAR', 'VAR', '', 'VAR'] VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR('VAR', '/', VAR, VAR=VAR(VAR='1'), VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR'VAR-VAR', VAR.VAR) VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1)[1] VAR = VAR.VAR(VAR'\VAR\VAR')   VAR VAR, VAR VAR VAR([VAR VAR VAR VAR VAR VAR VAR]): VAR.VAR(VAR[VAR * 2], VAR(VAR(VAR))[2:].VAR('VAR-8')) VAR.VAR(VAR[VAR * 2 + 1], VAR.VAR('VAR-8')) VAR VAR(VAR, VAR): VAR.VAR() VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR, VAR=VAR) VAR, VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1) VAR.VAR(VAR'VAR-VAR: VAR', VAR.VAR(VAR'\VAR\VAR')) VAR VAR: VAR = VAR VAR VAR(VAR, VAR) VAR VAR.VAR('VAR-8') VAR.VAR(VAR'\VAR\VAR' + VAR + VAR'\VAR\VAR', VAR) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR')) VAR = VAR.VAR(VAR'\VAR\VAR', 1)[0] VAR = VAR(VAR, 16) VAR.VAR(VAR, VAR(VAR)) VAR: VAR.VAR(VAR, VAR'0\VAR\VAR\VAR\VAR') VAR VAR(VAR): VAR.VAR(VAR'VAR\VAR\VAR') VAR VAR(VAR):   VAR = VAR'VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR'.VAR('VAR-8') VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR('') VAR VAR(VAR): VAR.VAR([]) VAR VAR(VAR): VAR.VAR() VAR = ['VAR', 'VAR', '', 'VAR'] VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR( 'VAR', '/', VAR, VAR={'VAR': 'VAR.VAR'}, VAR=VAR ) VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1)[0].VAR() VAR = VAR.VAR(VAR'\VAR\VAR')[1:] VAR = [VAR VAR VAR VAR VAR VAR VAR.VAR(VAR'VAR')] VAR.VAR(VAR(VAR), 1) VAR VAR(VAR): VAR.VAR() VAR = ['VAR', 'VAR', '', 'VAR'] VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR, VAR=VAR) VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1)[0].VAR() VAR = VAR.VAR(VAR'\VAR\VAR')[1:] VAR = [VAR VAR VAR VAR VAR VAR VAR.VAR(VAR'VAR')] VAR.VAR(VAR(VAR), 1) ",1
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,docs/requirements.txt,"-r ../dev-requirements.txt
sphinx>3.0.0
requests>=2,<2.16
furo",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"-VAR ../VAR-VAR.VAR VAR>3.0.0 VAR>=2,<2.16 VAR ",1
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,src/urllib3/contripyopenssl.py,"""""""
TLS with SNI_-support for Python 2. Follow these instructions if you would
like to verify TLS certificates in Python 2. Note, the default libraries do
*not* do certificate checking; you need to do additional work to validate
certificates yourself.

This needs the following packages installed:

* `pyOpenSSL`_ (tested with 16.0.0)
* `cryptography`_ (minimum 1.3.4, from pyopenssl)
* `idna`_ (minimum 2.0, from cryptography)

However, pyopenssl depends on cryptography, which depends on idna, so while we
use all three directly here we end up having relatively few packages required.

You can install them with the following command:

.. code-block:: bash

    $ python -m pip install pyopenssl cryptography idna

To activate certificate checking, call
:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code
before you begin making HTTP requests. This can be done in a ``sitecustomize``
module, or at any other time before your application begins using ``urllib3``,
like this:

.. code-block:: python

    try:
        import urllib3.contrib.pyopenssl
        urllib3.contrib.pyopenssl.inject_into_urllib3()
    except ImportError:
        pass

Now you can use :mod:`urllib3` as you normally would, and it will support SNI
when the required modules are installed.

Activating this module also has the positive side effect of disabling SSL/TLS
compression in Python 2 (see `CRIME attack`_).

.. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication
.. _crime attack: https://en.wikipedia.org/wiki/CRIME_(security_exploit)
.. _pyopenssl: https://www.pyopenssl.org
.. _cryptography: https://cryptography.io
.. _idna: https://github.com/kjd/idna
""""""
from __future__ import absolute_import

import OpenSSL.SSL
from cryptography import x509
from cryptography.hazmat.backends.openssl import backend as openssl_backend
from cryptography.hazmat.backends.openssl.x509 import _Certificate

try:
    from cryptography.x509 import UnsupportedExtension
except ImportError:
    # UnsupportedExtension is gone in cryptography >= 2.1.0
    class UnsupportedExtension(Exception):
        pass


from io import BytesIO
from socket import error as SocketError
from socket import timeout

try:  # Platform-specific: Python 2
    from socket import _fileobject
except ImportError:  # Platform-specific: Python 3
    _fileobject = None
    from ..packages.backports.makefile import backport_makefile

import logging
import ssl
import sys

from .. import util
from ..packages import six
from ..util.ssl_ import PROTOCOL_TLS_CLIENT

__all__ = [""inject_into_urllib3"", ""extract_from_urllib3""]

# SNI always works.
HAS_SNI = True

# Map from urllib3 to PyOpenSSL compatible parameter-values.
_openssl_versions = {
    util.PROTOCOL_TLS: OpenSSL.SSL.SSLv23_METHOD,
    PROTOCOL_TLS_CLIENT: OpenSSL.SSL.SSLv23_METHOD,
    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,
}

if hasattr(ssl, ""PROTOCOL_SSLv3"") and hasattr(OpenSSL.SSL, ""SSLv3_METHOD""):
    _openssl_versions[ssl.PROTOCOL_SSLv3] = OpenSSL.SSL.SSLv3_METHOD

if hasattr(ssl, ""PROTOCOL_TLSv1_1"") and hasattr(OpenSSL.SSL, ""TLSv1_1_METHOD""):
    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD

if hasattr(ssl, ""PROTOCOL_TLSv1_2"") and hasattr(OpenSSL.SSL, ""TLSv1_2_METHOD""):
    _openssl_versions[ssl.PROTOCOL_TLSv1_2] = OpenSSL.SSL.TLSv1_2_METHOD


_stdlib_to_openssl_verify = {
    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,
    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,
    ssl.CERT_REQUIRED: OpenSSL.SSL.VERIFY_PEER
    + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,
}
_openssl_to_stdlib_verify = dict((v, k) for k, v in _stdlib_to_openssl_verify.items())

# OpenSSL will only write 16K at a time
SSL_WRITE_BLOCKSIZE = 16384

orig_util_HAS_SNI = util.HAS_SNI
orig_util_SSLContext = util.ssl_.SSLContext


log = logging.getLogger(__name__)


def inject_into_urllib3():
    ""Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.""

    _validate_dependencies_met()

    util.SSLContext = PyOpenSSLContext
    util.ssl_.SSLContext = PyOpenSSLContext
    util.HAS_SNI = HAS_SNI
    util.ssl_.HAS_SNI = HAS_SNI
    util.IS_PYOPENSSL = True
    util.ssl_.IS_PYOPENSSL = True


def extract_from_urllib3():
    ""Undo monkey-patching by :func:`inject_into_urllib3`.""

    util.SSLContext = orig_util_SSLContext
    util.ssl_.SSLContext = orig_util_SSLContext
    util.HAS_SNI = orig_util_HAS_SNI
    util.ssl_.HAS_SNI = orig_util_HAS_SNI
    util.IS_PYOPENSSL = False
    util.ssl_.IS_PYOPENSSL = False


def _validate_dependencies_met():
    """"""
    Verifies that PyOpenSSL's package-level dependencies have been met.
    Throws `ImportError` if they are not met.
    """"""
    # Method added in `cryptography==1.1`; not available in older versions
    from cryptography.x509.extensions import Extensions

    if getattr(Extensions, ""get_extension_for_class"", None) is None:
        raise ImportError(
            ""'cryptography' module missing required functionality.  ""
            ""Try upgrading to v1.3.4 or newer.""
        )

    # pyOpenSSL 0.14 and above use cryptography for OpenSSL bindings. The _x509
    # attribute is only present on those versions.
    from OpenSSL.crypto import X509

    x509 = X509()
    if getattr(x509, ""_x509"", None) is None:
        raise ImportError(
            ""'pyOpenSSL' module missing required functionality. ""
            ""Try upgrading to v0.14 or newer.""
        )


def _dnsname_to_stdlib(name):
    """"""
    Converts a dNSName SubjectAlternativeName field to the form used by the
    standard library on the given Python version.

    Cryptography produces a dNSName as a unicode string that was idna-decoded
    from ASCII bytes. We need to idna-encode that string to get it back, and
    then on Python 3 we also need to convert to unicode via UTF-8 (the stdlib
    uses PyUnicode_FromStringAndSize on it, which decodes via UTF-8).

    If the name cannot be idna-encoded then we return None signalling that
    the name given should be skipped.
    """"""

    def idna_encode(name):
        """"""
        Borrowed wholesale from the Python Cryptography Project. It turns out
        that we can't just safely call `idna.encode`: it can explode for
        wildcard names. This avoids that problem.
        """"""
        import idna

        try:
            for prefix in [u""*."", u"".""]:
                if name.startswith(prefix):
                    name = name[len(prefix) :]
                    return prefix.encode(""ascii"") + idna.encode(name)
            return idna.encode(name)
        except idna.core.IDNAError:
            return None

    # Don't send IPv6 addresses through the IDNA encoder.
    if "":"" in name:
        return name

    name = idna_encode(name)
    if name is None:
        return None
    elif sys.version_info >= (3, 0):
        name = name.decode(""utf-8"")
    return name


def get_subj_alt_name(peer_cert):
    """"""
    Given an PyOpenSSL certificate, provides all the subject alternative names.
    """"""
    # Pass the cert to cryptography, which has much better APIs for this.
    if hasattr(peer_cert, ""to_cryptography""):
        cert = peer_cert.to_cryptography()
    else:
        # This is technically using private APIs, but should work across all
        # relevant versions before PyOpenSSL got a proper API for this.
        cert = _Certificate(openssl_backend, peer_cert._x509)

    # We want to find the SAN extension. Ask Cryptography to locate it (it's
    # faster than looping in Python)
    try:
        ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName).value
    except x509.ExtensionNotFound:
        # No such extension, return the empty list.
        return []
    except (
        x509.DuplicateExtension,
        UnsupportedExtension,
        x509.UnsupportedGeneralNameType,
        UnicodeError,
    ) as e:
        # A problem has been found with the quality of the certificate. Assume
        # no SAN field is present.
        log.warning(
            ""A problem was encountered with the certificate that prevented ""
            ""urllib3 from finding the SubjectAlternativeName field. This can ""
            ""affect certificate validation. The error was %s"",
            e,
        )
        return []

    # We want to return dNSName and iPAddress fields. We need to cast the IPs
    # back to strings because the match_hostname function wants them as
    # strings.
    # Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8
    # decoded. This is pretty frustrating, but that's what the standard library
    # does with certificates, and so we need to attempt to do the same.
    # We also want to skip over names which cannot be idna encoded.
    names = [
        (""DNS"", name)
        for name in map(_dnsname_to_stdlib, ext.get_values_for_type(x509.DNSName))
        if name is not None
    ]
    names.extend(
        (""IP Address"", str(name)) for name in ext.get_values_for_type(x509.IPAddress)
    )

    return names


class WrappedSocket(object):
    """"""API-compatibility wrapper for Python OpenSSL's Connection-class.

    Note: _makefile_refs, _drop() and _reuse() are needed for the garbage
    collector of pypy.
    """"""

    def __init__(self, connection, socket, suppress_ragged_eofs=True):
        self.connection = connection
        self.socket = socket
        self.suppress_ragged_eofs = suppress_ragged_eofs
        self._makefile_refs = 0
        self._closed = False

    def fileno(self):
        return self.socket.fileno()

    # Copy-pasted from Python 3.5 source code
    def _decref_socketios(self):
        if self._makefile_refs > 0:
            self._makefile_refs -= 1
        if self._closed:
            self.close()

    def recv(self, *args, **kwargs):
        try:
            data = self.connection.recv(*args, **kwargs)
        except OpenSSL.SSL.SysCallError as e:
            if self.suppress_ragged_eofs and e.args == (-1, ""Unexpected EOF""):
                return b""""
            else:
                raise SocketError(str(e))
        except OpenSSL.SSL.ZeroReturnError:
            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
                return b""""
            else:
                raise
        except OpenSSL.SSL.WantReadError:
            if not util.wait_for_read(self.socket, self.socket.gettimeout()):
                raise timeout(""The read operation timed out"")
            else:
                return self.recv(*args, **kwargs)

        # TLS 1.3 post-handshake authentication
        except OpenSSL.SSL.Error as e:
            raise ssl.SSLError(""read error: %r"" % e)
        else:
            return data

    def recv_into(self, *args, **kwargs):
        try:
            return self.connection.recv_into(*args, **kwargs)
        except OpenSSL.SSL.SysCallError as e:
            if self.suppress_ragged_eofs and e.args == (-1, ""Unexpected EOF""):
                return 0
            else:
                raise SocketError(str(e))
        except OpenSSL.SSL.ZeroReturnError:
            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
                return 0
            else:
                raise
        except OpenSSL.SSL.WantReadError:
            if not util.wait_for_read(self.socket, self.socket.gettimeout()):
                raise timeout(""The read operation timed out"")
            else:
                return self.recv_into(*args, **kwargs)

        # TLS 1.3 post-handshake authentication
        except OpenSSL.SSL.Error as e:
            raise ssl.SSLError(""read error: %r"" % e)

    def settimeout(self, timeout):
        return self.socket.settimeout(timeout)

    def _send_until_done(self, data):
        while True:
            try:
                return self.connection.send(data)
            except OpenSSL.SSL.WantWriteError:
                if not util.wait_for_write(self.socket, self.socket.gettimeout()):
                    raise timeout()
                continue
            except OpenSSL.SSL.SysCallError as e:
                raise SocketError(str(e))

    def sendall(self, data):
        total_sent = 0
        while total_sent < len(data):
            sent = self._send_until_done(
                data[total_sent : total_sent + SSL_WRITE_BLOCKSIZE]
            )
            total_sent += sent

    def shutdown(self):
        # FIXME rethrow compatible exceptions should we ever use this
        self.connection.shutdown()

    def close(self):
        if self._makefile_refs < 1:
            try:
                self._closed = True
                return self.connection.close()
            except OpenSSL.SSL.Error:
                return
        else:
            self._makefile_refs -= 1

    def getpeercert(self, binary_form=False):
        x509 = self.connection.get_peer_certificate()

        if not x509:
            return x509

        if binary_form:
            return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_ASN1, x509)

        return {
            ""subject"": (((""commonName"", x509.get_subject().CN),),),
            ""subjectAltName"": get_subj_alt_name(x509),
        }

    def version(self):
        return self.connection.get_protocol_version_name()

    def _reuse(self):
        self._makefile_refs += 1

    def _drop(self):
        if self._makefile_refs < 1:
            self.close()
        else:
            self._makefile_refs -= 1


if _fileobject:  # Platform-specific: Python 2

    def makefile(self, mode, bufsize=-1):
        self._makefile_refs += 1
        return _fileobject(self, mode, bufsize, close=True)


else:  # Platform-specific: Python 3
    makefile = backport_makefile

WrappedSocket.makefile = makefile


class PyOpenSSLContext(object):
    """"""
    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible
    for translating the interface of the standard library ``SSLContext`` object
    to calls into PyOpenSSL.
    """"""

    def __init__(self, protocol):
        self.protocol = _openssl_versions[protocol]
        self._ctx = OpenSSL.SSL.Context(self.protocol)
        self._options = 0
        self.check_hostname = False

    @property
    def options(self):
        return self._options

    @options.setter
    def options(self, value):
        self._options = value
        self._ctx.set_options(value)

    @property
    def verify_mode(self):
        return _openssl_to_stdlib_verify[self._ctx.get_verify_mode()]

    @verify_mode.setter
    def verify_mode(self, value):
        self._ctx.set_verify(_stdlib_to_openssl_verify[value], _verify_callback)

    def set_default_verify_paths(self):
        self._ctx.set_default_verify_paths()

    def set_ciphers(self, ciphers):
        if isinstance(ciphers, six.text_type):
            ciphers = ciphers.encode(""utf-8"")
        self._ctx.set_cipher_list(ciphers)

    def load_verify_locations(self, cafile=None, capath=None, cadata=None):
        if cafile is not None:
            cafile = cafile.encode(""utf-8"")
        if capath is not None:
            capath = capath.encode(""utf-8"")
        try:
            self._ctx.load_verify_locations(cafile, capath)
            if cadata is not None:
                self._ctx.load_verify_locations(BytesIO(cadata))
        except OpenSSL.SSL.Error as e:
            raise ssl.SSLError(""unable to load trusted certificates: %r"" % e)

    def load_cert_chain(self, certfile, keyfile=None, password=None):
        self._ctx.use_certificate_chain_file(certfile)
        if password is not None:
            if not isinstance(password, six.binary_type):
                password = password.encode(""utf-8"")
            self._ctx.set_passwd_cb(lambda *_: password)
        self._ctx.use_privatekey_file(keyfile or certfile)

    def set_alpn_protocols(self, protocols):
        protocols = [six.ensure_binary(p) for p in protocols]
        return self._ctx.set_alpn_protos(protocols)

    def wrap_socket(
        self,
        sock,
        server_side=False,
        do_handshake_on_connect=True,
        suppress_ragged_eofs=True,
        server_hostname=None,
    ):
        cnx = OpenSSL.SSL.Connection(self._ctx, sock)

        if isinstance(server_hostname, six.text_type):  # Platform-specific: Python 3
            server_hostname = server_hostname.encode(""utf-8"")

        if server_hostname is not None:
            cnx.set_tlsext_host_name(server_hostname)

        cnx.set_connect_state()

        while True:
            try:
                cnx.do_handshake()
            except OpenSSL.SSL.WantReadError:
                if not util.wait_for_read(sock, sock.gettimeout()):
                    raise timeout(""select timed out"")
                continue
            except OpenSSL.SSL.Error as e:
                raise ssl.SSLError(""bad handshake: %r"" % e)
            break

        return WrappedSocket(cnx, sock)


def _verify_callback(cnx, x509, err_no, err_depth, return_code):
    return err_no == 0",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,""""""" VAR VAR VAR-VAR VAR VAR 2. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 2. VAR, VAR VAR VAR VAR *VAR* VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR: * `VAR`VAR (VAR VAR 16.0.0) * `VAR`VAR (VAR 1.3.4, VAR VAR) * `VAR`VAR (VAR 2.0, VAR VAR) VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR: .. VAR-VAR:: VAR $ VAR -VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR ``VAR`` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR``, VAR VAR: .. VAR-VAR:: VAR VAR: VAR VAR.VAR.VAR VAR.VAR.VAR.VAR() VAR VAR: VAR VAR VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR VAR 2 (VAR `VAR VAR`VAR). .. VAR: VAR: .. VAR VAR: VAR: .. VAR: VAR: .. VAR: VAR: .. VAR: VAR: """""" VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR: VAR VAR.VAR VAR VAR VAR VAR:  VAR VAR(VAR): VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR:  VAR VAR VAR VAR VAR VAR:  VAR = VAR VAR ..VAR.VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .. VAR VAR VAR ..VAR VAR VAR VAR ..VAR.VAR VAR VAR VAR = [""VAR"", ""VAR""]  VAR = VAR  VAR = { VAR.VAR: VAR.VAR.VAR, VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR, } VAR VAR(VAR, ""VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR[VAR.VAR] = VAR.VAR.VAR VAR VAR(VAR, ""VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR[VAR.VAR] = VAR.VAR.VAR VAR VAR(VAR, ""VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR[VAR.VAR] = VAR.VAR.VAR VAR = { VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR + VAR.VAR.VAR, } VAR = VAR((VAR, VAR) VAR VAR, VAR VAR VAR.VAR())  VAR = 16384 VAR = VAR.VAR VAR = VAR.VAR.VAR VAR = VAR.VAR(VAR) VAR VAR(): ""VAR-VAR VAR VAR VAR-VAR VAR-VAR."" VAR() VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR VAR(): ""VAR VAR-VAR VAR :VAR:`VAR`."" VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR VAR(): """""" VAR VAR VAR'VAR VAR-VAR VAR VAR VAR VAR. VAR `VAR` VAR VAR VAR VAR VAR. """"""  VAR VAR.VAR.VAR VAR VAR VAR VAR(VAR, ""VAR"", VAR) VAR VAR: VAR VAR( ""'VAR' VAR VAR VAR VAR. "" ""VAR VAR VAR VAR.3.4 VAR VAR."" )   VAR VAR.VAR VAR VAR VAR = VAR() VAR VAR(VAR, ""VAR"", VAR) VAR VAR: VAR VAR( ""'VAR' VAR VAR VAR VAR. "" ""VAR VAR VAR VAR.14 VAR VAR."" ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR. VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR 3 VAR VAR VAR VAR VAR VAR VAR VAR VAR-8 (VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR-8). VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR `VAR.VAR`: VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR. """""" VAR VAR VAR: VAR VAR VAR [VAR""*."", VAR"".""]: VAR VAR.VAR(VAR): VAR = VAR[VAR(VAR) :] VAR VAR.VAR(""VAR"") + VAR.VAR(VAR) VAR VAR.VAR(VAR) VAR VAR.VAR.VAR: VAR VAR  VAR "":"" VAR VAR: VAR VAR VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR VAR VAR.VAR >= (3, 0): VAR = VAR.VAR(""VAR-8"") VAR VAR VAR VAR(VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. """"""  VAR VAR(VAR, ""VAR""): VAR = VAR.VAR() VAR:   VAR = VAR(VAR, VAR.VAR)   VAR: VAR = VAR.VAR.VAR(VAR.VAR).VAR VAR VAR.VAR:  VAR [] VAR ( VAR.VAR, VAR, VAR.VAR, VAR, ) VAR VAR:   VAR.VAR( ""VAR VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR VAR. VAR VAR "" ""VAR VAR VAR. VAR VAR VAR %VAR"", VAR, ) VAR []        VAR = [ (""VAR"", VAR) VAR VAR VAR VAR(VAR, VAR.VAR(VAR.VAR)) VAR VAR VAR VAR VAR ] VAR.VAR( (""VAR VAR"", VAR(VAR)) VAR VAR VAR VAR.VAR(VAR.VAR) ) VAR VAR VAR VAR(VAR): """"""VAR-VAR VAR VAR VAR VAR'VAR VAR-VAR. VAR: VAR, VAR() VAR VAR() VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR, VAR, VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR VAR(VAR): VAR VAR.VAR.VAR()  VAR VAR(VAR): VAR VAR.VAR > 0: VAR.VAR -= 1 VAR VAR.VAR: VAR.VAR() VAR VAR(VAR, *VAR, **VAR): VAR: VAR = VAR.VAR.VAR(*VAR, **VAR) VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR == (-1, ""VAR VAR""): VAR VAR"""" VAR: VAR VAR(VAR(VAR)) VAR VAR.VAR.VAR: VAR VAR.VAR.VAR() == VAR.VAR.VAR: VAR VAR"""" VAR: VAR VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR(""VAR VAR VAR VAR VAR"") VAR: VAR VAR.VAR(*VAR, **VAR)  VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR(""VAR VAR: %VAR"" % VAR) VAR: VAR VAR VAR VAR(VAR, *VAR, **VAR): VAR: VAR VAR.VAR.VAR(*VAR, **VAR) VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR == (-1, ""VAR VAR""): VAR 0 VAR: VAR VAR(VAR(VAR)) VAR VAR.VAR.VAR: VAR VAR.VAR.VAR() == VAR.VAR.VAR: VAR 0 VAR: VAR VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR(""VAR VAR VAR VAR VAR"") VAR: VAR VAR.VAR(*VAR, **VAR)  VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR(""VAR VAR: %VAR"" % VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR(VAR) VAR VAR(VAR, VAR): VAR VAR: VAR: VAR VAR.VAR.VAR(VAR) VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR() VAR VAR VAR.VAR.VAR VAR VAR: VAR VAR(VAR(VAR)) VAR VAR(VAR, VAR): VAR = 0 VAR VAR < VAR(VAR): VAR = VAR.VAR( VAR[VAR : VAR + VAR] ) VAR += VAR VAR VAR(VAR):  VAR.VAR.VAR() VAR VAR(VAR): VAR VAR.VAR < 1: VAR: VAR.VAR = VAR VAR VAR.VAR.VAR() VAR VAR.VAR.VAR: VAR VAR: VAR.VAR -= 1 VAR VAR(VAR, VAR=VAR): VAR = VAR.VAR.VAR() VAR VAR VAR: VAR VAR VAR VAR: VAR VAR.VAR.VAR(VAR.VAR.VAR, VAR) VAR { ""VAR"": (((""VAR"", VAR.VAR().VAR),),), ""VAR"": VAR(VAR), } VAR VAR(VAR): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR.VAR += 1 VAR VAR(VAR): VAR VAR.VAR < 1: VAR.VAR() VAR: VAR.VAR -= 1 VAR VAR:  VAR VAR(VAR, VAR, VAR=-1): VAR.VAR += 1 VAR VAR(VAR, VAR, VAR, VAR=VAR) VAR:  VAR = VAR VAR.VAR = VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = VAR[VAR] VAR.VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR = 0 VAR.VAR = VAR @VAR VAR VAR(VAR): VAR VAR.VAR @VAR.VAR VAR VAR(VAR, VAR): VAR.VAR = VAR VAR.VAR.VAR(VAR) @VAR VAR VAR(VAR): VAR VAR[VAR.VAR.VAR()] @VAR.VAR VAR VAR(VAR, VAR): VAR.VAR.VAR(VAR[VAR], VAR) VAR VAR(VAR): VAR.VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR, VAR.VAR): VAR = VAR.VAR(""VAR-8"") VAR.VAR.VAR(VAR) VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR VAR VAR VAR VAR: VAR = VAR.VAR(""VAR-8"") VAR VAR VAR VAR VAR: VAR = VAR.VAR(""VAR-8"") VAR: VAR.VAR.VAR(VAR, VAR) VAR VAR VAR VAR VAR: VAR.VAR.VAR(VAR(VAR)) VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR VAR: %VAR"" % VAR) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): VAR.VAR.VAR(VAR) VAR VAR VAR VAR VAR: VAR VAR VAR(VAR, VAR.VAR): VAR = VAR.VAR(""VAR-8"") VAR.VAR.VAR(VAR *VAR: VAR) VAR.VAR.VAR(VAR VAR VAR) VAR VAR(VAR, VAR): VAR = [VAR.VAR(VAR) VAR VAR VAR VAR] VAR VAR.VAR.VAR(VAR) VAR VAR( VAR, VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, ): VAR = VAR.VAR.VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR.VAR):  VAR = VAR.VAR(""VAR-8"") VAR VAR VAR VAR VAR: VAR.VAR(VAR) VAR.VAR() VAR VAR: VAR: VAR.VAR() VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR, VAR.VAR()): VAR VAR(""VAR VAR VAR"") VAR VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR(""VAR VAR: %VAR"" % VAR) VAR VAR VAR(VAR, VAR) VAR VAR(VAR, VAR, VAR, VAR, VAR): VAR VAR == 0 ",1
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,src/urllib3/filepost.py,"from __future__ import absolute_import

import binascii
import codecs
import os
from io import BytesIO

from .fields import RequestField
from .packages import six
from .packages.six import b

writer = codecs.lookup(""utf-8"")[3]


def choose_boundary():
    """"""
    Our embarrassingly-simple replacement for mimetools.choose_boundary.
    """"""
    boundary = binascii.hexlify(os.urandom(16))
    if not six.PY2:
        boundary = boundary.decode(""ascii"")
    return boundary


def iter_field_objects(fields):
    """"""
    Iterate over fields.

    Supports list of (k, v) tuples and dicts, and lists of
    :class:`~urllib3.fields.RequestField`.

    """"""
    if isinstance(fields, dict):
        i = six.iteritems(fields)
    else:
        i = iter(fields)

    for field in i:
        if isinstance(field, RequestField):
            yield field
        else:
            yield RequestField.from_tuples(*field)


def iter_fields(fields):
    """"""
    .. deprecated:: 1.6

    Iterate over fields.

    The addition of :class:`~urllib3.fields.RequestField` makes this function
    obsolete. Instead, use :func:`iter_field_objects`, which returns
    :class:`~urllib3.fields.RequestField` objects.

    Supports list of (k, v) tuples and dicts.
    """"""
    if isinstance(fields, dict):
        return ((k, v) for k, v in six.iteritems(fields))

    return ((k, v) for k, v in fields)


def encode_multipart_formdata(fields, boundary=None):
    """"""
    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.

    :param fields:
        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).

    :param boundary:
        If not specified, then a random boundary will be generated using
        :func:`urllib3.filepost.choose_boundary`.
    """"""
    body = BytesIO()
    if boundary is None:
        boundary = choose_boundary()

    for field in iter_field_objects(fields):
        body.write(b(""--%s\r\n"" % (boundary)))

        writer(body).write(field.render_headers())
        data = field.data

        if isinstance(data, int):
            data = str(data)  # Backwards compatibility

        if isinstance(data, six.text_type):
            writer(body).write(data)
        else:
            body.write(data)

        body.write(b""\r\n"")

    body.write(b(""--%s--\r\n"" % (boundary)))

    content_type = str(""multipart/form-data; boundary=%s"" % boundary)

    return body.getvalue(), content_type",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR VAR VAR VAR .VAR.VAR VAR VAR VAR = VAR.VAR(""VAR-8"")[3] VAR VAR(): """""" VAR VAR-VAR VAR VAR VAR.VAR. """""" VAR = VAR.VAR(VAR.VAR(16)) VAR VAR VAR.VAR: VAR = VAR.VAR(""VAR"") VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR, VAR VAR VAR :VAR:`~VAR.VAR.VAR`. """""" VAR VAR(VAR, VAR): VAR = VAR.VAR(VAR) VAR: VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR.VAR(*VAR) VAR VAR(VAR): """""" .. VAR:: 1.6 VAR VAR VAR. VAR VAR VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR VAR. VAR, VAR :VAR:`VAR`, VAR VAR :VAR:`~VAR.VAR.VAR` VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR ((VAR, VAR) VAR VAR, VAR VAR VAR.VAR(VAR)) VAR ((VAR, VAR) VAR VAR, VAR VAR VAR) VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR ``VAR`` VAR VAR VAR/VAR-VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR (VAR, :VAR:`~VAR.VAR.VAR`). :VAR VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR`. """""" VAR = VAR() VAR VAR VAR VAR: VAR = VAR() VAR VAR VAR VAR(VAR): VAR.VAR(VAR(""--%VAR\VAR\VAR"" % (VAR))) VAR(VAR).VAR(VAR.VAR()) VAR = VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR)  VAR VAR(VAR, VAR.VAR): VAR(VAR).VAR(VAR) VAR: VAR.VAR(VAR) VAR.VAR(VAR""\VAR\VAR"") VAR.VAR(VAR(""--%VAR--\VAR\VAR"" % (VAR))) VAR = VAR(""VAR/VAR-VAR; VAR=%VAR"" % VAR) VAR VAR.VAR(), VAR ",1
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,src/urllib3/response.py,"from __future__ import absolute_import

import io
import logging
import zlib
from contextlib import contextmanager
from socket import error as SocketError
from socket import timeout as SocketTimeout

try:
    import brotli
except ImportError:
    brotli = None

from ._collections import HTTPHeaderDict
from .connection import BaseSSLError, HTTPException
from .exceptions import (
    BodyNotHttplibCompatible,
    DecodeError,
    HTTPError,
    IncompleteRead,
    InvalidChunkLength,
    InvalidHeader,
    ProtocolError,
    ReadTimeoutError,
    ResponseNotChunked,
    SSLError,
)
from .packages import six
from .util.response import is_fp_closed, is_response_to_head

log = logging.getLogger(__name__)


class DeflateDecoder(object):
    def __init__(self):
        self._first_try = True
        self._data = b""""
        self._obj = zlib.decompressobj()

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        if not data:
            return data

        if not self._first_try:
            return self._obj.decompress(data)

        self._data += data
        try:
            decompressed = self._obj.decompress(data)
            if decompressed:
                self._first_try = False
                self._data = None
            return decompressed
        except zlib.error:
            self._first_try = False
            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
            try:
                return self.decompress(self._data)
            finally:
                self._data = None


class GzipDecoderState(object):

    FIRST_MEMBER = 0
    OTHER_MEMBERS = 1
    SWALLOW_DATA = 2


class GzipDecoder(object):
    def __init__(self):
        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
        self._state = GzipDecoderState.FIRST_MEMBER

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        ret = bytearray()
        if self._state == GzipDecoderState.SWALLOW_DATA or not data:
            return bytes(ret)
        while True:
            try:
                ret += self._obj.decompress(data)
            except zlib.error:
                previous_state = self._state
                # Ignore data after the first error
                self._state = GzipDecoderState.SWALLOW_DATA
                if previous_state == GzipDecoderState.OTHER_MEMBERS:
                    # Allow trailing garbage acceptable in other gzip clients
                    return bytes(ret)
                raise
            data = self._obj.unused_data
            if not data:
                return bytes(ret)
            self._state = GzipDecoderState.OTHER_MEMBERS
            self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)


if brotli is not None:

    class BrotliDecoder(object):
        # Supports both 'brotlipy' and 'Brotli' packages
        # since they share an import name. The top branches
        # are for 'brotlipy' and bottom branches for 'Brotli'
        def __init__(self):
            self._obj = brotli.Decompressor()
            if hasattr(self._obj, ""decompress""):
                self.decompress = self._obj.decompress
            else:
                self.decompress = self._obj.process

        def flush(self):
            if hasattr(self._obj, ""flush""):
                return self._obj.flush()
            return b""""


class MultiDecoder(object):
    """"""
    From RFC7231:
        If one or more encodings have been applied to a representation, the
        sender that applied the encodings MUST generate a Content-Encoding
        header field that lists the content codings in the order in which
        they were applied.
    """"""

    def __init__(self, modes):
        self._decoders = [_get_decoder(m.strip()) for m in modes.split("","")]

    def flush(self):
        return self._decoders[0].flush()

    def decompress(self, data):
        for d in reversed(self._decoders):
            data = d.decompress(data)
        return data


def _get_decoder(mode):
    if "","" in mode:
        return MultiDecoder(mode)

    if mode == ""gzip"":
        return GzipDecoder()

    if brotli is not None and mode == ""br"":
        return BrotliDecoder()

    return DeflateDecoder()


class HTTPResponse(io.IOBase):
    """"""
    HTTP Response container.

    Backwards-compatible with :class:`http.client.HTTPResponse` but the response ``body`` is
    loaded and decoded on-demand when the ``data`` property is accessed.  This
    class is also compatible with the Python standard library's :mod:`io`
    module, and can hence be treated as a readable object in the context of that
    framework.

    Extra parameters for behaviour not present in :class:`http.client.HTTPResponse`:

    :param preload_content:
        If True, the response's body will be preloaded during construction.

    :param decode_content:
        If True, will attempt to decode the body based on the
        'content-encoding' header.

    :param original_response:
        When this HTTPResponse wrapper is generated from an :class:`http.client.HTTPResponse`
        object, it's convenient to include the original for debug purposes. It's
        otherwise unused.

    :param retries:
        The retries contains the last :class:`~urllib3.util.retry.Retry` that
        was used during the request.

    :param enforce_content_length:
        Enforce content length checking. Body returned by server must match
        value of Content-Length header, if present. Otherwise, raise error.
    """"""

    CONTENT_DECODERS = [""gzip"", ""deflate""]
    if brotli is not None:
        CONTENT_DECODERS += [""br""]
    REDIRECT_STATUSES = [301, 302, 303, 307, 308]

    def __init__(
        self,
        body="""",
        headers=None,
        status=0,
        version=0,
        reason=None,
        strict=0,
        preload_content=True,
        decode_content=True,
        original_response=None,
        pool=None,
        connection=None,
        msg=None,
        retries=None,
        enforce_content_length=False,
        request_method=None,
        request_url=None,
        auto_close=True,
    ):

        if isinstance(headers, HTTPHeaderDict):
            self.headers = headers
        else:
            self.headers = HTTPHeaderDict(headers)
        self.status = status
        self.version = version
        self.reason = reason
        self.strict = strict
        self.decode_content = decode_content
        self.retries = retries
        self.enforce_content_length = enforce_content_length
        self.auto_close = auto_close

        self._decoder = None
        self._body = None
        self._fp = None
        self._original_response = original_response
        self._fp_bytes_read = 0
        self.msg = msg
        self._request_url = request_url

        if body and isinstance(body, (six.string_types, bytes)):
            self._body = body

        self._pool = pool
        self._connection = connection

        if hasattr(body, ""read""):
            self._fp = body

        # Are we using the chunked-style of transfer encoding?
        self.chunked = False
        self.chunk_left = None
        tr_enc = self.headers.get(""transfer-encoding"", """").lower()
        # Don't incur the penalty of creating a list and then discarding it
        encodings = (enc.strip() for enc in tr_enc.split("",""))
        if ""chunked"" in encodings:
            self.chunked = True

        # Determine length of response
        self.length_remaining = self._init_length(request_method)

        # If requested, preload the body.
        if preload_content and not self._body:
            self._body = self.read(decode_content=decode_content)

    def get_redirect_location(self):
        """"""
        Should we redirect and where to?

        :returns: Truthy redirect location string if we got a redirect status
            code and valid location. ``None`` if redirect status and no
            location. ``False`` if not a redirect status code.
        """"""
        if self.status in self.REDIRECT_STATUSES:
            return self.headers.get(""location"")

        return False

    def release_conn(self):
        if not self._pool or not self._connection:
            return

        self._pool._put_conn(self._connection)
        self._connection = None

    def drain_conn(self):
        """"""
        Read and discard any remaining HTTP response data in the response connection.

        Unread data in the HTTPResponse connection blocks the connection from being released back to the pool.
        """"""
        try:
            self.read()
        except (HTTPError, SocketError, BaseSSLError, HTTPException):
            pass

    @property
    def data(self):
        # For backwards-compat with earlier urllib3 0.4 and earlier.
        if self._body:
            return self._body

        if self._fp:
            return self.read(cache_content=True)

    @property
    def connection(self):
        return self._connection

    def isclosed(self):
        return is_fp_closed(self._fp)

    def tell(self):
        """"""
        Obtain the number of bytes pulled over the wire so far. May differ from
        the amount of content returned by :meth:``urllib3.response.HTTPResponse.read``
        if bytes are encoded on the wire (e.g, compressed).
        """"""
        return self._fp_bytes_read

    def _init_length(self, request_method):
        """"""
        Set initial length value for Response content if available.
        """"""
        length = self.headers.get(""content-length"")

        if length is not None:
            if self.chunked:
                # This Response will fail with an IncompleteRead if it can't be
                # received as chunked. This method falls back to attempt reading
                # the response before raising an exception.
                log.warning(
                    ""Received response with both Content-Length and ""
                    ""Transfer-Encoding set. This is expressly forbidden ""
                    ""by RFC 7230 sec 3.3.2. Ignoring Content-Length and ""
                    ""attempting to process response as Transfer-Encoding: ""
                    ""chunked.""
                )
                return None

            try:
                # RFC 7230 section 3.3.2 specifies multiple content lengths can
                # be sent in a single Content-Length header
                # (e.g. Content-Length: 42, 42). This line ensures the values
                # are all valid ints and that as long as the `set` length is 1,
                # all values are the same. Otherwise, the header is invalid.
                lengths = set([int(val) for val in length.split("","")])
                if len(lengths) > 1:
                    raise InvalidHeader(
                        ""Content-Length contained multiple ""
                        ""unmatching values (%s)"" % length
                    )
                length = lengths.pop()
            except ValueError:
                length = None
            else:
                if length < 0:
                    length = None

        # Convert status to int for comparison
        # In some cases, httplib returns a status of ""_UNKNOWN""
        try:
            status = int(self.status)
        except ValueError:
            status = 0

        # Check for responses that shouldn't include a body
        if status in (204, 304) or 100 <= status < 200 or request_method == ""HEAD"":
            length = 0

        return length

    def _init_decoder(self):
        """"""
        Set-up the _decoder attribute if necessary.
        """"""
        # Note: content-encoding value should be case-insensitive, per RFC 7230
        # Section 3.2
        content_encoding = self.headers.get(""content-encoding"", """").lower()
        if self._decoder is None:
            if content_encoding in self.CONTENT_DECODERS:
                self._decoder = _get_decoder(content_encoding)
            elif "","" in content_encoding:
                encodings = [
                    e.strip()
                    for e in content_encoding.split("","")
                    if e.strip() in self.CONTENT_DECODERS
                ]
                if len(encodings):
                    self._decoder = _get_decoder(content_encoding)

    DECODER_ERROR_CLASSES = (IOError, zlib.error)
    if brotli is not None:
        DECODER_ERROR_CLASSES += (brotli.error,)

    def _decode(self, data, decode_content, flush_decoder):
        """"""
        Decode the data passed in and potentially flush the decoder.
        """"""
        if not decode_content:
            return data

        try:
            if self._decoder:
                data = self._decoder.decompress(data)
        except self.DECODER_ERROR_CLASSES as e:
            content_encoding = self.headers.get(""content-encoding"", """").lower()
            raise DecodeError(
                ""Received response with content-encoding: %s, but ""
                ""failed to decode it."" % content_encoding,
                e,
            )
        if flush_decoder:
            data += self._flush_decoder()

        return data

    def _flush_decoder(self):
        """"""
        Flushes the decoder. Should only be called if the decoder is actually
        being used.
        """"""
        if self._decoder:
            buf = self._decoder.decompress(b"""")
            return buf + self._decoder.flush()

        return b""""

    @contextmanager
    def _error_catcher(self):
        """"""
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.

        On exit, release the connection back to the pool.
        """"""
        clean_exit = False

        try:
            try:
                yield

            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, ""Read timed out."")

            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if ""read operation timed out"" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)

                raise ReadTimeoutError(self._pool, None, ""Read timed out."")

            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
                raise ProtocolError(""Connection broken: %r"" % e, e)

            # If no exception is thrown, we should avoid cleaning up
            # unnecessarily.
            clean_exit = True
        finally:
            # If we didn't terminate cleanly, we need to throw away our
            # connection.
            if not clean_exit:
                # The response may not be closed but we're not going to use it
                # anymore so close it now to ensure that the connection is
                # released back to the pool.
                if self._original_response:
                    self._original_response.close()

                # Closing the response may not actually be sufficient to close
                # everything, so if we have a hold of the connection close that
                # too.
                if self._connection:
                    self._connection.close()

            # If we hold the original response but it's closed now, we should
            # return the connection back to the pool.
            if self._original_response and self._original_response.isclosed():
                self.release_conn()

    def read(self, amt=None, decode_content=None, cache_content=False):
        """"""
        Similar to :meth:`http.client.HTTPResponse.read`, but with two additional
        parameters: ``decode_content`` and ``cache_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.

        :param cache_content:
            If True, will save the returned data such that the same result is
            returned despite of the state of the underlying file object. This
            is useful if you want the ``.data`` property to continue working
            after having ``.read()`` the file object. (Overridden if ``amt`` is
            set.)
        """"""
        self._init_decoder()
        if decode_content is None:
            decode_content = self.decode_content

        if self._fp is None:
            return

        flush_decoder = False
        fp_closed = getattr(self._fp, ""closed"", False)

        with self._error_catcher():
            if amt is None:
                # cStringIO doesn't like amt=None
                data = self._fp.read() if not fp_closed else b""""
                flush_decoder = True
            else:
                cache_content = False
                data = self._fp.read(amt) if not fp_closed else b""""
                if (
                    amt != 0 and not data
                ):  # Platform-specific: Buggy versions of Python.
                    # Close the connection when no data is returned
                    #
                    # This is redundant to what httplib/http.client _should_
                    # already do.  However, versions of python released before
                    # December 15, 2012 (http://bugs.python.org/issue16298) do
                    # not properly close the connection in all cases. There is
                    # no harm in redundantly calling close.
                    self._fp.close()
                    flush_decoder = True
                    if self.enforce_content_length and self.length_remaining not in (
                        0,
                        None,
                    ):
                        # This is an edge case that httplib failed to cover due
                        # to concerns of backward compatibility. We're
                        # addressing it here to make sure IncompleteRead is
                        # raised during streaming, so all calls with incorrect
                        # Content-Length are caught.
                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)

        if data:
            self._fp_bytes_read += len(data)
            if self.length_remaining is not None:
                self.length_remaining -= len(data)

            data = self._decode(data, decode_content, flush_decoder)

            if cache_content:
                self._body = data

        return data

    def stream(self, amt=2 ** 16, decode_content=None):
        """"""
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.

        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        if self.chunked and self.supports_chunked_reads():
            for line in self.read_chunked(amt, decode_content=decode_content):
                yield line
        else:
            while not is_fp_closed(self._fp):
                data = self.read(amt=amt, decode_content=decode_content)

                if data:
                    yield data

    @classmethod
    def from_httplib(ResponseCls, r, **response_kw):
        """"""
        Given an :class:`http.client.HTTPResponse` instance ``r``, return a
        corresponding :class:`urllib3.response.HTTPResponse` object.

        Remaining parameters are passed to the HTTPResponse constructor, along
        with ``original_response=r``.
        """"""
        headers = r.msg

        if not isinstance(headers, HTTPHeaderDict):
            if six.PY2:
                # Python 2.7
                headers = HTTPHeaderDict.from_httplib(headers)
            else:
                headers = HTTPHeaderDict(headers.items())

        # HTTPResponse objects in Python 3 don't have a .strict attribute
        strict = getattr(r, ""strict"", 0)
        resp = ResponseCls(
            body=r,
            headers=headers,
            status=r.status,
            version=r.version,
            reason=r.reason,
            strict=strict,
            original_response=r,
            **response_kw
        )
        return resp

    # Backwards-compatibility methods for http.client.HTTPResponse
    def getheaders(self):
        return self.headers

    def getheader(self, name, default=None):
        return self.headers.get(name, default)

    # Backwards compatibility for http.cookiejar
    def info(self):
        return self.headers

    # Overrides from io.IOBase
    def close(self):
        if not self.closed:
            self._fp.close()

        if self._connection:
            self._connection.close()

        if not self.auto_close:
            io.IOBase.close(self)

    @property
    def closed(self):
        if not self.auto_close:
            return io.IOBase.closed.__get__(self)
        elif self._fp is None:
            return True
        elif hasattr(self._fp, ""isclosed""):
            return self._fp.isclosed()
        elif hasattr(self._fp, ""closed""):
            return self._fp.closed
        else:
            return True

    def fileno(self):
        if self._fp is None:
            raise IOError(""HTTPResponse has no file to get a fileno from"")
        elif hasattr(self._fp, ""fileno""):
            return self._fp.fileno()
        else:
            raise IOError(
                ""The file-like object this HTTPResponse is wrapped ""
                ""around has no file descriptor""
            )

    def flush(self):
        if (
            self._fp is not None
            and hasattr(self._fp, ""flush"")
            and not getattr(self._fp, ""closed"", False)
        ):
            return self._fp.flush()

    def readable(self):
        # This method is required for `io` module compatibility.
        return True

    def readinto(self, b):
        # This method is required for `io` module compatibility.
        temp = self.read(len(b))
        if len(temp) == 0:
            return 0
        else:
            b[: len(temp)] = temp
            return len(temp)

    def supports_chunked_reads(self):
        """"""
        Checks if the underlying file-like object looks like a
        :class:`http.client.HTTPResponse` object. We do this by testing for
        the fp attribute. If it is present we assume it returns raw chunks as
        processed by read_chunked().
        """"""
        return hasattr(self._fp, ""fp"")

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b"";"", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
            raise InvalidChunkLength(self, line)

    def _handle_chunk(self, amt):
        returned_chunk = None
        if amt is None:
            chunk = self._fp._safe_read(self.chunk_left)
            returned_chunk = chunk
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        elif amt < self.chunk_left:
            value = self._fp._safe_read(amt)
            self.chunk_left = self.chunk_left - amt
            returned_chunk = value
        elif amt == self.chunk_left:
            value = self._fp._safe_read(amt)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
            returned_chunk = value
        else:  # amt > self.chunk_left
            returned_chunk = self._fp._safe_read(self.chunk_left)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        return returned_chunk

    def read_chunked(self, amt=None, decode_content=None):
        """"""
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                ""Response is not chunked. ""
                ""Header 'transfer-encoding: chunked' is missing.""
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                ""Body should be http.client.HTTPResponse like. ""
                ""It should have have an fp attribute which returns raw chunks.""
            )

        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return

            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return

            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded

            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded

            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b""\r\n"":
                    break

            # We read everything; close the ""file"".
            if self._original_response:
                self._original_response.close()

    def geturl(self):
        """"""
        Returns the URL that was the source of this response.
        If the request that generated this response redirected, this method
        will return the final redirect location.
        """"""
        if self.retries is not None and len(self.retries.history):
            return self.retries.history[-1].redirect_location
        else:
            return self._request_url

    def __iter__(self):
        buffer = []
        for chunk in self.stream(decode_content=True):
            if b""\n"" in chunk:
                chunk = chunk.split(b""\n"")
                yield b"""".join(buffer) + chunk[0] + b""\n""
                for x in chunk[1:-1]:
                    yield x + b""\n""
                if chunk[-1]:
                    buffer = [chunk[-1]]
                else:
                    buffer = []
            else:
                buffer.append(chunk)
        if buffer:
            yield b"""".join(buffer)",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR: VAR = VAR VAR .VAR VAR VAR VAR .VAR VAR VAR, VAR VAR .VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR .VAR VAR VAR VAR .VAR.VAR VAR VAR, VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR VAR.VAR = VAR"""" VAR.VAR = VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR) VAR.VAR += VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR: VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR VAR.VAR = VAR.VAR(-VAR.VAR) VAR: VAR VAR.VAR(VAR.VAR) VAR: VAR.VAR = VAR VAR VAR(VAR): VAR = 0 VAR = 1 VAR = 2 VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR.VAR = VAR.VAR VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR = VAR() VAR VAR.VAR == VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR VAR: VAR: VAR += VAR.VAR.VAR(VAR) VAR VAR.VAR: VAR = VAR.VAR  VAR.VAR = VAR.VAR VAR VAR == VAR.VAR:  VAR VAR(VAR) VAR VAR = VAR.VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR.VAR = VAR.VAR VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR VAR VAR VAR VAR: VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR.VAR() VAR VAR(VAR.VAR, ""VAR""): VAR.VAR = VAR.VAR.VAR VAR: VAR.VAR = VAR.VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR VAR"""" VAR VAR(VAR): """""" VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = [VAR(VAR.VAR()) VAR VAR VAR VAR.VAR("","")] VAR VAR(VAR): VAR VAR.VAR[0].VAR() VAR VAR(VAR, VAR): VAR VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR "","" VAR VAR: VAR VAR(VAR) VAR VAR == ""VAR"": VAR VAR() VAR VAR VAR VAR VAR VAR VAR == ""VAR"": VAR VAR() VAR VAR() VAR VAR(VAR.VAR): """""" VAR VAR VAR. VAR-VAR VAR :VAR:`VAR.VAR.VAR` VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR-VAR VAR VAR ``VAR`` VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR :VAR:`VAR` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR`: :VAR VAR: VAR VAR, VAR VAR'VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR'VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR, VAR VAR. VAR, VAR VAR. """""" VAR = [""VAR"", ""VAR""] VAR VAR VAR VAR VAR: VAR += [""VAR""] VAR = [301, 302, 303, 307, 308] VAR VAR( VAR, VAR="""", VAR=VAR, VAR=0, VAR=0, VAR=VAR, VAR=0, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, ): VAR VAR(VAR, VAR): VAR.VAR = VAR VAR: VAR.VAR = VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR(VAR, (VAR.VAR, VAR)): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, ""VAR""): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR VAR = VAR.VAR.VAR(""VAR-VAR"", """").VAR()  VAR = (VAR.VAR() VAR VAR VAR VAR.VAR("","")) VAR ""VAR"" VAR VAR: VAR.VAR = VAR  VAR.VAR = VAR.VAR(VAR)  VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR.VAR(VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR? :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR.VAR(""VAR"") VAR VAR VAR VAR(VAR): VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR.VAR) VAR.VAR = VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR: VAR.VAR() VAR (VAR, VAR, VAR, VAR): VAR @VAR VAR VAR(VAR):  VAR VAR.VAR: VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR(VAR=VAR) @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:``VAR.VAR.VAR.VAR`` VAR VAR VAR VAR VAR VAR VAR (VAR.VAR, VAR). """""" VAR VAR.VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR(""VAR-VAR"") VAR VAR VAR VAR VAR: VAR VAR.VAR:    VAR.VAR( ""VAR VAR VAR VAR VAR-VAR VAR "" ""VAR-VAR VAR. VAR VAR VAR VAR "" ""VAR VAR 7230 VAR 3.3.2. VAR VAR-VAR VAR "" ""VAR VAR VAR VAR VAR VAR-VAR: "" ""VAR."" ) VAR VAR VAR:      VAR = VAR([VAR(VAR) VAR VAR VAR VAR.VAR("","")]) VAR VAR(VAR) > 1: VAR VAR( ""VAR-VAR VAR VAR "" ""VAR VAR (%VAR)"" % VAR ) VAR = VAR.VAR() VAR VAR: VAR = VAR VAR: VAR VAR < 0: VAR = VAR   VAR: VAR = VAR(VAR.VAR) VAR VAR: VAR = 0  VAR VAR VAR (204, 304) VAR 100 <= VAR < 200 VAR VAR == ""VAR"": VAR = 0 VAR VAR VAR VAR(VAR): """""" VAR-VAR VAR VAR VAR VAR VAR. """"""   VAR = VAR.VAR.VAR(""VAR-VAR"", """").VAR() VAR VAR.VAR VAR VAR: VAR VAR VAR VAR.VAR: VAR.VAR = VAR(VAR) VAR "","" VAR VAR: VAR = [ VAR.VAR() VAR VAR VAR VAR.VAR("","") VAR VAR.VAR() VAR VAR.VAR ] VAR VAR(VAR): VAR.VAR = VAR(VAR) VAR = (VAR, VAR.VAR) VAR VAR VAR VAR VAR: VAR += (VAR.VAR,) VAR VAR(VAR, VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR VAR: VAR VAR VAR: VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR.VAR VAR VAR: VAR = VAR.VAR.VAR(""VAR-VAR"", """").VAR() VAR VAR( ""VAR VAR VAR VAR-VAR: %VAR, VAR "" ""VAR VAR VAR VAR."" % VAR, VAR, ) VAR VAR: VAR += VAR.VAR() VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR"""") VAR VAR + VAR.VAR.VAR() VAR VAR"""" @VAR VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR, VAR VAR-VAR VAR VAR, VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR VAR: VAR: VAR VAR VAR:   VAR VAR(VAR.VAR, VAR, ""VAR VAR VAR."") VAR VAR VAR VAR:  VAR ""VAR VAR VAR VAR"" VAR VAR VAR(VAR):  VAR VAR(VAR) VAR VAR(VAR.VAR, VAR, ""VAR VAR VAR."") VAR (VAR, VAR) VAR VAR:  VAR VAR(""VAR VAR: %VAR"" % VAR, VAR)   VAR = VAR VAR:   VAR VAR VAR:    VAR VAR.VAR: VAR.VAR.VAR()    VAR VAR.VAR: VAR.VAR.VAR()   VAR VAR.VAR VAR VAR.VAR.VAR(): VAR.VAR() VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR.VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR`` VAR ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR ``.VAR`` VAR VAR VAR VAR VAR VAR ``.VAR()`` VAR VAR VAR. (VAR VAR ``VAR`` VAR VAR.) """""" VAR.VAR() VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR.VAR VAR VAR: VAR VAR = VAR VAR = VAR(VAR.VAR, ""VAR"", VAR) VAR VAR.VAR(): VAR VAR VAR VAR:  VAR = VAR.VAR.VAR() VAR VAR VAR VAR VAR"""" VAR = VAR VAR: VAR = VAR VAR = VAR.VAR.VAR(VAR) VAR VAR VAR VAR VAR"""" VAR ( VAR != 0 VAR VAR VAR ):         VAR.VAR.VAR() VAR = VAR VAR VAR.VAR VAR VAR.VAR VAR VAR ( 0, VAR, ):      VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR += VAR(VAR) VAR VAR.VAR VAR VAR VAR: VAR.VAR -= VAR(VAR) VAR = VAR.VAR(VAR, VAR, VAR) VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=2 ** 16, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR() VAR. VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR VAR.VAR VAR VAR.VAR(): VAR VAR VAR VAR.VAR(VAR, VAR=VAR): VAR VAR VAR: VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR=VAR, VAR=VAR) VAR VAR: VAR VAR @VAR VAR VAR(VAR, VAR, **VAR): """""" VAR VAR :VAR:`VAR.VAR.VAR` VAR ``VAR``, VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR ``VAR=VAR``. """""" VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR VAR.VAR:  VAR = VAR.VAR(VAR) VAR: VAR = VAR(VAR.VAR())  VAR = VAR(VAR, ""VAR"", 0) VAR = VAR( VAR=VAR, VAR=VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR, **VAR ) VAR VAR  VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR, VAR, VAR=VAR): VAR VAR.VAR.VAR(VAR, VAR)  VAR VAR(VAR): VAR VAR.VAR  VAR VAR(VAR): VAR VAR VAR.VAR: VAR.VAR.VAR() VAR VAR.VAR: VAR.VAR.VAR() VAR VAR VAR.VAR: VAR.VAR.VAR(VAR) @VAR VAR VAR(VAR): VAR VAR VAR.VAR: VAR VAR.VAR.VAR.VAR(VAR) VAR VAR.VAR VAR VAR: VAR VAR VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR VAR: VAR VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR: VAR VAR( ""VAR VAR-VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR"" ) VAR VAR(VAR): VAR ( VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR, ""VAR"") VAR VAR VAR(VAR.VAR, ""VAR"", VAR) ): VAR VAR.VAR.VAR() VAR VAR(VAR):  VAR VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR(VAR(VAR)) VAR VAR(VAR) == 0: VAR 0 VAR: VAR[: VAR(VAR)] = VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR(). """""" VAR VAR(VAR.VAR, ""VAR"") VAR VAR(VAR):   VAR VAR.VAR VAR VAR VAR: VAR VAR = VAR.VAR.VAR.VAR() VAR = VAR.VAR(VAR"";"", 1)[0] VAR: VAR.VAR = VAR(VAR, 16) VAR VAR:  VAR.VAR() VAR VAR(VAR, VAR) VAR VAR(VAR, VAR): VAR = VAR VAR VAR VAR VAR: VAR = VAR.VAR.VAR(VAR.VAR) VAR = VAR VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR < VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR = VAR.VAR - VAR VAR = VAR VAR VAR == VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR = VAR VAR:  VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR.VAR()  VAR VAR VAR.VAR: VAR VAR( ""VAR VAR VAR VAR. "" ""VAR 'VAR-VAR: VAR' VAR VAR."" ) VAR VAR VAR.VAR(): VAR VAR( ""VAR VAR VAR VAR.VAR.VAR VAR. "" ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."" ) VAR VAR.VAR():  VAR VAR.VAR VAR VAR(VAR.VAR): VAR.VAR.VAR() VAR   VAR VAR.VAR.VAR VAR VAR: VAR VAR VAR: VAR.VAR() VAR VAR.VAR == 0: VAR VAR = VAR.VAR(VAR) VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR VAR VAR VAR:    VAR = VAR.VAR() VAR VAR:  VAR VAR  VAR VAR: VAR = VAR.VAR.VAR.VAR() VAR VAR VAR:  VAR VAR VAR == VAR""\VAR\VAR"": VAR  VAR VAR.VAR: VAR.VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR.VAR): VAR VAR.VAR.VAR[-1].VAR VAR: VAR VAR.VAR VAR VAR(VAR): VAR = [] VAR VAR VAR VAR.VAR(VAR=VAR): VAR VAR""\VAR"" VAR VAR: VAR = VAR.VAR(VAR""\VAR"") VAR VAR"""".VAR(VAR) + VAR[0] + VAR""\VAR"" VAR VAR VAR VAR[1:-1]: VAR VAR + VAR""\VAR"" VAR VAR[-1]: VAR = [VAR[-1]] VAR: VAR = [] VAR: VAR.VAR(VAR) VAR VAR: VAR VAR"""".VAR(VAR) ",1
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/test_response.py,"# -*- coding: utf-8 -*-

import contextlib
import re
import socket
import ssl
import zlib
from base64 import b64decode
from io import BufferedReader, BytesIO, TextIOWrapper
from test import onlyBrotlipy

import mock
import pytest
import six

from urllib3.exceptions import (
    DecodeError,
    IncompleteRead,
    InvalidChunkLength,
    InvalidHeader,
    ProtocolError,
    ResponseNotChunked,
    SSLError,
    httplib_IncompleteRead,
)
from urllib3.packages.six.moves import http_client as httplib
from urllib3.response import HTTPResponse, brotli
from urllib3.util.response import is_fp_closed
from urllib3.util.retry import RequestHistory, Retry

# A known random (i.e, not-too-compressible) payload generated with:
#    """".join(random.choice(string.printable) for i in xrange(512))
#    .encode(""zlib"").encode(""base64"")
# Randomness in tests == bad, and fixing a seed may not be sufficient.
ZLIB_PAYLOAD = b64decode(
    b""""""\
eJwFweuaoQAAANDfineQhiKLUiaiCzvuTEmNNlJGiL5QhnGpZ99z8luQfe1AHoMioB+QSWHQu/L+
lzd7W5CipqYmeVTBjdgSATdg4l4Z2zhikbuF+EKn69Q0DTpdmNJz8S33odfJoVEexw/l2SS9nFdi
pis7KOwXzfSqarSo9uJYgbDGrs1VNnQpT9f8zAorhYCEZronZQF9DuDFfNK3Hecc+WHLnZLQptwk
nufw8S9I43sEwxsT71BiqedHo0QeIrFE01F/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/nNvDGKZ
Khe5TF36JbnKVjdcL1EUNpwrWVfQpFYJ/WWm2b74qNeSZeQv5/xBhRdOmKTJFYgO96PwrHBlsnLn
a3l0LwJsloWpMbzByU5WLbRE6X5INFqjQOtIwYz5BAlhkn+kVqJvWM5vBlfrwP42ifonM5yF4ciJ
auHVks62997mNGOsM7WXNG3P98dBHPo2NhbTvHleL0BI5dus2JY81MUOnK3SGWLH8HeWPa1t5KcW
S5moAj5HexY/g/F8TctpxwsvyZp38dXeLDjSQvEQIkF7XR3YXbeZgKk3V34KGCPOAeeuQDIgyVhV
nP4HF2uWHA==""""""
)


@pytest.fixture
def sock():
    s = socket.socket()
    yield s
    s.close()


class TestLegacyResponse(object):
    def test_getheaders(self):
        headers = {""host"": ""example.com""}
        r = HTTPResponse(headers=headers)
        assert r.getheaders() == headers

    def test_getheader(self):
        headers = {""host"": ""example.com""}
        r = HTTPResponse(headers=headers)
        assert r.getheader(""host"") == ""example.com""


class TestResponse(object):
    def test_cache_content(self):
        r = HTTPResponse(""foo"")
        assert r.data == ""foo""
        assert r._body == ""foo""

    def test_default(self):
        r = HTTPResponse()
        assert r.data is None

    def test_none(self):
        r = HTTPResponse(None)
        assert r.data is None

    def test_preload(self):
        fp = BytesIO(b""foo"")

        r = HTTPResponse(fp, preload_content=True)

        assert fp.tell() == len(b""foo"")
        assert r.data == b""foo""

    def test_no_preload(self):
        fp = BytesIO(b""foo"")

        r = HTTPResponse(fp, preload_content=False)

        assert fp.tell() == 0
        assert r.data == b""foo""
        assert fp.tell() == len(b""foo"")

    def test_decode_bad_data(self):
        fp = BytesIO(b""\x00"" * 10)
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={""content-encoding"": ""deflate""})

    def test_reference_read(self):
        fp = BytesIO(b""foo"")
        r = HTTPResponse(fp, preload_content=False)

        assert r.read(1) == b""f""
        assert r.read(2) == b""oo""
        assert r.read() == b""""
        assert r.read() == b""""

    def test_decode_deflate(self):
        data = zlib.compress(b""foo"")

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""deflate""})

        assert r.data == b""foo""

    def test_decode_deflate_case_insensitve(self):
        data = zlib.compress(b""foo"")

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""DeFlAtE""})

        assert r.data == b""foo""

    def test_chunked_decoding_deflate(self):
        data = zlib.compress(b""foo"")

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={""content-encoding"": ""deflate""}, preload_content=False
        )

        assert r.read(3) == b""""
        # Buffer in case we need to switch to the raw stream
        assert r._decoder._data is not None
        assert r.read(1) == b""f""
        # Now that we've decoded data, we just stream through the decoder
        assert r._decoder._data is None
        assert r.read(2) == b""oo""
        assert r.read() == b""""
        assert r.read() == b""""

    def test_chunked_decoding_deflate2(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={""content-encoding"": ""deflate""}, preload_content=False
        )

        assert r.read(1) == b""""
        assert r.read(1) == b""f""
        # Once we've decoded data, we just stream to the decoder; no buffering
        assert r._decoder._data is None
        assert r.read(2) == b""oo""
        assert r.read() == b""""
        assert r.read() == b""""

    def test_chunked_decoding_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={""content-encoding"": ""gzip""}, preload_content=False
        )

        assert r.read(11) == b""""
        assert r.read(1) == b""f""
        assert r.read(2) == b""oo""
        assert r.read() == b""""
        assert r.read() == b""""

    def test_decode_gzip_multi_member(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()
        data = data * 3

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""gzip""})

        assert r.data == b""foofoofoo""

    def test_decode_gzip_error(self):
        fp = BytesIO(b""foo"")
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={""content-encoding"": ""gzip""})

    def test_decode_gzip_swallow_garbage(self):
        # When data comes from multiple calls to read(), data after
        # the first zlib error (here triggered by garbage) should be
        # ignored.
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()
        data = data * 3 + b""foo""

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={""content-encoding"": ""gzip""}, preload_content=False
        )
        ret = b""""
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break

        assert ret == b""foofoofoo""

    def test_chunked_decoding_gzip_swallow_garbage(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()
        data = data * 3 + b""foo""

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""gzip""})

        assert r.data == b""foofoofoo""

    @onlyBrotlipy()
    def test_decode_brotli(self):
        data = brotli.compress(b""foo"")

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""br""})
        assert r.data == b""foo""

    @onlyBrotlipy()
    def test_chunked_decoding_brotli(self):
        data = brotli.compress(b""foobarbaz"")

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""br""}, preload_content=False)

        ret = b""""
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break
        assert ret == b""foobarbaz""

    @onlyBrotlipy()
    def test_decode_brotli_error(self):
        fp = BytesIO(b""foo"")
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={""content-encoding"": ""br""})

    def test_multi_decoding_deflate_deflate(self):
        data = zlib.compress(zlib.compress(b""foo""))

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""deflate, deflate""})

        assert r.data == b""foo""

    def test_multi_decoding_deflate_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(zlib.compress(b""foo""))
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""deflate, gzip""})

        assert r.data == b""foo""

    def test_multi_decoding_gzip_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()

        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(data)
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""gzip, gzip""})

        assert r.data == b""foo""

    def test_body_blob(self):
        resp = HTTPResponse(b""foo"")
        assert resp.data == b""foo""
        assert resp.closed

    def test_io(self, sock):
        fp = BytesIO(b""foo"")
        resp = HTTPResponse(fp, preload_content=False)

        assert not resp.closed
        assert resp.readable()
        assert not resp.writable()
        with pytest.raises(IOError):
            resp.fileno()

        resp.close()
        assert resp.closed

        # Try closing with an `httplib.HTTPResponse`, because it has an
        # `isclosed` method.
        try:
            hlr = httplib.HTTPResponse(sock)
            resp2 = HTTPResponse(hlr, preload_content=False)
            assert not resp2.closed
            resp2.close()
            assert resp2.closed
        finally:
            hlr.close()

        # also try when only data is present.
        resp3 = HTTPResponse(""foodata"")
        with pytest.raises(IOError):
            resp3.fileno()

        resp3._fp = 2
        # A corner case where _fp is present but doesn't have `closed`,
        # `isclosed`, or `fileno`.  Unlikely, but possible.
        assert resp3.closed
        with pytest.raises(IOError):
            resp3.fileno()

    def test_io_closed_consistently(self, sock):
        try:
            hlr = httplib.HTTPResponse(sock)
            hlr.fp = BytesIO(b""foo"")
            hlr.chunked = 0
            hlr.length = 3
            with HTTPResponse(hlr, preload_content=False) as resp:
                assert not resp.closed
                assert not resp._fp.isclosed()
                assert not is_fp_closed(resp._fp)
                assert not resp.isclosed()
                resp.read()
                assert resp.closed
                assert resp._fp.isclosed()
                assert is_fp_closed(resp._fp)
                assert resp.isclosed()
        finally:
            hlr.close()

    def test_io_bufferedreader(self):
        fp = BytesIO(b""foo"")
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp)

        assert br.read() == b""foo""

        br.close()
        assert resp.closed

        # HTTPResponse.read() by default closes the response
        # https://github.com/urllib3/urllib3/issues/1305
        fp = BytesIO(b""hello\nworld"")
        resp = HTTPResponse(fp, preload_content=False)
        with pytest.raises(ValueError) as ctx:
            list(BufferedReader(resp))
        assert str(ctx.value) == ""readline of closed file""

        b = b""fooandahalf""
        fp = BytesIO(b)
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp, 5)

        br.read(1)  # sets up the buffer, reading 5
        assert len(fp.read()) == (len(b) - 5)

        # This is necessary to make sure the ""no bytes left"" part of `readinto`
        # gets tested.
        while not br.closed:
            br.read(5)

    def test_io_not_autoclose_bufferedreader(self):
        fp = BytesIO(b""hello\nworld"")
        resp = HTTPResponse(fp, preload_content=False, auto_close=False)
        reader = BufferedReader(resp)
        assert list(reader) == [b""hello\n"", b""world""]

        assert not reader.closed
        assert not resp.closed
        with pytest.raises(StopIteration):
            next(reader)

        reader.close()
        assert reader.closed
        assert resp.closed
        with pytest.raises(ValueError) as ctx:
            next(reader)
        assert str(ctx.value) == ""readline of closed file""

    def test_io_textiowrapper(self):
        fp = BytesIO(b""\xc3\xa4\xc3\xb6\xc3\xbc\xc3\x9f"")
        resp = HTTPResponse(fp, preload_content=False)
        br = TextIOWrapper(resp, encoding=""utf8"")

        assert br.read() == u""""

        br.close()
        assert resp.closed

        # HTTPResponse.read() by default closes the response
        # https://github.com/urllib3/urllib3/issues/1305
        fp = BytesIO(
            b""\xc3\xa4\xc3\xb6\xc3\xbc\xc3\x9f\n\xce\xb1\xce\xb2\xce\xb3\xce\xb4""
        )
        resp = HTTPResponse(fp, preload_content=False)
        with pytest.raises(ValueError) as ctx:
            if six.PY2:
                # py2's implementation of TextIOWrapper requires `read1`
                # method which is provided by `BufferedReader` wrapper
                resp = BufferedReader(resp)
            list(TextIOWrapper(resp))
        assert re.match(""I/O operation on closed file.?"", str(ctx.value))

    def test_io_not_autoclose_textiowrapper(self):
        fp = BytesIO(
            b""\xc3\xa4\xc3\xb6\xc3\xbc\xc3\x9f\n\xce\xb1\xce\xb2\xce\xb3\xce\xb4""
        )
        resp = HTTPResponse(fp, preload_content=False, auto_close=False)
        if six.PY2:
            # py2's implementation of TextIOWrapper requires `read1`
            # method which is provided by `BufferedReader` wrapper
            resp = BufferedReader(resp)
        reader = TextIOWrapper(resp, encoding=""utf8"")
        assert list(reader) == [u""\n"", u""""]

        assert not reader.closed
        assert not resp.closed
        with pytest.raises(StopIteration):
            next(reader)

        reader.close()
        assert reader.closed
        assert resp.closed
        with pytest.raises(ValueError) as ctx:
            next(reader)
        assert re.match(""I/O operation on closed file.?"", str(ctx.value))

    def test_streaming(self):
        fp = BytesIO(b""foo"")
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        assert next(stream) == b""fo""
        assert next(stream) == b""o""
        with pytest.raises(StopIteration):
            next(stream)

    def test_streaming_tell(self):
        fp = BytesIO(b""foo"")
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        position = 0

        position += len(next(stream))
        assert 2 == position
        assert position == resp.tell()

        position += len(next(stream))
        assert 3 == position
        assert position == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(
            fp, headers={""content-encoding"": ""gzip""}, preload_content=False
        )
        stream = resp.stream(2)

        assert next(stream) == b""f""
        assert next(stream) == b""oo""
        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming_tell(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        uncompressed_data = b""foo""
        data = compress.compress(uncompressed_data)
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(
            fp, headers={""content-encoding"": ""gzip""}, preload_content=False
        )
        stream = resp.stream()

        # Read everything
        payload = next(stream)
        assert payload == uncompressed_data

        assert len(data) == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate_streaming_tell_intermediate_point(self):
        # Ensure that ``tell()`` returns the correct number of bytes when
        # part-way through streaming compressed content.
        NUMBER_OF_READS = 10

        class MockCompressedDataReading(BytesIO):
            """"""
            A BytesIO-like reader returning ``payload`` in ``NUMBER_OF_READS``
            calls to ``read``.
            """"""

            def __init__(self, payload, payload_part_size):
                self.payloads = [
                    payload[i * payload_part_size : (i + 1) * payload_part_size]
                    for i in range(NUMBER_OF_READS + 1)
                ]

                assert b"""".join(self.payloads) == payload

            def read(self, _):
                # Amount is unused.
                if len(self.payloads) > 0:
                    return self.payloads.pop(0)
                return b""""

        uncompressed_data = zlib.decompress(ZLIB_PAYLOAD)

        payload_part_size = len(ZLIB_PAYLOAD) // NUMBER_OF_READS
        fp = MockCompressedDataReading(ZLIB_PAYLOAD, payload_part_size)
        resp = HTTPResponse(
            fp, headers={""content-encoding"": ""deflate""}, preload_content=False
        )
        stream = resp.stream()

        parts_positions = [(part, resp.tell()) for part in stream]
        end_of_stream = resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

        parts, positions = zip(*parts_positions)

        # Check that the payload is equal to the uncompressed data
        payload = b"""".join(parts)
        assert uncompressed_data == payload

        # Check that the positions in the stream are correct
        expected = [(i + 1) * payload_part_size for i in range(NUMBER_OF_READS)]
        assert expected == list(positions)

        # Check that the end of the stream is in the correct place
        assert len(ZLIB_PAYLOAD) == end_of_stream

    def test_deflate_streaming(self):
        data = zlib.compress(b""foo"")

        fp = BytesIO(data)
        resp = HTTPResponse(
            fp, headers={""content-encoding"": ""deflate""}, preload_content=False
        )
        stream = resp.stream(2)

        assert next(stream) == b""f""
        assert next(stream) == b""oo""
        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate2_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(
            fp, headers={""content-encoding"": ""deflate""}, preload_content=False
        )
        stream = resp.stream(2)

        assert next(stream) == b""f""
        assert next(stream) == b""oo""
        with pytest.raises(StopIteration):
            next(stream)

    def test_empty_stream(self):
        fp = BytesIO(b"""")
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        with pytest.raises(StopIteration):
            next(stream)

    def test_length_no_header(self):
        fp = BytesIO(b""12345"")
        resp = HTTPResponse(fp, preload_content=False)
        assert resp.length_remaining is None

    def test_length_w_valid_header(self):
        headers = {""content-length"": ""5""}
        fp = BytesIO(b""12345"")

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

    def test_length_w_bad_header(self):
        garbage = {""content-length"": ""foo""}
        fp = BytesIO(b""12345"")

        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

        garbage[""content-length""] = ""-10""
        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

    def test_length_when_chunked(self):
        # This is expressly forbidden in RFC 7230 sec 3.3.2
        # We fall back to chunked in this case and try to
        # handle response ignoring content length.
        headers = {""content-length"": ""5"", ""transfer-encoding"": ""chunked""}
        fp = BytesIO(b""12345"")

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining is None

    def test_length_with_multiple_content_lengths(self):
        headers = {""content-length"": ""5, 5, 5""}
        garbage = {""content-length"": ""5, 42""}
        fp = BytesIO(b""abcde"")

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

        with pytest.raises(InvalidHeader):
            HTTPResponse(fp, headers=garbage, preload_content=False)

    def test_length_after_read(self):
        headers = {""content-length"": ""5""}

        # Test no defined length
        fp = BytesIO(b""12345"")
        resp = HTTPResponse(fp, preload_content=False)
        resp.read()
        assert resp.length_remaining is None

        # Test our update from content-length
        fp = BytesIO(b""12345"")
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        resp.read()
        assert resp.length_remaining == 0

        # Test partial read
        fp = BytesIO(b""12345"")
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        data = resp.stream(2)
        next(data)
        assert resp.length_remaining == 3

    def test_mock_httpresponse_stream(self):
        # Mock out a HTTP Request that does enough to make it through urllib3's
        # read() and close() calls, and also exhausts and underlying file
        # object.
        class MockHTTPRequest(object):
            self.fp = None

            def read(self, amt):
                data = self.fp.read(amt)
                if not data:
                    self.fp = None

                return data

            def close(self):
                self.fp = None

        bio = BytesIO(b""foo"")
        fp = MockHTTPRequest()
        fp.fp = bio
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b""fo""
        assert next(stream) == b""o""
        with pytest.raises(StopIteration):
            next(stream)

    def test_mock_transfer_encoding_chunked(self):
        stream = [b""fo"", b""o"", b""bar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )

        for i, c in enumerate(resp.stream()):
            assert c == stream[i]

    def test_mock_gzipped_transfer_encoding_chunked_decoded(self):
        """"""Show that we can decode the gzipped and chunked body.""""""

        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b""foobar"")
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i : i + 2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {""transfer-encoding"": ""chunked"", ""content-encoding"": ""gzip""}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b""""
        for c in resp.stream(decode_content=True):
            data += c

        assert b""foobar"" == data

    def test_mock_transfer_encoding_chunked_custom_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        expected_response = [b""fo"", b""oo"", b""o"", b""bb"", b""bb"", b""aa"", b""aa"", b""ar""]
        response = list(resp.read_chunked(2))
        assert expected_response == response

    def test_mock_transfer_encoding_chunked_unlmtd_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        assert stream == list(resp.read_chunked())

    def test_read_not_chunked_response_as_chunks(self):
        fp = BytesIO(b""foo"")
        resp = HTTPResponse(fp, preload_content=False)
        r = resp.read_chunked()
        with pytest.raises(ResponseNotChunked):
            next(r)

    def test_buggy_incomplete_read(self):
        # Simulate buggy versions of Python (<2.7.4)
        # See http://bugs.python.org/issue16298
        content_length = 1337
        fp = BytesIO(b"""")
        resp = HTTPResponse(
            fp,
            headers={""content-length"": str(content_length)},
            preload_content=False,
            enforce_content_length=True,
        )
        with pytest.raises(ProtocolError) as ctx:
            resp.read(3)

        orig_ex = ctx.value.args[1]
        assert isinstance(orig_ex, IncompleteRead)
        assert orig_ex.partial == 0
        assert orig_ex.expected == content_length

    def test_incomplete_chunk(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedIncompleteRead(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        with pytest.raises(ProtocolError) as ctx:
            next(resp.read_chunked())

        orig_ex = ctx.value.args[1]
        assert isinstance(orig_ex, httplib_IncompleteRead)

    def test_invalid_chunk_length(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedInvalidChunkLength(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        with pytest.raises(ProtocolError) as ctx:
            next(resp.read_chunked())

        orig_ex = ctx.value.args[1]
        assert isinstance(orig_ex, InvalidChunkLength)
        assert orig_ex.length == six.b(fp.BAD_LENGTH_LINE)

    def test_chunked_response_without_crlf_on_end(self):
        stream = [b""foo"", b""bar"", b""baz""]
        fp = MockChunkedEncodingWithoutCRLFOnEnd(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        assert stream == list(resp.stream())

    def test_chunked_response_with_extensions(self):
        stream = [b""foo"", b""bar""]
        fp = MockChunkedEncodingWithExtensions(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        assert stream == list(resp.stream())

    def test_chunked_head_response(self):
        r = httplib.HTTPResponse(MockSock, method=""HEAD"")
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            """",
            preload_content=False,
            headers={""transfer-encoding"": ""chunked""},
            original_response=r,
        )
        assert resp.chunked is True

        resp.supports_chunked_reads = lambda: True
        resp.release_conn = mock.Mock()
        for _ in resp.stream():
            continue
        resp.release_conn.assert_called_once_with()

    def test_get_case_insensitive_headers(self):
        headers = {""host"": ""example.com""}
        r = HTTPResponse(headers=headers)
        assert r.headers.get(""host"") == ""example.com""
        assert r.headers.get(""Host"") == ""example.com""

    def test_retries(self):
        fp = BytesIO(b"""")
        resp = HTTPResponse(fp)
        assert resp.retries is None
        retry = Retry()
        resp = HTTPResponse(fp, retries=retry)
        assert resp.retries == retry

    def test_geturl(self):
        fp = BytesIO(b"""")
        request_url = ""https://example.com""
        resp = HTTPResponse(fp, request_url=request_url)
        assert resp.geturl() == request_url

    def test_geturl_retries(self):
        fp = BytesIO(b"""")
        resp = HTTPResponse(fp, request_url=""http://example.com"")
        request_histories = [
            RequestHistory(
                method=""GET"",
                url=""http://example.com"",
                error=None,
                status=301,
                redirect_location=""https://example.com/"",
            ),
            RequestHistory(
                method=""GET"",
                url=""https://example.com/"",
                error=None,
                status=301,
                redirect_location=""https://www.example.com"",
            ),
        ]
        retry = Retry(history=request_histories)
        resp = HTTPResponse(fp, retries=retry)
        assert resp.geturl() == ""https://www.example.com""

    @pytest.mark.parametrize(
        [""payload"", ""expected_stream""],
        [
            (b"""", []),
            (b""\n"", [b""\n""]),
            (b""\n\n\n"", [b""\n"", b""\n"", b""\n""]),
            (b""abc\ndef"", [b""abc\n"", b""def""]),
            (b""Hello\nworld\n\n\n!"", [b""Hello\n"", b""world\n"", b""\n"", b""\n"", b""!""]),
        ],
    )
    def test__iter__(self, payload, expected_stream):
        actual_stream = []
        for chunk in HTTPResponse(BytesIO(payload), preload_content=False):
            actual_stream.append(chunk)

        assert actual_stream == expected_stream

    def test__iter__decode_content(self):
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b""foo\nbar"")
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i : i + 2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {""transfer-encoding"": ""chunked"", ""content-encoding"": ""gzip""}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b""""
        for c in resp:
            data += c

        assert b""foo\nbar"" == data

    def test_non_timeout_ssl_error_on_read(self):
        mac_error = ssl.SSLError(
            ""SSL routines"", ""ssl3_get_record"", ""decryption failed or bad record mac""
        )

        @contextlib.contextmanager
        def make_bad_mac_fp():
            fp = BytesIO(b"""")
            with mock.patch.object(fp, ""read"") as fp_read:
                # mac/decryption error
                fp_read.side_effect = mac_error
                yield fp

        with make_bad_mac_fp() as fp:
            with pytest.raises(SSLError) as e:
                HTTPResponse(fp)
            assert e.value.args[0] == mac_error

        with make_bad_mac_fp() as fp:
            resp = HTTPResponse(fp, preload_content=False)
            with pytest.raises(SSLError) as e:
                resp.read()
            assert e.value.args[0] == mac_error


class MockChunkedEncodingResponse(object):
    def __init__(self, content):
        """"""
        content: collection of str, each str is a chunk in response
        """"""
        self.content = content
        self.index = 0  # This class iterates over self.content.
        self.closed = False
        self.cur_chunk = b""""
        self.chunks_exhausted = False

    @staticmethod
    def _encode_chunk(chunk):
        # In the general case, we can't decode the chunk to unicode
        length = ""%X\r\n"" % len(chunk)
        return length.encode() + chunk + b""\r\n""

    def _pop_new_chunk(self):
        if self.chunks_exhausted:
            return b""""
        try:
            chunk = self.content[self.index]
        except IndexError:
            chunk = b""""
            self.chunks_exhausted = True
        else:
            self.index += 1
        chunk = self._encode_chunk(chunk)
        if not isinstance(chunk, bytes):
            chunk = chunk.encode()
        return chunk

    def pop_current_chunk(self, amt=-1, till_crlf=False):
        if amt > 0 and till_crlf:
            raise ValueError(""Can't specify amt and till_crlf."")
        if len(self.cur_chunk) <= 0:
            self.cur_chunk = self._pop_new_chunk()
        if till_crlf:
            try:
                i = self.cur_chunk.index(b""\r\n"")
            except ValueError:
                # No CRLF in current chunk -- probably caused by encoder.
                self.cur_chunk = b""""
                return b""""
            else:
                chunk_part = self.cur_chunk[: i + 2]
                self.cur_chunk = self.cur_chunk[i + 2 :]
                return chunk_part
        elif amt <= -1:
            chunk_part = self.cur_chunk
            self.cur_chunk = b""""
            return chunk_part
        else:
            try:
                chunk_part = self.cur_chunk[:amt]
            except IndexError:
                chunk_part = self.cur_chunk
                self.cur_chunk = b""""
            else:
                self.cur_chunk = self.cur_chunk[amt:]
            return chunk_part

    def readline(self):
        return self.pop_current_chunk(till_crlf=True)

    def read(self, amt=-1):
        return self.pop_current_chunk(amt)

    def flush(self):
        # Python 3 wants this method.
        pass

    def close(self):
        self.closed = True


class MockChunkedIncompleteRead(MockChunkedEncodingResponse):
    def _encode_chunk(self, chunk):
        return ""9999\r\n%s\r\n"" % chunk.decode()


class MockChunkedInvalidChunkLength(MockChunkedEncodingResponse):
    BAD_LENGTH_LINE = ""ZZZ\r\n""

    def _encode_chunk(self, chunk):
        return ""%s%s\r\n"" % (self.BAD_LENGTH_LINE, chunk.decode())


class MockChunkedEncodingWithoutCRLFOnEnd(MockChunkedEncodingResponse):
    def _encode_chunk(self, chunk):
        return ""%X\r\n%s%s"" % (
            len(chunk),
            chunk.decode(),
            ""\r\n"" if len(chunk) > 0 else """",
        )


class MockChunkedEncodingWithExtensions(MockChunkedEncodingResponse):
    def _encode_chunk(self, chunk):
        return ""%X;asd=qwe\r\n%s\r\n"" % (len(chunk), chunk.decode())


class MockSock(object):
    @classmethod
    def makefile(cls, *args, **kwargs):
        return",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED," VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR     VAR = VAR( VAR""""""\ VAR+VAR/VAR+ VAR+VAR/VAR VAR+VAR VAR/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/VAR VAR/VAR/VAR VAR+VAR VAR VAR/VAR/VAR VAR=="""""" ) @VAR.VAR VAR VAR(): VAR = VAR.VAR() VAR VAR VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = {""VAR"": ""VAR.VAR""} VAR = VAR(VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = {""VAR"": ""VAR.VAR""} VAR = VAR(VAR=VAR) VAR VAR.VAR(""VAR"") == ""VAR.VAR"" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR(""VAR"") VAR VAR.VAR == ""VAR"" VAR VAR.VAR == ""VAR"" VAR VAR(VAR): VAR = VAR() VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR(VAR""VAR"") VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 0 VAR VAR.VAR == VAR""VAR"" VAR VAR.VAR() == VAR(VAR""VAR"") VAR VAR(VAR): VAR = VAR(VAR""\VAR"" * 10) VAR VAR.VAR(VAR): VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(1) == VAR""VAR"" VAR VAR.VAR(2) == VAR""VAR"" VAR VAR.VAR() == VAR"""" VAR VAR.VAR() == VAR"""" VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR VAR.VAR(3) == VAR""""  VAR VAR.VAR.VAR VAR VAR VAR VAR VAR.VAR(1) == VAR""VAR""  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR""VAR"" VAR VAR.VAR() == VAR"""" VAR VAR.VAR() == VAR"""" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR VAR.VAR(1) == VAR"""" VAR VAR.VAR(1) == VAR""VAR""  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR""VAR"" VAR VAR.VAR() == VAR"""" VAR VAR.VAR() == VAR"""" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR VAR.VAR(11) == VAR"""" VAR VAR.VAR(1) == VAR""VAR"" VAR VAR.VAR(2) == VAR""VAR"" VAR VAR.VAR() == VAR"""" VAR VAR.VAR() == VAR"""" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR * 3 VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR VAR.VAR(VAR): VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR(VAR):    VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR * 3 + VAR""VAR"" VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR"""" VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR * 3 + VAR""VAR"" VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR.VAR == VAR""VAR"" @VAR() VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR.VAR == VAR""VAR"" @VAR() VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR) VAR = VAR"""" VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR""VAR"" @VAR() VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR VAR.VAR(VAR): VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR(VAR""VAR"")) VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR, VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR.VAR(VAR""VAR"")) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR, VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR, VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR VAR.VAR == VAR""VAR"" VAR VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR VAR.VAR() VAR VAR VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR.VAR   VAR: VAR = VAR.VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR.VAR() VAR VAR.VAR VAR: VAR.VAR()  VAR = VAR(""VAR"") VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR = 2   VAR VAR.VAR VAR VAR.VAR(VAR): VAR.VAR() VAR VAR(VAR, VAR): VAR: VAR = VAR.VAR(VAR) VAR.VAR = VAR(VAR""VAR"") VAR.VAR = 0 VAR.VAR = 3 VAR VAR(VAR, VAR=VAR) VAR VAR: VAR VAR VAR.VAR VAR VAR VAR.VAR.VAR() VAR VAR VAR(VAR.VAR) VAR VAR VAR.VAR() VAR.VAR() VAR VAR.VAR VAR VAR.VAR.VAR() VAR VAR(VAR.VAR) VAR VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR) VAR VAR.VAR() == VAR""VAR"" VAR.VAR() VAR VAR.VAR   VAR = VAR(VAR""VAR\VAR"") VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(VAR) VAR VAR: VAR(VAR(VAR)) VAR VAR(VAR.VAR) == ""VAR VAR VAR VAR"" VAR = VAR""VAR"" VAR = VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR, 5) VAR.VAR(1)  VAR VAR(VAR.VAR()) == (VAR(VAR) - 5)   VAR VAR VAR.VAR: VAR.VAR(5) VAR VAR(VAR): VAR = VAR(VAR""VAR\VAR"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR(VAR) VAR VAR(VAR) == [VAR""VAR\VAR"", VAR""VAR""] VAR VAR VAR.VAR VAR VAR VAR.VAR VAR VAR.VAR(VAR): VAR(VAR) VAR.VAR() VAR VAR.VAR VAR VAR.VAR VAR VAR.VAR(VAR) VAR VAR: VAR(VAR) VAR VAR(VAR.VAR) == ""VAR VAR VAR VAR"" VAR VAR(VAR): VAR = VAR(VAR""\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR"") VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR, VAR=""VAR"") VAR VAR.VAR() == VAR"""" VAR.VAR() VAR VAR.VAR   VAR = VAR( VAR""\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR"" ) VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(VAR) VAR VAR: VAR VAR.VAR:   VAR = VAR(VAR) VAR(VAR(VAR)) VAR VAR.VAR(""VAR/VAR VAR VAR VAR VAR.?"", VAR(VAR.VAR)) VAR VAR(VAR): VAR = VAR( VAR""\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR"" ) VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR:   VAR = VAR(VAR) VAR = VAR(VAR, VAR=""VAR"") VAR VAR(VAR) == [VAR""\VAR"", VAR""""] VAR VAR VAR.VAR VAR VAR VAR.VAR VAR VAR.VAR(VAR): VAR(VAR) VAR.VAR() VAR VAR.VAR VAR VAR.VAR VAR VAR.VAR(VAR) VAR VAR: VAR(VAR) VAR VAR.VAR(""VAR/VAR VAR VAR VAR VAR.?"", VAR(VAR.VAR)) VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR(VAR) == VAR""VAR"" VAR VAR(VAR) == VAR""VAR"" VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR = 0 VAR += VAR(VAR(VAR)) VAR 2 == VAR VAR VAR == VAR.VAR() VAR += VAR(VAR(VAR)) VAR 3 == VAR VAR VAR == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR""VAR"" VAR VAR(VAR) == VAR""VAR"" VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR""VAR"" VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR.VAR()  VAR = VAR(VAR) VAR VAR == VAR VAR VAR(VAR) == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR):   VAR = 10 VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR ``VAR`` VAR ``VAR`` VAR VAR ``VAR``. """""" VAR VAR(VAR, VAR, VAR): VAR.VAR = [ VAR[VAR * VAR : (VAR + 1) * VAR] VAR VAR VAR VAR(VAR + 1) ] VAR VAR"""".VAR(VAR.VAR) == VAR VAR VAR(VAR, VAR):  VAR VAR(VAR.VAR) > 0: VAR VAR.VAR.VAR(0) VAR VAR"""" VAR = VAR.VAR(VAR) VAR = VAR(VAR)  VAR = VAR(VAR, VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR.VAR() VAR = [(VAR, VAR.VAR()) VAR VAR VAR VAR] VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR, VAR = VAR(*VAR)  VAR = VAR"""".VAR(VAR) VAR VAR == VAR  VAR = [(VAR + 1) * VAR VAR VAR VAR VAR(VAR)] VAR VAR == VAR(VAR)  VAR VAR(VAR) == VAR VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR""VAR"" VAR VAR(VAR) == VAR""VAR"" VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR""VAR"" VAR VAR(VAR) == VAR""VAR"" VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR"""") VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""} VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR(VAR): VAR = {""VAR-VAR"": ""VAR""} VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR[""VAR-VAR""] = ""-10"" VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR):    VAR = {""VAR-VAR"": ""5"", ""VAR-VAR"": ""VAR""} VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""5, 5, 5""} VAR = {""VAR-VAR"": ""5, 42""} VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR.VAR(VAR): VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""}  VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR VAR VAR  VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR == 0  VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR(2) VAR(VAR) VAR VAR.VAR == 3 VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(VAR) VAR VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR): VAR.VAR = VAR VAR = VAR(VAR""VAR"") VAR = VAR() VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR""VAR"" VAR VAR(VAR) == VAR""VAR"" VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR, VAR VAR VAR(VAR.VAR()): VAR VAR == VAR[VAR] VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR : VAR + 2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {""VAR-VAR"": ""VAR"", ""VAR-VAR"": ""VAR""} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR"""" VAR VAR VAR VAR.VAR(VAR=VAR): VAR += VAR VAR VAR""VAR"" == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR"", VAR""VAR"", VAR""VAR"", VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR.VAR(2)) VAR VAR == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR):   VAR = 1337 VAR = VAR(VAR"""") VAR = VAR( VAR, VAR={""VAR-VAR"": VAR(VAR)}, VAR=VAR, VAR=VAR, ) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(3) VAR = VAR.VAR.VAR[1] VAR VAR(VAR, VAR) VAR VAR.VAR == 0 VAR VAR.VAR == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR.VAR(VAR) VAR VAR: VAR(VAR.VAR()) VAR = VAR.VAR.VAR[1] VAR VAR(VAR, VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR.VAR(VAR) VAR VAR: VAR(VAR.VAR()) VAR = VAR.VAR.VAR[1] VAR VAR(VAR, VAR) VAR VAR.VAR == VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR(VAR, VAR=""VAR"") VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( """", VAR=VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR, ) VAR VAR.VAR VAR VAR VAR.VAR = VAR: VAR VAR.VAR = VAR.VAR() VAR VAR VAR VAR.VAR(): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR = {""VAR"": ""VAR.VAR""} VAR = VAR(VAR=VAR) VAR VAR.VAR.VAR(""VAR"") == ""VAR.VAR"" VAR VAR.VAR.VAR(""VAR"") == ""VAR.VAR"" VAR VAR(VAR): VAR = VAR(VAR"""") VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR = VAR() VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR == VAR VAR VAR(VAR): VAR = VAR(VAR"""") VAR = ""VAR: VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = VAR(VAR"""") VAR = VAR(VAR, VAR=""VAR: VAR = [ VAR( VAR=""VAR"", VAR=""VAR: VAR=VAR, VAR=301, VAR=""VAR: ), VAR( VAR=""VAR"", VAR=""VAR: VAR=VAR, VAR=301, VAR=""VAR: ), ] VAR = VAR(VAR=VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == ""VAR: @VAR.VAR.VAR( [""VAR"", ""VAR""], [ (VAR"""", []), (VAR""\VAR"", [VAR""\VAR""]), (VAR""\VAR\VAR\VAR"", [VAR""\VAR"", VAR""\VAR"", VAR""\VAR""]), (VAR""VAR\VAR"", [VAR""VAR\VAR"", VAR""VAR""]), (VAR""VAR\VAR\VAR\VAR\VAR!"", [VAR""VAR\VAR"", VAR""VAR\VAR"", VAR""\VAR"", VAR""\VAR"", VAR""!""]), ], ) VAR VAR(VAR, VAR, VAR): VAR = [] VAR VAR VAR VAR(VAR(VAR), VAR=VAR): VAR.VAR(VAR) VAR VAR == VAR VAR VAR(VAR): VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR\VAR"") VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR : VAR + 2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {""VAR-VAR"": ""VAR"", ""VAR-VAR"": ""VAR""} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR"""" VAR VAR VAR VAR: VAR += VAR VAR VAR""VAR\VAR"" == VAR VAR VAR(VAR): VAR = VAR.VAR( ""VAR VAR"", ""VAR"", ""VAR VAR VAR VAR VAR VAR"" ) @VAR.VAR VAR VAR(): VAR = VAR(VAR"""") VAR VAR.VAR.VAR(VAR, ""VAR"") VAR VAR:  VAR.VAR = VAR VAR VAR VAR VAR() VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR(VAR) VAR VAR.VAR.VAR[0] == VAR VAR VAR() VAR VAR: VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR() VAR VAR.VAR.VAR[0] == VAR VAR VAR(VAR): VAR VAR(VAR, VAR): """""" VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR """""" VAR.VAR = VAR VAR.VAR = 0  VAR.VAR = VAR VAR.VAR = VAR"""" VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR = ""%VAR\VAR\VAR"" % VAR(VAR) VAR VAR.VAR() + VAR + VAR""\VAR\VAR"" VAR VAR(VAR): VAR VAR.VAR: VAR VAR"""" VAR: VAR = VAR.VAR[VAR.VAR] VAR VAR: VAR = VAR"""" VAR.VAR = VAR VAR: VAR.VAR += 1 VAR = VAR.VAR(VAR) VAR VAR VAR(VAR, VAR): VAR = VAR.VAR() VAR VAR VAR VAR(VAR, VAR=-1, VAR=VAR): VAR VAR > 0 VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR."") VAR VAR(VAR.VAR) <= 0: VAR.VAR = VAR.VAR() VAR VAR: VAR: VAR = VAR.VAR.VAR(VAR""\VAR\VAR"") VAR VAR:  VAR.VAR = VAR"""" VAR VAR"""" VAR: VAR = VAR.VAR[: VAR + 2] VAR.VAR = VAR.VAR[VAR + 2 :] VAR VAR VAR VAR <= -1: VAR = VAR.VAR VAR.VAR = VAR"""" VAR VAR VAR: VAR: VAR = VAR.VAR[:VAR] VAR VAR: VAR = VAR.VAR VAR.VAR = VAR"""" VAR: VAR.VAR = VAR.VAR[VAR:] VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR=VAR) VAR VAR(VAR, VAR=-1): VAR VAR.VAR(VAR) VAR VAR(VAR):  VAR VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR): VAR VAR(VAR, VAR): VAR ""9999\VAR\VAR%VAR\VAR\VAR"" % VAR.VAR() VAR VAR(VAR): VAR = ""VAR\VAR\VAR"" VAR VAR(VAR, VAR): VAR ""%VAR%VAR\VAR\VAR"" % (VAR.VAR, VAR.VAR()) VAR VAR(VAR): VAR VAR(VAR, VAR): VAR ""%VAR\VAR\VAR%VAR%VAR"" % ( VAR(VAR), VAR.VAR(), ""\VAR\VAR"" VAR VAR(VAR) > 0 VAR """", ) VAR VAR(VAR): VAR VAR(VAR, VAR): VAR ""%VAR;VAR=VAR\VAR\VAR%VAR\VAR\VAR"" % (VAR(VAR), VAR.VAR()) VAR VAR(VAR): @VAR VAR VAR(VAR, *VAR, **VAR): VAR ",1
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,docs/requirements.txt,"-r ../dev-requirements.txt
ndg-httpsclient
sphinx
alabaster
requests>=2.0,<2.16",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"-VAR ../VAR-VAR.VAR VAR-VAR VAR VAR VAR>=2.0,<2.16 ",1
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,src/urllib3/contripyopenssl.py,"""""""
SSL with SNI_-support for Python 2. Follow these instructions if you would
like to verify SSL certificates in Python 2. Note, the default libraries do
*not* do certificate checking; you need to do additional work to validate
certificates yourself.

This needs the following packages installed:

* pyOpenSSL (tested with 16.0.0)
* cryptography (minimum 1.3.4, from pyopenssl)
* idna (minimum 2.0, from cryptography)

However, pyopenssl depends on cryptography, which depends on idna, so while we
use all three directly here we end up having relatively few packages required.

You can install them with the following command:

    pip install pyopenssl cryptography idna

To activate certificate checking, call
:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code
before you begin making HTTP requests. This can be done in a ``sitecustomize``
module, or at any other time before your application begins using ``urllib3``,
like this::

    try:
        import urllib3.contrib.pyopenssl
        urllib3.contrib.pyopenssl.inject_into_urllib3()
    except ImportError:
        pass

Now you can use :mod:`urllib3` as you normally would, and it will support SNI
when the required modules are installed.

Activating this module also has the positive side effect of disabling SSL/TLS
compression in Python 2 (see `CRIME attack`_).

If you want to configure the default list of supported cipher suites, you can
set the ``urllib3.contrib.pyopenssl.DEFAULT_SSL_CIPHER_LIST`` variable.

.. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication
.. _crime attack: https://en.wikipedia.org/wiki/CRIME_(security_exploit)
""""""
from __future__ import absolute_import

import OpenSSL.SSL
from cryptography import x509
from cryptography.hazmat.backends.openssl import backend as openssl_backend
from cryptography.hazmat.backends.openssl.x509 import _Certificate
try:
    from cryptography.x509 import UnsupportedExtension
except ImportError:
    # UnsupportedExtension is gone in cryptography >= 2.1.0
    class UnsupportedExtension(Exception):
        pass

from socket import timeout, error as SocketError
from io import BytesIO

try:  # Platform-specific: Python 2
    from socket import _fileobject
except ImportError:  # Platform-specific: Python 3
    _fileobject = None
    from ..packages.backports.makefile import backport_makefile

import logging
import ssl
from ..packages import six
import sys

from .. import util

__all__ = ['inject_into_urllib3', 'extract_from_urllib3']

# SNI always works.
HAS_SNI = True

# Map from urllib3 to PyOpenSSL compatible parameter-values.
_openssl_versions = {
    ssl.PROTOCOL_SSLv23: OpenSSL.SSL.SSLv23_METHOD,
    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,
}

if hasattr(ssl, 'PROTOCOL_TLSv1_1') and hasattr(OpenSSL.SSL, 'TLSv1_1_METHOD'):
    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD

if hasattr(ssl, 'PROTOCOL_TLSv1_2') and hasattr(OpenSSL.SSL, 'TLSv1_2_METHOD'):
    _openssl_versions[ssl.PROTOCOL_TLSv1_2] = OpenSSL.SSL.TLSv1_2_METHOD

try:
    _openssl_versions.update({ssl.PROTOCOL_SSLv3: OpenSSL.SSL.SSLv3_METHOD})
except AttributeError:
    pass

_stdlib_to_openssl_verify = {
    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,
    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,
    ssl.CERT_REQUIRED:
        OpenSSL.SSL.VERIFY_PEER + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,
}
_openssl_to_stdlib_verify = dict(
    (v, k) for k, v in _stdlib_to_openssl_verify.items()
)

# OpenSSL will only write 16K at a time
SSL_WRITE_BLOCKSIZE = 16384

orig_util_HAS_SNI = util.HAS_SNI
orig_util_SSLContext = util.ssl_.SSLContext


log = logging.getLogger(__name__)


def inject_into_urllib3():
    'Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.'

    _validate_dependencies_met()

    util.ssl_.SSLContext = PyOpenSSLContext
    util.HAS_SNI = HAS_SNI
    util.ssl_.HAS_SNI = HAS_SNI
    util.IS_PYOPENSSL = True
    util.ssl_.IS_PYOPENSSL = True


def extract_from_urllib3():
    'Undo monkey-patching by :func:`inject_into_urllib3`.'

    util.ssl_.SSLContext = orig_util_SSLContext
    util.HAS_SNI = orig_util_HAS_SNI
    util.ssl_.HAS_SNI = orig_util_HAS_SNI
    util.IS_PYOPENSSL = False
    util.ssl_.IS_PYOPENSSL = False


def _validate_dependencies_met():
    """"""
    Verifies that PyOpenSSL's package-level dependencies have been met.
    Throws `ImportError` if they are not met.
    """"""
    # Method added in `cryptography==1.1`; not available in older versions
    from cryptography.x509.extensions import Extensions
    if getattr(Extensions, ""get_extension_for_class"", None) is None:
        raise ImportError(""'cryptography' module missing required functionality.  ""
                          ""Try upgrading to v1.3.4 or newer."")

    # pyOpenSSL 0.14 and above use cryptography for OpenSSL bindings. The _x509
    # attribute is only present on those versions.
    from OpenSSL.crypto import X509
    x509 = X509()
    if getattr(x509, ""_x509"", None) is None:
        raise ImportError(""'pyOpenSSL' module missing required functionality. ""
                          ""Try upgrading to v0.14 or newer."")


def _dnsname_to_stdlib(name):
    """"""
    Converts a dNSName SubjectAlternativeName field to the form used by the
    standard library on the given Python version.

    Cryptography produces a dNSName as a unicode string that was idna-decoded
    from ASCII bytes. We need to idna-encode that string to get it back, and
    then on Python 3 we also need to convert to unicode via UTF-8 (the stdlib
    uses PyUnicode_FromStringAndSize on it, which decodes via UTF-8).

    If the name cannot be idna-encoded then we return None signalling that
    the name given should be skipped.
    """"""
    def idna_encode(name):
        """"""
        Borrowed wholesale from the Python Cryptography Project. It turns out
        that we can't just safely call `idna.encode`: it can explode for
        wildcard names. This avoids that problem.
        """"""
        import idna

        try:
            for prefix in [u'*.', u'.']:
                if name.startswith(prefix):
                    name = name[len(prefix):]
                    return prefix.encode('ascii') + idna.encode(name)
            return idna.encode(name)
        except idna.core.IDNAError:
            return None

    if ':' in name:
        return name

    name = idna_encode(name)
    if name is None:
        return None
    elif sys.version_info >= (3, 0):
        name = name.decode('utf-8')
    return name


def get_subj_alt_name(peer_cert):
    """"""
    Given an PyOpenSSL certificate, provides all the subject alternative names.
    """"""
    # Pass the cert to cryptography, which has much better APIs for this.
    if hasattr(peer_cert, ""to_cryptography""):
        cert = peer_cert.to_cryptography()
    else:
        # This is technically using private APIs, but should work across all
        # relevant versions before PyOpenSSL got a proper API for this.
        cert = _Certificate(openssl_backend, peer_cert._x509)

    # We want to find the SAN extension. Ask Cryptography to locate it (it's
    # faster than looping in Python)
    try:
        ext = cert.extensions.get_extension_for_class(
            x509.SubjectAlternativeName
        ).value
    except x509.ExtensionNotFound:
        # No such extension, return the empty list.
        return []
    except (x509.DuplicateExtension, UnsupportedExtension,
            x509.UnsupportedGeneralNameType, UnicodeError) as e:
        # A problem has been found with the quality of the certificate. Assume
        # no SAN field is present.
        log.warning(
            ""A problem was encountered with the certificate that prevented ""
            ""urllib3 from finding the SubjectAlternativeName field. This can ""
            ""affect certificate validation. The error was %s"",
            e,
        )
        return []

    # We want to return dNSName and iPAddress fields. We need to cast the IPs
    # back to strings because the match_hostname function wants them as
    # strings.
    # Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8
    # decoded. This is pretty frustrating, but that's what the standard library
    # does with certificates, and so we need to attempt to do the same.
    # We also want to skip over names which cannot be idna encoded.
    names = [
        ('DNS', name) for name in map(_dnsname_to_stdlib, ext.get_values_for_type(x509.DNSName))
        if name is not None
    ]
    names.extend(
        ('IP Address', str(name))
        for name in ext.get_values_for_type(x509.IPAddress)
    )

    return names


class WrappedSocket(object):
    '''API-compatibility wrapper for Python OpenSSL's Connection-class.

    Note: _makefile_refs, _drop() and _reuse() are needed for the garbage
    collector of pypy.
    '''

    def __init__(self, connection, socket, suppress_ragged_eofs=True):
        self.connection = connection
        self.socket = socket
        self.suppress_ragged_eofs = suppress_ragged_eofs
        self._makefile_refs = 0
        self._closed = False

    def fileno(self):
        return self.socket.fileno()

    # Copy-pasted from Python 3.5 source code
    def _decref_socketios(self):
        if self._makefile_refs > 0:
            self._makefile_refs -= 1
        if self._closed:
            self.close()

    def recv(self, *args, **kwargs):
        try:
            data = self.connection.recv(*args, **kwargs)
        except OpenSSL.SSL.SysCallError as e:
            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):
                return b''
            else:
                raise SocketError(str(e))
        except OpenSSL.SSL.ZeroReturnError:
            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
                return b''
            else:
                raise
        except OpenSSL.SSL.WantReadError:
            if not util.wait_for_read(self.socket, self.socket.gettimeout()):
                raise timeout('The read operation timed out')
            else:
                return self.recv(*args, **kwargs)
        else:
            return data

    def recv_into(self, *args, **kwargs):
        try:
            return self.connection.recv_into(*args, **kwargs)
        except OpenSSL.SSL.SysCallError as e:
            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):
                return 0
            else:
                raise SocketError(str(e))
        except OpenSSL.SSL.ZeroReturnError:
            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
                return 0
            else:
                raise
        except OpenSSL.SSL.WantReadError:
            if not util.wait_for_read(self.socket, self.socket.gettimeout()):
                raise timeout('The read operation timed out')
            else:
                return self.recv_into(*args, **kwargs)

    def settimeout(self, timeout):
        return self.socket.settimeout(timeout)

    def _send_until_done(self, data):
        while True:
            try:
                return self.connection.send(data)
            except OpenSSL.SSL.WantWriteError:
                if not util.wait_for_write(self.socket, self.socket.gettimeout()):
                    raise timeout()
                continue
            except OpenSSL.SSL.SysCallError as e:
                raise SocketError(str(e))

    def sendall(self, data):
        total_sent = 0
        while total_sent < len(data):
            sent = self._send_until_done(data[total_sent:total_sent + SSL_WRITE_BLOCKSIZE])
            total_sent += sent

    def shutdown(self):
        # FIXME rethrow compatible exceptions should we ever use this
        self.connection.shutdown()

    def close(self):
        if self._makefile_refs < 1:
            try:
                self._closed = True
                return self.connection.close()
            except OpenSSL.SSL.Error:
                return
        else:
            self._makefile_refs -= 1

    def getpeercert(self, binary_form=False):
        x509 = self.connection.get_peer_certificate()

        if not x509:
            return x509

        if binary_form:
            return OpenSSL.crypto.dump_certificate(
                OpenSSL.crypto.FILETYPE_ASN1,
                x509)

        return {
            'subject': (
                (('commonName', x509.get_subject().CN),),
            ),
            'subjectAltName': get_subj_alt_name(x509)
        }

    def _reuse(self):
        self._makefile_refs += 1

    def _drop(self):
        if self._makefile_refs < 1:
            self.close()
        else:
            self._makefile_refs -= 1


if _fileobject:  # Platform-specific: Python 2
    def makefile(self, mode, bufsize=-1):
        self._makefile_refs += 1
        return _fileobject(self, mode, bufsize, close=True)
else:  # Platform-specific: Python 3
    makefile = backport_makefile

WrappedSocket.makefile = makefile


class PyOpenSSLContext(object):
    """"""
    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible
    for translating the interface of the standard library ``SSLContext`` object
    to calls into PyOpenSSL.
    """"""
    def __init__(self, protocol):
        self.protocol = _openssl_versions[protocol]
        self._ctx = OpenSSL.SSL.Context(self.protocol)
        self._options = 0
        self.check_hostname = False

    @property
    def options(self):
        return self._options

    @options.setter
    def options(self, value):
        self._options = value
        self._ctx.set_options(value)

    @property
    def verify_mode(self):
        return _openssl_to_stdlib_verify[self._ctx.get_verify_mode()]

    @verify_mode.setter
    def verify_mode(self, value):
        self._ctx.set_verify(
            _stdlib_to_openssl_verify[value],
            _verify_callback
        )

    def set_default_verify_paths(self):
        self._ctx.set_default_verify_paths()

    def set_ciphers(self, ciphers):
        if isinstance(ciphers, six.text_type):
            ciphers = ciphers.encode('utf-8')
        self._ctx.set_cipher_list(ciphers)

    def load_verify_locations(self, cafile=None, capath=None, cadata=None):
        if cafile is not None:
            cafile = cafile.encode('utf-8')
        if capath is not None:
            capath = capath.encode('utf-8')
        self._ctx.load_verify_locations(cafile, capath)
        if cadata is not None:
            self._ctx.load_verify_locations(BytesIO(cadata))

    def load_cert_chain(self, certfile, keyfile=None, password=None):
        self._ctx.use_certificate_chain_file(certfile)
        if password is not None:
            self._ctx.set_passwd_cb(lambda max_length, prompt_twice, userdata: password)
        self._ctx.use_privatekey_file(keyfile or certfile)

    def wrap_socket(self, sock, server_side=False,
                    do_handshake_on_connect=True, suppress_ragged_eofs=True,
                    server_hostname=None):
        cnx = OpenSSL.SSL.Connection(self._ctx, sock)

        if isinstance(server_hostname, six.text_type):  # Platform-specific: Python 3
            server_hostname = server_hostname.encode('utf-8')

        if server_hostname is not None:
            cnx.set_tlsext_host_name(server_hostname)

        cnx.set_connect_state()

        while True:
            try:
                cnx.do_handshake()
            except OpenSSL.SSL.WantReadError:
                if not util.wait_for_read(sock, sock.gettimeout()):
                    raise timeout('select timed out')
                continue
            except OpenSSL.SSL.Error as e:
                raise ssl.SSLError('bad handshake: %r' % e)
            break

        return WrappedSocket(cnx, sock)


def _verify_callback(cnx, x509, err_no, err_depth, return_code):
    return err_no == 0",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,""""""" VAR VAR VAR-VAR VAR VAR 2. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 2. VAR, VAR VAR VAR VAR *VAR* VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR: * VAR (VAR VAR 16.0.0) * VAR (VAR 1.3.4, VAR VAR) * VAR (VAR 2.0, VAR VAR) VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR ``VAR`` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR``, VAR VAR:: VAR: VAR VAR.VAR.VAR VAR.VAR.VAR.VAR() VAR VAR: VAR VAR VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR VAR 2 (VAR `VAR VAR`VAR). VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR ``VAR.VAR.VAR.VAR`` VAR. .. VAR: VAR: .. VAR VAR: VAR: """""" VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR: VAR VAR.VAR VAR VAR VAR VAR:  VAR VAR(VAR): VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR:  VAR VAR VAR VAR VAR VAR:  VAR = VAR VAR ..VAR.VAR.VAR VAR VAR VAR VAR VAR VAR VAR ..VAR VAR VAR VAR VAR VAR .. VAR VAR VAR = ['VAR', 'VAR']  VAR = VAR  VAR = { VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR, } VAR VAR(VAR, 'VAR') VAR VAR(VAR.VAR, 'VAR'): VAR[VAR.VAR] = VAR.VAR.VAR VAR VAR(VAR, 'VAR') VAR VAR(VAR.VAR, 'VAR'): VAR[VAR.VAR] = VAR.VAR.VAR VAR: VAR.VAR({VAR.VAR: VAR.VAR.VAR}) VAR VAR: VAR VAR = { VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR + VAR.VAR.VAR, } VAR = VAR( (VAR, VAR) VAR VAR, VAR VAR VAR.VAR() )  VAR = 16384 VAR = VAR.VAR VAR = VAR.VAR.VAR VAR = VAR.VAR(VAR) VAR VAR(): 'VAR-VAR VAR VAR VAR-VAR VAR-VAR.' VAR() VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR VAR(): 'VAR VAR-VAR VAR :VAR:`VAR`.' VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR VAR(): """""" VAR VAR VAR'VAR VAR-VAR VAR VAR VAR VAR. VAR `VAR` VAR VAR VAR VAR VAR. """"""  VAR VAR.VAR.VAR VAR VAR VAR VAR(VAR, ""VAR"", VAR) VAR VAR: VAR VAR(""'VAR' VAR VAR VAR VAR. "" ""VAR VAR VAR VAR.3.4 VAR VAR."")   VAR VAR.VAR VAR VAR VAR = VAR() VAR VAR(VAR, ""VAR"", VAR) VAR VAR: VAR VAR(""'VAR' VAR VAR VAR VAR. "" ""VAR VAR VAR VAR.14 VAR VAR."") VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR. VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR 3 VAR VAR VAR VAR VAR VAR VAR VAR VAR-8 (VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR-8). VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR `VAR.VAR`: VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR. """""" VAR VAR VAR: VAR VAR VAR [VAR'*.', VAR'.']: VAR VAR.VAR(VAR): VAR = VAR[VAR(VAR):] VAR VAR.VAR('VAR') + VAR.VAR(VAR) VAR VAR.VAR(VAR) VAR VAR.VAR.VAR: VAR VAR VAR ':' VAR VAR: VAR VAR VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR VAR VAR.VAR >= (3, 0): VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR(VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. """"""  VAR VAR(VAR, ""VAR""): VAR = VAR.VAR() VAR:   VAR = VAR(VAR, VAR.VAR)   VAR: VAR = VAR.VAR.VAR( VAR.VAR ).VAR VAR VAR.VAR:  VAR [] VAR (VAR.VAR, VAR, VAR.VAR, VAR) VAR VAR:   VAR.VAR( ""VAR VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR VAR. VAR VAR "" ""VAR VAR VAR. VAR VAR VAR %VAR"", VAR, ) VAR []        VAR = [ ('VAR', VAR) VAR VAR VAR VAR(VAR, VAR.VAR(VAR.VAR)) VAR VAR VAR VAR VAR ] VAR.VAR( ('VAR VAR', VAR(VAR)) VAR VAR VAR VAR.VAR(VAR.VAR) ) VAR VAR VAR VAR(VAR): '''VAR-VAR VAR VAR VAR VAR'VAR VAR-VAR. VAR: VAR, VAR() VAR VAR() VAR VAR VAR VAR VAR VAR VAR VAR. ''' VAR VAR(VAR, VAR, VAR, VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR VAR(VAR): VAR VAR.VAR.VAR()  VAR VAR(VAR): VAR VAR.VAR > 0: VAR.VAR -= 1 VAR VAR.VAR: VAR.VAR() VAR VAR(VAR, *VAR, **VAR): VAR: VAR = VAR.VAR.VAR(*VAR, **VAR) VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR == (-1, 'VAR VAR'): VAR VAR'' VAR: VAR VAR(VAR(VAR)) VAR VAR.VAR.VAR: VAR VAR.VAR.VAR() == VAR.VAR.VAR: VAR VAR'' VAR: VAR VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR('VAR VAR VAR VAR VAR') VAR: VAR VAR.VAR(*VAR, **VAR) VAR: VAR VAR VAR VAR(VAR, *VAR, **VAR): VAR: VAR VAR.VAR.VAR(*VAR, **VAR) VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR == (-1, 'VAR VAR'): VAR 0 VAR: VAR VAR(VAR(VAR)) VAR VAR.VAR.VAR: VAR VAR.VAR.VAR() == VAR.VAR.VAR: VAR 0 VAR: VAR VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR('VAR VAR VAR VAR VAR') VAR: VAR VAR.VAR(*VAR, **VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR(VAR) VAR VAR(VAR, VAR): VAR VAR: VAR: VAR VAR.VAR.VAR(VAR) VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR() VAR VAR VAR.VAR.VAR VAR VAR: VAR VAR(VAR(VAR)) VAR VAR(VAR, VAR): VAR = 0 VAR VAR < VAR(VAR): VAR = VAR.VAR(VAR[VAR:VAR + VAR]) VAR += VAR VAR VAR(VAR):  VAR.VAR.VAR() VAR VAR(VAR): VAR VAR.VAR < 1: VAR: VAR.VAR = VAR VAR VAR.VAR.VAR() VAR VAR.VAR.VAR: VAR VAR: VAR.VAR -= 1 VAR VAR(VAR, VAR=VAR): VAR = VAR.VAR.VAR() VAR VAR VAR: VAR VAR VAR VAR: VAR VAR.VAR.VAR( VAR.VAR.VAR, VAR) VAR { 'VAR': ( (('VAR', VAR.VAR().VAR),), ), 'VAR': VAR(VAR) } VAR VAR(VAR): VAR.VAR += 1 VAR VAR(VAR): VAR VAR.VAR < 1: VAR.VAR() VAR: VAR.VAR -= 1 VAR VAR:  VAR VAR(VAR, VAR, VAR=-1): VAR.VAR += 1 VAR VAR(VAR, VAR, VAR, VAR=VAR) VAR:  VAR = VAR VAR.VAR = VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = VAR[VAR] VAR.VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR = 0 VAR.VAR = VAR @VAR VAR VAR(VAR): VAR VAR.VAR @VAR.VAR VAR VAR(VAR, VAR): VAR.VAR = VAR VAR.VAR.VAR(VAR) @VAR VAR VAR(VAR): VAR VAR[VAR.VAR.VAR()] @VAR.VAR VAR VAR(VAR, VAR): VAR.VAR.VAR( VAR[VAR], VAR ) VAR VAR(VAR): VAR.VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR, VAR.VAR): VAR = VAR.VAR('VAR-8') VAR.VAR.VAR(VAR) VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR VAR VAR VAR VAR: VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR VAR: VAR = VAR.VAR('VAR-8') VAR.VAR.VAR(VAR, VAR) VAR VAR VAR VAR VAR: VAR.VAR.VAR(VAR(VAR)) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): VAR.VAR.VAR(VAR) VAR VAR VAR VAR VAR: VAR.VAR.VAR(VAR VAR, VAR, VAR: VAR) VAR.VAR.VAR(VAR VAR VAR) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR = VAR.VAR.VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR.VAR):  VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR VAR: VAR.VAR(VAR) VAR.VAR() VAR VAR: VAR: VAR.VAR() VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR, VAR.VAR()): VAR VAR('VAR VAR VAR') VAR VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR('VAR VAR: %VAR' % VAR) VAR VAR VAR(VAR, VAR) VAR VAR(VAR, VAR, VAR, VAR, VAR): VAR VAR == 0 ",1
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,src/urllib3/filepost.py,"from __future__ import absolute_import
import binascii
import codecs
import os

from io import BytesIO

from .packages import six
from .packages.six import b
from .fields import RequestField

writer = codecs.lookup('utf-8')[3]


def choose_boundary():
    """"""
    Our embarrassingly-simple replacement for mimetools.choose_boundary.
    """"""
    boundary = binascii.hexlify(os.urandom(16))
    if six.PY3:
        boundary = boundary.decode('ascii')
    return boundary


def iter_field_objects(fields):
    """"""
    Iterate over fields.

    Supports list of (k, v) tuples and dicts, and lists of
    :class:`~urllib3.fields.RequestField`.

    """"""
    if isinstance(fields, dict):
        i = six.iteritems(fields)
    else:
        i = iter(fields)

    for field in i:
        if isinstance(field, RequestField):
            yield field
        else:
            yield RequestField.from_tuples(*field)


def iter_fields(fields):
    """"""
    .. deprecated:: 1.6

    Iterate over fields.

    The addition of :class:`~urllib3.fields.RequestField` makes this function
    obsolete. Instead, use :func:`iter_field_objects`, which returns
    :class:`~urllib3.fields.RequestField` objects.

    Supports list of (k, v) tuples and dicts.
    """"""
    if isinstance(fields, dict):
        return ((k, v) for k, v in six.iteritems(fields))

    return ((k, v) for k, v in fields)


def encode_multipart_formdata(fields, boundary=None):
    """"""
    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.

    :param fields:
        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).

    :param boundary:
        If not specified, then a random boundary will be generated using
        :func:`urllib3.filepost.choose_boundary`.
    """"""
    body = BytesIO()
    if boundary is None:
        boundary = choose_boundary()

    for field in iter_field_objects(fields):
        body.write(b('--%s\r\n' % (boundary)))

        writer(body).write(field.render_headers())
        data = field.data

        if isinstance(data, int):
            data = str(data)  # Backwards compatibility

        if isinstance(data, six.text_type):
            writer(body).write(data)
        else:
            body.write(data)

        body.write(b'\r\n')

    body.write(b('--%s--\r\n' % (boundary)))

    content_type = str('multipart/form-data; boundary=%s' % boundary)

    return body.getvalue(), content_type",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR.VAR VAR VAR VAR .VAR VAR VAR VAR = VAR.VAR('VAR-8')[3] VAR VAR(): """""" VAR VAR-VAR VAR VAR VAR.VAR. """""" VAR = VAR.VAR(VAR.VAR(16)) VAR VAR.VAR: VAR = VAR.VAR('VAR') VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR, VAR VAR VAR :VAR:`~VAR.VAR.VAR`. """""" VAR VAR(VAR, VAR): VAR = VAR.VAR(VAR) VAR: VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR.VAR(*VAR) VAR VAR(VAR): """""" .. VAR:: 1.6 VAR VAR VAR. VAR VAR VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR VAR. VAR, VAR :VAR:`VAR`, VAR VAR :VAR:`~VAR.VAR.VAR` VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR ((VAR, VAR) VAR VAR, VAR VAR VAR.VAR(VAR)) VAR ((VAR, VAR) VAR VAR, VAR VAR VAR) VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR ``VAR`` VAR VAR VAR/VAR-VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR (VAR, :VAR:`~VAR.VAR.VAR`). :VAR VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR`. """""" VAR = VAR() VAR VAR VAR VAR: VAR = VAR() VAR VAR VAR VAR(VAR): VAR.VAR(VAR('--%VAR\VAR\VAR' % (VAR))) VAR(VAR).VAR(VAR.VAR()) VAR = VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR)  VAR VAR(VAR, VAR.VAR): VAR(VAR).VAR(VAR) VAR: VAR.VAR(VAR) VAR.VAR(VAR'\VAR\VAR') VAR.VAR(VAR('--%VAR--\VAR\VAR' % (VAR))) VAR = VAR('VAR/VAR-VAR; VAR=%VAR' % VAR) VAR VAR.VAR(), VAR ",1
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,src/urllib3/response.py,"from __future__ import absolute_import
from contextlib import contextmanager
import zlib
import io
import logging
from socket import timeout as SocketTimeout
from socket import error as SocketError

from ._collections import HTTPHeaderDict
from .exceptions import (
    BodyNotHttplibCompatible, ProtocolError, DecodeError, ReadTimeoutError,
    ResponseNotChunked, IncompleteRead, InvalidHeader
)
from .packages.six import string_types as basestring, PY3
from .packages.six.moves import http_client as httplib
from .connection import HTTPException, BaseSSLError
from .util.response import is_fp_closed, is_response_to_head

log = logging.getLogger(__name__)


class DeflateDecoder(object):

    def __init__(self):
        self._first_try = True
        self._data = b''
        self._obj = zlib.decompressobj()

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        if not data:
            return data

        if not self._first_try:
            return self._obj.decompress(data)

        self._data += data
        try:
            decompressed = self._obj.decompress(data)
            if decompressed:
                self._first_try = False
                self._data = None
            return decompressed
        except zlib.error:
            self._first_try = False
            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
            try:
                return self.decompress(self._data)
            finally:
                self._data = None


class GzipDecoderState(object):

    FIRST_MEMBER = 0
    OTHER_MEMBERS = 1
    SWALLOW_DATA = 2


class GzipDecoder(object):

    def __init__(self):
        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
        self._state = GzipDecoderState.FIRST_MEMBER

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        ret = bytearray()
        if self._state == GzipDecoderState.SWALLOW_DATA or not data:
            return bytes(ret)
        while True:
            try:
                ret += self._obj.decompress(data)
            except zlib.error:
                previous_state = self._state
                # Ignore data after the first error
                self._state = GzipDecoderState.SWALLOW_DATA
                if previous_state == GzipDecoderState.OTHER_MEMBERS:
                    # Allow trailing garbage acceptable in other gzip clients
                    return bytes(ret)
                raise
            data = self._obj.unused_data
            if not data:
                return bytes(ret)
            self._state = GzipDecoderState.OTHER_MEMBERS
            self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)


class MultiDecoder(object):
    """"""
    From RFC7231:
        If one or more encodings have been applied to a representation, the
        sender that applied the encodings MUST generate a Content-Encoding
        header field that lists the content codings in the order in which
        they were applied.
    """"""

    def __init__(self, modes):
        self._decoders = [_get_decoder(m.strip()) for m in modes.split(',')]

    def flush(self):
        return self._decoders[0].flush()

    def decompress(self, data):
        for d in reversed(self._decoders):
            data = d.decompress(data)
        return data


def _get_decoder(mode):
    if ',' in mode:
        return MultiDecoder(mode)

    if mode == 'gzip':
        return GzipDecoder()

    return DeflateDecoder()


class HTTPResponse(io.IOBase):
    """"""
    HTTP Response container.

    Backwards-compatible to httplib's HTTPResponse but the response ``body`` is
    loaded and decoded on-demand when the ``data`` property is accessed.  This
    class is also compatible with the Python standard library's :mod:`io`
    module, and can hence be treated as a readable object in the context of that
    framework.

    Extra parameters for behaviour not present in httplib.HTTPResponse:

    :param preload_content:
        If True, the response's body will be preloaded during construction.

    :param decode_content:
        If True, will attempt to decode the body based on the
        'content-encoding' header.

    :param original_response:
        When this HTTPResponse wrapper is generated from an httplib.HTTPResponse
        object, it's convenient to include the original for debug purposes. It's
        otherwise unused.

    :param retries:
        The retries contains the last :class:`~urllib3.util.retry.Retry` that
        was used during the request.

    :param enforce_content_length:
        Enforce content length checking. Body returned by server must match
        value of Content-Length header, if present. Otherwise, raise error.
    """"""

    CONTENT_DECODERS = ['gzip', 'deflate']
    REDIRECT_STATUSES = [301, 302, 303, 307, 308]

    def __init__(self, body='', headers=None, status=0, version=0, reason=None,
                 strict=0, preload_content=True, decode_content=True,
                 original_response=None, pool=None, connection=None, msg=None,
                 retries=None, enforce_content_length=False,
                 request_method=None, request_url=None):

        if isinstance(headers, HTTPHeaderDict):
            self.headers = headers
        else:
            self.headers = HTTPHeaderDict(headers)
        self.status = status
        self.version = version
        self.reason = reason
        self.strict = strict
        self.decode_content = decode_content
        self.retries = retries
        self.enforce_content_length = enforce_content_length

        self._decoder = None
        self._body = None
        self._fp = None
        self._original_response = original_response
        self._fp_bytes_read = 0
        self.msg = msg
        self._request_url = request_url

        if body and isinstance(body, (basestring, bytes)):
            self._body = body

        self._pool = pool
        self._connection = connection

        if hasattr(body, 'read'):
            self._fp = body

        # Are we using the chunked-style of transfer encoding?
        self.chunked = False
        self.chunk_left = None
        tr_enc = self.headers.get('transfer-encoding', '').lower()
        # Don't incur the penalty of creating a list and then discarding it
        encodings = (enc.strip() for enc in tr_enc.split("",""))
        if ""chunked"" in encodings:
            self.chunked = True

        # Determine length of response
        self.length_remaining = self._init_length(request_method)

        # If requested, preload the body.
        if preload_content and not self._body:
            self._body = self.read(decode_content=decode_content)

    def get_redirect_location(self):
        """"""
        Should we redirect and where to?

        :returns: Truthy redirect location string if we got a redirect status
            code and valid location. ``None`` if redirect status and no
            location. ``False`` if not a redirect status code.
        """"""
        if self.status in self.REDIRECT_STATUSES:
            return self.headers.get('location')

        return False

    def release_conn(self):
        if not self._pool or not self._connection:
            return

        self._pool._put_conn(self._connection)
        self._connection = None

    @property
    def data(self):
        # For backwords-compat with earlier urllib3 0.4 and earlier.
        if self._body:
            return self._body

        if self._fp:
            return self.read(cache_content=True)

    @property
    def connection(self):
        return self._connection

    def isclosed(self):
        return is_fp_closed(self._fp)

    def tell(self):
        """"""
        Obtain the number of bytes pulled over the wire so far. May differ from
        the amount of content returned by :meth:``HTTPResponse.read`` if bytes
        are encoded on the wire (e.g, compressed).
        """"""
        return self._fp_bytes_read

    def _init_length(self, request_method):
        """"""
        Set initial length value for Response content if available.
        """"""
        length = self.headers.get('content-length')

        if length is not None:
            if self.chunked:
                # This Response will fail with an IncompleteRead if it can't be
                # received as chunked. This method falls back to attempt reading
                # the response before raising an exception.
                log.warning(""Received response with both Content-Length and ""
                            ""Transfer-Encoding set. This is expressly forbidden ""
                            ""by RFC 7230 sec 3.3.2. Ignoring Content-Length and ""
                            ""attempting to process response as Transfer-Encoding: ""
                            ""chunked."")
                return None

            try:
                # RFC 7230 section 3.3.2 specifies multiple content lengths can
                # be sent in a single Content-Length header
                # (e.g. Content-Length: 42, 42). This line ensures the values
                # are all valid ints and that as long as the `set` length is 1,
                # all values are the same. Otherwise, the header is invalid.
                lengths = set([int(val) for val in length.split(',')])
                if len(lengths) > 1:
                    raise InvalidHeader(""Content-Length contained multiple ""
                                        ""unmatching values (%s)"" % length)
                length = lengths.pop()
            except ValueError:
                length = None
            else:
                if length < 0:
                    length = None

        # Convert status to int for comparison
        # In some cases, httplib returns a status of ""_UNKNOWN""
        try:
            status = int(self.status)
        except ValueError:
            status = 0

        # Check for responses that shouldn't include a body
        if status in (204, 304) or 100 <= status < 200 or request_method == 'HEAD':
            length = 0

        return length

    def _init_decoder(self):
        """"""
        Set-up the _decoder attribute if necessary.
        """"""
        # Note: content-encoding value should be case-insensitive, per RFC 7230
        # Section 3.2
        content_encoding = self.headers.get('content-encoding', '').lower()
        if self._decoder is None:
            if content_encoding in self.CONTENT_DECODERS:
                self._decoder = _get_decoder(content_encoding)
            elif ',' in content_encoding:
                encodings = [
                    e.strip() for e in content_encoding.split(',')
                    if e.strip() in self.CONTENT_DECODERS]
                if len(encodings):
                    self._decoder = _get_decoder(content_encoding)

    def _decode(self, data, decode_content, flush_decoder):
        """"""
        Decode the data passed in and potentially flush the decoder.
        """"""
        try:
            if decode_content and self._decoder:
                data = self._decoder.decompress(data)
        except (IOError, zlib.error) as e:
            content_encoding = self.headers.get('content-encoding', '').lower()
            raise DecodeError(
                ""Received response with content-encoding: %s, but ""
                ""failed to decode it."" % content_encoding, e)

        if flush_decoder and decode_content:
            data += self._flush_decoder()

        return data

    def _flush_decoder(self):
        """"""
        Flushes the decoder. Should only be called if the decoder is actually
        being used.
        """"""
        if self._decoder:
            buf = self._decoder.decompress(b'')
            return buf + self._decoder.flush()

        return b''

    @contextmanager
    def _error_catcher(self):
        """"""
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.

        On exit, release the connection back to the pool.
        """"""
        clean_exit = False

        try:
            try:
                yield

            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if 'read operation timed out' not in str(e):  # Defensive:
                    # This shouldn't happen but just in case we're missing an edge
                    # case, let's avoid swallowing SSL errors.
                    raise

                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
                raise ProtocolError('Connection broken: %r' % e, e)

            # If no exception is thrown, we should avoid cleaning up
            # unnecessarily.
            clean_exit = True
        finally:
            # If we didn't terminate cleanly, we need to throw away our
            # connection.
            if not clean_exit:
                # The response may not be closed but we're not going to use it
                # anymore so close it now to ensure that the connection is
                # released back to the pool.
                if self._original_response:
                    self._original_response.close()

                # Closing the response may not actually be sufficient to close
                # everything, so if we have a hold of the connection close that
                # too.
                if self._connection:
                    self._connection.close()

            # If we hold the original response but it's closed now, we should
            # return the connection back to the pool.
            if self._original_response and self._original_response.isclosed():
                self.release_conn()

    def read(self, amt=None, decode_content=None, cache_content=False):
        """"""
        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional
        parameters: ``decode_content`` and ``cache_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.

        :param cache_content:
            If True, will save the returned data such that the same result is
            returned despite of the state of the underlying file object. This
            is useful if you want the ``.data`` property to continue working
            after having ``.read()`` the file object. (Overridden if ``amt`` is
            set.)
        """"""
        self._init_decoder()
        if decode_content is None:
            decode_content = self.decode_content

        if self._fp is None:
            return

        flush_decoder = False
        data = None

        with self._error_catcher():
            if amt is None:
                # cStringIO doesn't like amt=None
                data = self._fp.read()
                flush_decoder = True
            else:
                cache_content = False
                data = self._fp.read(amt)
                if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.
                    # Close the connection when no data is returned
                    #
                    # This is redundant to what httplib/http.client _should_
                    # already do.  However, versions of python released before
                    # December 15, 2012 (http://bugs.python.org/issue16298) do
                    # not properly close the connection in all cases. There is
                    # no harm in redundantly calling close.
                    self._fp.close()
                    flush_decoder = True
                    if self.enforce_content_length and self.length_remaining not in (0, None):
                        # This is an edge case that httplib failed to cover due
                        # to concerns of backward compatibility. We're
                        # addressing it here to make sure IncompleteRead is
                        # raised during streaming, so all calls with incorrect
                        # Content-Length are caught.
                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)

        if data:
            self._fp_bytes_read += len(data)
            if self.length_remaining is not None:
                self.length_remaining -= len(data)

            data = self._decode(data, decode_content, flush_decoder)

            if cache_content:
                self._body = data

        return data

    def stream(self, amt=2**16, decode_content=None):
        """"""
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.

        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        if self.chunked and self.supports_chunked_reads():
            for line in self.read_chunked(amt, decode_content=decode_content):
                yield line
        else:
            while not is_fp_closed(self._fp):
                data = self.read(amt=amt, decode_content=decode_content)

                if data:
                    yield data

    @classmethod
    def from_httplib(ResponseCls, r, **response_kw):
        """"""
        Given an :class:`httplib.HTTPResponse` instance ``r``, return a
        corresponding :class:`urllib3.response.HTTPResponse` object.

        Remaining parameters are passed to the HTTPResponse constructor, along
        with ``original_response=r``.
        """"""
        headers = r.msg

        if not isinstance(headers, HTTPHeaderDict):
            if PY3:  # Python 3
                headers = HTTPHeaderDict(headers.items())
            else:  # Python 2
                headers = HTTPHeaderDict.from_httplib(headers)

        # HTTPResponse objects in Python 3 don't have a .strict attribute
        strict = getattr(r, 'strict', 0)
        resp = ResponseCls(body=r,
                           headers=headers,
                           status=r.status,
                           version=r.version,
                           reason=r.reason,
                           strict=strict,
                           original_response=r,
                           **response_kw)
        return resp

    # Backwards-compatibility methods for httplib.HTTPResponse
    def getheaders(self):
        return self.headers

    def getheader(self, name, default=None):
        return self.headers.get(name, default)

    # Backwards compatibility for http.cookiejar
    def info(self):
        return self.headers

    # Overrides from io.IOBase
    def close(self):
        if not self.closed:
            self._fp.close()

        if self._connection:
            self._connection.close()

    @property
    def closed(self):
        if self._fp is None:
            return True
        elif hasattr(self._fp, 'isclosed'):
            return self._fp.isclosed()
        elif hasattr(self._fp, 'closed'):
            return self._fp.closed
        else:
            return True

    def fileno(self):
        if self._fp is None:
            raise IOError(""HTTPResponse has no file to get a fileno from"")
        elif hasattr(self._fp, ""fileno""):
            return self._fp.fileno()
        else:
            raise IOError(""The file-like object this HTTPResponse is wrapped ""
                          ""around has no file descriptor"")

    def flush(self):
        if self._fp is not None and hasattr(self._fp, 'flush'):
            return self._fp.flush()

    def readable(self):
        # This method is required for `io` module compatibility.
        return True

    def readinto(self, b):
        # This method is required for `io` module compatibility.
        temp = self.read(len(b))
        if len(temp) == 0:
            return 0
        else:
            b[:len(temp)] = temp
            return len(temp)

    def supports_chunked_reads(self):
        """"""
        Checks if the underlying file-like object looks like a
        httplib.HTTPResponse object. We do this by testing for the fp
        attribute. If it is present we assume it returns raw chunks as
        processed by read_chunked().
        """"""
        return hasattr(self._fp, 'fp')

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b';', 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
            raise httplib.IncompleteRead(line)

    def _handle_chunk(self, amt):
        returned_chunk = None
        if amt is None:
            chunk = self._fp._safe_read(self.chunk_left)
            returned_chunk = chunk
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        elif amt < self.chunk_left:
            value = self._fp._safe_read(amt)
            self.chunk_left = self.chunk_left - amt
            returned_chunk = value
        elif amt == self.chunk_left:
            value = self._fp._safe_read(amt)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
            returned_chunk = value
        else:  # amt > self.chunk_left
            returned_chunk = self._fp._safe_read(self.chunk_left)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        return returned_chunk

    def read_chunked(self, amt=None, decode_content=None):
        """"""
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                ""Response is not chunked. ""
                ""Header 'transfer-encoding: chunked' is missing."")
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                ""Body should be httplib.HTTPResponse like. ""
                ""It should have have an fp attribute which returns raw chunks."")

        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return

            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return

            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(chunk, decode_content=decode_content,
                                       flush_decoder=False)
                if decoded:
                    yield decoded

            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded

            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b'\r\n':
                    break

            # We read everything; close the ""file"".
            if self._original_response:
                self._original_response.close()

    def geturl(self):
        """"""
        Returns the URL that was the source of this response.
        If the request that generated this response redirected, this method
        will return the final redirect location.
        """"""
        if self.retries is not None and len(self.retries.history):
            return self.retries.history[-1].redirect_location
        else:
            return self._request_url",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR ) VAR .VAR.VAR VAR VAR VAR VAR, VAR VAR .VAR.VAR.VAR VAR VAR VAR VAR VAR .VAR VAR VAR, VAR VAR .VAR.VAR VAR VAR, VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR) VAR.VAR += VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR: VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR VAR.VAR = VAR.VAR(-VAR.VAR) VAR: VAR VAR.VAR(VAR.VAR) VAR: VAR.VAR = VAR VAR VAR(VAR): VAR = 0 VAR = 1 VAR = 2 VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR.VAR = VAR.VAR VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR = VAR() VAR VAR.VAR == VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR VAR: VAR: VAR += VAR.VAR.VAR(VAR) VAR VAR.VAR: VAR = VAR.VAR  VAR.VAR = VAR.VAR VAR VAR == VAR.VAR:  VAR VAR(VAR) VAR VAR = VAR.VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR.VAR = VAR.VAR VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR VAR(VAR): """""" VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = [VAR(VAR.VAR()) VAR VAR VAR VAR.VAR(',')] VAR VAR(VAR): VAR VAR.VAR[0].VAR() VAR VAR(VAR, VAR): VAR VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR ',' VAR VAR: VAR VAR(VAR) VAR VAR == 'VAR': VAR VAR() VAR VAR() VAR VAR(VAR.VAR): """""" VAR VAR VAR. VAR-VAR VAR VAR'VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR-VAR VAR VAR ``VAR`` VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR :VAR:`VAR` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR.VAR: :VAR VAR: VAR VAR, VAR VAR'VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR'VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR, VAR VAR. VAR, VAR VAR. """""" VAR = ['VAR', 'VAR'] VAR = [301, 302, 303, 307, 308] VAR VAR(VAR, VAR='', VAR=VAR, VAR=0, VAR=0, VAR=VAR, VAR=0, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR VAR(VAR, VAR): VAR.VAR = VAR VAR: VAR.VAR = VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR(VAR, (VAR, VAR)): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, 'VAR'): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR VAR = VAR.VAR.VAR('VAR-VAR', '').VAR()  VAR = (VAR.VAR() VAR VAR VAR VAR.VAR("","")) VAR ""VAR"" VAR VAR: VAR.VAR = VAR  VAR.VAR = VAR.VAR(VAR)  VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR.VAR(VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR? :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR.VAR('VAR') VAR VAR VAR VAR(VAR): VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR.VAR) VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR VAR.VAR: VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR(VAR=VAR) @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:``VAR.VAR`` VAR VAR VAR VAR VAR VAR VAR (VAR.VAR, VAR). """""" VAR VAR.VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR') VAR VAR VAR VAR VAR: VAR VAR.VAR:    VAR.VAR(""VAR VAR VAR VAR VAR-VAR VAR "" ""VAR-VAR VAR. VAR VAR VAR VAR "" ""VAR VAR 7230 VAR 3.3.2. VAR VAR-VAR VAR "" ""VAR VAR VAR VAR VAR VAR-VAR: "" ""VAR."") VAR VAR VAR:      VAR = VAR([VAR(VAR) VAR VAR VAR VAR.VAR(',')]) VAR VAR(VAR) > 1: VAR VAR(""VAR-VAR VAR VAR "" ""VAR VAR (%VAR)"" % VAR) VAR = VAR.VAR() VAR VAR: VAR = VAR VAR: VAR VAR < 0: VAR = VAR   VAR: VAR = VAR(VAR.VAR) VAR VAR: VAR = 0  VAR VAR VAR (204, 304) VAR 100 <= VAR < 200 VAR VAR == 'VAR': VAR = 0 VAR VAR VAR VAR(VAR): """""" VAR-VAR VAR VAR VAR VAR VAR. """"""   VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR.VAR VAR VAR: VAR VAR VAR VAR.VAR: VAR.VAR = VAR(VAR) VAR ',' VAR VAR: VAR = [ VAR.VAR() VAR VAR VAR VAR.VAR(',') VAR VAR.VAR() VAR VAR.VAR] VAR VAR(VAR): VAR.VAR = VAR(VAR) VAR VAR(VAR, VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR: VAR VAR VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR (VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR( ""VAR VAR VAR VAR-VAR: %VAR, VAR "" ""VAR VAR VAR VAR."" % VAR, VAR) VAR VAR VAR VAR: VAR += VAR.VAR() VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR'') VAR VAR + VAR.VAR.VAR() VAR VAR'' @VAR VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR, VAR VAR-VAR VAR VAR, VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR VAR: VAR: VAR VAR VAR:   VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR VAR VAR VAR:  VAR 'VAR VAR VAR VAR' VAR VAR VAR(VAR):    VAR VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR (VAR, VAR) VAR VAR:  VAR VAR('VAR VAR: %VAR' % VAR, VAR)   VAR = VAR VAR:   VAR VAR VAR:    VAR VAR.VAR: VAR.VAR.VAR()    VAR VAR.VAR: VAR.VAR.VAR()   VAR VAR.VAR VAR VAR.VAR.VAR(): VAR.VAR() VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR`` VAR ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR ``.VAR`` VAR VAR VAR VAR VAR VAR ``.VAR()`` VAR VAR VAR. (VAR VAR ``VAR`` VAR VAR.) """""" VAR.VAR() VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR.VAR VAR VAR: VAR VAR = VAR VAR = VAR VAR VAR.VAR(): VAR VAR VAR VAR:  VAR = VAR.VAR.VAR() VAR = VAR VAR: VAR = VAR VAR = VAR.VAR.VAR(VAR) VAR VAR != 0 VAR VAR VAR:         VAR.VAR.VAR() VAR = VAR VAR VAR.VAR VAR VAR.VAR VAR VAR (0, VAR):      VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR += VAR(VAR) VAR VAR.VAR VAR VAR VAR: VAR.VAR -= VAR(VAR) VAR = VAR.VAR(VAR, VAR, VAR) VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=2**16, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR() VAR. VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR VAR.VAR VAR VAR.VAR(): VAR VAR VAR VAR.VAR(VAR, VAR=VAR): VAR VAR VAR: VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR=VAR, VAR=VAR) VAR VAR: VAR VAR @VAR VAR VAR(VAR, VAR, **VAR): """""" VAR VAR :VAR:`VAR.VAR` VAR ``VAR``, VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR ``VAR=VAR``. """""" VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR VAR:  VAR = VAR(VAR.VAR()) VAR:  VAR = VAR.VAR(VAR)  VAR = VAR(VAR, 'VAR', 0) VAR = VAR(VAR=VAR, VAR=VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR, **VAR) VAR VAR  VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR, VAR, VAR=VAR): VAR VAR.VAR.VAR(VAR, VAR)  VAR VAR(VAR): VAR VAR.VAR  VAR VAR(VAR): VAR VAR VAR.VAR: VAR.VAR.VAR() VAR VAR.VAR: VAR.VAR.VAR() @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR VAR: VAR VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR: VAR VAR(""VAR VAR-VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR"") VAR VAR(VAR): VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR):  VAR VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR(VAR(VAR)) VAR VAR(VAR) == 0: VAR 0 VAR: VAR[:VAR(VAR)] = VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR.VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR(). """""" VAR VAR(VAR.VAR, 'VAR') VAR VAR(VAR):   VAR VAR.VAR VAR VAR VAR: VAR VAR = VAR.VAR.VAR.VAR() VAR = VAR.VAR(VAR';', 1)[0] VAR: VAR.VAR = VAR(VAR, 16) VAR VAR:  VAR.VAR() VAR VAR.VAR(VAR) VAR VAR(VAR, VAR): VAR = VAR VAR VAR VAR VAR: VAR = VAR.VAR.VAR(VAR.VAR) VAR = VAR VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR < VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR = VAR.VAR - VAR VAR = VAR VAR VAR == VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR = VAR VAR:  VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR.VAR()  VAR VAR VAR.VAR: VAR VAR( ""VAR VAR VAR VAR. "" ""VAR 'VAR-VAR: VAR' VAR VAR."") VAR VAR VAR.VAR(): VAR VAR( ""VAR VAR VAR VAR.VAR VAR. "" ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR.VAR():  VAR VAR.VAR VAR VAR(VAR.VAR): VAR.VAR.VAR() VAR   VAR VAR.VAR.VAR VAR VAR: VAR VAR VAR: VAR.VAR() VAR VAR.VAR == 0: VAR VAR = VAR.VAR(VAR) VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR: VAR VAR VAR VAR:    VAR = VAR.VAR() VAR VAR:  VAR VAR  VAR VAR: VAR = VAR.VAR.VAR.VAR() VAR VAR VAR:  VAR VAR VAR == VAR'\VAR\VAR': VAR  VAR VAR.VAR: VAR.VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR.VAR): VAR VAR.VAR.VAR[-1].VAR VAR: VAR VAR.VAR ",1
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/test_response.py,"import socket
import zlib

from io import BytesIO, BufferedReader

import pytest
import mock

from urllib3.response import HTTPResponse
from urllib3.exceptions import (
    DecodeError, ResponseNotChunked, ProtocolError, InvalidHeader
)
from urllib3.packages.six.moves import http_client as httplib
from urllib3.util.retry import Retry, RequestHistory
from urllib3.util.response import is_fp_closed

from base64 import b64decode

# A known random (i.e, not-too-compressible) payload generated with:
#    """".join(random.choice(string.printable) for i in xrange(512))
#    .encode(""zlib"").encode(""base64"")
# Randomness in tests == bad, and fixing a seed may not be sufficient.
ZLIB_PAYLOAD = b64decode(b""""""\
eJwFweuaoQAAANDfineQhiKLUiaiCzvuTEmNNlJGiL5QhnGpZ99z8luQfe1AHoMioB+QSWHQu/L+
lzd7W5CipqYmeVTBjdgSATdg4l4Z2zhikbuF+EKn69Q0DTpdmNJz8S33odfJoVEexw/l2SS9nFdi
pis7KOwXzfSqarSo9uJYgbDGrs1VNnQpT9f8zAorhYCEZronZQF9DuDFfNK3Hecc+WHLnZLQptwk
nufw8S9I43sEwxsT71BiqedHo0QeIrFE01F/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/nNvDGKZ
Khe5TF36JbnKVjdcL1EUNpwrWVfQpFYJ/WWm2b74qNeSZeQv5/xBhRdOmKTJFYgO96PwrHBlsnLn
a3l0LwJsloWpMbzByU5WLbRE6X5INFqjQOtIwYz5BAlhkn+kVqJvWM5vBlfrwP42ifonM5yF4ciJ
auHVks62997mNGOsM7WXNG3P98dBHPo2NhbTvHleL0BI5dus2JY81MUOnK3SGWLH8HeWPa1t5KcW
S5moAj5HexY/g/F8TctpxwsvyZp38dXeLDjSQvEQIkF7XR3YXbeZgKk3V34KGCPOAeeuQDIgyVhV
nP4HF2uWHA=="""""")


@pytest.fixture
def sock():
    s = socket.socket()
    yield s
    s.close()


class TestLegacyResponse(object):
    def test_getheaders(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheaders() == headers

    def test_getheader(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheader('host') == 'example.com'


class TestResponse(object):
    def test_cache_content(self):
        r = HTTPResponse('foo')
        assert r.data == 'foo'
        assert r._body == 'foo'

    def test_default(self):
        r = HTTPResponse()
        assert r.data is None

    def test_none(self):
        r = HTTPResponse(None)
        assert r.data is None

    def test_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=True)

        assert fp.tell() == len(b'foo')
        assert r.data == b'foo'

    def test_no_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=False)

        assert fp.tell() == 0
        assert r.data == b'foo'
        assert fp.tell() == len(b'foo')

    def test_decode_bad_data(self):
        fp = BytesIO(b'\x00' * 10)
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'deflate'})

    def test_reference_read(self):
        fp = BytesIO(b'foo')
        r = HTTPResponse(fp, preload_content=False)

        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'})

        assert r.data == b'foo'

    def test_decode_deflate_case_insensitve(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'DeFlAtE'})

        assert r.data == b'foo'

    def test_chunked_decoding_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(3) == b''
        # Buffer in case we need to switch to the raw stream
        assert r._decoder._data is not None
        assert r.read(1) == b'f'
        # Now that we've decoded data, we just stream through the decoder
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_deflate2(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(1) == b''
        assert r.read(1) == b'f'
        # Once we've decoded data, we just stream to the decoder; no buffering
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                         preload_content=False)

        assert r.read(11) == b''
        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_gzip_multi_member(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    def test_decode_gzip_error(self):
        fp = BytesIO(b'foo')
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'gzip'})

    def test_decode_gzip_swallow_garbage(self):
        # When data comes from multiple calls to read(), data after
        # the first zlib error (here triggered by garbage) should be
        # ignored.
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={'content-encoding': 'gzip'}, preload_content=False)
        ret = b''
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break

        assert ret == b'foofoofoo'

    def test_chunked_decoding_gzip_swallow_garbage(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    def test_multi_decoding_deflate_deflate(self):
        data = zlib.compress(zlib.compress(b'foo'))

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, deflate'})

        assert r.data == b'foo'

    def test_multi_decoding_deflate_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(zlib.compress(b'foo'))
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, gzip'})

        assert r.data == b'foo'

    def test_multi_decoding_gzip_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(data)
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip, gzip'})

        assert r.data == b'foo'

    def test_body_blob(self):
        resp = HTTPResponse(b'foo')
        assert resp.data == b'foo'
        assert resp.closed

    def test_io(self, sock):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)

        assert not resp.closed
        assert resp.readable()
        assert not resp.writable()
        with pytest.raises(IOError):
            resp.fileno()

        resp.close()
        assert resp.closed

        # Try closing with an `httplib.HTTPResponse`, because it has an
        # `isclosed` method.
        try:
            hlr = httplib.HTTPResponse(sock)
            resp2 = HTTPResponse(hlr, preload_content=False)
            assert not resp2.closed
            resp2.close()
            assert resp2.closed
        finally:
            hlr.close()

        # also try when only data is present.
        resp3 = HTTPResponse('foodata')
        with pytest.raises(IOError):
            resp3.fileno()

        resp3._fp = 2
        # A corner case where _fp is present but doesn't have `closed`,
        # `isclosed`, or `fileno`.  Unlikely, but possible.
        assert resp3.closed
        with pytest.raises(IOError):
            resp3.fileno()

    def test_io_closed_consistently(self, sock):
        try:
            hlr = httplib.HTTPResponse(sock)
            hlr.fp = BytesIO(b'foo')
            hlr.chunked = 0
            hlr.length = 3
            with HTTPResponse(hlr, preload_content=False) as resp:
                assert not resp.closed
                assert not resp._fp.isclosed()
                assert not is_fp_closed(resp._fp)
                assert not resp.isclosed()
                resp.read()
                assert resp.closed
                assert resp._fp.isclosed()
                assert is_fp_closed(resp._fp)
                assert resp.isclosed()
        finally:
            hlr.close()

    def test_io_bufferedreader(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp)

        assert br.read() == b'foo'

        br.close()
        assert resp.closed

        b = b'fooandahalf'
        fp = BytesIO(b)
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp, 5)

        br.read(1)  # sets up the buffer, reading 5
        assert len(fp.read()) == (len(b) - 5)

        # This is necessary to make sure the ""no bytes left"" part of `readinto`
        # gets tested.
        while not br.closed:
            br.read(5)

    def test_streaming(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_streaming_tell(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        position = 0

        position += len(next(stream))
        assert 2 == position
        assert position == resp.tell()

        position += len(next(stream))
        assert 3 == position
        assert position == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming_tell(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        uncompressed_data = b'foo'
        data = compress.compress(uncompressed_data)
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream()

        # Read everything
        payload = next(stream)
        assert payload == uncompressed_data

        assert len(data) == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate_streaming_tell_intermediate_point(self):
        # Ensure that ``tell()`` returns the correct number of bytes when
        # part-way through streaming compressed content.
        NUMBER_OF_READS = 10

        class MockCompressedDataReading(BytesIO):
            """"""
            A ByteIO-like reader returning ``payload`` in ``NUMBER_OF_READS``
            calls to ``read``.
            """"""

            def __init__(self, payload, payload_part_size):
                self.payloads = [
                    payload[i*payload_part_size:(i+1)*payload_part_size]
                    for i in range(NUMBER_OF_READS+1)]

                assert b"""".join(self.payloads) == payload

            def read(self, _):
                # Amount is unused.
                if len(self.payloads) > 0:
                    return self.payloads.pop(0)
                return b""""

        uncompressed_data = zlib.decompress(ZLIB_PAYLOAD)

        payload_part_size = len(ZLIB_PAYLOAD) // NUMBER_OF_READS
        fp = MockCompressedDataReading(ZLIB_PAYLOAD, payload_part_size)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream()

        parts_positions = [(part, resp.tell()) for part in stream]
        end_of_stream = resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

        parts, positions = zip(*parts_positions)

        # Check that the payload is equal to the uncompressed data
        payload = b"""".join(parts)
        assert uncompressed_data == payload

        # Check that the positions in the stream are correct
        expected = [(i+1)*payload_part_size for i in range(NUMBER_OF_READS)]
        assert expected == list(positions)

        # Check that the end of the stream is in the correct place
        assert len(ZLIB_PAYLOAD) == end_of_stream

    def test_deflate_streaming(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate2_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_empty_stream(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        with pytest.raises(StopIteration):
            next(stream)

    def test_length_no_header(self):
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        assert resp.length_remaining is None

    def test_length_w_valid_header(self):
        headers = {""content-length"": ""5""}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

    def test_length_w_bad_header(self):
        garbage = {'content-length': 'foo'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

        garbage['content-length'] = ""-10""
        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

    def test_length_when_chunked(self):
        # This is expressly forbidden in RFC 7230 sec 3.3.2
        # We fall back to chunked in this case and try to
        # handle response ignoring content length.
        headers = {'content-length': '5',
                   'transfer-encoding': 'chunked'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining is None

    def test_length_with_multiple_content_lengths(self):
        headers = {'content-length': '5, 5, 5'}
        garbage = {'content-length': '5, 42'}
        fp = BytesIO(b'abcde')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

        with pytest.raises(InvalidHeader):
            HTTPResponse(fp, headers=garbage, preload_content=False)

    def test_length_after_read(self):
        headers = {""content-length"": ""5""}

        # Test no defined length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        resp.read()
        assert resp.length_remaining is None

        # Test our update from content-length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        resp.read()
        assert resp.length_remaining == 0

        # Test partial read
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        data = resp.stream(2)
        next(data)
        assert resp.length_remaining == 3

    def test_mock_httpresponse_stream(self):
        # Mock out a HTTP Request that does enough to make it through urllib3's
        # read() and close() calls, and also exhausts and underlying file
        # object.
        class MockHTTPRequest(object):
            self.fp = None

            def read(self, amt):
                data = self.fp.read(amt)
                if not data:
                    self.fp = None

                return data

            def close(self):
                self.fp = None

        bio = BytesIO(b'foo')
        fp = MockHTTPRequest()
        fp.fp = bio
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_mock_transfer_encoding_chunked(self):
        stream = [b""fo"", b""o"", b""bar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})

        for i, c in enumerate(resp.stream()):
            assert c == stream[i]

    def test_mock_gzipped_transfer_encoding_chunked_decoded(self):
        """"""Show that we can decode the gizpped and chunked body.""""""
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b'foobar')
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i:i+2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {'transfer-encoding': 'chunked', 'content-encoding': 'gzip'}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b''
        for c in resp.stream(decode_content=True):
            data += c

        assert b'foobar' == data

    def test_mock_transfer_encoding_chunked_custom_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        expected_response = [b'fo', b'oo', b'o', b'bb', b'bb', b'aa', b'aa', b'ar']
        response = list(resp.read_chunked(2))
        assert expected_response == response

    def test_mock_transfer_encoding_chunked_unlmtd_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.read_chunked())

    def test_read_not_chunked_response_as_chunks(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        r = resp.read_chunked()
        with pytest.raises(ResponseNotChunked):
            next(r)

    def test_invalid_chunks(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedInvalidEncoding(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        with pytest.raises(ProtocolError):
            next(resp.read_chunked())

    def test_chunked_response_without_crlf_on_end(self):
        stream = [b""foo"", b""bar"", b""baz""]
        fp = MockChunkedEncodingWithoutCRLFOnEnd(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_response_with_extensions(self):
        stream = [b""foo"", b""bar""]
        fp = MockChunkedEncodingWithExtensions(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_head_response(self):
        r = httplib.HTTPResponse(MockSock, method='HEAD')
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse('',
                            preload_content=False,
                            headers={'transfer-encoding': 'chunked'},
                            original_response=r)
        assert resp.chunked is True

        resp.supports_chunked_reads = lambda: True
        resp.release_conn = mock.Mock()
        for _ in resp.stream():
            continue
        resp.release_conn.assert_called_once_with()

    def test_get_case_insensitive_headers(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.headers.get('host') == 'example.com'
        assert r.headers.get('Host') == 'example.com'

    def test_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp)
        assert resp.retries is None
        retry = Retry()
        resp = HTTPResponse(fp, retries=retry)
        assert resp.retries == retry

    def test_geturl(self):
        fp = BytesIO(b'')
        request_url = 'https://example.com'
        resp = HTTPResponse(fp, request_url=request_url)
        assert resp.geturl() == request_url

    def test_geturl_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, request_url='http://example.com')
        request_histories = [
            RequestHistory(method='GET', url='http://example.com', error=None,
                           status=301, redirect_location='https://example.com/'),
            RequestHistory(method='GET', url='https://example.com/', error=None,
                           status=301, redirect_location='https://www.example.com')]
        retry = Retry(history=request_histories)
        resp = HTTPResponse(fp, retries=retry)
        assert resp.geturl() == 'https://www.example.com'


class MockChunkedEncodingResponse(object):

    def __init__(self, content):
        """"""
        content: collection of str, each str is a chunk in response
        """"""
        self.content = content
        self.index = 0  # This class iterates over self.content.
        self.closed = False
        self.cur_chunk = b''
        self.chunks_exhausted = False

    @staticmethod
    def _encode_chunk(chunk):
        # In the general case, we can't decode the chunk to unicode
        length = '%X\r\n' % len(chunk)
        return length.encode() + chunk + b'\r\n'

    def _pop_new_chunk(self):
        if self.chunks_exhausted:
            return b""""
        try:
            chunk = self.content[self.index]
        except IndexError:
            chunk = b''
            self.chunks_exhausted = True
        else:
            self.index += 1
        chunk = self._encode_chunk(chunk)
        if not isinstance(chunk, bytes):
            chunk = chunk.encode()
        return chunk

    def pop_current_chunk(self, amt=-1, till_crlf=False):
        if amt > 0 and till_crlf:
            raise ValueError(""Can't specify amt and till_crlf."")
        if len(self.cur_chunk) <= 0:
            self.cur_chunk = self._pop_new_chunk()
        if till_crlf:
            try:
                i = self.cur_chunk.index(b""\r\n"")
            except ValueError:
                # No CRLF in current chunk -- probably caused by encoder.
                self.cur_chunk = b""""
                return b""""
            else:
                chunk_part = self.cur_chunk[:i+2]
                self.cur_chunk = self.cur_chunk[i+2:]
                return chunk_part
        elif amt <= -1:
            chunk_part = self.cur_chunk
            self.cur_chunk = b''
            return chunk_part
        else:
            try:
                chunk_part = self.cur_chunk[:amt]
            except IndexError:
                chunk_part = self.cur_chunk
                self.cur_chunk = b''
            else:
                self.cur_chunk = self.cur_chunk[amt:]
            return chunk_part

    def readline(self):
        return self.pop_current_chunk(till_crlf=True)

    def read(self, amt=-1):
        return self.pop_current_chunk(amt)

    def flush(self):
        # Python 3 wants this method.
        pass

    def close(self):
        self.closed = True


class MockChunkedInvalidEncoding(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return 'ZZZ\r\n%s\r\n' % chunk.decode()


class MockChunkedEncodingWithoutCRLFOnEnd(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X\r\n%s%s' % (len(chunk), chunk.decode(),
                               ""\r\n"" if len(chunk) > 0 else """")


class MockChunkedEncodingWithExtensions(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X;asd=qwe\r\n%s\r\n' % (len(chunk), chunk.decode())


class MockSock(object):
    @classmethod
    def makefile(cls, *args, **kwargs):
        return",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR ) VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR VAR VAR     VAR = VAR(VAR""""""\ VAR+VAR/VAR+ VAR+VAR/VAR VAR+VAR VAR/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/VAR VAR/VAR/VAR VAR+VAR VAR VAR/VAR/VAR VAR=="""""") @VAR.VAR VAR VAR(): VAR = VAR.VAR() VAR VAR VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR VAR(VAR): VAR = VAR('VAR') VAR VAR.VAR == 'VAR' VAR VAR.VAR == 'VAR' VAR VAR(VAR): VAR = VAR() VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 0 VAR VAR.VAR == VAR'VAR' VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR(VAR): VAR = VAR(VAR'\VAR' * 10) VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(3) == VAR''  VAR VAR.VAR.VAR VAR VAR VAR VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(1) == VAR'' VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(11) == VAR'' VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR):    VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR( VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR VAR.VAR() VAR VAR VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR.VAR   VAR: VAR = VAR.VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR.VAR() VAR VAR.VAR VAR: VAR.VAR()  VAR = VAR('VAR') VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR = 2   VAR VAR.VAR VAR VAR.VAR(VAR): VAR.VAR() VAR VAR(VAR, VAR): VAR: VAR = VAR.VAR(VAR) VAR.VAR = VAR(VAR'VAR') VAR.VAR = 0 VAR.VAR = 3 VAR VAR(VAR, VAR=VAR) VAR VAR: VAR VAR VAR.VAR VAR VAR VAR.VAR.VAR() VAR VAR VAR(VAR.VAR) VAR VAR VAR.VAR() VAR.VAR() VAR VAR.VAR VAR VAR.VAR.VAR() VAR VAR(VAR.VAR) VAR VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR) VAR VAR.VAR() == VAR'VAR' VAR.VAR() VAR VAR.VAR VAR = VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR, 5) VAR.VAR(1)  VAR VAR(VAR.VAR()) == (VAR(VAR) - 5)   VAR VAR VAR.VAR: VAR.VAR(5) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR = 0 VAR += VAR(VAR(VAR)) VAR 2 == VAR VAR VAR == VAR.VAR() VAR += VAR(VAR(VAR)) VAR 3 == VAR VAR VAR == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR'VAR' VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR()  VAR = VAR(VAR) VAR VAR == VAR VAR VAR(VAR) == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR):   VAR = 10 VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR ``VAR`` VAR ``VAR`` VAR VAR ``VAR``. """""" VAR VAR(VAR, VAR, VAR): VAR.VAR = [ VAR[VAR*VAR:(VAR+1)*VAR] VAR VAR VAR VAR(VAR+1)] VAR VAR"""".VAR(VAR.VAR) == VAR VAR VAR(VAR, VAR):  VAR VAR(VAR.VAR) > 0: VAR VAR.VAR.VAR(0) VAR VAR"""" VAR = VAR.VAR(VAR) VAR = VAR(VAR)  VAR = VAR(VAR, VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR() VAR = [(VAR, VAR.VAR()) VAR VAR VAR VAR] VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR, VAR = VAR(*VAR)  VAR = VAR"""".VAR(VAR) VAR VAR == VAR  VAR = [(VAR+1)*VAR VAR VAR VAR VAR(VAR)] VAR VAR == VAR(VAR)  VAR VAR(VAR) == VAR VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR['VAR-VAR'] = ""-10"" VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR):    VAR = {'VAR-VAR': '5', 'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {'VAR-VAR': '5, 5, 5'} VAR = {'VAR-VAR': '5, 42'} VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR.VAR(VAR): VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""}  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR VAR VAR  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR == 0  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR(2) VAR(VAR) VAR VAR.VAR == 3 VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(VAR) VAR VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR): VAR.VAR = VAR VAR = VAR(VAR'VAR') VAR = VAR() VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR, VAR VAR VAR(VAR.VAR()): VAR VAR == VAR[VAR] VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR:VAR+2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': 'VAR'} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR.VAR(VAR=VAR): VAR += VAR VAR VAR'VAR' == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR = [VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR'] VAR = VAR(VAR.VAR(2)) VAR VAR == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR = VAR VAR.VAR = VAR VAR = VAR('', VAR=VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR VAR VAR VAR.VAR = VAR: VAR VAR.VAR = VAR.VAR() VAR VAR VAR VAR.VAR(): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR = VAR() VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = 'VAR: VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR='VAR: VAR = [ VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR = VAR(VAR=VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 'VAR: VAR VAR(VAR): VAR VAR(VAR, VAR): """""" VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR """""" VAR.VAR = VAR VAR.VAR = 0  VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR = '%VAR\VAR\VAR' % VAR(VAR) VAR VAR.VAR() + VAR + VAR'\VAR\VAR' VAR VAR(VAR): VAR VAR.VAR: VAR VAR"""" VAR: VAR = VAR.VAR[VAR.VAR] VAR VAR: VAR = VAR'' VAR.VAR = VAR VAR: VAR.VAR += 1 VAR = VAR.VAR(VAR) VAR VAR VAR(VAR, VAR): VAR = VAR.VAR() VAR VAR VAR VAR(VAR, VAR=-1, VAR=VAR): VAR VAR > 0 VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR."") VAR VAR(VAR.VAR) <= 0: VAR.VAR = VAR.VAR() VAR VAR: VAR: VAR = VAR.VAR.VAR(VAR""\VAR\VAR"") VAR VAR:  VAR.VAR = VAR"""" VAR VAR"""" VAR: VAR = VAR.VAR[:VAR+2] VAR.VAR = VAR.VAR[VAR+2:] VAR VAR VAR VAR <= -1: VAR = VAR.VAR VAR.VAR = VAR'' VAR VAR VAR: VAR: VAR = VAR.VAR[:VAR] VAR VAR: VAR = VAR.VAR VAR.VAR = VAR'' VAR: VAR.VAR = VAR.VAR[VAR:] VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR=VAR) VAR VAR(VAR, VAR=-1): VAR VAR.VAR(VAR) VAR VAR(VAR):  VAR VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR): VAR VAR(VAR, VAR): VAR 'VAR\VAR\VAR%VAR\VAR\VAR' % VAR.VAR() VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR\VAR\VAR%VAR%VAR' % (VAR(VAR), VAR.VAR(), ""\VAR\VAR"" VAR VAR(VAR) > 0 VAR """") VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR;VAR=VAR\VAR\VAR%VAR\VAR\VAR' % (VAR(VAR), VAR.VAR()) VAR VAR(VAR): @VAR VAR VAR(VAR, *VAR, **VAR): VAR ",1
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/with_dummyserver/test_chunked_transfer.py,"# -*- coding: utf-8 -*-

from urllib3 import HTTPConnectionPool
from dummyserver.testcase import SocketDummyServerTestCase


class TestChunkedTransfer(SocketDummyServerTestCase):
    def start_chunked_handler(self):
        self.buffer = b''

        def socket_handler(listener):
            sock = listener.accept()[0]

            while not self.buffer.endswith(b'\r\n0\r\n\r\n'):
                self.buffer += sock.recv(65536)

            sock.send(
               b'HTTP/1.1 200 OK\r\n'
               b'Content-type: text/plain\r\n'
               b'Content-Length: 0\r\n'
               b'\r\n')
            sock.close()

        self._start_server(socket_handler)

    def test_chunks(self):
        self.start_chunked_handler()
        chunks = ['foo', 'bar', '', 'bazzzzzzzzzzzzzzzzzzzzzz']
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        pool.urlopen('GET', '/', chunks, headers=dict(DNT='1'), chunked=True)
        self.addCleanup(pool.close)

        self.assertIn(b'Transfer-Encoding', self.buffer)
        body = self.buffer.split(b'\r\n\r\n', 1)[1]
        lines = body.split(b'\r\n')
        # Empty chunks should have been skipped, as this could not be distinguished
        # from terminating the transmission
        for i, chunk in enumerate([c for c in chunks if c]):
            self.assertEqual(lines[i * 2], hex(len(chunk))[2:].encode('utf-8'))
            self.assertEqual(lines[i * 2 + 1], chunk.encode('utf-8'))

    def _test_body(self, data):
        self.start_chunked_handler()
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)

        pool.urlopen('GET', '/', data, chunked=True)
        header, body = self.buffer.split(b'\r\n\r\n', 1)

        self.assertIn(b'Transfer-Encoding: chunked', header.split(b'\r\n'))
        if data:
            bdata = data if isinstance(data, bytes) else data.encode('utf-8')
            self.assertIn(b'\r\n' + bdata + b'\r\n', body)
            self.assertTrue(body.endswith(b'\r\n0\r\n\r\n'))

            len_str = body.split(b'\r\n', 1)[0]
            stated_len = int(len_str, 16)
            self.assertEqual(stated_len, len(bdata))
        else:
            self.assertEqual(body, b'0\r\n\r\n')

    def test_bytestring_body(self):
        self._test_body(b'thisshouldbeonechunk\r\nasdf')

    def test_unicode_body(self):
        # Define u'thisshouldbeonechunk\r\n' in a way, so that python3.1
        # does not suffer a syntax error
        chunk = b'thisshouldbeonechunk\r\n\xc3\xa4\xc3\xb6\xc3\xbc\xc3\x9f'.decode('utf-8')
        self._test_body(chunk)

    def test_empty_body(self):
        self._test_body(None)

    def test_empty_string_body(self):
        self._test_body('')

    def test_empty_iterable_body(self):
        self._test_body([])

    def test_removes_duplicate_host_header(self):
        self.start_chunked_handler()
        chunks = ['foo', 'bar', '', 'bazzzzzzzzzzzzzzzzzzzzzz']
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.urlopen(
            'GET', '/', chunks, headers={'Host': 'test.org'}, chunked=True
        )

        header_block = self.buffer.split(b'\r\n\r\n', 1)[0].lower()
        header_lines = header_block.split(b'\r\n')[1:]

        host_headers = [x for x in header_lines if x.startswith(b'host')]
        self.assertEqual(len(host_headers), 1)

    def test_provides_default_host_header(self):
        self.start_chunked_handler()
        chunks = ['foo', 'bar', '', 'bazzzzzzzzzzzzzzzzzzzzzz']
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.urlopen('GET', '/', chunks, chunked=True)

        header_block = self.buffer.split(b'\r\n\r\n', 1)[0].lower()
        header_lines = header_block.split(b'\r\n')[1:]

        host_headers = [x for x in header_lines if x.startswith(b'host')]
        self.assertEqual(len(host_headers), 1)",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED," VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR'' VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR'): VAR.VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR() VAR = ['VAR', 'VAR', '', 'VAR'] VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR('VAR', '/', VAR, VAR=VAR(VAR='1'), VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR'VAR-VAR', VAR.VAR) VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1)[1] VAR = VAR.VAR(VAR'\VAR\VAR')   VAR VAR, VAR VAR VAR([VAR VAR VAR VAR VAR VAR VAR]): VAR.VAR(VAR[VAR * 2], VAR(VAR(VAR))[2:].VAR('VAR-8')) VAR.VAR(VAR[VAR * 2 + 1], VAR.VAR('VAR-8')) VAR VAR(VAR, VAR): VAR.VAR() VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR, VAR=VAR) VAR, VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1) VAR.VAR(VAR'VAR-VAR: VAR', VAR.VAR(VAR'\VAR\VAR')) VAR VAR: VAR = VAR VAR VAR(VAR, VAR) VAR VAR.VAR('VAR-8') VAR.VAR(VAR'\VAR\VAR' + VAR + VAR'\VAR\VAR', VAR) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR')) VAR = VAR.VAR(VAR'\VAR\VAR', 1)[0] VAR = VAR(VAR, 16) VAR.VAR(VAR, VAR(VAR)) VAR: VAR.VAR(VAR, VAR'0\VAR\VAR\VAR\VAR') VAR VAR(VAR): VAR.VAR(VAR'VAR\VAR\VAR') VAR VAR(VAR):   VAR = VAR'VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR'.VAR('VAR-8') VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR('') VAR VAR(VAR): VAR.VAR([]) VAR VAR(VAR): VAR.VAR() VAR = ['VAR', 'VAR', '', 'VAR'] VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR( 'VAR', '/', VAR, VAR={'VAR': 'VAR.VAR'}, VAR=VAR ) VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1)[0].VAR() VAR = VAR.VAR(VAR'\VAR\VAR')[1:] VAR = [VAR VAR VAR VAR VAR VAR VAR.VAR(VAR'VAR')] VAR.VAR(VAR(VAR), 1) VAR VAR(VAR): VAR.VAR() VAR = ['VAR', 'VAR', '', 'VAR'] VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR, VAR=VAR) VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1)[0].VAR() VAR = VAR.VAR(VAR'\VAR\VAR')[1:] VAR = [VAR VAR VAR VAR VAR VAR VAR.VAR(VAR'VAR')] VAR.VAR(VAR(VAR), 1) ",1
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,docs/requirements.txt,"-r ../dev-requirements.txt
sphinx
alabaster
requests>=2,<2.16",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"-VAR ../VAR-VAR.VAR VAR VAR VAR>=2,<2.16 ",1
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,src/urllib3/contripyopenssl.py,"""""""
SSL with SNI_-support for Python 2. Follow these instructions if you would
like to verify SSL certificates in Python 2. Note, the default libraries do
*not* do certificate checking; you need to do additional work to validate
certificates yourself.

This needs the following packages installed:

* pyOpenSSL (tested with 16.0.0)
* cryptography (minimum 1.3.4, from pyopenssl)
* idna (minimum 2.0, from cryptography)

However, pyopenssl depends on cryptography, which depends on idna, so while we
use all three directly here we end up having relatively few packages required.

You can install them with the following command:

    pip install pyopenssl cryptography idna

To activate certificate checking, call
:func:`~urllib3.contrib.pyopenssl.inject_into_urllib3` from your Python code
before you begin making HTTP requests. This can be done in a ``sitecustomize``
module, or at any other time before your application begins using ``urllib3``,
like this::

    try:
        import urllib3.contrib.pyopenssl
        urllib3.contrib.pyopenssl.inject_into_urllib3()
    except ImportError:
        pass

Now you can use :mod:`urllib3` as you normally would, and it will support SNI
when the required modules are installed.

Activating this module also has the positive side effect of disabling SSL/TLS
compression in Python 2 (see `CRIME attack`_).

If you want to configure the default list of supported cipher suites, you can
set the ``urllib3.contrib.pyopenssl.DEFAULT_SSL_CIPHER_LIST`` variable.

.. _sni: https://en.wikipedia.org/wiki/Server_Name_Indication
.. _crime attack: https://en.wikipedia.org/wiki/CRIME_(security_exploit)
""""""
from __future__ import absolute_import

import OpenSSL.SSL
from cryptography import x509
from cryptography.hazmat.backends.openssl import backend as openssl_backend
from cryptography.hazmat.backends.openssl.x509 import _Certificate
try:
    from cryptography.x509 import UnsupportedExtension
except ImportError:
    # UnsupportedExtension is gone in cryptography >= 2.1.0
    class UnsupportedExtension(Exception):
        pass

from socket import timeout, error as SocketError
from io import BytesIO

try:  # Platform-specific: Python 2
    from socket import _fileobject
except ImportError:  # Platform-specific: Python 3
    _fileobject = None
    from ..packages.backports.makefile import backport_makefile

import logging
import ssl
from ..packages import six
import sys

from .. import util


__all__ = ['inject_into_urllib3', 'extract_from_urllib3']

# SNI always works.
HAS_SNI = True

# Map from urllib3 to PyOpenSSL compatible parameter-values.
_openssl_versions = {
    util.PROTOCOL_TLS: OpenSSL.SSL.SSLv23_METHOD,
    ssl.PROTOCOL_TLSv1: OpenSSL.SSL.TLSv1_METHOD,
}

if hasattr(ssl, 'PROTOCOL_SSLv3') and hasattr(OpenSSL.SSL, 'SSLv3_METHOD'):
    _openssl_versions[ssl.PROTOCOL_SSLv3] = OpenSSL.SSL.SSLv3_METHOD

if hasattr(ssl, 'PROTOCOL_TLSv1_1') and hasattr(OpenSSL.SSL, 'TLSv1_1_METHOD'):
    _openssl_versions[ssl.PROTOCOL_TLSv1_1] = OpenSSL.SSL.TLSv1_1_METHOD

if hasattr(ssl, 'PROTOCOL_TLSv1_2') and hasattr(OpenSSL.SSL, 'TLSv1_2_METHOD'):
    _openssl_versions[ssl.PROTOCOL_TLSv1_2] = OpenSSL.SSL.TLSv1_2_METHOD


_stdlib_to_openssl_verify = {
    ssl.CERT_NONE: OpenSSL.SSL.VERIFY_NONE,
    ssl.CERT_OPTIONAL: OpenSSL.SSL.VERIFY_PEER,
    ssl.CERT_REQUIRED:
        OpenSSL.SSL.VERIFY_PEER + OpenSSL.SSL.VERIFY_FAIL_IF_NO_PEER_CERT,
}
_openssl_to_stdlib_verify = dict(
    (v, k) for k, v in _stdlib_to_openssl_verify.items()
)

# OpenSSL will only write 16K at a time
SSL_WRITE_BLOCKSIZE = 16384

orig_util_HAS_SNI = util.HAS_SNI
orig_util_SSLContext = util.ssl_.SSLContext


log = logging.getLogger(__name__)


def inject_into_urllib3():
    'Monkey-patch urllib3 with PyOpenSSL-backed SSL-support.'

    _validate_dependencies_met()

    util.SSLContext = PyOpenSSLContext
    util.ssl_.SSLContext = PyOpenSSLContext
    util.HAS_SNI = HAS_SNI
    util.ssl_.HAS_SNI = HAS_SNI
    util.IS_PYOPENSSL = True
    util.ssl_.IS_PYOPENSSL = True


def extract_from_urllib3():
    'Undo monkey-patching by :func:`inject_into_urllib3`.'

    util.SSLContext = orig_util_SSLContext
    util.ssl_.SSLContext = orig_util_SSLContext
    util.HAS_SNI = orig_util_HAS_SNI
    util.ssl_.HAS_SNI = orig_util_HAS_SNI
    util.IS_PYOPENSSL = False
    util.ssl_.IS_PYOPENSSL = False


def _validate_dependencies_met():
    """"""
    Verifies that PyOpenSSL's package-level dependencies have been met.
    Throws `ImportError` if they are not met.
    """"""
    # Method added in `cryptography==1.1`; not available in older versions
    from cryptography.x509.extensions import Extensions
    if getattr(Extensions, ""get_extension_for_class"", None) is None:
        raise ImportError(""'cryptography' module missing required functionality.  ""
                          ""Try upgrading to v1.3.4 or newer."")

    # pyOpenSSL 0.14 and above use cryptography for OpenSSL bindings. The _x509
    # attribute is only present on those versions.
    from OpenSSL.crypto import X509
    x509 = X509()
    if getattr(x509, ""_x509"", None) is None:
        raise ImportError(""'pyOpenSSL' module missing required functionality. ""
                          ""Try upgrading to v0.14 or newer."")


def _dnsname_to_stdlib(name):
    """"""
    Converts a dNSName SubjectAlternativeName field to the form used by the
    standard library on the given Python version.

    Cryptography produces a dNSName as a unicode string that was idna-decoded
    from ASCII bytes. We need to idna-encode that string to get it back, and
    then on Python 3 we also need to convert to unicode via UTF-8 (the stdlib
    uses PyUnicode_FromStringAndSize on it, which decodes via UTF-8).

    If the name cannot be idna-encoded then we return None signalling that
    the name given should be skipped.
    """"""
    def idna_encode(name):
        """"""
        Borrowed wholesale from the Python Cryptography Project. It turns out
        that we can't just safely call `idna.encode`: it can explode for
        wildcard names. This avoids that problem.
        """"""
        import idna

        try:
            for prefix in [u'*.', u'.']:
                if name.startswith(prefix):
                    name = name[len(prefix):]
                    return prefix.encode('ascii') + idna.encode(name)
            return idna.encode(name)
        except idna.core.IDNAError:
            return None

    # Don't send IPv6 addresses through the IDNA encoder.
    if ':' in name:
        return name

    name = idna_encode(name)
    if name is None:
        return None
    elif sys.version_info >= (3, 0):
        name = name.decode('utf-8')
    return name


def get_subj_alt_name(peer_cert):
    """"""
    Given an PyOpenSSL certificate, provides all the subject alternative names.
    """"""
    # Pass the cert to cryptography, which has much better APIs for this.
    if hasattr(peer_cert, ""to_cryptography""):
        cert = peer_cert.to_cryptography()
    else:
        # This is technically using private APIs, but should work across all
        # relevant versions before PyOpenSSL got a proper API for this.
        cert = _Certificate(openssl_backend, peer_cert._x509)

    # We want to find the SAN extension. Ask Cryptography to locate it (it's
    # faster than looping in Python)
    try:
        ext = cert.extensions.get_extension_for_class(
            x509.SubjectAlternativeName
        ).value
    except x509.ExtensionNotFound:
        # No such extension, return the empty list.
        return []
    except (x509.DuplicateExtension, UnsupportedExtension,
            x509.UnsupportedGeneralNameType, UnicodeError) as e:
        # A problem has been found with the quality of the certificate. Assume
        # no SAN field is present.
        log.warning(
            ""A problem was encountered with the certificate that prevented ""
            ""urllib3 from finding the SubjectAlternativeName field. This can ""
            ""affect certificate validation. The error was %s"",
            e,
        )
        return []

    # We want to return dNSName and iPAddress fields. We need to cast the IPs
    # back to strings because the match_hostname function wants them as
    # strings.
    # Sadly the DNS names need to be idna encoded and then, on Python 3, UTF-8
    # decoded. This is pretty frustrating, but that's what the standard library
    # does with certificates, and so we need to attempt to do the same.
    # We also want to skip over names which cannot be idna encoded.
    names = [
        ('DNS', name) for name in map(_dnsname_to_stdlib, ext.get_values_for_type(x509.DNSName))
        if name is not None
    ]
    names.extend(
        ('IP Address', str(name))
        for name in ext.get_values_for_type(x509.IPAddress)
    )

    return names


class WrappedSocket(object):
    '''API-compatibility wrapper for Python OpenSSL's Connection-class.

    Note: _makefile_refs, _drop() and _reuse() are needed for the garbage
    collector of pypy.
    '''

    def __init__(self, connection, socket, suppress_ragged_eofs=True):
        self.connection = connection
        self.socket = socket
        self.suppress_ragged_eofs = suppress_ragged_eofs
        self._makefile_refs = 0
        self._closed = False

    def fileno(self):
        return self.socket.fileno()

    # Copy-pasted from Python 3.5 source code
    def _decref_socketios(self):
        if self._makefile_refs > 0:
            self._makefile_refs -= 1
        if self._closed:
            self.close()

    def recv(self, *args, **kwargs):
        try:
            data = self.connection.recv(*args, **kwargs)
        except OpenSSL.SSL.SysCallError as e:
            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):
                return b''
            else:
                raise SocketError(str(e))
        except OpenSSL.SSL.ZeroReturnError:
            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
                return b''
            else:
                raise
        except OpenSSL.SSL.WantReadError:
            if not util.wait_for_read(self.socket, self.socket.gettimeout()):
                raise timeout('The read operation timed out')
            else:
                return self.recv(*args, **kwargs)

        # TLS 1.3 post-handshake authentication
        except OpenSSL.SSL.Error as e:
            raise ssl.SSLError(""read error: %r"" % e)
        else:
            return data

    def recv_into(self, *args, **kwargs):
        try:
            return self.connection.recv_into(*args, **kwargs)
        except OpenSSL.SSL.SysCallError as e:
            if self.suppress_ragged_eofs and e.args == (-1, 'Unexpected EOF'):
                return 0
            else:
                raise SocketError(str(e))
        except OpenSSL.SSL.ZeroReturnError:
            if self.connection.get_shutdown() == OpenSSL.SSL.RECEIVED_SHUTDOWN:
                return 0
            else:
                raise
        except OpenSSL.SSL.WantReadError:
            if not util.wait_for_read(self.socket, self.socket.gettimeout()):
                raise timeout('The read operation timed out')
            else:
                return self.recv_into(*args, **kwargs)

        # TLS 1.3 post-handshake authentication
        except OpenSSL.SSL.Error as e:
            raise ssl.SSLError(""read error: %r"" % e)

    def settimeout(self, timeout):
        return self.socket.settimeout(timeout)

    def _send_until_done(self, data):
        while True:
            try:
                return self.connection.send(data)
            except OpenSSL.SSL.WantWriteError:
                if not util.wait_for_write(self.socket, self.socket.gettimeout()):
                    raise timeout()
                continue
            except OpenSSL.SSL.SysCallError as e:
                raise SocketError(str(e))

    def sendall(self, data):
        total_sent = 0
        while total_sent < len(data):
            sent = self._send_until_done(data[total_sent:total_sent + SSL_WRITE_BLOCKSIZE])
            total_sent += sent

    def shutdown(self):
        # FIXME rethrow compatible exceptions should we ever use this
        self.connection.shutdown()

    def close(self):
        if self._makefile_refs < 1:
            try:
                self._closed = True
                return self.connection.close()
            except OpenSSL.SSL.Error:
                return
        else:
            self._makefile_refs -= 1

    def getpeercert(self, binary_form=False):
        x509 = self.connection.get_peer_certificate()

        if not x509:
            return x509

        if binary_form:
            return OpenSSL.crypto.dump_certificate(
                OpenSSL.crypto.FILETYPE_ASN1,
                x509)

        return {
            'subject': (
                (('commonName', x509.get_subject().CN),),
            ),
            'subjectAltName': get_subj_alt_name(x509)
        }

    def version(self):
        return self.connection.get_protocol_version_name()

    def _reuse(self):
        self._makefile_refs += 1

    def _drop(self):
        if self._makefile_refs < 1:
            self.close()
        else:
            self._makefile_refs -= 1


if _fileobject:  # Platform-specific: Python 2
    def makefile(self, mode, bufsize=-1):
        self._makefile_refs += 1
        return _fileobject(self, mode, bufsize, close=True)
else:  # Platform-specific: Python 3
    makefile = backport_makefile

WrappedSocket.makefile = makefile


class PyOpenSSLContext(object):
    """"""
    I am a wrapper class for the PyOpenSSL ``Context`` object. I am responsible
    for translating the interface of the standard library ``SSLContext`` object
    to calls into PyOpenSSL.
    """"""
    def __init__(self, protocol):
        self.protocol = _openssl_versions[protocol]
        self._ctx = OpenSSL.SSL.Context(self.protocol)
        self._options = 0
        self.check_hostname = False

    @property
    def options(self):
        return self._options

    @options.setter
    def options(self, value):
        self._options = value
        self._ctx.set_options(value)

    @property
    def verify_mode(self):
        return _openssl_to_stdlib_verify[self._ctx.get_verify_mode()]

    @verify_mode.setter
    def verify_mode(self, value):
        self._ctx.set_verify(
            _stdlib_to_openssl_verify[value],
            _verify_callback
        )

    def set_default_verify_paths(self):
        self._ctx.set_default_verify_paths()

    def set_ciphers(self, ciphers):
        if isinstance(ciphers, six.text_type):
            ciphers = ciphers.encode('utf-8')
        self._ctx.set_cipher_list(ciphers)

    def load_verify_locations(self, cafile=None, capath=None, cadata=None):
        if cafile is not None:
            cafile = cafile.encode('utf-8')
        if capath is not None:
            capath = capath.encode('utf-8')
        self._ctx.load_verify_locations(cafile, capath)
        if cadata is not None:
            self._ctx.load_verify_locations(BytesIO(cadata))

    def load_cert_chain(self, certfile, keyfile=None, password=None):
        self._ctx.use_certificate_chain_file(certfile)
        if password is not None:
            if not isinstance(password, six.binary_type):
                password = password.encode('utf-8')
            self._ctx.set_passwd_cb(lambda *_: password)
        self._ctx.use_privatekey_file(keyfile or certfile)

    def wrap_socket(self, sock, server_side=False,
                    do_handshake_on_connect=True, suppress_ragged_eofs=True,
                    server_hostname=None):
        cnx = OpenSSL.SSL.Connection(self._ctx, sock)

        if isinstance(server_hostname, six.text_type):  # Platform-specific: Python 3
            server_hostname = server_hostname.encode('utf-8')

        if server_hostname is not None:
            cnx.set_tlsext_host_name(server_hostname)

        cnx.set_connect_state()

        while True:
            try:
                cnx.do_handshake()
            except OpenSSL.SSL.WantReadError:
                if not util.wait_for_read(sock, sock.gettimeout()):
                    raise timeout('select timed out')
                continue
            except OpenSSL.SSL.Error as e:
                raise ssl.SSLError('bad handshake: %r' % e)
            break

        return WrappedSocket(cnx, sock)


def _verify_callback(cnx, x509, err_no, err_depth, return_code):
    return err_no == 0",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,""""""" VAR VAR VAR-VAR VAR VAR 2. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 2. VAR, VAR VAR VAR VAR *VAR* VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR: * VAR (VAR VAR 16.0.0) * VAR (VAR 1.3.4, VAR VAR) * VAR (VAR 2.0, VAR VAR) VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR ``VAR`` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR``, VAR VAR:: VAR: VAR VAR.VAR.VAR VAR.VAR.VAR.VAR() VAR VAR: VAR VAR VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR VAR 2 (VAR `VAR VAR`VAR). VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR ``VAR.VAR.VAR.VAR`` VAR. .. VAR: VAR: .. VAR VAR: VAR: """""" VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR: VAR VAR.VAR VAR VAR VAR VAR:  VAR VAR(VAR): VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR:  VAR VAR VAR VAR VAR VAR:  VAR = VAR VAR ..VAR.VAR.VAR VAR VAR VAR VAR VAR VAR VAR ..VAR VAR VAR VAR VAR VAR .. VAR VAR VAR = ['VAR', 'VAR']  VAR = VAR  VAR = { VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR, } VAR VAR(VAR, 'VAR') VAR VAR(VAR.VAR, 'VAR'): VAR[VAR.VAR] = VAR.VAR.VAR VAR VAR(VAR, 'VAR') VAR VAR(VAR.VAR, 'VAR'): VAR[VAR.VAR] = VAR.VAR.VAR VAR VAR(VAR, 'VAR') VAR VAR(VAR.VAR, 'VAR'): VAR[VAR.VAR] = VAR.VAR.VAR VAR = { VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR, VAR.VAR: VAR.VAR.VAR + VAR.VAR.VAR, } VAR = VAR( (VAR, VAR) VAR VAR, VAR VAR VAR.VAR() )  VAR = 16384 VAR = VAR.VAR VAR = VAR.VAR.VAR VAR = VAR.VAR(VAR) VAR VAR(): 'VAR-VAR VAR VAR VAR-VAR VAR-VAR.' VAR() VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR VAR(): 'VAR VAR-VAR VAR :VAR:`VAR`.' VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR.VAR = VAR VAR.VAR.VAR = VAR VAR VAR(): """""" VAR VAR VAR'VAR VAR-VAR VAR VAR VAR VAR. VAR `VAR` VAR VAR VAR VAR VAR. """"""  VAR VAR.VAR.VAR VAR VAR VAR VAR(VAR, ""VAR"", VAR) VAR VAR: VAR VAR(""'VAR' VAR VAR VAR VAR. "" ""VAR VAR VAR VAR.3.4 VAR VAR."")   VAR VAR.VAR VAR VAR VAR = VAR() VAR VAR(VAR, ""VAR"", VAR) VAR VAR: VAR VAR(""'VAR' VAR VAR VAR VAR. "" ""VAR VAR VAR VAR.14 VAR VAR."") VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR. VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR 3 VAR VAR VAR VAR VAR VAR VAR VAR VAR-8 (VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR-8). VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR `VAR.VAR`: VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR. """""" VAR VAR VAR: VAR VAR VAR [VAR'*.', VAR'.']: VAR VAR.VAR(VAR): VAR = VAR[VAR(VAR):] VAR VAR.VAR('VAR') + VAR.VAR(VAR) VAR VAR.VAR(VAR) VAR VAR.VAR.VAR: VAR VAR  VAR ':' VAR VAR: VAR VAR VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR VAR VAR.VAR >= (3, 0): VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR(VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. """"""  VAR VAR(VAR, ""VAR""): VAR = VAR.VAR() VAR:   VAR = VAR(VAR, VAR.VAR)   VAR: VAR = VAR.VAR.VAR( VAR.VAR ).VAR VAR VAR.VAR:  VAR [] VAR (VAR.VAR, VAR, VAR.VAR, VAR) VAR VAR:   VAR.VAR( ""VAR VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR VAR. VAR VAR "" ""VAR VAR VAR. VAR VAR VAR %VAR"", VAR, ) VAR []        VAR = [ ('VAR', VAR) VAR VAR VAR VAR(VAR, VAR.VAR(VAR.VAR)) VAR VAR VAR VAR VAR ] VAR.VAR( ('VAR VAR', VAR(VAR)) VAR VAR VAR VAR.VAR(VAR.VAR) ) VAR VAR VAR VAR(VAR): '''VAR-VAR VAR VAR VAR VAR'VAR VAR-VAR. VAR: VAR, VAR() VAR VAR() VAR VAR VAR VAR VAR VAR VAR VAR. ''' VAR VAR(VAR, VAR, VAR, VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR VAR(VAR): VAR VAR.VAR.VAR()  VAR VAR(VAR): VAR VAR.VAR > 0: VAR.VAR -= 1 VAR VAR.VAR: VAR.VAR() VAR VAR(VAR, *VAR, **VAR): VAR: VAR = VAR.VAR.VAR(*VAR, **VAR) VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR == (-1, 'VAR VAR'): VAR VAR'' VAR: VAR VAR(VAR(VAR)) VAR VAR.VAR.VAR: VAR VAR.VAR.VAR() == VAR.VAR.VAR: VAR VAR'' VAR: VAR VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR('VAR VAR VAR VAR VAR') VAR: VAR VAR.VAR(*VAR, **VAR)  VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR(""VAR VAR: %VAR"" % VAR) VAR: VAR VAR VAR VAR(VAR, *VAR, **VAR): VAR: VAR VAR.VAR.VAR(*VAR, **VAR) VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR == (-1, 'VAR VAR'): VAR 0 VAR: VAR VAR(VAR(VAR)) VAR VAR.VAR.VAR: VAR VAR.VAR.VAR() == VAR.VAR.VAR: VAR 0 VAR: VAR VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR('VAR VAR VAR VAR VAR') VAR: VAR VAR.VAR(*VAR, **VAR)  VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR(""VAR VAR: %VAR"" % VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR(VAR) VAR VAR(VAR, VAR): VAR VAR: VAR: VAR VAR.VAR.VAR(VAR) VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR.VAR, VAR.VAR.VAR()): VAR VAR() VAR VAR VAR.VAR.VAR VAR VAR: VAR VAR(VAR(VAR)) VAR VAR(VAR, VAR): VAR = 0 VAR VAR < VAR(VAR): VAR = VAR.VAR(VAR[VAR:VAR + VAR]) VAR += VAR VAR VAR(VAR):  VAR.VAR.VAR() VAR VAR(VAR): VAR VAR.VAR < 1: VAR: VAR.VAR = VAR VAR VAR.VAR.VAR() VAR VAR.VAR.VAR: VAR VAR: VAR.VAR -= 1 VAR VAR(VAR, VAR=VAR): VAR = VAR.VAR.VAR() VAR VAR VAR: VAR VAR VAR VAR: VAR VAR.VAR.VAR( VAR.VAR.VAR, VAR) VAR { 'VAR': ( (('VAR', VAR.VAR().VAR),), ), 'VAR': VAR(VAR) } VAR VAR(VAR): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR.VAR += 1 VAR VAR(VAR): VAR VAR.VAR < 1: VAR.VAR() VAR: VAR.VAR -= 1 VAR VAR:  VAR VAR(VAR, VAR, VAR=-1): VAR.VAR += 1 VAR VAR(VAR, VAR, VAR, VAR=VAR) VAR:  VAR = VAR VAR.VAR = VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = VAR[VAR] VAR.VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR = 0 VAR.VAR = VAR @VAR VAR VAR(VAR): VAR VAR.VAR @VAR.VAR VAR VAR(VAR, VAR): VAR.VAR = VAR VAR.VAR.VAR(VAR) @VAR VAR VAR(VAR): VAR VAR[VAR.VAR.VAR()] @VAR.VAR VAR VAR(VAR, VAR): VAR.VAR.VAR( VAR[VAR], VAR ) VAR VAR(VAR): VAR.VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR, VAR.VAR): VAR = VAR.VAR('VAR-8') VAR.VAR.VAR(VAR) VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR VAR VAR VAR VAR: VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR VAR: VAR = VAR.VAR('VAR-8') VAR.VAR.VAR(VAR, VAR) VAR VAR VAR VAR VAR: VAR.VAR.VAR(VAR(VAR)) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): VAR.VAR.VAR(VAR) VAR VAR VAR VAR VAR: VAR VAR VAR(VAR, VAR.VAR): VAR = VAR.VAR('VAR-8') VAR.VAR.VAR(VAR *VAR: VAR) VAR.VAR.VAR(VAR VAR VAR) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR = VAR.VAR.VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR.VAR):  VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR VAR: VAR.VAR(VAR) VAR.VAR() VAR VAR: VAR: VAR.VAR() VAR VAR.VAR.VAR: VAR VAR VAR.VAR(VAR, VAR.VAR()): VAR VAR('VAR VAR VAR') VAR VAR VAR.VAR.VAR VAR VAR: VAR VAR.VAR('VAR VAR: %VAR' % VAR) VAR VAR VAR(VAR, VAR) VAR VAR(VAR, VAR, VAR, VAR, VAR): VAR VAR == 0 ",1
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,src/urllib3/filepost.py,"from __future__ import absolute_import
import binascii
import codecs
import os

from io import BytesIO

from .packages import six
from .packages.six import b
from .fields import RequestField

writer = codecs.lookup('utf-8')[3]


def choose_boundary():
    """"""
    Our embarrassingly-simple replacement for mimetools.choose_boundary.
    """"""
    boundary = binascii.hexlify(os.urandom(16))
    if six.PY3:
        boundary = boundary.decode('ascii')
    return boundary


def iter_field_objects(fields):
    """"""
    Iterate over fields.

    Supports list of (k, v) tuples and dicts, and lists of
    :class:`~urllib3.fields.RequestField`.

    """"""
    if isinstance(fields, dict):
        i = six.iteritems(fields)
    else:
        i = iter(fields)

    for field in i:
        if isinstance(field, RequestField):
            yield field
        else:
            yield RequestField.from_tuples(*field)


def iter_fields(fields):
    """"""
    .. deprecated:: 1.6

    Iterate over fields.

    The addition of :class:`~urllib3.fields.RequestField` makes this function
    obsolete. Instead, use :func:`iter_field_objects`, which returns
    :class:`~urllib3.fields.RequestField` objects.

    Supports list of (k, v) tuples and dicts.
    """"""
    if isinstance(fields, dict):
        return ((k, v) for k, v in six.iteritems(fields))

    return ((k, v) for k, v in fields)


def encode_multipart_formdata(fields, boundary=None):
    """"""
    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.

    :param fields:
        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).

    :param boundary:
        If not specified, then a random boundary will be generated using
        :func:`urllib3.filepost.choose_boundary`.
    """"""
    body = BytesIO()
    if boundary is None:
        boundary = choose_boundary()

    for field in iter_field_objects(fields):
        body.write(b('--%s\r\n' % (boundary)))

        writer(body).write(field.render_headers())
        data = field.data

        if isinstance(data, int):
            data = str(data)  # Backwards compatibility

        if isinstance(data, six.text_type):
            writer(body).write(data)
        else:
            body.write(data)

        body.write(b'\r\n')

    body.write(b('--%s--\r\n' % (boundary)))

    content_type = str('multipart/form-data; boundary=%s' % boundary)

    return body.getvalue(), content_type",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR.VAR VAR VAR VAR .VAR VAR VAR VAR = VAR.VAR('VAR-8')[3] VAR VAR(): """""" VAR VAR-VAR VAR VAR VAR.VAR. """""" VAR = VAR.VAR(VAR.VAR(16)) VAR VAR.VAR: VAR = VAR.VAR('VAR') VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR, VAR VAR VAR :VAR:`~VAR.VAR.VAR`. """""" VAR VAR(VAR, VAR): VAR = VAR.VAR(VAR) VAR: VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR.VAR(*VAR) VAR VAR(VAR): """""" .. VAR:: 1.6 VAR VAR VAR. VAR VAR VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR VAR. VAR, VAR :VAR:`VAR`, VAR VAR :VAR:`~VAR.VAR.VAR` VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR ((VAR, VAR) VAR VAR, VAR VAR VAR.VAR(VAR)) VAR ((VAR, VAR) VAR VAR, VAR VAR VAR) VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR ``VAR`` VAR VAR VAR/VAR-VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR (VAR, :VAR:`~VAR.VAR.VAR`). :VAR VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR`. """""" VAR = VAR() VAR VAR VAR VAR: VAR = VAR() VAR VAR VAR VAR(VAR): VAR.VAR(VAR('--%VAR\VAR\VAR' % (VAR))) VAR(VAR).VAR(VAR.VAR()) VAR = VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR)  VAR VAR(VAR, VAR.VAR): VAR(VAR).VAR(VAR) VAR: VAR.VAR(VAR) VAR.VAR(VAR'\VAR\VAR') VAR.VAR(VAR('--%VAR--\VAR\VAR' % (VAR))) VAR = VAR('VAR/VAR-VAR; VAR=%VAR' % VAR) VAR VAR.VAR(), VAR ",1
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,src/urllib3/response.py,"from __future__ import absolute_import
from contextlib import contextmanager
import zlib
import io
import logging
from socket import timeout as SocketTimeout
from socket import error as SocketError

try:
    import brotli
except ImportError:
    brotli = None

from ._collections import HTTPHeaderDict
from .exceptions import (
    BodyNotHttplibCompatible, ProtocolError, DecodeError, ReadTimeoutError,
    ResponseNotChunked, IncompleteRead, InvalidHeader
)
from .packages.six import string_types as basestring, PY3
from .packages.six.moves import http_client as httplib
from .connection import HTTPException, BaseSSLError
from .util.response import is_fp_closed, is_response_to_head

log = logging.getLogger(__name__)


class DeflateDecoder(object):

    def __init__(self):
        self._first_try = True
        self._data = b''
        self._obj = zlib.decompressobj()

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        if not data:
            return data

        if not self._first_try:
            return self._obj.decompress(data)

        self._data += data
        try:
            decompressed = self._obj.decompress(data)
            if decompressed:
                self._first_try = False
                self._data = None
            return decompressed
        except zlib.error:
            self._first_try = False
            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
            try:
                return self.decompress(self._data)
            finally:
                self._data = None


class GzipDecoderState(object):

    FIRST_MEMBER = 0
    OTHER_MEMBERS = 1
    SWALLOW_DATA = 2


class GzipDecoder(object):

    def __init__(self):
        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
        self._state = GzipDecoderState.FIRST_MEMBER

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        ret = bytearray()
        if self._state == GzipDecoderState.SWALLOW_DATA or not data:
            return bytes(ret)
        while True:
            try:
                ret += self._obj.decompress(data)
            except zlib.error:
                previous_state = self._state
                # Ignore data after the first error
                self._state = GzipDecoderState.SWALLOW_DATA
                if previous_state == GzipDecoderState.OTHER_MEMBERS:
                    # Allow trailing garbage acceptable in other gzip clients
                    return bytes(ret)
                raise
            data = self._obj.unused_data
            if not data:
                return bytes(ret)
            self._state = GzipDecoderState.OTHER_MEMBERS
            self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)


if brotli is not None:
    class BrotliDecoder(object):
        # Supports both 'brotlipy' and 'Brotli' packages
        # since they share an import name. The top branches
        # are for 'brotlipy' and bottom branches for 'Brotli'
        def __init__(self):
            self._obj = brotli.Decompressor()

        def decompress(self, data):
            if hasattr(self._obj, 'decompress'):
                return self._obj.decompress(data)
            return self._obj.process(data)

        def flush(self):
            if hasattr(self._obj, 'flush'):
                return self._obj.flush()
            return b''


class MultiDecoder(object):
    """"""
    From RFC7231:
        If one or more encodings have been applied to a representation, the
        sender that applied the encodings MUST generate a Content-Encoding
        header field that lists the content codings in the order in which
        they were applied.
    """"""

    def __init__(self, modes):
        self._decoders = [_get_decoder(m.strip()) for m in modes.split(',')]

    def flush(self):
        return self._decoders[0].flush()

    def decompress(self, data):
        for d in reversed(self._decoders):
            data = d.decompress(data)
        return data


def _get_decoder(mode):
    if ',' in mode:
        return MultiDecoder(mode)

    if mode == 'gzip':
        return GzipDecoder()

    if brotli is not None and mode == 'br':
        return BrotliDecoder()

    return DeflateDecoder()


class HTTPResponse(io.IOBase):
    """"""
    HTTP Response container.

    Backwards-compatible to httplib's HTTPResponse but the response ``body`` is
    loaded and decoded on-demand when the ``data`` property is accessed.  This
    class is also compatible with the Python standard library's :mod:`io`
    module, and can hence be treated as a readable object in the context of that
    framework.

    Extra parameters for behaviour not present in httplib.HTTPResponse:

    :param preload_content:
        If True, the response's body will be preloaded during construction.

    :param decode_content:
        If True, will attempt to decode the body based on the
        'content-encoding' header.

    :param original_response:
        When this HTTPResponse wrapper is generated from an httplib.HTTPResponse
        object, it's convenient to include the original for debug purposes. It's
        otherwise unused.

    :param retries:
        The retries contains the last :class:`~urllib3.util.retry.Retry` that
        was used during the request.

    :param enforce_content_length:
        Enforce content length checking. Body returned by server must match
        value of Content-Length header, if present. Otherwise, raise error.
    """"""

    CONTENT_DECODERS = ['gzip', 'deflate']
    if brotli is not None:
        CONTENT_DECODERS += ['br']
    REDIRECT_STATUSES = [301, 302, 303, 307, 308]

    def __init__(self, body='', headers=None, status=0, version=0, reason=None,
                 strict=0, preload_content=True, decode_content=True,
                 original_response=None, pool=None, connection=None, msg=None,
                 retries=None, enforce_content_length=False,
                 request_method=None, request_url=None):

        if isinstance(headers, HTTPHeaderDict):
            self.headers = headers
        else:
            self.headers = HTTPHeaderDict(headers)
        self.status = status
        self.version = version
        self.reason = reason
        self.strict = strict
        self.decode_content = decode_content
        self.retries = retries
        self.enforce_content_length = enforce_content_length

        self._decoder = None
        self._body = None
        self._fp = None
        self._original_response = original_response
        self._fp_bytes_read = 0
        self.msg = msg
        self._request_url = request_url

        if body and isinstance(body, (basestring, bytes)):
            self._body = body

        self._pool = pool
        self._connection = connection

        if hasattr(body, 'read'):
            self._fp = body

        # Are we using the chunked-style of transfer encoding?
        self.chunked = False
        self.chunk_left = None
        tr_enc = self.headers.get('transfer-encoding', '').lower()
        # Don't incur the penalty of creating a list and then discarding it
        encodings = (enc.strip() for enc in tr_enc.split("",""))
        if ""chunked"" in encodings:
            self.chunked = True

        # Determine length of response
        self.length_remaining = self._init_length(request_method)

        # If requested, preload the body.
        if preload_content and not self._body:
            self._body = self.read(decode_content=decode_content)

    def get_redirect_location(self):
        """"""
        Should we redirect and where to?

        :returns: Truthy redirect location string if we got a redirect status
            code and valid location. ``None`` if redirect status and no
            location. ``False`` if not a redirect status code.
        """"""
        if self.status in self.REDIRECT_STATUSES:
            return self.headers.get('location')

        return False

    def release_conn(self):
        if not self._pool or not self._connection:
            return

        self._pool._put_conn(self._connection)
        self._connection = None

    @property
    def data(self):
        # For backwords-compat with earlier urllib3 0.4 and earlier.
        if self._body:
            return self._body

        if self._fp:
            return self.read(cache_content=True)

    @property
    def connection(self):
        return self._connection

    def isclosed(self):
        return is_fp_closed(self._fp)

    def tell(self):
        """"""
        Obtain the number of bytes pulled over the wire so far. May differ from
        the amount of content returned by :meth:``HTTPResponse.read`` if bytes
        are encoded on the wire (e.g, compressed).
        """"""
        return self._fp_bytes_read

    def _init_length(self, request_method):
        """"""
        Set initial length value for Response content if available.
        """"""
        length = self.headers.get('content-length')

        if length is not None:
            if self.chunked:
                # This Response will fail with an IncompleteRead if it can't be
                # received as chunked. This method falls back to attempt reading
                # the response before raising an exception.
                log.warning(""Received response with both Content-Length and ""
                            ""Transfer-Encoding set. This is expressly forbidden ""
                            ""by RFC 7230 sec 3.3.2. Ignoring Content-Length and ""
                            ""attempting to process response as Transfer-Encoding: ""
                            ""chunked."")
                return None

            try:
                # RFC 7230 section 3.3.2 specifies multiple content lengths can
                # be sent in a single Content-Length header
                # (e.g. Content-Length: 42, 42). This line ensures the values
                # are all valid ints and that as long as the `set` length is 1,
                # all values are the same. Otherwise, the header is invalid.
                lengths = set([int(val) for val in length.split(',')])
                if len(lengths) > 1:
                    raise InvalidHeader(""Content-Length contained multiple ""
                                        ""unmatching values (%s)"" % length)
                length = lengths.pop()
            except ValueError:
                length = None
            else:
                if length < 0:
                    length = None

        # Convert status to int for comparison
        # In some cases, httplib returns a status of ""_UNKNOWN""
        try:
            status = int(self.status)
        except ValueError:
            status = 0

        # Check for responses that shouldn't include a body
        if status in (204, 304) or 100 <= status < 200 or request_method == 'HEAD':
            length = 0

        return length

    def _init_decoder(self):
        """"""
        Set-up the _decoder attribute if necessary.
        """"""
        # Note: content-encoding value should be case-insensitive, per RFC 7230
        # Section 3.2
        content_encoding = self.headers.get('content-encoding', '').lower()
        if self._decoder is None:
            if content_encoding in self.CONTENT_DECODERS:
                self._decoder = _get_decoder(content_encoding)
            elif ',' in content_encoding:
                encodings = [
                    e.strip() for e in content_encoding.split(',')
                    if e.strip() in self.CONTENT_DECODERS]
                if len(encodings):
                    self._decoder = _get_decoder(content_encoding)

    DECODER_ERROR_CLASSES = (IOError, zlib.error)
    if brotli is not None:
        DECODER_ERROR_CLASSES += (brotli.error,)

    def _decode(self, data, decode_content, flush_decoder):
        """"""
        Decode the data passed in and potentially flush the decoder.
        """"""
        if not decode_content:
            return data

        try:
            if self._decoder:
                data = self._decoder.decompress(data)
        except self.DECODER_ERROR_CLASSES as e:
            content_encoding = self.headers.get('content-encoding', '').lower()
            raise DecodeError(
                ""Received response with content-encoding: %s, but ""
                ""failed to decode it."" % content_encoding, e)
        if flush_decoder:
            data += self._flush_decoder()

        return data

    def _flush_decoder(self):
        """"""
        Flushes the decoder. Should only be called if the decoder is actually
        being used.
        """"""
        if self._decoder:
            buf = self._decoder.decompress(b'')
            return buf + self._decoder.flush()

        return b''

    @contextmanager
    def _error_catcher(self):
        """"""
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.

        On exit, release the connection back to the pool.
        """"""
        clean_exit = False

        try:
            try:
                yield

            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if 'read operation timed out' not in str(e):  # Defensive:
                    # This shouldn't happen but just in case we're missing an edge
                    # case, let's avoid swallowing SSL errors.
                    raise

                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
                raise ProtocolError('Connection broken: %r' % e, e)

            # If no exception is thrown, we should avoid cleaning up
            # unnecessarily.
            clean_exit = True
        finally:
            # If we didn't terminate cleanly, we need to throw away our
            # connection.
            if not clean_exit:
                # The response may not be closed but we're not going to use it
                # anymore so close it now to ensure that the connection is
                # released back to the pool.
                if self._original_response:
                    self._original_response.close()

                # Closing the response may not actually be sufficient to close
                # everything, so if we have a hold of the connection close that
                # too.
                if self._connection:
                    self._connection.close()

            # If we hold the original response but it's closed now, we should
            # return the connection back to the pool.
            if self._original_response and self._original_response.isclosed():
                self.release_conn()

    def read(self, amt=None, decode_content=None, cache_content=False):
        """"""
        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional
        parameters: ``decode_content`` and ``cache_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.

        :param cache_content:
            If True, will save the returned data such that the same result is
            returned despite of the state of the underlying file object. This
            is useful if you want the ``.data`` property to continue working
            after having ``.read()`` the file object. (Overridden if ``amt`` is
            set.)
        """"""
        self._init_decoder()
        if decode_content is None:
            decode_content = self.decode_content

        if self._fp is None:
            return

        flush_decoder = False
        data = None

        with self._error_catcher():
            if amt is None:
                # cStringIO doesn't like amt=None
                data = self._fp.read()
                flush_decoder = True
            else:
                cache_content = False
                data = self._fp.read(amt)
                if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.
                    # Close the connection when no data is returned
                    #
                    # This is redundant to what httplib/http.client _should_
                    # already do.  However, versions of python released before
                    # December 15, 2012 (http://bugs.python.org/issue16298) do
                    # not properly close the connection in all cases. There is
                    # no harm in redundantly calling close.
                    self._fp.close()
                    flush_decoder = True
                    if self.enforce_content_length and self.length_remaining not in (0, None):
                        # This is an edge case that httplib failed to cover due
                        # to concerns of backward compatibility. We're
                        # addressing it here to make sure IncompleteRead is
                        # raised during streaming, so all calls with incorrect
                        # Content-Length are caught.
                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)

        if data:
            self._fp_bytes_read += len(data)
            if self.length_remaining is not None:
                self.length_remaining -= len(data)

            data = self._decode(data, decode_content, flush_decoder)

            if cache_content:
                self._body = data

        return data

    def stream(self, amt=2**16, decode_content=None):
        """"""
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.

        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        if self.chunked and self.supports_chunked_reads():
            for line in self.read_chunked(amt, decode_content=decode_content):
                yield line
        else:
            while not is_fp_closed(self._fp):
                data = self.read(amt=amt, decode_content=decode_content)

                if data:
                    yield data

    @classmethod
    def from_httplib(ResponseCls, r, **response_kw):
        """"""
        Given an :class:`httplib.HTTPResponse` instance ``r``, return a
        corresponding :class:`urllib3.response.HTTPResponse` object.

        Remaining parameters are passed to the HTTPResponse constructor, along
        with ``original_response=r``.
        """"""
        headers = r.msg

        if not isinstance(headers, HTTPHeaderDict):
            if PY3:
                headers = HTTPHeaderDict(headers.items())
            else:
                # Python 2.7
                headers = HTTPHeaderDict.from_httplib(headers)

        # HTTPResponse objects in Python 3 don't have a .strict attribute
        strict = getattr(r, 'strict', 0)
        resp = ResponseCls(body=r,
                           headers=headers,
                           status=r.status,
                           version=r.version,
                           reason=r.reason,
                           strict=strict,
                           original_response=r,
                           **response_kw)
        return resp

    # Backwards-compatibility methods for httplib.HTTPResponse
    def getheaders(self):
        return self.headers

    def getheader(self, name, default=None):
        return self.headers.get(name, default)

    # Backwards compatibility for http.cookiejar
    def info(self):
        return self.headers

    # Overrides from io.IOBase
    def close(self):
        if not self.closed:
            self._fp.close()

        if self._connection:
            self._connection.close()

    @property
    def closed(self):
        if self._fp is None:
            return True
        elif hasattr(self._fp, 'isclosed'):
            return self._fp.isclosed()
        elif hasattr(self._fp, 'closed'):
            return self._fp.closed
        else:
            return True

    def fileno(self):
        if self._fp is None:
            raise IOError(""HTTPResponse has no file to get a fileno from"")
        elif hasattr(self._fp, ""fileno""):
            return self._fp.fileno()
        else:
            raise IOError(""The file-like object this HTTPResponse is wrapped ""
                          ""around has no file descriptor"")

    def flush(self):
        if self._fp is not None and hasattr(self._fp, 'flush'):
            return self._fp.flush()

    def readable(self):
        # This method is required for `io` module compatibility.
        return True

    def readinto(self, b):
        # This method is required for `io` module compatibility.
        temp = self.read(len(b))
        if len(temp) == 0:
            return 0
        else:
            b[:len(temp)] = temp
            return len(temp)

    def supports_chunked_reads(self):
        """"""
        Checks if the underlying file-like object looks like a
        httplib.HTTPResponse object. We do this by testing for the fp
        attribute. If it is present we assume it returns raw chunks as
        processed by read_chunked().
        """"""
        return hasattr(self._fp, 'fp')

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b';', 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
            raise httplib.IncompleteRead(line)

    def _handle_chunk(self, amt):
        returned_chunk = None
        if amt is None:
            chunk = self._fp._safe_read(self.chunk_left)
            returned_chunk = chunk
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        elif amt < self.chunk_left:
            value = self._fp._safe_read(amt)
            self.chunk_left = self.chunk_left - amt
            returned_chunk = value
        elif amt == self.chunk_left:
            value = self._fp._safe_read(amt)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
            returned_chunk = value
        else:  # amt > self.chunk_left
            returned_chunk = self._fp._safe_read(self.chunk_left)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        return returned_chunk

    def read_chunked(self, amt=None, decode_content=None):
        """"""
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                ""Response is not chunked. ""
                ""Header 'transfer-encoding: chunked' is missing."")
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                ""Body should be httplib.HTTPResponse like. ""
                ""It should have have an fp attribute which returns raw chunks."")

        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return

            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return

            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(chunk, decode_content=decode_content,
                                       flush_decoder=False)
                if decoded:
                    yield decoded

            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded

            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b'\r\n':
                    break

            # We read everything; close the ""file"".
            if self._original_response:
                self._original_response.close()

    def geturl(self):
        """"""
        Returns the URL that was the source of this response.
        If the request that generated this response redirected, this method
        will return the final redirect location.
        """"""
        if self.retries is not None and len(self.retries.history):
            return self.retries.history[-1].redirect_location
        else:
            return self._request_url

    def __iter__(self):
        buffer = [b""""]
        for chunk in self.stream(decode_content=True):
            if b""\n"" in chunk:
                chunk = chunk.split(b""\n"")
                yield b"""".join(buffer) + chunk[0] + b""\n""
                for x in chunk[1:-1]:
                    yield x + b""\n""
                if chunk[-1]:
                    buffer = [chunk[-1]]
                else:
                    buffer = []
            else:
                buffer.append(chunk)
        if buffer:
            yield b"""".join(buffer)",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR: VAR = VAR VAR .VAR VAR VAR VAR .VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR ) VAR .VAR.VAR VAR VAR VAR VAR, VAR VAR .VAR.VAR.VAR VAR VAR VAR VAR VAR .VAR VAR VAR, VAR VAR .VAR.VAR VAR VAR, VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR) VAR.VAR += VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR: VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR VAR.VAR = VAR.VAR(-VAR.VAR) VAR: VAR VAR.VAR(VAR.VAR) VAR: VAR.VAR = VAR VAR VAR(VAR): VAR = 0 VAR = 1 VAR = 2 VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR.VAR = VAR.VAR VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR = VAR() VAR VAR.VAR == VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR VAR: VAR: VAR += VAR.VAR.VAR(VAR) VAR VAR.VAR: VAR = VAR.VAR  VAR.VAR = VAR.VAR VAR VAR == VAR.VAR:  VAR VAR(VAR) VAR VAR = VAR.VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR.VAR = VAR.VAR VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR VAR VAR VAR VAR: VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR(VAR) VAR VAR.VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR'' VAR VAR(VAR): """""" VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = [VAR(VAR.VAR()) VAR VAR VAR VAR.VAR(',')] VAR VAR(VAR): VAR VAR.VAR[0].VAR() VAR VAR(VAR, VAR): VAR VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR ',' VAR VAR: VAR VAR(VAR) VAR VAR == 'VAR': VAR VAR() VAR VAR VAR VAR VAR VAR VAR == 'VAR': VAR VAR() VAR VAR() VAR VAR(VAR.VAR): """""" VAR VAR VAR. VAR-VAR VAR VAR'VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR-VAR VAR VAR ``VAR`` VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR :VAR:`VAR` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR.VAR: :VAR VAR: VAR VAR, VAR VAR'VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR'VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR, VAR VAR. VAR, VAR VAR. """""" VAR = ['VAR', 'VAR'] VAR VAR VAR VAR VAR: VAR += ['VAR'] VAR = [301, 302, 303, 307, 308] VAR VAR(VAR, VAR='', VAR=VAR, VAR=0, VAR=0, VAR=VAR, VAR=0, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR VAR(VAR, VAR): VAR.VAR = VAR VAR: VAR.VAR = VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR(VAR, (VAR, VAR)): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, 'VAR'): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR VAR = VAR.VAR.VAR('VAR-VAR', '').VAR()  VAR = (VAR.VAR() VAR VAR VAR VAR.VAR("","")) VAR ""VAR"" VAR VAR: VAR.VAR = VAR  VAR.VAR = VAR.VAR(VAR)  VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR.VAR(VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR? :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR.VAR('VAR') VAR VAR VAR VAR(VAR): VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR.VAR) VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR VAR.VAR: VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR(VAR=VAR) @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:``VAR.VAR`` VAR VAR VAR VAR VAR VAR VAR (VAR.VAR, VAR). """""" VAR VAR.VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR') VAR VAR VAR VAR VAR: VAR VAR.VAR:    VAR.VAR(""VAR VAR VAR VAR VAR-VAR VAR "" ""VAR-VAR VAR. VAR VAR VAR VAR "" ""VAR VAR 7230 VAR 3.3.2. VAR VAR-VAR VAR "" ""VAR VAR VAR VAR VAR VAR-VAR: "" ""VAR."") VAR VAR VAR:      VAR = VAR([VAR(VAR) VAR VAR VAR VAR.VAR(',')]) VAR VAR(VAR) > 1: VAR VAR(""VAR-VAR VAR VAR "" ""VAR VAR (%VAR)"" % VAR) VAR = VAR.VAR() VAR VAR: VAR = VAR VAR: VAR VAR < 0: VAR = VAR   VAR: VAR = VAR(VAR.VAR) VAR VAR: VAR = 0  VAR VAR VAR (204, 304) VAR 100 <= VAR < 200 VAR VAR == 'VAR': VAR = 0 VAR VAR VAR VAR(VAR): """""" VAR-VAR VAR VAR VAR VAR VAR. """"""   VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR.VAR VAR VAR: VAR VAR VAR VAR.VAR: VAR.VAR = VAR(VAR) VAR ',' VAR VAR: VAR = [ VAR.VAR() VAR VAR VAR VAR.VAR(',') VAR VAR.VAR() VAR VAR.VAR] VAR VAR(VAR): VAR.VAR = VAR(VAR) VAR = (VAR, VAR.VAR) VAR VAR VAR VAR VAR: VAR += (VAR.VAR,) VAR VAR(VAR, VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR VAR: VAR VAR VAR: VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR.VAR VAR VAR: VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR( ""VAR VAR VAR VAR-VAR: %VAR, VAR "" ""VAR VAR VAR VAR."" % VAR, VAR) VAR VAR: VAR += VAR.VAR() VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR'') VAR VAR + VAR.VAR.VAR() VAR VAR'' @VAR VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR, VAR VAR-VAR VAR VAR, VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR VAR: VAR: VAR VAR VAR:   VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR VAR VAR VAR:  VAR 'VAR VAR VAR VAR' VAR VAR VAR(VAR):    VAR VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR (VAR, VAR) VAR VAR:  VAR VAR('VAR VAR: %VAR' % VAR, VAR)   VAR = VAR VAR:   VAR VAR VAR:    VAR VAR.VAR: VAR.VAR.VAR()    VAR VAR.VAR: VAR.VAR.VAR()   VAR VAR.VAR VAR VAR.VAR.VAR(): VAR.VAR() VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR`` VAR ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR ``.VAR`` VAR VAR VAR VAR VAR VAR ``.VAR()`` VAR VAR VAR. (VAR VAR ``VAR`` VAR VAR.) """""" VAR.VAR() VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR.VAR VAR VAR: VAR VAR = VAR VAR = VAR VAR VAR.VAR(): VAR VAR VAR VAR:  VAR = VAR.VAR.VAR() VAR = VAR VAR: VAR = VAR VAR = VAR.VAR.VAR(VAR) VAR VAR != 0 VAR VAR VAR:         VAR.VAR.VAR() VAR = VAR VAR VAR.VAR VAR VAR.VAR VAR VAR (0, VAR):      VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR += VAR(VAR) VAR VAR.VAR VAR VAR VAR: VAR.VAR -= VAR(VAR) VAR = VAR.VAR(VAR, VAR, VAR) VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=2**16, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR() VAR. VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR VAR.VAR VAR VAR.VAR(): VAR VAR VAR VAR.VAR(VAR, VAR=VAR): VAR VAR VAR: VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR=VAR, VAR=VAR) VAR VAR: VAR VAR @VAR VAR VAR(VAR, VAR, **VAR): """""" VAR VAR :VAR:`VAR.VAR` VAR ``VAR``, VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR ``VAR=VAR``. """""" VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR VAR: VAR = VAR(VAR.VAR()) VAR:  VAR = VAR.VAR(VAR)  VAR = VAR(VAR, 'VAR', 0) VAR = VAR(VAR=VAR, VAR=VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR, **VAR) VAR VAR  VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR, VAR, VAR=VAR): VAR VAR.VAR.VAR(VAR, VAR)  VAR VAR(VAR): VAR VAR.VAR  VAR VAR(VAR): VAR VAR VAR.VAR: VAR.VAR.VAR() VAR VAR.VAR: VAR.VAR.VAR() @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR VAR: VAR VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR: VAR VAR(""VAR VAR-VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR"") VAR VAR(VAR): VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR):  VAR VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR(VAR(VAR)) VAR VAR(VAR) == 0: VAR 0 VAR: VAR[:VAR(VAR)] = VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR.VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR(). """""" VAR VAR(VAR.VAR, 'VAR') VAR VAR(VAR):   VAR VAR.VAR VAR VAR VAR: VAR VAR = VAR.VAR.VAR.VAR() VAR = VAR.VAR(VAR';', 1)[0] VAR: VAR.VAR = VAR(VAR, 16) VAR VAR:  VAR.VAR() VAR VAR.VAR(VAR) VAR VAR(VAR, VAR): VAR = VAR VAR VAR VAR VAR: VAR = VAR.VAR.VAR(VAR.VAR) VAR = VAR VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR < VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR = VAR.VAR - VAR VAR = VAR VAR VAR == VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR = VAR VAR:  VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR.VAR()  VAR VAR VAR.VAR: VAR VAR( ""VAR VAR VAR VAR. "" ""VAR 'VAR-VAR: VAR' VAR VAR."") VAR VAR VAR.VAR(): VAR VAR( ""VAR VAR VAR VAR.VAR VAR. "" ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR.VAR():  VAR VAR.VAR VAR VAR(VAR.VAR): VAR.VAR.VAR() VAR   VAR VAR.VAR.VAR VAR VAR: VAR VAR VAR: VAR.VAR() VAR VAR.VAR == 0: VAR VAR = VAR.VAR(VAR) VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR: VAR VAR VAR VAR:    VAR = VAR.VAR() VAR VAR:  VAR VAR  VAR VAR: VAR = VAR.VAR.VAR.VAR() VAR VAR VAR:  VAR VAR VAR == VAR'\VAR\VAR': VAR  VAR VAR.VAR: VAR.VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR.VAR): VAR VAR.VAR.VAR[-1].VAR VAR: VAR VAR.VAR VAR VAR(VAR): VAR = [VAR""""] VAR VAR VAR VAR.VAR(VAR=VAR): VAR VAR""\VAR"" VAR VAR: VAR = VAR.VAR(VAR""\VAR"") VAR VAR"""".VAR(VAR) + VAR[0] + VAR""\VAR"" VAR VAR VAR VAR[1:-1]: VAR VAR + VAR""\VAR"" VAR VAR[-1]: VAR = [VAR[-1]] VAR: VAR = [] VAR: VAR.VAR(VAR) VAR VAR: VAR VAR"""".VAR(VAR) ",1
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/test_response.py,"import socket
import zlib

from io import BytesIO, BufferedReader

import pytest
import mock

from urllib3.response import HTTPResponse, brotli
from urllib3.exceptions import (
    DecodeError, ResponseNotChunked, ProtocolError, InvalidHeader
)
from urllib3.packages.six.moves import http_client as httplib
from urllib3.util.retry import Retry, RequestHistory
from urllib3.util.response import is_fp_closed

from test import onlyBrotlipy

from base64 import b64decode

# A known random (i.e, not-too-compressible) payload generated with:
#    """".join(random.choice(string.printable) for i in xrange(512))
#    .encode(""zlib"").encode(""base64"")
# Randomness in tests == bad, and fixing a seed may not be sufficient.
ZLIB_PAYLOAD = b64decode(b""""""\
eJwFweuaoQAAANDfineQhiKLUiaiCzvuTEmNNlJGiL5QhnGpZ99z8luQfe1AHoMioB+QSWHQu/L+
lzd7W5CipqYmeVTBjdgSATdg4l4Z2zhikbuF+EKn69Q0DTpdmNJz8S33odfJoVEexw/l2SS9nFdi
pis7KOwXzfSqarSo9uJYgbDGrs1VNnQpT9f8zAorhYCEZronZQF9DuDFfNK3Hecc+WHLnZLQptwk
nufw8S9I43sEwxsT71BiqedHo0QeIrFE01F/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/nNvDGKZ
Khe5TF36JbnKVjdcL1EUNpwrWVfQpFYJ/WWm2b74qNeSZeQv5/xBhRdOmKTJFYgO96PwrHBlsnLn
a3l0LwJsloWpMbzByU5WLbRE6X5INFqjQOtIwYz5BAlhkn+kVqJvWM5vBlfrwP42ifonM5yF4ciJ
auHVks62997mNGOsM7WXNG3P98dBHPo2NhbTvHleL0BI5dus2JY81MUOnK3SGWLH8HeWPa1t5KcW
S5moAj5HexY/g/F8TctpxwsvyZp38dXeLDjSQvEQIkF7XR3YXbeZgKk3V34KGCPOAeeuQDIgyVhV
nP4HF2uWHA=="""""")


@pytest.fixture
def sock():
    s = socket.socket()
    yield s
    s.close()


class TestLegacyResponse(object):
    def test_getheaders(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheaders() == headers

    def test_getheader(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheader('host') == 'example.com'


class TestResponse(object):
    def test_cache_content(self):
        r = HTTPResponse('foo')
        assert r.data == 'foo'
        assert r._body == 'foo'

    def test_default(self):
        r = HTTPResponse()
        assert r.data is None

    def test_none(self):
        r = HTTPResponse(None)
        assert r.data is None

    def test_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=True)

        assert fp.tell() == len(b'foo')
        assert r.data == b'foo'

    def test_no_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=False)

        assert fp.tell() == 0
        assert r.data == b'foo'
        assert fp.tell() == len(b'foo')

    def test_decode_bad_data(self):
        fp = BytesIO(b'\x00' * 10)
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'deflate'})

    def test_reference_read(self):
        fp = BytesIO(b'foo')
        r = HTTPResponse(fp, preload_content=False)

        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'})

        assert r.data == b'foo'

    def test_decode_deflate_case_insensitve(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'DeFlAtE'})

        assert r.data == b'foo'

    def test_chunked_decoding_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(3) == b''
        # Buffer in case we need to switch to the raw stream
        assert r._decoder._data is not None
        assert r.read(1) == b'f'
        # Now that we've decoded data, we just stream through the decoder
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_deflate2(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(1) == b''
        assert r.read(1) == b'f'
        # Once we've decoded data, we just stream to the decoder; no buffering
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                         preload_content=False)

        assert r.read(11) == b''
        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_gzip_multi_member(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    def test_decode_gzip_error(self):
        fp = BytesIO(b'foo')
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'gzip'})

    def test_decode_gzip_swallow_garbage(self):
        # When data comes from multiple calls to read(), data after
        # the first zlib error (here triggered by garbage) should be
        # ignored.
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={'content-encoding': 'gzip'}, preload_content=False)
        ret = b''
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break

        assert ret == b'foofoofoo'

    def test_chunked_decoding_gzip_swallow_garbage(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    @onlyBrotlipy()
    def test_decode_brotli(self):
        data = brotli.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'br'})
        assert r.data == b'foo'

    @onlyBrotlipy()
    def test_chunked_decoding_brotli(self):
        data = brotli.compress(b'foobarbaz')

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={'content-encoding': 'br'}, preload_content=False)

        ret = b''
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break
        assert ret == b'foobarbaz'

    @onlyBrotlipy()
    def test_decode_brotli_error(self):
        fp = BytesIO(b'foo')
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'br'})

    def test_multi_decoding_deflate_deflate(self):
        data = zlib.compress(zlib.compress(b'foo'))

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, deflate'})

        assert r.data == b'foo'

    def test_multi_decoding_deflate_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(zlib.compress(b'foo'))
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, gzip'})

        assert r.data == b'foo'

    def test_multi_decoding_gzip_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(data)
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip, gzip'})

        assert r.data == b'foo'

    def test_body_blob(self):
        resp = HTTPResponse(b'foo')
        assert resp.data == b'foo'
        assert resp.closed

    def test_io(self, sock):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)

        assert not resp.closed
        assert resp.readable()
        assert not resp.writable()
        with pytest.raises(IOError):
            resp.fileno()

        resp.close()
        assert resp.closed

        # Try closing with an `httplib.HTTPResponse`, because it has an
        # `isclosed` method.
        try:
            hlr = httplib.HTTPResponse(sock)
            resp2 = HTTPResponse(hlr, preload_content=False)
            assert not resp2.closed
            resp2.close()
            assert resp2.closed
        finally:
            hlr.close()

        # also try when only data is present.
        resp3 = HTTPResponse('foodata')
        with pytest.raises(IOError):
            resp3.fileno()

        resp3._fp = 2
        # A corner case where _fp is present but doesn't have `closed`,
        # `isclosed`, or `fileno`.  Unlikely, but possible.
        assert resp3.closed
        with pytest.raises(IOError):
            resp3.fileno()

    def test_io_closed_consistently(self, sock):
        try:
            hlr = httplib.HTTPResponse(sock)
            hlr.fp = BytesIO(b'foo')
            hlr.chunked = 0
            hlr.length = 3
            with HTTPResponse(hlr, preload_content=False) as resp:
                assert not resp.closed
                assert not resp._fp.isclosed()
                assert not is_fp_closed(resp._fp)
                assert not resp.isclosed()
                resp.read()
                assert resp.closed
                assert resp._fp.isclosed()
                assert is_fp_closed(resp._fp)
                assert resp.isclosed()
        finally:
            hlr.close()

    def test_io_bufferedreader(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp)

        assert br.read() == b'foo'

        br.close()
        assert resp.closed

        b = b'fooandahalf'
        fp = BytesIO(b)
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp, 5)

        br.read(1)  # sets up the buffer, reading 5
        assert len(fp.read()) == (len(b) - 5)

        # This is necessary to make sure the ""no bytes left"" part of `readinto`
        # gets tested.
        while not br.closed:
            br.read(5)

    def test_streaming(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_streaming_tell(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        position = 0

        position += len(next(stream))
        assert 2 == position
        assert position == resp.tell()

        position += len(next(stream))
        assert 3 == position
        assert position == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming_tell(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        uncompressed_data = b'foo'
        data = compress.compress(uncompressed_data)
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream()

        # Read everything
        payload = next(stream)
        assert payload == uncompressed_data

        assert len(data) == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate_streaming_tell_intermediate_point(self):
        # Ensure that ``tell()`` returns the correct number of bytes when
        # part-way through streaming compressed content.
        NUMBER_OF_READS = 10

        class MockCompressedDataReading(BytesIO):
            """"""
            A ByteIO-like reader returning ``payload`` in ``NUMBER_OF_READS``
            calls to ``read``.
            """"""

            def __init__(self, payload, payload_part_size):
                self.payloads = [
                    payload[i*payload_part_size:(i+1)*payload_part_size]
                    for i in range(NUMBER_OF_READS+1)]

                assert b"""".join(self.payloads) == payload

            def read(self, _):
                # Amount is unused.
                if len(self.payloads) > 0:
                    return self.payloads.pop(0)
                return b""""

        uncompressed_data = zlib.decompress(ZLIB_PAYLOAD)

        payload_part_size = len(ZLIB_PAYLOAD) // NUMBER_OF_READS
        fp = MockCompressedDataReading(ZLIB_PAYLOAD, payload_part_size)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream()

        parts_positions = [(part, resp.tell()) for part in stream]
        end_of_stream = resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

        parts, positions = zip(*parts_positions)

        # Check that the payload is equal to the uncompressed data
        payload = b"""".join(parts)
        assert uncompressed_data == payload

        # Check that the positions in the stream are correct
        expected = [(i+1)*payload_part_size for i in range(NUMBER_OF_READS)]
        assert expected == list(positions)

        # Check that the end of the stream is in the correct place
        assert len(ZLIB_PAYLOAD) == end_of_stream

    def test_deflate_streaming(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate2_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_empty_stream(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        with pytest.raises(StopIteration):
            next(stream)

    def test_length_no_header(self):
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        assert resp.length_remaining is None

    def test_length_w_valid_header(self):
        headers = {""content-length"": ""5""}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

    def test_length_w_bad_header(self):
        garbage = {'content-length': 'foo'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

        garbage['content-length'] = ""-10""
        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

    def test_length_when_chunked(self):
        # This is expressly forbidden in RFC 7230 sec 3.3.2
        # We fall back to chunked in this case and try to
        # handle response ignoring content length.
        headers = {'content-length': '5',
                   'transfer-encoding': 'chunked'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining is None

    def test_length_with_multiple_content_lengths(self):
        headers = {'content-length': '5, 5, 5'}
        garbage = {'content-length': '5, 42'}
        fp = BytesIO(b'abcde')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

        with pytest.raises(InvalidHeader):
            HTTPResponse(fp, headers=garbage, preload_content=False)

    def test_length_after_read(self):
        headers = {""content-length"": ""5""}

        # Test no defined length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        resp.read()
        assert resp.length_remaining is None

        # Test our update from content-length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        resp.read()
        assert resp.length_remaining == 0

        # Test partial read
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        data = resp.stream(2)
        next(data)
        assert resp.length_remaining == 3

    def test_mock_httpresponse_stream(self):
        # Mock out a HTTP Request that does enough to make it through urllib3's
        # read() and close() calls, and also exhausts and underlying file
        # object.
        class MockHTTPRequest(object):
            self.fp = None

            def read(self, amt):
                data = self.fp.read(amt)
                if not data:
                    self.fp = None

                return data

            def close(self):
                self.fp = None

        bio = BytesIO(b'foo')
        fp = MockHTTPRequest()
        fp.fp = bio
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_mock_transfer_encoding_chunked(self):
        stream = [b""fo"", b""o"", b""bar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})

        for i, c in enumerate(resp.stream()):
            assert c == stream[i]

    def test_mock_gzipped_transfer_encoding_chunked_decoded(self):
        """"""Show that we can decode the gizpped and chunked body.""""""
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b'foobar')
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i:i+2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {'transfer-encoding': 'chunked', 'content-encoding': 'gzip'}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b''
        for c in resp.stream(decode_content=True):
            data += c

        assert b'foobar' == data

    def test_mock_transfer_encoding_chunked_custom_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        expected_response = [b'fo', b'oo', b'o', b'bb', b'bb', b'aa', b'aa', b'ar']
        response = list(resp.read_chunked(2))
        assert expected_response == response

    def test_mock_transfer_encoding_chunked_unlmtd_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.read_chunked())

    def test_read_not_chunked_response_as_chunks(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        r = resp.read_chunked()
        with pytest.raises(ResponseNotChunked):
            next(r)

    def test_invalid_chunks(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedInvalidEncoding(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        with pytest.raises(ProtocolError):
            next(resp.read_chunked())

    def test_chunked_response_without_crlf_on_end(self):
        stream = [b""foo"", b""bar"", b""baz""]
        fp = MockChunkedEncodingWithoutCRLFOnEnd(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_response_with_extensions(self):
        stream = [b""foo"", b""bar""]
        fp = MockChunkedEncodingWithExtensions(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_head_response(self):
        r = httplib.HTTPResponse(MockSock, method='HEAD')
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse('',
                            preload_content=False,
                            headers={'transfer-encoding': 'chunked'},
                            original_response=r)
        assert resp.chunked is True

        resp.supports_chunked_reads = lambda: True
        resp.release_conn = mock.Mock()
        for _ in resp.stream():
            continue
        resp.release_conn.assert_called_once_with()

    def test_get_case_insensitive_headers(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.headers.get('host') == 'example.com'
        assert r.headers.get('Host') == 'example.com'

    def test_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp)
        assert resp.retries is None
        retry = Retry()
        resp = HTTPResponse(fp, retries=retry)
        assert resp.retries == retry

    def test_geturl(self):
        fp = BytesIO(b'')
        request_url = 'https://example.com'
        resp = HTTPResponse(fp, request_url=request_url)
        assert resp.geturl() == request_url

    def test_geturl_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, request_url='http://example.com')
        request_histories = [
            RequestHistory(method='GET', url='http://example.com', error=None,
                           status=301, redirect_location='https://example.com/'),
            RequestHistory(method='GET', url='https://example.com/', error=None,
                           status=301, redirect_location='https://www.example.com')]
        retry = Retry(history=request_histories)
        resp = HTTPResponse(fp, retries=retry)
        assert resp.geturl() == 'https://www.example.com'

    @pytest.mark.parametrize(
        [""payload"", ""expected_stream""],
        [(b"""", [b""""]),
         (b""\n"", [b""\n""]),
         (b""abc\ndef"", [b""abc\n"", b""def""]),
         (b""Hello\nworld\n\n\n!"", [b""Hello\n"", b""world\n"", b""\n"", b""\n"", b""!""])]
    )
    def test__iter__(self, payload, expected_stream):
        actual_stream = []
        for chunk in HTTPResponse(BytesIO(payload), preload_content=False):
            actual_stream.append(chunk)

        assert actual_stream == expected_stream

    def test__iter__decode_content(self):
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b'foo\nbar')
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i:i + 2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {'transfer-encoding': 'chunked', 'content-encoding': 'gzip'}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b''
        for c in resp:
            data += c

        assert b'foo\nbar' == data


class MockChunkedEncodingResponse(object):

    def __init__(self, content):
        """"""
        content: collection of str, each str is a chunk in response
        """"""
        self.content = content
        self.index = 0  # This class iterates over self.content.
        self.closed = False
        self.cur_chunk = b''
        self.chunks_exhausted = False

    @staticmethod
    def _encode_chunk(chunk):
        # In the general case, we can't decode the chunk to unicode
        length = '%X\r\n' % len(chunk)
        return length.encode() + chunk + b'\r\n'

    def _pop_new_chunk(self):
        if self.chunks_exhausted:
            return b""""
        try:
            chunk = self.content[self.index]
        except IndexError:
            chunk = b''
            self.chunks_exhausted = True
        else:
            self.index += 1
        chunk = self._encode_chunk(chunk)
        if not isinstance(chunk, bytes):
            chunk = chunk.encode()
        return chunk

    def pop_current_chunk(self, amt=-1, till_crlf=False):
        if amt > 0 and till_crlf:
            raise ValueError(""Can't specify amt and till_crlf."")
        if len(self.cur_chunk) <= 0:
            self.cur_chunk = self._pop_new_chunk()
        if till_crlf:
            try:
                i = self.cur_chunk.index(b""\r\n"")
            except ValueError:
                # No CRLF in current chunk -- probably caused by encoder.
                self.cur_chunk = b""""
                return b""""
            else:
                chunk_part = self.cur_chunk[:i+2]
                self.cur_chunk = self.cur_chunk[i+2:]
                return chunk_part
        elif amt <= -1:
            chunk_part = self.cur_chunk
            self.cur_chunk = b''
            return chunk_part
        else:
            try:
                chunk_part = self.cur_chunk[:amt]
            except IndexError:
                chunk_part = self.cur_chunk
                self.cur_chunk = b''
            else:
                self.cur_chunk = self.cur_chunk[amt:]
            return chunk_part

    def readline(self):
        return self.pop_current_chunk(till_crlf=True)

    def read(self, amt=-1):
        return self.pop_current_chunk(amt)

    def flush(self):
        # Python 3 wants this method.
        pass

    def close(self):
        self.closed = True


class MockChunkedInvalidEncoding(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return 'ZZZ\r\n%s\r\n' % chunk.decode()


class MockChunkedEncodingWithoutCRLFOnEnd(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X\r\n%s%s' % (len(chunk), chunk.decode(),
                               ""\r\n"" if len(chunk) > 0 else """")


class MockChunkedEncodingWithExtensions(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X;asd=qwe\r\n%s\r\n' % (len(chunk), chunk.decode())


class MockSock(object):
    @classmethod
    def makefile(cls, *args, **kwargs):
        return",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR ) VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR     VAR = VAR(VAR""""""\ VAR+VAR/VAR+ VAR+VAR/VAR VAR+VAR VAR/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/VAR VAR/VAR/VAR VAR+VAR VAR VAR/VAR/VAR VAR=="""""") @VAR.VAR VAR VAR(): VAR = VAR.VAR() VAR VAR VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR VAR(VAR): VAR = VAR('VAR') VAR VAR.VAR == 'VAR' VAR VAR.VAR == 'VAR' VAR VAR(VAR): VAR = VAR() VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 0 VAR VAR.VAR == VAR'VAR' VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR(VAR): VAR = VAR(VAR'\VAR' * 10) VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(3) == VAR''  VAR VAR.VAR.VAR VAR VAR VAR VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(1) == VAR'' VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(11) == VAR'' VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR):    VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR( VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' @VAR() VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' @VAR() VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR( VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR'VAR' @VAR() VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR VAR.VAR() VAR VAR VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR.VAR   VAR: VAR = VAR.VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR.VAR() VAR VAR.VAR VAR: VAR.VAR()  VAR = VAR('VAR') VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR = 2   VAR VAR.VAR VAR VAR.VAR(VAR): VAR.VAR() VAR VAR(VAR, VAR): VAR: VAR = VAR.VAR(VAR) VAR.VAR = VAR(VAR'VAR') VAR.VAR = 0 VAR.VAR = 3 VAR VAR(VAR, VAR=VAR) VAR VAR: VAR VAR VAR.VAR VAR VAR VAR.VAR.VAR() VAR VAR VAR(VAR.VAR) VAR VAR VAR.VAR() VAR.VAR() VAR VAR.VAR VAR VAR.VAR.VAR() VAR VAR(VAR.VAR) VAR VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR) VAR VAR.VAR() == VAR'VAR' VAR.VAR() VAR VAR.VAR VAR = VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR, 5) VAR.VAR(1)  VAR VAR(VAR.VAR()) == (VAR(VAR) - 5)   VAR VAR VAR.VAR: VAR.VAR(5) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR = 0 VAR += VAR(VAR(VAR)) VAR 2 == VAR VAR VAR == VAR.VAR() VAR += VAR(VAR(VAR)) VAR 3 == VAR VAR VAR == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR'VAR' VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR()  VAR = VAR(VAR) VAR VAR == VAR VAR VAR(VAR) == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR):   VAR = 10 VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR ``VAR`` VAR ``VAR`` VAR VAR ``VAR``. """""" VAR VAR(VAR, VAR, VAR): VAR.VAR = [ VAR[VAR*VAR:(VAR+1)*VAR] VAR VAR VAR VAR(VAR+1)] VAR VAR"""".VAR(VAR.VAR) == VAR VAR VAR(VAR, VAR):  VAR VAR(VAR.VAR) > 0: VAR VAR.VAR.VAR(0) VAR VAR"""" VAR = VAR.VAR(VAR) VAR = VAR(VAR)  VAR = VAR(VAR, VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR() VAR = [(VAR, VAR.VAR()) VAR VAR VAR VAR] VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR, VAR = VAR(*VAR)  VAR = VAR"""".VAR(VAR) VAR VAR == VAR  VAR = [(VAR+1)*VAR VAR VAR VAR VAR(VAR)] VAR VAR == VAR(VAR)  VAR VAR(VAR) == VAR VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR['VAR-VAR'] = ""-10"" VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR):    VAR = {'VAR-VAR': '5', 'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {'VAR-VAR': '5, 5, 5'} VAR = {'VAR-VAR': '5, 42'} VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR.VAR(VAR): VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""}  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR VAR VAR  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR == 0  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR(2) VAR(VAR) VAR VAR.VAR == 3 VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(VAR) VAR VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR): VAR.VAR = VAR VAR = VAR(VAR'VAR') VAR = VAR() VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR, VAR VAR VAR(VAR.VAR()): VAR VAR == VAR[VAR] VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR:VAR+2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': 'VAR'} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR.VAR(VAR=VAR): VAR += VAR VAR VAR'VAR' == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR = [VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR'] VAR = VAR(VAR.VAR(2)) VAR VAR == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR = VAR VAR.VAR = VAR VAR = VAR('', VAR=VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR VAR VAR VAR.VAR = VAR: VAR VAR.VAR = VAR.VAR() VAR VAR VAR VAR.VAR(): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR = VAR() VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = 'VAR: VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR='VAR: VAR = [ VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR = VAR(VAR=VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 'VAR: @VAR.VAR.VAR( [""VAR"", ""VAR""], [(VAR"""", [VAR""""]), (VAR""\VAR"", [VAR""\VAR""]), (VAR""VAR\VAR"", [VAR""VAR\VAR"", VAR""VAR""]), (VAR""VAR\VAR\VAR\VAR\VAR!"", [VAR""VAR\VAR"", VAR""VAR\VAR"", VAR""\VAR"", VAR""\VAR"", VAR""!""])] ) VAR VAR(VAR, VAR, VAR): VAR = [] VAR VAR VAR VAR(VAR(VAR), VAR=VAR): VAR.VAR(VAR) VAR VAR == VAR VAR VAR(VAR): VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR\VAR') VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR:VAR + 2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': 'VAR'} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR: VAR += VAR VAR VAR'VAR\VAR' == VAR VAR VAR(VAR): VAR VAR(VAR, VAR): """""" VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR """""" VAR.VAR = VAR VAR.VAR = 0  VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR = '%VAR\VAR\VAR' % VAR(VAR) VAR VAR.VAR() + VAR + VAR'\VAR\VAR' VAR VAR(VAR): VAR VAR.VAR: VAR VAR"""" VAR: VAR = VAR.VAR[VAR.VAR] VAR VAR: VAR = VAR'' VAR.VAR = VAR VAR: VAR.VAR += 1 VAR = VAR.VAR(VAR) VAR VAR VAR(VAR, VAR): VAR = VAR.VAR() VAR VAR VAR VAR(VAR, VAR=-1, VAR=VAR): VAR VAR > 0 VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR."") VAR VAR(VAR.VAR) <= 0: VAR.VAR = VAR.VAR() VAR VAR: VAR: VAR = VAR.VAR.VAR(VAR""\VAR\VAR"") VAR VAR:  VAR.VAR = VAR"""" VAR VAR"""" VAR: VAR = VAR.VAR[:VAR+2] VAR.VAR = VAR.VAR[VAR+2:] VAR VAR VAR VAR <= -1: VAR = VAR.VAR VAR.VAR = VAR'' VAR VAR VAR: VAR: VAR = VAR.VAR[:VAR] VAR VAR: VAR = VAR.VAR VAR.VAR = VAR'' VAR: VAR.VAR = VAR.VAR[VAR:] VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR=VAR) VAR VAR(VAR, VAR=-1): VAR VAR.VAR(VAR) VAR VAR(VAR):  VAR VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR): VAR VAR(VAR, VAR): VAR 'VAR\VAR\VAR%VAR\VAR\VAR' % VAR.VAR() VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR\VAR\VAR%VAR%VAR' % (VAR(VAR), VAR.VAR(), ""\VAR\VAR"" VAR VAR(VAR) > 0 VAR """") VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR;VAR=VAR\VAR\VAR%VAR\VAR\VAR' % (VAR(VAR), VAR.VAR()) VAR VAR(VAR): @VAR VAR VAR(VAR, *VAR, **VAR): VAR ",1
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/with_dummyserver/test_chunked_transfer.py,"# -*- coding: utf-8 -*-

from urllib3 import HTTPConnectionPool
from dummyserver.testcase import SocketDummyServerTestCase


class TestChunkedTransfer(SocketDummyServerTestCase):
    def start_chunked_handler(self):
        self.buffer = b''

        def socket_handler(listener):
            sock = listener.accept()[0]

            while not self.buffer.endswith(b'\r\n0\r\n\r\n'):
                self.buffer += sock.recv(65536)

            sock.send(
               b'HTTP/1.1 200 OK\r\n'
               b'Content-type: text/plain\r\n'
               b'Content-Length: 0\r\n'
               b'\r\n')
            sock.close()

        self._start_server(socket_handler)

    def test_chunks(self):
        self.start_chunked_handler()
        chunks = ['foo', 'bar', '', 'bazzzzzzzzzzzzzzzzzzzzzz']
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        pool.urlopen('GET', '/', chunks, headers=dict(DNT='1'), chunked=True)
        self.addCleanup(pool.close)

        self.assertIn(b'Transfer-Encoding', self.buffer)
        body = self.buffer.split(b'\r\n\r\n', 1)[1]
        lines = body.split(b'\r\n')
        # Empty chunks should have been skipped, as this could not be distinguished
        # from terminating the transmission
        for i, chunk in enumerate([c for c in chunks if c]):
            self.assertEqual(lines[i * 2], hex(len(chunk))[2:].encode('utf-8'))
            self.assertEqual(lines[i * 2 + 1], chunk.encode('utf-8'))

    def _test_body(self, data):
        self.start_chunked_handler()
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)

        pool.urlopen('GET', '/', data, chunked=True)
        header, body = self.buffer.split(b'\r\n\r\n', 1)

        self.assertIn(b'Transfer-Encoding: chunked', header.split(b'\r\n'))
        if data:
            bdata = data if isinstance(data, bytes) else data.encode('utf-8')
            self.assertIn(b'\r\n' + bdata + b'\r\n', body)
            self.assertTrue(body.endswith(b'\r\n0\r\n\r\n'))

            len_str = body.split(b'\r\n', 1)[0]
            stated_len = int(len_str, 16)
            self.assertEqual(stated_len, len(bdata))
        else:
            self.assertEqual(body, b'0\r\n\r\n')

    def test_bytestring_body(self):
        self._test_body(b'thisshouldbeonechunk\r\nasdf')

    def test_unicode_body(self):
        # Define u'thisshouldbeonechunk\r\n' in a way, so that python3.1
        # does not suffer a syntax error
        chunk = b'thisshouldbeonechunk\r\n\xc3\xa4\xc3\xb6\xc3\xbc\xc3\x9f'.decode('utf-8')
        self._test_body(chunk)

    def test_empty_body(self):
        self._test_body(None)

    def test_empty_string_body(self):
        self._test_body('')

    def test_empty_iterable_body(self):
        self._test_body([])

    def test_removes_duplicate_host_header(self):
        self.start_chunked_handler()
        chunks = ['foo', 'bar', '', 'bazzzzzzzzzzzzzzzzzzzzzz']
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.urlopen(
            'GET', '/', chunks, headers={'Host': 'test.org'}, chunked=True
        )

        header_block = self.buffer.split(b'\r\n\r\n', 1)[0].lower()
        header_lines = header_block.split(b'\r\n')[1:]

        host_headers = [x for x in header_lines if x.startswith(b'host')]
        self.assertEqual(len(host_headers), 1)

    def test_provides_default_host_header(self):
        self.start_chunked_handler()
        chunks = ['foo', 'bar', '', 'bazzzzzzzzzzzzzzzzzzzzzz']
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.urlopen('GET', '/', chunks, chunked=True)

        header_block = self.buffer.split(b'\r\n\r\n', 1)[0].lower()
        header_lines = header_block.split(b'\r\n')[1:]

        host_headers = [x for x in header_lines if x.startswith(b'host')]
        self.assertEqual(len(host_headers), 1)",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED," VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR'' VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR'): VAR.VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR() VAR = ['VAR', 'VAR', '', 'VAR'] VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR('VAR', '/', VAR, VAR=VAR(VAR='1'), VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR'VAR-VAR', VAR.VAR) VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1)[1] VAR = VAR.VAR(VAR'\VAR\VAR')   VAR VAR, VAR VAR VAR([VAR VAR VAR VAR VAR VAR VAR]): VAR.VAR(VAR[VAR * 2], VAR(VAR(VAR))[2:].VAR('VAR-8')) VAR.VAR(VAR[VAR * 2 + 1], VAR.VAR('VAR-8')) VAR VAR(VAR, VAR): VAR.VAR() VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR, VAR=VAR) VAR, VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1) VAR.VAR(VAR'VAR-VAR: VAR', VAR.VAR(VAR'\VAR\VAR')) VAR VAR: VAR = VAR VAR VAR(VAR, VAR) VAR VAR.VAR('VAR-8') VAR.VAR(VAR'\VAR\VAR' + VAR + VAR'\VAR\VAR', VAR) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR')) VAR = VAR.VAR(VAR'\VAR\VAR', 1)[0] VAR = VAR(VAR, 16) VAR.VAR(VAR, VAR(VAR)) VAR: VAR.VAR(VAR, VAR'0\VAR\VAR\VAR\VAR') VAR VAR(VAR): VAR.VAR(VAR'VAR\VAR\VAR') VAR VAR(VAR):   VAR = VAR'VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR'.VAR('VAR-8') VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR('') VAR VAR(VAR): VAR.VAR([]) VAR VAR(VAR): VAR.VAR() VAR = ['VAR', 'VAR', '', 'VAR'] VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR( 'VAR', '/', VAR, VAR={'VAR': 'VAR.VAR'}, VAR=VAR ) VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1)[0].VAR() VAR = VAR.VAR(VAR'\VAR\VAR')[1:] VAR = [VAR VAR VAR VAR VAR VAR VAR.VAR(VAR'VAR')] VAR.VAR(VAR(VAR), 1) VAR VAR(VAR): VAR.VAR() VAR = ['VAR', 'VAR', '', 'VAR'] VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR, VAR=VAR) VAR = VAR.VAR.VAR(VAR'\VAR\VAR\VAR\VAR', 1)[0].VAR() VAR = VAR.VAR(VAR'\VAR\VAR')[1:] VAR = [VAR VAR VAR VAR VAR VAR VAR.VAR(VAR'VAR')] VAR.VAR(VAR(VAR), 1) ",1

commit,file,added_code,deleted_code,hash_clean,cve_id,hash,repo_url,rel_type,score,extraction_status,text_norm,cluster_kmeans
airflow_ac65b82eeeeaa670e09a83c7da65cbac7e89f8db,tests/www/views/test_views_tasks.py,"def test_graph_view_without_dag_permission(app, one_dag_perm_user_client):
    url = ""/dags/example_bash_operator/graph""
    resp = one_dag_perm_user_client.get(url, follow_redirects=True)
    assert resp.status_code == 200
    assert resp.request.url == ""http://localhost/dags/example_bash_operator/graph""
    check_content_in_response(""example_bash_operator"", resp)

    url = ""/dags/example_xcom/graph""
    resp = one_dag_perm_user_client.get(url, follow_redirects=True)
    assert resp.status_code == 200
    assert resp.request.url == ""http://localhost/home""
    check_content_in_response(""Access is Denied"", resp)


@pytest.fixture()
def one_dag_perm_user_client(app):
    username = ""test_user_one_dag_perm""
    dag_id = ""example_bash_operator""
    sm = app.appbuilder.sm
    perm = f""{permissions.RESOURCE_DAG_PREFIX}{dag_id}""

    sm.create_permission(permissions.ACTION_CAN_READ, perm)

    create_user(
        app,
        username=username,
        role_name=""User with permission to access only one dag"",
        permissions=[
            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_INSTANCE),
            (permissions.ACTION_CAN_READ, permissions.RESOURCE_TASK_LOG),
            (permissions.ACTION_CAN_READ, permissions.RESOURCE_WEBSITE),
            (permissions.ACTION_CAN_READ, perm),
        ],
    )

    sm.find_user(username=username)

    yield client_with_login(
        app,
        username=username,
        password=username,
    )

    delete_user(app, username=username)  # type: ignore
    delete_roles(app)

",,ac65b82eeeeaa670e09a83c7da65cbac7e89f8db,CVE-2023-35908,ac65b82eeeeaa670e09a83c7da65cbac7e89f8db,https://github.com/apache/airflow,GHSD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR(VAR, VAR): VAR = ""/VAR/VAR/VAR"" VAR = VAR.VAR(VAR, VAR=VAR) VAR VAR.VAR == 200 VAR VAR.VAR.VAR == ""VAR: VAR(""VAR"", VAR) VAR = ""/VAR/VAR/VAR"" VAR = VAR.VAR(VAR, VAR=VAR) VAR VAR.VAR == 200 VAR VAR.VAR.VAR == ""VAR: VAR(""VAR VAR VAR"", VAR) @VAR.VAR() VAR VAR(VAR): VAR = ""VAR"" VAR = ""VAR"" VAR = VAR.VAR.VAR VAR = VAR""{VAR.VAR}{VAR}"" VAR.VAR(VAR.VAR, VAR) VAR( VAR, VAR=VAR, VAR=""VAR VAR VAR VAR VAR VAR VAR VAR"", VAR=[ (VAR.VAR, VAR.VAR), (VAR.VAR, VAR.VAR), (VAR.VAR, VAR.VAR), (VAR.VAR, VAR), ], ) VAR.VAR(VAR=VAR) VAR VAR( VAR, VAR=VAR, VAR=VAR, ) VAR(VAR, VAR=VAR)  VAR(VAR) ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,collector/scripts/yt_utils.py,"import json, requests, os, re
from slugify import slugify
from dotenv import load_dotenv
load_dotenv()

def is_yt_short(videoId):
    url = 'https://www.youtube.com/shorts/' + videoId
    ret = requests.head(url)
    return ret.status_code == 200

def get_channel_id(channel_link):
  if('@' in channel_link):
    pattern = r'https?://www\.youtube\.com/(@\w+)/?'
    match = re.match(pattern, channel_link)
    if match is False: return None
    handle = match.group(1)
    print('Need to map username to channelId - this can take a while sometimes.')
    response = requests.get(f""https://yt.lemnoslife.com/channels?handle={handle}"", timeout=20)

    if(response.ok == False):
      print(""Handle => ChannelId mapping endpoint is too slow - use regular youtube.com/channel URL"")
      return None

    json_data = response.json()
    return json_data.get('items')[0].get('id')
  else:
    pattern = r""youtube\.com/channel/([\w-]+)""
    match = re.search(pattern, channel_link)
    return match.group(1) if match else None


def clean_text(text):
  return re.sub(r""\[.*?\]"", """", text)

def append_meta(video, duration, text):
  meta = {
    'youtubeURL': f""https://youtube.com/watch?v={video.get('id')}"",
    'thumbnail': video.get('thumbnail'),
    'description': video.get('description'),
    'createdAt': video.get('published'),
    'videoDurationInSeconds': duration,
  }
  return ""Video JSON Metadata:\n""+json.dumps(meta, indent=4)+""\n\n\nAudio Transcript:\n"" + text

def get_duration(json_str):
  data = json.loads(json_str)
  return data[-1].get('start')

def fetch_channel_video_information(channel_id, windowSize = 50):
    if channel_id == None or len(channel_id) == 0:
      print(""No channel id provided!"")
      exit(1)

    if os.path.isdir(""./outputs/channel-logs"") == False:
      os.makedirs(""./outputs/channel-logs"")

    file_path = f""./outputs/channel-logs/channel-{channel_id}.json""
    if os.path.exists(file_path):
      with open(file_path, ""r"") as file:
        print(f""Returning cached data for channel {channel_id}. If you do not wish to use stored data then delete the file for this channel to allow refetching."")
        return json.load(file)

    if(os.getenv('GOOGLE_APIS_KEY') == None):
        print(""GOOGLE_APIS_KEY env variable not set!"")
        exit(1)

    done = False
    currentPage = None
    pageTokens = []
    items = []
    data = {
       'id': channel_id,
    }

    print(""Fetching first page of results..."")
    while(done == False):
        url = f""https://www.googleapis.com/youtube/v3/search?key={os.getenv('GOOGLE_APIS_KEY')}&channelId={channel_id}&part=snippet,id&order=date&type=video&maxResults={windowSize}""
        if(currentPage != None):
           print(f""Fetching page ${currentPage}"")
           url += f""&pageToken={currentPage}""

        req = requests.get(url)
        if(req.ok == False):
           print(""Could not fetch channel_id items!"")
           exit(1)

        response = req.json()
        currentPage = response.get('nextPageToken')
        if currentPage in pageTokens:
          print('All pages iterated and logged!')
          done = True
          break

        for item in response.get('items'):
          if 'id' in item and 'videoId' in item.get('id'):
            if is_yt_short(item.get('id').get('videoId')):
              print(f""Filtering out YT Short {item.get('id').get('videoId')}"")
              continue

            if data.get('channelTitle') is None:
              data['channelTitle'] = slugify(item.get('snippet').get('channelTitle'))

            newItem = {
              'id': item.get('id').get('videoId'),
              'url': f""https://youtube.com/watch?v={item.get('id').get('videoId')}"",
              'title': item.get('snippet').get('title'),
              'description':  item.get('snippet').get('description'),
              'thumbnail': item.get('snippet').get('thumbnails').get('high').get('url'),
              'published': item.get('snippet').get('publishTime'),
            }
            items.append(newItem)

        pageTokens.append(currentPage)

    data['items'] = items
    with open(file_path, 'w+', encoding='utf-8') as json_file:
      json.dump(data, json_file, ensure_ascii=True, indent=2)
      print(f""{len(items)} videos found for channel {data.get('channelTitle')}. Saved to channel-logs/channel-{channel_id}.json"")

    return data",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR, VAR, VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR() VAR VAR(VAR): VAR = 'VAR: VAR = VAR.VAR(VAR) VAR VAR.VAR == 200 VAR VAR(VAR): VAR('@' VAR VAR): VAR = VAR'VAR?: VAR = VAR.VAR(VAR, VAR) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR(1) VAR('VAR VAR VAR VAR VAR VAR - VAR VAR VAR VAR VAR VAR.') VAR = VAR.VAR(VAR""VAR: VAR(VAR.VAR == VAR): VAR(""VAR => VAR VAR VAR VAR VAR VAR - VAR VAR VAR.VAR/VAR VAR"") VAR VAR VAR = VAR.VAR() VAR VAR.VAR('VAR')[0].VAR('VAR') VAR: VAR = VAR""VAR\.VAR/VAR/([\VAR-]+)"" VAR = VAR.VAR(VAR, VAR) VAR VAR.VAR(1) VAR VAR VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR""\[.*?\]"", """", VAR) VAR VAR(VAR, VAR, VAR): VAR = { 'VAR': VAR""VAR: 'VAR': VAR.VAR('VAR'), 'VAR': VAR.VAR('VAR'), 'VAR': VAR.VAR('VAR'), 'VAR': VAR, } VAR ""VAR VAR VAR:\VAR""+VAR.VAR(VAR, VAR=4)+""\VAR\VAR\VAR VAR:\VAR"" + VAR VAR VAR(VAR): VAR = VAR.VAR(VAR) VAR VAR[-1].VAR('VAR') VAR VAR(VAR, VAR = 50): VAR VAR == VAR VAR VAR(VAR) == 0: VAR(""VAR VAR VAR VAR!"") VAR(1) VAR VAR.VAR.VAR(""./VAR/VAR-VAR"") == VAR: VAR.VAR(""./VAR/VAR-VAR"") VAR = VAR""./VAR/VAR-VAR/VAR-{VAR}.VAR"" VAR VAR.VAR.VAR(VAR): VAR VAR(VAR, ""VAR"") VAR VAR: VAR(VAR""VAR VAR VAR VAR VAR {VAR}. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR.VAR(VAR) VAR(VAR.VAR('VAR') == VAR): VAR(""VAR VAR VAR VAR VAR!"") VAR(1) VAR = VAR VAR = VAR VAR = [] VAR = [] VAR = { 'VAR': VAR, } VAR(""VAR VAR VAR VAR VAR..."") VAR(VAR == VAR): VAR = VAR""VAR: VAR(VAR != VAR): VAR(VAR""VAR VAR ${VAR}"") VAR += VAR""&VAR={VAR}"" VAR = VAR.VAR(VAR) VAR(VAR.VAR == VAR): VAR(""VAR VAR VAR VAR VAR!"") VAR(1) VAR = VAR.VAR() VAR = VAR.VAR('VAR') VAR VAR VAR VAR: VAR('VAR VAR VAR VAR VAR!') VAR = VAR VAR VAR VAR VAR VAR.VAR('VAR'): VAR 'VAR' VAR VAR VAR 'VAR' VAR VAR.VAR('VAR'): VAR VAR(VAR.VAR('VAR').VAR('VAR')): VAR(VAR""VAR VAR VAR VAR {VAR.VAR('VAR').VAR('VAR')}"") VAR VAR VAR.VAR('VAR') VAR VAR: VAR['VAR'] = VAR(VAR.VAR('VAR').VAR('VAR')) VAR = { 'VAR': VAR.VAR('VAR').VAR('VAR'), 'VAR': VAR""VAR: 'VAR': VAR.VAR('VAR').VAR('VAR'), 'VAR': VAR.VAR('VAR').VAR('VAR'), 'VAR': VAR.VAR('VAR').VAR('VAR').VAR('VAR').VAR('VAR'), 'VAR': VAR.VAR('VAR').VAR('VAR'), } VAR.VAR(VAR) VAR.VAR(VAR) VAR['VAR'] = VAR VAR VAR(VAR, 'VAR+', VAR='VAR-8') VAR VAR: VAR.VAR(VAR, VAR, VAR=VAR, VAR=2) VAR(VAR""{VAR(VAR)} VAR VAR VAR VAR {VAR.VAR('VAR')}. VAR VAR VAR-VAR/VAR-{VAR}.VAR"") VAR VAR ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,docker/docker-healthcheck.sh,"#!/bin/bash

# Send a request to the specified URL
response=$(curl --write-out '%{http_code}' --silent --output /dev/null http://localhost:3001/api/ping)

# If the HTTP response code is 200 (OK), the server is up
if [ $response -eq 200 ]; then
    echo ""Server is up""
    exit 0
else
    echo ""Server is down""
    exit 1
fi",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"  VAR=$(VAR --VAR-VAR '%{VAR}' --VAR --VAR /VAR/VAR VAR:  VAR [ $VAR -VAR 200 ]; VAR VAR ""VAR VAR VAR"" VAR 0 VAR VAR ""VAR VAR VAR"" VAR 1 VAR ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,frontend/src/utils/session.js,"import { API_BASE } from ""./constants"";
import { baseHeaders } from ""./request"";

// Checks current localstorage and validates the session based on that.
export default async function validateSessionTokenForUser() {
  const isValidSession = await fetch(`${API_BASE}/system/check-token`, {
    method: ""GET"",
    cache: ""default"",
    headers: baseHeaders(),
  })
    .then((res) => res.status === 200)
    .catch(() => false);

  return isValidSession;
}",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } VAR ""./VAR""; VAR { VAR } VAR ""./VAR"";  VAR VAR VAR VAR VAR() { VAR VAR = VAR VAR(`${VAR}/VAR/VAR-VAR`, { VAR: ""VAR"", VAR: ""VAR"", VAR: VAR(), }) .VAR((VAR) => VAR.VAR === 200) .VAR(() => VAR); VAR VAR; } ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/endpoints/admin.js,"const { ApiKey } = require(""../models/apiKeys"");
const { Document } = require(""../models/documents"");
const { Invite } = require(""../models/invite"");
const { SystemSettings } = require(""../models/systemSettings"");
const { User } = require(""../models/user"");
const { DocumentVectors } = require(""../models/vectors"");
const { Workspace } = require(""../models/workspace"");
const { WorkspaceChats } = require(""../models/workspaceChats"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { userFromSession, reqBody } = require(""../utils/http"");
const { validatedRequest } = require(""../utils/middleware/validatedRequest"");

function adminEndpoints(app) {
  if (!app) return;

  app.get(""/admin/users"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }
      const users = (await User.where()).map((user) => {
        const { password, ...rest } = user;
        return rest;
      });
      response.status(200).json({ users });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/admin/users/new"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const newUserParams = reqBody(request);
        const { user: newUser, error } = await User.create(newUserParams);
        response.status(200).json({ user: newUser, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(""/admin/user/:id"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }

      const { id } = request.params;
      const updates = reqBody(request);
      const { success, error } = await User.update(id, updates);
      response.status(200).json({ success, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/admin/user/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const { id } = request.params;
        await User.delete(`id = ${id}`);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/admin/invites"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }

      const invites = await Invite.whereWithUsers();
      response.status(200).json({ invites });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/admin/invite/new"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { invite, error } = await Invite.create(user.id);
        response.status(200).json({ invite, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/invite/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        const { success, error } = await Invite.deactivate(id);
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(
    ""/admin/workspaces"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const workspaces = await Workspace.whereWithUsers();
        response.status(200).json({ workspaces });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/workspaces/new"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const { name } = reqBody(request);
        const { workspace, message: error } = await Workspace.new(
          name,
          user.id
        );
        response.status(200).json({ workspace, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/workspaces/:workspaceId/update-users"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { workspaceId } = request.params;
        const { userIds } = reqBody(request);
        const { success, error } = await Workspace.updateUsers(
          workspaceId,
          userIds
        );
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/workspaces/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        const VectorDb = getVectorDbClass();
        const workspace = Workspace.get(`id = ${id}`);
        if (!workspace) {
          response.sendStatus(404).end();
          return;
        }

        await Workspace.delete(`id = ${id}`);
        await DocumentVectors.deleteForWorkspace(id);
        await Document.delete(`workspaceId = ${Number(id)}`);
        await WorkspaceChats.delete(`workspaceId = ${Number(id)}`);
        try {
          await VectorDb[""delete-namespace""]({ namespace: workspace.slug });
        } catch (e) {
          console.error(e.message);
        }

        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/workspace-chats"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const { offset = 0 } = reqBody(request);
        const chats = await WorkspaceChats.whereWithData(`id >= ${offset}`, 20);
        const hasPages = (await WorkspaceChats.count()) > 20;
        response.status(200).json({ chats: chats.reverse(), hasPages });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/workspace-chats/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        await WorkspaceChats.delete(`id = ${id}`);
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(
    ""/admin/system-preferences"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const settings = {
          users_can_delete_workspaces:
            (await SystemSettings.get(`label = 'users_can_delete_workspaces'`))
              ?.value === ""true"",
          limit_user_messages:
            (await SystemSettings.get(`label = 'limit_user_messages'`))
              ?.value === ""true"",
          message_limit:
            Number(
              (await SystemSettings.get(`label = 'message_limit'`))?.value
            ) || 10,
        };
        response.status(200).json({ settings });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/system-preferences"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const updates = reqBody(request);
        await SystemSettings.updateSettings(updates);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/admin/api-keys"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }

      const apiKeys = await ApiKey.whereWithUser(""id IS NOT NULL"");
      return response.status(200).json({
        apiKeys,
        error: null,
      });
    } catch (error) {
      console.error(error);
      response.status(500).json({
        apiKey: null,
        error: ""Could not find an API Keys."",
      });
    }
  });

  app.post(
    ""/admin/generate-api-key"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { apiKey, error } = await ApiKey.create(user.id);
        return response.status(200).json({
          apiKey,
          error,
        });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/delete-api-key/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { id } = request.params;
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        await ApiKey.delete(`id = ${id}`);
        return response.status(200).end();
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { adminEndpoints };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = (VAR VAR.VAR()).VAR((VAR) => { VAR { VAR, ...VAR } = VAR; VAR VAR; }); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR { VAR: VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR(VAR, VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR.VAR(`VAR = ${VAR}`); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(VAR.VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR(VAR); VAR { VAR, VAR: VAR } = VAR VAR.VAR( VAR, VAR.VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/:VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR } = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR( VAR, VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR = VAR(); VAR VAR = VAR.VAR(`VAR = ${VAR}`); VAR (!VAR) { VAR.VAR(404).VAR(); VAR; } VAR VAR.VAR(`VAR = ${VAR}`); VAR VAR.VAR(VAR); VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR { VAR VAR[""VAR-VAR""]({ VAR: VAR.VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR); } VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR = 0 } = VAR(VAR); VAR VAR = VAR VAR.VAR(`VAR >= ${VAR}`, 20); VAR VAR = (VAR VAR.VAR()) > 20; VAR.VAR(200).VAR({ VAR: VAR.VAR(), VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR.VAR(`VAR = ${VAR}`); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = { VAR: (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR"", VAR: (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR"", VAR: VAR( (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR ) || 10, }; VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(""VAR VAR VAR VAR""); VAR VAR.VAR(200).VAR({ VAR, VAR: VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."", }); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(VAR.VAR); VAR VAR.VAR(200).VAR({ VAR, VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR.VAR(`VAR = ${VAR}`); VAR VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/endpoints/api/admin/index.js,"const { Invite } = require(""../../../models/invite"");
const { SystemSettings } = require(""../../../models/systemSettings"");
const { User } = require(""../../../models/user"");
const { Workspace } = require(""../../../models/workspace"");
const { WorkspaceChats } = require(""../../../models/workspaceChats"");
const { multiUserMode, reqBody } = require(""../../../utils/http"");
const { validApiKey } = require(""../../../utils/middleware/validApiKey"");

function apiAdminEndpoints(app) {
  if (!app) return;

  app.get(""/v1/admin/is-multi-user-mode"", [validApiKey], (_, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""isMultiUser"": true
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    const isMultiUser = multiUserMode(response);
    response.status(200).json({ isMultiUser });
  });

  app.get(""/v1/admin/users"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""users"": [
                {
                  username: ""sample-sam"",
                  role: 'default',
                }
             ]
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const users = (await User.where()).map((user) => {
        const { password, ...rest } = user;
        return rest;
      });
      response.status(200).json({ users });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/v1/admin/users/new"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Create a new user with username and password. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Key pair object that will define the new user to add to the system.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              username: ""sample-sam"",
              password: 'hunter2',
              role: 'default | admin'
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              user: {
                id: 1,
                username: 'sample-sam',
                role: 'default',
              },
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const newUserParams = reqBody(request);
      const { user: newUser, error } = await User.create(newUserParams);
      response.status(200).json({ user: newUser, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/v1/admin/users/:id"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.path = '/v1/admin/users/{id}'
    #swagger.parameters['id'] = {
      in: 'path',
      description: 'id of the user in the database.',
      required: true,
      type: 'string'
    }
    #swagger.description = 'Update existing user settings. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Key pair object that will update the found user. All fields are optional and will not update unless specified.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              username: ""sample-sam"",
              password: 'hunter2',
              role: 'default | admin',
              suspended: 0,
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const { id } = request.params;
      const updates = reqBody(request);
      const { success, error } = await User.update(id, updates);
      response.status(200).json({ success, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/v1/admin/users/:id"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Delete existing user by id. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.path = '/v1/admin/users/{id}'
    #swagger.parameters['id'] = {
      in: 'path',
      description: 'id of the user in the database.',
      required: true,
      type: 'string'
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        await User.delete(`id = ${id}`);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/v1/admin/invites"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'List all existing invitations to instance regardless of status. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""invites"": [
                {
                  id: 1,
                  status: ""pending"",
                  code: 'abc-123',
                  claimedBy: null
                }
             ]
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const invites = await Invite.whereWithUsers();
      response.status(200).json({ invites });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/v1/admin/invite/new"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Create a new invite code for someone to use to register with instance. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              invite: {
                id: 1,
                status: ""pending"",
                code: 'abc-123',
              },
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const { invite, error } = await Invite.create();
      response.status(200).json({ invite, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/v1/admin/invite/:id"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Deactivates (soft-delete) invite by id. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.path = '/v1/admin/invite/{id}'
    #swagger.parameters['id'] = {
      in: 'path',
      description: 'id of the invite in the database.',
      required: true,
      type: 'string'
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        const { success, error } = await Invite.deactivate(id);
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/v1/admin/workspaces/:workspaceId/update-users"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.path = '/v1/admin/workspaces/{workspaceId}/update-users'
    #swagger.parameters['workspaceId'] = {
      in: 'path',
      description: 'id of the workspace in the database.',
      required: true,
      type: 'string'
    }
    #swagger.description = 'Overwrite workspace permissions to only be accessible by the given user ids and admins. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Entire array of user ids who can access the workspace. All fields are optional and will not update unless specified.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              userIds: [1,2,4,12],
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { workspaceId } = request.params;
        const { userIds } = reqBody(request);
        const { success, error } = await Workspace.updateUsers(
          workspaceId,
          userIds
        );
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/v1/admin/workspace-chats"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'All chats in the system ordered by most recent. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Page offset to show of workspace chats. All fields are optional and will not update unless specified.',
        required: false,
        type: 'integer',
        content: {
          ""application/json"": {
            example: {
              offset: 2,
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { offset = 0 } = reqBody(request);
        const chats = await WorkspaceChats.whereWithData(`id >= ${offset}`, 20);
        const hasPages = (await WorkspaceChats.count()) > 20;
        response.status(200).json({ chats: chats.reverse(), hasPages });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/v1/admin/preferences"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Show all multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              settings: {
                users_can_delete_workspaces: true,
                limit_user_messages: false,
                message_limit: 10,
              }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const settings = {
        users_can_delete_workspaces:
          (await SystemSettings.get(`label = 'users_can_delete_workspaces'`))
            ?.value === ""true"",
        limit_user_messages:
          (await SystemSettings.get(`label = 'limit_user_messages'`))?.value ===
          ""true"",
        message_limit:
          Number(
            (await SystemSettings.get(`label = 'message_limit'`))?.value
          ) || 10,
      };
      response.status(200).json({ settings });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/v1/admin/preferences"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Update multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
      description: 'Object with setting key and new value to set. All keys are optional and will not update unless specified.',
      required: true,
      type: 'object',
      content: {
        ""application/json"": {
          example: {
            users_can_delete_workspaces: false,
            limit_user_messages: true,
            message_limit: 5,
          }
        }
      }
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const updates = reqBody(request);
        await SystemSettings.updateSettings(updates);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { apiAdminEndpoints };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR, VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR/VAR-VAR-VAR-VAR"", [VAR], (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": VAR } } } } }  VAR: { ""$VAR"": "" } } */ VAR VAR = VAR(VAR); VAR.VAR(200).VAR({ VAR }); }); VAR.VAR(""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": [ { VAR: ""VAR-VAR"", VAR: 'VAR', } ] } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = (VAR VAR.VAR()).VAR((VAR) => { VAR { VAR, ...VAR } = VAR; VAR VAR; }); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: ""VAR-VAR"", VAR: 'VAR', VAR: 'VAR | VAR' } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: 1, VAR: 'VAR-VAR', VAR: 'VAR', }, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR { VAR: VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }   VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: ""VAR-VAR"", VAR: 'VAR', VAR: 'VAR | VAR', VAR: 0, } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR(VAR, VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { /*     VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR.VAR(`VAR = ${VAR}`); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": [ { VAR: 1, VAR: ""VAR"", VAR: 'VAR-123', VAR: VAR } ] } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: 1, VAR: ""VAR"", VAR: 'VAR-123', }, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { /*     VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/VAR/:VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }   VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: [1,2,4,12], } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR } = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR( VAR, VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: 2, } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR = 0 } = VAR(VAR); VAR VAR = VAR VAR.VAR(`VAR >= ${VAR}`, 20); VAR VAR = (VAR VAR.VAR()) > 20; VAR.VAR(200).VAR({ VAR: VAR.VAR(), VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: VAR, VAR: VAR, VAR: 10, } } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = { VAR: (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR"", VAR: (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR === ""VAR"", VAR: VAR( (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR ) || 10, }; VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: VAR, VAR: VAR, VAR: 5, } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/endpoints/api/auth/index.js,"const { validApiKey } = require(""../../../utils/middleware/validApiKey"");

function apiAuthEndpoints(app) {
  if (!app) return;

  app.get(""/v1/auth"", [validApiKey], (_, response) => {
    /*
    #swagger.tags = ['Authentication']
    #swagger.description = 'Verify the attached Authentication header contains a valid API token.'
    #swagger.responses[200] = {
      description: 'Valid auth token was found.',
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              authenticated: true,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    response.status(200).json({ authenticated: true });
  });
}

module.exports = { apiAuthEndpoints };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", [VAR], (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR.', VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } } */ VAR.VAR(200).VAR({ VAR: VAR }); }); } VAR.VAR = { VAR }; ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/endpoints/api/document/index.js,"const { Telemetry } = require(""../../../models/telemetry"");
const { validApiKey } = require(""../../../utils/middleware/validApiKey"");
const { setupMulter } = require(""../../../utils/files/multer"");
const {
  checkPythonAppAlive,
  acceptedFileTypes,
  processDocument,
} = require(""../../../utils/files/documentProcessor"");
const { viewLocalFiles } = require(""../../../utils/files"");
const { handleUploads } = setupMulter();

function apiDocumentEndpoints(app) {
  if (!app) return;

  app.post(
    ""/v1/document/upload"",
    [validApiKey],
    handleUploads.single(""file""),
    async (request, response) => {
      /*
    #swagger.tags = ['Documents']
    #swagger.description = 'Upload a new file to AnythingLLM to be parsed and prepared for embedding.'

    #swagger.requestBody = {
      description: 'File to be uploaded.',
      required: true,
      type: 'file',
      content: {
        ""multipart/form-data"": {
          schema: {
            type: 'object',
            properties: {
              file: {
                type: 'string',
                format: 'binary',
              }
            }
          }
        }
      }
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
      try {
        const { originalname } = request.file;
        const processingOnline = await checkPythonAppAlive();

        if (!processingOnline) {
          response
            .status(500)
            .json({
              success: false,
              error: `Python processing API is not online. Document ${originalname} will not be processed automatically.`,
            })
            .end();
        }

        const { success, reason } = await processDocument(originalname);
        if (!success) {
          response.status(500).json({ success: false, error: reason }).end();
        }

        console.log(
          `Document ${originalname} uploaded processed and successfully. It is now available in documents.`
        );
        await Telemetry.sendTelemetry(""document_uploaded"");
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/v1/documents"", [validApiKey], async (_, response) => {
    /*
    #swagger.tags = ['Documents']
    #swagger.description = 'List of all locally-stored documents in instance'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""localFiles"": {
              ""name"": ""documents"",
              ""type"": ""folder"",
              items: [
                {
                  ""name"": ""my-stored-document.json"",
                  ""type"": ""file"",
                  ""id"": ""bb07c334-4dab-4419-9462-9d00065a49a1"",
                  ""url"": ""file://my-stored-document.txt"",
                  ""title"": ""my-stored-document.txt"",
                  ""cached"": false
                },
              ]
             }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    try {
      const localFiles = await viewLocalFiles();
      response.status(200).json({ localFiles });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/v1/document/accepted-file-types"",
    [validApiKey],
    async (_, response) => {
      /*
    #swagger.tags = ['Documents']
    #swagger.description = 'Check available filetypes and MIMEs that can be uploaded.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              ""types"": {
                ""application/mbox"": [
                  "".mbox""
                ],
                ""application/pdf"": [
                  "".pdf""
                ],
                ""application/vnd.oasis.opendocument.text"": [
                  "".odt""
                ],
                ""application/vnd.openxmlformats-officedocument.wordprocessingml.document"": [
                  "".docx""
                ],
                ""text/plain"": [
                  "".txt"",
                  "".md""
                ]
              }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
      try {
        const types = await acceptedFileTypes();
        if (!types) {
          response.sendStatus(404).end();
          return;
        }

        response.status(200).json({ types });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { apiDocumentEndpoints };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR, VAR, VAR, } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR.VAR(""VAR""), VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR-VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: 'VAR', VAR: 'VAR', } } } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(); VAR (!VAR) { VAR .VAR(500) .VAR({ VAR: VAR, VAR: `VAR VAR VAR VAR VAR VAR. VAR ${VAR} VAR VAR VAR VAR VAR.`, }) .VAR(); } VAR { VAR, VAR } = VAR VAR(VAR); VAR (!VAR) { VAR.VAR(500).VAR({ VAR: VAR, VAR: VAR }).VAR(); } VAR.VAR( `VAR ${VAR} VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR.` ); VAR VAR.VAR(""VAR""); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"", VAR: [ { ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR-4dab-4419-9462-9d00065a49a1"", ""VAR"": ""VAR: ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": VAR }, ] } } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": { ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR.VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR.VAR-VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"", "".VAR"" ] } } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR VAR(); VAR (!VAR) { VAR.VAR(404).VAR(); VAR; } VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/endpoints/api/system/index.js,"const { SystemSettings } = require(""../../../models/systemSettings"");
const { getVectorDbClass } = require(""../../../utils/helpers"");
const { dumpENV, updateENV } = require(""../../../utils/helpers/updateENV"");
const { reqBody } = require(""../../../utils/http"");
const { validApiKey } = require(""../../../utils/middleware/validApiKey"");

function apiSystemEndpoints(app) {
  if (!app) return;

  app.get(""/v1/system/env-dump"", async (_, response) => {
    /*
   #swagger.tags = ['System Settings']
   #swagger.description = 'Dump all settings to file storage'
   #swagger.responses[403] = {
     schema: {
       ""$ref"": ""#/definitions/InvalidAPIKey""
     }
   }
   */
    try {
      if (process.env.NODE_ENV !== ""production"")
        return response.sendStatus(200).end();
      await dumpENV();
      response.sendStatus(200).end();
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/v1/system"", [validApiKey], async (_, response) => {
    /*
    #swagger.tags = ['System Settings']
    #swagger.description = 'Get all current system settings that are defined.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""settings"": {
                ""VectorDB"": ""pinecone"",
                ""PineConeEnvironment"": ""us-west4-gcp-free"",
                ""PineConeKey"": true,
                ""PineConeIndex"": ""my-pinecone-index"",
                ""LLMProvider"": ""azure"",
                ""[KEY_NAME]"": ""KEY_VALUE"",
              }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    try {
      const settings = await SystemSettings.currentSettings();
      response.status(200).json({ settings });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/v1/system/vector-count"", [validApiKey], async (_, response) => {
    /*
    #swagger.tags = ['System Settings']
    #swagger.description = 'Number of all vectors in connected vector database'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""vectorCount"": 5450
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    try {
      const VectorDb = getVectorDbClass();
      const vectorCount = await VectorDb.totalIndicies();
      response.status(200).json({ vectorCount });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/v1/system/update-env"",
    [validApiKey],
    async (request, response) => {
      /*
      #swagger.tags = ['System Settings']
      #swagger.description = 'Update a system setting or preference.'
      #swagger.requestBody = {
        description: 'Key pair object that matches a valid setting and value. Get keys from GET /v1/system or refer to codebase.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              VectorDB: ""lancedb"",
              AnotherKey: ""updatedValue""
            }
          }
        }
      }
      #swagger.responses[200] = {
        content: {
          ""application/json"": {
            schema: {
              type: 'object',
              example: {
                newValues: {""[ENV_KEY]"": 'Value'},
                error: 'error goes here, otherwise null'
              }
            }
          }
        }
      }
      #swagger.responses[403] = {
        schema: {
          ""$ref"": ""#/definitions/InvalidAPIKey""
        }
      }
      */
      try {
        const body = reqBody(request);
        const { newValues, error } = updateENV(body);
        if (process.env.NODE_ENV === ""production"") await dumpENV();
        response.status(200).json({ newValues, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { apiSystemEndpoints };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR, VAR } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR/VAR-VAR"", VAR (VAR, VAR) => { /*    VAR: { ""$VAR"": "" } } */ VAR { VAR (VAR.VAR.VAR !== ""VAR"") VAR VAR.VAR(200).VAR(); VAR VAR(); VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR-VAR-VAR-VAR"", ""VAR"": VAR, ""VAR"": ""VAR-VAR-VAR"", ""VAR"": ""VAR"", ""[VAR]"": ""VAR"", } } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": 5450 } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR(); VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR /VAR/VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: ""VAR"", VAR: ""VAR"" } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: {""[VAR]"": 'VAR'}, VAR: 'VAR VAR VAR, VAR VAR' } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR(VAR); VAR (VAR.VAR.VAR === ""VAR"") VAR VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/endpoints/invite.js,"const { Invite } = require(""../models/invite"");
const { User } = require(""../models/user"");
const { reqBody } = require(""../utils/http"");

function inviteEndpoints(app) {
  if (!app) return;

  app.get(""/invite/:code"", async (request, response) => {
    try {
      const { code } = request.params;
      const invite = await Invite.get(`code = '${code}'`);
      if (!invite) {
        response.status(200).json({ invite: null, error: ""Invite not found."" });
        return;
      }

      if (invite.status !== ""pending"") {
        response
          .status(200)
          .json({ invite: null, error: ""Invite is no longer valid."" });
        return;
      }

      response
        .status(200)
        .json({ invite: { code, status: invite.status }, error: null });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/invite/:code"", async (request, response) => {
    try {
      const { code } = request.params;
      const userParams = reqBody(request);
      const invite = await Invite.get(`code = '${code}'`);
      if (!invite || invite.status !== ""pending"") {
        response
          .status(200)
          .json({ success: false, error: ""Invite not found or is invalid."" });
        return;
      }

      const { user, error } = await User.create(userParams);
      if (!user) {
        console.error(""Accepting invite:"", error);
        response
          .status(200)
          .json({ success: false, error: ""Could not create user."" });
        return;
      }

      await Invite.markClaimed(invite.id, user);
      response.status(200).json({ success: true, error: null });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });
}

module.exports = { inviteEndpoints };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/:VAR"", VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR.VAR(`VAR = '${VAR}'`); VAR (!VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: ""VAR VAR VAR."" }); VAR; } VAR (VAR.VAR !== ""VAR"") { VAR .VAR(200) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR."" }); VAR; } VAR .VAR(200) .VAR({ VAR: { VAR, VAR: VAR.VAR }, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/:VAR"", VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR VAR = VAR VAR.VAR(`VAR = '${VAR}'`); VAR (!VAR || VAR.VAR !== ""VAR"") { VAR .VAR(200) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."" }); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(VAR); VAR (!VAR) { VAR.VAR(""VAR VAR:"", VAR); VAR .VAR(200) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR."" }); VAR; } VAR VAR.VAR(VAR.VAR, VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); } VAR.VAR = { VAR }; ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/endpoints/system.js,"process.env.NODE_ENV === ""development""
  ? require(""dotenv"").config({ path: `.env.${process.env.NODE_ENV}` })
  : require(""dotenv"").config();
const { validateTablePragmas } = require(""../utils/database"");
const { viewLocalFiles } = require(""../utils/files"");
const { exportData, unpackAndOverwriteImport } = require(""../utils/files/data"");
const {
  checkPythonAppAlive,
  acceptedFileTypes,
} = require(""../utils/files/documentProcessor"");
const { purgeDocument } = require(""../utils/files/purgeDocument"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { updateENV, dumpENV } = require(""../utils/helpers/updateENV"");
const {
  reqBody,
  makeJWT,
  userFromSession,
  multiUserMode,
} = require(""../utils/http"");
const { setupDataImports, setupLogoUploads } = require(""../utils/files/multer"");
const { v4 } = require(""uuid"");
const { SystemSettings } = require(""../models/systemSettings"");
const { User } = require(""../models/user"");
const { validatedRequest } = require(""../utils/middleware/validatedRequest"");
const { handleImports } = setupDataImports();
const { handleLogoUploads } = setupLogoUploads();
const fs = require(""fs"");
const path = require(""path"");
const {
  getDefaultFilename,
  determineLogoFilepath,
  fetchLogo,
  validFilename,
  renameLogoFile,
  removeCustomLogo,
  DARK_LOGO_FILENAME,
} = require(""../utils/files/logo"");
const { Telemetry } = require(""../models/telemetry"");
const { WelcomeMessages } = require(""../models/welcomeMessages"");
const { ApiKey } = require(""../models/apiKeys"");

function systemEndpoints(app) {
  if (!app) return;

  app.get(""/ping"", (_, response) => {
    response.status(200).json({ online: true });
  });

  app.get(""/migrate"", async (_, response) => {
    await validateTablePragmas(true);
    response.sendStatus(200);
  });

  app.get(""/env-dump"", async (_, response) => {
    if (process.env.NODE_ENV !== ""production"")
      return response.sendStatus(200).end();
    await dumpENV();
    response.sendStatus(200).end();
  });

  app.get(""/setup-complete"", async (_, response) => {
    try {
      const results = await SystemSettings.currentSettings();
      response.status(200).json({ results });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/system/check-token"",
    [validatedRequest],
    async (request, response) => {
      try {
        if (multiUserMode(response)) {
          const user = await userFromSession(request, response);
          if (!user || user.suspended) {
            response.sendStatus(403).end();
            return;
          }

          response.sendStatus(200).end();
          return;
        }

        response.sendStatus(200).end();
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(""/request-token"", async (request, response) => {
    try {
      if (await SystemSettings.isMultiUserMode()) {
        const { username, password } = reqBody(request);
        const existingUser = await User.get(`username = '${username}'`);

        if (!existingUser) {
          response.status(200).json({
            user: null,
            valid: false,
            token: null,
            message: ""[001] Invalid login credentials."",
          });
          return;
        }

        const bcrypt = require(""bcrypt"");
        if (!bcrypt.compareSync(password, existingUser.password)) {
          response.status(200).json({
            user: null,
            valid: false,
            token: null,
            message: ""[002] Invalid login credentials."",
          });
          return;
        }

        if (existingUser.suspended) {
          response.status(200).json({
            user: null,
            valid: false,
            token: null,
            message: ""[004] Account suspended by admin."",
          });
          return;
        }

        response.status(200).json({
          valid: true,
          user: existingUser,
          token: makeJWT(
            { id: existingUser.id, username: existingUser.username },
            ""30d""
          ),
          message: null,
        });
        return;
      } else {
        const { password } = reqBody(request);
        if (password !== process.env.AUTH_TOKEN) {
          response.status(401).json({
            valid: false,
            token: null,
            message: ""[003] Invalid password provided"",
          });
          return;
        }

        response.status(200).json({
          valid: true,
          token: makeJWT({ p: password }, ""30d""),
          message: null,
        });
      }
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/system/system-vectors"", [validatedRequest], async (_, response) => {
    try {
      const VectorDb = getVectorDbClass();
      const vectorCount = await VectorDb.totalIndicies();
      response.status(200).json({ vectorCount });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/system/remove-document"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { name, meta } = reqBody(request);
        await purgeDocument(name, meta);
        response.sendStatus(200).end();
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/system/local-files"", [validatedRequest], async (_, response) => {
    try {
      const localFiles = await viewLocalFiles();
      response.status(200).json({ localFiles });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/system/document-processing-status"",
    [validatedRequest],
    async (_, response) => {
      try {
        const online = await checkPythonAppAlive();
        response.sendStatus(online ? 200 : 503);
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(
    ""/system/accepted-document-types"",
    [validatedRequest],
    async (_, response) => {
      try {
        const types = await acceptedFileTypes();
        if (!types) {
          response.sendStatus(404).end();
          return;
        }

        response.status(200).json({ types });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/system/update-env"",
    [validatedRequest],
    async (request, response) => {
      try {
        const body = reqBody(request);
        const { newValues, error } = updateENV(body);
        if (process.env.NODE_ENV === ""production"") await dumpENV();
        response.status(200).json({ newValues, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/system/update-password"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { usePassword, newPassword } = reqBody(request);
        const { error } = updateENV({
          AuthToken: usePassword ? newPassword : """",
          JWTSecret: usePassword ? v4() : """",
        });
        response.status(200).json({ success: !error, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/system/enable-multi-user"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { username, password } = reqBody(request);
        const multiUserModeEnabled = await SystemSettings.isMultiUserMode();
        if (multiUserModeEnabled) {
          response.status(200).json({
            success: false,
            error: ""Multi-user mode is already enabled."",
          });
          return;
        }

        const { user, error } = await User.create({
          username,
          password,
          role: ""admin"",
        });
        await SystemSettings.updateSettings({
          multi_user_mode: true,
          users_can_delete_workspaces: false,
          limit_user_messages: false,
          message_limit: 25,
        });
        process.env.AUTH_TOKEN = null;
        process.env.JWT_SECRET = process.env.JWT_SECRET ?? v4(); // Make sure JWT_SECRET is set for JWT issuance.
        await Telemetry.sendTelemetry(""enabled_multi_user_mode"");
        response.status(200).json({ success: !!user, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/system/data-export"", [validatedRequest], async (_, response) => {
    try {
      const { filename, error } = await exportData();
      response.status(200).json({ filename, error });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/system/data-exports/:filename"",
    [validatedRequest],
    (request, response) => {
      const exportLocation = __dirname + ""/../storage/exports/"";
      const sanitized = path
        .normalize(request.params.filename)
        .replace(/^(\.\.(\/|\\|$))+/, """");
      const finalDestination = path.join(exportLocation, sanitized);

      if (!fs.existsSync(finalDestination)) {
        response.status(404).json({
          error: 404,
          msg: `File ${request.params.filename} does not exist in exports.`,
        });
        return;
      }

      response.download(finalDestination, request.params.filename, (err) => {
        if (err) {
          response.send({
            error: err,
            msg: ""Problem downloading the file"",
          });
        }
      });
    }
  );

  app.post(
    ""/system/data-import"",
    handleImports.single(""file""),
    async function (request, response) {
      const { originalname } = request.file;
      const { success, error } = await unpackAndOverwriteImport(originalname);
      response.status(200).json({ success, error });
    }
  );

  app.get(""/system/logo/:mode?"", async function (request, response) {
    try {
      const defaultFilename = getDefaultFilename(request.params.mode);
      const logoPath = await determineLogoFilepath(defaultFilename);
      const { buffer, size, mime } = fetchLogo(logoPath);
      response.writeHead(200, {
        ""Content-Type"": mime || ""image/png"",
        ""Content-Disposition"": `attachment; filename=${path.basename(
          logoPath
        )}`,
        ""Content-Length"": size,
      });
      response.end(Buffer.from(buffer, ""base64""));
      return;
    } catch (error) {
      console.error(""Error processing the logo request:"", error);
      response.status(500).json({ message: ""Internal server error"" });
    }
  });

  app.post(
    ""/system/upload-logo"",
    [validatedRequest],
    handleLogoUploads.single(""logo""),
    async (request, response) => {
      if (!request.file || !request.file.originalname) {
        return response.status(400).json({ message: ""No logo file provided."" });
      }

      if (!validFilename(request.file.originalname)) {
        return response.status(400).json({
          message: ""Invalid file name. Please choose a different file."",
        });
      }

      try {
        if (
          response.locals.multiUserMode &&
          response.locals.user?.role !== ""admin""
        ) {
          return response.sendStatus(401).end();
        }

        const newFilename = await renameLogoFile(request.file.originalname);
        const existingLogoFilename = await SystemSettings.currentLogoFilename();
        await removeCustomLogo(existingLogoFilename);

        const { success, error } = await SystemSettings.updateSettings({
          logo_filename: newFilename,
        });

        return response.status(success ? 200 : 500).json({
          message: success
            ? ""Logo uploaded successfully.""
            : error || ""Failed to update with new logo."",
        });
      } catch (error) {
        console.error(""Error processing the logo upload:"", error);
        response.status(500).json({ message: ""Error uploading the logo."" });
      }
    }
  );

  app.get(
    ""/system/remove-logo"",
    [validatedRequest],
    async (request, response) => {
      try {
        if (
          response.locals.multiUserMode &&
          response.locals.user?.role !== ""admin""
        ) {
          return response.sendStatus(401).end();
        }

        const currentLogoFilename = await SystemSettings.currentLogoFilename();
        await removeCustomLogo(currentLogoFilename);
        const { success, error } = await SystemSettings.updateSettings({
          logo_filename: DARK_LOGO_FILENAME,
        });

        return response.status(success ? 200 : 500).json({
          message: success
            ? ""Logo removed successfully.""
            : error || ""Failed to update with new logo."",
        });
      } catch (error) {
        console.error(""Error processing the logo removal:"", error);
        response.status(500).json({ message: ""Error removing the logo."" });
      }
    }
  );

  app.get(
    ""/system/can-delete-workspaces"",
    [validatedRequest],
    async function (request, response) {
      try {
        if (!response.locals.multiUserMode) {
          return response.status(200).json({ canDelete: true });
        }

        if (response.locals.user?.role === ""admin"") {
          return response.status(200).json({ canDelete: true });
        }

        const canDelete = await SystemSettings.canDeleteWorkspaces();
        response.status(200).json({ canDelete });
      } catch (error) {
        console.error(""Error fetching can delete workspaces:"", error);
        response.status(500).json({
          success: false,
          message: ""Internal server error"",
          canDelete: false,
        });
      }
    }
  );

  app.get(""/system/welcome-messages"", async function (request, response) {
    try {
      const welcomeMessages = await WelcomeMessages.getMessages();
      response.status(200).json({ success: true, welcomeMessages });
    } catch (error) {
      console.error(""Error fetching welcome messages:"", error);
      response
        .status(500)
        .json({ success: false, message: ""Internal server error"" });
    }
  });

  app.post(
    ""/system/set-welcome-messages"",
    [validatedRequest],
    async (request, response) => {
      try {
        if (
          response.locals.multiUserMode &&
          response.locals.user?.role !== ""admin""
        ) {
          return response.sendStatus(401).end();
        }

        const { messages = [] } = reqBody(request);
        if (!Array.isArray(messages)) {
          return response.status(400).json({
            success: false,
            message: ""Invalid message format. Expected an array of messages."",
          });
        }

        await WelcomeMessages.saveAll(messages);
        return response.status(200).json({
          success: true,
          message: ""Welcome messages saved successfully."",
        });
      } catch (error) {
        console.error(""Error processing the welcome messages:"", error);
        response.status(500).json({
          success: true,
          message: ""Error saving the welcome messages."",
        });
      }
    }
  );

  app.get(""/system/api-key"", [validatedRequest], async (_, response) => {
    try {
      if (response.locals.multiUserMode) {
        return response.sendStatus(401).end();
      }

      const apiKey = await ApiKey.get(""id IS NOT NULL"");
      return response.status(200).json({
        apiKey,
        error: null,
      });
    } catch (error) {
      console.error(error);
      response.status(500).json({
        apiKey: null,
        error: ""Could not find an API Key."",
      });
    }
  });

  app.post(
    ""/system/generate-api-key"",
    [validatedRequest],
    async (_, response) => {
      try {
        if (response.locals.multiUserMode) {
          return response.sendStatus(401).end();
        }

        await ApiKey.delete();
        const { apiKey, error } = await ApiKey.create();
        return response.status(200).json({
          apiKey,
          error,
        });
      } catch (error) {
        console.error(error);
        response.status(500).json({
          apiKey: null,
          error: ""Error generating api key."",
        });
      }
    }
  );

  app.delete(""/system/api-key"", [validatedRequest], async (_, response) => {
    try {
      if (response.locals.multiUserMode) {
        return response.sendStatus(401).end();
      }

      await ApiKey.delete();
      return response.status(200).end();
    } catch (error) {
      console.error(error);
      response.status(500).end();
    }
  });
}

module.exports = { systemEndpoints };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR.VAR.VAR === ""VAR"" ? VAR(""VAR"").VAR({ VAR: `.VAR.${VAR.VAR.VAR}` }) : VAR(""VAR"").VAR(); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR, VAR, } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR, VAR, VAR, VAR, } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(); VAR { VAR } = VAR(); VAR VAR = VAR(""VAR""); VAR VAR = VAR(""VAR""); VAR { VAR, VAR, VAR, VAR, VAR, VAR, VAR, } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR"", (VAR, VAR) => { VAR.VAR(200).VAR({ VAR: VAR }); }); VAR.VAR(""/VAR"", VAR (VAR, VAR) => { VAR VAR(VAR); VAR.VAR(200); }); VAR.VAR(""/VAR-VAR"", VAR (VAR, VAR) => { VAR (VAR.VAR.VAR !== ""VAR"") VAR VAR.VAR(200).VAR(); VAR VAR(); VAR.VAR(200).VAR(); }); VAR.VAR(""/VAR-VAR"", VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR(VAR)) { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR.VAR) { VAR.VAR(403).VAR(); VAR; } VAR.VAR(200).VAR(); VAR; } VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR-VAR"", VAR (VAR, VAR) => { VAR { VAR (VAR VAR.VAR()) { VAR { VAR, VAR } = VAR(VAR); VAR VAR = VAR VAR.VAR(`VAR = '${VAR}'`); VAR (!VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: ""[001] VAR VAR VAR."", }); VAR; } VAR VAR = VAR(""VAR""); VAR (!VAR.VAR(VAR, VAR.VAR)) { VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: ""[002] VAR VAR VAR."", }); VAR; } VAR (VAR.VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: ""[004] VAR VAR VAR VAR."", }); VAR; } VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR( { VAR: VAR.VAR, VAR: VAR.VAR }, ""30d"" ), VAR: VAR, }); VAR; } VAR { VAR { VAR } = VAR(VAR); VAR (VAR !== VAR.VAR.VAR) { VAR.VAR(401).VAR({ VAR: VAR, VAR: VAR, VAR: ""[003] VAR VAR VAR"", }); VAR; } VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR({ VAR: VAR }, ""30d""), VAR: VAR, }); } } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR(); VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR(VAR); VAR VAR(VAR, VAR); VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(); VAR.VAR(VAR ? 200 : 503); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(); VAR (!VAR) { VAR.VAR(404).VAR(); VAR; } VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR(VAR); VAR (VAR.VAR.VAR === ""VAR"") VAR VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR(VAR); VAR { VAR } = VAR({ VAR: VAR ? VAR : """", VAR: VAR ? VAR() : """", }); VAR.VAR(200).VAR({ VAR: !VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR(VAR); VAR VAR = VAR VAR.VAR(); VAR (VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: ""VAR-VAR VAR VAR VAR VAR."", }); VAR; } VAR { VAR, VAR } = VAR VAR.VAR({ VAR, VAR, VAR: ""VAR"", }); VAR VAR.VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: 25, }); VAR.VAR.VAR = VAR; VAR.VAR.VAR = VAR.VAR.VAR ?? VAR();  VAR VAR.VAR(""VAR""); VAR.VAR(200).VAR({ VAR: !!VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR/:VAR"", [VAR], (VAR, VAR) => { VAR VAR = VAR + ""/../VAR/VAR/""; VAR VAR = VAR .VAR(VAR.VAR.VAR) .VAR(/^(\.\.(\/|\\|$))+/, """"); VAR VAR = VAR.VAR(VAR, VAR); VAR (!VAR.VAR(VAR)) { VAR.VAR(404).VAR({ VAR: 404, VAR: `VAR ${VAR.VAR.VAR} VAR VAR VAR VAR VAR.`, }); VAR; } VAR.VAR(VAR, VAR.VAR.VAR, (VAR) => { VAR (VAR) { VAR.VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR"", }); } }); } ); VAR.VAR( ""/VAR/VAR-VAR"", VAR.VAR(""VAR""), VAR VAR (VAR, VAR) { VAR { VAR } = VAR.VAR; VAR { VAR, VAR } = VAR VAR(VAR); VAR.VAR(200).VAR({ VAR, VAR }); } ); VAR.VAR(""/VAR/VAR/:VAR?"", VAR VAR (VAR, VAR) { VAR { VAR VAR = VAR(VAR.VAR.VAR); VAR VAR = VAR VAR(VAR); VAR { VAR, VAR, VAR } = VAR(VAR); VAR.VAR(200, { ""VAR-VAR"": VAR || ""VAR/VAR"", ""VAR-VAR"": `VAR; VAR=${VAR.VAR( VAR )}`, ""VAR-VAR"": VAR, }); VAR.VAR(VAR.VAR(VAR, ""VAR"")); VAR; } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: ""VAR VAR VAR"" }); } }); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR.VAR(""VAR""), VAR (VAR, VAR) => { VAR (!VAR.VAR || !VAR.VAR.VAR) { VAR VAR.VAR(400).VAR({ VAR: ""VAR VAR VAR VAR."" }); } VAR (!VAR(VAR.VAR.VAR)) { VAR VAR.VAR(400).VAR({ VAR: ""VAR VAR VAR. VAR VAR VAR VAR VAR."", }); } VAR { VAR ( VAR.VAR.VAR && VAR.VAR.VAR?.VAR !== ""VAR"" ) { VAR VAR.VAR(401).VAR(); } VAR VAR = VAR VAR(VAR.VAR.VAR); VAR VAR = VAR VAR.VAR(); VAR VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR({ VAR: VAR, }); VAR VAR.VAR(VAR ? 200 : 500).VAR({ VAR: VAR ? ""VAR VAR VAR."" : VAR || ""VAR VAR VAR VAR VAR VAR."", }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: ""VAR VAR VAR VAR."" }); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR ( VAR.VAR.VAR && VAR.VAR.VAR?.VAR !== ""VAR"" ) { VAR VAR.VAR(401).VAR(); } VAR VAR = VAR VAR.VAR(); VAR VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR({ VAR: VAR, }); VAR VAR.VAR(VAR ? 200 : 500).VAR({ VAR: VAR ? ""VAR VAR VAR."" : VAR || ""VAR VAR VAR VAR VAR VAR."", }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: ""VAR VAR VAR VAR."" }); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR VAR (VAR, VAR) { VAR { VAR (!VAR.VAR.VAR) { VAR VAR.VAR(200).VAR({ VAR: VAR }); } VAR (VAR.VAR.VAR?.VAR === ""VAR"") { VAR VAR.VAR(200).VAR({ VAR: VAR }); } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR"", VAR: VAR, }); } } ); VAR.VAR(""/VAR/VAR-VAR"", VAR VAR (VAR, VAR) { VAR { VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR: VAR, VAR }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR:"", VAR); VAR .VAR(500) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR"" }); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR ( VAR.VAR.VAR && VAR.VAR.VAR?.VAR !== ""VAR"" ) { VAR VAR.VAR(401).VAR(); } VAR { VAR = [] } = VAR(VAR); VAR (!VAR.VAR(VAR)) { VAR VAR.VAR(400).VAR({ VAR: VAR, VAR: ""VAR VAR VAR. VAR VAR VAR VAR VAR."", }); } VAR VAR.VAR(VAR); VAR VAR.VAR(200).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR."", }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR."", }); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR.VAR.VAR) { VAR VAR.VAR(401).VAR(); } VAR VAR = VAR VAR.VAR(""VAR VAR VAR VAR""); VAR VAR.VAR(200).VAR({ VAR, VAR: VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."", }); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR.VAR.VAR) { VAR VAR.VAR(401).VAR(); } VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR.VAR(); VAR VAR.VAR(200).VAR({ VAR, VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR."", }); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR.VAR.VAR) { VAR VAR.VAR(401).VAR(); } VAR VAR.VAR(); VAR VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); } VAR.VAR = { VAR }; ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/endpoints/utils.js,"const { SystemSettings } = require(""../models/systemSettings"");

function getGitVersion() {
  try {
    return require(""child_process"")
      .execSync(""git rev-parse HEAD"")
      .toString()
      .trim();
  } catch (e) {
    console.error(""getGitVersion"", e.message);
    return ""--"";
  }
}

function byteToGigaByte(n) {
  return n / Math.pow(10, 9);
}

async function getDiskStorage() {
  try {
    const checkDiskSpace = require(""check-disk-space"").default;
    const { free, size } = await checkDiskSpace(""/"");
    return {
      current: Math.floor(byteToGigaByte(free)),
      capacity: Math.floor(byteToGigaByte(size)),
    };
  } catch {
    return {
      current: null,
      capacity: null,
    };
  }
}

function utilEndpoints(app) {
  if (!app) return;

  app.get(""/utils/metrics"", async (_, response) => {
    try {
      const metrics = {
        online: true,
        version: getGitVersion(),
        mode: (await SystemSettings.isMultiUserMode())
          ? ""multi-user""
          : ""single-user"",
        vectorDB: process.env.VECTOR_DB || ""lancedb"",
        storage: await getDiskStorage(),
      };
      response.status(200).json(metrics);
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });
}

module.exports = { utilEndpoints, getGitVersion };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR VAR() { VAR { VAR VAR(""VAR"") .VAR(""VAR VAR-VAR VAR"") .VAR() .VAR(); } VAR (VAR) { VAR.VAR(""VAR"", VAR.VAR); VAR ""--""; } } VAR VAR(VAR) { VAR VAR / VAR.VAR(10, 9); } VAR VAR VAR() { VAR { VAR VAR = VAR(""VAR-VAR-VAR"").VAR; VAR { VAR, VAR } = VAR VAR(""/""); VAR { VAR: VAR.VAR(VAR(VAR)), VAR: VAR.VAR(VAR(VAR)), }; } VAR { VAR { VAR: VAR, VAR: VAR, }; } } VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", VAR (VAR, VAR) => { VAR { VAR VAR = { VAR: VAR, VAR: VAR(), VAR: (VAR VAR.VAR()) ? ""VAR-VAR"" : ""VAR-VAR"", VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR VAR(), }; VAR.VAR(200).VAR(VAR); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); } VAR.VAR = { VAR, VAR }; ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/endpoints/workspaces.js,"const { reqBody, multiUserMode, userFromSession } = require(""../utils/http"");
const { Workspace } = require(""../models/workspace"");
const { Document } = require(""../models/documents"");
const { DocumentVectors } = require(""../models/vectors"");
const { WorkspaceChats } = require(""../models/workspaceChats"");
const { convertToChatHistory } = require(""../utils/chats"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { setupMulter } = require(""../utils/files/multer"");
const {
  checkPythonAppAlive,
  processDocument,
} = require(""../utils/files/documentProcessor"");
const { validatedRequest } = require(""../utils/middleware/validatedRequest"");
const { SystemSettings } = require(""../models/systemSettings"");
const { Telemetry } = require(""../models/telemetry"");
const { handleUploads } = setupMulter();

function workspaceEndpoints(app) {
  if (!app) return;

  app.post(""/workspace/new"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      const { name = null } = reqBody(request);
      const { workspace, message } = await Workspace.new(name, user?.id);
      await Telemetry.sendTelemetry(""workspace_created"", {
        multiUserMode: multiUserMode(response),
        LLMSelection: process.env.LLM_PROVIDER || ""openai"",
        VectorDbSelection: process.env.VECTOR_DB || ""pinecone"",
      });
      response.status(200).json({ workspace, message });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/workspace/:slug/update"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        const { slug = null } = request.params;
        const data = reqBody(request);
        const currWorkspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = '${slug}'`)
          : await Workspace.get(`slug = '${slug}'`);

        if (!currWorkspace) {
          response.sendStatus(400).end();
          return;
        }

        const { workspace, message } = await Workspace.update(
          currWorkspace.id,
          data
        );
        response.status(200).json({ workspace, message });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/workspace/:slug/upload"",
    handleUploads.single(""file""),
    async function (request, response) {
      const { originalname } = request.file;
      const processingOnline = await checkPythonAppAlive();

      if (!processingOnline) {
        response
          .status(500)
          .json({
            success: false,
            error: `Python processing API is not online. Document ${originalname} will not be processed automatically.`,
          })
          .end();
        return;
      }

      const { success, reason } = await processDocument(originalname);
      if (!success) {
        response.status(500).json({ success: false, error: reason }).end();
        return;
      }

      console.log(
        `Document ${originalname} uploaded processed and successfully. It is now available in documents.`
      );
      await Telemetry.sendTelemetry(""document_uploaded"");
      response.status(200).json({ success: true, error: null });
    }
  );

  app.post(
    ""/workspace/:slug/update-embeddings"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        const { slug = null } = request.params;
        const { adds = [], deletes = [] } = reqBody(request);
        const currWorkspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = '${slug}'`)
          : await Workspace.get(`slug = '${slug}'`);

        if (!currWorkspace) {
          response.sendStatus(400).end();
          return;
        }

        await Document.removeDocuments(currWorkspace, deletes);
        await Document.addDocuments(currWorkspace, adds);
        const updatedWorkspace = await Workspace.get(`slug = '${slug}'`);
        response.status(200).json({ workspace: updatedWorkspace });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/workspace/:slug"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { slug = """" } = request.params;
        const user = await userFromSession(request, response);
        const VectorDb = getVectorDbClass();
        const workspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = '${slug}'`)
          : await Workspace.get(`slug = '${slug}'`);

        if (!workspace) {
          response.sendStatus(400).end();
          return;
        }

        if (multiUserMode(response) && user.role !== ""admin"") {
          const canDelete =
            (await SystemSettings.get(`label = 'users_can_delete_workspaces'`))
              ?.value === ""true"";
          if (!canDelete) {
            response.sendStatus(500).end();
            return;
          }
        }

        await Workspace.delete(`slug = '${slug.toLowerCase()}'`);
        await DocumentVectors.deleteForWorkspace(workspace.id);
        await Document.delete(`workspaceId = ${Number(workspace.id)}`);
        await WorkspaceChats.delete(`workspaceId = ${Number(workspace.id)}`);
        try {
          await VectorDb[""delete-namespace""]({ namespace: slug });
        } catch (e) {
          console.error(e.message);
        }
        response.sendStatus(200).end();
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/workspaces"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      const workspaces = multiUserMode(response)
        ? await Workspace.whereWithUser(user)
        : await Workspace.where();

      response.status(200).json({ workspaces });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/workspace/:slug"", [validatedRequest], async (request, response) => {
    try {
      const { slug } = request.params;
      const user = await userFromSession(request, response);
      const workspace = multiUserMode(response)
        ? await Workspace.getWithUser(user, `slug = '${slug}'`)
        : await Workspace.get(`slug = '${slug}'`);

      response.status(200).json({ workspace });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/workspace/:slug/chats"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { slug } = request.params;
        const user = await userFromSession(request, response);
        const workspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = '${slug}'`)
          : await Workspace.get(`slug = '${slug}'`);

        if (!workspace) {
          response.sendStatus(400).end();
          return;
        }

        const history = multiUserMode(response)
          ? await WorkspaceChats.forWorkspaceByUser(workspace.id, user.id)
          : await WorkspaceChats.forWorkspace(workspace.id);

        response.status(200).json({ history: convertToChatHistory(history) });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { workspaceEndpoints };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR, VAR, VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR, VAR, } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR { VAR = VAR } = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR(VAR, VAR?.VAR); VAR VAR.VAR(""VAR"", { VAR: VAR(VAR), VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR.VAR.VAR || ""VAR"", }); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/:VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR { VAR = VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = '${VAR}'`) : VAR VAR.VAR(`VAR = '${VAR}'`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR( VAR.VAR, VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/:VAR/VAR"", VAR.VAR(""VAR""), VAR VAR (VAR, VAR) { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(); VAR (!VAR) { VAR .VAR(500) .VAR({ VAR: VAR, VAR: `VAR VAR VAR VAR VAR VAR. VAR ${VAR} VAR VAR VAR VAR VAR.`, }) .VAR(); VAR; } VAR { VAR, VAR } = VAR VAR(VAR); VAR (!VAR) { VAR.VAR(500).VAR({ VAR: VAR, VAR: VAR }).VAR(); VAR; } VAR.VAR( `VAR ${VAR} VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR.` ); VAR VAR.VAR(""VAR""); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } ); VAR.VAR( ""/VAR/:VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR { VAR = VAR } = VAR.VAR; VAR { VAR = [], VAR = [] } = VAR(VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = '${VAR}'`) : VAR VAR.VAR(`VAR = '${VAR}'`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR VAR.VAR(VAR, VAR); VAR VAR.VAR(VAR, VAR); VAR VAR = VAR VAR.VAR(`VAR = '${VAR}'`); VAR.VAR(200).VAR({ VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR = """" } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = '${VAR}'`) : VAR VAR.VAR(`VAR = '${VAR}'`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR (VAR(VAR) && VAR.VAR !== ""VAR"") { VAR VAR = (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR""; VAR (!VAR) { VAR.VAR(500).VAR(); VAR; } } VAR VAR.VAR(`VAR = '${VAR.VAR()}'`); VAR VAR.VAR(VAR.VAR); VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR { VAR VAR[""VAR-VAR""]({ VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR); } VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR) : VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = '${VAR}'`) : VAR VAR.VAR(`VAR = '${VAR}'`); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/:VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = '${VAR}'`) : VAR VAR.VAR(`VAR = '${VAR}'`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR.VAR, VAR.VAR) : VAR VAR.VAR(VAR.VAR); VAR.VAR(200).VAR({ VAR: VAR(VAR) }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/swagger/openapi.json,"{
  ""openapi"": ""3.0.0"",
  ""info"": {
    ""version"": ""1.0.0"",
    ""title"": ""AnythingLLM Developer API"",
    ""description"": ""API endpoints that enable programmatic reading, writing, and updating of your AnythingLLM instance. UI supplied by Swagger.io.""
  },
  ""servers"": [
    {
      ""url"": ""http:///api/""
    }
  ],
  ""paths"": {
    ""/v1/auth"": {
      ""get"": {
        ""tags"": [
          ""Authentication""
        ],
        ""description"": ""Verify the attached Authentication header contains a valid API token."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""Valid auth token was found."",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""authenticated"": true
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          }
        }
      }
    },
    ""/v1/admin/is-multi-user-mode"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""isMultiUser"": true
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          }
        }
      }
    },
    ""/v1/admin/users"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""users"": [
                      {
                        ""username"": ""sample-sam"",
                        ""role"": ""default""
                      }
                    ]
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/users/new"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Create a new user with username and password. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""user"": {
                      ""id"": 1,
                      ""username"": ""sample-sam"",
                      ""role"": ""default""
                    },
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Key pair object that will define the new user to add to the system."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""username"": ""sample-sam"",
                ""password"": ""hunter2"",
                ""role"": ""default | admin""
              }
            }
          }
        }
      }
    },
    ""/v1/admin/users/{id}"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Update existing user settings. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""id"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the user in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Key pair object that will update the found user. All fields are optional and will not update unless specified."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""username"": ""sample-sam"",
                ""password"": ""hunter2"",
                ""role"": ""default | admin"",
                ""suspended"": 0
              }
            }
          }
        }
      },
      ""delete"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Delete existing user by id. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""id"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the user in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/invites"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""List all existing invitations to instance regardless of status. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""invites"": [
                      {
                        ""id"": 1,
                        ""status"": ""pending"",
                        ""code"": ""abc-123"",
                        ""claimedBy"": null
                      }
                    ]
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/invite/new"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Create a new invite code for someone to use to register with instance. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""invite"": {
                      ""id"": 1,
                      ""status"": ""pending"",
                      ""code"": ""abc-123""
                    },
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/invite/{id}"": {
      ""delete"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Deactivates (soft-delete) invite by id. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""id"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the invite in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/workspaces/{workspaceId}/update-users"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Overwrite workspace permissions to only be accessible by the given user ids and admins. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""workspaceId"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the workspace in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Entire array of user ids who can access the workspace. All fields are optional and will not update unless specified."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""userIds"": [
                  1,
                  2,
                  4,
                  12
                ]
              }
            }
          }
        }
      }
    },
    ""/v1/admin/workspace-chats"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""All chats in the system ordered by most recent. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Page offset to show of workspace chats. All fields are optional and will not update unless specified."",
          ""required"": false,
          ""type"": ""integer"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""offset"": 2
              }
            }
          }
        }
      }
    },
    ""/v1/admin/preferences"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Show all multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""settings"": {
                      ""users_can_delete_workspaces"": true,
                      ""limit_user_messages"": false,
                      ""message_limit"": 10
                    }
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      },
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Update multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Object with setting key and new value to set. All keys are optional and will not update unless specified."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""users_can_delete_workspaces"": false,
                ""limit_user_messages"": true,
                ""message_limit"": 5
              }
            }
          }
        }
      }
    },
    ""/v1/document/upload"": {
      ""post"": {
        ""tags"": [
          ""Documents""
        ],
        ""description"": ""Upload a new file to AnythingLLM to be parsed and prepared for embedding."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""File to be uploaded."",
          ""required"": true,
          ""type"": ""file"",
          ""content"": {
            ""multipart/form-data"": {
              ""schema"": {
                ""type"": ""object"",
                ""properties"": {
                  ""file"": {
                    ""type"": ""string"",
                    ""format"": ""binary""
                  }
                }
              }
            }
          }
        }
      }
    },
    ""/v1/documents"": {
      ""get"": {
        ""tags"": [
          ""Documents""
        ],
        ""description"": ""List of all locally-stored documents in instance"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""localFiles"": {
                      ""name"": ""documents"",
                      ""type"": ""folder"",
                      ""items"": [
                        {
                          ""name"": ""my-stored-document.json"",
                          ""type"": ""file"",
                          ""id"": ""bb07c334-4dab-4419-9462-9d00065a49a1"",
                          ""url"": ""file://my-stored-document.txt"",
                          ""title"": ""my-stored-document.txt"",
                          ""cached"": false
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/document/accepted-file-types"": {
      ""get"": {
        ""tags"": [
          ""Documents""
        ],
        ""description"": ""Check available filetypes and MIMEs that can be uploaded."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""types"": {
                      ""application/mbox"": [
                        "".mbox""
                      ],
                      ""application/pdf"": [
                        "".pdf""
                      ],
                      ""application/vnd.oasis.opendocument.text"": [
                        "".odt""
                      ],
                      ""application/vnd.openxmlformats-officedocument.wordprocessingml.document"": [
                        "".docx""
                      ],
                      ""text/plain"": [
                        "".txt"",
                        "".md""
                      ]
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""404"": {
            ""description"": ""Not Found""
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/new"": {
      ""post"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Create a new workspace"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""Sample workspace"",
                      ""slug"": ""sample-workspace"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null
                    },
                    ""message"": ""Workspace created""
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""JSON object containing new display name of workspace."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""name"": ""My New Workspace""
              }
            }
          }
        }
      }
    },
    ""/v1/workspaces"": {
      ""get"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""List all current workspaces"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspaces"": [
                      {
                        ""id"": 79,
                        ""name"": ""Sample workspace"",
                        ""slug"": ""sample-workspace"",
                        ""createdAt"": ""2023-08-17 00:45:03"",
                        ""openAiTemp"": null,
                        ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                        ""openAiHistory"": 20,
                        ""openAiPrompt"": null
                      }
                    ]
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/{slug}"": {
      ""get"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Get a workspace by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""My workspace"",
                      ""slug"": ""my-workspace-123"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null,
                      ""documents"": []
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      },
      ""delete"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Deletes a workspace by its slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to delete""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK""
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/{slug}/update"": {
      ""post"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Update workspace settings by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""My workspace"",
                      ""slug"": ""my-workspace-123"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null,
                      ""documents"": []
                    },
                    ""message"": null
                  }
                }
              }
            }
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""JSON object containing new settings to update a workspace. All keys are optional and will not update unless provided"",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""name"": ""Updated Workspace Name"",
                ""openAiTemp"": 0.2,
                ""openAiHistory"": 20,
                ""openAiPrompt"": ""Respond to all inquires and questions in binary - do not respond in any other format.""
              }
            }
          }
        }
      }
    },
    ""/v1/workspace/{slug}/chats"": {
      ""get"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Get a workspaces chats regardless of user by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""history"": [
                      {
                        ""role"": ""user"",
                        ""content"": ""What is AnythingLLM?"",
                        ""sentAt"": 1692851630
                      },
                      {
                        ""role"": ""assistant"",
                        ""content"": ""AnythingLLM is a platform that allows you to convert notes, PDFs, and other source materials into a chatbot. It ensures privacy, cites its answers, and allows multiple people to interact with the same documents simultaneously. It is particularly useful for businesses to enhance the visibility and readability of various written communications such as SOPs, contracts, and sales calls. You can try it out with a free trial to see if it meets your business needs."",
                        ""sources"": [
                          {
                            ""source"": ""object about source document and snippets used""
                          }
                        ]
                      }
                    ]
                  }
                }
              }
            }
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/{slug}/update-embeddings"": {
      ""post"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Add or remove documents from a workspace by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""My workspace"",
                      ""slug"": ""my-workspace-123"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null,
                      ""documents"": []
                    },
                    ""message"": null
                  }
                }
              }
            }
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""JSON object of additions and removals of documents to add to update a workspace. The value should be the folder + filename with the exclusions of the top-level documents path."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""adds"": [],
                ""deletes"": [
                  ""custom-documents/anythingllm-hash.json""
                ]
              }
            }
          }
        }
      }
    },
    ""/v1/system/env-dump"": {
      ""get"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Dump all settings to file storage"",
        ""responses"": {
          ""200"": {
            ""description"": ""OK""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/system"": {
      ""get"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Get all current system settings that are defined."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""settings"": {
                      ""VectorDB"": ""pinecone"",
                      ""PineConeEnvironment"": ""us-west4-gcp-free"",
                      ""PineConeKey"": true,
                      ""PineConeIndex"": ""my-pinecone-index"",
                      ""LLMProvider"": ""azure"",
                      ""[KEY_NAME]"": ""KEY_VALUE""
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/system/vector-count"": {
      ""get"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Number of all vectors in connected vector database"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""vectorCount"": 5450
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/system/update-env"": {
      ""post"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Update a system setting or preference."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""newValues"": {
                      ""[ENV_KEY]"": ""Value""
                    },
                    ""error"": ""error goes here, otherwise null""
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Key pair object that matches a valid setting and value. Get keys from GET /v1/system or refer to codebase."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""VectorDB"": ""lancedb"",
                ""AnotherKey"": ""updatedValue""
              }
            }
          }
        }
      }
    }
  },
  ""components"": {
    ""schemas"": {
      ""InvalidAPIKey"": {
        ""type"": ""object"",
        ""properties"": {
          ""message"": {
            ""type"": ""string"",
            ""example"": ""Invalid API Key""
          }
        },
        ""xml"": {
          ""name"": ""InvalidAPIKey""
        }
      }
    },
    ""securitySchemes"": {
      ""BearerAuth"": {
        ""type"": ""http"",
        ""scheme"": ""bearer"",
        ""bearerFormat"": ""JWT""
      }
    }
  },
  ""security"": [
    {
      ""BearerAuth"": []
    }
  ]
}",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"{ ""VAR"": ""3.0.0"", ""VAR"": { ""VAR"": ""1.0.0"", ""VAR"": ""VAR VAR VAR"", ""VAR"": ""VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR.VAR."" }, ""VAR"": [ { ""VAR"": ""VAR: } ], ""VAR"": { ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR VAR VAR VAR VAR."", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } } } } }, ""/VAR/VAR/VAR-VAR-VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR-VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR-VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"" } ] } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 1, ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"" }, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR | VAR"" } } } } } }, ""/VAR/VAR/VAR/{VAR}"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR | VAR"", ""VAR"": 0 } } } } }, ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": 1, ""VAR"": ""VAR"", ""VAR"": ""VAR-123"", ""VAR"": VAR } ] } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 1, ""VAR"": ""VAR"", ""VAR"": ""VAR-123"" }, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/{VAR}"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR (VAR-VAR) VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/{VAR}/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": [ 1, 2, 4, 12 ] } } } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": 2 } } } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR-VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": VAR, ""VAR"": VAR, ""VAR"": 10 } } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } }, ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR-VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": VAR, ""VAR"": VAR, ""VAR"": 5 } } } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR-VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"" } } } } } } } }, ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR-VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": [ { ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR-4dab-4419-9462-9d00065a49a1"", ""VAR"": ""VAR: ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": VAR } ] } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR-VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR.VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR.VAR-VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"", "".VAR"" ] } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""404"": { ""VAR"": ""VAR VAR"" }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR }, ""VAR"": ""VAR VAR"" } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR VAR VAR"" } } } } } }, ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR } ] } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/{VAR}"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR-123"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR, ""VAR"": [] } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } }, ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"" }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/{VAR}/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR-123"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR, ""VAR"": [] }, ""VAR"": VAR } } } } }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR VAR VAR"", ""VAR"": 0.2, ""VAR"": 20, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR - VAR VAR VAR VAR VAR VAR VAR."" } } } } } }, ""/VAR/VAR/{VAR}/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR VAR VAR?"", ""VAR"": 1692851630 }, { ""VAR"": ""VAR"", ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR"" } ] } ] } } } } }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/{VAR}/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR-123"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR, ""VAR"": [] }, ""VAR"": VAR } } } } }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR + VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": [], ""VAR"": [ ""VAR-VAR/VAR-VAR.VAR"" ] } } } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR"", ""VAR"": { ""200"": { ""VAR"": ""VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR-VAR-VAR-VAR"", ""VAR"": VAR, ""VAR"": ""VAR-VAR-VAR"", ""VAR"": ""VAR"", ""[VAR]"": ""VAR"" } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": 5450 } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""[VAR]"": ""VAR"" }, ""VAR"": ""VAR VAR VAR, VAR VAR"" } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR /VAR/VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"" } } } } } } }, ""VAR"": { ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR"" } } }, ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR"" } } }, ""VAR"": [ { ""VAR"": [] } ] } ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,collector/scripts/yt_utils.py,"import json, requests, os, re
from slugify import slugify
from dotenv import load_dotenv
load_dotenv()

def is_yt_short(videoId):
    url = 'https://www.youtube.com/shorts/' + videoId
    ret = requests.head(url)
    return ret.status_code == 200

def get_channel_id(channel_link):
  if('@' in channel_link):
    pattern = r'https?://www\.youtube\.com/(@\w+)/?'
    match = re.match(pattern, channel_link)
    if match is False: return None
    handle = match.group(1)
    print('Need to map username to channelId - this can take a while sometimes.')
    response = requests.get(f""https://yt.lemnoslife.com/channels?handle={handle}"", timeout=20)

    if(response.ok == False):
      print(""Handle => ChannelId mapping endpoint is too slow - use regular youtube.com/channel URL"")
      return None

    json_data = response.json()
    return json_data.get('items')[0].get('id')
  else:
    pattern = r""youtube\.com/channel/([\w-]+)""
    match = re.search(pattern, channel_link)
    return match.group(1) if match else None


def clean_text(text):
  return re.sub(r""\[.*?\]"", """", text)

def append_meta(video, duration, text):
  meta = {
    'youtubeURL': f""https://youtube.com/watch?v={video.get('id')}"",
    'thumbnail': video.get('thumbnail'),
    'description': video.get('description'),
    'createdAt': video.get('published'),
    'videoDurationInSeconds': duration,
  }
  return ""Video JSON Metadata:\n""+json.dumps(meta, indent=4)+""\n\n\nAudio Transcript:\n"" + text

def get_duration(json_str):
  data = json.loads(json_str)
  return data[-1].get('start')

def fetch_channel_video_information(channel_id, windowSize = 50):
    if channel_id == None or len(channel_id) == 0:
      print(""No channel id provided!"")
      exit(1)

    if os.path.isdir(""./outputs/channel-logs"") == False:
      os.makedirs(""./outputs/channel-logs"")

    file_path = f""./outputs/channel-logs/channel-{channel_id}.json""
    if os.path.exists(file_path):
      with open(file_path, ""r"") as file:
        print(f""Returning cached data for channel {channel_id}. If you do not wish to use stored data then delete the file for this channel to allow refetching."")
        return json.load(file)

    if(os.getenv('GOOGLE_APIS_KEY') == None):
        print(""GOOGLE_APIS_KEY env variable not set!"")
        exit(1)

    done = False
    currentPage = None
    pageTokens = []
    items = []
    data = {
       'id': channel_id,
    }

    print(""Fetching first page of results..."")
    while(done == False):
        url = f""https://www.googleapis.com/youtube/v3/search?key={os.getenv('GOOGLE_APIS_KEY')}&channelId={channel_id}&part=snippet,id&order=date&type=video&maxResults={windowSize}""
        if(currentPage != None):
           print(f""Fetching page ${currentPage}"")
           url += f""&pageToken={currentPage}""

        req = requests.get(url)
        if(req.ok == False):
           print(""Could not fetch channel_id items!"")
           exit(1)

        response = req.json()
        currentPage = response.get('nextPageToken')
        if currentPage in pageTokens:
          print('All pages iterated and logged!')
          done = True
          break

        for item in response.get('items'):
          if 'id' in item and 'videoId' in item.get('id'):
            if is_yt_short(item.get('id').get('videoId')):
              print(f""Filtering out YT Short {item.get('id').get('videoId')}"")
              continue

            if data.get('channelTitle') is None:
              data['channelTitle'] = slugify(item.get('snippet').get('channelTitle'))

            newItem = {
              'id': item.get('id').get('videoId'),
              'url': f""https://youtube.com/watch?v={item.get('id').get('videoId')}"",
              'title': item.get('snippet').get('title'),
              'description':  item.get('snippet').get('description'),
              'thumbnail': item.get('snippet').get('thumbnails').get('high').get('url'),
              'published': item.get('snippet').get('publishTime'),
            }
            items.append(newItem)

        pageTokens.append(currentPage)

    data['items'] = items
    with open(file_path, 'w+', encoding='utf-8') as json_file:
      json.dump(data, json_file, ensure_ascii=True, indent=2)
      print(f""{len(items)} videos found for channel {data.get('channelTitle')}. Saved to channel-logs/channel-{channel_id}.json"")

    return data",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR, VAR, VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR() VAR VAR(VAR): VAR = 'VAR: VAR = VAR.VAR(VAR) VAR VAR.VAR == 200 VAR VAR(VAR): VAR('@' VAR VAR): VAR = VAR'VAR?: VAR = VAR.VAR(VAR, VAR) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR(1) VAR('VAR VAR VAR VAR VAR VAR - VAR VAR VAR VAR VAR VAR.') VAR = VAR.VAR(VAR""VAR: VAR(VAR.VAR == VAR): VAR(""VAR => VAR VAR VAR VAR VAR VAR - VAR VAR VAR.VAR/VAR VAR"") VAR VAR VAR = VAR.VAR() VAR VAR.VAR('VAR')[0].VAR('VAR') VAR: VAR = VAR""VAR\.VAR/VAR/([\VAR-]+)"" VAR = VAR.VAR(VAR, VAR) VAR VAR.VAR(1) VAR VAR VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR""\[.*?\]"", """", VAR) VAR VAR(VAR, VAR, VAR): VAR = { 'VAR': VAR""VAR: 'VAR': VAR.VAR('VAR'), 'VAR': VAR.VAR('VAR'), 'VAR': VAR.VAR('VAR'), 'VAR': VAR, } VAR ""VAR VAR VAR:\VAR""+VAR.VAR(VAR, VAR=4)+""\VAR\VAR\VAR VAR:\VAR"" + VAR VAR VAR(VAR): VAR = VAR.VAR(VAR) VAR VAR[-1].VAR('VAR') VAR VAR(VAR, VAR = 50): VAR VAR == VAR VAR VAR(VAR) == 0: VAR(""VAR VAR VAR VAR!"") VAR(1) VAR VAR.VAR.VAR(""./VAR/VAR-VAR"") == VAR: VAR.VAR(""./VAR/VAR-VAR"") VAR = VAR""./VAR/VAR-VAR/VAR-{VAR}.VAR"" VAR VAR.VAR.VAR(VAR): VAR VAR(VAR, ""VAR"") VAR VAR: VAR(VAR""VAR VAR VAR VAR VAR {VAR}. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR.VAR(VAR) VAR(VAR.VAR('VAR') == VAR): VAR(""VAR VAR VAR VAR VAR!"") VAR(1) VAR = VAR VAR = VAR VAR = [] VAR = [] VAR = { 'VAR': VAR, } VAR(""VAR VAR VAR VAR VAR..."") VAR(VAR == VAR): VAR = VAR""VAR: VAR(VAR != VAR): VAR(VAR""VAR VAR ${VAR}"") VAR += VAR""&VAR={VAR}"" VAR = VAR.VAR(VAR) VAR(VAR.VAR == VAR): VAR(""VAR VAR VAR VAR VAR!"") VAR(1) VAR = VAR.VAR() VAR = VAR.VAR('VAR') VAR VAR VAR VAR: VAR('VAR VAR VAR VAR VAR!') VAR = VAR VAR VAR VAR VAR VAR.VAR('VAR'): VAR 'VAR' VAR VAR VAR 'VAR' VAR VAR.VAR('VAR'): VAR VAR(VAR.VAR('VAR').VAR('VAR')): VAR(VAR""VAR VAR VAR VAR {VAR.VAR('VAR').VAR('VAR')}"") VAR VAR VAR.VAR('VAR') VAR VAR: VAR['VAR'] = VAR(VAR.VAR('VAR').VAR('VAR')) VAR = { 'VAR': VAR.VAR('VAR').VAR('VAR'), 'VAR': VAR""VAR: 'VAR': VAR.VAR('VAR').VAR('VAR'), 'VAR': VAR.VAR('VAR').VAR('VAR'), 'VAR': VAR.VAR('VAR').VAR('VAR').VAR('VAR').VAR('VAR'), 'VAR': VAR.VAR('VAR').VAR('VAR'), } VAR.VAR(VAR) VAR.VAR(VAR) VAR['VAR'] = VAR VAR VAR(VAR, 'VAR+', VAR='VAR-8') VAR VAR: VAR.VAR(VAR, VAR, VAR=VAR, VAR=2) VAR(VAR""{VAR(VAR)} VAR VAR VAR VAR {VAR.VAR('VAR')}. VAR VAR VAR-VAR/VAR-{VAR}.VAR"") VAR VAR ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,collector/scripts/yt_utils.py,"import json, requests, os, re
from slugify import slugify
from dotenv import load_dotenv
load_dotenv()

def is_yt_short(videoId):
    url = 'https://www.youtube.com/shorts/' + videoId
    ret = requests.head(url)
    return ret.status_code == 200

def get_channel_id(channel_link):
  if('@' in channel_link):
    pattern = r'https?://www\.youtube\.com/(@\w+)/?'
    match = re.match(pattern, channel_link)
    if match is False: return None
    handle = match.group(1)
    print('Need to map username to channelId - this can take a while sometimes.')
    response = requests.get(f""https://yt.lemnoslife.com/channels?handle={handle}"", timeout=20)

    if(response.ok == False):
      print(""Handle => ChannelId mapping endpoint is too slow - use regular youtube.com/channel URL"")
      return None

    json_data = response.json()
    return json_data.get('items')[0].get('id')
  else:
    pattern = r""youtube\.com/channel/([\w-]+)""
    match = re.search(pattern, channel_link)
    return match.group(1) if match else None


def clean_text(text):
  return re.sub(r""\[.*?\]"", """", text)

def append_meta(video, duration, text):
  meta = {
    'youtubeURL': f""https://youtube.com/watch?v={video.get('id')}"",
    'thumbnail': video.get('thumbnail'),
    'description': video.get('description'),
    'createdAt': video.get('published'),
    'videoDurationInSeconds': duration,
  }
  return ""Video JSON Metadata:\n""+json.dumps(meta, indent=4)+""\n\n\nAudio Transcript:\n"" + text

def get_duration(json_str):
  data = json.loads(json_str)
  return data[-1].get('start')

def fetch_channel_video_information(channel_id, windowSize = 50):
    if channel_id == None or len(channel_id) == 0:
      print(""No channel id provided!"")
      exit(1)

    if os.path.isdir(""./outputs/channel-logs"") == False:
      os.makedirs(""./outputs/channel-logs"")

    file_path = f""./outputs/channel-logs/channel-{channel_id}.json""
    if os.path.exists(file_path):
      with open(file_path, ""r"") as file:
        print(f""Returning cached data for channel {channel_id}. If you do not wish to use stored data then delete the file for this channel to allow refetching."")
        return json.load(file)

    if(os.getenv('GOOGLE_APIS_KEY') == None):
        print(""GOOGLE_APIS_KEY env variable not set!"")
        exit(1)

    done = False
    currentPage = None
    pageTokens = []
    items = []
    data = {
       'id': channel_id,
    }

    print(""Fetching first page of results..."")
    while(done == False):
        url = f""https://www.googleapis.com/youtube/v3/search?key={os.getenv('GOOGLE_APIS_KEY')}&channelId={channel_id}&part=snippet,id&order=date&type=video&maxResults={windowSize}""
        if(currentPage != None):
           print(f""Fetching page ${currentPage}"")
           url += f""&pageToken={currentPage}""

        req = requests.get(url)
        if(req.ok == False):
           print(""Could not fetch channel_id items!"")
           exit(1)

        response = req.json()
        currentPage = response.get('nextPageToken')
        if currentPage in pageTokens:
          print('All pages iterated and logged!')
          done = True
          break

        for item in response.get('items'):
          if 'id' in item and 'videoId' in item.get('id'):
            if is_yt_short(item.get('id').get('videoId')):
              print(f""Filtering out YT Short {item.get('id').get('videoId')}"")
              continue

            if data.get('channelTitle') is None:
              data['channelTitle'] = slugify(item.get('snippet').get('channelTitle'))

            newItem = {
              'id': item.get('id').get('videoId'),
              'url': f""https://youtube.com/watch?v={item.get('id').get('videoId')}"",
              'title': item.get('snippet').get('title'),
              'description':  item.get('snippet').get('description'),
              'thumbnail': item.get('snippet').get('thumbnails').get('high').get('url'),
              'published': item.get('snippet').get('publishTime'),
            }
            items.append(newItem)

        pageTokens.append(currentPage)

    data['items'] = items
    with open(file_path, 'w+', encoding='utf-8') as json_file:
      json.dump(data, json_file, ensure_ascii=True, indent=2)
      print(f""{len(items)} videos found for channel {data.get('channelTitle')}. Saved to channel-logs/channel-{channel_id}.json"")

    return data",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR, VAR, VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR() VAR VAR(VAR): VAR = 'VAR: VAR = VAR.VAR(VAR) VAR VAR.VAR == 200 VAR VAR(VAR): VAR('@' VAR VAR): VAR = VAR'VAR?: VAR = VAR.VAR(VAR, VAR) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR(1) VAR('VAR VAR VAR VAR VAR VAR - VAR VAR VAR VAR VAR VAR.') VAR = VAR.VAR(VAR""VAR: VAR(VAR.VAR == VAR): VAR(""VAR => VAR VAR VAR VAR VAR VAR - VAR VAR VAR.VAR/VAR VAR"") VAR VAR VAR = VAR.VAR() VAR VAR.VAR('VAR')[0].VAR('VAR') VAR: VAR = VAR""VAR\.VAR/VAR/([\VAR-]+)"" VAR = VAR.VAR(VAR, VAR) VAR VAR.VAR(1) VAR VAR VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR""\[.*?\]"", """", VAR) VAR VAR(VAR, VAR, VAR): VAR = { 'VAR': VAR""VAR: 'VAR': VAR.VAR('VAR'), 'VAR': VAR.VAR('VAR'), 'VAR': VAR.VAR('VAR'), 'VAR': VAR, } VAR ""VAR VAR VAR:\VAR""+VAR.VAR(VAR, VAR=4)+""\VAR\VAR\VAR VAR:\VAR"" + VAR VAR VAR(VAR): VAR = VAR.VAR(VAR) VAR VAR[-1].VAR('VAR') VAR VAR(VAR, VAR = 50): VAR VAR == VAR VAR VAR(VAR) == 0: VAR(""VAR VAR VAR VAR!"") VAR(1) VAR VAR.VAR.VAR(""./VAR/VAR-VAR"") == VAR: VAR.VAR(""./VAR/VAR-VAR"") VAR = VAR""./VAR/VAR-VAR/VAR-{VAR}.VAR"" VAR VAR.VAR.VAR(VAR): VAR VAR(VAR, ""VAR"") VAR VAR: VAR(VAR""VAR VAR VAR VAR VAR {VAR}. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR.VAR(VAR) VAR(VAR.VAR('VAR') == VAR): VAR(""VAR VAR VAR VAR VAR!"") VAR(1) VAR = VAR VAR = VAR VAR = [] VAR = [] VAR = { 'VAR': VAR, } VAR(""VAR VAR VAR VAR VAR..."") VAR(VAR == VAR): VAR = VAR""VAR: VAR(VAR != VAR): VAR(VAR""VAR VAR ${VAR}"") VAR += VAR""&VAR={VAR}"" VAR = VAR.VAR(VAR) VAR(VAR.VAR == VAR): VAR(""VAR VAR VAR VAR VAR!"") VAR(1) VAR = VAR.VAR() VAR = VAR.VAR('VAR') VAR VAR VAR VAR: VAR('VAR VAR VAR VAR VAR!') VAR = VAR VAR VAR VAR VAR VAR.VAR('VAR'): VAR 'VAR' VAR VAR VAR 'VAR' VAR VAR.VAR('VAR'): VAR VAR(VAR.VAR('VAR').VAR('VAR')): VAR(VAR""VAR VAR VAR VAR {VAR.VAR('VAR').VAR('VAR')}"") VAR VAR VAR.VAR('VAR') VAR VAR: VAR['VAR'] = VAR(VAR.VAR('VAR').VAR('VAR')) VAR = { 'VAR': VAR.VAR('VAR').VAR('VAR'), 'VAR': VAR""VAR: 'VAR': VAR.VAR('VAR').VAR('VAR'), 'VAR': VAR.VAR('VAR').VAR('VAR'), 'VAR': VAR.VAR('VAR').VAR('VAR').VAR('VAR').VAR('VAR'), 'VAR': VAR.VAR('VAR').VAR('VAR'), } VAR.VAR(VAR) VAR.VAR(VAR) VAR['VAR'] = VAR VAR VAR(VAR, 'VAR+', VAR='VAR-8') VAR VAR: VAR.VAR(VAR, VAR, VAR=VAR, VAR=2) VAR(VAR""{VAR(VAR)} VAR VAR VAR VAR {VAR.VAR('VAR')}. VAR VAR VAR-VAR/VAR-{VAR}.VAR"") VAR VAR ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,docker/docker-healthcheck.sh,"#!/bin/bash

# Send a request to the specified URL
response=$(curl --write-out '%{http_code}' --silent --output /dev/null http://localhost:3001/api/ping)

# If the HTTP response code is 200 (OK), the server is up
if [ $response -eq 200 ]; then
    echo ""Server is up""
    exit 0
else
    echo ""Server is down""
    exit 1
fi",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"  VAR=$(VAR --VAR-VAR '%{VAR}' --VAR --VAR /VAR/VAR VAR:  VAR [ $VAR -VAR 200 ]; VAR VAR ""VAR VAR VAR"" VAR 0 VAR VAR ""VAR VAR VAR"" VAR 1 VAR ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,docker/docker-healthcheck.sh,"#!/bin/bash

# Send a request to the specified URL
response=$(curl --write-out '%{http_code}' --silent --output /dev/null http://localhost:3001/api/ping)

# If the HTTP response code is 200 (OK), the server is up
if [ $response -eq 200 ]; then
    echo ""Server is up""
    exit 0
else
    echo ""Server is down""
    exit 1
fi",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"  VAR=$(VAR --VAR-VAR '%{VAR}' --VAR --VAR /VAR/VAR VAR:  VAR [ $VAR -VAR 200 ]; VAR VAR ""VAR VAR VAR"" VAR 0 VAR VAR ""VAR VAR VAR"" VAR 1 VAR ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/utils/session.js,"import { API_BASE } from ""./constants"";
import { baseHeaders } from ""./request"";

// Checks current localstorage and validates the session based on that.
export default async function validateSessionTokenForUser() {
  const isValidSession = await fetch(`${API_BASE}/system/check-token`, {
    method: ""GET"",
    cache: ""default"",
    headers: baseHeaders(),
  })
    .then((res) => res.status === 200)
    .catch(() => false);

  return isValidSession;
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } VAR ""./VAR""; VAR { VAR } VAR ""./VAR"";  VAR VAR VAR VAR VAR() { VAR VAR = VAR VAR(`${VAR}/VAR/VAR-VAR`, { VAR: ""VAR"", VAR: ""VAR"", VAR: VAR(), }) .VAR((VAR) => VAR.VAR === 200) .VAR(() => VAR); VAR VAR; } ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/utils/session.js,"import { API_BASE } from ""./constants"";
import { baseHeaders } from ""./request"";

// Checks current localstorage and validates the session based on that.
export default async function validateSessionTokenForUser() {
  const isValidSession = await fetch(`${API_BASE}/system/check-token`, {
    method: ""GET"",
    cache: ""default"",
    headers: baseHeaders(),
  })
    .then((res) => res.status === 200)
    .catch(() => false);

  return isValidSession;
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } VAR ""./VAR""; VAR { VAR } VAR ""./VAR"";  VAR VAR VAR VAR VAR() { VAR VAR = VAR VAR(`${VAR}/VAR/VAR-VAR`, { VAR: ""VAR"", VAR: ""VAR"", VAR: VAR(), }) .VAR((VAR) => VAR.VAR === 200) .VAR(() => VAR); VAR VAR; } ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/admin.js,"const { escape } = require(""sqlstring-sqlite"");
const { ApiKey } = require(""../models/apiKeys"");
const { Document } = require(""../models/documents"");
const { Invite } = require(""../models/invite"");
const { SystemSettings } = require(""../models/systemSettings"");
const { User } = require(""../models/user"");
const { DocumentVectors } = require(""../models/vectors"");
const { Workspace } = require(""../models/workspace"");
const { WorkspaceChats } = require(""../models/workspaceChats"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { userFromSession, reqBody } = require(""../utils/http"");
const { validatedRequest } = require(""../utils/middleware/validatedRequest"");

function adminEndpoints(app) {
  if (!app) return;

  app.get(""/admin/users"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }
      const users = (await User.where()).map((user) => {
        const { password, ...rest } = user;
        return rest;
      });
      response.status(200).json({ users });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/admin/users/new"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const newUserParams = reqBody(request);
        const { user: newUser, error } = await User.create(newUserParams);
        response.status(200).json({ user: newUser, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(""/admin/user/:id"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }

      const { id } = request.params;
      const updates = reqBody(request);
      const { success, error } = await User.update(id, updates);
      response.status(200).json({ success, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/admin/user/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const { id } = request.params;
        await User.delete(`id = ${id}`);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/admin/invites"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }

      const invites = await Invite.whereWithUsers();
      response.status(200).json({ invites });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/admin/invite/new"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { invite, error } = await Invite.create(user.id);
        response.status(200).json({ invite, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/invite/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        const { success, error } = await Invite.deactivate(id);
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(
    ""/admin/workspaces"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const workspaces = await Workspace.whereWithUsers();
        response.status(200).json({ workspaces });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/workspaces/new"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const { name } = reqBody(request);
        const { workspace, message: error } = await Workspace.new(
          name,
          user.id
        );
        response.status(200).json({ workspace, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/workspaces/:workspaceId/update-users"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { workspaceId } = request.params;
        const { userIds } = reqBody(request);
        const { success, error } = await Workspace.updateUsers(
          escape(Number(workspaceId)),
          userIds
        );
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/workspaces/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        const VectorDb = getVectorDbClass();
        const workspace = Workspace.get(`id = ${escape(id)}`);
        if (!workspace) {
          response.sendStatus(404).end();
          return;
        }

        await Workspace.delete(`id = ${workspace.id}`);
        await DocumentVectors.deleteForWorkspace(workspace.id);
        await Document.delete(`workspaceId = ${Number(workspace.id)}`);
        await WorkspaceChats.delete(`workspaceId = ${Number(workspace.id)}`);
        try {
          await VectorDb[""delete-namespace""]({ namespace: workspace.slug });
        } catch (e) {
          console.error(e.message);
        }

        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/workspace-chats"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const { offset = 0 } = reqBody(request);
        const chats = await WorkspaceChats.whereWithData(
          `id >= ${escape(offset)}`,
          20
        );
        const hasPages = (await WorkspaceChats.count()) > 20;
        response.status(200).json({ chats: chats.reverse(), hasPages });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/workspace-chats/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        await WorkspaceChats.delete(`id = ${id}`);
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(
    ""/admin/system-preferences"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const settings = {
          users_can_delete_workspaces:
            (await SystemSettings.get(`label = 'users_can_delete_workspaces'`))
              ?.value === ""true"",
          limit_user_messages:
            (await SystemSettings.get(`label = 'limit_user_messages'`))
              ?.value === ""true"",
          message_limit:
            Number(
              (await SystemSettings.get(`label = 'message_limit'`))?.value
            ) || 10,
        };
        response.status(200).json({ settings });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/system-preferences"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const updates = reqBody(request);
        await SystemSettings.updateSettings(updates);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/admin/api-keys"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }

      const apiKeys = await ApiKey.whereWithUser(""id IS NOT NULL"");
      return response.status(200).json({
        apiKeys,
        error: null,
      });
    } catch (error) {
      console.error(error);
      response.status(500).json({
        apiKey: null,
        error: ""Could not find an API Keys."",
      });
    }
  });

  app.post(
    ""/admin/generate-api-key"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { apiKey, error } = await ApiKey.create(user.id);
        return response.status(200).json({
          apiKey,
          error,
        });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/delete-api-key/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { id } = request.params;
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        await ApiKey.delete(`id = ${id}`);
        return response.status(200).end();
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { adminEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR-VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = (VAR VAR.VAR()).VAR((VAR) => { VAR { VAR, ...VAR } = VAR; VAR VAR; }); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR { VAR: VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR(VAR, VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR.VAR(`VAR = ${VAR}`); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(VAR.VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR(VAR); VAR { VAR, VAR: VAR } = VAR VAR.VAR( VAR, VAR.VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/:VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR } = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR( VAR(VAR(VAR)), VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR = VAR(); VAR VAR = VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(404).VAR(); VAR; } VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR VAR.VAR(VAR.VAR); VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR { VAR VAR[""VAR-VAR""]({ VAR: VAR.VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR); } VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR = 0 } = VAR(VAR); VAR VAR = VAR VAR.VAR( `VAR >= ${VAR(VAR)}`, 20 ); VAR VAR = (VAR VAR.VAR()) > 20; VAR.VAR(200).VAR({ VAR: VAR.VAR(), VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR.VAR(`VAR = ${VAR}`); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = { VAR: (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR"", VAR: (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR"", VAR: VAR( (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR ) || 10, }; VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(""VAR VAR VAR VAR""); VAR VAR.VAR(200).VAR({ VAR, VAR: VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."", }); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(VAR.VAR); VAR VAR.VAR(200).VAR({ VAR, VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR.VAR(`VAR = ${VAR}`); VAR VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/admin.js,"const { escape } = require(""sqlstring-sqlite"");
const { ApiKey } = require(""../models/apiKeys"");
const { Document } = require(""../models/documents"");
const { Invite } = require(""../models/invite"");
const { SystemSettings } = require(""../models/systemSettings"");
const { User } = require(""../models/user"");
const { DocumentVectors } = require(""../models/vectors"");
const { Workspace } = require(""../models/workspace"");
const { WorkspaceChats } = require(""../models/workspaceChats"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { userFromSession, reqBody } = require(""../utils/http"");
const { validatedRequest } = require(""../utils/middleware/validatedRequest"");

function adminEndpoints(app) {
  if (!app) return;

  app.get(""/admin/users"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }
      const users = (await User.where()).map((user) => {
        const { password, ...rest } = user;
        return rest;
      });
      response.status(200).json({ users });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/admin/users/new"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const newUserParams = reqBody(request);
        const { user: newUser, error } = await User.create(newUserParams);
        response.status(200).json({ user: newUser, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(""/admin/user/:id"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }

      const { id } = request.params;
      const updates = reqBody(request);
      const { success, error } = await User.update(id, updates);
      response.status(200).json({ success, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/admin/user/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const { id } = request.params;
        await User.delete(`id = ${id}`);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/admin/invites"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }

      const invites = await Invite.whereWithUsers();
      response.status(200).json({ invites });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/admin/invite/new"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { invite, error } = await Invite.create(user.id);
        response.status(200).json({ invite, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/invite/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        const { success, error } = await Invite.deactivate(id);
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(
    ""/admin/workspaces"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const workspaces = await Workspace.whereWithUsers();
        response.status(200).json({ workspaces });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/workspaces/new"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const { name } = reqBody(request);
        const { workspace, message: error } = await Workspace.new(
          name,
          user.id
        );
        response.status(200).json({ workspace, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/workspaces/:workspaceId/update-users"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { workspaceId } = request.params;
        const { userIds } = reqBody(request);
        const { success, error } = await Workspace.updateUsers(
          escape(Number(workspaceId)),
          userIds
        );
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/workspaces/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        const VectorDb = getVectorDbClass();
        const workspace = Workspace.get(`id = ${escape(id)}`);
        if (!workspace) {
          response.sendStatus(404).end();
          return;
        }

        await Workspace.delete(`id = ${workspace.id}`);
        await DocumentVectors.deleteForWorkspace(workspace.id);
        await Document.delete(`workspaceId = ${Number(workspace.id)}`);
        await WorkspaceChats.delete(`workspaceId = ${Number(workspace.id)}`);
        try {
          await VectorDb[""delete-namespace""]({ namespace: workspace.slug });
        } catch (e) {
          console.error(e.message);
        }

        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/workspace-chats"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }
        const { offset = 0 } = reqBody(request);
        const chats = await WorkspaceChats.whereWithData(
          `id >= ${escape(offset)}`,
          20
        );
        const hasPages = (await WorkspaceChats.count()) > 20;
        response.status(200).json({ chats: chats.reverse(), hasPages });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/workspace-chats/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        await WorkspaceChats.delete(`id = ${id}`);
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(
    ""/admin/system-preferences"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const settings = {
          users_can_delete_workspaces:
            (await SystemSettings.get(`label = 'users_can_delete_workspaces'`))
              ?.value === ""true"",
          limit_user_messages:
            (await SystemSettings.get(`label = 'limit_user_messages'`))
              ?.value === ""true"",
          message_limit:
            Number(
              (await SystemSettings.get(`label = 'message_limit'`))?.value
            ) || 10,
        };
        response.status(200).json({ settings });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/admin/system-preferences"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const updates = reqBody(request);
        await SystemSettings.updateSettings(updates);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/admin/api-keys"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      if (!user || user?.role !== ""admin"") {
        response.sendStatus(401).end();
        return;
      }

      const apiKeys = await ApiKey.whereWithUser(""id IS NOT NULL"");
      return response.status(200).json({
        apiKeys,
        error: null,
      });
    } catch (error) {
      console.error(error);
      response.status(500).json({
        apiKey: null,
        error: ""Could not find an API Keys."",
      });
    }
  });

  app.post(
    ""/admin/generate-api-key"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        const { apiKey, error } = await ApiKey.create(user.id);
        return response.status(200).json({
          apiKey,
          error,
        });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/admin/delete-api-key/:id"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { id } = request.params;
        const user = await userFromSession(request, response);
        if (!user || user?.role !== ""admin"") {
          response.sendStatus(401).end();
          return;
        }

        await ApiKey.delete(`id = ${id}`);
        return response.status(200).end();
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { adminEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR-VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = (VAR VAR.VAR()).VAR((VAR) => { VAR { VAR, ...VAR } = VAR; VAR VAR; }); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR { VAR: VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR(VAR, VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR.VAR(`VAR = ${VAR}`); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(VAR.VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR(VAR); VAR { VAR, VAR: VAR } = VAR VAR.VAR( VAR, VAR.VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/:VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR } = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR( VAR(VAR(VAR)), VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR = VAR(); VAR VAR = VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(404).VAR(); VAR; } VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR VAR.VAR(VAR.VAR); VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR { VAR VAR[""VAR-VAR""]({ VAR: VAR.VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR); } VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR = 0 } = VAR(VAR); VAR VAR = VAR VAR.VAR( `VAR >= ${VAR(VAR)}`, 20 ); VAR VAR = (VAR VAR.VAR()) > 20; VAR.VAR(200).VAR({ VAR: VAR.VAR(), VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR.VAR(`VAR = ${VAR}`); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = { VAR: (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR"", VAR: (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR"", VAR: VAR( (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR ) || 10, }; VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(""VAR VAR VAR VAR""); VAR VAR.VAR(200).VAR({ VAR, VAR: VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."", }); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(VAR.VAR); VAR VAR.VAR(200).VAR({ VAR, VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR?.VAR !== ""VAR"") { VAR.VAR(401).VAR(); VAR; } VAR VAR.VAR(`VAR = ${VAR}`); VAR VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/api/admin/index.js,"const { escape } = require(""sqlstring-sqlite"");
const { Invite } = require(""../../../models/invite"");
const { SystemSettings } = require(""../../../models/systemSettings"");
const { User } = require(""../../../models/user"");
const { Workspace } = require(""../../../models/workspace"");
const { WorkspaceChats } = require(""../../../models/workspaceChats"");
const { multiUserMode, reqBody } = require(""../../../utils/http"");
const { validApiKey } = require(""../../../utils/middleware/validApiKey"");

function apiAdminEndpoints(app) {
  if (!app) return;

  app.get(""/v1/admin/is-multi-user-mode"", [validApiKey], (_, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""isMultiUser"": true
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    const isMultiUser = multiUserMode(response);
    response.status(200).json({ isMultiUser });
  });

  app.get(""/v1/admin/users"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""users"": [
                {
                  username: ""sample-sam"",
                  role: 'default',
                }
             ]
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const users = (await User.where()).map((user) => {
        const { password, ...rest } = user;
        return rest;
      });
      response.status(200).json({ users });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/v1/admin/users/new"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Create a new user with username and password. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Key pair object that will define the new user to add to the system.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              username: ""sample-sam"",
              password: 'hunter2',
              role: 'default | admin'
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              user: {
                id: 1,
                username: 'sample-sam',
                role: 'default',
              },
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const newUserParams = reqBody(request);
      const { user: newUser, error } = await User.create(newUserParams);
      response.status(200).json({ user: newUser, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/v1/admin/users/:id"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.path = '/v1/admin/users/{id}'
    #swagger.parameters['id'] = {
      in: 'path',
      description: 'id of the user in the database.',
      required: true,
      type: 'string'
    }
    #swagger.description = 'Update existing user settings. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Key pair object that will update the found user. All fields are optional and will not update unless specified.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              username: ""sample-sam"",
              password: 'hunter2',
              role: 'default | admin',
              suspended: 0,
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const { id } = request.params;
      const updates = reqBody(request);
      const { success, error } = await User.update(id, updates);
      response.status(200).json({ success, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/v1/admin/users/:id"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Delete existing user by id. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.path = '/v1/admin/users/{id}'
    #swagger.parameters['id'] = {
      in: 'path',
      description: 'id of the user in the database.',
      required: true,
      type: 'string'
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        await User.delete(`id = ${id}`);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/v1/admin/invites"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'List all existing invitations to instance regardless of status. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""invites"": [
                {
                  id: 1,
                  status: ""pending"",
                  code: 'abc-123',
                  claimedBy: null
                }
             ]
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const invites = await Invite.whereWithUsers();
      response.status(200).json({ invites });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/v1/admin/invite/new"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Create a new invite code for someone to use to register with instance. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              invite: {
                id: 1,
                status: ""pending"",
                code: 'abc-123',
              },
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const { invite, error } = await Invite.create();
      response.status(200).json({ invite, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/v1/admin/invite/:id"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Deactivates (soft-delete) invite by id. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.path = '/v1/admin/invite/{id}'
    #swagger.parameters['id'] = {
      in: 'path',
      description: 'id of the invite in the database.',
      required: true,
      type: 'string'
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        const { success, error } = await Invite.deactivate(id);
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/v1/admin/workspaces/:workspaceId/update-users"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.path = '/v1/admin/workspaces/{workspaceId}/update-users'
    #swagger.parameters['workspaceId'] = {
      in: 'path',
      description: 'id of the workspace in the database.',
      required: true,
      type: 'string'
    }
    #swagger.description = 'Overwrite workspace permissions to only be accessible by the given user ids and admins. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Entire array of user ids who can access the workspace. All fields are optional and will not update unless specified.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              userIds: [1,2,4,12],
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { workspaceId } = request.params;
        const { userIds } = reqBody(request);
        const { success, error } = await Workspace.updateUsers(
          escape(Number(workspaceId)),
          userIds
        );
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/v1/admin/workspace-chats"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'All chats in the system ordered by most recent. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Page offset to show of workspace chats. All fields are optional and will not update unless specified.',
        required: false,
        type: 'integer',
        content: {
          ""application/json"": {
            example: {
              offset: 2,
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { offset = 0 } = reqBody(request);
        const chats = await WorkspaceChats.whereWithData(
          `id >= ${escape(offset)}`,
          20
        );
        const hasPages = (await WorkspaceChats.count()) > 20;
        response.status(200).json({ chats: chats.reverse(), hasPages });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/v1/admin/preferences"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Show all multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              settings: {
                users_can_delete_workspaces: true,
                limit_user_messages: false,
                message_limit: 10,
              }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const settings = {
        users_can_delete_workspaces:
          (await SystemSettings.get(`label = 'users_can_delete_workspaces'`))
            ?.value === ""true"",
        limit_user_messages:
          (await SystemSettings.get(`label = 'limit_user_messages'`))?.value ===
          ""true"",
        message_limit:
          Number(
            (await SystemSettings.get(`label = 'message_limit'`))?.value
          ) || 10,
      };
      response.status(200).json({ settings });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/v1/admin/preferences"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Update multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
      description: 'Object with setting key and new value to set. All keys are optional and will not update unless specified.',
      required: true,
      type: 'object',
      content: {
        ""application/json"": {
          example: {
            users_can_delete_workspaces: false,
            limit_user_messages: true,
            message_limit: 5,
          }
        }
      }
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const updates = reqBody(request);
        await SystemSettings.updateSettings(updates);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { apiAdminEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR-VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR, VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR/VAR-VAR-VAR-VAR"", [VAR], (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": VAR } } } } }  VAR: { ""$VAR"": "" } } */ VAR VAR = VAR(VAR); VAR.VAR(200).VAR({ VAR }); }); VAR.VAR(""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": [ { VAR: ""VAR-VAR"", VAR: 'VAR', } ] } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = (VAR VAR.VAR()).VAR((VAR) => { VAR { VAR, ...VAR } = VAR; VAR VAR; }); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: ""VAR-VAR"", VAR: 'VAR', VAR: 'VAR | VAR' } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: 1, VAR: 'VAR-VAR', VAR: 'VAR', }, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR { VAR: VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }   VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: ""VAR-VAR"", VAR: 'VAR', VAR: 'VAR | VAR', VAR: 0, } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR(VAR, VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { /*     VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR.VAR(`VAR = ${VAR}`); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": [ { VAR: 1, VAR: ""VAR"", VAR: 'VAR-123', VAR: VAR } ] } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: 1, VAR: ""VAR"", VAR: 'VAR-123', }, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { /*     VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/VAR/:VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }   VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: [1,2,4,12], } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR } = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR( VAR(VAR(VAR)), VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: 2, } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR = 0 } = VAR(VAR); VAR VAR = VAR VAR.VAR( `VAR >= ${VAR(VAR)}`, 20 ); VAR VAR = (VAR VAR.VAR()) > 20; VAR.VAR(200).VAR({ VAR: VAR.VAR(), VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: VAR, VAR: VAR, VAR: 10, } } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = { VAR: (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR"", VAR: (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR === ""VAR"", VAR: VAR( (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR ) || 10, }; VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: VAR, VAR: VAR, VAR: 5, } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/api/admin/index.js,"const { escape } = require(""sqlstring-sqlite"");
const { Invite } = require(""../../../models/invite"");
const { SystemSettings } = require(""../../../models/systemSettings"");
const { User } = require(""../../../models/user"");
const { Workspace } = require(""../../../models/workspace"");
const { WorkspaceChats } = require(""../../../models/workspaceChats"");
const { multiUserMode, reqBody } = require(""../../../utils/http"");
const { validApiKey } = require(""../../../utils/middleware/validApiKey"");

function apiAdminEndpoints(app) {
  if (!app) return;

  app.get(""/v1/admin/is-multi-user-mode"", [validApiKey], (_, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""isMultiUser"": true
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    const isMultiUser = multiUserMode(response);
    response.status(200).json({ isMultiUser });
  });

  app.get(""/v1/admin/users"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""users"": [
                {
                  username: ""sample-sam"",
                  role: 'default',
                }
             ]
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const users = (await User.where()).map((user) => {
        const { password, ...rest } = user;
        return rest;
      });
      response.status(200).json({ users });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/v1/admin/users/new"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Create a new user with username and password. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Key pair object that will define the new user to add to the system.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              username: ""sample-sam"",
              password: 'hunter2',
              role: 'default | admin'
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              user: {
                id: 1,
                username: 'sample-sam',
                role: 'default',
              },
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const newUserParams = reqBody(request);
      const { user: newUser, error } = await User.create(newUserParams);
      response.status(200).json({ user: newUser, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/v1/admin/users/:id"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.path = '/v1/admin/users/{id}'
    #swagger.parameters['id'] = {
      in: 'path',
      description: 'id of the user in the database.',
      required: true,
      type: 'string'
    }
    #swagger.description = 'Update existing user settings. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Key pair object that will update the found user. All fields are optional and will not update unless specified.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              username: ""sample-sam"",
              password: 'hunter2',
              role: 'default | admin',
              suspended: 0,
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const { id } = request.params;
      const updates = reqBody(request);
      const { success, error } = await User.update(id, updates);
      response.status(200).json({ success, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/v1/admin/users/:id"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Delete existing user by id. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.path = '/v1/admin/users/{id}'
    #swagger.parameters['id'] = {
      in: 'path',
      description: 'id of the user in the database.',
      required: true,
      type: 'string'
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        await User.delete(`id = ${id}`);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/v1/admin/invites"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'List all existing invitations to instance regardless of status. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""invites"": [
                {
                  id: 1,
                  status: ""pending"",
                  code: 'abc-123',
                  claimedBy: null
                }
             ]
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const invites = await Invite.whereWithUsers();
      response.status(200).json({ invites });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/v1/admin/invite/new"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Create a new invite code for someone to use to register with instance. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              invite: {
                id: 1,
                status: ""pending"",
                code: 'abc-123',
              },
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const { invite, error } = await Invite.create();
      response.status(200).json({ invite, error });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/v1/admin/invite/:id"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Deactivates (soft-delete) invite by id. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.path = '/v1/admin/invite/{id}'
    #swagger.parameters['id'] = {
      in: 'path',
      description: 'id of the invite in the database.',
      required: true,
      type: 'string'
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { id } = request.params;
        const { success, error } = await Invite.deactivate(id);
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/v1/admin/workspaces/:workspaceId/update-users"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.path = '/v1/admin/workspaces/{workspaceId}/update-users'
    #swagger.parameters['workspaceId'] = {
      in: 'path',
      description: 'id of the workspace in the database.',
      required: true,
      type: 'string'
    }
    #swagger.description = 'Overwrite workspace permissions to only be accessible by the given user ids and admins. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Entire array of user ids who can access the workspace. All fields are optional and will not update unless specified.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              userIds: [1,2,4,12],
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { workspaceId } = request.params;
        const { userIds } = reqBody(request);
        const { success, error } = await Workspace.updateUsers(
          escape(Number(workspaceId)),
          userIds
        );
        response.status(200).json({ success, error });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/v1/admin/workspace-chats"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'All chats in the system ordered by most recent. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
        description: 'Page offset to show of workspace chats. All fields are optional and will not update unless specified.',
        required: false,
        type: 'integer',
        content: {
          ""application/json"": {
            example: {
              offset: 2,
            }
          }
        }
      }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const { offset = 0 } = reqBody(request);
        const chats = await WorkspaceChats.whereWithData(
          `id >= ${escape(offset)}`,
          20
        );
        const hasPages = (await WorkspaceChats.count()) > 20;
        response.status(200).json({ chats: chats.reverse(), hasPages });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/v1/admin/preferences"", [validApiKey], async (request, response) => {
    /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Show all multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              settings: {
                users_can_delete_workspaces: true,
                limit_user_messages: false,
                message_limit: 10,
              }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
    try {
      if (!multiUserMode(response)) {
        response.sendStatus(401).end();
        return;
      }

      const settings = {
        users_can_delete_workspaces:
          (await SystemSettings.get(`label = 'users_can_delete_workspaces'`))
            ?.value === ""true"",
        limit_user_messages:
          (await SystemSettings.get(`label = 'limit_user_messages'`))?.value ===
          ""true"",
        message_limit:
          Number(
            (await SystemSettings.get(`label = 'message_limit'`))?.value
          ) || 10,
      };
      response.status(200).json({ settings });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/v1/admin/preferences"",
    [validApiKey],
    async (request, response) => {
      /*
    #swagger.tags = ['Admin']
    #swagger.description = 'Update multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI.'
    #swagger.requestBody = {
      description: 'Object with setting key and new value to set. All keys are optional and will not update unless specified.',
      required: true,
      type: 'object',
      content: {
        ""application/json"": {
          example: {
            users_can_delete_workspaces: false,
            limit_user_messages: true,
            message_limit: 5,
          }
        }
      }
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
     #swagger.responses[401] = {
      description: ""Instance is not in Multi-User mode. Method denied"",
    }
    */
      try {
        if (!multiUserMode(response)) {
          response.sendStatus(401).end();
          return;
        }

        const updates = reqBody(request);
        await SystemSettings.updateSettings(updates);
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.error(e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { apiAdminEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR-VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR, VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR/VAR-VAR-VAR-VAR"", [VAR], (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": VAR } } } } }  VAR: { ""$VAR"": "" } } */ VAR VAR = VAR(VAR); VAR.VAR(200).VAR({ VAR }); }); VAR.VAR(""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": [ { VAR: ""VAR-VAR"", VAR: 'VAR', } ] } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = (VAR VAR.VAR()).VAR((VAR) => { VAR { VAR, ...VAR } = VAR; VAR VAR; }); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: ""VAR-VAR"", VAR: 'VAR', VAR: 'VAR | VAR' } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: 1, VAR: 'VAR-VAR', VAR: 'VAR', }, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR { VAR: VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }   VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: ""VAR-VAR"", VAR: 'VAR', VAR: 'VAR | VAR', VAR: 0, } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR(VAR, VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { /*     VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR VAR.VAR(`VAR = ${VAR}`); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": [ { VAR: 1, VAR: ""VAR"", VAR: 'VAR-123', VAR: VAR } ] } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: 1, VAR: ""VAR"", VAR: 'VAR-123', }, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { /*     VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR, VAR } = VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/VAR/:VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR', VAR: 'VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR' }   VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: [1,2,4,12], } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR } = VAR.VAR; VAR { VAR } = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR( VAR(VAR(VAR)), VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: 2, } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR { VAR = 0 } = VAR(VAR); VAR VAR = VAR VAR.VAR( `VAR >= ${VAR(VAR)}`, 20 ); VAR VAR = (VAR VAR.VAR()) > 20; VAR.VAR(200).VAR({ VAR: VAR.VAR(), VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: VAR, VAR: VAR, VAR: 10, } } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = { VAR: (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR"", VAR: (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR === ""VAR"", VAR: VAR( (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR ) || 10, }; VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: VAR, VAR: VAR, VAR: 5, } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } }  VAR: ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"", } */ VAR { VAR (!VAR(VAR)) { VAR.VAR(401).VAR(); VAR; } VAR VAR = VAR(VAR); VAR VAR.VAR(VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/api/auth/index.js,"const { validApiKey } = require(""../../../utils/middleware/validApiKey"");

function apiAuthEndpoints(app) {
  if (!app) return;

  app.get(""/v1/auth"", [validApiKey], (_, response) => {
    /*
    #swagger.tags = ['Authentication']
    #swagger.description = 'Verify the attached Authentication header contains a valid API token.'
    #swagger.responses[200] = {
      description: 'Valid auth token was found.',
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              authenticated: true,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    response.status(200).json({ authenticated: true });
  });
}

module.exports = { apiAuthEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", [VAR], (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR.', VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } } */ VAR.VAR(200).VAR({ VAR: VAR }); }); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/api/auth/index.js,"const { validApiKey } = require(""../../../utils/middleware/validApiKey"");

function apiAuthEndpoints(app) {
  if (!app) return;

  app.get(""/v1/auth"", [validApiKey], (_, response) => {
    /*
    #swagger.tags = ['Authentication']
    #swagger.description = 'Verify the attached Authentication header contains a valid API token.'
    #swagger.responses[200] = {
      description: 'Valid auth token was found.',
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              authenticated: true,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    response.status(200).json({ authenticated: true });
  });
}

module.exports = { apiAuthEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", [VAR], (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR.', VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } } */ VAR.VAR(200).VAR({ VAR: VAR }); }); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/api/document/index.js,"const { Telemetry } = require(""../../../models/telemetry"");
const { validApiKey } = require(""../../../utils/middleware/validApiKey"");
const { setupMulter } = require(""../../../utils/files/multer"");
const {
  checkPythonAppAlive,
  acceptedFileTypes,
  processDocument,
} = require(""../../../utils/files/documentProcessor"");
const { viewLocalFiles } = require(""../../../utils/files"");
const { handleUploads } = setupMulter();

function apiDocumentEndpoints(app) {
  if (!app) return;

  app.post(
    ""/v1/document/upload"",
    [validApiKey],
    handleUploads.single(""file""),
    async (request, response) => {
      /*
    #swagger.tags = ['Documents']
    #swagger.description = 'Upload a new file to AnythingLLM to be parsed and prepared for embedding.'

    #swagger.requestBody = {
      description: 'File to be uploaded.',
      required: true,
      type: 'file',
      content: {
        ""multipart/form-data"": {
          schema: {
            type: 'object',
            properties: {
              file: {
                type: 'string',
                format: 'binary',
              }
            }
          }
        }
      }
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
      try {
        const { originalname } = request.file;
        const processingOnline = await checkPythonAppAlive();

        if (!processingOnline) {
          response
            .status(500)
            .json({
              success: false,
              error: `Python processing API is not online. Document ${originalname} will not be processed automatically.`,
            })
            .end();
        }

        const { success, reason } = await processDocument(originalname);
        if (!success) {
          response.status(500).json({ success: false, error: reason }).end();
        }

        console.log(
          `Document ${originalname} uploaded processed and successfully. It is now available in documents.`
        );
        await Telemetry.sendTelemetry(""document_uploaded"");
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/v1/documents"", [validApiKey], async (_, response) => {
    /*
    #swagger.tags = ['Documents']
    #swagger.description = 'List of all locally-stored documents in instance'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""localFiles"": {
              ""name"": ""documents"",
              ""type"": ""folder"",
              items: [
                {
                  ""name"": ""my-stored-document.json"",
                  ""type"": ""file"",
                  ""id"": ""bb07c334-4dab-4419-9462-9d00065a49a1"",
                  ""url"": ""file://my-stored-document.txt"",
                  ""title"": ""my-stored-document.txt"",
                  ""cached"": false
                },
              ]
             }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    try {
      const localFiles = await viewLocalFiles();
      response.status(200).json({ localFiles });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/v1/document/accepted-file-types"",
    [validApiKey],
    async (_, response) => {
      /*
    #swagger.tags = ['Documents']
    #swagger.description = 'Check available filetypes and MIMEs that can be uploaded.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              ""types"": {
                ""application/mbox"": [
                  "".mbox""
                ],
                ""application/pdf"": [
                  "".pdf""
                ],
                ""application/vnd.oasis.opendocument.text"": [
                  "".odt""
                ],
                ""application/vnd.openxmlformats-officedocument.wordprocessingml.document"": [
                  "".docx""
                ],
                ""text/plain"": [
                  "".txt"",
                  "".md""
                ]
              }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
      try {
        const types = await acceptedFileTypes();
        if (!types) {
          response.sendStatus(404).end();
          return;
        }

        response.status(200).json({ types });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { apiDocumentEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR, VAR, VAR, } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR.VAR(""VAR""), VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR-VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: 'VAR', VAR: 'VAR', } } } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(); VAR (!VAR) { VAR .VAR(500) .VAR({ VAR: VAR, VAR: `VAR VAR VAR VAR VAR VAR. VAR ${VAR} VAR VAR VAR VAR VAR.`, }) .VAR(); } VAR { VAR, VAR } = VAR VAR(VAR); VAR (!VAR) { VAR.VAR(500).VAR({ VAR: VAR, VAR: VAR }).VAR(); } VAR.VAR( `VAR ${VAR} VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR.` ); VAR VAR.VAR(""VAR""); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"", VAR: [ { ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR-4dab-4419-9462-9d00065a49a1"", ""VAR"": ""VAR: ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": VAR }, ] } } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": { ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR.VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR.VAR-VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"", "".VAR"" ] } } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR VAR(); VAR (!VAR) { VAR.VAR(404).VAR(); VAR; } VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/api/document/index.js,"const { Telemetry } = require(""../../../models/telemetry"");
const { validApiKey } = require(""../../../utils/middleware/validApiKey"");
const { setupMulter } = require(""../../../utils/files/multer"");
const {
  checkPythonAppAlive,
  acceptedFileTypes,
  processDocument,
} = require(""../../../utils/files/documentProcessor"");
const { viewLocalFiles } = require(""../../../utils/files"");
const { handleUploads } = setupMulter();

function apiDocumentEndpoints(app) {
  if (!app) return;

  app.post(
    ""/v1/document/upload"",
    [validApiKey],
    handleUploads.single(""file""),
    async (request, response) => {
      /*
    #swagger.tags = ['Documents']
    #swagger.description = 'Upload a new file to AnythingLLM to be parsed and prepared for embedding.'

    #swagger.requestBody = {
      description: 'File to be uploaded.',
      required: true,
      type: 'file',
      content: {
        ""multipart/form-data"": {
          schema: {
            type: 'object',
            properties: {
              file: {
                type: 'string',
                format: 'binary',
              }
            }
          }
        }
      }
    }
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              success: true,
              error: null,
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
      try {
        const { originalname } = request.file;
        const processingOnline = await checkPythonAppAlive();

        if (!processingOnline) {
          response
            .status(500)
            .json({
              success: false,
              error: `Python processing API is not online. Document ${originalname} will not be processed automatically.`,
            })
            .end();
        }

        const { success, reason } = await processDocument(originalname);
        if (!success) {
          response.status(500).json({ success: false, error: reason }).end();
        }

        console.log(
          `Document ${originalname} uploaded processed and successfully. It is now available in documents.`
        );
        await Telemetry.sendTelemetry(""document_uploaded"");
        response.status(200).json({ success: true, error: null });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/v1/documents"", [validApiKey], async (_, response) => {
    /*
    #swagger.tags = ['Documents']
    #swagger.description = 'List of all locally-stored documents in instance'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""localFiles"": {
              ""name"": ""documents"",
              ""type"": ""folder"",
              items: [
                {
                  ""name"": ""my-stored-document.json"",
                  ""type"": ""file"",
                  ""id"": ""bb07c334-4dab-4419-9462-9d00065a49a1"",
                  ""url"": ""file://my-stored-document.txt"",
                  ""title"": ""my-stored-document.txt"",
                  ""cached"": false
                },
              ]
             }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    try {
      const localFiles = await viewLocalFiles();
      response.status(200).json({ localFiles });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/v1/document/accepted-file-types"",
    [validApiKey],
    async (_, response) => {
      /*
    #swagger.tags = ['Documents']
    #swagger.description = 'Check available filetypes and MIMEs that can be uploaded.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
              ""types"": {
                ""application/mbox"": [
                  "".mbox""
                ],
                ""application/pdf"": [
                  "".pdf""
                ],
                ""application/vnd.oasis.opendocument.text"": [
                  "".odt""
                ],
                ""application/vnd.openxmlformats-officedocument.wordprocessingml.document"": [
                  "".docx""
                ],
                ""text/plain"": [
                  "".txt"",
                  "".md""
                ]
              }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
      try {
        const types = await acceptedFileTypes();
        if (!types) {
          response.sendStatus(404).end();
          return;
        }

        response.status(200).json({ types });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { apiDocumentEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR, VAR, VAR, } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR( ""/VAR/VAR/VAR"", [VAR], VAR.VAR(""VAR""), VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR-VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: { VAR: 'VAR', VAR: 'VAR', } } } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: VAR, VAR: VAR, } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(); VAR (!VAR) { VAR .VAR(500) .VAR({ VAR: VAR, VAR: `VAR VAR VAR VAR VAR VAR. VAR ${VAR} VAR VAR VAR VAR VAR.`, }) .VAR(); } VAR { VAR, VAR } = VAR VAR(VAR); VAR (!VAR) { VAR.VAR(500).VAR({ VAR: VAR, VAR: VAR }).VAR(); } VAR.VAR( `VAR ${VAR} VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR.` ); VAR VAR.VAR(""VAR""); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"", VAR: [ { ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR-4dab-4419-9462-9d00065a49a1"", ""VAR"": ""VAR: ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": VAR }, ] } } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": { ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR.VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR.VAR-VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"", "".VAR"" ] } } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR VAR(); VAR (!VAR) { VAR.VAR(404).VAR(); VAR; } VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/api/system/index.js,"const { SystemSettings } = require(""../../../models/systemSettings"");
const { getVectorDbClass } = require(""../../../utils/helpers"");
const { dumpENV, updateENV } = require(""../../../utils/helpers/updateENV"");
const { reqBody } = require(""../../../utils/http"");
const { validApiKey } = require(""../../../utils/middleware/validApiKey"");

function apiSystemEndpoints(app) {
  if (!app) return;

  app.get(""/v1/system/env-dump"", async (_, response) => {
    /*
   #swagger.tags = ['System Settings']
   #swagger.description = 'Dump all settings to file storage'
   #swagger.responses[403] = {
     schema: {
       ""$ref"": ""#/definitions/InvalidAPIKey""
     }
   }
   */
    try {
      if (process.env.NODE_ENV !== ""production"")
        return response.sendStatus(200).end();
      await dumpENV();
      response.sendStatus(200).end();
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/v1/system"", [validApiKey], async (_, response) => {
    /*
    #swagger.tags = ['System Settings']
    #swagger.description = 'Get all current system settings that are defined.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""settings"": {
                ""VectorDB"": ""pinecone"",
                ""PineConeEnvironment"": ""us-west4-gcp-free"",
                ""PineConeKey"": true,
                ""PineConeIndex"": ""my-pinecone-index"",
                ""LLMProvider"": ""azure"",
                ""[KEY_NAME]"": ""KEY_VALUE"",
              }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    try {
      const settings = await SystemSettings.currentSettings();
      response.status(200).json({ settings });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/v1/system/vector-count"", [validApiKey], async (_, response) => {
    /*
    #swagger.tags = ['System Settings']
    #swagger.description = 'Number of all vectors in connected vector database'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""vectorCount"": 5450
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    try {
      const VectorDb = getVectorDbClass();
      const vectorCount = await VectorDb.totalIndicies();
      response.status(200).json({ vectorCount });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/v1/system/update-env"",
    [validApiKey],
    async (request, response) => {
      /*
      #swagger.tags = ['System Settings']
      #swagger.description = 'Update a system setting or preference.'
      #swagger.requestBody = {
        description: 'Key pair object that matches a valid setting and value. Get keys from GET /v1/system or refer to codebase.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              VectorDB: ""lancedb"",
              AnotherKey: ""updatedValue""
            }
          }
        }
      }
      #swagger.responses[200] = {
        content: {
          ""application/json"": {
            schema: {
              type: 'object',
              example: {
                newValues: {""[ENV_KEY]"": 'Value'},
                error: 'error goes here, otherwise null'
              }
            }
          }
        }
      }
      #swagger.responses[403] = {
        schema: {
          ""$ref"": ""#/definitions/InvalidAPIKey""
        }
      }
      */
      try {
        const body = reqBody(request);
        const { newValues, error } = updateENV(body);
        if (process.env.NODE_ENV === ""production"") await dumpENV();
        response.status(200).json({ newValues, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { apiSystemEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR, VAR } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR/VAR-VAR"", VAR (VAR, VAR) => { /*    VAR: { ""$VAR"": "" } } */ VAR { VAR (VAR.VAR.VAR !== ""VAR"") VAR VAR.VAR(200).VAR(); VAR VAR(); VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR-VAR-VAR-VAR"", ""VAR"": VAR, ""VAR"": ""VAR-VAR-VAR"", ""VAR"": ""VAR"", ""[VAR]"": ""VAR"", } } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": 5450 } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR(); VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR /VAR/VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: ""VAR"", VAR: ""VAR"" } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: {""[VAR]"": 'VAR'}, VAR: 'VAR VAR VAR, VAR VAR' } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR(VAR); VAR (VAR.VAR.VAR === ""VAR"") VAR VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/api/system/index.js,"const { SystemSettings } = require(""../../../models/systemSettings"");
const { getVectorDbClass } = require(""../../../utils/helpers"");
const { dumpENV, updateENV } = require(""../../../utils/helpers/updateENV"");
const { reqBody } = require(""../../../utils/http"");
const { validApiKey } = require(""../../../utils/middleware/validApiKey"");

function apiSystemEndpoints(app) {
  if (!app) return;

  app.get(""/v1/system/env-dump"", async (_, response) => {
    /*
   #swagger.tags = ['System Settings']
   #swagger.description = 'Dump all settings to file storage'
   #swagger.responses[403] = {
     schema: {
       ""$ref"": ""#/definitions/InvalidAPIKey""
     }
   }
   */
    try {
      if (process.env.NODE_ENV !== ""production"")
        return response.sendStatus(200).end();
      await dumpENV();
      response.sendStatus(200).end();
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/v1/system"", [validApiKey], async (_, response) => {
    /*
    #swagger.tags = ['System Settings']
    #swagger.description = 'Get all current system settings that are defined.'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""settings"": {
                ""VectorDB"": ""pinecone"",
                ""PineConeEnvironment"": ""us-west4-gcp-free"",
                ""PineConeKey"": true,
                ""PineConeIndex"": ""my-pinecone-index"",
                ""LLMProvider"": ""azure"",
                ""[KEY_NAME]"": ""KEY_VALUE"",
              }
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    try {
      const settings = await SystemSettings.currentSettings();
      response.status(200).json({ settings });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/v1/system/vector-count"", [validApiKey], async (_, response) => {
    /*
    #swagger.tags = ['System Settings']
    #swagger.description = 'Number of all vectors in connected vector database'
    #swagger.responses[200] = {
      content: {
        ""application/json"": {
          schema: {
            type: 'object',
            example: {
             ""vectorCount"": 5450
            }
          }
        }
      }
    }
    #swagger.responses[403] = {
      schema: {
        ""$ref"": ""#/definitions/InvalidAPIKey""
      }
    }
    */
    try {
      const VectorDb = getVectorDbClass();
      const vectorCount = await VectorDb.totalIndicies();
      response.status(200).json({ vectorCount });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/v1/system/update-env"",
    [validApiKey],
    async (request, response) => {
      /*
      #swagger.tags = ['System Settings']
      #swagger.description = 'Update a system setting or preference.'
      #swagger.requestBody = {
        description: 'Key pair object that matches a valid setting and value. Get keys from GET /v1/system or refer to codebase.',
        required: true,
        type: 'object',
        content: {
          ""application/json"": {
            example: {
              VectorDB: ""lancedb"",
              AnotherKey: ""updatedValue""
            }
          }
        }
      }
      #swagger.responses[200] = {
        content: {
          ""application/json"": {
            schema: {
              type: 'object',
              example: {
                newValues: {""[ENV_KEY]"": 'Value'},
                error: 'error goes here, otherwise null'
              }
            }
          }
        }
      }
      #swagger.responses[403] = {
        schema: {
          ""$ref"": ""#/definitions/InvalidAPIKey""
        }
      }
      */
      try {
        const body = reqBody(request);
        const { newValues, error } = updateENV(body);
        if (process.env.NODE_ENV === ""production"") await dumpENV();
        response.status(200).json({ newValues, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { apiSystemEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR, VAR } = VAR(""../../../VAR/VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR""); VAR { VAR } = VAR(""../../../VAR/VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR/VAR-VAR"", VAR (VAR, VAR) => { /*    VAR: { ""$VAR"": "" } } */ VAR { VAR (VAR.VAR.VAR !== ""VAR"") VAR VAR.VAR(200).VAR(); VAR VAR(); VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR-VAR-VAR-VAR"", ""VAR"": VAR, ""VAR"": ""VAR-VAR-VAR"", ""VAR"": ""VAR"", ""[VAR]"": ""VAR"", } } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { ""VAR"": 5450 } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR(); VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { /*    VAR: 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR /VAR/VAR VAR VAR VAR VAR.', VAR: VAR, VAR: 'VAR', VAR: { ""VAR/VAR"": { VAR: { VAR: ""VAR"", VAR: ""VAR"" } } } }  VAR: { ""VAR/VAR"": { VAR: { VAR: 'VAR', VAR: { VAR: {""[VAR]"": 'VAR'}, VAR: 'VAR VAR VAR, VAR VAR' } } } } }  VAR: { ""$VAR"": "" } } */ VAR { VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR(VAR); VAR (VAR.VAR.VAR === ""VAR"") VAR VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/invite.js,"const { escape } = require(""sqlstring-sqlite"");
const { Invite } = require(""../models/invite"");
const { User } = require(""../models/user"");
const { reqBody } = require(""../utils/http"");

function inviteEndpoints(app) {
  if (!app) return;

  app.get(""/invite/:code"", async (request, response) => {
    try {
      const { code } = request.params;
      const invite = await Invite.get(`code = ${escape(code)}`);
      if (!invite) {
        response.status(200).json({ invite: null, error: ""Invite not found."" });
        return;
      }

      if (invite.status !== ""pending"") {
        response
          .status(200)
          .json({ invite: null, error: ""Invite is no longer valid."" });
        return;
      }

      response
        .status(200)
        .json({ invite: { code, status: invite.status }, error: null });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/invite/:code"", async (request, response) => {
    try {
      const { code } = request.params;
      const userParams = reqBody(request);
      const invite = await Invite.get(`code = ${escape(code)}`);
      if (!invite || invite.status !== ""pending"") {
        response
          .status(200)
          .json({ success: false, error: ""Invite not found or is invalid."" });
        return;
      }

      const { user, error } = await User.create(userParams);
      if (!user) {
        console.error(""Accepting invite:"", error);
        response
          .status(200)
          .json({ success: false, error: ""Could not create user."" });
        return;
      }

      await Invite.markClaimed(invite.id, user);
      response.status(200).json({ success: true, error: null });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });
}

module.exports = { inviteEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR-VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/:VAR"", VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: ""VAR VAR VAR."" }); VAR; } VAR (VAR.VAR !== ""VAR"") { VAR .VAR(200) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR."" }); VAR; } VAR .VAR(200) .VAR({ VAR: { VAR, VAR: VAR.VAR }, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/:VAR"", VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR || VAR.VAR !== ""VAR"") { VAR .VAR(200) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."" }); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(VAR); VAR (!VAR) { VAR.VAR(""VAR VAR:"", VAR); VAR .VAR(200) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR."" }); VAR; } VAR VAR.VAR(VAR.VAR, VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/invite.js,"const { escape } = require(""sqlstring-sqlite"");
const { Invite } = require(""../models/invite"");
const { User } = require(""../models/user"");
const { reqBody } = require(""../utils/http"");

function inviteEndpoints(app) {
  if (!app) return;

  app.get(""/invite/:code"", async (request, response) => {
    try {
      const { code } = request.params;
      const invite = await Invite.get(`code = ${escape(code)}`);
      if (!invite) {
        response.status(200).json({ invite: null, error: ""Invite not found."" });
        return;
      }

      if (invite.status !== ""pending"") {
        response
          .status(200)
          .json({ invite: null, error: ""Invite is no longer valid."" });
        return;
      }

      response
        .status(200)
        .json({ invite: { code, status: invite.status }, error: null });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });

  app.post(""/invite/:code"", async (request, response) => {
    try {
      const { code } = request.params;
      const userParams = reqBody(request);
      const invite = await Invite.get(`code = ${escape(code)}`);
      if (!invite || invite.status !== ""pending"") {
        response
          .status(200)
          .json({ success: false, error: ""Invite not found or is invalid."" });
        return;
      }

      const { user, error } = await User.create(userParams);
      if (!user) {
        console.error(""Accepting invite:"", error);
        response
          .status(200)
          .json({ success: false, error: ""Could not create user."" });
        return;
      }

      await Invite.markClaimed(invite.id, user);
      response.status(200).json({ success: true, error: null });
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });
}

module.exports = { inviteEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR-VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/:VAR"", VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: ""VAR VAR VAR."" }); VAR; } VAR (VAR.VAR !== ""VAR"") { VAR .VAR(200) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR."" }); VAR; } VAR .VAR(200) .VAR({ VAR: { VAR, VAR: VAR.VAR }, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/:VAR"", VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR || VAR.VAR !== ""VAR"") { VAR .VAR(200) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."" }); VAR; } VAR { VAR, VAR } = VAR VAR.VAR(VAR); VAR (!VAR) { VAR.VAR(""VAR VAR:"", VAR); VAR .VAR(200) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR."" }); VAR; } VAR VAR.VAR(VAR.VAR, VAR); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/system.js,"process.env.NODE_ENV === ""development""
  ? require(""dotenv"").config({ path: `.env.${process.env.NODE_ENV}` })
  : require(""dotenv"").config();
const { validateTablePragmas } = require(""../utils/database"");
const { viewLocalFiles } = require(""../utils/files"");
const { exportData, unpackAndOverwriteImport } = require(""../utils/files/data"");
const {
  checkPythonAppAlive,
  acceptedFileTypes,
} = require(""../utils/files/documentProcessor"");
const { purgeDocument } = require(""../utils/files/purgeDocument"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { updateENV, dumpENV } = require(""../utils/helpers/updateENV"");
const {
  reqBody,
  makeJWT,
  userFromSession,
  multiUserMode,
} = require(""../utils/http"");
const { setupDataImports, setupLogoUploads } = require(""../utils/files/multer"");
const { v4 } = require(""uuid"");
const { SystemSettings } = require(""../models/systemSettings"");
const { User } = require(""../models/user"");
const { validatedRequest } = require(""../utils/middleware/validatedRequest"");
const { handleImports } = setupDataImports();
const { handleLogoUploads } = setupLogoUploads();
const fs = require(""fs"");
const path = require(""path"");
const {
  getDefaultFilename,
  determineLogoFilepath,
  fetchLogo,
  validFilename,
  renameLogoFile,
  removeCustomLogo,
  DARK_LOGO_FILENAME,
} = require(""../utils/files/logo"");
const { Telemetry } = require(""../models/telemetry"");
const { WelcomeMessages } = require(""../models/welcomeMessages"");
const { ApiKey } = require(""../models/apiKeys"");
const { escape } = require(""sqlstring-sqlite"");

function systemEndpoints(app) {
  if (!app) return;

  app.get(""/ping"", (_, response) => {
    response.status(200).json({ online: true });
  });

  app.get(""/migrate"", async (_, response) => {
    await validateTablePragmas(true);
    response.sendStatus(200);
  });

  app.get(""/env-dump"", async (_, response) => {
    if (process.env.NODE_ENV !== ""production"")
      return response.sendStatus(200).end();
    await dumpENV();
    response.sendStatus(200).end();
  });

  app.get(""/setup-complete"", async (_, response) => {
    try {
      const results = await SystemSettings.currentSettings();
      response.status(200).json({ results });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/system/check-token"",
    [validatedRequest],
    async (request, response) => {
      try {
        if (multiUserMode(response)) {
          const user = await userFromSession(request, response);
          if (!user || user.suspended) {
            response.sendStatus(403).end();
            return;
          }

          response.sendStatus(200).end();
          return;
        }

        response.sendStatus(200).end();
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(""/request-token"", async (request, response) => {
    try {
      if (await SystemSettings.isMultiUserMode()) {
        const { username, password } = reqBody(request);
        const existingUser = await User.get(`username = ${escape(username)}`);

        if (!existingUser) {
          response.status(200).json({
            user: null,
            valid: false,
            token: null,
            message: ""[001] Invalid login credentials."",
          });
          return;
        }

        const bcrypt = require(""bcrypt"");
        if (!bcrypt.compareSync(password, existingUser.password)) {
          response.status(200).json({
            user: null,
            valid: false,
            token: null,
            message: ""[002] Invalid login credentials."",
          });
          return;
        }

        if (existingUser.suspended) {
          response.status(200).json({
            user: null,
            valid: false,
            token: null,
            message: ""[004] Account suspended by admin."",
          });
          return;
        }

        response.status(200).json({
          valid: true,
          user: existingUser,
          token: makeJWT(
            { id: existingUser.id, username: existingUser.username },
            ""30d""
          ),
          message: null,
        });
        return;
      } else {
        const { password } = reqBody(request);
        if (password !== process.env.AUTH_TOKEN) {
          response.status(401).json({
            valid: false,
            token: null,
            message: ""[003] Invalid password provided"",
          });
          return;
        }

        response.status(200).json({
          valid: true,
          token: makeJWT({ p: password }, ""30d""),
          message: null,
        });
      }
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/system/system-vectors"", [validatedRequest], async (_, response) => {
    try {
      const VectorDb = getVectorDbClass();
      const vectorCount = await VectorDb.totalIndicies();
      response.status(200).json({ vectorCount });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/system/remove-document"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { name, meta } = reqBody(request);
        await purgeDocument(name, meta);
        response.sendStatus(200).end();
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/system/local-files"", [validatedRequest], async (_, response) => {
    try {
      const localFiles = await viewLocalFiles();
      response.status(200).json({ localFiles });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/system/document-processing-status"",
    [validatedRequest],
    async (_, response) => {
      try {
        const online = await checkPythonAppAlive();
        response.sendStatus(online ? 200 : 503);
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(
    ""/system/accepted-document-types"",
    [validatedRequest],
    async (_, response) => {
      try {
        const types = await acceptedFileTypes();
        if (!types) {
          response.sendStatus(404).end();
          return;
        }

        response.status(200).json({ types });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/system/update-env"",
    [validatedRequest],
    async (request, response) => {
      try {
        const body = reqBody(request);
        const { newValues, error } = updateENV(body);
        if (process.env.NODE_ENV === ""production"") await dumpENV();
        response.status(200).json({ newValues, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/system/update-password"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { usePassword, newPassword } = reqBody(request);
        const { error } = updateENV({
          AuthToken: usePassword ? newPassword : """",
          JWTSecret: usePassword ? v4() : """",
        });
        response.status(200).json({ success: !error, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/system/enable-multi-user"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { username, password } = reqBody(request);
        const multiUserModeEnabled = await SystemSettings.isMultiUserMode();
        if (multiUserModeEnabled) {
          response.status(200).json({
            success: false,
            error: ""Multi-user mode is already enabled."",
          });
          return;
        }

        const { user, error } = await User.create({
          username,
          password,
          role: ""admin"",
        });
        await SystemSettings.updateSettings({
          multi_user_mode: true,
          users_can_delete_workspaces: false,
          limit_user_messages: false,
          message_limit: 25,
        });
        process.env.AUTH_TOKEN = null;
        process.env.JWT_SECRET = process.env.JWT_SECRET ?? v4(); // Make sure JWT_SECRET is set for JWT issuance.
        await Telemetry.sendTelemetry(""enabled_multi_user_mode"");
        response.status(200).json({ success: !!user, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/system/data-export"", [validatedRequest], async (_, response) => {
    try {
      const { filename, error } = await exportData();
      response.status(200).json({ filename, error });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/system/data-exports/:filename"",
    [validatedRequest],
    (request, response) => {
      const exportLocation = __dirname + ""/../storage/exports/"";
      const sanitized = path
        .normalize(request.params.filename)
        .replace(/^(\.\.(\/|\\|$))+/, """");
      const finalDestination = path.join(exportLocation, sanitized);

      if (!fs.existsSync(finalDestination)) {
        response.status(404).json({
          error: 404,
          msg: `File ${request.params.filename} does not exist in exports.`,
        });
        return;
      }

      response.download(finalDestination, request.params.filename, (err) => {
        if (err) {
          response.send({
            error: err,
            msg: ""Problem downloading the file"",
          });
        }
      });
    }
  );

  app.post(
    ""/system/data-import"",
    handleImports.single(""file""),
    async function (request, response) {
      const { originalname } = request.file;
      const { success, error } = await unpackAndOverwriteImport(originalname);
      response.status(200).json({ success, error });
    }
  );

  app.get(""/system/logo/:mode?"", async function (request, response) {
    try {
      const defaultFilename = getDefaultFilename(request.params.mode);
      const logoPath = await determineLogoFilepath(defaultFilename);
      const { buffer, size, mime } = fetchLogo(logoPath);
      response.writeHead(200, {
        ""Content-Type"": mime || ""image/png"",
        ""Content-Disposition"": `attachment; filename=${path.basename(
          logoPath
        )}`,
        ""Content-Length"": size,
      });
      response.end(Buffer.from(buffer, ""base64""));
      return;
    } catch (error) {
      console.error(""Error processing the logo request:"", error);
      response.status(500).json({ message: ""Internal server error"" });
    }
  });

  app.post(
    ""/system/upload-logo"",
    [validatedRequest],
    handleLogoUploads.single(""logo""),
    async (request, response) => {
      if (!request.file || !request.file.originalname) {
        return response.status(400).json({ message: ""No logo file provided."" });
      }

      if (!validFilename(request.file.originalname)) {
        return response.status(400).json({
          message: ""Invalid file name. Please choose a different file."",
        });
      }

      try {
        if (
          response.locals.multiUserMode &&
          response.locals.user?.role !== ""admin""
        ) {
          return response.sendStatus(401).end();
        }

        const newFilename = await renameLogoFile(request.file.originalname);
        const existingLogoFilename = await SystemSettings.currentLogoFilename();
        await removeCustomLogo(existingLogoFilename);

        const { success, error } = await SystemSettings.updateSettings({
          logo_filename: newFilename,
        });

        return response.status(success ? 200 : 500).json({
          message: success
            ? ""Logo uploaded successfully.""
            : error || ""Failed to update with new logo."",
        });
      } catch (error) {
        console.error(""Error processing the logo upload:"", error);
        response.status(500).json({ message: ""Error uploading the logo."" });
      }
    }
  );

  app.get(
    ""/system/remove-logo"",
    [validatedRequest],
    async (request, response) => {
      try {
        if (
          response.locals.multiUserMode &&
          response.locals.user?.role !== ""admin""
        ) {
          return response.sendStatus(401).end();
        }

        const currentLogoFilename = await SystemSettings.currentLogoFilename();
        await removeCustomLogo(currentLogoFilename);
        const { success, error } = await SystemSettings.updateSettings({
          logo_filename: DARK_LOGO_FILENAME,
        });

        return response.status(success ? 200 : 500).json({
          message: success
            ? ""Logo removed successfully.""
            : error || ""Failed to update with new logo."",
        });
      } catch (error) {
        console.error(""Error processing the logo removal:"", error);
        response.status(500).json({ message: ""Error removing the logo."" });
      }
    }
  );

  app.get(
    ""/system/can-delete-workspaces"",
    [validatedRequest],
    async function (request, response) {
      try {
        if (!response.locals.multiUserMode) {
          return response.status(200).json({ canDelete: true });
        }

        if (response.locals.user?.role === ""admin"") {
          return response.status(200).json({ canDelete: true });
        }

        const canDelete = await SystemSettings.canDeleteWorkspaces();
        response.status(200).json({ canDelete });
      } catch (error) {
        console.error(""Error fetching can delete workspaces:"", error);
        response.status(500).json({
          success: false,
          message: ""Internal server error"",
          canDelete: false,
        });
      }
    }
  );

  app.get(""/system/welcome-messages"", async function (request, response) {
    try {
      const welcomeMessages = await WelcomeMessages.getMessages();
      response.status(200).json({ success: true, welcomeMessages });
    } catch (error) {
      console.error(""Error fetching welcome messages:"", error);
      response
        .status(500)
        .json({ success: false, message: ""Internal server error"" });
    }
  });

  app.post(
    ""/system/set-welcome-messages"",
    [validatedRequest],
    async (request, response) => {
      try {
        if (
          response.locals.multiUserMode &&
          response.locals.user?.role !== ""admin""
        ) {
          return response.sendStatus(401).end();
        }

        const { messages = [] } = reqBody(request);
        if (!Array.isArray(messages)) {
          return response.status(400).json({
            success: false,
            message: ""Invalid message format. Expected an array of messages."",
          });
        }

        await WelcomeMessages.saveAll(messages);
        return response.status(200).json({
          success: true,
          message: ""Welcome messages saved successfully."",
        });
      } catch (error) {
        console.error(""Error processing the welcome messages:"", error);
        response.status(500).json({
          success: true,
          message: ""Error saving the welcome messages."",
        });
      }
    }
  );

  app.get(""/system/api-key"", [validatedRequest], async (_, response) => {
    try {
      if (response.locals.multiUserMode) {
        return response.sendStatus(401).end();
      }

      const apiKey = await ApiKey.get(""id IS NOT NULL"");
      return response.status(200).json({
        apiKey,
        error: null,
      });
    } catch (error) {
      console.error(error);
      response.status(500).json({
        apiKey: null,
        error: ""Could not find an API Key."",
      });
    }
  });

  app.post(
    ""/system/generate-api-key"",
    [validatedRequest],
    async (_, response) => {
      try {
        if (response.locals.multiUserMode) {
          return response.sendStatus(401).end();
        }

        await ApiKey.delete();
        const { apiKey, error } = await ApiKey.create();
        return response.status(200).json({
          apiKey,
          error,
        });
      } catch (error) {
        console.error(error);
        response.status(500).json({
          apiKey: null,
          error: ""Error generating api key."",
        });
      }
    }
  );

  app.delete(""/system/api-key"", [validatedRequest], async (_, response) => {
    try {
      if (response.locals.multiUserMode) {
        return response.sendStatus(401).end();
      }

      await ApiKey.delete();
      return response.status(200).end();
    } catch (error) {
      console.error(error);
      response.status(500).end();
    }
  });
}

module.exports = { systemEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR.VAR.VAR === ""VAR"" ? VAR(""VAR"").VAR({ VAR: `.VAR.${VAR.VAR.VAR}` }) : VAR(""VAR"").VAR(); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR, VAR, } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR, VAR, VAR, VAR, } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(); VAR { VAR } = VAR(); VAR VAR = VAR(""VAR""); VAR VAR = VAR(""VAR""); VAR { VAR, VAR, VAR, VAR, VAR, VAR, VAR, } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""VAR-VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR"", (VAR, VAR) => { VAR.VAR(200).VAR({ VAR: VAR }); }); VAR.VAR(""/VAR"", VAR (VAR, VAR) => { VAR VAR(VAR); VAR.VAR(200); }); VAR.VAR(""/VAR-VAR"", VAR (VAR, VAR) => { VAR (VAR.VAR.VAR !== ""VAR"") VAR VAR.VAR(200).VAR(); VAR VAR(); VAR.VAR(200).VAR(); }); VAR.VAR(""/VAR-VAR"", VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR(VAR)) { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR.VAR) { VAR.VAR(403).VAR(); VAR; } VAR.VAR(200).VAR(); VAR; } VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR-VAR"", VAR (VAR, VAR) => { VAR { VAR (VAR VAR.VAR()) { VAR { VAR, VAR } = VAR(VAR); VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: ""[001] VAR VAR VAR."", }); VAR; } VAR VAR = VAR(""VAR""); VAR (!VAR.VAR(VAR, VAR.VAR)) { VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: ""[002] VAR VAR VAR."", }); VAR; } VAR (VAR.VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: ""[004] VAR VAR VAR VAR."", }); VAR; } VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR( { VAR: VAR.VAR, VAR: VAR.VAR }, ""30d"" ), VAR: VAR, }); VAR; } VAR { VAR { VAR } = VAR(VAR); VAR (VAR !== VAR.VAR.VAR) { VAR.VAR(401).VAR({ VAR: VAR, VAR: VAR, VAR: ""[003] VAR VAR VAR"", }); VAR; } VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR({ VAR: VAR }, ""30d""), VAR: VAR, }); } } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR(); VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR(VAR); VAR VAR(VAR, VAR); VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(); VAR.VAR(VAR ? 200 : 503); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(); VAR (!VAR) { VAR.VAR(404).VAR(); VAR; } VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR(VAR); VAR (VAR.VAR.VAR === ""VAR"") VAR VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR(VAR); VAR { VAR } = VAR({ VAR: VAR ? VAR : """", VAR: VAR ? VAR() : """", }); VAR.VAR(200).VAR({ VAR: !VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR(VAR); VAR VAR = VAR VAR.VAR(); VAR (VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: ""VAR-VAR VAR VAR VAR VAR."", }); VAR; } VAR { VAR, VAR } = VAR VAR.VAR({ VAR, VAR, VAR: ""VAR"", }); VAR VAR.VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: 25, }); VAR.VAR.VAR = VAR; VAR.VAR.VAR = VAR.VAR.VAR ?? VAR();  VAR VAR.VAR(""VAR""); VAR.VAR(200).VAR({ VAR: !!VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR/:VAR"", [VAR], (VAR, VAR) => { VAR VAR = VAR + ""/../VAR/VAR/""; VAR VAR = VAR .VAR(VAR.VAR.VAR) .VAR(/^(\.\.(\/|\\|$))+/, """"); VAR VAR = VAR.VAR(VAR, VAR); VAR (!VAR.VAR(VAR)) { VAR.VAR(404).VAR({ VAR: 404, VAR: `VAR ${VAR.VAR.VAR} VAR VAR VAR VAR VAR.`, }); VAR; } VAR.VAR(VAR, VAR.VAR.VAR, (VAR) => { VAR (VAR) { VAR.VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR"", }); } }); } ); VAR.VAR( ""/VAR/VAR-VAR"", VAR.VAR(""VAR""), VAR VAR (VAR, VAR) { VAR { VAR } = VAR.VAR; VAR { VAR, VAR } = VAR VAR(VAR); VAR.VAR(200).VAR({ VAR, VAR }); } ); VAR.VAR(""/VAR/VAR/:VAR?"", VAR VAR (VAR, VAR) { VAR { VAR VAR = VAR(VAR.VAR.VAR); VAR VAR = VAR VAR(VAR); VAR { VAR, VAR, VAR } = VAR(VAR); VAR.VAR(200, { ""VAR-VAR"": VAR || ""VAR/VAR"", ""VAR-VAR"": `VAR; VAR=${VAR.VAR( VAR )}`, ""VAR-VAR"": VAR, }); VAR.VAR(VAR.VAR(VAR, ""VAR"")); VAR; } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: ""VAR VAR VAR"" }); } }); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR.VAR(""VAR""), VAR (VAR, VAR) => { VAR (!VAR.VAR || !VAR.VAR.VAR) { VAR VAR.VAR(400).VAR({ VAR: ""VAR VAR VAR VAR."" }); } VAR (!VAR(VAR.VAR.VAR)) { VAR VAR.VAR(400).VAR({ VAR: ""VAR VAR VAR. VAR VAR VAR VAR VAR."", }); } VAR { VAR ( VAR.VAR.VAR && VAR.VAR.VAR?.VAR !== ""VAR"" ) { VAR VAR.VAR(401).VAR(); } VAR VAR = VAR VAR(VAR.VAR.VAR); VAR VAR = VAR VAR.VAR(); VAR VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR({ VAR: VAR, }); VAR VAR.VAR(VAR ? 200 : 500).VAR({ VAR: VAR ? ""VAR VAR VAR."" : VAR || ""VAR VAR VAR VAR VAR VAR."", }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: ""VAR VAR VAR VAR."" }); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR ( VAR.VAR.VAR && VAR.VAR.VAR?.VAR !== ""VAR"" ) { VAR VAR.VAR(401).VAR(); } VAR VAR = VAR VAR.VAR(); VAR VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR({ VAR: VAR, }); VAR VAR.VAR(VAR ? 200 : 500).VAR({ VAR: VAR ? ""VAR VAR VAR."" : VAR || ""VAR VAR VAR VAR VAR VAR."", }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: ""VAR VAR VAR VAR."" }); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR VAR (VAR, VAR) { VAR { VAR (!VAR.VAR.VAR) { VAR VAR.VAR(200).VAR({ VAR: VAR }); } VAR (VAR.VAR.VAR?.VAR === ""VAR"") { VAR VAR.VAR(200).VAR({ VAR: VAR }); } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR"", VAR: VAR, }); } } ); VAR.VAR(""/VAR/VAR-VAR"", VAR VAR (VAR, VAR) { VAR { VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR: VAR, VAR }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR:"", VAR); VAR .VAR(500) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR"" }); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR ( VAR.VAR.VAR && VAR.VAR.VAR?.VAR !== ""VAR"" ) { VAR VAR.VAR(401).VAR(); } VAR { VAR = [] } = VAR(VAR); VAR (!VAR.VAR(VAR)) { VAR VAR.VAR(400).VAR({ VAR: VAR, VAR: ""VAR VAR VAR. VAR VAR VAR VAR VAR."", }); } VAR VAR.VAR(VAR); VAR VAR.VAR(200).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR."", }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR."", }); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR.VAR.VAR) { VAR VAR.VAR(401).VAR(); } VAR VAR = VAR VAR.VAR(""VAR VAR VAR VAR""); VAR VAR.VAR(200).VAR({ VAR, VAR: VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."", }); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR.VAR.VAR) { VAR VAR.VAR(401).VAR(); } VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR.VAR(); VAR VAR.VAR(200).VAR({ VAR, VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR."", }); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR.VAR.VAR) { VAR VAR.VAR(401).VAR(); } VAR VAR.VAR(); VAR VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/system.js,"process.env.NODE_ENV === ""development""
  ? require(""dotenv"").config({ path: `.env.${process.env.NODE_ENV}` })
  : require(""dotenv"").config();
const { validateTablePragmas } = require(""../utils/database"");
const { viewLocalFiles } = require(""../utils/files"");
const { exportData, unpackAndOverwriteImport } = require(""../utils/files/data"");
const {
  checkPythonAppAlive,
  acceptedFileTypes,
} = require(""../utils/files/documentProcessor"");
const { purgeDocument } = require(""../utils/files/purgeDocument"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { updateENV, dumpENV } = require(""../utils/helpers/updateENV"");
const {
  reqBody,
  makeJWT,
  userFromSession,
  multiUserMode,
} = require(""../utils/http"");
const { setupDataImports, setupLogoUploads } = require(""../utils/files/multer"");
const { v4 } = require(""uuid"");
const { SystemSettings } = require(""../models/systemSettings"");
const { User } = require(""../models/user"");
const { validatedRequest } = require(""../utils/middleware/validatedRequest"");
const { handleImports } = setupDataImports();
const { handleLogoUploads } = setupLogoUploads();
const fs = require(""fs"");
const path = require(""path"");
const {
  getDefaultFilename,
  determineLogoFilepath,
  fetchLogo,
  validFilename,
  renameLogoFile,
  removeCustomLogo,
  DARK_LOGO_FILENAME,
} = require(""../utils/files/logo"");
const { Telemetry } = require(""../models/telemetry"");
const { WelcomeMessages } = require(""../models/welcomeMessages"");
const { ApiKey } = require(""../models/apiKeys"");
const { escape } = require(""sqlstring-sqlite"");

function systemEndpoints(app) {
  if (!app) return;

  app.get(""/ping"", (_, response) => {
    response.status(200).json({ online: true });
  });

  app.get(""/migrate"", async (_, response) => {
    await validateTablePragmas(true);
    response.sendStatus(200);
  });

  app.get(""/env-dump"", async (_, response) => {
    if (process.env.NODE_ENV !== ""production"")
      return response.sendStatus(200).end();
    await dumpENV();
    response.sendStatus(200).end();
  });

  app.get(""/setup-complete"", async (_, response) => {
    try {
      const results = await SystemSettings.currentSettings();
      response.status(200).json({ results });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/system/check-token"",
    [validatedRequest],
    async (request, response) => {
      try {
        if (multiUserMode(response)) {
          const user = await userFromSession(request, response);
          if (!user || user.suspended) {
            response.sendStatus(403).end();
            return;
          }

          response.sendStatus(200).end();
          return;
        }

        response.sendStatus(200).end();
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(""/request-token"", async (request, response) => {
    try {
      if (await SystemSettings.isMultiUserMode()) {
        const { username, password } = reqBody(request);
        const existingUser = await User.get(`username = ${escape(username)}`);

        if (!existingUser) {
          response.status(200).json({
            user: null,
            valid: false,
            token: null,
            message: ""[001] Invalid login credentials."",
          });
          return;
        }

        const bcrypt = require(""bcrypt"");
        if (!bcrypt.compareSync(password, existingUser.password)) {
          response.status(200).json({
            user: null,
            valid: false,
            token: null,
            message: ""[002] Invalid login credentials."",
          });
          return;
        }

        if (existingUser.suspended) {
          response.status(200).json({
            user: null,
            valid: false,
            token: null,
            message: ""[004] Account suspended by admin."",
          });
          return;
        }

        response.status(200).json({
          valid: true,
          user: existingUser,
          token: makeJWT(
            { id: existingUser.id, username: existingUser.username },
            ""30d""
          ),
          message: null,
        });
        return;
      } else {
        const { password } = reqBody(request);
        if (password !== process.env.AUTH_TOKEN) {
          response.status(401).json({
            valid: false,
            token: null,
            message: ""[003] Invalid password provided"",
          });
          return;
        }

        response.status(200).json({
          valid: true,
          token: makeJWT({ p: password }, ""30d""),
          message: null,
        });
      }
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/system/system-vectors"", [validatedRequest], async (_, response) => {
    try {
      const VectorDb = getVectorDbClass();
      const vectorCount = await VectorDb.totalIndicies();
      response.status(200).json({ vectorCount });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.delete(
    ""/system/remove-document"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { name, meta } = reqBody(request);
        await purgeDocument(name, meta);
        response.sendStatus(200).end();
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/system/local-files"", [validatedRequest], async (_, response) => {
    try {
      const localFiles = await viewLocalFiles();
      response.status(200).json({ localFiles });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/system/document-processing-status"",
    [validatedRequest],
    async (_, response) => {
      try {
        const online = await checkPythonAppAlive();
        response.sendStatus(online ? 200 : 503);
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(
    ""/system/accepted-document-types"",
    [validatedRequest],
    async (_, response) => {
      try {
        const types = await acceptedFileTypes();
        if (!types) {
          response.sendStatus(404).end();
          return;
        }

        response.status(200).json({ types });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/system/update-env"",
    [validatedRequest],
    async (request, response) => {
      try {
        const body = reqBody(request);
        const { newValues, error } = updateENV(body);
        if (process.env.NODE_ENV === ""production"") await dumpENV();
        response.status(200).json({ newValues, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/system/update-password"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { usePassword, newPassword } = reqBody(request);
        const { error } = updateENV({
          AuthToken: usePassword ? newPassword : """",
          JWTSecret: usePassword ? v4() : """",
        });
        response.status(200).json({ success: !error, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/system/enable-multi-user"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { username, password } = reqBody(request);
        const multiUserModeEnabled = await SystemSettings.isMultiUserMode();
        if (multiUserModeEnabled) {
          response.status(200).json({
            success: false,
            error: ""Multi-user mode is already enabled."",
          });
          return;
        }

        const { user, error } = await User.create({
          username,
          password,
          role: ""admin"",
        });
        await SystemSettings.updateSettings({
          multi_user_mode: true,
          users_can_delete_workspaces: false,
          limit_user_messages: false,
          message_limit: 25,
        });
        process.env.AUTH_TOKEN = null;
        process.env.JWT_SECRET = process.env.JWT_SECRET ?? v4(); // Make sure JWT_SECRET is set for JWT issuance.
        await Telemetry.sendTelemetry(""enabled_multi_user_mode"");
        response.status(200).json({ success: !!user, error });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/system/data-export"", [validatedRequest], async (_, response) => {
    try {
      const { filename, error } = await exportData();
      response.status(200).json({ filename, error });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/system/data-exports/:filename"",
    [validatedRequest],
    (request, response) => {
      const exportLocation = __dirname + ""/../storage/exports/"";
      const sanitized = path
        .normalize(request.params.filename)
        .replace(/^(\.\.(\/|\\|$))+/, """");
      const finalDestination = path.join(exportLocation, sanitized);

      if (!fs.existsSync(finalDestination)) {
        response.status(404).json({
          error: 404,
          msg: `File ${request.params.filename} does not exist in exports.`,
        });
        return;
      }

      response.download(finalDestination, request.params.filename, (err) => {
        if (err) {
          response.send({
            error: err,
            msg: ""Problem downloading the file"",
          });
        }
      });
    }
  );

  app.post(
    ""/system/data-import"",
    handleImports.single(""file""),
    async function (request, response) {
      const { originalname } = request.file;
      const { success, error } = await unpackAndOverwriteImport(originalname);
      response.status(200).json({ success, error });
    }
  );

  app.get(""/system/logo/:mode?"", async function (request, response) {
    try {
      const defaultFilename = getDefaultFilename(request.params.mode);
      const logoPath = await determineLogoFilepath(defaultFilename);
      const { buffer, size, mime } = fetchLogo(logoPath);
      response.writeHead(200, {
        ""Content-Type"": mime || ""image/png"",
        ""Content-Disposition"": `attachment; filename=${path.basename(
          logoPath
        )}`,
        ""Content-Length"": size,
      });
      response.end(Buffer.from(buffer, ""base64""));
      return;
    } catch (error) {
      console.error(""Error processing the logo request:"", error);
      response.status(500).json({ message: ""Internal server error"" });
    }
  });

  app.post(
    ""/system/upload-logo"",
    [validatedRequest],
    handleLogoUploads.single(""logo""),
    async (request, response) => {
      if (!request.file || !request.file.originalname) {
        return response.status(400).json({ message: ""No logo file provided."" });
      }

      if (!validFilename(request.file.originalname)) {
        return response.status(400).json({
          message: ""Invalid file name. Please choose a different file."",
        });
      }

      try {
        if (
          response.locals.multiUserMode &&
          response.locals.user?.role !== ""admin""
        ) {
          return response.sendStatus(401).end();
        }

        const newFilename = await renameLogoFile(request.file.originalname);
        const existingLogoFilename = await SystemSettings.currentLogoFilename();
        await removeCustomLogo(existingLogoFilename);

        const { success, error } = await SystemSettings.updateSettings({
          logo_filename: newFilename,
        });

        return response.status(success ? 200 : 500).json({
          message: success
            ? ""Logo uploaded successfully.""
            : error || ""Failed to update with new logo."",
        });
      } catch (error) {
        console.error(""Error processing the logo upload:"", error);
        response.status(500).json({ message: ""Error uploading the logo."" });
      }
    }
  );

  app.get(
    ""/system/remove-logo"",
    [validatedRequest],
    async (request, response) => {
      try {
        if (
          response.locals.multiUserMode &&
          response.locals.user?.role !== ""admin""
        ) {
          return response.sendStatus(401).end();
        }

        const currentLogoFilename = await SystemSettings.currentLogoFilename();
        await removeCustomLogo(currentLogoFilename);
        const { success, error } = await SystemSettings.updateSettings({
          logo_filename: DARK_LOGO_FILENAME,
        });

        return response.status(success ? 200 : 500).json({
          message: success
            ? ""Logo removed successfully.""
            : error || ""Failed to update with new logo."",
        });
      } catch (error) {
        console.error(""Error processing the logo removal:"", error);
        response.status(500).json({ message: ""Error removing the logo."" });
      }
    }
  );

  app.get(
    ""/system/can-delete-workspaces"",
    [validatedRequest],
    async function (request, response) {
      try {
        if (!response.locals.multiUserMode) {
          return response.status(200).json({ canDelete: true });
        }

        if (response.locals.user?.role === ""admin"") {
          return response.status(200).json({ canDelete: true });
        }

        const canDelete = await SystemSettings.canDeleteWorkspaces();
        response.status(200).json({ canDelete });
      } catch (error) {
        console.error(""Error fetching can delete workspaces:"", error);
        response.status(500).json({
          success: false,
          message: ""Internal server error"",
          canDelete: false,
        });
      }
    }
  );

  app.get(""/system/welcome-messages"", async function (request, response) {
    try {
      const welcomeMessages = await WelcomeMessages.getMessages();
      response.status(200).json({ success: true, welcomeMessages });
    } catch (error) {
      console.error(""Error fetching welcome messages:"", error);
      response
        .status(500)
        .json({ success: false, message: ""Internal server error"" });
    }
  });

  app.post(
    ""/system/set-welcome-messages"",
    [validatedRequest],
    async (request, response) => {
      try {
        if (
          response.locals.multiUserMode &&
          response.locals.user?.role !== ""admin""
        ) {
          return response.sendStatus(401).end();
        }

        const { messages = [] } = reqBody(request);
        if (!Array.isArray(messages)) {
          return response.status(400).json({
            success: false,
            message: ""Invalid message format. Expected an array of messages."",
          });
        }

        await WelcomeMessages.saveAll(messages);
        return response.status(200).json({
          success: true,
          message: ""Welcome messages saved successfully."",
        });
      } catch (error) {
        console.error(""Error processing the welcome messages:"", error);
        response.status(500).json({
          success: true,
          message: ""Error saving the welcome messages."",
        });
      }
    }
  );

  app.get(""/system/api-key"", [validatedRequest], async (_, response) => {
    try {
      if (response.locals.multiUserMode) {
        return response.sendStatus(401).end();
      }

      const apiKey = await ApiKey.get(""id IS NOT NULL"");
      return response.status(200).json({
        apiKey,
        error: null,
      });
    } catch (error) {
      console.error(error);
      response.status(500).json({
        apiKey: null,
        error: ""Could not find an API Key."",
      });
    }
  });

  app.post(
    ""/system/generate-api-key"",
    [validatedRequest],
    async (_, response) => {
      try {
        if (response.locals.multiUserMode) {
          return response.sendStatus(401).end();
        }

        await ApiKey.delete();
        const { apiKey, error } = await ApiKey.create();
        return response.status(200).json({
          apiKey,
          error,
        });
      } catch (error) {
        console.error(error);
        response.status(500).json({
          apiKey: null,
          error: ""Error generating api key."",
        });
      }
    }
  );

  app.delete(""/system/api-key"", [validatedRequest], async (_, response) => {
    try {
      if (response.locals.multiUserMode) {
        return response.sendStatus(401).end();
      }

      await ApiKey.delete();
      return response.status(200).end();
    } catch (error) {
      console.error(error);
      response.status(500).end();
    }
  });
}

module.exports = { systemEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR.VAR.VAR === ""VAR"" ? VAR(""VAR"").VAR({ VAR: `.VAR.${VAR.VAR.VAR}` }) : VAR(""VAR"").VAR(); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR, VAR, } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR, VAR, VAR, VAR, } = VAR(""../VAR/VAR""); VAR { VAR, VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(); VAR { VAR } = VAR(); VAR VAR = VAR(""VAR""); VAR VAR = VAR(""VAR""); VAR { VAR, VAR, VAR, VAR, VAR, VAR, VAR, } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""VAR-VAR""); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR"", (VAR, VAR) => { VAR.VAR(200).VAR({ VAR: VAR }); }); VAR.VAR(""/VAR"", VAR (VAR, VAR) => { VAR VAR(VAR); VAR.VAR(200); }); VAR.VAR(""/VAR-VAR"", VAR (VAR, VAR) => { VAR (VAR.VAR.VAR !== ""VAR"") VAR VAR.VAR(200).VAR(); VAR VAR(); VAR.VAR(200).VAR(); }); VAR.VAR(""/VAR-VAR"", VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR(VAR)) { VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR || VAR.VAR) { VAR.VAR(403).VAR(); VAR; } VAR.VAR(200).VAR(); VAR; } VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR-VAR"", VAR (VAR, VAR) => { VAR { VAR (VAR VAR.VAR()) { VAR { VAR, VAR } = VAR(VAR); VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: ""[001] VAR VAR VAR."", }); VAR; } VAR VAR = VAR(""VAR""); VAR (!VAR.VAR(VAR, VAR.VAR)) { VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: ""[002] VAR VAR VAR."", }); VAR; } VAR (VAR.VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: ""[004] VAR VAR VAR VAR."", }); VAR; } VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR, VAR: VAR( { VAR: VAR.VAR, VAR: VAR.VAR }, ""30d"" ), VAR: VAR, }); VAR; } VAR { VAR { VAR } = VAR(VAR); VAR (VAR !== VAR.VAR.VAR) { VAR.VAR(401).VAR({ VAR: VAR, VAR: VAR, VAR: ""[003] VAR VAR VAR"", }); VAR; } VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR({ VAR: VAR }, ""30d""), VAR: VAR, }); } } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR(); VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR(VAR); VAR VAR(VAR, VAR); VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(); VAR.VAR(VAR ? 200 : 503); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(); VAR (!VAR) { VAR.VAR(404).VAR(); VAR; } VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR(VAR); VAR { VAR, VAR } = VAR(VAR); VAR (VAR.VAR.VAR === ""VAR"") VAR VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR(VAR); VAR { VAR } = VAR({ VAR: VAR ? VAR : """", VAR: VAR ? VAR() : """", }); VAR.VAR(200).VAR({ VAR: !VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR(VAR); VAR VAR = VAR VAR.VAR(); VAR (VAR) { VAR.VAR(200).VAR({ VAR: VAR, VAR: ""VAR-VAR VAR VAR VAR VAR."", }); VAR; } VAR { VAR, VAR } = VAR VAR.VAR({ VAR, VAR, VAR: ""VAR"", }); VAR VAR.VAR({ VAR: VAR, VAR: VAR, VAR: VAR, VAR: 25, }); VAR.VAR.VAR = VAR; VAR.VAR.VAR = VAR.VAR.VAR ?? VAR();  VAR VAR.VAR(""VAR""); VAR.VAR(200).VAR({ VAR: !!VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR, VAR } = VAR VAR(); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/VAR-VAR/:VAR"", [VAR], (VAR, VAR) => { VAR VAR = VAR + ""/../VAR/VAR/""; VAR VAR = VAR .VAR(VAR.VAR.VAR) .VAR(/^(\.\.(\/|\\|$))+/, """"); VAR VAR = VAR.VAR(VAR, VAR); VAR (!VAR.VAR(VAR)) { VAR.VAR(404).VAR({ VAR: 404, VAR: `VAR ${VAR.VAR.VAR} VAR VAR VAR VAR VAR.`, }); VAR; } VAR.VAR(VAR, VAR.VAR.VAR, (VAR) => { VAR (VAR) { VAR.VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR"", }); } }); } ); VAR.VAR( ""/VAR/VAR-VAR"", VAR.VAR(""VAR""), VAR VAR (VAR, VAR) { VAR { VAR } = VAR.VAR; VAR { VAR, VAR } = VAR VAR(VAR); VAR.VAR(200).VAR({ VAR, VAR }); } ); VAR.VAR(""/VAR/VAR/:VAR?"", VAR VAR (VAR, VAR) { VAR { VAR VAR = VAR(VAR.VAR.VAR); VAR VAR = VAR VAR(VAR); VAR { VAR, VAR, VAR } = VAR(VAR); VAR.VAR(200, { ""VAR-VAR"": VAR || ""VAR/VAR"", ""VAR-VAR"": `VAR; VAR=${VAR.VAR( VAR )}`, ""VAR-VAR"": VAR, }); VAR.VAR(VAR.VAR(VAR, ""VAR"")); VAR; } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: ""VAR VAR VAR"" }); } }); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR.VAR(""VAR""), VAR (VAR, VAR) => { VAR (!VAR.VAR || !VAR.VAR.VAR) { VAR VAR.VAR(400).VAR({ VAR: ""VAR VAR VAR VAR."" }); } VAR (!VAR(VAR.VAR.VAR)) { VAR VAR.VAR(400).VAR({ VAR: ""VAR VAR VAR. VAR VAR VAR VAR VAR."", }); } VAR { VAR ( VAR.VAR.VAR && VAR.VAR.VAR?.VAR !== ""VAR"" ) { VAR VAR.VAR(401).VAR(); } VAR VAR = VAR VAR(VAR.VAR.VAR); VAR VAR = VAR VAR.VAR(); VAR VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR({ VAR: VAR, }); VAR VAR.VAR(VAR ? 200 : 500).VAR({ VAR: VAR ? ""VAR VAR VAR."" : VAR || ""VAR VAR VAR VAR VAR VAR."", }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: ""VAR VAR VAR VAR."" }); } } ); VAR.VAR( ""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR ( VAR.VAR.VAR && VAR.VAR.VAR?.VAR !== ""VAR"" ) { VAR VAR.VAR(401).VAR(); } VAR VAR = VAR VAR.VAR(); VAR VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR({ VAR: VAR, }); VAR VAR.VAR(VAR ? 200 : 500).VAR({ VAR: VAR ? ""VAR VAR VAR."" : VAR || ""VAR VAR VAR VAR VAR VAR."", }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: ""VAR VAR VAR VAR."" }); } } ); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR VAR (VAR, VAR) { VAR { VAR (!VAR.VAR.VAR) { VAR VAR.VAR(200).VAR({ VAR: VAR }); } VAR (VAR.VAR.VAR?.VAR === ""VAR"") { VAR VAR.VAR(200).VAR({ VAR: VAR }); } VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR"", VAR: VAR, }); } } ); VAR.VAR(""/VAR/VAR-VAR"", VAR VAR (VAR, VAR) { VAR { VAR VAR = VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR: VAR, VAR }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR:"", VAR); VAR .VAR(500) .VAR({ VAR: VAR, VAR: ""VAR VAR VAR"" }); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR ( VAR.VAR.VAR && VAR.VAR.VAR?.VAR !== ""VAR"" ) { VAR VAR.VAR(401).VAR(); } VAR { VAR = [] } = VAR(VAR); VAR (!VAR.VAR(VAR)) { VAR VAR.VAR(400).VAR({ VAR: VAR, VAR: ""VAR VAR VAR. VAR VAR VAR VAR VAR."", }); } VAR VAR.VAR(VAR); VAR VAR.VAR(200).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR."", }); } VAR (VAR) { VAR.VAR(""VAR VAR VAR VAR VAR:"", VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR."", }); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR.VAR.VAR) { VAR VAR.VAR(401).VAR(); } VAR VAR = VAR VAR.VAR(""VAR VAR VAR VAR""); VAR VAR.VAR(200).VAR({ VAR, VAR: VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."", }); } }); VAR.VAR( ""/VAR/VAR-VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR.VAR.VAR) { VAR VAR.VAR(401).VAR(); } VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR.VAR(); VAR VAR.VAR(200).VAR({ VAR, VAR, }); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR({ VAR: VAR, VAR: ""VAR VAR VAR VAR."", }); } } ); VAR.VAR(""/VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR (VAR.VAR.VAR) { VAR VAR.VAR(401).VAR(); } VAR VAR.VAR(); VAR VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/utils.js,"const { SystemSettings } = require(""../models/systemSettings"");

function getGitVersion() {
  try {
    return require(""child_process"")
      .execSync(""git rev-parse HEAD"")
      .toString()
      .trim();
  } catch (e) {
    console.error(""getGitVersion"", e.message);
    return ""--"";
  }
}

function byteToGigaByte(n) {
  return n / Math.pow(10, 9);
}

async function getDiskStorage() {
  try {
    const checkDiskSpace = require(""check-disk-space"").default;
    const { free, size } = await checkDiskSpace(""/"");
    return {
      current: Math.floor(byteToGigaByte(free)),
      capacity: Math.floor(byteToGigaByte(size)),
    };
  } catch {
    return {
      current: null,
      capacity: null,
    };
  }
}

function utilEndpoints(app) {
  if (!app) return;

  app.get(""/utils/metrics"", async (_, response) => {
    try {
      const metrics = {
        online: true,
        version: getGitVersion(),
        mode: (await SystemSettings.isMultiUserMode())
          ? ""multi-user""
          : ""single-user"",
        vectorDB: process.env.VECTOR_DB || ""lancedb"",
        storage: await getDiskStorage(),
      };
      response.status(200).json(metrics);
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });
}

module.exports = { utilEndpoints, getGitVersion };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR VAR() { VAR { VAR VAR(""VAR"") .VAR(""VAR VAR-VAR VAR"") .VAR() .VAR(); } VAR (VAR) { VAR.VAR(""VAR"", VAR.VAR); VAR ""--""; } } VAR VAR(VAR) { VAR VAR / VAR.VAR(10, 9); } VAR VAR VAR() { VAR { VAR VAR = VAR(""VAR-VAR-VAR"").VAR; VAR { VAR, VAR } = VAR VAR(""/""); VAR { VAR: VAR.VAR(VAR(VAR)), VAR: VAR.VAR(VAR(VAR)), }; } VAR { VAR { VAR: VAR, VAR: VAR, }; } } VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", VAR (VAR, VAR) => { VAR { VAR VAR = { VAR: VAR, VAR: VAR(), VAR: (VAR VAR.VAR()) ? ""VAR-VAR"" : ""VAR-VAR"", VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR VAR(), }; VAR.VAR(200).VAR(VAR); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); } VAR.VAR = { VAR, VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/utils.js,"const { SystemSettings } = require(""../models/systemSettings"");

function getGitVersion() {
  try {
    return require(""child_process"")
      .execSync(""git rev-parse HEAD"")
      .toString()
      .trim();
  } catch (e) {
    console.error(""getGitVersion"", e.message);
    return ""--"";
  }
}

function byteToGigaByte(n) {
  return n / Math.pow(10, 9);
}

async function getDiskStorage() {
  try {
    const checkDiskSpace = require(""check-disk-space"").default;
    const { free, size } = await checkDiskSpace(""/"");
    return {
      current: Math.floor(byteToGigaByte(free)),
      capacity: Math.floor(byteToGigaByte(size)),
    };
  } catch {
    return {
      current: null,
      capacity: null,
    };
  }
}

function utilEndpoints(app) {
  if (!app) return;

  app.get(""/utils/metrics"", async (_, response) => {
    try {
      const metrics = {
        online: true,
        version: getGitVersion(),
        mode: (await SystemSettings.isMultiUserMode())
          ? ""multi-user""
          : ""single-user"",
        vectorDB: process.env.VECTOR_DB || ""lancedb"",
        storage: await getDiskStorage(),
      };
      response.status(200).json(metrics);
    } catch (e) {
      console.error(e);
      response.sendStatus(500).end();
    }
  });
}

module.exports = { utilEndpoints, getGitVersion };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR VAR() { VAR { VAR VAR(""VAR"") .VAR(""VAR VAR-VAR VAR"") .VAR() .VAR(); } VAR (VAR) { VAR.VAR(""VAR"", VAR.VAR); VAR ""--""; } } VAR VAR(VAR) { VAR VAR / VAR.VAR(10, 9); } VAR VAR VAR() { VAR { VAR VAR = VAR(""VAR-VAR-VAR"").VAR; VAR { VAR, VAR } = VAR VAR(""/""); VAR { VAR: VAR.VAR(VAR(VAR)), VAR: VAR.VAR(VAR(VAR)), }; } VAR { VAR { VAR: VAR, VAR: VAR, }; } } VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", VAR (VAR, VAR) => { VAR { VAR VAR = { VAR: VAR, VAR: VAR(), VAR: (VAR VAR.VAR()) ? ""VAR-VAR"" : ""VAR-VAR"", VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR VAR(), }; VAR.VAR(200).VAR(VAR); } VAR (VAR) { VAR.VAR(VAR); VAR.VAR(500).VAR(); } }); } VAR.VAR = { VAR, VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/workspaces.js,"const { reqBody, multiUserMode, userFromSession } = require(""../utils/http"");
const { Workspace } = require(""../models/workspace"");
const { Document } = require(""../models/documents"");
const { DocumentVectors } = require(""../models/vectors"");
const { WorkspaceChats } = require(""../models/workspaceChats"");
const { convertToChatHistory } = require(""../utils/chats"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { setupMulter } = require(""../utils/files/multer"");
const {
  checkPythonAppAlive,
  processDocument,
} = require(""../utils/files/documentProcessor"");
const { validatedRequest } = require(""../utils/middleware/validatedRequest"");
const { SystemSettings } = require(""../models/systemSettings"");
const { Telemetry } = require(""../models/telemetry"");
const { escape } = require(""sqlstring-sqlite"");
const { handleUploads } = setupMulter();

function workspaceEndpoints(app) {
  if (!app) return;

  app.post(""/workspace/new"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      const { name = null } = reqBody(request);
      const { workspace, message } = await Workspace.new(name, user?.id);
      await Telemetry.sendTelemetry(""workspace_created"", {
        multiUserMode: multiUserMode(response),
        LLMSelection: process.env.LLM_PROVIDER || ""openai"",
        VectorDbSelection: process.env.VECTOR_DB || ""pinecone"",
      });
      response.status(200).json({ workspace, message });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/workspace/:slug/update"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        const { slug = null } = request.params;
        const data = reqBody(request);
        const currWorkspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = ${escape(slug)}`)
          : await Workspace.get(`slug = ${escape(slug)}`);

        if (!currWorkspace) {
          response.sendStatus(400).end();
          return;
        }

        const { workspace, message } = await Workspace.update(
          currWorkspace.id,
          data
        );
        response.status(200).json({ workspace, message });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/workspace/:slug/upload"",
    handleUploads.single(""file""),
    async function (request, response) {
      const { originalname } = request.file;
      const processingOnline = await checkPythonAppAlive();

      if (!processingOnline) {
        response
          .status(500)
          .json({
            success: false,
            error: `Python processing API is not online. Document ${originalname} will not be processed automatically.`,
          })
          .end();
        return;
      }

      const { success, reason } = await processDocument(originalname);
      if (!success) {
        response.status(500).json({ success: false, error: reason }).end();
        return;
      }

      console.log(
        `Document ${originalname} uploaded processed and successfully. It is now available in documents.`
      );
      await Telemetry.sendTelemetry(""document_uploaded"");
      response.status(200).json({ success: true, error: null });
    }
  );

  app.post(
    ""/workspace/:slug/update-embeddings"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        const { slug = null } = request.params;
        const { adds = [], deletes = [] } = reqBody(request);
        const currWorkspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = ${escape(slug)}`)
          : await Workspace.get(`slug = ${escape(slug)}`);

        if (!currWorkspace) {
          response.sendStatus(400).end();
          return;
        }

        await Document.removeDocuments(currWorkspace, deletes);
        await Document.addDocuments(currWorkspace, adds);
        const updatedWorkspace = await Workspace.get(
          `id = ${currWorkspace.id}`
        );
        response.status(200).json({ workspace: updatedWorkspace });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/workspace/:slug"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { slug = """" } = request.params;
        const user = await userFromSession(request, response);
        const VectorDb = getVectorDbClass();
        const workspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = ${escape(slug)}`)
          : await Workspace.get(`slug = ${escape(slug)}`);

        if (!workspace) {
          response.sendStatus(400).end();
          return;
        }

        if (multiUserMode(response) && user.role !== ""admin"") {
          const canDelete =
            (await SystemSettings.get(`label = 'users_can_delete_workspaces'`))
              ?.value === ""true"";
          if (!canDelete) {
            response.sendStatus(500).end();
            return;
          }
        }

        await Workspace.delete(`id = ${Number(workspace.id)}`);
        await DocumentVectors.deleteForWorkspace(workspace.id);
        await Document.delete(`workspaceId = ${Number(workspace.id)}`);
        await WorkspaceChats.delete(`workspaceId = ${Number(workspace.id)}`);
        try {
          await VectorDb[""delete-namespace""]({ namespace: slug });
        } catch (e) {
          console.error(e.message);
        }
        response.sendStatus(200).end();
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/workspaces"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      const workspaces = multiUserMode(response)
        ? await Workspace.whereWithUser(user)
        : await Workspace.where();

      response.status(200).json({ workspaces });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/workspace/:slug"", [validatedRequest], async (request, response) => {
    try {
      const { slug } = request.params;
      const user = await userFromSession(request, response);
      const workspace = multiUserMode(response)
        ? await Workspace.getWithUser(user, `slug = ${escape(slug)}`)
        : await Workspace.get(`slug = ${escape(slug)}`);

      response.status(200).json({ workspace });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/workspace/:slug/chats"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { slug } = request.params;
        const user = await userFromSession(request, response);
        const workspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = ${escape(slug)}`)
          : await Workspace.get(`slug = ${escape(slug)}`);

        if (!workspace) {
          response.sendStatus(400).end();
          return;
        }

        const history = multiUserMode(response)
          ? await WorkspaceChats.forWorkspaceByUser(workspace.id, user.id)
          : await WorkspaceChats.forWorkspace(workspace.id);

        response.status(200).json({ history: convertToChatHistory(history) });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { workspaceEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR, VAR, VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR, VAR, } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""VAR-VAR""); VAR { VAR } = VAR(); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR { VAR = VAR } = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR(VAR, VAR?.VAR); VAR VAR.VAR(""VAR"", { VAR: VAR(VAR), VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR.VAR.VAR || ""VAR"", }); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/:VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR { VAR = VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = ${VAR(VAR)}`) : VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR( VAR.VAR, VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/:VAR/VAR"", VAR.VAR(""VAR""), VAR VAR (VAR, VAR) { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(); VAR (!VAR) { VAR .VAR(500) .VAR({ VAR: VAR, VAR: `VAR VAR VAR VAR VAR VAR. VAR ${VAR} VAR VAR VAR VAR VAR.`, }) .VAR(); VAR; } VAR { VAR, VAR } = VAR VAR(VAR); VAR (!VAR) { VAR.VAR(500).VAR({ VAR: VAR, VAR: VAR }).VAR(); VAR; } VAR.VAR( `VAR ${VAR} VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR.` ); VAR VAR.VAR(""VAR""); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } ); VAR.VAR( ""/VAR/:VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR { VAR = VAR } = VAR.VAR; VAR { VAR = [], VAR = [] } = VAR(VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = ${VAR(VAR)}`) : VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR VAR.VAR(VAR, VAR); VAR VAR.VAR(VAR, VAR); VAR VAR = VAR VAR.VAR( `VAR = ${VAR.VAR}` ); VAR.VAR(200).VAR({ VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR = """" } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = ${VAR(VAR)}`) : VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR (VAR(VAR) && VAR.VAR !== ""VAR"") { VAR VAR = (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR""; VAR (!VAR) { VAR.VAR(500).VAR(); VAR; } } VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR VAR.VAR(VAR.VAR); VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR { VAR VAR[""VAR-VAR""]({ VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR); } VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR) : VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = ${VAR(VAR)}`) : VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/:VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = ${VAR(VAR)}`) : VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR.VAR, VAR.VAR) : VAR VAR.VAR(VAR.VAR); VAR.VAR(200).VAR({ VAR: VAR(VAR) }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/endpoints/workspaces.js,"const { reqBody, multiUserMode, userFromSession } = require(""../utils/http"");
const { Workspace } = require(""../models/workspace"");
const { Document } = require(""../models/documents"");
const { DocumentVectors } = require(""../models/vectors"");
const { WorkspaceChats } = require(""../models/workspaceChats"");
const { convertToChatHistory } = require(""../utils/chats"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { setupMulter } = require(""../utils/files/multer"");
const {
  checkPythonAppAlive,
  processDocument,
} = require(""../utils/files/documentProcessor"");
const { validatedRequest } = require(""../utils/middleware/validatedRequest"");
const { SystemSettings } = require(""../models/systemSettings"");
const { Telemetry } = require(""../models/telemetry"");
const { escape } = require(""sqlstring-sqlite"");
const { handleUploads } = setupMulter();

function workspaceEndpoints(app) {
  if (!app) return;

  app.post(""/workspace/new"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      const { name = null } = reqBody(request);
      const { workspace, message } = await Workspace.new(name, user?.id);
      await Telemetry.sendTelemetry(""workspace_created"", {
        multiUserMode: multiUserMode(response),
        LLMSelection: process.env.LLM_PROVIDER || ""openai"",
        VectorDbSelection: process.env.VECTOR_DB || ""pinecone"",
      });
      response.status(200).json({ workspace, message });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.post(
    ""/workspace/:slug/update"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        const { slug = null } = request.params;
        const data = reqBody(request);
        const currWorkspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = ${escape(slug)}`)
          : await Workspace.get(`slug = ${escape(slug)}`);

        if (!currWorkspace) {
          response.sendStatus(400).end();
          return;
        }

        const { workspace, message } = await Workspace.update(
          currWorkspace.id,
          data
        );
        response.status(200).json({ workspace, message });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.post(
    ""/workspace/:slug/upload"",
    handleUploads.single(""file""),
    async function (request, response) {
      const { originalname } = request.file;
      const processingOnline = await checkPythonAppAlive();

      if (!processingOnline) {
        response
          .status(500)
          .json({
            success: false,
            error: `Python processing API is not online. Document ${originalname} will not be processed automatically.`,
          })
          .end();
        return;
      }

      const { success, reason } = await processDocument(originalname);
      if (!success) {
        response.status(500).json({ success: false, error: reason }).end();
        return;
      }

      console.log(
        `Document ${originalname} uploaded processed and successfully. It is now available in documents.`
      );
      await Telemetry.sendTelemetry(""document_uploaded"");
      response.status(200).json({ success: true, error: null });
    }
  );

  app.post(
    ""/workspace/:slug/update-embeddings"",
    [validatedRequest],
    async (request, response) => {
      try {
        const user = await userFromSession(request, response);
        const { slug = null } = request.params;
        const { adds = [], deletes = [] } = reqBody(request);
        const currWorkspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = ${escape(slug)}`)
          : await Workspace.get(`slug = ${escape(slug)}`);

        if (!currWorkspace) {
          response.sendStatus(400).end();
          return;
        }

        await Document.removeDocuments(currWorkspace, deletes);
        await Document.addDocuments(currWorkspace, adds);
        const updatedWorkspace = await Workspace.get(
          `id = ${currWorkspace.id}`
        );
        response.status(200).json({ workspace: updatedWorkspace });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.delete(
    ""/workspace/:slug"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { slug = """" } = request.params;
        const user = await userFromSession(request, response);
        const VectorDb = getVectorDbClass();
        const workspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = ${escape(slug)}`)
          : await Workspace.get(`slug = ${escape(slug)}`);

        if (!workspace) {
          response.sendStatus(400).end();
          return;
        }

        if (multiUserMode(response) && user.role !== ""admin"") {
          const canDelete =
            (await SystemSettings.get(`label = 'users_can_delete_workspaces'`))
              ?.value === ""true"";
          if (!canDelete) {
            response.sendStatus(500).end();
            return;
          }
        }

        await Workspace.delete(`id = ${Number(workspace.id)}`);
        await DocumentVectors.deleteForWorkspace(workspace.id);
        await Document.delete(`workspaceId = ${Number(workspace.id)}`);
        await WorkspaceChats.delete(`workspaceId = ${Number(workspace.id)}`);
        try {
          await VectorDb[""delete-namespace""]({ namespace: slug });
        } catch (e) {
          console.error(e.message);
        }
        response.sendStatus(200).end();
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );

  app.get(""/workspaces"", [validatedRequest], async (request, response) => {
    try {
      const user = await userFromSession(request, response);
      const workspaces = multiUserMode(response)
        ? await Workspace.whereWithUser(user)
        : await Workspace.where();

      response.status(200).json({ workspaces });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(""/workspace/:slug"", [validatedRequest], async (request, response) => {
    try {
      const { slug } = request.params;
      const user = await userFromSession(request, response);
      const workspace = multiUserMode(response)
        ? await Workspace.getWithUser(user, `slug = ${escape(slug)}`)
        : await Workspace.get(`slug = ${escape(slug)}`);

      response.status(200).json({ workspace });
    } catch (e) {
      console.log(e.message, e);
      response.sendStatus(500).end();
    }
  });

  app.get(
    ""/workspace/:slug/chats"",
    [validatedRequest],
    async (request, response) => {
      try {
        const { slug } = request.params;
        const user = await userFromSession(request, response);
        const workspace = multiUserMode(response)
          ? await Workspace.getWithUser(user, `slug = ${escape(slug)}`)
          : await Workspace.get(`slug = ${escape(slug)}`);

        if (!workspace) {
          response.sendStatus(400).end();
          return;
        }

        const history = multiUserMode(response)
          ? await WorkspaceChats.forWorkspaceByUser(workspace.id, user.id)
          : await WorkspaceChats.forWorkspace(workspace.id);

        response.status(200).json({ history: convertToChatHistory(history) });
      } catch (e) {
        console.log(e.message, e);
        response.sendStatus(500).end();
      }
    }
  );
}

module.exports = { workspaceEndpoints };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR, VAR, VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR, VAR, } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""VAR-VAR""); VAR { VAR } = VAR(); VAR VAR(VAR) { VAR (!VAR) VAR; VAR.VAR(""/VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR { VAR = VAR } = VAR(VAR); VAR { VAR, VAR } = VAR VAR.VAR(VAR, VAR?.VAR); VAR VAR.VAR(""VAR"", { VAR: VAR(VAR), VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR.VAR.VAR || ""VAR"", }); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/:VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR { VAR = VAR } = VAR.VAR; VAR VAR = VAR(VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = ${VAR(VAR)}`) : VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR { VAR, VAR } = VAR VAR.VAR( VAR.VAR, VAR ); VAR.VAR(200).VAR({ VAR, VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/:VAR/VAR"", VAR.VAR(""VAR""), VAR VAR (VAR, VAR) { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(); VAR (!VAR) { VAR .VAR(500) .VAR({ VAR: VAR, VAR: `VAR VAR VAR VAR VAR VAR. VAR ${VAR} VAR VAR VAR VAR VAR.`, }) .VAR(); VAR; } VAR { VAR, VAR } = VAR VAR(VAR); VAR (!VAR) { VAR.VAR(500).VAR({ VAR: VAR, VAR: VAR }).VAR(); VAR; } VAR.VAR( `VAR ${VAR} VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR.` ); VAR VAR.VAR(""VAR""); VAR.VAR(200).VAR({ VAR: VAR, VAR: VAR }); } ); VAR.VAR( ""/VAR/:VAR/VAR-VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR { VAR = VAR } = VAR.VAR; VAR { VAR = [], VAR = [] } = VAR(VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = ${VAR(VAR)}`) : VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR VAR.VAR(VAR, VAR); VAR VAR.VAR(VAR, VAR); VAR VAR = VAR VAR.VAR( `VAR = ${VAR.VAR}` ); VAR.VAR(200).VAR({ VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR( ""/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR = """" } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = ${VAR(VAR)}`) : VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR (VAR(VAR) && VAR.VAR !== ""VAR"") { VAR VAR = (VAR VAR.VAR(`VAR = 'VAR'`)) ?.VAR === ""VAR""; VAR (!VAR) { VAR.VAR(500).VAR(); VAR; } } VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR VAR.VAR(VAR.VAR); VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR VAR.VAR(`VAR = ${VAR(VAR.VAR)}`); VAR { VAR VAR[""VAR-VAR""]({ VAR: VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR); } VAR.VAR(200).VAR(); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); VAR.VAR(""/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR) : VAR VAR.VAR(); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR(""/VAR/:VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = ${VAR(VAR)}`) : VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR.VAR(200).VAR({ VAR }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } }); VAR.VAR( ""/VAR/:VAR/VAR"", [VAR], VAR (VAR, VAR) => { VAR { VAR { VAR } = VAR.VAR; VAR VAR = VAR VAR(VAR, VAR); VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR, `VAR = ${VAR(VAR)}`) : VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) { VAR.VAR(400).VAR(); VAR; } VAR VAR = VAR(VAR) ? VAR VAR.VAR(VAR.VAR, VAR.VAR) : VAR VAR.VAR(VAR.VAR); VAR.VAR(200).VAR({ VAR: VAR(VAR) }); } VAR (VAR) { VAR.VAR(VAR.VAR, VAR); VAR.VAR(500).VAR(); } } ); } VAR.VAR = { VAR }; ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/swagger/openapi.json,"{
  ""openapi"": ""3.0.0"",
  ""info"": {
    ""version"": ""1.0.0"",
    ""title"": ""AnythingLLM Developer API"",
    ""description"": ""API endpoints that enable programmatic reading, writing, and updating of your AnythingLLM instance. UI supplied by Swagger.io.""
  },
  ""servers"": [
    {
      ""url"": ""http:///api/""
    }
  ],
  ""paths"": {
    ""/v1/auth"": {
      ""get"": {
        ""tags"": [
          ""Authentication""
        ],
        ""description"": ""Verify the attached Authentication header contains a valid API token."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""Valid auth token was found."",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""authenticated"": true
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          }
        }
      }
    },
    ""/v1/admin/is-multi-user-mode"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""isMultiUser"": true
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          }
        }
      }
    },
    ""/v1/admin/users"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""users"": [
                      {
                        ""username"": ""sample-sam"",
                        ""role"": ""default""
                      }
                    ]
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/users/new"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Create a new user with username and password. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""user"": {
                      ""id"": 1,
                      ""username"": ""sample-sam"",
                      ""role"": ""default""
                    },
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Key pair object that will define the new user to add to the system."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""username"": ""sample-sam"",
                ""password"": ""hunter2"",
                ""role"": ""default | admin""
              }
            }
          }
        }
      }
    },
    ""/v1/admin/users/{id}"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Update existing user settings. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""id"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the user in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Key pair object that will update the found user. All fields are optional and will not update unless specified."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""username"": ""sample-sam"",
                ""password"": ""hunter2"",
                ""role"": ""default | admin"",
                ""suspended"": 0
              }
            }
          }
        }
      },
      ""delete"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Delete existing user by id. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""id"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the user in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/invites"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""List all existing invitations to instance regardless of status. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""invites"": [
                      {
                        ""id"": 1,
                        ""status"": ""pending"",
                        ""code"": ""abc-123"",
                        ""claimedBy"": null
                      }
                    ]
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/invite/new"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Create a new invite code for someone to use to register with instance. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""invite"": {
                      ""id"": 1,
                      ""status"": ""pending"",
                      ""code"": ""abc-123""
                    },
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/invite/{id}"": {
      ""delete"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Deactivates (soft-delete) invite by id. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""id"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the invite in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/workspaces/{workspaceId}/update-users"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Overwrite workspace permissions to only be accessible by the given user ids and admins. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""workspaceId"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the workspace in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Entire array of user ids who can access the workspace. All fields are optional and will not update unless specified."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""userIds"": [
                  1,
                  2,
                  4,
                  12
                ]
              }
            }
          }
        }
      }
    },
    ""/v1/admin/workspace-chats"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""All chats in the system ordered by most recent. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Page offset to show of workspace chats. All fields are optional and will not update unless specified."",
          ""required"": false,
          ""type"": ""integer"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""offset"": 2
              }
            }
          }
        }
      }
    },
    ""/v1/admin/preferences"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Show all multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""settings"": {
                      ""users_can_delete_workspaces"": true,
                      ""limit_user_messages"": false,
                      ""message_limit"": 10
                    }
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      },
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Update multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Object with setting key and new value to set. All keys are optional and will not update unless specified."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""users_can_delete_workspaces"": false,
                ""limit_user_messages"": true,
                ""message_limit"": 5
              }
            }
          }
        }
      }
    },
    ""/v1/document/upload"": {
      ""post"": {
        ""tags"": [
          ""Documents""
        ],
        ""description"": ""Upload a new file to AnythingLLM to be parsed and prepared for embedding."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""File to be uploaded."",
          ""required"": true,
          ""type"": ""file"",
          ""content"": {
            ""multipart/form-data"": {
              ""schema"": {
                ""type"": ""object"",
                ""properties"": {
                  ""file"": {
                    ""type"": ""string"",
                    ""format"": ""binary""
                  }
                }
              }
            }
          }
        }
      }
    },
    ""/v1/documents"": {
      ""get"": {
        ""tags"": [
          ""Documents""
        ],
        ""description"": ""List of all locally-stored documents in instance"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""localFiles"": {
                      ""name"": ""documents"",
                      ""type"": ""folder"",
                      ""items"": [
                        {
                          ""name"": ""my-stored-document.json"",
                          ""type"": ""file"",
                          ""id"": ""bb07c334-4dab-4419-9462-9d00065a49a1"",
                          ""url"": ""file://my-stored-document.txt"",
                          ""title"": ""my-stored-document.txt"",
                          ""cached"": false
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/document/accepted-file-types"": {
      ""get"": {
        ""tags"": [
          ""Documents""
        ],
        ""description"": ""Check available filetypes and MIMEs that can be uploaded."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""types"": {
                      ""application/mbox"": [
                        "".mbox""
                      ],
                      ""application/pdf"": [
                        "".pdf""
                      ],
                      ""application/vnd.oasis.opendocument.text"": [
                        "".odt""
                      ],
                      ""application/vnd.openxmlformats-officedocument.wordprocessingml.document"": [
                        "".docx""
                      ],
                      ""text/plain"": [
                        "".txt"",
                        "".md""
                      ]
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""404"": {
            ""description"": ""Not Found""
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/new"": {
      ""post"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Create a new workspace"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""Sample workspace"",
                      ""slug"": ""sample-workspace"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null
                    },
                    ""message"": ""Workspace created""
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""JSON object containing new display name of workspace."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""name"": ""My New Workspace""
              }
            }
          }
        }
      }
    },
    ""/v1/workspaces"": {
      ""get"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""List all current workspaces"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspaces"": [
                      {
                        ""id"": 79,
                        ""name"": ""Sample workspace"",
                        ""slug"": ""sample-workspace"",
                        ""createdAt"": ""2023-08-17 00:45:03"",
                        ""openAiTemp"": null,
                        ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                        ""openAiHistory"": 20,
                        ""openAiPrompt"": null
                      }
                    ]
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/{slug}"": {
      ""get"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Get a workspace by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""My workspace"",
                      ""slug"": ""my-workspace-123"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null,
                      ""documents"": []
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      },
      ""delete"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Deletes a workspace by its slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to delete""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK""
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/{slug}/update"": {
      ""post"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Update workspace settings by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""My workspace"",
                      ""slug"": ""my-workspace-123"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null,
                      ""documents"": []
                    },
                    ""message"": null
                  }
                }
              }
            }
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""JSON object containing new settings to update a workspace. All keys are optional and will not update unless provided"",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""name"": ""Updated Workspace Name"",
                ""openAiTemp"": 0.2,
                ""openAiHistory"": 20,
                ""openAiPrompt"": ""Respond to all inquires and questions in binary - do not respond in any other format.""
              }
            }
          }
        }
      }
    },
    ""/v1/workspace/{slug}/chats"": {
      ""get"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Get a workspaces chats regardless of user by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""history"": [
                      {
                        ""role"": ""user"",
                        ""content"": ""What is AnythingLLM?"",
                        ""sentAt"": 1692851630
                      },
                      {
                        ""role"": ""assistant"",
                        ""content"": ""AnythingLLM is a platform that allows you to convert notes, PDFs, and other source materials into a chatbot. It ensures privacy, cites its answers, and allows multiple people to interact with the same documents simultaneously. It is particularly useful for businesses to enhance the visibility and readability of various written communications such as SOPs, contracts, and sales calls. You can try it out with a free trial to see if it meets your business needs."",
                        ""sources"": [
                          {
                            ""source"": ""object about source document and snippets used""
                          }
                        ]
                      }
                    ]
                  }
                }
              }
            }
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/{slug}/update-embeddings"": {
      ""post"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Add or remove documents from a workspace by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""My workspace"",
                      ""slug"": ""my-workspace-123"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null,
                      ""documents"": []
                    },
                    ""message"": null
                  }
                }
              }
            }
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""JSON object of additions and removals of documents to add to update a workspace. The value should be the folder + filename with the exclusions of the top-level documents path."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""adds"": [],
                ""deletes"": [
                  ""custom-documents/anythingllm-hash.json""
                ]
              }
            }
          }
        }
      }
    },
    ""/v1/system/env-dump"": {
      ""get"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Dump all settings to file storage"",
        ""responses"": {
          ""200"": {
            ""description"": ""OK""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/system"": {
      ""get"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Get all current system settings that are defined."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""settings"": {
                      ""VectorDB"": ""pinecone"",
                      ""PineConeEnvironment"": ""us-west4-gcp-free"",
                      ""PineConeKey"": true,
                      ""PineConeIndex"": ""my-pinecone-index"",
                      ""LLMProvider"": ""azure"",
                      ""[KEY_NAME]"": ""KEY_VALUE""
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/system/vector-count"": {
      ""get"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Number of all vectors in connected vector database"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""vectorCount"": 5450
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/system/update-env"": {
      ""post"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Update a system setting or preference."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""newValues"": {
                      ""[ENV_KEY]"": ""Value""
                    },
                    ""error"": ""error goes here, otherwise null""
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Key pair object that matches a valid setting and value. Get keys from GET /v1/system or refer to codebase."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""VectorDB"": ""lancedb"",
                ""AnotherKey"": ""updatedValue""
              }
            }
          }
        }
      }
    }
  },
  ""components"": {
    ""schemas"": {
      ""InvalidAPIKey"": {
        ""type"": ""object"",
        ""properties"": {
          ""message"": {
            ""type"": ""string"",
            ""example"": ""Invalid API Key""
          }
        },
        ""xml"": {
          ""name"": ""InvalidAPIKey""
        }
      }
    },
    ""securitySchemes"": {
      ""BearerAuth"": {
        ""type"": ""http"",
        ""scheme"": ""bearer"",
        ""bearerFormat"": ""JWT""
      }
    }
  },
  ""security"": [
    {
      ""BearerAuth"": []
    }
  ]
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"{ ""VAR"": ""3.0.0"", ""VAR"": { ""VAR"": ""1.0.0"", ""VAR"": ""VAR VAR VAR"", ""VAR"": ""VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR.VAR."" }, ""VAR"": [ { ""VAR"": ""VAR: } ], ""VAR"": { ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR VAR VAR VAR VAR."", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } } } } }, ""/VAR/VAR/VAR-VAR-VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR-VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR-VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"" } ] } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 1, ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"" }, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR | VAR"" } } } } } }, ""/VAR/VAR/VAR/{VAR}"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR | VAR"", ""VAR"": 0 } } } } }, ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": 1, ""VAR"": ""VAR"", ""VAR"": ""VAR-123"", ""VAR"": VAR } ] } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 1, ""VAR"": ""VAR"", ""VAR"": ""VAR-123"" }, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/{VAR}"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR (VAR-VAR) VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/{VAR}/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": [ 1, 2, 4, 12 ] } } } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": 2 } } } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR-VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": VAR, ""VAR"": VAR, ""VAR"": 10 } } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } }, ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR-VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": VAR, ""VAR"": VAR, ""VAR"": 5 } } } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR-VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"" } } } } } } } }, ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR-VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": [ { ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR-4dab-4419-9462-9d00065a49a1"", ""VAR"": ""VAR: ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": VAR } ] } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR-VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR.VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR.VAR-VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"", "".VAR"" ] } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""404"": { ""VAR"": ""VAR VAR"" }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR }, ""VAR"": ""VAR VAR"" } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR VAR VAR"" } } } } } }, ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR } ] } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/{VAR}"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR-123"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR, ""VAR"": [] } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } }, ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"" }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/{VAR}/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR-123"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR, ""VAR"": [] }, ""VAR"": VAR } } } } }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR VAR VAR"", ""VAR"": 0.2, ""VAR"": 20, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR - VAR VAR VAR VAR VAR VAR VAR."" } } } } } }, ""/VAR/VAR/{VAR}/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR VAR VAR?"", ""VAR"": 1692851630 }, { ""VAR"": ""VAR"", ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR"" } ] } ] } } } } }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/{VAR}/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR-123"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR, ""VAR"": [] }, ""VAR"": VAR } } } } }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR + VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": [], ""VAR"": [ ""VAR-VAR/VAR-VAR.VAR"" ] } } } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR"", ""VAR"": { ""200"": { ""VAR"": ""VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR-VAR-VAR-VAR"", ""VAR"": VAR, ""VAR"": ""VAR-VAR-VAR"", ""VAR"": ""VAR"", ""[VAR]"": ""VAR"" } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": 5450 } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""[VAR]"": ""VAR"" }, ""VAR"": ""VAR VAR VAR, VAR VAR"" } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR /VAR/VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"" } } } } } } }, ""VAR"": { ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR"" } } }, ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR"" } } }, ""VAR"": [ { ""VAR"": [] } ] } ",8
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/swagger/openapi.json,"{
  ""openapi"": ""3.0.0"",
  ""info"": {
    ""version"": ""1.0.0"",
    ""title"": ""AnythingLLM Developer API"",
    ""description"": ""API endpoints that enable programmatic reading, writing, and updating of your AnythingLLM instance. UI supplied by Swagger.io.""
  },
  ""servers"": [
    {
      ""url"": ""http:///api/""
    }
  ],
  ""paths"": {
    ""/v1/auth"": {
      ""get"": {
        ""tags"": [
          ""Authentication""
        ],
        ""description"": ""Verify the attached Authentication header contains a valid API token."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""Valid auth token was found."",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""authenticated"": true
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          }
        }
      }
    },
    ""/v1/admin/is-multi-user-mode"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""isMultiUser"": true
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          }
        }
      }
    },
    ""/v1/admin/users"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Check to see if the instance is in multi-user-mode first. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""users"": [
                      {
                        ""username"": ""sample-sam"",
                        ""role"": ""default""
                      }
                    ]
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/users/new"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Create a new user with username and password. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""user"": {
                      ""id"": 1,
                      ""username"": ""sample-sam"",
                      ""role"": ""default""
                    },
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Key pair object that will define the new user to add to the system."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""username"": ""sample-sam"",
                ""password"": ""hunter2"",
                ""role"": ""default | admin""
              }
            }
          }
        }
      }
    },
    ""/v1/admin/users/{id}"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Update existing user settings. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""id"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the user in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Key pair object that will update the found user. All fields are optional and will not update unless specified."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""username"": ""sample-sam"",
                ""password"": ""hunter2"",
                ""role"": ""default | admin"",
                ""suspended"": 0
              }
            }
          }
        }
      },
      ""delete"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Delete existing user by id. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""id"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the user in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/invites"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""List all existing invitations to instance regardless of status. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""invites"": [
                      {
                        ""id"": 1,
                        ""status"": ""pending"",
                        ""code"": ""abc-123"",
                        ""claimedBy"": null
                      }
                    ]
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/invite/new"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Create a new invite code for someone to use to register with instance. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""invite"": {
                      ""id"": 1,
                      ""status"": ""pending"",
                      ""code"": ""abc-123""
                    },
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/invite/{id}"": {
      ""delete"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Deactivates (soft-delete) invite by id. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""id"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the invite in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/admin/workspaces/{workspaceId}/update-users"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Overwrite workspace permissions to only be accessible by the given user ids and admins. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""workspaceId"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""id of the workspace in the database.""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Entire array of user ids who can access the workspace. All fields are optional and will not update unless specified."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""userIds"": [
                  1,
                  2,
                  4,
                  12
                ]
              }
            }
          }
        }
      }
    },
    ""/v1/admin/workspace-chats"": {
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""All chats in the system ordered by most recent. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Page offset to show of workspace chats. All fields are optional and will not update unless specified."",
          ""required"": false,
          ""type"": ""integer"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""offset"": 2
              }
            }
          }
        }
      }
    },
    ""/v1/admin/preferences"": {
      ""get"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Show all multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""settings"": {
                      ""users_can_delete_workspaces"": true,
                      ""limit_user_messages"": false,
                      ""message_limit"": 10
                    }
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      },
      ""post"": {
        ""tags"": [
          ""Admin""
        ],
        ""description"": ""Update multi-user preferences for instance. Methods are disabled until multi user mode is enabled via the UI."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""401"": {
            ""description"": ""Instance is not in Multi-User mode. Method denied""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Object with setting key and new value to set. All keys are optional and will not update unless specified."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""users_can_delete_workspaces"": false,
                ""limit_user_messages"": true,
                ""message_limit"": 5
              }
            }
          }
        }
      }
    },
    ""/v1/document/upload"": {
      ""post"": {
        ""tags"": [
          ""Documents""
        ],
        ""description"": ""Upload a new file to AnythingLLM to be parsed and prepared for embedding."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""success"": true,
                    ""error"": null
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""File to be uploaded."",
          ""required"": true,
          ""type"": ""file"",
          ""content"": {
            ""multipart/form-data"": {
              ""schema"": {
                ""type"": ""object"",
                ""properties"": {
                  ""file"": {
                    ""type"": ""string"",
                    ""format"": ""binary""
                  }
                }
              }
            }
          }
        }
      }
    },
    ""/v1/documents"": {
      ""get"": {
        ""tags"": [
          ""Documents""
        ],
        ""description"": ""List of all locally-stored documents in instance"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""localFiles"": {
                      ""name"": ""documents"",
                      ""type"": ""folder"",
                      ""items"": [
                        {
                          ""name"": ""my-stored-document.json"",
                          ""type"": ""file"",
                          ""id"": ""bb07c334-4dab-4419-9462-9d00065a49a1"",
                          ""url"": ""file://my-stored-document.txt"",
                          ""title"": ""my-stored-document.txt"",
                          ""cached"": false
                        }
                      ]
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/document/accepted-file-types"": {
      ""get"": {
        ""tags"": [
          ""Documents""
        ],
        ""description"": ""Check available filetypes and MIMEs that can be uploaded."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""types"": {
                      ""application/mbox"": [
                        "".mbox""
                      ],
                      ""application/pdf"": [
                        "".pdf""
                      ],
                      ""application/vnd.oasis.opendocument.text"": [
                        "".odt""
                      ],
                      ""application/vnd.openxmlformats-officedocument.wordprocessingml.document"": [
                        "".docx""
                      ],
                      ""text/plain"": [
                        "".txt"",
                        "".md""
                      ]
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""404"": {
            ""description"": ""Not Found""
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/new"": {
      ""post"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Create a new workspace"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""Sample workspace"",
                      ""slug"": ""sample-workspace"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null
                    },
                    ""message"": ""Workspace created""
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""JSON object containing new display name of workspace."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""name"": ""My New Workspace""
              }
            }
          }
        }
      }
    },
    ""/v1/workspaces"": {
      ""get"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""List all current workspaces"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspaces"": [
                      {
                        ""id"": 79,
                        ""name"": ""Sample workspace"",
                        ""slug"": ""sample-workspace"",
                        ""createdAt"": ""2023-08-17 00:45:03"",
                        ""openAiTemp"": null,
                        ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                        ""openAiHistory"": 20,
                        ""openAiPrompt"": null
                      }
                    ]
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/{slug}"": {
      ""get"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Get a workspace by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""My workspace"",
                      ""slug"": ""my-workspace-123"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null,
                      ""documents"": []
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      },
      ""delete"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Deletes a workspace by its slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to delete""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK""
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/{slug}/update"": {
      ""post"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Update workspace settings by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""My workspace"",
                      ""slug"": ""my-workspace-123"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null,
                      ""documents"": []
                    },
                    ""message"": null
                  }
                }
              }
            }
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""JSON object containing new settings to update a workspace. All keys are optional and will not update unless provided"",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""name"": ""Updated Workspace Name"",
                ""openAiTemp"": 0.2,
                ""openAiHistory"": 20,
                ""openAiPrompt"": ""Respond to all inquires and questions in binary - do not respond in any other format.""
              }
            }
          }
        }
      }
    },
    ""/v1/workspace/{slug}/chats"": {
      ""get"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Get a workspaces chats regardless of user by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""history"": [
                      {
                        ""role"": ""user"",
                        ""content"": ""What is AnythingLLM?"",
                        ""sentAt"": 1692851630
                      },
                      {
                        ""role"": ""assistant"",
                        ""content"": ""AnythingLLM is a platform that allows you to convert notes, PDFs, and other source materials into a chatbot. It ensures privacy, cites its answers, and allows multiple people to interact with the same documents simultaneously. It is particularly useful for businesses to enhance the visibility and readability of various written communications such as SOPs, contracts, and sales calls. You can try it out with a free trial to see if it meets your business needs."",
                        ""sources"": [
                          {
                            ""source"": ""object about source document and snippets used""
                          }
                        ]
                      }
                    ]
                  }
                }
              }
            }
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/workspace/{slug}/update-embeddings"": {
      ""post"": {
        ""tags"": [
          ""Workspaces""
        ],
        ""description"": ""Add or remove documents from a workspace by its unique slug."",
        ""parameters"": [
          {
            ""name"": ""slug"",
            ""in"": ""path"",
            ""required"": true,
            ""schema"": {
              ""type"": ""string""
            },
            ""description"": ""Unique slug of workspace to find""
          },
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""workspace"": {
                      ""id"": 79,
                      ""name"": ""My workspace"",
                      ""slug"": ""my-workspace-123"",
                      ""createdAt"": ""2023-08-17 00:45:03"",
                      ""openAiTemp"": null,
                      ""lastUpdatedAt"": ""2023-08-17 00:45:03"",
                      ""openAiHistory"": 20,
                      ""openAiPrompt"": null,
                      ""documents"": []
                    },
                    ""message"": null
                  }
                }
              }
            }
          },
          ""400"": {
            ""description"": ""Bad Request""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""JSON object of additions and removals of documents to add to update a workspace. The value should be the folder + filename with the exclusions of the top-level documents path."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""adds"": [],
                ""deletes"": [
                  ""custom-documents/anythingllm-hash.json""
                ]
              }
            }
          }
        }
      }
    },
    ""/v1/system/env-dump"": {
      ""get"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Dump all settings to file storage"",
        ""responses"": {
          ""200"": {
            ""description"": ""OK""
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/system"": {
      ""get"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Get all current system settings that are defined."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""settings"": {
                      ""VectorDB"": ""pinecone"",
                      ""PineConeEnvironment"": ""us-west4-gcp-free"",
                      ""PineConeKey"": true,
                      ""PineConeIndex"": ""my-pinecone-index"",
                      ""LLMProvider"": ""azure"",
                      ""[KEY_NAME]"": ""KEY_VALUE""
                    }
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/system/vector-count"": {
      ""get"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Number of all vectors in connected vector database"",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""vectorCount"": 5450
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        }
      }
    },
    ""/v1/system/update-env"": {
      ""post"": {
        ""tags"": [
          ""System Settings""
        ],
        ""description"": ""Update a system setting or preference."",
        ""parameters"": [
          {
            ""name"": ""Authorization"",
            ""in"": ""header"",
            ""schema"": {
              ""type"": ""string""
            }
          }
        ],
        ""responses"": {
          ""200"": {
            ""description"": ""OK"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""type"": ""object"",
                  ""example"": {
                    ""newValues"": {
                      ""[ENV_KEY]"": ""Value""
                    },
                    ""error"": ""error goes here, otherwise null""
                  }
                }
              }
            }
          },
          ""403"": {
            ""description"": ""Forbidden"",
            ""content"": {
              ""application/json"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              },
              ""application/xml"": {
                ""schema"": {
                  ""$ref"": ""#/components/schemas/InvalidAPIKey""
                }
              }
            }
          },
          ""500"": {
            ""description"": ""Internal Server Error""
          }
        },
        ""requestBody"": {
          ""description"": ""Key pair object that matches a valid setting and value. Get keys from GET /v1/system or refer to codebase."",
          ""required"": true,
          ""type"": ""object"",
          ""content"": {
            ""application/json"": {
              ""example"": {
                ""VectorDB"": ""lancedb"",
                ""AnotherKey"": ""updatedValue""
              }
            }
          }
        }
      }
    }
  },
  ""components"": {
    ""schemas"": {
      ""InvalidAPIKey"": {
        ""type"": ""object"",
        ""properties"": {
          ""message"": {
            ""type"": ""string"",
            ""example"": ""Invalid API Key""
          }
        },
        ""xml"": {
          ""name"": ""InvalidAPIKey""
        }
      }
    },
    ""securitySchemes"": {
      ""BearerAuth"": {
        ""type"": ""http"",
        ""scheme"": ""bearer"",
        ""bearerFormat"": ""JWT""
      }
    }
  },
  ""security"": [
    {
      ""BearerAuth"": []
    }
  ]
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"{ ""VAR"": ""3.0.0"", ""VAR"": { ""VAR"": ""1.0.0"", ""VAR"": ""VAR VAR VAR"", ""VAR"": ""VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR.VAR."" }, ""VAR"": [ { ""VAR"": ""VAR: } ], ""VAR"": { ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR VAR VAR VAR VAR."", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } } } } }, ""/VAR/VAR/VAR-VAR-VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR-VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR-VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"" } ] } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 1, ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"" }, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR | VAR"" } } } } } }, ""/VAR/VAR/VAR/{VAR}"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR-VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR | VAR"", ""VAR"": 0 } } } } }, ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": 1, ""VAR"": ""VAR"", ""VAR"": ""VAR-123"", ""VAR"": VAR } ] } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 1, ""VAR"": ""VAR"", ""VAR"": ""VAR-123"" }, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/{VAR}"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR (VAR-VAR) VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR/{VAR}/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": [ 1, 2, 4, 12 ] } } } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": 2 } } } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR-VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": VAR, ""VAR"": VAR, ""VAR"": 10 } } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } }, ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR-VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""401"": { ""VAR"": ""VAR VAR VAR VAR VAR-VAR VAR. VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": VAR, ""VAR"": VAR, ""VAR"": 5 } } } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": VAR, ""VAR"": VAR } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR-VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"" } } } } } } } }, ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR-VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": [ { ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR-4dab-4419-9462-9d00065a49a1"", ""VAR"": ""VAR: ""VAR"": ""VAR-VAR-VAR.VAR"", ""VAR"": VAR } ] } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR-VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"" ], ""VAR/VAR.VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR.VAR-VAR.VAR.VAR"": [ "".VAR"" ], ""VAR/VAR"": [ "".VAR"", "".VAR"" ] } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""404"": { ""VAR"": ""VAR VAR"" }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR }, ""VAR"": ""VAR VAR"" } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR VAR VAR"" } } } } } }, ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR } ] } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/{VAR}"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR-123"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR, ""VAR"": [] } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } }, ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"" }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/{VAR}/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR-123"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR, ""VAR"": [] }, ""VAR"": VAR } } } } }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR VAR VAR"", ""VAR"": 0.2, ""VAR"": 20, ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR - VAR VAR VAR VAR VAR VAR VAR."" } } } } } }, ""/VAR/VAR/{VAR}/VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR VAR VAR?"", ""VAR"": 1692851630 }, { ""VAR"": ""VAR"", ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR"" } ] } ] } } } } }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/{VAR}/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": VAR, ""VAR"": { ""VAR"": ""VAR"" }, ""VAR"": ""VAR VAR VAR VAR VAR VAR"" }, { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": 79, ""VAR"": ""VAR VAR"", ""VAR"": ""VAR-VAR-123"", ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": VAR, ""VAR"": ""2023-08-17 00:45:03"", ""VAR"": 20, ""VAR"": VAR, ""VAR"": [] }, ""VAR"": VAR } } } } }, ""400"": { ""VAR"": ""VAR VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR + VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": [], ""VAR"": [ ""VAR-VAR/VAR-VAR.VAR"" ] } } } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR"", ""VAR"": { ""200"": { ""VAR"": ""VAR"" }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR-VAR-VAR-VAR"", ""VAR"": VAR, ""VAR"": ""VAR-VAR-VAR"", ""VAR"": ""VAR"", ""[VAR]"": ""VAR"" } } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR"", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": 5450 } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } } } }, ""/VAR/VAR/VAR-VAR"": { ""VAR"": { ""VAR"": [ ""VAR VAR"" ], ""VAR"": ""VAR VAR VAR VAR VAR VAR."", ""VAR"": [ { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": { ""VAR"": ""VAR"" } } ], ""VAR"": { ""200"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""[VAR]"": ""VAR"" }, ""VAR"": ""VAR VAR VAR, VAR VAR"" } } } } }, ""403"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } }, ""VAR/VAR"": { ""VAR"": { ""$VAR"": "" } } } }, ""500"": { ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR /VAR/VAR VAR VAR VAR VAR."", ""VAR"": VAR, ""VAR"": ""VAR"", ""VAR"": { ""VAR/VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"" } } } } } } }, ""VAR"": { ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR VAR VAR"" } }, ""VAR"": { ""VAR"": ""VAR"" } } }, ""VAR"": { ""VAR"": { ""VAR"": ""VAR"", ""VAR"": ""VAR"", ""VAR"": ""VAR"" } } }, ""VAR"": [ { ""VAR"": [] } ] } ",8
cpython_4bfcffe16e9742c154f54ae96b5b36903500abaa,Litest/test_site.py,"    def _create_underpth_exe(self, lines, exe_pth=True):
        import _winapi
        dll_src_file = _winapi.GetModuleFileName(sys.dllhandle)
        dll_file = os.path.join(temp_dir, os.path.split(dll_src_file)[1])
        shutil.copy(dll_src_file, dll_file)
        if exe_pth:
            _pth_file = os.path.splitext(exe_file)[0] + '._pth'
        else:
            _pth_file = os.path.splitext(dll_file)[0] + '._pth'
    def test_underpth_dll_file(self):
        libpath = os.path.dirname(os.path.dirname(encodings.__file__))
        exe_prefix = os.path.dirname(sys.executable)
        exe_file = self._create_underpth_exe([
            'fake-path-name',
            *[libpath for _ in range(200)],
            '',
            '# comment',
            'import site'
        ], exe_pth=False)
        sys_prefix = os.path.dirname(exe_file)
        env = os.environ.copy()
        env['PYTHONPATH'] = 'from-env'
        env['PATH'] = '{};{}'.format(exe_prefix, os.getenv('PATH'))
        rc = subprocess.call([exe_file, '-c',
            'import sys; sys.exit(not sys.flags.no_site and '
            '%r in sys.path and %r in sys.path and %r not in sys.path and '
            'all(""\\r"" not in p and ""\\n"" not in p for p in sys.path))' % (
                os.path.join(sys_prefix, 'fake-path-name'),
                libpath,
                os.path.join(sys_prefix, 'from-env'),
            )], env=env)
        self.assertTrue(rc, ""sys.path is incorrect"")

","    def _create_underpth_exe(self, lines):
        _pth_file = os.path.splitext(exe_file)[0] + '._pth'",4bfcffe16e9742c154f54ae96b5b36903500abaa,CVE-2020-15801,4bfcffe16e9742c154f54ae96b5b36903500abaa,https://github.com/python/cpython,NVD_GIT_REPOBASED,120,COMPLETED,"VAR VAR(VAR, VAR, VAR=VAR): VAR VAR VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR.VAR(VAR, VAR.VAR.VAR(VAR)[1]) VAR.VAR(VAR, VAR) VAR VAR: VAR = VAR.VAR.VAR(VAR)[0] + '.VAR' VAR: VAR = VAR.VAR.VAR(VAR)[0] + '.VAR' VAR VAR(VAR): VAR = VAR.VAR.VAR(VAR.VAR.VAR(VAR.VAR)) VAR = VAR.VAR.VAR(VAR.VAR) VAR = VAR.VAR([ 'VAR-VAR-VAR', *[VAR VAR VAR VAR VAR(200)], '', ' 'VAR VAR' ], VAR=VAR) VAR = VAR.VAR.VAR(VAR) VAR = VAR.VAR.VAR() VAR['VAR'] = 'VAR-VAR' VAR['VAR'] = '{};{}'.VAR(VAR, VAR.VAR('VAR')) VAR = VAR.VAR([VAR, '-VAR', 'VAR VAR; VAR.VAR(VAR VAR.VAR.VAR VAR ' '%VAR VAR VAR.VAR VAR %VAR VAR VAR.VAR VAR %VAR VAR VAR VAR.VAR VAR ' 'VAR(""\\VAR"" VAR VAR VAR VAR ""\\VAR"" VAR VAR VAR VAR VAR VAR VAR.VAR))' % ( VAR.VAR.VAR(VAR, 'VAR-VAR-VAR'), VAR, VAR.VAR.VAR(VAR, 'VAR-VAR'), )], VAR=VAR) VAR.VAR(VAR, ""VAR.VAR VAR VAR"") VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(VAR)[0] + '.VAR'",8
cpython_83fc70159b24f5b11a5ef87c9b05c2cf4c7faeba,Litest/test_urllib.py,"    def test_url_path_with_control_char_rejected(self):
    def test_url_path_with_newline_header_injection_rejected(self):
    @unittest.skipUnless(ssl, ""ssl module required"")
    def test_url_host_with_control_char_rejected(self):
        for char_no in list(range(0, 0x21)) + [0x7f]:
            char = chr(char_no)
            schemeless_url = f""//localhost{char}/test/""
            self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
            try:
                escaped_char_repr = repr(char).replace('\\', r'\\')
                InvalidURL = http.client.InvalidURL
                with self.assertRaisesRegex(
                    InvalidURL, f""contain control.*{escaped_char_repr}""):
                    urlopen(f""http:{schemeless_url}"")
                with self.assertRaisesRegex(InvalidURL, f""contain control.*{escaped_char_repr}""):
                    urlopen(f""https:{schemeless_url}"")
            finally:
                self.unfakehttp()

    @unittest.skipUnless(ssl, ""ssl module required"")
    def test_url_host_with_newline_header_injection_rejected(self):
        self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
        host = ""localhost\r\nX-injected: header\r\n""
        schemeless_url = ""//"" + host + "":8080/test/?test=a""
        try:
            InvalidURL = http.client.InvalidURL
            with self.assertRaisesRegex(
                InvalidURL, r""contain control.*\\r""):
                urlopen(f""http:{schemeless_url}"")
            with self.assertRaisesRegex(InvalidURL, r""contain control.*\\n""):
                urlopen(f""https:{schemeless_url}"")
        finally:
            self.unfakehttp()
","    def test_url_with_control_char_rejected(self):
    def test_url_with_newline_header_injection_rejected(self):",83fc70159b24f5b11a5ef87c9b05c2cf4c7faeba,CVE-2019-18348,83fc70159b24f5b11a5ef87c9b05c2cf4c7faeba,https://github.com/python/cpython,CPE_GIT_REPOBASED,150,COMPLETED,"VAR VAR(VAR): VAR VAR(VAR): @VAR.VAR(VAR, ""VAR VAR VAR"") VAR VAR(VAR): VAR VAR VAR VAR(VAR(0, 0x21)) + [0x7f]: VAR = VAR(VAR) VAR = VAR"" VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR: VAR = VAR(VAR).VAR('\\', VAR'\\') VAR = VAR.VAR.VAR VAR VAR.VAR( VAR, VAR""VAR VAR.*{VAR}""): VAR(VAR""VAR:{VAR}"") VAR VAR.VAR(VAR, VAR""VAR VAR.*{VAR}""): VAR(VAR""VAR:{VAR}"") VAR: VAR.VAR() @VAR.VAR(VAR, ""VAR VAR VAR"") VAR VAR(VAR): VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR = ""VAR\VAR\VAR-VAR: VAR\VAR\VAR"" VAR = "" VAR: VAR = VAR.VAR.VAR VAR VAR.VAR( VAR, VAR""VAR VAR.*\\VAR""): VAR(VAR""VAR:{VAR}"") VAR VAR.VAR(VAR, VAR""VAR VAR.*\\VAR""): VAR(VAR""VAR:{VAR}"") VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR):",8
cpython_bb8071a4cae5ab3fe321481dd3d73662ffb26052,Litest/test_urllib.py,"    def test_url_with_control_char_rejected(self):
        for char_no in range(0, 0x21) + range(0x7f, 0x100):
            char = chr(char_no)
            schemeless_url = ""//localhost:7777/test%s/"" % char
            self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
            try:
                # urllib quotes the URL so there is no injection.
                resp = urllib.urlopen(""http:"" + schemeless_url)
                self.assertNotIn(char, resp.geturl())
            finally:
                self.unfakehttp()

    def test_url_with_newline_header_injection_rejected(self):
        self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
        host = ""localhost:7777?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123""
        schemeless_url = ""//"" + host + "":8080/test/?test=a""
        try:
            # urllib quotes the URL so there is no injection.
            resp = urllib.urlopen(""http:"" + schemeless_url)
            self.assertNotIn(' ', resp.geturl())
            self.assertNotIn('\r', resp.geturl())
            self.assertNotIn('\n', resp.geturl())
        finally:
            self.unfakehttp()
",,bb8071a4cae5ab3fe321481dd3d73662ffb26052,CVE-2019-9947,bb8071a4cae5ab3fe321481dd3d73662ffb26052,https://github.com/python/cpython,CPE_GIT_REPOBASED,96,COMPLETED,"VAR VAR(VAR): VAR VAR VAR VAR(0, 0x21) + VAR(0x7f, 0x100): VAR = VAR(VAR) VAR = "" VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR:  VAR = VAR.VAR(""VAR:"" + VAR) VAR.VAR(VAR, VAR.VAR()) VAR: VAR.VAR() VAR VAR(VAR): VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR = ""VAR:7777?VAR=1 VAR/1.1\VAR\VAR-VAR: VAR\VAR\VAR: 123"" VAR = "" VAR:  VAR = VAR.VAR(""VAR:"" + VAR) VAR.VAR(' ', VAR.VAR()) VAR.VAR('\VAR', VAR.VAR()) VAR.VAR('\VAR', VAR.VAR()) VAR: VAR.VAR() ",8
cpython_bb8071a4cae5ab3fe321481dd3d73662ffb26052,Litest/test_urllib.py,"    def test_url_with_control_char_rejected(self):
        for char_no in range(0, 0x21) + range(0x7f, 0x100):
            char = chr(char_no)
            schemeless_url = ""//localhost:7777/test%s/"" % char
            self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
            try:
                # urllib quotes the URL so there is no injection.
                resp = urllib.urlopen(""http:"" + schemeless_url)
                self.assertNotIn(char, resp.geturl())
            finally:
                self.unfakehttp()

    def test_url_with_newline_header_injection_rejected(self):
        self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
        host = ""localhost:7777?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123""
        schemeless_url = ""//"" + host + "":8080/test/?test=a""
        try:
            # urllib quotes the URL so there is no injection.
            resp = urllib.urlopen(""http:"" + schemeless_url)
            self.assertNotIn(' ', resp.geturl())
            self.assertNotIn('\r', resp.geturl())
            self.assertNotIn('\n', resp.geturl())
        finally:
            self.unfakehttp()
",,bb8071a4cae5ab3fe321481dd3d73662ffb26052,CVE-2019-9740,bb8071a4cae5ab3fe321481dd3d73662ffb26052,https://github.com/python/cpython,CPE_GIT_REPOBASED,96,COMPLETED,"VAR VAR(VAR): VAR VAR VAR VAR(0, 0x21) + VAR(0x7f, 0x100): VAR = VAR(VAR) VAR = "" VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR:  VAR = VAR.VAR(""VAR:"" + VAR) VAR.VAR(VAR, VAR.VAR()) VAR: VAR.VAR() VAR VAR(VAR): VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR = ""VAR:7777?VAR=1 VAR/1.1\VAR\VAR-VAR: VAR\VAR\VAR: 123"" VAR = "" VAR:  VAR = VAR.VAR(""VAR:"" + VAR) VAR.VAR(' ', VAR.VAR()) VAR.VAR('\VAR', VAR.VAR()) VAR.VAR('\VAR', VAR.VAR()) VAR: VAR.VAR() ",8
cpython_bb8071a4cae5ab3fe321481dd3d73662ffb26052,Litest/test_urllib2.py,"from test.test_urllib import FakeHTTPMixin


class MiscTests(unittest.TestCase, FakeHTTPMixin):
    @unittest.skipUnless(ssl, ""ssl module required"")
    def test_url_with_control_char_rejected(self):
        for char_no in range(0, 0x21) + range(0x7f, 0x100):
            char = chr(char_no)
            schemeless_url = ""//localhost:7777/test%s/"" % char
            self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
            try:
                # We explicitly test urllib.request.urlopen() instead of the top
                # level 'def urlopen()' function defined in this... (quite ugly)
                # test suite.  They use different url opening codepaths.  Plain
                # urlopen uses FancyURLOpener which goes via a codepath that
                # calls urllib.parse.quote() on the URL which makes all of the
                # above attempts at injection within the url _path_ safe.
                escaped_char_repr = repr(char).replace('\\', r'\\')
                InvalidURL = httplib.InvalidURL
                with self.assertRaisesRegexp(
                    InvalidURL, ""contain control.*"" + escaped_char_repr):
                    urllib2.urlopen(""http:"" + schemeless_url)
                with self.assertRaisesRegexp(
                    InvalidURL, ""contain control.*"" + escaped_char_repr):
                    urllib2.urlopen(""https:"" + schemeless_url)
            finally:
                self.unfakehttp()

    @unittest.skipUnless(ssl, ""ssl module required"")
    def test_url_with_newline_header_injection_rejected(self):
        self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
        host = ""localhost:7777?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123""
        schemeless_url = ""//"" + host + "":8080/test/?test=a""
        try:
            # We explicitly test urllib2.urlopen() instead of the top
            # level 'def urlopen()' function defined in this... (quite ugly)
            # test suite.  They use different url opening codepaths.  Plain
            # urlopen uses FancyURLOpener which goes via a codepath that
            # calls urllib.parse.quote() on the URL which makes all of the
            # above attempts at injection within the url _path_ safe.
            InvalidURL = httplib.InvalidURL
            with self.assertRaisesRegexp(
                InvalidURL, r""contain control.*\\r.*(found at least . .)""):
                urllib2.urlopen(""http:"" + schemeless_url)
            with self.assertRaisesRegexp(InvalidURL, r""contain control.*\\n""):
                urllib2.urlopen(""https:"" + schemeless_url)
        finally:
            self.unfakehttp()

",class MiscTests(unittest.TestCase):,bb8071a4cae5ab3fe321481dd3d73662ffb26052,CVE-2019-9947,bb8071a4cae5ab3fe321481dd3d73662ffb26052,https://github.com/python/cpython,CPE_GIT_REPOBASED,96,COMPLETED,"VAR VAR.VAR VAR VAR VAR VAR(VAR.VAR, VAR): @VAR.VAR(VAR, ""VAR VAR VAR"") VAR VAR(VAR): VAR VAR VAR VAR(0, 0x21) + VAR(0x7f, 0x100): VAR = VAR(VAR) VAR = "" VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR:       VAR = VAR(VAR).VAR('\\', VAR'\\') VAR = VAR.VAR VAR VAR.VAR( VAR, ""VAR VAR.*"" + VAR): VAR.VAR(""VAR:"" + VAR) VAR VAR.VAR( VAR, ""VAR VAR.*"" + VAR): VAR.VAR(""VAR:"" + VAR) VAR: VAR.VAR() @VAR.VAR(VAR, ""VAR VAR VAR"") VAR VAR(VAR): VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR = ""VAR:7777?VAR=1 VAR/1.1\VAR\VAR-VAR: VAR\VAR\VAR: 123"" VAR = "" VAR:       VAR = VAR.VAR VAR VAR.VAR( VAR, VAR""VAR VAR.*\\VAR.*(VAR VAR VAR . .)""): VAR.VAR(""VAR:"" + VAR) VAR VAR.VAR(VAR, VAR""VAR VAR.*\\VAR""): VAR.VAR(""VAR:"" + VAR) VAR: VAR.VAR() VAR VAR(VAR.VAR):",8
cpython_bb8071a4cae5ab3fe321481dd3d73662ffb26052,Litest/test_urllib2.py,"from test.test_urllib import FakeHTTPMixin


class MiscTests(unittest.TestCase, FakeHTTPMixin):
    @unittest.skipUnless(ssl, ""ssl module required"")
    def test_url_with_control_char_rejected(self):
        for char_no in range(0, 0x21) + range(0x7f, 0x100):
            char = chr(char_no)
            schemeless_url = ""//localhost:7777/test%s/"" % char
            self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
            try:
                # We explicitly test urllib.request.urlopen() instead of the top
                # level 'def urlopen()' function defined in this... (quite ugly)
                # test suite.  They use different url opening codepaths.  Plain
                # urlopen uses FancyURLOpener which goes via a codepath that
                # calls urllib.parse.quote() on the URL which makes all of the
                # above attempts at injection within the url _path_ safe.
                escaped_char_repr = repr(char).replace('\\', r'\\')
                InvalidURL = httplib.InvalidURL
                with self.assertRaisesRegexp(
                    InvalidURL, ""contain control.*"" + escaped_char_repr):
                    urllib2.urlopen(""http:"" + schemeless_url)
                with self.assertRaisesRegexp(
                    InvalidURL, ""contain control.*"" + escaped_char_repr):
                    urllib2.urlopen(""https:"" + schemeless_url)
            finally:
                self.unfakehttp()

    @unittest.skipUnless(ssl, ""ssl module required"")
    def test_url_with_newline_header_injection_rejected(self):
        self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
        host = ""localhost:7777?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123""
        schemeless_url = ""//"" + host + "":8080/test/?test=a""
        try:
            # We explicitly test urllib2.urlopen() instead of the top
            # level 'def urlopen()' function defined in this... (quite ugly)
            # test suite.  They use different url opening codepaths.  Plain
            # urlopen uses FancyURLOpener which goes via a codepath that
            # calls urllib.parse.quote() on the URL which makes all of the
            # above attempts at injection within the url _path_ safe.
            InvalidURL = httplib.InvalidURL
            with self.assertRaisesRegexp(
                InvalidURL, r""contain control.*\\r.*(found at least . .)""):
                urllib2.urlopen(""http:"" + schemeless_url)
            with self.assertRaisesRegexp(InvalidURL, r""contain control.*\\n""):
                urllib2.urlopen(""https:"" + schemeless_url)
        finally:
            self.unfakehttp()

",class MiscTests(unittest.TestCase):,bb8071a4cae5ab3fe321481dd3d73662ffb26052,CVE-2019-9740,bb8071a4cae5ab3fe321481dd3d73662ffb26052,https://github.com/python/cpython,CPE_GIT_REPOBASED,96,COMPLETED,"VAR VAR.VAR VAR VAR VAR VAR(VAR.VAR, VAR): @VAR.VAR(VAR, ""VAR VAR VAR"") VAR VAR(VAR): VAR VAR VAR VAR(0, 0x21) + VAR(0x7f, 0x100): VAR = VAR(VAR) VAR = "" VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR:       VAR = VAR(VAR).VAR('\\', VAR'\\') VAR = VAR.VAR VAR VAR.VAR( VAR, ""VAR VAR.*"" + VAR): VAR.VAR(""VAR:"" + VAR) VAR VAR.VAR( VAR, ""VAR VAR.*"" + VAR): VAR.VAR(""VAR:"" + VAR) VAR: VAR.VAR() @VAR.VAR(VAR, ""VAR VAR VAR"") VAR VAR(VAR): VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR = ""VAR:7777?VAR=1 VAR/1.1\VAR\VAR-VAR: VAR\VAR\VAR: 123"" VAR = "" VAR:       VAR = VAR.VAR VAR VAR.VAR( VAR, VAR""VAR VAR.*\\VAR.*(VAR VAR VAR . .)""): VAR.VAR(""VAR:"" + VAR) VAR VAR.VAR(VAR, VAR""VAR VAR.*\\VAR""): VAR.VAR(""VAR:"" + VAR) VAR: VAR.VAR() VAR VAR(VAR.VAR):",8
cpython_c50d437e942d4c4c45c8cd76329b05340c02eb31,Litest/test_urllib.py,"    @unittest.skipUnless(ssl, ""ssl module required"")
    def test_url_with_control_char_rejected(self):
        for char_no in list(range(0, 0x21)) + [0x7f]:
            char = chr(char_no)
            schemeless_url = f""//localhost:7777/test{char}/""
            self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
            try:
                # We explicitly test urllib.request.urlopen() instead of the top
                # level 'def urlopen()' function defined in this... (quite ugly)
                # test suite.  They use different url opening codepaths.  Plain
                # urlopen uses FancyURLOpener which goes via a codepath that
                # calls urllib.parse.quote() on the URL which makes all of the
                # above attempts at injection within the url _path_ safe.
                escaped_char_repr = repr(char).replace('\\', r'\\')
                InvalidURL = http.client.InvalidURL
                with self.assertRaisesRegex(
                    InvalidURL, f""contain control.*{escaped_char_repr}""):
                    urllib.request.urlopen(f""http:{schemeless_url}"")
                with self.assertRaisesRegex(
                    InvalidURL, f""contain control.*{escaped_char_repr}""):
                    urllib.request.urlopen(f""https:{schemeless_url}"")
                # This code path quotes the URL so there is no injection.
                resp = urlopen(f""http:{schemeless_url}"")
                self.assertNotIn(char, resp.geturl())
            finally:
                self.unfakehttp()

    @unittest.skipUnless(ssl, ""ssl module required"")
    def test_url_with_newline_header_injection_rejected(self):
        self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
        host = ""localhost:7777?a=1 HTTP/1.1\r\nX-injected: header\r\nTEST: 123""
        schemeless_url = ""//"" + host + "":8080/test/?test=a""
        try:
            # We explicitly test urllib.request.urlopen() instead of the top
            # level 'def urlopen()' function defined in this... (quite ugly)
            # test suite.  They use different url opening codepaths.  Plain
            # urlopen uses FancyURLOpener which goes via a codepath that
            # calls urllib.parse.quote() on the URL which makes all of the
            # above attempts at injection within the url _path_ safe.
            InvalidURL = http.client.InvalidURL
            with self.assertRaisesRegex(
                InvalidURL, r""contain control.*\\r.*(found at least . .)""):
                urllib.request.urlopen(f""http:{schemeless_url}"")
            with self.assertRaisesRegex(InvalidURL, r""contain control.*\\n""):
                urllib.request.urlopen(f""https:{schemeless_url}"")
            # This code path quotes the URL so there is no injection.
            resp = urlopen(f""http:{schemeless_url}"")
            self.assertNotIn(' ', resp.geturl())
            self.assertNotIn('\r', resp.geturl())
            self.assertNotIn('\n', resp.geturl())
        finally:
            self.unfakehttp()
",,c50d437e942d4c4c45c8cd76329b05340c02eb31,CVE-2019-9947,c50d437e942d4c4c45c8cd76329b05340c02eb31,https://github.com/python/cpython,CPE_GIT_REPOBASED,98,COMPLETED,"@VAR.VAR(VAR, ""VAR VAR VAR"") VAR VAR(VAR): VAR VAR VAR VAR(VAR(0, 0x21)) + [0x7f]: VAR = VAR(VAR) VAR = VAR"" VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR:       VAR = VAR(VAR).VAR('\\', VAR'\\') VAR = VAR.VAR.VAR VAR VAR.VAR( VAR, VAR""VAR VAR.*{VAR}""): VAR.VAR.VAR(VAR""VAR:{VAR}"") VAR VAR.VAR( VAR, VAR""VAR VAR.*{VAR}""): VAR.VAR.VAR(VAR""VAR:{VAR}"")  VAR = VAR(VAR""VAR:{VAR}"") VAR.VAR(VAR, VAR.VAR()) VAR: VAR.VAR() @VAR.VAR(VAR, ""VAR VAR VAR"") VAR VAR(VAR): VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR = ""VAR:7777?VAR=1 VAR/1.1\VAR\VAR-VAR: VAR\VAR\VAR: 123"" VAR = "" VAR:       VAR = VAR.VAR.VAR VAR VAR.VAR( VAR, VAR""VAR VAR.*\\VAR.*(VAR VAR VAR . .)""): VAR.VAR.VAR(VAR""VAR:{VAR}"") VAR VAR.VAR(VAR, VAR""VAR VAR.*\\VAR""): VAR.VAR.VAR(VAR""VAR:{VAR}"")  VAR = VAR(VAR""VAR:{VAR}"") VAR.VAR(' ', VAR.VAR()) VAR.VAR('\VAR', VAR.VAR()) VAR.VAR('\VAR', VAR.VAR()) VAR: VAR.VAR() ",8
cpython_e176e0c105786e9f476758eb5438c57223b65e7f,Litest/test_urllib2.py,"    def test_url_path_with_control_char_rejected(self):
    def test_url_path_with_newline_header_injection_rejected(self):
            with self.assertRaisesRegexp(InvalidURL,
                    r""contain control.*\\r.*(found at least . .)""):
                urllib2.urlopen(""http:{}"".format(schemeless_url))
            with self.assertRaisesRegexp(InvalidURL,
                    r""contain control.*\\n""):
                urllib2.urlopen(""https:{}"".format(schemeless_url))
    @unittest.skipUnless(ssl, ""ssl module required"")
    def test_url_host_with_control_char_rejected(self):
        for char_no in list(range(0, 0x21)) + [0x7f]:
            char = chr(char_no)
            schemeless_url = ""//localhost{}/test/"".format(char)
            self.fakehttp(b""HTTP/1.1 200 OK\r\n\r\nHello."")
            try:
                escaped_char_repr = repr(char).replace('\\', r'\\')
                InvalidURL = httplib.InvalidURL
                with self.assertRaisesRegexp(InvalidURL,
                    ""contain control.*{}"".format(escaped_char_repr)):
                        urllib2.urlopen(""http:{}"".format(schemeless_url))
                with self.assertRaisesRegexp(InvalidURL,
                    ""contain control.*{}"".format(escaped_char_repr)):
                        urllib2.urlopen(""https:{}"".format(schemeless_url))
            finally:
                self.unfakehttp()","    def test_url_with_control_char_rejected(self):
    def test_url_with_newline_header_injection_rejected(self):
            with self.assertRaisesRegexp(
                InvalidURL, r""contain control.*\\r.*(found at least . .)""):
                urllib2.urlopen(""http:"" + schemeless_url)
            with self.assertRaisesRegexp(InvalidURL, r""contain control.*\\n""):
                urllib2.urlopen(""https:"" + schemeless_url)",e176e0c105786e9f476758eb5438c57223b65e7f,CVE-2019-18348,e176e0c105786e9f476758eb5438c57223b65e7f,https://github.com/python/cpython,CPE_GIT_REPOBASED,148,COMPLETED,"VAR VAR(VAR): VAR VAR(VAR): VAR VAR.VAR(VAR, VAR""VAR VAR.*\\VAR.*(VAR VAR VAR . .)""): VAR.VAR(""VAR:{}"".VAR(VAR)) VAR VAR.VAR(VAR, VAR""VAR VAR.*\\VAR""): VAR.VAR(""VAR:{}"".VAR(VAR)) @VAR.VAR(VAR, ""VAR VAR VAR"") VAR VAR(VAR): VAR VAR VAR VAR(VAR(0, 0x21)) + [0x7f]: VAR = VAR(VAR) VAR = "" VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR."") VAR: VAR = VAR(VAR).VAR('\\', VAR'\\') VAR = VAR.VAR VAR VAR.VAR(VAR, ""VAR VAR.*{}"".VAR(VAR)): VAR.VAR(""VAR:{}"".VAR(VAR)) VAR VAR.VAR(VAR, ""VAR VAR.*{}"".VAR(VAR)): VAR.VAR(""VAR:{}"".VAR(VAR)) VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR VAR.VAR( VAR, VAR""VAR VAR.*\\VAR.*(VAR VAR VAR . .)""): VAR.VAR(""VAR:"" + VAR) VAR VAR.VAR(VAR, VAR""VAR VAR.*\\VAR""): VAR.VAR(""VAR:"" + VAR)",8
directus_ff53d3e69a602d05342e15d9bb616884833ddbff,api/src/operations/request/index.test.ts,"vi.mock('../../request', () => ({
	getAxios: () =>
		axiosDefault.mockResolvedValue({
			status: 200,
			statusText: 'OK',
			headers: {},
			data: {},
		}),","vi.mock('axios', () => ({
	default: axiosDefault.mockResolvedValue({
		status: 200,
		statusText: 'OK',
		headers: {},
		data: {},
	}),",ff53d3e69a602d05342e15d9bb616884833ddbff,CVE-2023-26492,ff53d3e69a602d05342e15d9bb616884833ddbff,https://github.com/directus/directus,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR.VAR('../../VAR', () => ({ VAR: () => VAR.VAR({ VAR: 200, VAR: 'VAR', VAR: {}, VAR: {}, }), VAR.VAR('VAR', () => ({ VAR: VAR.VAR({ VAR: 200, VAR: 'VAR', VAR: {}, VAR: {}, }),",8
discourse_0ce38bd7bce862db251b882613ab7053ca777382,spec/requests/posts_controller_spec.rb,"
      it ""creates unlisted topic with admin master key"" do
        master_key = Fabricate(:api_key).key

        expect do
          post ""/posts.json"",
            params: { raw: ""this is a test title"", title: ""this is test body"", unlist_topic: true },
            headers: { HTTP_API_USERNAME: admin.username, HTTP_API_KEY: master_key }
        end.to change { Topic.count }.by(1)

        expect(response.status).to eq(200)
        expect(Topic.find(response.parsed_body[""topic_id""]).visible).to eq(false)
      end

      it ""prevents creation of unlisted topic with non-admin key"" do
        user_key = ApiKey.create!(user: user).key

        expect do
          post ""/posts.json"",
            params: { raw: ""this is a test title"", title: ""this is test body"", unlist_topic: true },
            headers: { HTTP_API_USERNAME: user.username, HTTP_API_KEY: user_key }
        end.not_to change { Topic.count }

        expect(response.status).to eq(422)
        expect(response.parsed_body[""errors""]).to include(
          I18n.t(""activerecord.errors.models.topic.attributes.base.unable_to_unlist"")
        )
      end
        expect(topic.visible).to eq(true)
    context ""with topic unlisting"" do
      context ""when logged in as staff"" do
        before do
          sign_in(admin)
        end

        it ""creates an unlisted topic"" do
          expect do
            post ""/posts.json"", params: {
              raw: ""this is the test content"",
              title: ""this is the test title for the topic"",
              unlist_topic: true
            }
          end.to change { Topic.count }.by(1)

          expect(response.status).to eq(200)
          expect(Topic.find(response.parsed_body[""topic_id""]).visible).to eq(false)
        end
      end

      context ""when logged in as a non-staff user"" do
        before do
          sign_in(user)
        end

        it ""prevents creation of an unlisted topic"" do
          expect do
            post ""/posts.json"", params: {
              raw: ""this is the test content"",
              title: ""this is the test title for the topic"",
              unlist_topic: true
            }
          end.not_to change { Topic.count }

          expect(response.status).to eq(422)
          expect(response.parsed_body[""errors""]).to include(
            I18n.t(""activerecord.errors.models.topic.attributes.base.unable_to_unlist"")
          )
        end
      end
    end
",,0ce38bd7bce862db251b882613ab7053ca777382,CVE-2022-46159,0ce38bd7bce862db251b882613ab7053ca777382,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ""VAR VAR VAR VAR VAR VAR VAR"" VAR VAR = VAR(:VAR).VAR VAR VAR VAR ""/VAR.VAR"", VAR: { VAR: ""VAR VAR VAR VAR VAR"", VAR: ""VAR VAR VAR VAR"", VAR: VAR }, VAR: { VAR: VAR.VAR, VAR: VAR } VAR.VAR VAR { VAR.VAR }.VAR(1) VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR(VAR.VAR[""VAR""]).VAR).VAR VAR(VAR) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR-VAR VAR"" VAR VAR = VAR.VAR!(VAR: VAR).VAR VAR VAR VAR ""/VAR.VAR"", VAR: { VAR: ""VAR VAR VAR VAR VAR"", VAR: ""VAR VAR VAR VAR"", VAR: VAR }, VAR: { VAR: VAR.VAR, VAR: VAR } VAR.VAR VAR { VAR.VAR } VAR(VAR.VAR).VAR VAR(422) VAR(VAR.VAR[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR.VAR.VAR.VAR.VAR.VAR"") ) VAR VAR(VAR.VAR).VAR VAR(VAR) VAR ""VAR VAR VAR"" VAR VAR ""VAR VAR VAR VAR VAR"" VAR VAR VAR VAR(VAR) VAR VAR ""VAR VAR VAR VAR"" VAR VAR VAR VAR ""/VAR.VAR"", VAR: { VAR: ""VAR VAR VAR VAR VAR"", VAR: ""VAR VAR VAR VAR VAR VAR VAR VAR"", VAR: VAR } VAR.VAR VAR { VAR.VAR }.VAR(1) VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR(VAR.VAR[""VAR""]).VAR).VAR VAR(VAR) VAR VAR VAR ""VAR VAR VAR VAR VAR VAR-VAR VAR"" VAR VAR VAR VAR(VAR) VAR VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR VAR VAR ""/VAR.VAR"", VAR: { VAR: ""VAR VAR VAR VAR VAR"", VAR: ""VAR VAR VAR VAR VAR VAR VAR VAR"", VAR: VAR } VAR.VAR VAR { VAR.VAR } VAR(VAR.VAR).VAR VAR(422) VAR(VAR.VAR[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR.VAR.VAR.VAR.VAR.VAR"") ) VAR VAR VAR ",8
discourse_3c5fb871c0f54af47679ae71ad449666b01d8216,plugins/chat/spec/requests/core_ext/users_controller_spec.rb,"
  describe ""#user_menu_bookmarks"" do
    fab!(:chatters) { Fabricate(:group) }
    let(:current_user) { Fabricate(:user, group_ids: [chatters.id]) }
    let(:bookmark_message) { Fabricate(:chat_message) }
    let(:bookmark_user) { current_user }

    before do
      register_test_bookmarkable(Chat::MessageBookmarkable)
      SiteSetting.chat_allowed_groups = [chatters]
      sign_in(current_user)
    end

    it ""does not return any unread notifications for chat bookmarks that the user no longer has access to"" do
      bookmark_with_reminder =
        Fabricate(:bookmark, user: current_user, bookmarkable: bookmark_message)
      BookmarkReminderNotificationHandler.new(bookmark_with_reminder).send_notification

      bookmark_with_reminder.bookmarkable.update!(
        chat_channel: Fabricate(:private_category_channel),
      )

      get ""/u/#{current_user.username}/user-menu-bookmarks""
      expect(response.status).to eq(200)

      notifications = response.parsed_body[""notifications""]
      expect(notifications.size).to eq(0)
    end
  end",,3c5fb871c0f54af47679ae71ad449666b01d8216,CVE-2023-45816,3c5fb871c0f54af47679ae71ad449666b01d8216,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR "" VAR!(:VAR) { VAR(:VAR) } VAR(:VAR) { VAR(:VAR, VAR: [VAR.VAR]) } VAR(:VAR) { VAR(:VAR) } VAR(:VAR) { VAR } VAR VAR VAR(VAR::VAR) VAR.VAR = [VAR] VAR(VAR) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR = VAR(:VAR, VAR: VAR, VAR: VAR) VAR.VAR(VAR).VAR VAR.VAR.VAR!( VAR: VAR(:VAR), ) VAR ""/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR = VAR.VAR[""VAR""] VAR(VAR.VAR).VAR VAR(0) VAR VAR ",8
discourse_3c5fb871c0f54af47679ae71ad449666b01d8216,spec/requests/users_controller_spec.rb,"        expect(notifications.size).to eq(0)

      it ""does not return any unread notifications for bookmarks that the user no longer has access to"" do
        bookmark_with_reminder2 = Fabricate(:bookmark, user: user, bookmarkable: Fabricate(:post))
        TopicUser.change(user.id, bookmark_with_reminder2.bookmarkable.topic, total_msecs_viewed: 1)
        BookmarkReminderNotificationHandler.new(bookmark_with_reminder2).send_notification

        bookmark_with_reminder2.bookmarkable.topic.update!(
          archetype: Archetype.private_message,
          category: nil,
        )

        get ""/u/#{user.username}/user-menu-bookmarks""
        expect(response.status).to eq(200)

        notifications = response.parsed_body[""notifications""]
        expect(notifications.size).to eq(1)
        expect(notifications.first[""data""][""bookmark_id""]).to eq(bookmark_with_reminder.id)
      end","        expect(notifications.size).to eq(1)
        expect(notifications.first[""data""][""bookmark_id""]).to be_nil",3c5fb871c0f54af47679ae71ad449666b01d8216,CVE-2023-45816,3c5fb871c0f54af47679ae71ad449666b01d8216,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR(VAR.VAR).VAR VAR(0) VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR = VAR(:VAR, VAR: VAR, VAR: VAR(:VAR)) VAR.VAR(VAR.VAR, VAR.VAR.VAR, VAR: 1) VAR.VAR(VAR).VAR VAR.VAR.VAR.VAR!( VAR: VAR.VAR, VAR: VAR, ) VAR ""/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR = VAR.VAR[""VAR""] VAR(VAR.VAR).VAR VAR(1) VAR(VAR.VAR[""VAR""][""VAR""]).VAR VAR(VAR.VAR) VAR VAR(VAR.VAR).VAR VAR(1) VAR(VAR.VAR[""VAR""][""VAR""]).VAR VAR",8
discourse_52387be4a44cdeaca5421ee955ba1343e836bade,spec/requests/session_controller_spec.rb,"  describe '#email_login_info' do
    context 'valid token' do
      it 'returns information' do
        get ""/session/email-login/#{email_token.token}.json""

        expect(JSON.parse(response.body)[""can_login""]).to eq(true)
        expect(JSON.parse(response.body)[""second_factor_required""]).to eq(nil)

        # Does not log in the user
        expect(session[:current_user_id]).to be_nil
      end

      it 'fails when local logins via email is disabled' do
        SiteSetting.enable_local_logins_via_email = false

        get ""/session/email-login/#{email_token.token}.json""

        expect(response.status).to eq(404)
      end

      it 'fails when local logins is disabled' do
        SiteSetting.enable_local_logins = false

        get ""/session/email-login/#{email_token.token}.json""

        expect(response.status).to eq(500)
      end

      context 'user has 2-factor logins' do
        let!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user) }
        let!(:user_second_factor_backup) { Fabricate(:user_second_factor_backup, user: user) }

        it ""includes that information in the response"" do
          get ""/session/email-login/#{email_token.token}.json""

          expect(JSON.parse(response.body)[""can_login""]).to eq(true)
          expect(JSON.parse(response.body)[""second_factor_required""]).to eq(true)
          expect(JSON.parse(response.body)[""backup_codes_enabled""]).to eq(true)
        end
      end
    end
  end

  describe '#email_login' do
    before do
      SiteSetting.enable_local_logins_via_email = true
    end

    context 'missing token' do
      it 'returns the right response' do
        post ""/session/email-login""
        expect(response.status).to eq(404)
      end
    end

        post ""/session/email-login/adasdad.json""
        expect(JSON.parse(response.body)[""error""]).to eq(
          post ""/session/email-login/#{email_token.token}.json""
          expect(JSON.parse(response.body)[""error""]).to eq(
        post ""/session/email-login/#{email_token.token}.json""
        expect(JSON.parse(response.body)[""success""]).to eq(""OK"")
        expect(session[:current_user_id]).to eq(user.id)
        post ""/session/email-login/#{email_token.token}.json""
        expect(session[:current_user_id]).to eq(nil)
        post ""/session/email-login/#{email_token.token}.json""
        expect(session[:current_user_id]).to eq(nil)
        post ""/session/email-login/#{email_token.token}.json""
        expect(JSON.parse(response.body)[""error""]).to eq(I18n.t(""login.not_approved""))
        expect(session[:current_user_id]).to eq(nil)
          post ""/session/email-login/#{email_token.token}.json""
          expect(JSON.parse(response.body)[""error""]).to eq(
          expect(session[:current_user_id]).to eq(nil)
          post ""/session/email-login/#{email_token.token}.json""
          expect(JSON.parse(response.body)[""error""]).to eq(
          expect(session[:current_user_id]).to eq(nil)
        post ""/session/email-login/#{email_token.token}.json""
        expect(JSON.parse(response.body)[""error""]).to eq(
          I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only)
        expect(session[:current_user_id]).to eq(nil)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""error""]).to eq(
                I18n.t(""login.invalid_second_factor_code"")
              )
              expect(session[:current_user_id]).to eq(nil)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""error""]).to eq(
                I18n.t(""login.invalid_second_factor_code"")
              )
              expect(session[:current_user_id]).to eq(nil)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""success""]).to eq(""OK"")
              expect(session[:current_user_id]).to eq(user.id)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""success""]).to eq(""OK"")
              expect(session[:current_user_id]).to eq(user.id)","  describe '#email_login' do
        get ""/session/email-login/adasdad""

        expect(CGI.unescapeHTML(response.body)).to match(
          get ""/session/email-login/#{email_token.token}""
          expect(CGI.unescapeHTML(response.body)).to match(
        get ""/session/email-login/#{email_token.token}""
        expect(response).to redirect_to(""/"")
        get ""/session/email-login/#{email_token.token}""
        get ""/session/email-login/#{email_token.token}""
        get ""/session/email-login/#{email_token.token}""
        expect(CGI.unescapeHTML(response.body)).to include(
          I18n.t(""login.not_approved"")
        )
          get ""/session/email-login/#{email_token.token}""
          expect(CGI.unescapeHTML(response.body)).to include(
          get ""/session/email-login/#{email_token.token}""
          expect(CGI.unescapeHTML(response.body)).to include(
        get ""/session/email-login/#{email_token.token}""
        expect(CGI.unescapeHTML(response.body)).to include(I18n.t(""login.suspended"",
          date: I18n.l(user.suspended_till, format: :date_only)
        describe 'requires second factor' do
          it 'should return a second factor prompt' do
            get ""/session/email-login/#{email_token.token}""

            expect(response.status).to eq(200)

            response_body = CGI.unescapeHTML(response.body)

            expect(response_body).to include(I18n.t(
              ""login.second_factor_title""
            ))

            expect(response_body).to_not include(I18n.t(
              ""login.invalid_second_factor_code""
            ))
          end
        end

              post ""/session/email-login/#{email_token.token}"", params: {
              expect(CGI.unescapeHTML(response.body)).to include(I18n.t(
                ""login.invalid_second_factor_code""
              ))
              post ""/session/email-login/#{email_token.token}"", params: {
              expect(CGI.unescapeHTML(response.body)).to include(I18n.t(
                ""login.invalid_second_factor_code""
              ))
              post ""/session/email-login/#{email_token.token}"", params: {
              expect(response).to redirect_to(""/"")
              post ""/session/email-login/#{email_token.token}"", params: {
              expect(response).to redirect_to(""/"")",52387be4a44cdeaca5421ee955ba1343e836bade,CVE-2019-1020018,52387be4a44cdeaca5421ee955ba1343e836bade,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ' VAR 'VAR VAR' VAR VAR 'VAR VAR' VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR)  VAR(VAR[:VAR]).VAR VAR VAR VAR 'VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR.VAR = VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR).VAR VAR(404) VAR VAR 'VAR VAR VAR VAR VAR VAR' VAR VAR.VAR = VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR).VAR VAR(500) VAR VAR 'VAR VAR 2-VAR VAR' VAR VAR!(:VAR) { VAR(:VAR, VAR: VAR) } VAR!(:VAR) { VAR(:VAR, VAR: VAR) } VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR VAR VAR VAR VAR ' VAR VAR VAR.VAR = VAR VAR VAR 'VAR VAR' VAR VAR 'VAR VAR VAR VAR' VAR VAR ""/VAR/VAR-VAR"" VAR(VAR.VAR).VAR VAR(404) VAR VAR VAR ""/VAR/VAR-VAR/VAR.VAR"" VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(""VAR"") VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR"", VAR: VAR.VAR(VAR.VAR, VAR: :VAR) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR"") ) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR"") ) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(""VAR"") VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(""VAR"") VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR ' VAR ""/VAR/VAR-VAR/VAR"" VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR).VAR VAR(""/"") VAR ""/VAR/VAR-VAR/ VAR ""/VAR/VAR-VAR/ VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR.VAR(""VAR.VAR"") ) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR(VAR.VAR(""VAR.VAR"", VAR: VAR.VAR(VAR.VAR, VAR: :VAR) VAR 'VAR VAR VAR' VAR VAR 'VAR VAR VAR VAR VAR VAR' VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR).VAR VAR(200) VAR = VAR.VAR(VAR.VAR) VAR(VAR).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR(VAR).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR ""/VAR/VAR-VAR/ VAR(VAR).VAR VAR(""/"") VAR ""/VAR/VAR-VAR/ VAR(VAR).VAR VAR(""/"")",8
discourse_5e2e178fcfb490c37b9f8bb9f737185441b1d6de,spec/requests/users_controller_spec.rb,"    it ""should not be able to view a private user profile"" do
      user1.user_profile.update!(bio_raw: ""Hello world!"")
      user1.user_option.update!(hide_profile_and_presence: true)

      get ""/u/#{user1.username}""

      expect(response.status).to eq(200)
      expect(response.body).not_to include(""Hello world!"")
    end
",,5e2e178fcfb490c37b9f8bb9f737185441b1d6de,CVE-2022-21678,5e2e178fcfb490c37b9f8bb9f737185441b1d6de,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR.VAR.VAR!(VAR: ""VAR VAR!"") VAR.VAR.VAR!(VAR: VAR) VAR ""/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR).VAR VAR(""VAR VAR!"") VAR ",8
discourse_a34075d205a8857e29574ffd82aaece0c467565e,spec/components/final_destination_spec.rb,"  let(:body_response) do
    {
      status: 200,
      body: ""<body>test</body>""
    }
  end

    it 'raises error when response is too big' do
      stub_const(described_class, ""MAX_REQUEST_SIZE_BYTES"", 1) do
        stub_request(:get, ""https://codinghorror.com/blog"").to_return(body_response)
        final = FinalDestination.new('https://codinghorror.com/blog', opts.merge(follow_canonical: true))
        expect { final.resolve }.to raise_error(Excon::Errors::ExpectationFailed, ""response size too big: https://codinghorror.com/blog"")
      end
    end

    it 'raises error when response is too slow' do
      stub_request(:get, ""https://codinghorror.com/blog"").to_return(lambda { |request| freeze_time(11.seconds.from_now) ; body_response })
      final = FinalDestination.new('https://codinghorror.com/blog', opts.merge(follow_canonical: true))
      expect { final.resolve }.to raise_error(Excon::Errors::ExpectationFailed, ""connect timeout reached: https://codinghorror.com/blog"")
    end
",,a34075d205a8857e29574ffd82aaece0c467565e,CVE-2022-23641,a34075d205a8857e29574ffd82aaece0c467565e,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR(:VAR) VAR { VAR: 200, VAR: ""<VAR>VAR</VAR>"" } VAR VAR 'VAR VAR VAR VAR VAR VAR VAR' VAR VAR(VAR, ""VAR"", 1) VAR VAR(:VAR, ""VAR: VAR = VAR.VAR('VAR: VAR { VAR.VAR }.VAR VAR(VAR::VAR::VAR, ""VAR VAR VAR VAR: VAR: VAR VAR VAR 'VAR VAR VAR VAR VAR VAR VAR' VAR VAR(:VAR, ""VAR: VAR = VAR.VAR('VAR: VAR { VAR.VAR }.VAR VAR(VAR::VAR::VAR, ""VAR VAR VAR: VAR: VAR ",8
discourse_a414520742da8dc9dc976d4fb7b72dbd445813bb,spec/requests/invites_controller_spec.rb,"      context ""for an email invite"" do
        fab!(:invite) { Fabricate(:invite, email: 'test@example.com') }
        fab!(:user) { Fabricate(:user, email: 'test@example.com') }
        fab!(:group) { Fabricate(:group) }
        it 'redeems the invitation and creates the invite accepted notification' do
          put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
          expect(response.status).to eq(200)
          expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success""))
          invite.reload
          expect(invite.invited_users.first.user).to eq(user)
          expect(invite.redeemed?).to be_truthy
          expect(
            Notification.exists?(
              user: invite.invited_by, notification_type: Notification.types[:invitee_accepted]
            )
          ).to eq(true)
        end
        it 'redirects to the first topic the user was invited to and creates the topic notification' do
          topic = Fabricate(:topic)
          TopicInvite.create!(invite: invite, topic: topic)
          put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
          expect(response.status).to eq(200)
          expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)
          expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)
        end
        it ""adds the user to the private topic"" do
          topic = Fabricate(:private_message_topic)
          TopicInvite.create!(invite: invite, topic: topic)
          put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
          expect(response.status).to eq(200)
          expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)
          expect(TopicAllowedUser.exists?(user: user, topic: topic)).to eq(true)
        end
        it ""adds the user to the groups specified on the invite and allows them to access the secure topic"" do
          group.add_owner(invite.invited_by)
          secured_category = Fabricate(:category)
          secured_category.permissions = { group.name => :full }
          secured_category.save!

          topic = Fabricate(:topic, category: secured_category)
          TopicInvite.create!(invite: invite, topic: topic)
          InvitedGroup.create!(invite: invite, group: group)
          expect(response.status).to eq(200)
          expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success""))
          expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)
          invite.reload
          expect(invite.redeemed?).to be_truthy
          expect(user.reload.groups).to include(group)
          expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)
        end
        it ""does not try to log in the user automatically"" do
          expect do
            put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
          end.not_to change { UserAuthToken.count }
          expect(response.status).to eq(200)
          expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success""))
        end

        it ""errors if the user's email doesn't match the invite email"" do
          user.update!(email: ""blah@test.com"")
          put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
          expect(response.status).to eq(412)
          expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.not_matching_email""))
        end

        it ""errors if the user's email domain doesn't match the invite domain"" do
          user.update!(email: ""blah@test.com"")
          invite.update!(email: nil, domain: ""example.com"")
          put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
          expect(response.status).to eq(412)
          expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.domain_not_allowed""))
        end
      context ""for an invite link"" do
        fab!(:invite) { Fabricate(:invite, email: nil) }
        fab!(:user) { Fabricate(:user, email: 'test@example.com') }
        fab!(:group) { Fabricate(:group) }

        it 'redeems the invitation and creates the invite accepted notification' do
          put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
          expect(response.status).to eq(200)
          expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success""))
          invite.reload
          expect(invite.invited_users.first.user).to eq(user)
          expect(invite.redeemed?).to be_truthy
          expect(
            Notification.exists?(
              user: invite.invited_by, notification_type: Notification.types[:invitee_accepted]
            )
          ).to eq(true)
        end

        it 'redirects to the first topic the user was invited to and creates the topic notification' do
          topic = Fabricate(:topic)
          TopicInvite.create!(invite: invite, topic: topic)
          put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
          expect(response.status).to eq(200)
          expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)
          expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)
        end

        it ""adds the user to the groups specified on the invite and allows them to access the secure topic"" do
          group.add_owner(invite.invited_by)
          secured_category = Fabricate(:category)
          secured_category.permissions = { group.name => :full }
          secured_category.save!

          topic = Fabricate(:topic, category: secured_category)
          TopicInvite.create!(invite: invite, topic: topic)
          InvitedGroup.create!(invite: invite, group: group)

          put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
          expect(response.status).to eq(200)
          expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success""))
          expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)
          invite.reload
          expect(invite.redeemed?).to be_truthy
          expect(user.reload.groups).to include(group)
          expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)
        end

        it ""does not try to log in the user automatically"" do
          expect do
            put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
          end.not_to change { UserAuthToken.count }
          expect(response.status).to eq(200)
          expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success""))
        end","      fab!(:invite) { Fabricate(:invite, email: 'test@example.com') }
      fab!(:user) { Fabricate(:user, email: 'test@example.com') }
      fab!(:group) { Fabricate(:group) }

      it 'redeems the invitation and creates the invite accepted notification' do
        put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
        expect(response.status).to eq(200)
        expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success""))
        invite.reload
        expect(invite.invited_users.first.user).to eq(user)
        expect(invite.redeemed?).to be_truthy
        expect(
          Notification.exists?(
            user: invite.invited_by, notification_type: Notification.types[:invitee_accepted]
          )
        ).to eq(true)
      end
      it 'redirects to the first topic the user was invited to and creates the topic notification' do
        topic = Fabricate(:topic)
        TopicInvite.create!(invite: invite, topic: topic)
        put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
        expect(response.status).to eq(200)
        expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)
        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)
      end
      it ""adds the user to the groups specified on the invite and allows them to access the secure topic"" do
        group.add_owner(invite.invited_by)
        secured_category = Fabricate(:category)
        secured_category.permissions = { group.name => :full }
        secured_category.save!
        topic = Fabricate(:topic, category: secured_category)
        TopicInvite.create!(invite: invite, topic: topic)
        InvitedGroup.create!(invite: invite, group: group)
        put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
        expect(response.status).to eq(200)
        expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success""))
        expect(response.parsed_body['redirect_to']).to eq(topic.relative_url)
        invite.reload
        expect(invite.redeemed?).to be_truthy
        expect(user.reload.groups).to include(group)
        expect(Notification.where(notification_type: Notification.types[:invited_to_topic], topic: topic).count).to eq(1)
      end
      it ""does not try to log in the user automatically"" do
        expect do
        end.not_to change { UserAuthToken.count }
        expect(response.status).to eq(200)
        expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.existing_user_success""))
      end
      it ""errors if the user's email doesn't match the invite email"" do
        user.update!(email: ""blah@test.com"")
        put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
        expect(response.status).to eq(412)
        expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.not_matching_email""))
      it ""errors if the user's email domain doesn't match the invite domain"" do
        user.update!(email: ""blah@test.com"")
        invite.update!(email: nil, domain: ""example.com"")
        put ""/invites/show/#{invite.invite_key}.json"", params: { id: invite.invite_key }
        expect(response.status).to eq(412)
        expect(response.parsed_body[""message""]).to eq(I18n.t(""invite.domain_not_allowed""))",a414520742da8dc9dc976d4fb7b72dbd445813bb,CVE-2022-39385,a414520742da8dc9dc976d4fb7b72dbd445813bb,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ""VAR VAR VAR VAR"" VAR VAR!(:VAR) { VAR(:VAR, VAR: 'VAR@VAR.VAR') } VAR!(:VAR) { VAR(:VAR, VAR: 'VAR@VAR.VAR') } VAR!(:VAR) { VAR(:VAR) } VAR 'VAR VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR.VAR VAR(VAR.VAR.VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR VAR( VAR.VAR?( VAR: VAR.VAR, VAR: VAR.VAR[:VAR] ) ).VAR VAR(VAR) VAR VAR 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR = VAR(:VAR) VAR.VAR!(VAR: VAR, VAR: VAR) VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR['VAR']).VAR VAR(VAR.VAR) VAR(VAR.VAR(VAR: VAR.VAR[:VAR], VAR: VAR).VAR).VAR VAR(1) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR"" VAR VAR = VAR(:VAR) VAR.VAR!(VAR: VAR, VAR: VAR) VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR['VAR']).VAR VAR(VAR.VAR) VAR(VAR.VAR?(VAR: VAR, VAR: VAR)).VAR VAR(VAR) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR.VAR(VAR.VAR) VAR = VAR(:VAR) VAR.VAR = { VAR.VAR => :VAR } VAR.VAR! VAR = VAR(:VAR, VAR: VAR) VAR.VAR!(VAR: VAR, VAR: VAR) VAR.VAR!(VAR: VAR, VAR: VAR) VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR(VAR.VAR['VAR']).VAR VAR(VAR.VAR) VAR.VAR VAR(VAR.VAR?).VAR VAR VAR(VAR.VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR(VAR: VAR.VAR[:VAR], VAR: VAR).VAR).VAR VAR(1) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR VAR VAR ""/VAR/VAR/ VAR.VAR VAR { VAR.VAR } VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR VAR ""VAR VAR VAR VAR'VAR VAR VAR'VAR VAR VAR VAR VAR"" VAR VAR.VAR!(VAR: ""VAR@VAR.VAR"") VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(412) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR VAR ""VAR VAR VAR VAR'VAR VAR VAR VAR'VAR VAR VAR VAR VAR"" VAR VAR.VAR!(VAR: ""VAR@VAR.VAR"") VAR.VAR!(VAR: VAR, VAR: ""VAR.VAR"") VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(412) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR VAR ""VAR VAR VAR VAR"" VAR VAR!(:VAR) { VAR(:VAR, VAR: VAR) } VAR!(:VAR) { VAR(:VAR, VAR: 'VAR@VAR.VAR') } VAR!(:VAR) { VAR(:VAR) } VAR 'VAR VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR.VAR VAR(VAR.VAR.VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR VAR( VAR.VAR?( VAR: VAR.VAR, VAR: VAR.VAR[:VAR] ) ).VAR VAR(VAR) VAR VAR 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR = VAR(:VAR) VAR.VAR!(VAR: VAR, VAR: VAR) VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR['VAR']).VAR VAR(VAR.VAR) VAR(VAR.VAR(VAR: VAR.VAR[:VAR], VAR: VAR).VAR).VAR VAR(1) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR.VAR(VAR.VAR) VAR = VAR(:VAR) VAR.VAR = { VAR.VAR => :VAR } VAR.VAR! VAR = VAR(:VAR, VAR: VAR) VAR.VAR!(VAR: VAR, VAR: VAR) VAR.VAR!(VAR: VAR, VAR: VAR) VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR(VAR.VAR['VAR']).VAR VAR(VAR.VAR) VAR.VAR VAR(VAR.VAR?).VAR VAR VAR(VAR.VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR(VAR: VAR.VAR[:VAR], VAR: VAR).VAR).VAR VAR(1) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR VAR VAR ""/VAR/VAR/ VAR.VAR VAR { VAR.VAR } VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR VAR!(:VAR) { VAR(:VAR, VAR: 'VAR@VAR.VAR') } VAR!(:VAR) { VAR(:VAR, VAR: 'VAR@VAR.VAR') } VAR!(:VAR) { VAR(:VAR) } VAR 'VAR VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR.VAR VAR(VAR.VAR.VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR VAR( VAR.VAR?( VAR: VAR.VAR, VAR: VAR.VAR[:VAR] ) ).VAR VAR(VAR) VAR VAR 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR = VAR(:VAR) VAR.VAR!(VAR: VAR, VAR: VAR) VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR['VAR']).VAR VAR(VAR.VAR) VAR(VAR.VAR(VAR: VAR.VAR[:VAR], VAR: VAR).VAR).VAR VAR(1) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR.VAR(VAR.VAR) VAR = VAR(:VAR) VAR.VAR = { VAR.VAR => :VAR } VAR.VAR! VAR = VAR(:VAR, VAR: VAR) VAR.VAR!(VAR: VAR, VAR: VAR) VAR.VAR!(VAR: VAR, VAR: VAR) VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR(VAR.VAR['VAR']).VAR VAR(VAR.VAR) VAR.VAR VAR(VAR.VAR?).VAR VAR VAR(VAR.VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR(VAR: VAR.VAR[:VAR], VAR: VAR).VAR).VAR VAR(1) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR VAR VAR.VAR VAR { VAR.VAR } VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR VAR ""VAR VAR VAR VAR'VAR VAR VAR'VAR VAR VAR VAR VAR"" VAR VAR.VAR!(VAR: ""VAR@VAR.VAR"") VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(412) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR ""VAR VAR VAR VAR'VAR VAR VAR VAR'VAR VAR VAR VAR VAR"" VAR VAR.VAR!(VAR: ""VAR@VAR.VAR"") VAR.VAR!(VAR: VAR, VAR: ""VAR.VAR"") VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(412) VAR(VAR.VAR[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR""))",8
discourse_b8340c6c8e50a71ff1bca9654b9126ca5a84ce9a,spec/requests/session_controller_spec.rb,"  describe '#email_login_info' do
    context 'valid token' do
      it 'returns information' do
        get ""/session/email-login/#{email_token.token}.json""

        expect(JSON.parse(response.body)[""can_login""]).to eq(true)
        expect(JSON.parse(response.body)[""second_factor_required""]).to eq(nil)

        # Does not log in the user
        expect(session[:current_user_id]).to be_nil
      end

      it 'fails when local logins via email is disabled' do
        SiteSetting.enable_local_logins_via_email = false

        get ""/session/email-login/#{email_token.token}.json""

        expect(response.status).to eq(404)
      end

      it 'fails when local logins is disabled' do
        SiteSetting.enable_local_logins = false

        get ""/session/email-login/#{email_token.token}.json""

        expect(response.status).to eq(500)
      end

      context 'user has 2-factor logins' do
        let!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user) }
        let!(:user_second_factor_backup) { Fabricate(:user_second_factor_backup, user: user) }

        it ""includes that information in the response"" do
          get ""/session/email-login/#{email_token.token}.json""

          expect(JSON.parse(response.body)[""can_login""]).to eq(true)
          expect(JSON.parse(response.body)[""second_factor_required""]).to eq(true)
          expect(JSON.parse(response.body)[""backup_codes_enabled""]).to eq(true)
        end
      end
    end
  end

  describe '#email_login' do
    before do
      SiteSetting.enable_local_logins_via_email = true
    end

    context 'missing token' do
      it 'returns the right response' do
        post ""/session/email-login""
        expect(response.status).to eq(404)
      end
    end

        post ""/session/email-login/adasdad.json""
        expect(JSON.parse(response.body)[""error""]).to eq(
          post ""/session/email-login/#{email_token.token}.json""
          expect(JSON.parse(response.body)[""error""]).to eq(
        post ""/session/email-login/#{email_token.token}.json""
        expect(JSON.parse(response.body)[""success""]).to eq(""OK"")
        expect(session[:current_user_id]).to eq(user.id)
        post ""/session/email-login/#{email_token.token}.json""
        expect(session[:current_user_id]).to eq(nil)
        post ""/session/email-login/#{email_token.token}.json""
        expect(session[:current_user_id]).to eq(nil)
        post ""/session/email-login/#{email_token.token}.json""
        expect(JSON.parse(response.body)[""error""]).to eq(I18n.t(""login.not_approved""))
        expect(session[:current_user_id]).to eq(nil)
          post ""/session/email-login/#{email_token.token}.json""
          expect(JSON.parse(response.body)[""error""]).to eq(
          expect(session[:current_user_id]).to eq(nil)
          post ""/session/email-login/#{email_token.token}.json""
          expect(JSON.parse(response.body)[""error""]).to eq(
          expect(session[:current_user_id]).to eq(nil)
        post ""/session/email-login/#{email_token.token}.json""
        expect(JSON.parse(response.body)[""error""]).to eq(
          I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only)
        expect(session[:current_user_id]).to eq(nil)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""error""]).to eq(
                I18n.t(""login.invalid_second_factor_code"")
              )
              expect(session[:current_user_id]).to eq(nil)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""error""]).to eq(
                I18n.t(""login.invalid_second_factor_code"")
              )
              expect(session[:current_user_id]).to eq(nil)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""success""]).to eq(""OK"")
              expect(session[:current_user_id]).to eq(user.id)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""success""]).to eq(""OK"")
              expect(session[:current_user_id]).to eq(user.id)

        post ""/session/otp/asd1231dasd123""

        expect(response.status).to eq(404)
        it ""should display the form for GET"" do
          token = SecureRandom.hex
          $redis.setex ""otp_#{token}"", 10.minutes, user.username

          get ""/session/otp/#{token}""

          expect(response.status).to eq(200)
          expect(response.body).to include(
            I18n.t(""user_api_key.otp_confirmation.logging_in_as"", username: user.username)
          )
          expect($redis.get(""otp_#{token}"")).to eq(user.username)

          expect(session[:current_user_id]).to eq(nil)
        end

        it ""should redirect on GET if already logged in"" do
          sign_in(user)
          token = SecureRandom.hex
          $redis.setex ""otp_#{token}"", 10.minutes, user.username

          get ""/session/otp/#{token}""
          expect(response.status).to eq(302)

          expect($redis.get(""otp_#{token}"")).to eq(nil)
          expect(session[:current_user_id]).to eq(user.id)
        end

          post ""/session/otp/#{token}""","  describe '#email_login' do
        get ""/session/email-login/adasdad""

        expect(CGI.unescapeHTML(response.body)).to match(
          get ""/session/email-login/#{email_token.token}""
          expect(CGI.unescapeHTML(response.body)).to match(
        get ""/session/email-login/#{email_token.token}""
        expect(response).to redirect_to(""/"")
        get ""/session/email-login/#{email_token.token}""
        get ""/session/email-login/#{email_token.token}""
        get ""/session/email-login/#{email_token.token}""
        expect(CGI.unescapeHTML(response.body)).to include(
          I18n.t(""login.not_approved"")
        )
          get ""/session/email-login/#{email_token.token}""
          expect(CGI.unescapeHTML(response.body)).to include(
          get ""/session/email-login/#{email_token.token}""
          expect(CGI.unescapeHTML(response.body)).to include(
        get ""/session/email-login/#{email_token.token}""
        expect(CGI.unescapeHTML(response.body)).to include(I18n.t(""login.suspended"",
          date: I18n.l(user.suspended_till, format: :date_only)
        describe 'requires second factor' do
          it 'should return a second factor prompt' do
            get ""/session/email-login/#{email_token.token}""

            expect(response.status).to eq(200)

            response_body = CGI.unescapeHTML(response.body)

            expect(response_body).to include(I18n.t(
              ""login.second_factor_title""
            ))

            expect(response_body).to_not include(I18n.t(
              ""login.invalid_second_factor_code""
            ))
          end
        end

              post ""/session/email-login/#{email_token.token}"", params: {
              expect(CGI.unescapeHTML(response.body)).to include(I18n.t(
                ""login.invalid_second_factor_code""
              ))
              post ""/session/email-login/#{email_token.token}"", params: {
              expect(CGI.unescapeHTML(response.body)).to include(I18n.t(
                ""login.invalid_second_factor_code""
              ))
              post ""/session/email-login/#{email_token.token}"", params: {
              expect(response).to redirect_to(""/"")
              post ""/session/email-login/#{email_token.token}"", params: {
              expect(response).to redirect_to(""/"")
          get ""/session/otp/#{token}""",b8340c6c8e50a71ff1bca9654b9126ca5a84ce9a,CVE-2019-1020017,b8340c6c8e50a71ff1bca9654b9126ca5a84ce9a,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ' VAR 'VAR VAR' VAR VAR 'VAR VAR' VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR)  VAR(VAR[:VAR]).VAR VAR VAR VAR 'VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR.VAR = VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR).VAR VAR(404) VAR VAR 'VAR VAR VAR VAR VAR VAR' VAR VAR.VAR = VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR).VAR VAR(500) VAR VAR 'VAR VAR 2-VAR VAR' VAR VAR!(:VAR) { VAR(:VAR, VAR: VAR) } VAR!(:VAR) { VAR(:VAR, VAR: VAR) } VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR VAR VAR VAR VAR ' VAR VAR VAR.VAR = VAR VAR VAR 'VAR VAR' VAR VAR 'VAR VAR VAR VAR' VAR VAR ""/VAR/VAR-VAR"" VAR(VAR.VAR).VAR VAR(404) VAR VAR VAR ""/VAR/VAR-VAR/VAR.VAR"" VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(""VAR"") VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR"", VAR: VAR.VAR(VAR.VAR, VAR: :VAR) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR"") ) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR"") ) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(""VAR"") VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(""VAR"") VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR ""/VAR/VAR/VAR"" VAR(VAR.VAR).VAR VAR(404) VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR = VAR.VAR $VAR.VAR ""VAR VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR).VAR VAR( VAR.VAR(""VAR.VAR.VAR"", VAR: VAR.VAR) ) VAR($VAR.VAR(""VAR VAR(VAR[:VAR]).VAR VAR(VAR) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR(VAR) VAR = VAR.VAR $VAR.VAR ""VAR VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(302) VAR($VAR.VAR(""VAR VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR VAR ""/VAR/VAR/ VAR ' VAR ""/VAR/VAR-VAR/VAR"" VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR).VAR VAR(""/"") VAR ""/VAR/VAR-VAR/ VAR ""/VAR/VAR-VAR/ VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR.VAR(""VAR.VAR"") ) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR(VAR.VAR(""VAR.VAR"", VAR: VAR.VAR(VAR.VAR, VAR: :VAR) VAR 'VAR VAR VAR' VAR VAR 'VAR VAR VAR VAR VAR VAR' VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR).VAR VAR(200) VAR = VAR.VAR(VAR.VAR) VAR(VAR).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR(VAR).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR ""/VAR/VAR-VAR/ VAR(VAR).VAR VAR(""/"") VAR ""/VAR/VAR-VAR/ VAR(VAR).VAR VAR(""/"") VAR ""/VAR/VAR/",8
discourse_b8340c6c8e50a71ff1bca9654b9126ca5a84ce9a,spec/requests/session_controller_spec.rb,"  describe '#email_login_info' do
    context 'valid token' do
      it 'returns information' do
        get ""/session/email-login/#{email_token.token}.json""

        expect(JSON.parse(response.body)[""can_login""]).to eq(true)
        expect(JSON.parse(response.body)[""second_factor_required""]).to eq(nil)

        # Does not log in the user
        expect(session[:current_user_id]).to be_nil
      end

      it 'fails when local logins via email is disabled' do
        SiteSetting.enable_local_logins_via_email = false

        get ""/session/email-login/#{email_token.token}.json""

        expect(response.status).to eq(404)
      end

      it 'fails when local logins is disabled' do
        SiteSetting.enable_local_logins = false

        get ""/session/email-login/#{email_token.token}.json""

        expect(response.status).to eq(500)
      end

      context 'user has 2-factor logins' do
        let!(:user_second_factor) { Fabricate(:user_second_factor_totp, user: user) }
        let!(:user_second_factor_backup) { Fabricate(:user_second_factor_backup, user: user) }

        it ""includes that information in the response"" do
          get ""/session/email-login/#{email_token.token}.json""

          expect(JSON.parse(response.body)[""can_login""]).to eq(true)
          expect(JSON.parse(response.body)[""second_factor_required""]).to eq(true)
          expect(JSON.parse(response.body)[""backup_codes_enabled""]).to eq(true)
        end
      end
    end
  end

  describe '#email_login' do
    before do
      SiteSetting.enable_local_logins_via_email = true
    end

    context 'missing token' do
      it 'returns the right response' do
        post ""/session/email-login""
        expect(response.status).to eq(404)
      end
    end

        post ""/session/email-login/adasdad.json""
        expect(JSON.parse(response.body)[""error""]).to eq(
          post ""/session/email-login/#{email_token.token}.json""
          expect(JSON.parse(response.body)[""error""]).to eq(
        post ""/session/email-login/#{email_token.token}.json""
        expect(JSON.parse(response.body)[""success""]).to eq(""OK"")
        expect(session[:current_user_id]).to eq(user.id)
        post ""/session/email-login/#{email_token.token}.json""
        expect(session[:current_user_id]).to eq(nil)
        post ""/session/email-login/#{email_token.token}.json""
        expect(session[:current_user_id]).to eq(nil)
        post ""/session/email-login/#{email_token.token}.json""
        expect(JSON.parse(response.body)[""error""]).to eq(I18n.t(""login.not_approved""))
        expect(session[:current_user_id]).to eq(nil)
          post ""/session/email-login/#{email_token.token}.json""
          expect(JSON.parse(response.body)[""error""]).to eq(
          expect(session[:current_user_id]).to eq(nil)
          post ""/session/email-login/#{email_token.token}.json""
          expect(JSON.parse(response.body)[""error""]).to eq(
          expect(session[:current_user_id]).to eq(nil)
        post ""/session/email-login/#{email_token.token}.json""
        expect(JSON.parse(response.body)[""error""]).to eq(
          I18n.t(""login.suspended"", date: I18n.l(user.suspended_till, format: :date_only)
        expect(session[:current_user_id]).to eq(nil)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""error""]).to eq(
                I18n.t(""login.invalid_second_factor_code"")
              )
              expect(session[:current_user_id]).to eq(nil)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""error""]).to eq(
                I18n.t(""login.invalid_second_factor_code"")
              )
              expect(session[:current_user_id]).to eq(nil)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""success""]).to eq(""OK"")
              expect(session[:current_user_id]).to eq(user.id)
              post ""/session/email-login/#{email_token.token}.json"", params: {
              expect(JSON.parse(response.body)[""success""]).to eq(""OK"")
              expect(session[:current_user_id]).to eq(user.id)

        post ""/session/otp/asd1231dasd123""

        expect(response.status).to eq(404)
        it ""should display the form for GET"" do
          token = SecureRandom.hex
          $redis.setex ""otp_#{token}"", 10.minutes, user.username

          get ""/session/otp/#{token}""

          expect(response.status).to eq(200)
          expect(response.body).to include(
            I18n.t(""user_api_key.otp_confirmation.logging_in_as"", username: user.username)
          )
          expect($redis.get(""otp_#{token}"")).to eq(user.username)

          expect(session[:current_user_id]).to eq(nil)
        end

        it ""should redirect on GET if already logged in"" do
          sign_in(user)
          token = SecureRandom.hex
          $redis.setex ""otp_#{token}"", 10.minutes, user.username

          get ""/session/otp/#{token}""
          expect(response.status).to eq(302)

          expect($redis.get(""otp_#{token}"")).to eq(nil)
          expect(session[:current_user_id]).to eq(user.id)
        end

          post ""/session/otp/#{token}""","  describe '#email_login' do
        get ""/session/email-login/adasdad""

        expect(CGI.unescapeHTML(response.body)).to match(
          get ""/session/email-login/#{email_token.token}""
          expect(CGI.unescapeHTML(response.body)).to match(
        get ""/session/email-login/#{email_token.token}""
        expect(response).to redirect_to(""/"")
        get ""/session/email-login/#{email_token.token}""
        get ""/session/email-login/#{email_token.token}""
        get ""/session/email-login/#{email_token.token}""
        expect(CGI.unescapeHTML(response.body)).to include(
          I18n.t(""login.not_approved"")
        )
          get ""/session/email-login/#{email_token.token}""
          expect(CGI.unescapeHTML(response.body)).to include(
          get ""/session/email-login/#{email_token.token}""
          expect(CGI.unescapeHTML(response.body)).to include(
        get ""/session/email-login/#{email_token.token}""
        expect(CGI.unescapeHTML(response.body)).to include(I18n.t(""login.suspended"",
          date: I18n.l(user.suspended_till, format: :date_only)
        describe 'requires second factor' do
          it 'should return a second factor prompt' do
            get ""/session/email-login/#{email_token.token}""

            expect(response.status).to eq(200)

            response_body = CGI.unescapeHTML(response.body)

            expect(response_body).to include(I18n.t(
              ""login.second_factor_title""
            ))

            expect(response_body).to_not include(I18n.t(
              ""login.invalid_second_factor_code""
            ))
          end
        end

              post ""/session/email-login/#{email_token.token}"", params: {
              expect(CGI.unescapeHTML(response.body)).to include(I18n.t(
                ""login.invalid_second_factor_code""
              ))
              post ""/session/email-login/#{email_token.token}"", params: {
              expect(CGI.unescapeHTML(response.body)).to include(I18n.t(
                ""login.invalid_second_factor_code""
              ))
              post ""/session/email-login/#{email_token.token}"", params: {
              expect(response).to redirect_to(""/"")
              post ""/session/email-login/#{email_token.token}"", params: {
              expect(response).to redirect_to(""/"")
          get ""/session/otp/#{token}""",b8340c6c8e50a71ff1bca9654b9126ca5a84ce9a,CVE-2019-1020018,b8340c6c8e50a71ff1bca9654b9126ca5a84ce9a,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ' VAR 'VAR VAR' VAR VAR 'VAR VAR' VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR)  VAR(VAR[:VAR]).VAR VAR VAR VAR 'VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR.VAR = VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR).VAR VAR(404) VAR VAR 'VAR VAR VAR VAR VAR VAR' VAR VAR.VAR = VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR).VAR VAR(500) VAR VAR 'VAR VAR 2-VAR VAR' VAR VAR!(:VAR) { VAR(:VAR, VAR: VAR) } VAR!(:VAR) { VAR(:VAR, VAR: VAR) } VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR) VAR VAR VAR VAR VAR ' VAR VAR VAR.VAR = VAR VAR VAR 'VAR VAR' VAR VAR 'VAR VAR VAR VAR' VAR VAR ""/VAR/VAR-VAR"" VAR(VAR.VAR).VAR VAR(404) VAR VAR VAR ""/VAR/VAR-VAR/VAR.VAR"" VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(""VAR"") VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(VAR.VAR(""VAR.VAR"")) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR"", VAR: VAR.VAR(VAR.VAR, VAR: :VAR) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR"") ) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR( VAR.VAR(""VAR.VAR"") ) VAR(VAR[:VAR]).VAR VAR(VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(""VAR"") VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)[""VAR""]).VAR VAR(""VAR"") VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR ""/VAR/VAR/VAR"" VAR(VAR.VAR).VAR VAR(404) VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR = VAR.VAR $VAR.VAR ""VAR VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR).VAR VAR( VAR.VAR(""VAR.VAR.VAR"", VAR: VAR.VAR) ) VAR($VAR.VAR(""VAR VAR(VAR[:VAR]).VAR VAR(VAR) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR(VAR) VAR = VAR.VAR $VAR.VAR ""VAR VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(302) VAR($VAR.VAR(""VAR VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR VAR ""/VAR/VAR/ VAR ' VAR ""/VAR/VAR-VAR/VAR"" VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR).VAR VAR(""/"") VAR ""/VAR/VAR-VAR/ VAR ""/VAR/VAR-VAR/ VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR.VAR(""VAR.VAR"") ) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR( VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR(VAR.VAR(""VAR.VAR"", VAR: VAR.VAR(VAR.VAR, VAR: :VAR) VAR 'VAR VAR VAR' VAR VAR 'VAR VAR VAR VAR VAR VAR' VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR).VAR VAR(200) VAR = VAR.VAR(VAR.VAR) VAR(VAR).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR(VAR).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR VAR VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR ""/VAR/VAR-VAR/ VAR(VAR.VAR(VAR.VAR)).VAR VAR(VAR.VAR( ""VAR.VAR"" )) VAR ""/VAR/VAR-VAR/ VAR(VAR).VAR VAR(""/"") VAR ""/VAR/VAR-VAR/ VAR(VAR).VAR VAR(""/"") VAR ""/VAR/VAR/",8
discourse_bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,app/controllers/admin/staff_action_logs_controller.rb,"  INDEX_LIMIT = 200

    page_size = fetch_limit_from_params(default: INDEX_LIMIT, max: INDEX_LIMIT)","    page_size = (params[:limit] || 200).to_i.clamp(1, 200)",bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,CVE-2023-38684,bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR = 200 VAR = VAR(VAR: VAR, VAR: VAR) VAR = (VAR[:VAR] || 200).VAR.VAR(1, 200)",8
discourse_bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,app/controllers/post_action_users_controller.rb,"  INDEX_LIMIT = 200

    page_size = fetch_limit_from_params(default: INDEX_LIMIT, max: INDEX_LIMIT)",    page_size = (params[:limit] || 200).to_i,bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,CVE-2023-38684,bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR = 200 VAR = VAR(VAR: VAR, VAR: VAR) VAR = (VAR[:VAR] || 200).VAR",8
discourse_bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,spec/requests/directory_items_controller_spec.rb,"    include_examples ""invalid limit params"", ""/directory_items.json"", described_class::PAGE_SIZE","    it ""does not exceed PAGE_SIZE if limit parameter is more than PAGE_SIZE"" do
      large_limit = DirectoryItemsController::PAGE_SIZE + 10
      get ""/directory_items.json"", params: { period: ""all"", limit: large_limit }
      expect(response.status).to eq(200)
      json = response.parsed_body

      expect(json[""directory_items""].length).to eq(DirectoryItemsController::PAGE_SIZE)
    end

    it ""handles invalid limit parameters gracefully"" do
      get ""/directory_items.json"", params: { period: ""all"", limit: ""invalid_limit"" }
      expect(response.status).to eq(200)
      json = response.parsed_body

      expect(json[""directory_items""]).not_to be_empty
    end",bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,CVE-2023-38684,bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ""VAR VAR VAR"", ""/VAR.VAR"", VAR::VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR = VAR::VAR + 10 VAR ""/VAR.VAR"", VAR: { VAR: ""VAR"", VAR: VAR } VAR(VAR.VAR).VAR VAR(200) VAR = VAR.VAR VAR(VAR[""VAR""].VAR).VAR VAR(VAR::VAR) VAR VAR ""VAR VAR VAR VAR VAR"" VAR VAR ""/VAR.VAR"", VAR: { VAR: ""VAR"", VAR: ""VAR"" } VAR(VAR.VAR).VAR VAR(200) VAR = VAR.VAR VAR(VAR[""VAR""]).VAR VAR VAR",8
discourse_c6ee28ec756436cc9ce154dd2c8e4c441f92f693,spec/requests/notifications_controller_spec.rb,"
        context ""with notifications for inaccessible topics"" do
          fab!(:sender) { Fabricate.build(:topic_allowed_user, user: Fabricate(:coding_horror)) }
          fab!(:allowed_user) { Fabricate.build(:topic_allowed_user, user: user) }
          fab!(:another_allowed_user) { Fabricate.build(:topic_allowed_user, user: Fabricate(:user)) }
          fab!(:allowed_pm) { Fabricate(:private_message_topic, topic_allowed_users: [sender, allowed_user, another_allowed_user]) }
          fab!(:forbidden_pm) { Fabricate(:private_message_topic, topic_allowed_users: [sender, another_allowed_user]) }
          fab!(:allowed_pm_notification) { Fabricate(:private_message_notification, user: user, topic: allowed_pm) }
          fab!(:forbidden_pm_notification) { Fabricate(:private_message_notification, user: user, topic: forbidden_pm) }

          def expect_correct_notifications(response)
            notification_ids = response.parsed_body[""notifications""].map { |n| n[""id""] }
            expect(notification_ids).to include(allowed_pm_notification.id)
            expect(notification_ids).to_not include(forbidden_pm_notification.id)
          end

          context ""with 'recent' filter"" do
            it ""doesn't include notifications from topics the user isn't allowed to see"" do
              SiteSetting.enable_experimental_sidebar_hamburger = true
              get ""/notifications.json"", params: { recent: true }
              expect(response.status).to eq(200)
              expect_correct_notifications(response)

              SiteSetting.enable_experimental_sidebar_hamburger = false
              get ""/notifications.json"", params: { recent: true }
              expect(response.status).to eq(200)
              expect_correct_notifications(response)
            end
          end

          context ""without 'recent' filter"" do
            it ""doesn't include notifications from topics the user isn't allowed to see"" do
              SiteSetting.enable_experimental_sidebar_hamburger = true
              get ""/notifications.json""
              expect(response.status).to eq(200)
              expect_correct_notifications(response)

              SiteSetting.enable_experimental_sidebar_hamburger = false
              get ""/notifications.json""
              expect(response.status).to eq(200)
              expect_correct_notifications(response)
            end
          end
        end",,c6ee28ec756436cc9ce154dd2c8e4c441f92f693,CVE-2022-41944,c6ee28ec756436cc9ce154dd2c8e4c441f92f693,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ""VAR VAR VAR VAR VAR"" VAR VAR!(:VAR) { VAR.VAR(:VAR, VAR: VAR(:VAR)) } VAR!(:VAR) { VAR.VAR(:VAR, VAR: VAR) } VAR!(:VAR) { VAR.VAR(:VAR, VAR: VAR(:VAR)) } VAR!(:VAR) { VAR(:VAR, VAR: [VAR, VAR, VAR]) } VAR!(:VAR) { VAR(:VAR, VAR: [VAR, VAR]) } VAR!(:VAR) { VAR(:VAR, VAR: VAR, VAR: VAR) } VAR!(:VAR) { VAR(:VAR, VAR: VAR, VAR: VAR) } VAR VAR(VAR) VAR = VAR.VAR[""VAR""].VAR { |VAR| VAR[""VAR""] } VAR(VAR).VAR VAR(VAR.VAR) VAR(VAR).VAR VAR(VAR.VAR) VAR VAR ""VAR 'VAR' VAR"" VAR VAR ""VAR'VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR"" VAR VAR.VAR = VAR VAR ""/VAR.VAR"", VAR: { VAR: VAR } VAR(VAR.VAR).VAR VAR(200) VAR(VAR) VAR.VAR = VAR VAR ""/VAR.VAR"", VAR: { VAR: VAR } VAR(VAR.VAR).VAR VAR(200) VAR(VAR) VAR VAR VAR ""VAR 'VAR' VAR"" VAR VAR ""VAR'VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR"" VAR VAR.VAR = VAR VAR ""/VAR.VAR"" VAR(VAR.VAR).VAR VAR(200) VAR(VAR) VAR.VAR = VAR VAR ""/VAR.VAR"" VAR(VAR.VAR).VAR VAR(200) VAR(VAR) VAR VAR VAR ",8
discourse_cf862e736565c6fa905c12b5dbe63d0bd056efb8,spec/requests/admin/email_controller_spec.rb,"  describe '#send_digest' do
    context ""when logged in as an admin"" do
      before { sign_in(admin) }

      it ""sends the digest"" do
        post ""/admin/email/send-digest.json"", params: {
          last_seen_at: 1.week.ago, username: admin.username, email: email('previous_replies')
        }
        expect(response.status).to eq(200)
      end
    end
  end
",,cf862e736565c6fa905c12b5dbe63d0bd056efb8,CVE-2022-23546,cf862e736565c6fa905c12b5dbe63d0bd056efb8,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ' VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR { VAR(VAR) } VAR ""VAR VAR VAR"" VAR VAR ""/VAR/VAR/VAR-VAR.VAR"", VAR: { VAR: 1.VAR.VAR, VAR: VAR.VAR, VAR: VAR('VAR') } VAR(VAR.VAR).VAR VAR(200) VAR VAR VAR ",8
discourse_e6e47f2fb22764c92aaa90445c7bf203192fba11,spec/requests/session_controller_spec.rb,"
        post ""/session/otp/asd1231dasd123""

        expect(response.status).to eq(404)
        it ""should display the form for GET"" do
          token = SecureRandom.hex
          $redis.setex ""otp_#{token}"", 10.minutes, user.username

          get ""/session/otp/#{token}""

          expect(response.status).to eq(200)
          expect(response.body).to include(
            I18n.t(""user_api_key.otp_confirmation.logging_in_as"", username: user.username)
          )
          expect($redis.get(""otp_#{token}"")).to eq(user.username)

          expect(session[:current_user_id]).to eq(nil)
        end

        it ""should redirect on GET if already logged in"" do
          sign_in(user)
          token = SecureRandom.hex
          $redis.setex ""otp_#{token}"", 10.minutes, user.username

          get ""/session/otp/#{token}""
          expect(response.status).to eq(302)

          expect($redis.get(""otp_#{token}"")).to eq(nil)
          expect(session[:current_user_id]).to eq(user.id)
        end

          post ""/session/otp/#{token}""","          get ""/session/otp/#{token}""",e6e47f2fb22764c92aaa90445c7bf203192fba11,CVE-2019-1020017,e6e47f2fb22764c92aaa90445c7bf203192fba11,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ""/VAR/VAR/VAR"" VAR(VAR.VAR).VAR VAR(404) VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR = VAR.VAR $VAR.VAR ""VAR VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(200) VAR(VAR.VAR).VAR VAR( VAR.VAR(""VAR.VAR.VAR"", VAR: VAR.VAR) ) VAR($VAR.VAR(""VAR VAR(VAR[:VAR]).VAR VAR(VAR) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR(VAR) VAR = VAR.VAR $VAR.VAR ""VAR VAR ""/VAR/VAR/ VAR(VAR.VAR).VAR VAR(302) VAR($VAR.VAR(""VAR VAR(VAR[:VAR]).VAR VAR(VAR.VAR) VAR VAR ""/VAR/VAR/ VAR ""/VAR/VAR/",8
discourse_f31f0b70f82c43d93220ce6fc0d4f57440452f37,spec/requests/tags_controller_spec.rb,"
      Fabricate(
        :tag,
        name: ""topic-test"",
        public_topic_count: 1,
        staff_topic_count: 1,
        pm_topic_count: 5,
      )
    end

    fab!(:pm_only_tag) do
      Fabricate(:tag, public_topic_count: 0, staff_topic_count: 0, pm_topic_count: 1)

        serialized_tag = tags.find { |t| t[""id""] == test_tag.name }

        expect(serialized_tag[""count""]).to eq(0)
        expect(serialized_tag[""pm_count""]).to eq(nil)
        expect(serialized_tag[""pm_only""]).to eq(false)

        serialized_tag = tags.find { |t| t[""id""] == topic_tag.name }

        expect(serialized_tag[""count""]).to eq(1)
        expect(serialized_tag[""pm_count""]).to eq(nil)
        expect(serialized_tag[""pm_only""]).to eq(false)
      end

      it ""does not include pm_count attribute when user cannot tag PM topics even if display_personal_messages_tag_counts site setting has been enabled"" do
        SiteSetting.display_personal_messages_tag_counts = true

        sign_in(admin)

        get ""/tags.json""

        expect(response.status).to eq(200)

        tags = response.parsed_body[""tags""]

        expect(tags[0][""pm_count""]).to eq(nil)
        expect(tags[1][""pm_count""]).to eq(nil)
      end

      it ""includes pm_count attribute when user can tag PM topics and display_personal_messages_tag_counts site setting has been enabled"" do
        SiteSetting.display_personal_messages_tag_counts = true
        SiteSetting.pm_tags_allowed_for_groups = Group::AUTO_GROUPS[:admins]

        sign_in(admin)

        get ""/tags.json""

        expect(response.status).to eq(200)

        tags = response.parsed_body[""tags""]

        serialized_tag = tags.find { |t| t[""id""] == test_tag.name }

        expect(serialized_tag[""pm_count""]).to eq(0)
        expect(serialized_tag[""pm_only""]).to eq(false)

        serialized_tag = tags.find { |t| t[""id""] == topic_tag.name }

        expect(serialized_tag[""pm_count""]).to eq(5)
        expect(serialized_tag[""pm_only""]).to eq(false)

        serialized_tag = tags.find { |t| t[""id""] == pm_only_tag.name }

        expect(serialized_tag[""pm_count""]).to eq(1)
        expect(serialized_tag[""pm_only""]).to eq(true)
        expect(tags[0][""pm_count""]).to eq(nil)
          SiteSetting.display_personal_messages_tag_counts = true
          expect(serialized_tag[""pm_count""]).to eq(5)
        expect(tags[0][""pm_count""]).to eq(nil)
        expect(categories[0][""tags""][0][""pm_count""]).to eq(nil)","      Fabricate(:tag, name: ""topic-test"", public_topic_count: 1, staff_topic_count: 1)
        expect(tags[0][""count""]).to eq(0)
        expect(tags[0][""pm_count""]).to eq(0)
        expect(tags[1][""count""]).to eq(1)
        expect(tags[1][""pm_count""]).to eq(0)
        expect(tags[0][""pm_count""]).to eq(0)
          expect(tags.length).to eq(2)
          expect(serialized_tag[""pm_count""]).to eq(0)
        expect(tags[0][""pm_count""]).to eq(0)
        expect(categories[0][""tags""][0][""pm_count""]).to eq(0)",f31f0b70f82c43d93220ce6fc0d4f57440452f37,CVE-2023-23935,f31f0b70f82c43d93220ce6fc0d4f57440452f37,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR( :VAR, VAR: ""VAR-VAR"", VAR: 1, VAR: 1, VAR: 5, ) VAR VAR!(:VAR) VAR VAR(:VAR, VAR: 0, VAR: 0, VAR: 1) VAR = VAR.VAR { |VAR| VAR[""VAR""] == VAR.VAR } VAR(VAR[""VAR""]).VAR VAR(0) VAR(VAR[""VAR""]).VAR VAR(VAR) VAR(VAR[""VAR""]).VAR VAR(VAR) VAR = VAR.VAR { |VAR| VAR[""VAR""] == VAR.VAR } VAR(VAR[""VAR""]).VAR VAR(1) VAR(VAR[""VAR""]).VAR VAR(VAR) VAR(VAR[""VAR""]).VAR VAR(VAR) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR.VAR = VAR VAR(VAR) VAR ""/VAR.VAR"" VAR(VAR.VAR).VAR VAR(200) VAR = VAR.VAR[""VAR""] VAR(VAR[0][""VAR""]).VAR VAR(VAR) VAR(VAR[1][""VAR""]).VAR VAR(VAR) VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR.VAR = VAR VAR.VAR = VAR::VAR[:VAR] VAR(VAR) VAR ""/VAR.VAR"" VAR(VAR.VAR).VAR VAR(200) VAR = VAR.VAR[""VAR""] VAR = VAR.VAR { |VAR| VAR[""VAR""] == VAR.VAR } VAR(VAR[""VAR""]).VAR VAR(0) VAR(VAR[""VAR""]).VAR VAR(VAR) VAR = VAR.VAR { |VAR| VAR[""VAR""] == VAR.VAR } VAR(VAR[""VAR""]).VAR VAR(5) VAR(VAR[""VAR""]).VAR VAR(VAR) VAR = VAR.VAR { |VAR| VAR[""VAR""] == VAR.VAR } VAR(VAR[""VAR""]).VAR VAR(1) VAR(VAR[""VAR""]).VAR VAR(VAR) VAR(VAR[0][""VAR""]).VAR VAR(VAR) VAR.VAR = VAR VAR(VAR[""VAR""]).VAR VAR(5) VAR(VAR[0][""VAR""]).VAR VAR(VAR) VAR(VAR[0][""VAR""][0][""VAR""]).VAR VAR(VAR) VAR(:VAR, VAR: ""VAR-VAR"", VAR: 1, VAR: 1) VAR(VAR[0][""VAR""]).VAR VAR(0) VAR(VAR[0][""VAR""]).VAR VAR(0) VAR(VAR[1][""VAR""]).VAR VAR(1) VAR(VAR[1][""VAR""]).VAR VAR(0) VAR(VAR[0][""VAR""]).VAR VAR(0) VAR(VAR.VAR).VAR VAR(2) VAR(VAR[""VAR""]).VAR VAR(0) VAR(VAR[0][""VAR""]).VAR VAR(0) VAR(VAR[0][""VAR""][0][""VAR""]).VAR VAR(0)",8
django_0e7861aec73702f7933ce2a93056f7983939f0d6,tests/regressiontests/admin_views/tests.py,"    def testHistoryView(self):
        """"""History view should restrict access.""""""

        # add user shoud not be able to view the list of article or change any of them
        self.client.get('/test_admin/admin/')
        self.client.post('/test_admin/admin/', self.adduser_login)
        response = self.client.get('/test_admin/admin/admin_views/article/1/history/')
        self.assertEqual(response.status_code, 403)
        self.client.get('/test_admin/admin/logout/')

        # change user can view all items and edit them
        self.client.get('/test_admin/admin/')
        self.client.post('/test_admin/admin/', self.changeuser_login)
        response = self.client.get('/test_admin/admin/admin_views/article/1/history/')
        self.assertEqual(response.status_code, 200)

        # Test redirection when using row-level change permissions. Refs #11513.
        RowLevelChangePermissionModel.objects.create(id=1, name=""odd id"")
        RowLevelChangePermissionModel.objects.create(id=2, name=""even id"")
        for login_dict in [self.super_login, self.changeuser_login, self.adduser_login, self.deleteuser_login]:
            self.client.post('/test_admin/admin/', login_dict)
            response = self.client.get('/test_admin/admin/admin_views/rowlevelchangepermissionmodel/1/history/')
            self.assertEqual(response.status_code, 403)

            response = self.client.get('/test_admin/admin/admin_views/rowlevelchangepermissionmodel/2/history/')
            self.assertEqual(response.status_code, 200)

            self.client.get('/test_admin/admin/logout/')

        for login_dict in [self.joepublic_login, self.no_username_login]:
            self.client.post('/test_admin/admin/', login_dict)
            response = self.client.get('/test_admin/admin/admin_views/rowlevelchangepermissionmodel/1/history/')
            self.assertEqual(response.status_code, 200)
            self.assertContains(response, 'login-form')
            response = self.client.get('/test_admin/admin/admin_views/rowlevelchangepermissionmodel/2/history/')
            self.assertEqual(response.status_code, 200)
            self.assertContains(response, 'login-form')

            self.client.get('/test_admin/admin/logout/')
",,0e7861aec73702f7933ce2a93056f7983939f0d6,CVE-2013-0305,0e7861aec73702f7933ce2a93056f7983939f0d6,https://github.com/django/django,GHSD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR(VAR): """"""VAR VAR VAR VAR VAR.""""""  VAR.VAR.VAR('/VAR/VAR/') VAR.VAR.VAR('/VAR/VAR/', VAR.VAR) VAR = VAR.VAR.VAR('/VAR/VAR/VAR/VAR/1/VAR/') VAR.VAR(VAR.VAR, 403) VAR.VAR.VAR('/VAR/VAR/VAR/')  VAR.VAR.VAR('/VAR/VAR/') VAR.VAR.VAR('/VAR/VAR/', VAR.VAR) VAR = VAR.VAR.VAR('/VAR/VAR/VAR/VAR/1/VAR/') VAR.VAR(VAR.VAR, 200)  VAR.VAR.VAR(VAR=1, VAR=""VAR VAR"") VAR.VAR.VAR(VAR=2, VAR=""VAR VAR"") VAR VAR VAR [VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR]: VAR.VAR.VAR('/VAR/VAR/', VAR) VAR = VAR.VAR.VAR('/VAR/VAR/VAR/VAR/1/VAR/') VAR.VAR(VAR.VAR, 403) VAR = VAR.VAR.VAR('/VAR/VAR/VAR/VAR/2/VAR/') VAR.VAR(VAR.VAR, 200) VAR.VAR.VAR('/VAR/VAR/VAR/') VAR VAR VAR [VAR.VAR, VAR.VAR]: VAR.VAR.VAR('/VAR/VAR/', VAR) VAR = VAR.VAR.VAR('/VAR/VAR/VAR/VAR/1/VAR/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR, 'VAR-VAR') VAR = VAR.VAR.VAR('/VAR/VAR/VAR/VAR/2/VAR/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR, 'VAR-VAR') VAR.VAR.VAR('/VAR/VAR/VAR/') ",8
django_cca0d98118cccf9ae0c6dcf2d6c57fc50469fbf0,tests/file_uploads/tests.py,"CANDIDATE_TRAVERSAL_FILE_NAMES = [
    '/tmp/hax0rd.txt',          # Absolute path, *nix-style.
    'C:\\Windows\\hax0rd.txt',  # Absolute path, win-style.
    'C:/Windows/hax0rd.txt',    # Absolute path, broken-style.
    '\\tmp\\hax0rd.txt',        # Absolute path, broken in a different way.
    '/tmp\\hax0rd.txt',         # Absolute path, broken by mixing.
    'subdir/hax0rd.txt',        # Descendant path, *nix-style.
    'subdir\\hax0rd.txt',       # Descendant path, win-style.
    'sub/dir\\hax0rd.txt',      # Descendant path, mixed.
    '../../hax0rd.txt',         # Relative path, *nix-style.
    '..\\..\\hax0rd.txt',       # Relative path, win-style.
    '../..\\hax0rd.txt',        # Relative path, mixed.
    '..&#x2F;hax0rd.txt',       # HTML entities.
    '..&sol;hax0rd.txt',        # HTML entities.
]

        for i, name in enumerate(CANDIDATE_TRAVERSAL_FILE_NAMES):
        for i, name in enumerate(CANDIDATE_TRAVERSAL_FILE_NAMES):
    def test_filename_traversal_upload(self):
        os.makedirs(UPLOAD_TO, exist_ok=True)
        self.addCleanup(shutil.rmtree, MEDIA_ROOT)
        tests = [
            '..&#x2F;test.txt',
            '..&sol;test.txt',
        ]
        for file_name in tests:
            with self.subTest(file_name=file_name):
                payload = client.FakePayload()
                payload.write(
                    '\r\n'.join([
                        '--' + client.BOUNDARY,
                        'Content-Disposition: form-data; name=""my_file""; '
                        'filename=""%s"";' % file_name,
                        'Content-Type: text/plain',
                        '',
                        'file contents.\r\n',
                        '\r\n--' + client.BOUNDARY + '--\r\n',
                    ]),
                )
                r = {
                    'CONTENT_LENGTH': len(payload),
                    'CONTENT_TYPE': client.MULTIPART_CONTENT,
                    'PATH_INFO': '/upload_traversal/',
                    'REQUEST_METHOD': 'POST',
                    'wsgi.input': payload,
                }
                response = self.client.request(**r)
                result = response.json()
                self.assertEqual(response.status_code, 200)
                self.assertEqual(result['file_name'], 'test.txt')
                self.assertIs(
                    os.path.exists(os.path.join(MEDIA_ROOT, 'test.txt')),
                    False,
                )
                self.assertIs(
                    os.path.exists(os.path.join(UPLOAD_TO, 'test.txt')),
                    True,
                )

    def test_sanitize_file_name(self):
        parser = MultiPartParser({
            'CONTENT_TYPE': 'multipart/form-data; boundary=_foo',
            'CONTENT_LENGTH': '1'
        }, StringIO('x'), [], 'utf-8')
        for file_name in CANDIDATE_TRAVERSAL_FILE_NAMES:
            with self.subTest(file_name=file_name):
                self.assertEqual(parser.sanitize_file_name(file_name), 'hax0rd.txt')
","        scary_file_names = [
            ""/tmp/hax0rd.txt"",          # Absolute path, *nix-style.
            ""C:\\Windows\\hax0rd.txt"",  # Absolute path, win-style.
            ""C:/Windows/hax0rd.txt"",    # Absolute path, broken-style.
            ""\\tmp\\hax0rd.txt"",        # Absolute path, broken in a different way.
            ""/tmp\\hax0rd.txt"",         # Absolute path, broken by mixing.
            ""subdir/hax0rd.txt"",        # Descendant path, *nix-style.
            ""subdir\\hax0rd.txt"",       # Descendant path, win-style.
            ""sub/dir\\hax0rd.txt"",      # Descendant path, mixed.
            ""../../hax0rd.txt"",         # Relative path, *nix-style.
            ""..\\..\\hax0rd.txt"",       # Relative path, win-style.
            ""../..\\hax0rd.txt""         # Relative path, mixed.
        ]

        for i, name in enumerate(scary_file_names):
        for i, name in enumerate(scary_file_names):",cca0d98118cccf9ae0c6dcf2d6c57fc50469fbf0,CVE-2021-28658,cca0d98118cccf9ae0c6dcf2d6c57fc50469fbf0,https://github.com/django/django,GHSD_REGISTRY,88,COMPLETED,"VAR = [ '/VAR/VAR.VAR',  'VAR:\\VAR\\VAR.VAR',  'VAR:/VAR/VAR.VAR',  '\\VAR\\VAR.VAR',  '/VAR\\VAR.VAR',  'VAR/VAR.VAR',  'VAR\\VAR.VAR',  'VAR/VAR\\VAR.VAR',  '../../VAR.VAR',  '..\\..\\VAR.VAR',  '../..\\VAR.VAR',  '..& '..&VAR;VAR.VAR',  ] VAR VAR, VAR VAR VAR(VAR): VAR VAR, VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR(VAR, VAR=VAR) VAR.VAR(VAR.VAR, VAR) VAR = [ '..& '..&VAR;VAR.VAR', ] VAR VAR VAR VAR: VAR VAR.VAR(VAR=VAR): VAR = VAR.VAR() VAR.VAR( '\VAR\VAR'.VAR([ '--' + VAR.VAR, 'VAR-VAR: VAR-VAR; VAR=""VAR""; ' 'VAR=""%VAR"";' % VAR, 'VAR-VAR: VAR/VAR', '', 'VAR VAR.\VAR\VAR', '\VAR\VAR--' + VAR.VAR + '--\VAR\VAR', ]), ) VAR = { 'VAR': VAR(VAR), 'VAR': VAR.VAR, 'VAR': '/VAR/', 'VAR': 'VAR', 'VAR.VAR': VAR, } VAR = VAR.VAR.VAR(**VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR['VAR'], 'VAR.VAR') VAR.VAR( VAR.VAR.VAR(VAR.VAR.VAR(VAR, 'VAR.VAR')), VAR, ) VAR.VAR( VAR.VAR.VAR(VAR.VAR.VAR(VAR, 'VAR.VAR')), VAR, ) VAR VAR(VAR): VAR = VAR({ 'VAR': 'VAR/VAR-VAR; VAR=VAR', 'VAR': '1' }, VAR('VAR'), [], 'VAR-8') VAR VAR VAR VAR: VAR VAR.VAR(VAR=VAR): VAR.VAR(VAR.VAR(VAR), 'VAR.VAR') VAR = [ ""/VAR/VAR.VAR"",  ""VAR:\\VAR\\VAR.VAR"",  ""VAR:/VAR/VAR.VAR"",  ""\\VAR\\VAR.VAR"",  ""/VAR\\VAR.VAR"",  ""VAR/VAR.VAR"",  ""VAR\\VAR.VAR"",  ""VAR/VAR\\VAR.VAR"",  ""../../VAR.VAR"",  ""..\\..\\VAR.VAR"",  ""../..\\VAR.VAR""  ] VAR VAR, VAR VAR VAR(VAR): VAR VAR, VAR VAR VAR(VAR):",8
django_d4d800ca1addc4141e03c5440a849bb64d1582cd,tests/file_uploads/tests.py,"CANDIDATE_TRAVERSAL_FILE_NAMES = [
    '/tmp/hax0rd.txt',          # Absolute path, *nix-style.
    'C:\\Windows\\hax0rd.txt',  # Absolute path, win-style.
    'C:/Windows/hax0rd.txt',    # Absolute path, broken-style.
    '\\tmp\\hax0rd.txt',        # Absolute path, broken in a different way.
    '/tmp\\hax0rd.txt',         # Absolute path, broken by mixing.
    'subdir/hax0rd.txt',        # Descendant path, *nix-style.
    'subdir\\hax0rd.txt',       # Descendant path, win-style.
    'sub/dir\\hax0rd.txt',      # Descendant path, mixed.
    '../../hax0rd.txt',         # Relative path, *nix-style.
    '..\\..\\hax0rd.txt',       # Relative path, win-style.
    '../..\\hax0rd.txt',        # Relative path, mixed.
    '..&#x2F;hax0rd.txt',       # HTML entities.
    '..&sol;hax0rd.txt',        # HTML entities.
]

        for i, name in enumerate(CANDIDATE_TRAVERSAL_FILE_NAMES):
        for i, name in enumerate(CANDIDATE_TRAVERSAL_FILE_NAMES):
    def test_filename_traversal_upload(self):
        os.makedirs(UPLOAD_TO, exist_ok=True)
        self.addCleanup(shutil.rmtree, MEDIA_ROOT)
        tests = [
            '..&#x2F;test.txt',
            '..&sol;test.txt',
        ]
        for file_name in tests:
            with self.subTest(file_name=file_name):
                payload = client.FakePayload()
                payload.write(
                    '\r\n'.join([
                        '--' + client.BOUNDARY,
                        'Content-Disposition: form-data; name=""my_file""; '
                        'filename=""%s"";' % file_name,
                        'Content-Type: text/plain',
                        '',
                        'file contents.\r\n',
                        '\r\n--' + client.BOUNDARY + '--\r\n',
                    ]),
                )
                r = {
                    'CONTENT_LENGTH': len(payload),
                    'CONTENT_TYPE': client.MULTIPART_CONTENT,
                    'PATH_INFO': '/upload_traversal/',
                    'REQUEST_METHOD': 'POST',
                    'wsgi.input': payload,
                }
                response = self.client.request(**r)
                result = response.json()
                self.assertEqual(response.status_code, 200)
                self.assertEqual(result['file_name'], 'test.txt')
                self.assertIs(
                    os.path.exists(os.path.join(MEDIA_ROOT, 'test.txt')),
                    False,
                )
                self.assertIs(
                    os.path.exists(os.path.join(UPLOAD_TO, 'test.txt')),
                    True,
                )

    def test_sanitize_file_name(self):
        parser = MultiPartParser({
            'CONTENT_TYPE': 'multipart/form-data; boundary=_foo',
            'CONTENT_LENGTH': '1'
        }, StringIO('x'), [], 'utf-8')
        for file_name in CANDIDATE_TRAVERSAL_FILE_NAMES:
            with self.subTest(file_name=file_name):
                self.assertEqual(parser.sanitize_file_name(file_name), 'hax0rd.txt')
","        scary_file_names = [
            ""/tmp/hax0rd.txt"",          # Absolute path, *nix-style.
            ""C:\\Windows\\hax0rd.txt"",  # Absolute path, win-style.
            ""C:/Windows/hax0rd.txt"",    # Absolute path, broken-style.
            ""\\tmp\\hax0rd.txt"",        # Absolute path, broken in a different way.
            ""/tmp\\hax0rd.txt"",         # Absolute path, broken by mixing.
            ""subdir/hax0rd.txt"",        # Descendant path, *nix-style.
            ""subdir\\hax0rd.txt"",       # Descendant path, win-style.
            ""sub/dir\\hax0rd.txt"",      # Descendant path, mixed.
            ""../../hax0rd.txt"",         # Relative path, *nix-style.
            ""..\\..\\hax0rd.txt"",       # Relative path, win-style.
            ""../..\\hax0rd.txt""         # Relative path, mixed.
        ]

        for i, name in enumerate(scary_file_names):
        for i, name in enumerate(scary_file_names):",d4d800ca1addc4141e03c5440a849bb64d1582cd,CVE-2021-28658,d4d800ca1addc4141e03c5440a849bb64d1582cd,https://github.com/django/django,GHSD_REGISTRY,152,COMPLETED,"VAR = [ '/VAR/VAR.VAR',  'VAR:\\VAR\\VAR.VAR',  'VAR:/VAR/VAR.VAR',  '\\VAR\\VAR.VAR',  '/VAR\\VAR.VAR',  'VAR/VAR.VAR',  'VAR\\VAR.VAR',  'VAR/VAR\\VAR.VAR',  '../../VAR.VAR',  '..\\..\\VAR.VAR',  '../..\\VAR.VAR',  '..& '..&VAR;VAR.VAR',  ] VAR VAR, VAR VAR VAR(VAR): VAR VAR, VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR(VAR, VAR=VAR) VAR.VAR(VAR.VAR, VAR) VAR = [ '..& '..&VAR;VAR.VAR', ] VAR VAR VAR VAR: VAR VAR.VAR(VAR=VAR): VAR = VAR.VAR() VAR.VAR( '\VAR\VAR'.VAR([ '--' + VAR.VAR, 'VAR-VAR: VAR-VAR; VAR=""VAR""; ' 'VAR=""%VAR"";' % VAR, 'VAR-VAR: VAR/VAR', '', 'VAR VAR.\VAR\VAR', '\VAR\VAR--' + VAR.VAR + '--\VAR\VAR', ]), ) VAR = { 'VAR': VAR(VAR), 'VAR': VAR.VAR, 'VAR': '/VAR/', 'VAR': 'VAR', 'VAR.VAR': VAR, } VAR = VAR.VAR.VAR(**VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR['VAR'], 'VAR.VAR') VAR.VAR( VAR.VAR.VAR(VAR.VAR.VAR(VAR, 'VAR.VAR')), VAR, ) VAR.VAR( VAR.VAR.VAR(VAR.VAR.VAR(VAR, 'VAR.VAR')), VAR, ) VAR VAR(VAR): VAR = VAR({ 'VAR': 'VAR/VAR-VAR; VAR=VAR', 'VAR': '1' }, VAR('VAR'), [], 'VAR-8') VAR VAR VAR VAR: VAR VAR.VAR(VAR=VAR): VAR.VAR(VAR.VAR(VAR), 'VAR.VAR') VAR = [ ""/VAR/VAR.VAR"",  ""VAR:\\VAR\\VAR.VAR"",  ""VAR:/VAR/VAR.VAR"",  ""\\VAR\\VAR.VAR"",  ""/VAR\\VAR.VAR"",  ""VAR/VAR.VAR"",  ""VAR\\VAR.VAR"",  ""VAR/VAR\\VAR.VAR"",  ""../../VAR.VAR"",  ""..\\..\\VAR.VAR"",  ""../..\\VAR.VAR""  ] VAR VAR, VAR VAR VAR(VAR): VAR VAR, VAR VAR VAR(VAR):",8
django_e7fba62248f604c76da4f23dcf1db4a57b0808ea,tests/file_uploads/tests.py,"CANDIDATE_TRAVERSAL_FILE_NAMES = [
    '/tmp/hax0rd.txt',          # Absolute path, *nix-style.
    'C:\\Windows\\hax0rd.txt',  # Absolute path, win-style.
    'C:/Windows/hax0rd.txt',    # Absolute path, broken-style.
    '\\tmp\\hax0rd.txt',        # Absolute path, broken in a different way.
    '/tmp\\hax0rd.txt',         # Absolute path, broken by mixing.
    'subdir/hax0rd.txt',        # Descendant path, *nix-style.
    'subdir\\hax0rd.txt',       # Descendant path, win-style.
    'sub/dir\\hax0rd.txt',      # Descendant path, mixed.
    '../../hax0rd.txt',         # Relative path, *nix-style.
    '..\\..\\hax0rd.txt',       # Relative path, win-style.
    '../..\\hax0rd.txt',        # Relative path, mixed.
    '..&#x2F;hax0rd.txt',       # HTML entities.
    '..&sol;hax0rd.txt',        # HTML entities.
]

        for i, name in enumerate(CANDIDATE_TRAVERSAL_FILE_NAMES):
        for i, name in enumerate(CANDIDATE_TRAVERSAL_FILE_NAMES):
    def test_filename_traversal_upload(self):
        os.makedirs(UPLOAD_TO, exist_ok=True)
        self.addCleanup(shutil.rmtree, MEDIA_ROOT)
        tests = [
            '..&#x2F;test.txt',
            '..&sol;test.txt',
        ]
        for file_name in tests:
            with self.subTest(file_name=file_name):
                payload = client.FakePayload()
                payload.write(
                    '\r\n'.join([
                        '--' + client.BOUNDARY,
                        'Content-Disposition: form-data; name=""my_file""; '
                        'filename=""%s"";' % file_name,
                        'Content-Type: text/plain',
                        '',
                        'file contents.\r\n',
                        '\r\n--' + client.BOUNDARY + '--\r\n',
                    ]),
                )
                r = {
                    'CONTENT_LENGTH': len(payload),
                    'CONTENT_TYPE': client.MULTIPART_CONTENT,
                    'PATH_INFO': '/upload_traversal/',
                    'REQUEST_METHOD': 'POST',
                    'wsgi.input': payload,
                }
                response = self.client.request(**r)
                result = response.json()
                self.assertEqual(response.status_code, 200)
                self.assertEqual(result['file_name'], 'test.txt')
                self.assertIs(
                    os.path.exists(os.path.join(MEDIA_ROOT, 'test.txt')),
                    False,
                )
                self.assertIs(
                    os.path.exists(os.path.join(UPLOAD_TO, 'test.txt')),
                    True,
                )

    def test_sanitize_file_name(self):
        parser = MultiPartParser({
            'CONTENT_TYPE': 'multipart/form-data; boundary=_foo',
            'CONTENT_LENGTH': '1'
        }, StringIO('x'), [], 'utf-8')
        for file_name in CANDIDATE_TRAVERSAL_FILE_NAMES:
            with self.subTest(file_name=file_name):
                self.assertEqual(parser.sanitize_file_name(file_name), 'hax0rd.txt')
","        scary_file_names = [
            ""/tmp/hax0rd.txt"",          # Absolute path, *nix-style.
            ""C:\\Windows\\hax0rd.txt"",  # Absolute path, win-style.
            ""C:/Windows/hax0rd.txt"",    # Absolute path, broken-style.
            ""\\tmp\\hax0rd.txt"",        # Absolute path, broken in a different way.
            ""/tmp\\hax0rd.txt"",         # Absolute path, broken by mixing.
            ""subdir/hax0rd.txt"",        # Descendant path, *nix-style.
            ""subdir\\hax0rd.txt"",       # Descendant path, win-style.
            ""sub/dir\\hax0rd.txt"",      # Descendant path, mixed.
            ""../../hax0rd.txt"",         # Relative path, *nix-style.
            ""..\\..\\hax0rd.txt"",       # Relative path, win-style.
            ""../..\\hax0rd.txt""         # Relative path, mixed.
        ]

        for i, name in enumerate(scary_file_names):
        for i, name in enumerate(scary_file_names):",e7fba62248f604c76da4f23dcf1db4a57b0808ea,CVE-2021-28658,e7fba62248f604c76da4f23dcf1db4a57b0808ea,https://github.com/django/django,GHSD_REGISTRY,88,COMPLETED,"VAR = [ '/VAR/VAR.VAR',  'VAR:\\VAR\\VAR.VAR',  'VAR:/VAR/VAR.VAR',  '\\VAR\\VAR.VAR',  '/VAR\\VAR.VAR',  'VAR/VAR.VAR',  'VAR\\VAR.VAR',  'VAR/VAR\\VAR.VAR',  '../../VAR.VAR',  '..\\..\\VAR.VAR',  '../..\\VAR.VAR',  '..& '..&VAR;VAR.VAR',  ] VAR VAR, VAR VAR VAR(VAR): VAR VAR, VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR(VAR, VAR=VAR) VAR.VAR(VAR.VAR, VAR) VAR = [ '..& '..&VAR;VAR.VAR', ] VAR VAR VAR VAR: VAR VAR.VAR(VAR=VAR): VAR = VAR.VAR() VAR.VAR( '\VAR\VAR'.VAR([ '--' + VAR.VAR, 'VAR-VAR: VAR-VAR; VAR=""VAR""; ' 'VAR=""%VAR"";' % VAR, 'VAR-VAR: VAR/VAR', '', 'VAR VAR.\VAR\VAR', '\VAR\VAR--' + VAR.VAR + '--\VAR\VAR', ]), ) VAR = { 'VAR': VAR(VAR), 'VAR': VAR.VAR, 'VAR': '/VAR/', 'VAR': 'VAR', 'VAR.VAR': VAR, } VAR = VAR.VAR.VAR(**VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR['VAR'], 'VAR.VAR') VAR.VAR( VAR.VAR.VAR(VAR.VAR.VAR(VAR, 'VAR.VAR')), VAR, ) VAR.VAR( VAR.VAR.VAR(VAR.VAR.VAR(VAR, 'VAR.VAR')), VAR, ) VAR VAR(VAR): VAR = VAR({ 'VAR': 'VAR/VAR-VAR; VAR=VAR', 'VAR': '1' }, VAR('VAR'), [], 'VAR-8') VAR VAR VAR VAR: VAR VAR.VAR(VAR=VAR): VAR.VAR(VAR.VAR(VAR), 'VAR.VAR') VAR = [ ""/VAR/VAR.VAR"",  ""VAR:\\VAR\\VAR.VAR"",  ""VAR:/VAR/VAR.VAR"",  ""\\VAR\\VAR.VAR"",  ""/VAR\\VAR.VAR"",  ""VAR/VAR.VAR"",  ""VAR\\VAR.VAR"",  ""VAR/VAR\\VAR.VAR"",  ""../../VAR.VAR"",  ""..\\..\\VAR.VAR"",  ""../..\\VAR.VAR""  ] VAR VAR, VAR VAR VAR(VAR): VAR VAR, VAR VAR VAR(VAR):",8
envoy_2c60632d41555ec8b3d9ef5246242be637a2db0f,test/extensions/filters/http/rbac/rbac_filter_integration_test.cc,"const std::string RBAC_CONFIG_HEADER_MATCH_CONDITION = R""EOF(
name: rbac
typed_config:
  ""@type"": type.googleapis.com/envoy.extensions.filters.http.rbac.v3.RBAC
  rules:
    policies:
      foo:
        permissions:
          - any: true
        principals:
          - any: true
        condition:
          call_expr:
            function: _==_
            args:
            - select_expr:
                operand:
                  select_expr:
                    operand:
                      ident_expr:
                        name: request
                    field: headers
                field: xxx
            - const_expr:
               string_value: {}
)EOF"";

// Basic CEL match on a header value.
TEST_P(RBACIntegrationTest, HeaderMatchCondition) {
  config_helper_.addFilter(fmt::format(RBAC_CONFIG_HEADER_MATCH_CONDITION, ""yyy""));
  initialize();

  codec_client_ = makeHttpConnection(lookupPort(""http""));

  auto response = codec_client_->makeRequestWithBody(
      Http::TestRequestHeaderMapImpl{
          {"":method"", ""POST""},
          {"":path"", ""/path""},
          {"":scheme"", ""http""},
          {"":authority"", ""host""},
          {""xxx"", ""yyy""},
      },
      1024);
  waitForNextUpstreamRequest();
  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);

  response->waitForEndStream();
  ASSERT_TRUE(response->complete());
  EXPECT_EQ(""200"", response->headers().getStatusValue());
}

// CEL match on a header value in which the header is a duplicate. Verifies we handle string
// copying correctly inside the CEL expression.
TEST_P(RBACIntegrationTest, HeaderMatchConditionDuplicateHeaderNoMatch) {
  config_helper_.addFilter(fmt::format(RBAC_CONFIG_HEADER_MATCH_CONDITION, ""yyy""));
  initialize();

  codec_client_ = makeHttpConnection(lookupPort(""http""));

  auto response = codec_client_->makeRequestWithBody(
      Http::TestRequestHeaderMapImpl{
          {"":method"", ""POST""},
          {"":path"", ""/path""},
          {"":scheme"", ""http""},
          {"":authority"", ""host""},
          {""xxx"", ""yyy""},
          {""xxx"", ""zzz""},
      },
      1024);
  response->waitForEndStream();
  ASSERT_TRUE(response->complete());
  EXPECT_EQ(""403"", response->headers().getStatusValue());
}

// CEL match on a header value in which the header is a duplicate. Verifies we handle string
// copying correctly inside the CEL expression.
TEST_P(RBACIntegrationTest, HeaderMatchConditionDuplicateHeaderMatch) {
  config_helper_.addFilter(fmt::format(RBAC_CONFIG_HEADER_MATCH_CONDITION, ""yyy,zzz""));
  initialize();

  codec_client_ = makeHttpConnection(lookupPort(""http""));

  auto response = codec_client_->makeRequestWithBody(
      Http::TestRequestHeaderMapImpl{
          {"":method"", ""POST""},
          {"":path"", ""/path""},
          {"":scheme"", ""http""},
          {"":authority"", ""host""},
          {""xxx"", ""yyy""},
          {""xxx"", ""zzz""},
      },
      1024);
  waitForNextUpstreamRequest();
  upstream_request_->encodeHeaders(Http::TestResponseHeaderMapImpl{{"":status"", ""200""}}, true);

  response->waitForEndStream();
  ASSERT_TRUE(response->complete());
  EXPECT_EQ(""200"", response->headers().getStatusValue());
}
",,2c60632d41555ec8b3d9ef5246242be637a2db0f,CVE-2020-25017,2c60632d41555ec8b3d9ef5246242be637a2db0f,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,102,COMPLETED,"VAR VAR::VAR VAR = VAR""VAR( VAR: VAR VAR: ""@VAR"": VAR.VAR.VAR/VAR.VAR.VAR.VAR.VAR.VAR.VAR VAR: VAR: VAR: VAR: - VAR: VAR VAR: - VAR: VAR VAR: VAR: VAR: VAR==VAR VAR: - VAR: VAR: VAR: VAR: VAR: VAR: VAR VAR: VAR VAR: VAR - VAR: VAR: {} )VAR"";  VAR(VAR, VAR) { VAR.VAR(VAR::VAR(VAR, ""VAR"")); VAR(); VAR = VAR(VAR(""VAR"")); VAR VAR = VAR->VAR( VAR::VAR{ {"":VAR"", ""VAR""}, {"":VAR"", ""/VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR""}, {""VAR"", ""VAR""}, }, 1024); VAR(); VAR->VAR(VAR::VAR{{"":VAR"", ""200""}}, VAR); VAR->VAR(); VAR(VAR->VAR()); VAR(""200"", VAR->VAR().VAR()); }   VAR(VAR, VAR) { VAR.VAR(VAR::VAR(VAR, ""VAR"")); VAR(); VAR = VAR(VAR(""VAR"")); VAR VAR = VAR->VAR( VAR::VAR{ {"":VAR"", ""VAR""}, {"":VAR"", ""/VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR""}, {""VAR"", ""VAR""}, {""VAR"", ""VAR""}, }, 1024); VAR->VAR(); VAR(VAR->VAR()); VAR(""403"", VAR->VAR().VAR()); }   VAR(VAR, VAR) { VAR.VAR(VAR::VAR(VAR, ""VAR,VAR"")); VAR(); VAR = VAR(VAR(""VAR"")); VAR VAR = VAR->VAR( VAR::VAR{ {"":VAR"", ""VAR""}, {"":VAR"", ""/VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR""}, {""VAR"", ""VAR""}, {""VAR"", ""VAR""}, }, 1024); VAR(); VAR->VAR(VAR::VAR{{"":VAR"", ""200""}}, VAR); VAR->VAR(); VAR(VAR->VAR()); VAR(""200"", VAR->VAR().VAR()); } ",8
envoy_5333b928d8bcffa26ab19bf018369a835f697585,test/integration/header_integration_test.cc,"          hcm.set_path_with_escaped_slashes_action(path_with_escaped_slashes_action_);
  void compareHeaders(Headers&& headers, const ExpectedHeaders& expected_headers) {
    EXPECT_THAT(&headers, HeaderMapEqualIgnoreOrder(&expected_headers));
  envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
      PathWithEscapedSlashesAction path_with_escaped_slashes_action_{
          envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager::
              KEEP_UNCHANGED};
// Validates that Envoy by default does not modify escaped slashes.
TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesByDefaultUnchanghed) {
  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
      v3::HttpConnectionManager::IMPLEMENTATION_SPECIFIC_DEFAULT;
  normalize_path_ = true;
  initializeFilter(HeaderMode::Append, false);
  performRequest(
      Http::TestRequestHeaderMapImpl{
          {"":method"", ""GET""},
          {"":path"", ""/private/..%2Fpublic%5c""},
          {"":scheme"", ""http""},
          {"":authority"", ""path-sanitization.com""},
      },
      Http::TestRequestHeaderMapImpl{{"":authority"", ""path-sanitization.com""},
                                     {"":path"", ""/private/..%2Fpublic%5c""},
                                     {"":method"", ""GET""},
                                     {""x-site"", ""private""}},
      Http::TestResponseHeaderMapImpl{
          {""server"", ""envoy""},
          {""content-length"", ""0""},
          {"":status"", ""200""},
          {""x-unmodified"", ""response""},
      },
      Http::TestResponseHeaderMapImpl{
          {""server"", ""envoy""},
          {""x-unmodified"", ""response""},
          {"":status"", ""200""},
      });
}

// Validates that default action can be overridden through runtime.
TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesDefaultOverriden) {
  // Override the default action to REJECT
  config_helper_.addRuntimeOverride(""http_connection_manager.path_with_escaped_slashes_action"",
                                    ""2"");
  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
      v3::HttpConnectionManager::IMPLEMENTATION_SPECIFIC_DEFAULT;
  initializeFilter(HeaderMode::Append, false);
  registerTestServerPorts({""http""});
  codec_client_ = makeHttpConnection(makeClientConnection(lookupPort(""http"")));
  IntegrationStreamDecoderPtr response =
      codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{
          {"":method"", ""GET""},
          {"":path"", ""/private%2f../public""},
          {"":scheme"", ""http""},
          {"":authority"", ""path-sanitization.com""},
      });
  EXPECT_TRUE(response->waitForEndStream());
  Http::TestResponseHeaderMapImpl response_headers{response->headers()};
  compareHeaders(response_headers, Http::TestResponseHeaderMapImpl{
                                       {""server"", ""envoy""},
                                       {""connection"", ""close""},
                                       {"":status"", ""400""},
                                   });
}

TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesRejected) {
  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
      v3::HttpConnectionManager::REJECT_REQUEST;
  initializeFilter(HeaderMode::Append, false);
  registerTestServerPorts({""http""});
  codec_client_ = makeHttpConnection(makeClientConnection(lookupPort(""http"")));
  IntegrationStreamDecoderPtr response =
      codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{
          {"":method"", ""GET""},
          {"":path"", ""/private%2f../public""},
          {"":scheme"", ""http""},
          {"":authority"", ""path-sanitization.com""},
      });
  EXPECT_TRUE(response->waitForEndStream());
  Http::TestResponseHeaderMapImpl response_headers{response->headers()};
  compareHeaders(response_headers, Http::TestResponseHeaderMapImpl{
                                       {""server"", ""envoy""},
                                       {""connection"", ""close""},
                                       {"":status"", ""400""},
                                   });
}

// Validates that Envoy does not modify escaped slashes when configured.
TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesUnmodified) {
  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
      v3::HttpConnectionManager::KEEP_UNCHANGED;
  normalize_path_ = true;
  initializeFilter(HeaderMode::Append, false);
  performRequest(
      Http::TestRequestHeaderMapImpl{
          {"":method"", ""GET""},
          {"":path"", ""/private/..%2Fpublic%5c""},
          {"":scheme"", ""http""},
          {"":authority"", ""path-sanitization.com""},
      },
      Http::TestRequestHeaderMapImpl{{"":authority"", ""path-sanitization.com""},
                                     {"":path"", ""/private/..%2Fpublic%5c""},
                                     {"":method"", ""GET""},
                                     {""x-site"", ""private""}},
      Http::TestResponseHeaderMapImpl{
          {""server"", ""envoy""},
          {""content-length"", ""0""},
          {"":status"", ""200""},
          {""x-unmodified"", ""response""},
      },
      Http::TestResponseHeaderMapImpl{
          {""server"", ""envoy""},
          {""x-unmodified"", ""response""},
          {"":status"", ""200""},
      });
}

// Validates that Envoy forwards unescaped slashes when configured.
TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesAndNormalizationForwarded) {
  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
      v3::HttpConnectionManager::UNESCAPE_AND_FORWARD;
  normalize_path_ = true;
  initializeFilter(HeaderMode::Append, false);
  performRequest(
      Http::TestRequestHeaderMapImpl{
          {"":method"", ""GET""},
          {"":path"", ""/private/..%2Fpublic%5c%2e%2Fabc""},
          {"":scheme"", ""http""},
          {"":authority"", ""path-sanitization.com""},
      },
      Http::TestRequestHeaderMapImpl{{"":authority"", ""path-sanitization.com""},
                                     {"":path"", ""/public/abc""},
                                     {"":method"", ""GET""},
                                     {""x-site"", ""public""}},
      Http::TestResponseHeaderMapImpl{
          {""server"", ""envoy""},
          {""content-length"", ""0""},
          {"":status"", ""200""},
          {""x-unmodified"", ""response""},
      },
      Http::TestResponseHeaderMapImpl{
          {""server"", ""envoy""},
          {""x-unmodified"", ""response""},
          {"":status"", ""200""},
      });
}

TEST_P(HeaderIntegrationTest, PathWithEscapedSlashesRedirected) {
  path_with_escaped_slashes_action_ = envoy::extensions::filters::network::http_connection_manager::
      v3::HttpConnectionManager::UNESCAPE_AND_REDIRECT;
  initializeFilter(HeaderMode::Append, false);
  registerTestServerPorts({""http""});
  codec_client_ = makeHttpConnection(makeClientConnection(lookupPort(""http"")));
  IntegrationStreamDecoderPtr response =
      codec_client_->makeHeaderOnlyRequest(Http::TestRequestHeaderMapImpl{
          {"":method"", ""GET""},
          {"":path"", ""/private%2f../%2e%5Cpublic""},
          {"":scheme"", ""http""},
          {"":authority"", ""path-sanitization.com""},
      });
  EXPECT_TRUE(response->waitForEndStream());
  Http::TestResponseHeaderMapImpl response_headers{response->headers()};
  compareHeaders(response_headers, Http::TestResponseHeaderMapImpl{
                                       {""server"", ""envoy""},
                                       {""location"", ""/private/../%2e\\public""},
                                       {"":status"", ""307""},
                                   });
}
","  void compareHeaders(Headers&& headers, ExpectedHeaders& expected_headers) {
    EXPECT_EQ(expected_headers, headers);",5333b928d8bcffa26ab19bf018369a835f697585,CVE-2021-29492,5333b928d8bcffa26ab19bf018369a835f697585,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,162,COMPLETED,"VAR.VAR(VAR); VAR VAR(VAR&& VAR, VAR VAR& VAR) { VAR(&VAR, VAR(&VAR)); VAR::VAR::VAR::VAR::VAR::VAR::VAR:: VAR VAR{ VAR::VAR::VAR::VAR::VAR::VAR::VAR:: VAR};  VAR(VAR, VAR) { VAR = VAR::VAR::VAR::VAR::VAR:: VAR::VAR::VAR; VAR = VAR; VAR(VAR::VAR, VAR); VAR( VAR::VAR{ {"":VAR"", ""VAR""}, {"":VAR"", ""/VAR/..%2Fpublic%5c""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR-VAR.VAR""}, }, VAR::VAR{{"":VAR"", ""VAR-VAR.VAR""}, {"":VAR"", ""/VAR/..%2Fpublic%5c""}, {"":VAR"", ""VAR""}, {""VAR-VAR"", ""VAR""}}, VAR::VAR{ {""VAR"", ""VAR""}, {""VAR-VAR"", ""0""}, {"":VAR"", ""200""}, {""VAR-VAR"", ""VAR""}, }, VAR::VAR{ {""VAR"", ""VAR""}, {""VAR-VAR"", ""VAR""}, {"":VAR"", ""200""}, }); }  VAR(VAR, VAR) {  VAR.VAR(""VAR.VAR"", ""2""); VAR = VAR::VAR::VAR::VAR::VAR:: VAR::VAR::VAR; VAR(VAR::VAR, VAR); VAR({""VAR""}); VAR = VAR(VAR(VAR(""VAR""))); VAR VAR = VAR->VAR(VAR::VAR{ {"":VAR"", ""VAR""}, {"":VAR"", ""/VAR%2f../VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR-VAR.VAR""}, }); VAR(VAR->VAR()); VAR::VAR VAR{VAR->VAR()}; VAR(VAR, VAR::VAR{ {""VAR"", ""VAR""}, {""VAR"", ""VAR""}, {"":VAR"", ""400""}, }); } VAR(VAR, VAR) { VAR = VAR::VAR::VAR::VAR::VAR:: VAR::VAR::VAR; VAR(VAR::VAR, VAR); VAR({""VAR""}); VAR = VAR(VAR(VAR(""VAR""))); VAR VAR = VAR->VAR(VAR::VAR{ {"":VAR"", ""VAR""}, {"":VAR"", ""/VAR%2f../VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR-VAR.VAR""}, }); VAR(VAR->VAR()); VAR::VAR VAR{VAR->VAR()}; VAR(VAR, VAR::VAR{ {""VAR"", ""VAR""}, {""VAR"", ""VAR""}, {"":VAR"", ""400""}, }); }  VAR(VAR, VAR) { VAR = VAR::VAR::VAR::VAR::VAR:: VAR::VAR::VAR; VAR = VAR; VAR(VAR::VAR, VAR); VAR( VAR::VAR{ {"":VAR"", ""VAR""}, {"":VAR"", ""/VAR/..%2Fpublic%5c""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR-VAR.VAR""}, }, VAR::VAR{{"":VAR"", ""VAR-VAR.VAR""}, {"":VAR"", ""/VAR/..%2Fpublic%5c""}, {"":VAR"", ""VAR""}, {""VAR-VAR"", ""VAR""}}, VAR::VAR{ {""VAR"", ""VAR""}, {""VAR-VAR"", ""0""}, {"":VAR"", ""200""}, {""VAR-VAR"", ""VAR""}, }, VAR::VAR{ {""VAR"", ""VAR""}, {""VAR-VAR"", ""VAR""}, {"":VAR"", ""200""}, }); }  VAR(VAR, VAR) { VAR = VAR::VAR::VAR::VAR::VAR:: VAR::VAR::VAR; VAR = VAR; VAR(VAR::VAR, VAR); VAR( VAR::VAR{ {"":VAR"", ""VAR""}, {"":VAR"", ""/VAR/..%2Fpublic%5c%2e%2Fabc""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR-VAR.VAR""}, }, VAR::VAR{{"":VAR"", ""VAR-VAR.VAR""}, {"":VAR"", ""/VAR/VAR""}, {"":VAR"", ""VAR""}, {""VAR-VAR"", ""VAR""}}, VAR::VAR{ {""VAR"", ""VAR""}, {""VAR-VAR"", ""0""}, {"":VAR"", ""200""}, {""VAR-VAR"", ""VAR""}, }, VAR::VAR{ {""VAR"", ""VAR""}, {""VAR-VAR"", ""VAR""}, {"":VAR"", ""200""}, }); } VAR(VAR, VAR) { VAR = VAR::VAR::VAR::VAR::VAR:: VAR::VAR::VAR; VAR(VAR::VAR, VAR); VAR({""VAR""}); VAR = VAR(VAR(VAR(""VAR""))); VAR VAR = VAR->VAR(VAR::VAR{ {"":VAR"", ""VAR""}, {"":VAR"", ""/VAR%2f../%2e%5Cpublic""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR-VAR.VAR""}, }); VAR(VAR->VAR()); VAR::VAR VAR{VAR->VAR()}; VAR(VAR, VAR::VAR{ {""VAR"", ""VAR""}, {""VAR"", ""/VAR/../%2e\\VAR""}, {"":VAR"", ""307""}, }); } VAR VAR(VAR&& VAR, VAR& VAR) { VAR(VAR, VAR);",8
envoy_65c05cad96db7f7874e1e5a2b70829dcfad10e88,test/common/http/conn_manager_impl_test.cc,"      ssl_connection_ = std::make_unique<Ssl::MockConnectionInfo>();
  std::unique_ptr<Ssl::MockConnectionInfo> ssl_connection_;
TEST_F(HttpConnectionManagerImplTest, TestAccessLogSsl) {
  setup(true, """");

  std::shared_ptr<MockStreamDecoderFilter> filter(new NiceMock<MockStreamDecoderFilter>());
  std::shared_ptr<AccessLog::MockInstance> handler(new NiceMock<AccessLog::MockInstance>());

  EXPECT_CALL(filter_factory_, createFilterChain(_))
      .WillOnce(Invoke([&](FilterChainFactoryCallbacks& callbacks) -> void {
        callbacks.addStreamDecoderFilter(filter);
        callbacks.addAccessLogHandler(handler);
      }));

  EXPECT_CALL(*handler, log(_, _, _, _))
      .WillOnce(Invoke([](const HeaderMap*, const HeaderMap*, const HeaderMap*,
                          const StreamInfo::StreamInfo& stream_info) {
        EXPECT_TRUE(stream_info.responseCode());
        EXPECT_EQ(stream_info.responseCode().value(), uint32_t(200));
        EXPECT_NE(nullptr, stream_info.downstreamLocalAddress());
        EXPECT_NE(nullptr, stream_info.downstreamRemoteAddress());
        EXPECT_NE(nullptr, stream_info.downstreamDirectRemoteAddress());
        EXPECT_NE(nullptr, stream_info.downstreamSslConnection());
        EXPECT_NE(nullptr, stream_info.routeEntry());
      }));

  StreamDecoder* decoder = nullptr;
  NiceMock<MockStreamEncoder> encoder;
  EXPECT_CALL(*codec_, dispatch(_)).WillRepeatedly(Invoke([&](Buffer::Instance& data) -> void {
    decoder = &conn_manager_->newStream(encoder);

    HeaderMapPtr headers{
        new TestHeaderMapImpl{{"":method"", ""GET""},
                              {"":authority"", ""host""},
                              {"":path"", ""/""},
                              {""x-request-id"", ""125a4afb-6f55-a4ba-ad80-413f09f48a28""}}};
    decoder->decodeHeaders(std::move(headers), true);

    HeaderMapPtr response_headers{new TestHeaderMapImpl{{"":status"", ""200""}}};
    filter->callbacks_->encodeHeaders(std::move(response_headers), false);

    HeaderMapPtr response_trailers{new TestHeaderMapImpl{{""x-trailer"", ""1""}}};
    filter->callbacks_->encodeTrailers(std::move(response_trailers));

    data.drain(4);
  }));

  Buffer::OwnedImpl fake_input(""1234"");
  conn_manager_->onData(fake_input, false);
}
","      ssl_connection_ = std::make_unique<Ssl::MockConnection>();
  std::unique_ptr<Ssl::MockConnection> ssl_connection_;",65c05cad96db7f7874e1e5a2b70829dcfad10e88,CVE-2019-9900,65c05cad96db7f7874e1e5a2b70829dcfad10e88,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,74,COMPLETED,"VAR = VAR::VAR<VAR::VAR>(); VAR::VAR<VAR::VAR> VAR; VAR(VAR, VAR) { VAR(VAR, """"); VAR::VAR<VAR> VAR(VAR VAR<VAR>()); VAR::VAR<VAR::VAR> VAR(VAR VAR<VAR::VAR>()); VAR(VAR, VAR(VAR)) .VAR(VAR([&](VAR& VAR) -> VAR { VAR.VAR(VAR); VAR.VAR(VAR); })); VAR(*VAR, VAR(VAR, VAR, VAR, VAR)) .VAR(VAR([](VAR VAR*, VAR VAR*, VAR VAR*, VAR VAR::VAR& VAR) { VAR(VAR.VAR()); VAR(VAR.VAR().VAR(), VAR(200)); VAR(VAR, VAR.VAR()); VAR(VAR, VAR.VAR()); VAR(VAR, VAR.VAR()); VAR(VAR, VAR.VAR()); VAR(VAR, VAR.VAR()); })); VAR* VAR = VAR; VAR<VAR> VAR; VAR(*VAR, VAR(VAR)).VAR(VAR([&](VAR::VAR& VAR) -> VAR { VAR = &VAR->VAR(VAR); VAR VAR{ VAR VAR{{"":VAR"", ""VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""/""}, {""VAR-VAR-VAR"", ""125a4afb-6f55-VAR-VAR-413f09f48a28""}}}; VAR->VAR(VAR::VAR(VAR), VAR); VAR VAR{VAR VAR{{"":VAR"", ""200""}}}; VAR->VAR->VAR(VAR::VAR(VAR), VAR); VAR VAR{VAR VAR{{""VAR-VAR"", ""1""}}}; VAR->VAR->VAR(VAR::VAR(VAR)); VAR.VAR(4); })); VAR::VAR VAR(""1234""); VAR->VAR(VAR, VAR); } VAR = VAR::VAR<VAR::VAR>(); VAR::VAR<VAR::VAR> VAR;",8
envoy_6a6ac1ccf928aa9866f19e2cf151c5dd339bb8e6,test/common/http/http1/codec_impl_test.cc,"  // Send the request, and validate the received request headers.
  // Then send a response just to clean up.
  void sendAndValidateRequestAndSendResponse(absl::string_view raw_request,
                                             const TestHeaderMapImpl& expected_request_headers) {
    NiceMock<Http::MockStreamDecoder> decoder;
    Http::StreamEncoder* response_encoder = nullptr;
    EXPECT_CALL(callbacks_, newStream(_, _))
        .Times(1)
        .WillOnce(Invoke([&](Http::StreamEncoder& encoder, bool) -> Http::StreamDecoder& {
          response_encoder = &encoder;
          return decoder;
        }));
    EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_request_headers), true)).Times(1);
    Buffer::OwnedImpl buffer(raw_request);
    codec_->dispatch(buffer);
    EXPECT_EQ(0U, buffer.length());
    response_encoder->encodeHeaders(TestHeaderMapImpl{{"":status"", ""200""}}, true);
  }

TEST_F(Http1ServerConnectionImplTest, HostWithLWS) {
  initialize();

  TestHeaderMapImpl expected_headers{{"":authority"", ""host""}, {"":path"", ""/""}, {"":method"", ""GET""}};

  // Regression test spaces before and after the host header value.
  sendAndValidateRequestAndSendResponse(""GET / HTTP/1.1\r\nHost: host \r\n\r\n"", expected_headers);

  // Regression test tabs before and after the host header value.
  sendAndValidateRequestAndSendResponse(""GET / HTTP/1.1\r\nHost:	host	\r\n\r\n"",
                                        expected_headers);

  // Regression test mixed spaces and tabs before and after the host header value.
  sendAndValidateRequestAndSendResponse(
      ""GET / HTTP/1.1\r\nHost: 	 	  host		  	 \r\n\r\n"", expected_headers);
}

  TestScopedRuntime scoped_runtime;
  Runtime::LoaderSingleton::getExisting()->mergeValues(
      {{""envoy.reloadable_features.strict_header_validation"", ""false""}});",,6a6ac1ccf928aa9866f19e2cf151c5dd339bb8e6,CVE-2019-18802,6a6ac1ccf928aa9866f19e2cf151c5dd339bb8e6,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED,"  VAR VAR(VAR::VAR VAR, VAR VAR& VAR) { VAR<VAR::VAR> VAR; VAR::VAR* VAR = VAR; VAR(VAR, VAR(VAR, VAR)) .VAR(1) .VAR(VAR([&](VAR::VAR& VAR, VAR) -> VAR::VAR& { VAR = &VAR; VAR VAR; })); VAR(VAR, VAR(VAR(&VAR), VAR)).VAR(1); VAR::VAR VAR(VAR); VAR->VAR(VAR); VAR(0U, VAR.VAR()); VAR->VAR(VAR{{"":VAR"", ""200""}}, VAR); } VAR(VAR, VAR) { VAR(); VAR VAR{{"":VAR"", ""VAR""}, {"":VAR"", ""/""}, {"":VAR"", ""VAR""}};  VAR(""VAR / VAR/1.1\VAR\VAR: VAR \VAR\VAR\VAR\VAR"", VAR);  VAR(""VAR / VAR/1.1\VAR\VAR: VAR \VAR\VAR\VAR\VAR"", VAR);  VAR( ""VAR / VAR/1.1\VAR\VAR: VAR \VAR\VAR\VAR\VAR"", VAR); } VAR VAR; VAR::VAR::VAR()->VAR( {{""VAR.VAR.VAR"", ""VAR""}}); ",8
envoy_6a95a21ce49d1144d3cde7159c767c192a44d8a4,test/common/http/http1/codec_impl_test.cc,"  // Send the request, and validate the received request headers.
  // Then send a response just to clean up.
  void sendAndValidateRequestAndSendResponse(absl::string_view raw_request,
                                             const TestHeaderMapImpl& expected_request_headers) {
    NiceMock<Http::MockStreamDecoder> decoder;
    Http::StreamEncoder* response_encoder = nullptr;
    EXPECT_CALL(callbacks_, newStream(_, _))
        .Times(1)
        .WillOnce(Invoke([&](Http::StreamEncoder& encoder, bool) -> Http::StreamDecoder& {
          response_encoder = &encoder;
          return decoder;
        }));
    EXPECT_CALL(decoder, decodeHeaders_(HeaderMapEqual(&expected_request_headers), true)).Times(1);
    Buffer::OwnedImpl buffer(raw_request);
    codec_->dispatch(buffer);
    EXPECT_EQ(0U, buffer.length());
    response_encoder->encodeHeaders(TestHeaderMapImpl{{"":status"", ""200""}}, true);
  }

TEST_F(Http1ServerConnectionImplTest, HostWithLWS) {
  initialize();

  TestHeaderMapImpl expected_headers{{"":authority"", ""host""}, {"":path"", ""/""}, {"":method"", ""GET""}};

  // Regression test spaces before and after the host header value.
  sendAndValidateRequestAndSendResponse(""GET / HTTP/1.1\r\nHost: host \r\n\r\n"", expected_headers);

  // Regression test tabs before and after the host header value.
  sendAndValidateRequestAndSendResponse(""GET / HTTP/1.1\r\nHost:	host	\r\n\r\n"",
                                        expected_headers);

  // Regression test mixed spaces and tabs before and after the host header value.
  sendAndValidateRequestAndSendResponse(
      ""GET / HTTP/1.1\r\nHost: 	 	  host		  	 \r\n\r\n"", expected_headers);
}
",,6a95a21ce49d1144d3cde7159c767c192a44d8a4,CVE-2019-18802,6a95a21ce49d1144d3cde7159c767c192a44d8a4,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED,"  VAR VAR(VAR::VAR VAR, VAR VAR& VAR) { VAR<VAR::VAR> VAR; VAR::VAR* VAR = VAR; VAR(VAR, VAR(VAR, VAR)) .VAR(1) .VAR(VAR([&](VAR::VAR& VAR, VAR) -> VAR::VAR& { VAR = &VAR; VAR VAR; })); VAR(VAR, VAR(VAR(&VAR), VAR)).VAR(1); VAR::VAR VAR(VAR); VAR->VAR(VAR); VAR(0U, VAR.VAR()); VAR->VAR(VAR{{"":VAR"", ""200""}}, VAR); } VAR(VAR, VAR) { VAR(); VAR VAR{{"":VAR"", ""VAR""}, {"":VAR"", ""/""}, {"":VAR"", ""VAR""}};  VAR(""VAR / VAR/1.1\VAR\VAR: VAR \VAR\VAR\VAR\VAR"", VAR);  VAR(""VAR / VAR/1.1\VAR\VAR: VAR \VAR\VAR\VAR\VAR"", VAR);  VAR( ""VAR / VAR/1.1\VAR\VAR: VAR \VAR\VAR\VAR\VAR"", VAR); } ",8
envoy_afc39bea36fd436e54262f150c009e8d72db5014,test/integration/protocol_integration_test.cc,"// Validate that lots of tiny cookies doesn't cause a DoS (single cookie header).
TEST_P(DownstreamProtocolIntegrationTest, LargeCookieParsingConcatenated) {
  initialize();

  codec_client_ = makeHttpConnection(lookupPort(""http""));
  Http::TestHeaderMapImpl request_headers{{"":method"", ""POST""},
                                          {"":path"", ""/test/long/url""},
                                          {"":scheme"", ""http""},
                                          {"":authority"", ""host""},
                                          {""content-length"", ""0""}};
  std::vector<std::string> cookie_pieces;
  for (int i = 0; i < 7000; i++) {
    cookie_pieces.push_back(fmt::sprintf(""a%x=b"", i));
  }
  request_headers.addCopy(""cookie"", absl::StrJoin(cookie_pieces, ""; ""));
  auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);

  ASSERT_TRUE(response->complete());
  EXPECT_EQ(""200"", response->headers().Status()->value().getStringView());
}

// Validate that lots of tiny cookies doesn't cause a DoS (many cookie headers).
TEST_P(DownstreamProtocolIntegrationTest, LargeCookieParsingMany) {
  initialize();

  codec_client_ = makeHttpConnection(lookupPort(""http""));
  Http::TestHeaderMapImpl request_headers{{"":method"", ""POST""},
                                          {"":path"", ""/test/long/url""},
                                          {"":scheme"", ""http""},
                                          {"":authority"", ""host""},
                                          {""content-length"", ""0""}};
  for (int i = 0; i < 2000; i++) {
    request_headers.addCopy(""cookie"", fmt::sprintf(""a%x=b"", i));
  }
  auto response = sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);

  ASSERT_TRUE(response->complete());
  EXPECT_EQ(""200"", response->headers().Status()->value().getStringView());
}

TEST_P(DownstreamProtocolIntegrationTest, ManyRequestHeadersTimeout) {
  // Set timeout for 5 seconds, and ensure that a request with 20k+ headers can be sent.
  testManyRequestHeaders(std::chrono::milliseconds(5000));
}

TEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersAccepted) {
  testLargeRequestTrailers(60, 96);
}

TEST_P(DownstreamProtocolIntegrationTest, LargeRequestTrailersRejected) {
  testLargeRequestTrailers(66, 60);
}

TEST_P(DownstreamProtocolIntegrationTest, ManyTrailerHeaders) {
  config_helper_.addConfigModifier(
      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });

  Http::TestHeaderMapImpl request_trailers{};
  for (int i = 0; i < 20000; i++) {
    request_trailers.addCopy(std::to_string(i), """");
  }

  initialize();
  codec_client_ = makeHttpConnection(lookupPort(""http""));
  auto encoder_decoder =
      codec_client_->startRequest(Http::TestHeaderMapImpl{{"":method"", ""POST""},
                                                          {"":path"", ""/test/long/url""},
                                                          {"":scheme"", ""http""},
                                                          {"":authority"", ""host""}});
  request_encoder_ = &encoder_decoder.first;
  auto response = std::move(encoder_decoder.second);
  codec_client_->sendTrailers(*request_encoder_, request_trailers);
  waitForNextUpstreamRequest();
  upstream_request_->encodeHeaders(default_response_headers_, true);
  response->waitForEndStream();

  EXPECT_TRUE(upstream_request_->complete());
  EXPECT_TRUE(response->complete());
  EXPECT_EQ(""200"", response->headers().Status()->value().getStringView());
}
",,afc39bea36fd436e54262f150c009e8d72db5014,CVE-2019-15226,afc39bea36fd436e54262f150c009e8d72db5014,https://github.com/envoyproxy/envoy,NVD_DIRECT_COMMIT,1337,COMPLETED," VAR(VAR, VAR) { VAR(); VAR = VAR(VAR(""VAR"")); VAR::VAR VAR{{"":VAR"", ""VAR""}, {"":VAR"", ""/VAR/VAR/VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR""}, {""VAR-VAR"", ""0""}}; VAR::VAR<VAR::VAR> VAR; VAR (VAR VAR = 0; VAR < 7000; VAR++) { VAR.VAR(VAR::VAR(""VAR%VAR=VAR"", VAR)); } VAR.VAR(""VAR"", VAR::VAR(VAR, ""; "")); VAR VAR = VAR(VAR, 0, VAR, 0); VAR(VAR->VAR()); VAR(""200"", VAR->VAR().VAR()->VAR().VAR()); }  VAR(VAR, VAR) { VAR(); VAR = VAR(VAR(""VAR"")); VAR::VAR VAR{{"":VAR"", ""VAR""}, {"":VAR"", ""/VAR/VAR/VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR""}, {""VAR-VAR"", ""0""}}; VAR (VAR VAR = 0; VAR < 2000; VAR++) { VAR.VAR(""VAR"", VAR::VAR(""VAR%VAR=VAR"", VAR)); } VAR VAR = VAR(VAR, 0, VAR, 0); VAR(VAR->VAR()); VAR(""200"", VAR->VAR().VAR()->VAR().VAR()); } VAR(VAR, VAR) {  VAR(VAR::VAR::VAR(5000)); } VAR(VAR, VAR) { VAR(60, 96); } VAR(VAR, VAR) { VAR(66, 60); } VAR(VAR, VAR) { VAR.VAR( [&](VAR::VAR::VAR::VAR::VAR::VAR::VAR& VAR) -> VAR { VAR.VAR()->VAR(96); }); VAR::VAR VAR{}; VAR (VAR VAR = 0; VAR < 20000; VAR++) { VAR.VAR(VAR::VAR(VAR), """"); } VAR(); VAR = VAR(VAR(""VAR"")); VAR VAR = VAR->VAR(VAR::VAR{{"":VAR"", ""VAR""}, {"":VAR"", ""/VAR/VAR/VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR""}}); VAR = &VAR.VAR; VAR VAR = VAR::VAR(VAR.VAR); VAR->VAR(*VAR, VAR); VAR(); VAR->VAR(VAR, VAR); VAR->VAR(); VAR(VAR->VAR()); VAR(VAR->VAR()); VAR(""200"", VAR->VAR().VAR()->VAR().VAR()); } ",8
glpi_527280358ec78988ac57e9809d2eb21fcd74caf7,tests/functionnal/Glpi/CalDAV/Server.php,"      $login = 'tech';
      $pass  = 'tech';
         'name'    => 'Test group',
         'is_task' => 1,
      $this->login($login, $pass);

   /**
    * Test ACL on main objects.
    */
   public function testAcl() {

      $user  = getItemByTypeName('User', 'tech');

      $group = new \Group();
      $group_id = (int)$group->add([
         'name'    => 'Test group',
         'is_task' => 1,
      ]);
      $this->integer($group_id)->isGreaterThan(0);
      $group->getFromDB($group_id);

      $group_user = new \Group_User();
      $this->integer(
         (int)$group_user->add([
            'groups_id' => $group_id,
            'users_id'  => $user->fields['id'],
         ])
      )->isGreaterThan(0);

      $objects = [
         'principals/users/' . $user->fields['name'],
         'calendars/users/' . $user->fields['name'] . '/calendar/',
         'principals/groups/' . $group_id,
         'calendars/groups/' . $group_id . '/calendar/',
      ];

      $users_access = [
         'normal' => 'HTTP/1.1 403 Forbidden',
         'tech'   => 'HTTP/1.1 200 OK',
      ];

      foreach ($users_access as $username => $expected_status) {
         $this->login($username, $username);

         foreach ($objects as $path) {
            $server = $this->getServerInstance('PROPFIND', $path);

            $this->validateThatAuthenticationIsRequired($server);

            $server->httpRequest->addHeader('Authorization', 'Basic ' . base64_encode($username . ':' . $username));

            $response = new \Sabre\HTTP\Response();
            $server->invokeMethod($server->httpRequest, $response, false);
            $this->validateResponseIsOk($response, 207, 'application/xml'); // 207 'Multi-Status'

            $xpath = $this->getXpathFromResponse($response);
            $result_path = '/d:multistatus/d:response[1]';
            $this->string($xpath->evaluate('string(' . $result_path . '/d:propstat/d:status)'))->isEqualTo($expected_status);
         }
      }
   }

    * @param string|null          $content_type","      $login = TU_USER;
      $pass  = TU_PASS;
      $this->login($login, $pass);

         'name' => 'Test group'",527280358ec78988ac57e9809d2eb21fcd74caf7,CVE-2020-26212,527280358ec78988ac57e9809d2eb21fcd74caf7,https://github.com/glpi-project/glpi,NVD_DIRECT_COMMIT,1337,COMPLETED,"$VAR = 'VAR'; $VAR = 'VAR'; 'VAR' => 'VAR VAR', 'VAR' => 1, $VAR->VAR($VAR, $VAR); /** * VAR VAR VAR VAR VAR. */ VAR VAR VAR() { $VAR = VAR('VAR', 'VAR'); $VAR = VAR \VAR(); $VAR = (VAR)$VAR->VAR([ 'VAR' => 'VAR VAR', 'VAR' => 1, ]); $VAR->VAR($VAR)->VAR(0); $VAR->VAR($VAR); $VAR = VAR \VAR(); $VAR->VAR( (VAR)$VAR->VAR([ 'VAR' => $VAR, 'VAR' => $VAR->VAR['VAR'], ]) )->VAR(0); $VAR = [ 'VAR/VAR/' . $VAR->VAR['VAR'], 'VAR/VAR/' . $VAR->VAR['VAR'] . '/VAR/', 'VAR/VAR/' . $VAR, 'VAR/VAR/' . $VAR . '/VAR/', ]; $VAR = [ 'VAR' => 'VAR/1.1 403 VAR', 'VAR' => 'VAR/1.1 200 VAR', ]; VAR ($VAR VAR $VAR => $VAR) { $VAR->VAR($VAR, $VAR); VAR ($VAR VAR $VAR) { $VAR = $VAR->VAR('VAR', $VAR); $VAR->VAR($VAR); $VAR->VAR->VAR('VAR', 'VAR ' . VAR($VAR . ':' . $VAR)); $VAR = VAR \VAR\VAR\VAR(); $VAR->VAR($VAR->VAR, $VAR, VAR); $VAR->VAR($VAR, 207, 'VAR/VAR');  $VAR = $VAR->VAR($VAR); $VAR = '/VAR:VAR/VAR:VAR[1]'; $VAR->VAR($VAR->VAR('VAR(' . $VAR . '/VAR:VAR/VAR:VAR)'))->VAR($VAR); } } } * @VAR VAR|VAR $VAR $VAR = VAR; $VAR = VAR; $VAR->VAR($VAR, $VAR); 'VAR' => 'VAR VAR'",8
go_3c010f2c2182a12f28ad86c5e1ff984f1f2d880a,src/net/textproto/reader.go,"	// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.
	// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large
	// MIMEHeaders average about 200 bytes per entry.
	lim -= 400
	const mapEntryOverhead = 200

			lim -= mapEntryOverhead",			lim -= 100 // map entry overhead,3c010f2c2182a12f28ad86c5e1ff984f1f2d880a,CVE-2023-24536,3c010f2c2182a12f28ad86c5e1ff984f1f2d880a,https://github.com/golang/go,CPE_GIT_REPOBASED,122,COMPLETED,   VAR -= 400 VAR VAR = 200 VAR -= VAR VAR -= 100 ,8
go_6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8,src/net/http/transport_test.go,"
func TestInvalidHeaderResponse(t *testing.T) {
	setParallel(t)
	defer afterTest(t)
	cst := newClientServerTest(t, h1Mode, HandlerFunc(func(w ResponseWriter, r *Request) {
		conn, buf, _ := w.(Hijacker).Hijack()
		buf.Write([]byte(""HTTP/1.1 200 OK\r\n"" +
			""Date: Wed, 30 Aug 2017 19:09:27 GMT\r\n"" +
			""Content-Type: text/html; charset=utf-8\r\n"" +
			""Content-Length: 0\r\n"" +
			""Foo : bar\r\n\r\n""))
		buf.Flush()
		conn.Close()
	}))
	defer cst.close()
	res, err := cst.c.Get(cst.ts.URL)
	if err != nil {
		t.Fatal(err)
	}
	defer res.Body.Close()
	if v := res.Header.Get(""Foo""); v != """" {
		t.Errorf(`unexpected ""Foo"" header: %q`, v)
	}
	if v := res.Header.Get(""Foo ""); v != ""bar"" {
		t.Errorf(`bad ""Foo "" header value: %q, want %q`, v, ""bar"")
	}
}",,6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8,CVE-2019-16276,6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8,https://github.com/golang/go,NVD_GIT_REPOBASED,160,COMPLETED,"VAR VAR(VAR *VAR.VAR) { VAR(VAR) VAR VAR(VAR) VAR := VAR(VAR, VAR, VAR(VAR(VAR VAR, VAR *VAR) { VAR, VAR, VAR := VAR.(VAR).VAR() VAR.VAR([]VAR(""VAR/1.1 200 VAR\VAR\VAR"" + ""VAR: VAR, 30 VAR 2017 19:09:27 VAR\VAR\VAR"" + ""VAR-VAR: VAR/VAR; VAR=VAR-8\VAR\VAR"" + ""VAR-VAR: 0\VAR\VAR"" + ""VAR : VAR\VAR\VAR\VAR\VAR"")) VAR.VAR() VAR.VAR() })) VAR VAR.VAR() VAR, VAR := VAR.VAR.VAR(VAR.VAR.VAR) VAR VAR != VAR { VAR.VAR(VAR) } VAR VAR.VAR.VAR() VAR VAR := VAR.VAR.VAR(""VAR""); VAR != """" { VAR.VAR(`VAR ""VAR"" VAR: %VAR`, VAR) } VAR VAR := VAR.VAR.VAR(""VAR ""); VAR != ""VAR"" { VAR.VAR(`VAR ""VAR "" VAR VAR: %VAR, VAR %VAR`, VAR, ""VAR"") } } ",8
go_7a359a651c7ebdb29e0a1c03102fce793e9f58f0,src/net/textproto/reader.go,"	// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.
	// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large
	// MIMEHeaders average about 200 bytes per entry.
	lim -= 400
	const mapEntryOverhead = 200

			lim -= mapEntryOverhead",			lim -= 100 // map entry overhead,7a359a651c7ebdb29e0a1c03102fce793e9f58f0,CVE-2023-24536,7a359a651c7ebdb29e0a1c03102fce793e9f58f0,https://github.com/golang/go,CPE_GIT_REPOBASED,154,COMPLETED,   VAR -= 400 VAR VAR = 200 VAR -= VAR VAR -= 100 ,8
go_829c5df58694b3345cb5ea41206783c8ccf5c3ca,src/net/http/fs_test.go,"	c, err := net.Dial(""tcp"", ts.Listener.Addr().String())
	defer c.Close()
	_, err = fmt.Fprintf(c, ""GET /..\x00 HTTP/1.0\r\n\r\n"")
	if err != nil {
		t.Fatal(err)
	}
	var got bytes.Buffer
	bufr := bufio.NewReader(io.TeeReader(c, &got))
	res, err := ReadResponse(bufr, nil)
		t.Fatal(""ReadResponse: "", err)
		t.Errorf(""got status 200; want an error. Body is:\n%s"", got.Bytes())","	res, err := Get(ts.URL + ""/..\x00"")
	b, err := ioutil.ReadAll(res.Body)
		t.Fatal(""reading Body:"", err)
		t.Errorf(""got status 200; want an error. Body is:\n%s"", string(b))",829c5df58694b3345cb5ea41206783c8ccf5c3ca,CVE-2019-9741,829c5df58694b3345cb5ea41206783c8ccf5c3ca,https://github.com/golang/go,NVD_GIT_REPOBASED,86,COMPLETED,"VAR, VAR := VAR.VAR(""VAR"", VAR.VAR.VAR().VAR()) VAR VAR.VAR() VAR, VAR = VAR.VAR(VAR, ""VAR /..\VAR VAR/1.0\VAR\VAR\VAR\VAR"") VAR VAR != VAR { VAR.VAR(VAR) } VAR VAR VAR.VAR VAR := VAR.VAR(VAR.VAR(VAR, &VAR)) VAR, VAR := VAR(VAR, VAR) VAR.VAR(""VAR: "", VAR) VAR.VAR(""VAR VAR 200; VAR VAR VAR. VAR VAR:\VAR%VAR"", VAR.VAR()) VAR, VAR := VAR(VAR.VAR + ""/..\VAR"") VAR, VAR := VAR.VAR(VAR.VAR) VAR.VAR(""VAR VAR:"", VAR) VAR.VAR(""VAR VAR 200; VAR VAR VAR. VAR VAR:\VAR%VAR"", VAR(VAR))",8
go_ae080c1aecb129a3230e7afecdb4a16ad3da9b3c,src/net/http/response_test.go,"
	// Both keep-alive and close, on the same Connection line. (Issue 8840)
	{
		""HTTP/1.1 200 OK\r\n"" +
			""Content-Length: 256\r\n"" +
			""Connection: keep-alive, close\r\n"" +
			""\r\n"",

		Response{
			Status:     ""200 OK"",
			StatusCode: 200,
			Proto:      ""HTTP/1.1"",
			ProtoMajor: 1,
			ProtoMinor: 1,
			Request:    dummyReq(""HEAD""),
			Header: Header{
				""Content-Length"": {""256""},
			},
			TransferEncoding: nil,
			Close:            true,
			ContentLength:    256,
		},

		"""",
	},

	// Both keep-alive and close, on different Connection lines. (Issue 8840)
	{
		""HTTP/1.1 200 OK\r\n"" +
			""Content-Length: 256\r\n"" +
			""Connection: keep-alive\r\n"" +
			""Connection: close\r\n"" +
			""\r\n"",

		Response{
			Status:     ""200 OK"",
			StatusCode: 200,
			Proto:      ""HTTP/1.1"",
			ProtoMajor: 1,
			ProtoMinor: 1,
			Request:    dummyReq(""HEAD""),
			Header: Header{
				""Content-Length"": {""256""},
			},
			TransferEncoding: nil,
			Close:            true,
			ContentLength:    256,
		},

		"""",
	},",,ae080c1aecb129a3230e7afecdb4a16ad3da9b3c,CVE-2021-31525,ae080c1aecb129a3230e7afecdb4a16ad3da9b3c,https://github.com/golang/go,NVD_GIT_REPOBASED,66,COMPLETED," { ""VAR/1.1 200 VAR\VAR\VAR"" + ""VAR-VAR: 256\VAR\VAR"" + ""VAR: VAR-VAR, VAR\VAR\VAR"" + ""\VAR\VAR"", VAR{ VAR: ""200 VAR"", VAR: 200, VAR: ""VAR/1.1"", VAR: 1, VAR: 1, VAR: VAR(""VAR""), VAR: VAR{ ""VAR-VAR"": {""256""}, }, VAR: VAR, VAR: VAR, VAR: 256, }, """", },  { ""VAR/1.1 200 VAR\VAR\VAR"" + ""VAR-VAR: 256\VAR\VAR"" + ""VAR: VAR-VAR\VAR\VAR"" + ""VAR: VAR\VAR\VAR"" + ""\VAR\VAR"", VAR{ VAR: ""200 VAR"", VAR: 200, VAR: ""VAR/1.1"", VAR: 1, VAR: 1, VAR: VAR(""VAR""), VAR: VAR{ ""VAR-VAR"": {""256""}, }, VAR: VAR, VAR: VAR, VAR: 256, }, """", }, ",8
go_ec18f62df59d8f857e63ed3d7480754c49b072c3,src/net/textproto/reader.go,"	// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.
	// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large
	// MIMEHeaders average about 200 bytes per entry.
	lim -= 400
	const mapEntryOverhead = 200

			lim -= mapEntryOverhead",			lim -= 100 // map entry overhead,ec18f62df59d8f857e63ed3d7480754c49b072c3,CVE-2023-24536,ec18f62df59d8f857e63ed3d7480754c49b072c3,https://github.com/golang/go,CPE_GIT_REPOBASED,158,COMPLETED,   VAR -= 400 VAR VAR = 200 VAR -= VAR VAR -= 100 ,8
libarchive_6e06b1c89dd0d16f74894eac4cfc1327a06ee4a0,libarchive/test/test_read_too_many_filters.c,"/*-
 * Copyright (c) 2003-2008,2015 Tim Kientzle
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
#include ""test.h""

DEFINE_TEST(test_read_too_many_filters)
{
	const char *name = ""test_read_too_many_filters.gz"";
	struct archive *a;
	int r;

	assert((a = archive_read_new()) != NULL);
	r = archive_read_support_filter_gzip(a);
	if (r == ARCHIVE_WARN) {
		skipping(""gzip reading not fully supported on this platform"");
	}
	assertEqualIntA(a, ARCHIVE_OK, archive_read_support_format_all(a));
	extract_reference_file(name);
	assertEqualIntA(a, ARCHIVE_FATAL,
	    archive_read_open_filename(a, name, 200));

	assertEqualInt(ARCHIVE_OK, archive_read_close(a));
	assertEqualInt(ARCHIVE_OK, archive_read_free(a));
}",,6e06b1c89dd0d16f74894eac4cfc1327a06ee4a0,CVE-2016-7166,6e06b1c89dd0d16f74894eac4cfc1327a06ee4a0,https://github.com/libarchive/libarchive,NVD_DIRECT_COMMIT,1337,COMPLETED,"/*- * VAR (VAR) 2003-2008,2015 VAR VAR * VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR * VAR VAR: * 1. VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR VAR. * 2. VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR/VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR(VAR) ``VAR VAR'' VAR VAR VAR VAR * VAR VAR, VAR, VAR VAR VAR VAR, VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR(VAR) VAR VAR VAR VAR VAR, VAR, * VAR, VAR, VAR, VAR VAR VAR (VAR, VAR * VAR VAR VAR, VAR VAR VAR VAR VAR VAR; VAR VAR VAR, * VAR, VAR VAR; VAR VAR VAR) VAR VAR VAR VAR VAR * VAR VAR VAR, VAR VAR VAR, VAR VAR, VAR VAR * (VAR VAR VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR. */  VAR(VAR) { VAR VAR *VAR = ""VAR.VAR""; VAR VAR *VAR; VAR VAR; VAR((VAR = VAR()) != VAR); VAR = VAR(VAR); VAR (VAR == VAR) { VAR(""VAR VAR VAR VAR VAR VAR VAR VAR""); } VAR(VAR, VAR, VAR(VAR)); VAR(VAR); VAR(VAR, VAR, VAR(VAR, VAR, 200)); VAR(VAR, VAR(VAR)); VAR(VAR, VAR(VAR)); } ",8
MISP_6f6fb678ca07c80cb7d2bdfe5cb0313bb71bd487,app/View/Elements/Events/View/value_field.ctp,"    $sigDisplay = $object['value'];
    if ('attachment' == $object['type'] || 'malware-sample' == $object['type'] ) {
        if ($object['type'] == 'attachment' && isset($object['image'])) {
            if (extension_loaded('gd')) {
                $img = '<it class=""fa fa-spin fa-spinner"" style=""font-size: large; left: 50%; top: 50%;""></it>';
                $img .= '<img class=""screenshot screenshot-collapsed useCursorPointer img-rounded hidden"" src=""' . $baseurl . '/attributes/viewPicture/' . h($object['id']) . '/1' . '"" title=""' . h($object['value']) . '"" onload=""$(this).show(200); $(this).parent().find(\'.fa-spinner\').remove();""/>';
                echo $img;
            } else {
                $extension = explode('.', $object['value']);
                $extension = end($extension);
                $uri = 'data:image/' . strtolower(h($extension)) . ';base64,' . h($object['image']);
                echo '<img class=""screenshot screenshot-collapsed useCursorPointer"" src=""' . $uri . '"" title=""' . h($object['value']) . '"" />';
            }
            $filenameHash = explode('|', h($object['value']));
            if (strrpos($filenameHash[0], '\\')) {
                $filepath = substr($filenameHash[0], 0, strrpos($filenameHash[0], '\\'));
                $filename = substr($filenameHash[0], strrpos($filenameHash[0], '\\'));
                echo h($filepath);
                echo '<a href=""' . $baseurl . '/attributes/download/' . h($object['id']) . '"" class=""' . $linkClass . '"">' . h($filename) . '</a>';
            } else {
                echo '<a href=""' . $baseurl . '/attributes/download/' . h($object['id']) . '"" class=""' . $linkClass . '"">' . h($filenameHash[0]) . '</a>';
            }
            if (isset($filenameHash[1])) echo '<br />' . $filenameHash[1];
    } else if (strpos($object['type'], '|') !== false) {
        $separator = in_array($object['type'], array('ip-dst|port', 'ip-src|port')) ? ':' : '<br />';
        $value_pieces = explode('|', $object['value']);
        foreach ($value_pieces as $k => $v) {
            $value_pieces[$k] = h($v);
        }
        $object['value'] = implode($separator, $value_pieces);
        echo ($object['value']);
    } else if ('vulnerability' == $object['type']) {
        $cveUrl = (is_null(Configure::read('MISP.cveurl'))) ? ""http://www.google.com/search?q="" : Configure::read('MISP.cveurl');
        echo $this->Html->link($sigDisplay, $cveUrl . $sigDisplay, array('target' => '_blank', 'class' => $linkClass));
    } else if ('link' == $object['type'] && (substr($object['value'], 0, 7) === 'http://' || substr($object['value'], 0, 8) === 'https://')) {
        echo $this->Html->link($sigDisplay, $sigDisplay, array('class' => $linkClass));
    } else if ('cortex' == $object['type']) {
        echo '<div class=""cortex-json"" data-cortex-json=""' . h($object['value']) . '"">Cortex object</div>';
    } else if ('text' == $object['type']) {
        if (($object['category'] == 'Internal reference' || $object['category'] == 'External analysis') && preg_match('/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/i', $object['value'])) {
            echo '<a href=""' . $baseurl . '/events/view/' . h($object['value']) . '"" class=""' . $linkClass . '"">' . h($object['value']) . '</a>';
        } else {
            $sigDisplay = str_replace(""\r"", '', h($sigDisplay));
            $sigDisplay = str_replace("" "", '&nbsp;', $sigDisplay);
            echo $sigDisplay;
        }
    } else if ('hex' == $object['type']) {
        $sigDisplay = str_replace(""\r"", '', $sigDisplay);
        echo '<span class=""hex-value"" title=""' . __('Hexadecimal representation') . '"">' . h($sigDisplay) . '</span>&nbsp;<span role=""button"" tabindex=""0"" aria-label=""' . __('Switch to binary representation') . '"" class=""icon-repeat hex-value-convert useCursorPointer"" title=""' . __('Switch to binary representation') . '""></span>';
        $sigDisplay = str_replace(""\r"", '', $sigDisplay);
        echo h($sigDisplay);
    if (isset($object['validationIssue'])) {
        echo ' <span class=""fa fa-exclamation-triangle"" title=""' . __('Warning, this doesn\'t seem to be a legitimate ') . strtoupper(h($object['type'])) . __(' value') . '"">&nbsp;</span>';","  $sigDisplay = $object['value'];
  if ('attachment' == $object['type'] || 'malware-sample' == $object['type'] ) {
    if ($object['type'] == 'attachment' && isset($object['image'])) {
        if (extension_loaded('gd')) {
            $img = '<it class=""fa fa-spin fa-spinner"" style=""font-size: large; left: 50%; top: 50%;""></it>';
            $img .= '<img class=""screenshot screenshot-collapsed useCursorPointer img-rounded hidden"" src=""' . $baseurl . '/attributes/viewPicture/' . h($object['id']) . '/1' . '"" title=""' . h($object['value']) . '"" onload=""$(this).show(200); $(this).parent().find(\'.fa-spinner\').remove();""/>';
            echo $img;
            $extension = explode('.', $object['value']);
            $extension = end($extension);
            $uri = 'data:image/' . strtolower(h($extension)) . ';base64,' . h($object['image']);
            echo '<img class=""screenshot screenshot-collapsed useCursorPointer"" src=""' . $uri . '"" title=""' . h($object['value']) . '"" />';
      $filenameHash = explode('|', h($object['value']));
      if (strrpos($filenameHash[0], '\\')) {
        $filepath = substr($filenameHash[0], 0, strrpos($filenameHash[0], '\\'));
        $filename = substr($filenameHash[0], strrpos($filenameHash[0], '\\'));
        echo h($filepath);
        echo '<a href=""' . $baseurl . '/attributes/download/' . h($object['id']) . '"" class=""' . $linkClass . '"">' . h($filename) . '</a>';
      } else {
        echo '<a href=""' . $baseurl . '/attributes/download/' . h($object['id']) . '"" class=""' . $linkClass . '"">' . h($filenameHash[0]) . '</a>';
      }
      if (isset($filenameHash[1])) echo '<br />' . $filenameHash[1];
  } else if (strpos($object['type'], '|') !== false) {
    $separator = in_array($object['type'], array('ip-dst|port', 'ip-src|port')) ? ':' : '<br />';
    $value_pieces = explode('|', $object['value']);
    foreach ($value_pieces as $k => $v) {
      $value_pieces[$k] = h($v);
    }
    $object['value'] = implode($separator, $value_pieces);
    echo ($object['value']);
  } else if ('vulnerability' == $object['type']) {
    $cveUrl = (is_null(Configure::read('MISP.cveurl'))) ? ""http://www.google.com/search?q="" : Configure::read('MISP.cveurl');
    echo $this->Html->link($sigDisplay, $cveUrl . $sigDisplay, array('target' => '_blank', 'class' => $linkClass));
  } else if ('link' == $object['type']) {
    echo $this->Html->link($sigDisplay, $sigDisplay, array('class' => $linkClass));
  } else if ('cortex' == $object['type']) {
    echo '<div class=""cortex-json"" data-cortex-json=""' . h($object['value']) . '"">Cortex object</div>';
  } else if ('text' == $object['type']) {
    if (($object['category'] == 'Internal reference' || $object['category'] == 'External analysis') && preg_match('/[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}/i', $object['value'])) {
      echo '<a href=""' . $baseurl . '/events/view/' . h($object['value']) . '"" class=""' . $linkClass . '"">' . h($object['value']) . '</a>';
    } else {
      $sigDisplay = str_replace(""\r"", '', h($sigDisplay));
      $sigDisplay = str_replace("" "", '&nbsp;', $sigDisplay);
      echo $sigDisplay;
  } else if ('hex' == $object['type']) {
    $sigDisplay = str_replace(""\r"", '', $sigDisplay);
    echo '<span class=""hex-value"" title=""' . __('Hexadecimal representation') . '"">' . h($sigDisplay) . '</span>&nbsp;<span role=""button"" tabindex=""0"" aria-label=""' . __('Switch to binary representation') . '"" class=""icon-repeat hex-value-convert useCursorPointer"" title=""' . __('Switch to binary representation') . '""></span>';
  } else {
    $sigDisplay = str_replace(""\r"", '', $sigDisplay);
    echo h($sigDisplay);
  }
  if (isset($object['validationIssue'])) echo ' <span class=""fa fa-exclamation-triangle"" title=""' . __('Warning, this doesn\'t seem to be a legitimate ') . strtoupper(h($object['type'])) . __(' value') . '"">&nbsp;</span>';",6f6fb678ca07c80cb7d2bdfe5cb0313bb71bd487,CVE-2019-11813,6f6fb678ca07c80cb7d2bdfe5cb0313bb71bd487,https://github.com/MISP/MISP,NVD_DIRECT_COMMIT,1337,COMPLETED,"$VAR = $VAR['VAR']; VAR ('VAR' == $VAR['VAR'] || 'VAR-VAR' == $VAR['VAR'] ) { VAR ($VAR['VAR'] == 'VAR' && VAR($VAR['VAR'])) { VAR (VAR('VAR')) { $VAR = '<VAR VAR=""VAR VAR-VAR VAR-VAR"" VAR=""VAR-VAR: VAR; VAR: 50%; VAR: 50%;""></VAR>'; $VAR .= '<VAR VAR=""VAR VAR-VAR VAR VAR-VAR VAR"" VAR=""' . $VAR . '/VAR/VAR/' . VAR($VAR['VAR']) . '/1' . '"" VAR=""' . VAR($VAR['VAR']) . '"" VAR=""$(VAR).VAR(200); $(VAR).VAR().VAR(\'.VAR-VAR\').VAR();""/>'; VAR $VAR; } VAR { $VAR = VAR('.', $VAR['VAR']); $VAR = VAR($VAR); $VAR = 'VAR:VAR/' . VAR(VAR($VAR)) . ';VAR,' . VAR($VAR['VAR']); VAR '<VAR VAR=""VAR VAR-VAR VAR"" VAR=""' . $VAR . '"" VAR=""' . VAR($VAR['VAR']) . '"" />'; } $VAR = VAR('|', VAR($VAR['VAR'])); VAR (VAR($VAR[0], '\\')) { $VAR = VAR($VAR[0], 0, VAR($VAR[0], '\\')); $VAR = VAR($VAR[0], VAR($VAR[0], '\\')); VAR VAR($VAR); VAR '<VAR VAR=""' . $VAR . '/VAR/VAR/' . VAR($VAR['VAR']) . '"" VAR=""' . $VAR . '"">' . VAR($VAR) . '</VAR>'; } VAR { VAR '<VAR VAR=""' . $VAR . '/VAR/VAR/' . VAR($VAR['VAR']) . '"" VAR=""' . $VAR . '"">' . VAR($VAR[0]) . '</VAR>'; } VAR (VAR($VAR[1])) VAR '<VAR />' . $VAR[1]; } VAR VAR (VAR($VAR['VAR'], '|') !== VAR) { $VAR = VAR($VAR['VAR'], VAR('VAR-VAR|VAR', 'VAR-VAR|VAR')) ? ':' : '<VAR />'; $VAR = VAR('|', $VAR['VAR']); VAR ($VAR VAR $VAR => $VAR) { $VAR[$VAR] = VAR($VAR); } $VAR['VAR'] = VAR($VAR, $VAR); VAR ($VAR['VAR']); } VAR VAR ('VAR' == $VAR['VAR']) { $VAR = (VAR(VAR::VAR('VAR.VAR'))) ? ""VAR: VAR $VAR->VAR->VAR($VAR, $VAR . $VAR, VAR('VAR' => 'VAR', 'VAR' => $VAR)); } VAR VAR ('VAR' == $VAR['VAR'] && (VAR($VAR['VAR'], 0, 7) === 'VAR: VAR $VAR->VAR->VAR($VAR, $VAR, VAR('VAR' => $VAR)); } VAR VAR ('VAR' == $VAR['VAR']) { VAR '<VAR VAR=""VAR-VAR"" VAR-VAR-VAR=""' . VAR($VAR['VAR']) . '"">VAR VAR</VAR>'; } VAR VAR ('VAR' == $VAR['VAR']) { VAR (($VAR['VAR'] == 'VAR VAR' || $VAR['VAR'] == 'VAR VAR') && VAR('/[VAR-VAR-9]{8}-[VAR-VAR-9]{4}-[VAR-VAR-9]{4}-[VAR-VAR-9]{4}-[VAR-VAR-9]{12}/VAR', $VAR['VAR'])) { VAR '<VAR VAR=""' . $VAR . '/VAR/VAR/' . VAR($VAR['VAR']) . '"" VAR=""' . $VAR . '"">' . VAR($VAR['VAR']) . '</VAR>'; } VAR { $VAR = VAR(""\VAR"", '', VAR($VAR)); $VAR = VAR("" "", '&VAR;', $VAR); VAR $VAR; } } VAR VAR ('VAR' == $VAR['VAR']) { $VAR = VAR(""\VAR"", '', $VAR); VAR '<VAR VAR=""VAR-VAR"" VAR=""' . VAR('VAR VAR') . '"">' . VAR($VAR) . '</VAR>&VAR;<VAR VAR=""VAR"" VAR=""0"" VAR-VAR=""' . VAR('VAR VAR VAR VAR') . '"" VAR=""VAR-VAR VAR-VAR-VAR VAR"" VAR=""' . VAR('VAR VAR VAR VAR') . '""></VAR>'; $VAR = VAR(""\VAR"", '', $VAR); VAR VAR($VAR); VAR (VAR($VAR['VAR'])) { VAR ' <VAR VAR=""VAR VAR-VAR-VAR"" VAR=""' . VAR('VAR, VAR VAR\'VAR VAR VAR VAR VAR VAR ') . VAR(VAR($VAR['VAR'])) . VAR(' VAR') . '"">&VAR;</VAR>'; $VAR = $VAR['VAR']; VAR ('VAR' == $VAR['VAR'] || 'VAR-VAR' == $VAR['VAR'] ) { VAR ($VAR['VAR'] == 'VAR' && VAR($VAR['VAR'])) { VAR (VAR('VAR')) { $VAR = '<VAR VAR=""VAR VAR-VAR VAR-VAR"" VAR=""VAR-VAR: VAR; VAR: 50%; VAR: 50%;""></VAR>'; $VAR .= '<VAR VAR=""VAR VAR-VAR VAR VAR-VAR VAR"" VAR=""' . $VAR . '/VAR/VAR/' . VAR($VAR['VAR']) . '/1' . '"" VAR=""' . VAR($VAR['VAR']) . '"" VAR=""$(VAR).VAR(200); $(VAR).VAR().VAR(\'.VAR-VAR\').VAR();""/>'; VAR $VAR; $VAR = VAR('.', $VAR['VAR']); $VAR = VAR($VAR); $VAR = 'VAR:VAR/' . VAR(VAR($VAR)) . ';VAR,' . VAR($VAR['VAR']); VAR '<VAR VAR=""VAR VAR-VAR VAR"" VAR=""' . $VAR . '"" VAR=""' . VAR($VAR['VAR']) . '"" />'; $VAR = VAR('|', VAR($VAR['VAR'])); VAR (VAR($VAR[0], '\\')) { $VAR = VAR($VAR[0], 0, VAR($VAR[0], '\\')); $VAR = VAR($VAR[0], VAR($VAR[0], '\\')); VAR VAR($VAR); VAR '<VAR VAR=""' . $VAR . '/VAR/VAR/' . VAR($VAR['VAR']) . '"" VAR=""' . $VAR . '"">' . VAR($VAR) . '</VAR>'; } VAR { VAR '<VAR VAR=""' . $VAR . '/VAR/VAR/' . VAR($VAR['VAR']) . '"" VAR=""' . $VAR . '"">' . VAR($VAR[0]) . '</VAR>'; } VAR (VAR($VAR[1])) VAR '<VAR />' . $VAR[1]; } VAR VAR (VAR($VAR['VAR'], '|') !== VAR) { $VAR = VAR($VAR['VAR'], VAR('VAR-VAR|VAR', 'VAR-VAR|VAR')) ? ':' : '<VAR />'; $VAR = VAR('|', $VAR['VAR']); VAR ($VAR VAR $VAR => $VAR) { $VAR[$VAR] = VAR($VAR); } $VAR['VAR'] = VAR($VAR, $VAR); VAR ($VAR['VAR']); } VAR VAR ('VAR' == $VAR['VAR']) { $VAR = (VAR(VAR::VAR('VAR.VAR'))) ? ""VAR: VAR $VAR->VAR->VAR($VAR, $VAR . $VAR, VAR('VAR' => 'VAR', 'VAR' => $VAR)); } VAR VAR ('VAR' == $VAR['VAR']) { VAR $VAR->VAR->VAR($VAR, $VAR, VAR('VAR' => $VAR)); } VAR VAR ('VAR' == $VAR['VAR']) { VAR '<VAR VAR=""VAR-VAR"" VAR-VAR-VAR=""' . VAR($VAR['VAR']) . '"">VAR VAR</VAR>'; } VAR VAR ('VAR' == $VAR['VAR']) { VAR (($VAR['VAR'] == 'VAR VAR' || $VAR['VAR'] == 'VAR VAR') && VAR('/[VAR-VAR-9]{8}-[VAR-VAR-9]{4}-[VAR-VAR-9]{4}-[VAR-VAR-9]{4}-[VAR-VAR-9]{12}/VAR', $VAR['VAR'])) { VAR '<VAR VAR=""' . $VAR . '/VAR/VAR/' . VAR($VAR['VAR']) . '"" VAR=""' . $VAR . '"">' . VAR($VAR['VAR']) . '</VAR>'; } VAR { $VAR = VAR(""\VAR"", '', VAR($VAR)); $VAR = VAR("" "", '&VAR;', $VAR); VAR $VAR; } VAR VAR ('VAR' == $VAR['VAR']) { $VAR = VAR(""\VAR"", '', $VAR); VAR '<VAR VAR=""VAR-VAR"" VAR=""' . VAR('VAR VAR') . '"">' . VAR($VAR) . '</VAR>&VAR;<VAR VAR=""VAR"" VAR=""0"" VAR-VAR=""' . VAR('VAR VAR VAR VAR') . '"" VAR=""VAR-VAR VAR-VAR-VAR VAR"" VAR=""' . VAR('VAR VAR VAR VAR') . '""></VAR>'; } VAR { $VAR = VAR(""\VAR"", '', $VAR); VAR VAR($VAR); } VAR (VAR($VAR['VAR'])) VAR ' <VAR VAR=""VAR VAR-VAR-VAR"" VAR=""' . VAR('VAR, VAR VAR\'VAR VAR VAR VAR VAR VAR ') . VAR(VAR($VAR['VAR'])) . VAR(' VAR') . '"">&VAR;</VAR>';",8
nautobot_362850f5a94689a4c75e3188bf6de826c3b012b2,nautobot/extras/tests/test_views.py,"from django.utils.html import format_html
from nautobot.dcim.models import (
    ConsolePort,
    Device,
    DeviceRole,
    DeviceType,
    Interface,
    LocationType,
    Manufacturer,
    Site,
)
    ComputedField,
class ComputedFieldRenderingTestCase(TestCase):
    """"""Tests for the inclusion of ComputedFields, distinct from tests of the ComputedField views themselves.""""""

    user_permissions = [""dcim.view_locationtype""]

    def setUp(self):
        super().setUp()
        self.computedfield = ComputedField(
            content_type=ContentType.objects.get_for_model(LocationType),
            slug=""test"",
            label=""Computed Field"",
            template=""FOO {{ obj.name }} BAR"",
            fallback_value=""Fallback Value"",
            weight=100,
        )
        self.computedfield.validated_save()
        self.location_type = LocationType.objects.get(name=""Campus"")

    def test_view_object_with_computed_field(self):
        """"""Ensure that the computed field template is rendered.""""""
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertIn(f""FOO {self.location_type.name} BAR"", content, content)

    def test_view_object_with_computed_field_fallback_value(self):
        """"""Ensure that the fallback_value is rendered if the template fails to render.""""""
        # Make the template invalid to demonstrate the fallback value
        self.computedfield.template = ""FOO {{ obj.""
        self.computedfield.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertIn(""Fallback Value"", content, content)

    def test_view_object_with_computed_field_unsafe_template(self):
        """"""Ensure that computed field templates can't be used as an XSS vector.""""""
        self.computedfield.template = '<script>alert(""Hello world!""</script>'
        self.computedfield.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)

    def test_view_object_with_computed_field_unsafe_fallback_value(self):
        """"""Ensure that computed field fallback values can't be used as an XSS vector.""""""
        self.computedfield.template = ""FOO {{ obj.""
        self.computedfield.fallback_value = '<script>alert(""Hello world!""</script>'
        self.computedfield.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)


class CustomLinkRenderingTestCase(TestCase):
    """"""Tests for the inclusion of CustomLinks, distinct from tests of the CustomLink views themselves.""""""

    def test_view_object_with_unsafe_custom_link_text(self):
        """"""Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.""""""
        customlink = CustomLink(
            content_type=ContentType.objects.get_for_model(Site),
            name=""Test"",
            text='<script>alert(""Hello world!"")</script>',
            target_url=""http://example.com/?location=None"",
            new_window=False,
        )
        customlink.validated_save()
        site = Site(name=""Test Site"", slug=""test-site"")
        site.save()

        response = self.client.get(site.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)
        self.assertIn(format_html('<a href=""{}""', customlink.target_url), content, content)

    def test_view_object_with_unsafe_custom_link_url(self):
        """"""Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.""""""
        customlink = CustomLink(
            content_type=ContentType.objects.get_for_model(Site),
            name=""Test"",
            text=""Hello"",
            target_url='""><script>alert(""Hello world!"")</script><a href=""',
            new_window=False,
        )
        customlink.validated_save()
        site = Site(name=""Test Site"", slug=""test-site"")
        site.save()

        response = self.client.get(site.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)
        self.assertIn(format_html('<a href=""{}""', customlink.target_url), content, content)

    def test_view_object_with_unsafe_custom_link_name(self):
        """"""Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.""""""
        customlink = CustomLink(
            content_type=ContentType.objects.get_for_model(Site),
            name='<script>alert(""Hello World"")</script>',
            text=""Hello"",
            target_url=""http://example.com/?site={{ obj.name "",  # intentionally bad jinja2 to trigger error case
            new_window=False,
        )
        customlink.validated_save()
        site = Site(name=""Test Site"", slug=""test-site"")
        site.save()

        response = self.client.get(site.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)

class JobButtonRenderingTestCase(TestCase):
    """"""Tests for the rendering of JobButtons, distinct from tests of the JobButton views themselves.""""""

    user_permissions = [""dcim.view_locationtype""]

    def setUp(self):
        super().setUp()
        self.job_button = JobButton(
            name=""JobButton"",
            text=""JobButton {{ obj.name }}"",
            job=Job.objects.get(job_class_name=""TestJobButtonReceiverSimple""),
            confirmation=False,
        )
        self.job_button.validated_save()
        self.job_button.content_types.add(ContentType.objects.get_for_model(LocationType))
        self.location_type = LocationType.objects.get(name=""Campus"")

    def test_view_object_with_job_button(self):
        """"""Ensure that the job button is rendered.""""""
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertIn(f""JobButton {self.location_type.name}"", content, content)

    def test_view_object_with_unsafe_text(self):
        """"""Ensure that JobButton text can't be used as a vector for XSS.""""""
        self.job_button.text = '<script>alert(""Hello world!"")</script>'
        self.job_button.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)

        # Make sure grouped rendering is safe too
        self.job_button.group = '<script>alert(""Goodbye"")</script>'
        self.job_button.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)

    def test_view_object_with_unsafe_name(self):
        """"""Ensure that JobButton names can't be used as a vector for XSS.""""""
        self.job_button.text = ""JobButton {{ obj""
        self.job_button.name = '<script>alert(""Yo"")</script>'
        self.job_button.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)

","from nautobot.dcim.models import ConsolePort, Device, DeviceRole, DeviceType, Interface, Manufacturer, Site
    ComputedField,
class CustomLinkTest(TestCase):",362850f5a94689a4c75e3188bf6de826c3b012b2,CVE-2023-48705,362850f5a94689a4c75e3188bf6de826c3b012b2,https://github.com/nautobot/nautobot,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR, VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = [""VAR.VAR""] VAR VAR(VAR): VAR().VAR() VAR.VAR = VAR( VAR=VAR.VAR.VAR(VAR), VAR=""VAR"", VAR=""VAR VAR"", VAR=""VAR {{ VAR.VAR }} VAR"", VAR=""VAR VAR"", VAR=100, ) VAR.VAR.VAR() VAR.VAR = VAR.VAR.VAR(VAR=""VAR"") VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(VAR""VAR {VAR.VAR.VAR} VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.""""""  VAR.VAR.VAR = ""VAR {{ VAR."" VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""VAR VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR."""""" VAR.VAR.VAR = '<VAR>VAR(""VAR VAR!""</VAR>' VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR."""""" VAR.VAR.VAR = ""VAR {{ VAR."" VAR.VAR.VAR = '<VAR>VAR(""VAR VAR!""</VAR>' VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR(VAR): """"""VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = VAR( VAR=VAR.VAR.VAR(VAR), VAR=""VAR"", VAR='<VAR>VAR(""VAR VAR!"")</VAR>', VAR=""VAR: VAR=VAR, ) VAR.VAR() VAR = VAR(VAR=""VAR VAR"", VAR=""VAR-VAR"") VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR.VAR(VAR('<VAR VAR=""{}""', VAR.VAR), VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = VAR( VAR=VAR.VAR.VAR(VAR), VAR=""VAR"", VAR=""VAR"", VAR='""><VAR>VAR(""VAR VAR!"")</VAR><VAR VAR=""', VAR=VAR, ) VAR.VAR() VAR = VAR(VAR=""VAR VAR"", VAR=""VAR-VAR"") VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR.VAR(VAR('<VAR VAR=""{}""', VAR.VAR), VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = VAR( VAR=VAR.VAR.VAR(VAR), VAR='<VAR>VAR(""VAR VAR"")</VAR>', VAR=""VAR"", VAR=""VAR: VAR=VAR, ) VAR.VAR() VAR = VAR(VAR=""VAR VAR"", VAR=""VAR-VAR"") VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = [""VAR.VAR""] VAR VAR(VAR): VAR().VAR() VAR.VAR = VAR( VAR=""VAR"", VAR=""VAR {{ VAR.VAR }}"", VAR=VAR.VAR.VAR(VAR=""VAR""), VAR=VAR, ) VAR.VAR.VAR() VAR.VAR.VAR.VAR(VAR.VAR.VAR(VAR)) VAR.VAR = VAR.VAR.VAR(VAR=""VAR"") VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR."""""" VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(VAR""VAR {VAR.VAR.VAR}"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR.VAR.VAR = '<VAR>VAR(""VAR VAR!"")</VAR>' VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR)  VAR.VAR.VAR = '<VAR>VAR(""VAR"")</VAR>' VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR.VAR.VAR = ""VAR {{ VAR"" VAR.VAR.VAR = '<VAR>VAR(""VAR"")</VAR>' VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR VAR.VAR.VAR VAR VAR, VAR, VAR, VAR, VAR, VAR, VAR VAR, VAR VAR(VAR):",8
nautobot_54abe23331b6c3d0d82bf1b028c679b1d200920d,nautobot/extras/tests/test_views.py,"from django.utils.html import format_html
    ComputedField,
class ComputedFieldRenderingTestCase(TestCase):
    """"""Tests for the inclusion of ComputedFields, distinct from tests of the ComputedField views themselves.""""""

    user_permissions = [""dcim.view_locationtype""]

    def setUp(self):
        super().setUp()
        self.computedfield = ComputedField(
            content_type=ContentType.objects.get_for_model(LocationType),
            key=""test"",
            label=""Computed Field"",
            template=""FOO {{ obj.name }} BAR"",
            fallback_value=""Fallback Value"",
            weight=100,
        )
        self.computedfield.validated_save()
        self.location_type = LocationType.objects.get(name=""Campus"")

    def test_view_object_with_computed_field(self):
        """"""Ensure that the computed field template is rendered.""""""
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertIn(f""FOO {self.location_type.name} BAR"", content, content)

    def test_view_object_with_computed_field_fallback_value(self):
        """"""Ensure that the fallback_value is rendered if the template fails to render.""""""
        # Make the template invalid to demonstrate the fallback value
        self.computedfield.template = ""FOO {{ obj.""
        self.computedfield.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertIn(""Fallback Value"", content, content)

    def test_view_object_with_computed_field_unsafe_template(self):
        """"""Ensure that computed field templates can't be used as an XSS vector.""""""
        self.computedfield.template = '<script>alert(""Hello world!""</script>'
        self.computedfield.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)

    def test_view_object_with_computed_field_unsafe_fallback_value(self):
        """"""Ensure that computed field fallback values can't be used as an XSS vector.""""""
        self.computedfield.template = ""FOO {{ obj.""
        self.computedfield.fallback_value = '<script>alert(""Hello world!""</script>'
        self.computedfield.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)


class CustomLinkRenderingTestCase(TestCase):
    """"""Tests for the inclusion of CustomLinks, distinct from tests of the CustomLink views themselves.""""""

    def test_view_object_with_unsafe_custom_link_text(self):
        """"""Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.""""""
        customlink = CustomLink(
            content_type=ContentType.objects.get_for_model(Location),
            name=""Test"",
            text='<script>alert(""Hello world!"")</script>',
            target_url=""http://example.com/?location=None"",
            new_window=False,
        )
        customlink.validated_save()
        location_type = LocationType.objects.get(name=""Campus"")
        status = Status.objects.get_for_model(Location).first()
        location = Location(name=""Test Location"", location_type=location_type, status=status)
        location.save()

        response = self.client.get(location.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)
        self.assertIn(format_html('<a href=""{}""', customlink.target_url), content, content)

    def test_view_object_with_unsafe_custom_link_url(self):
        """"""Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.""""""
        customlink = CustomLink(
            content_type=ContentType.objects.get_for_model(Location),
            name=""Test"",
            text=""Hello"",
            target_url='""><script>alert(""Hello world!"")</script><a href=""',
            new_window=False,
        )
        customlink.validated_save()
        location_type = LocationType.objects.get(name=""Campus"")
        status = Status.objects.get_for_model(Location).first()
        location = Location(name=""Test Location"", location_type=location_type, status=status)
        location.save()

        response = self.client.get(location.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)
        self.assertIn(format_html('<a href=""{}""', customlink.target_url), content, content)

    def test_view_object_with_unsafe_custom_link_name(self):
        """"""Ensure that custom links can't be used as a vector for injecting scripts or breaking HTML.""""""
        customlink = CustomLink(
            content_type=ContentType.objects.get_for_model(Location),
            name='<script>alert(""Hello World"")</script>',
            text=""Hello"",
            target_url=""http://example.com/?location={{ obj.name "",  # intentionally bad jinja2 to trigger error case
            new_window=False,
        )
        customlink.validated_save()
        location_type = LocationType.objects.get(name=""Campus"")
        status = Status.objects.get_for_model(Location).first()
        location = Location(name=""Test Location"", location_type=location_type, status=status)
        location.save()

        response = self.client.get(location.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)

class JobButtonRenderingTestCase(TestCase):
    """"""Tests for the rendering of JobButtons, distinct from tests of the JobButton views themselves.""""""

    user_permissions = [""dcim.view_locationtype""]

    def setUp(self):
        super().setUp()
        self.job_button = JobButton(
            name=""JobButton"",
            text=""JobButton {{ obj.name }}"",
            job=Job.objects.get(job_class_name=""TestJobButtonReceiverSimple""),
            confirmation=False,
        )
        self.job_button.validated_save()
        self.job_button.content_types.add(ContentType.objects.get_for_model(LocationType))
        self.location_type = LocationType.objects.get(name=""Campus"")

    def test_view_object_with_job_button(self):
        """"""Ensure that the job button is rendered.""""""
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertIn(f""JobButton {self.location_type.name}"", content, content)

    def test_view_object_with_unsafe_text(self):
        """"""Ensure that JobButton text can't be used as a vector for XSS.""""""
        self.job_button.text = '<script>alert(""Hello world!"")</script>'
        self.job_button.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)

        # Make sure grouped rendering is safe too
        self.job_button.group = '<script>alert(""Goodbye"")</script>'
        self.job_button.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)

    def test_view_object_with_unsafe_name(self):
        """"""Ensure that JobButton names can't be used as a vector for XSS.""""""
        self.job_button.text = ""JobButton {{ obj""
        self.job_button.name = '<script>alert(""Yo"")</script>'
        self.job_button.validated_save()
        response = self.client.get(self.location_type.get_absolute_url(), follow=True)
        self.assertEqual(response.status_code, 200)
        content = extract_page_body(response.content.decode(response.charset))
        self.assertNotIn(""<script>alert"", content, content)
        self.assertIn(""&lt;script&gt;alert"", content, content)

","    ComputedField,
class CustomLinkTest(TestCase):",54abe23331b6c3d0d82bf1b028c679b1d200920d,CVE-2023-48705,54abe23331b6c3d0d82bf1b028c679b1d200920d,https://github.com/nautobot/nautobot,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR.VAR.VAR VAR VAR VAR, VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = [""VAR.VAR""] VAR VAR(VAR): VAR().VAR() VAR.VAR = VAR( VAR=VAR.VAR.VAR(VAR), VAR=""VAR"", VAR=""VAR VAR"", VAR=""VAR {{ VAR.VAR }} VAR"", VAR=""VAR VAR"", VAR=100, ) VAR.VAR.VAR() VAR.VAR = VAR.VAR.VAR(VAR=""VAR"") VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(VAR""VAR {VAR.VAR.VAR} VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.""""""  VAR.VAR.VAR = ""VAR {{ VAR."" VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""VAR VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR."""""" VAR.VAR.VAR = '<VAR>VAR(""VAR VAR!""</VAR>' VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR."""""" VAR.VAR.VAR = ""VAR {{ VAR."" VAR.VAR.VAR = '<VAR>VAR(""VAR VAR!""</VAR>' VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR(VAR): """"""VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = VAR( VAR=VAR.VAR.VAR(VAR), VAR=""VAR"", VAR='<VAR>VAR(""VAR VAR!"")</VAR>', VAR=""VAR: VAR=VAR, ) VAR.VAR() VAR = VAR.VAR.VAR(VAR=""VAR"") VAR = VAR.VAR.VAR(VAR).VAR() VAR = VAR(VAR=""VAR VAR"", VAR=VAR, VAR=VAR) VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR.VAR(VAR('<VAR VAR=""{}""', VAR.VAR), VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = VAR( VAR=VAR.VAR.VAR(VAR), VAR=""VAR"", VAR=""VAR"", VAR='""><VAR>VAR(""VAR VAR!"")</VAR><VAR VAR=""', VAR=VAR, ) VAR.VAR() VAR = VAR.VAR.VAR(VAR=""VAR"") VAR = VAR.VAR.VAR(VAR).VAR() VAR = VAR(VAR=""VAR VAR"", VAR=VAR, VAR=VAR) VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR.VAR(VAR('<VAR VAR=""{}""', VAR.VAR), VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = VAR( VAR=VAR.VAR.VAR(VAR), VAR='<VAR>VAR(""VAR VAR"")</VAR>', VAR=""VAR"", VAR=""VAR: VAR=VAR, ) VAR.VAR() VAR = VAR.VAR.VAR(VAR=""VAR"") VAR = VAR.VAR.VAR(VAR).VAR() VAR = VAR(VAR=""VAR VAR"", VAR=VAR, VAR=VAR) VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR = [""VAR.VAR""] VAR VAR(VAR): VAR().VAR() VAR.VAR = VAR( VAR=""VAR"", VAR=""VAR {{ VAR.VAR }}"", VAR=VAR.VAR.VAR(VAR=""VAR""), VAR=VAR, ) VAR.VAR.VAR() VAR.VAR.VAR.VAR(VAR.VAR.VAR(VAR)) VAR.VAR = VAR.VAR.VAR(VAR=""VAR"") VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR."""""" VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(VAR""VAR {VAR.VAR.VAR}"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR.VAR.VAR = '<VAR>VAR(""VAR VAR!"")</VAR>' VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR)  VAR.VAR.VAR = '<VAR>VAR(""VAR"")</VAR>' VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR.VAR.VAR = ""VAR {{ VAR"" VAR.VAR.VAR = '<VAR>VAR(""VAR"")</VAR>' VAR.VAR.VAR() VAR = VAR.VAR.VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR(VAR.VAR.VAR(VAR.VAR)) VAR.VAR(""<VAR>VAR"", VAR, VAR) VAR.VAR(""&VAR;VAR&VAR;VAR"", VAR, VAR) VAR, VAR VAR(VAR):",8
parse-server_308668c89474223e2448be92d6823b52c1c313ec,spec/ParseQuery.spec.js,"  it_only_db('mongo')('gracefully handles invalid explain values', async () => {
    // Note that anything that is not truthy (like 0) does not cause an exception, as they get swallowed up by ClassesRouter::optionsFromBody
    const values = [1, 'yolo', { a: 1 }, [1, 2, 3]];
    for (const value of values) {
      try {
        await request({
          method: 'GET',
          url: `http://localhost:8378/1/classes/_User?explain=${value}`,
          json: true,
          headers: masterKeyHeaders,
        });
        fail('request did not throw');
      } catch (e) {
        // Expect that Parse Server did not crash
        expect(e.code).not.toEqual('ECONNRESET');
        // Expect that Parse Server validates the explain value and does not crash;
        // see https://jira.mongodb.org/browse/NODE-3463
        equal(e.data.code, Parse.Error.INVALID_QUERY);
        equal(e.data.error, 'Invalid value for explain');
      }
      // get queries (of the form '/classes/:className/:objectId' cannot have the explain key, see ClassesRouter.js)
      // so it is enough that we test find queries
    }
  });

  it_only_db('mongo')('supports valid explain values', async () => {
    const values = [
      false,
      true,
      'queryPlanner',
      'executionStats',
      'allPlansExecution',
      // 'queryPlannerExtended' is excluded as it only applies to MongoDB Data Lake which is currently not available in our CI environment
    ];
    for (const value of values) {
      const response = await request({
        method: 'GET',
        url: `http://localhost:8378/1/classes/_User?explain=${value}`,
        json: true,
        headers: masterKeyHeaders,
      });
      expect(response.status).toBe(200);
      if (value) {
        expect(response.data.results.ok).toBe(1);
      }
    }
  });
",,308668c89474223e2448be92d6823b52c1c313ec,CVE-2021-39187,308668c89474223e2448be92d6823b52c1c313ec,https://github.com/parse-community/parse-server,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR('VAR')('VAR VAR VAR VAR VAR', VAR () => {  VAR VAR = [1, 'VAR', { VAR: 1 }, [1, 2, 3]]; VAR (VAR VAR VAR VAR) { VAR { VAR VAR({ VAR: 'VAR', VAR: `VAR: VAR: VAR, VAR: VAR, }); VAR('VAR VAR VAR VAR'); } VAR (VAR) {  VAR(VAR.VAR).VAR.VAR('VAR');   VAR(VAR.VAR.VAR, VAR.VAR.VAR); VAR(VAR.VAR.VAR, 'VAR VAR VAR VAR'); }   } }); VAR('VAR')('VAR VAR VAR VAR', VAR () => { VAR VAR = [ VAR, VAR, 'VAR', 'VAR', 'VAR',  ]; VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR({ VAR: 'VAR', VAR: `VAR: VAR: VAR, VAR: VAR, }); VAR(VAR.VAR).VAR(200); VAR (VAR) { VAR(VAR.VAR.VAR.VAR).VAR(1); } } }); ",8
parse-server_5be375dec2fa35425c1003ae81c55995ac72af92,spec/ParseFile.spec.js,"  describe('getting files', () => {
    it('does not crash on file request with invalid app ID', async () => {
      const res1 = await request({
        url: 'http://localhost:8378/1/files/invalid-id/invalid-file.txt',
      }).catch(e => e);
      expect(res1.status).toBe(403);
      expect(res1.data).toEqual({ code: 119, error: 'Invalid application ID.' });
      // Ensure server did not crash
      const res2 = await request({ url: 'http://localhost:8378/1/health' });
      expect(res2.status).toEqual(200);
      expect(res2.data).toEqual({ status: 'ok' });
    });

    it('does not crash on file request with invalid path', async () => {
      const res1 = await request({
        url: 'http://localhost:8378/1/files/invalid-id//invalid-path/%20/invalid-file.txt',
      }).catch(e => e);
      expect(res1.status).toBe(403);
      expect(res1.data).toEqual({ error: 'unauthorized' });
      // Ensure server did not crash
      const res2 = await request({ url: 'http://localhost:8378/1/health' });
      expect(res2.status).toEqual(200);
      expect(res2.data).toEqual({ status: 'ok' });
    });

    it('does not crash on file metadata request with invalid app ID', async () => {
      const res1 = await request({
        url: `http://localhost:8378/1/files/invalid-id/metadata/invalid-file.txt`,
      });
      expect(res1.status).toBe(200);
      expect(res1.data).toEqual({});
      // Ensure server did not crash
      const res2 = await request({ url: 'http://localhost:8378/1/health' });
      expect(res2.status).toEqual(200);
      expect(res2.data).toEqual({ status: 'ok' });
    });
  });
",,5be375dec2fa35425c1003ae81c55995ac72af92,CVE-2022-31089,5be375dec2fa35425c1003ae81c55995ac72af92,https://github.com/parse-community/parse-server,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR('VAR VAR', () => { VAR('VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR', VAR () => { VAR VAR = VAR VAR({ VAR: 'VAR: }).VAR(VAR => VAR); VAR(VAR.VAR).VAR(403); VAR(VAR.VAR).VAR({ VAR: 119, VAR: 'VAR VAR VAR.' });  VAR VAR = VAR VAR({ VAR: 'VAR: VAR(VAR.VAR).VAR(200); VAR(VAR.VAR).VAR({ VAR: 'VAR' }); }); VAR('VAR VAR VAR VAR VAR VAR VAR VAR VAR', VAR () => { VAR VAR = VAR VAR({ VAR: 'VAR: }).VAR(VAR => VAR); VAR(VAR.VAR).VAR(403); VAR(VAR.VAR).VAR({ VAR: 'VAR' });  VAR VAR = VAR VAR({ VAR: 'VAR: VAR(VAR.VAR).VAR(200); VAR(VAR.VAR).VAR({ VAR: 'VAR' }); }); VAR('VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR', VAR () => { VAR VAR = VAR VAR({ VAR: `VAR: }); VAR(VAR.VAR).VAR(200); VAR(VAR.VAR).VAR({});  VAR VAR = VAR VAR({ VAR: 'VAR: VAR(VAR.VAR).VAR(200); VAR(VAR.VAR).VAR({ VAR: 'VAR' }); }); }); ",8
rack_b426cc224908ec6ed6eb8729325392b048215d88,test/spec_common_logger.rb,"  app_without_lint = lambda { |env|
    [200,
     { ""content-type"" => ""text/html"", ""content-length"" => length.to_s },
     [obj]]}
  it ""escapes non printable characters except newline"" do
    logdev = StringIO.new
    log = Logger.new(logdev)
    Rack::MockRequest.new(Rack::CommonLogger.new(app_without_lint, log)).request(""GET\b"", ""/hello"")

    logdev.string.must_match(/GET\\x8 \/hello HTTP\/1\.1/)
  end
",,b426cc224908ec6ed6eb8729325392b048215d88,CVE-2022-30123,b426cc224908ec6ed6eb8729325392b048215d88,https://github.com/rack/rack,GHSD_DIRECT_COMMIT,1337,COMPLETED,"VAR = VAR { |VAR| [200, { ""VAR-VAR"" => ""VAR/VAR"", ""VAR-VAR"" => VAR.VAR }, [VAR]]} VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR = VAR.VAR VAR = VAR.VAR(VAR) VAR::VAR.VAR(VAR::VAR.VAR(VAR, VAR)).VAR(""VAR\VAR"", ""/VAR"") VAR.VAR.VAR(/VAR\\VAR \/VAR VAR\/1\.1/) VAR ",8
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,dummyserver/handlers.py,"from __future__ import print_function

import collections
import contextlib
import gzip
import json
import logging
import sys
import time
import zlib

from io import BytesIO
from tornado.web import RequestHandler
from tornado import httputil
from datetime import datetime
from datetime import timedelta

from urllib3.packages.six.moves.http_client import responses
from urllib3.packages.six.moves.urllib.parse import urlsplit

log = logging.getLogger(__name__)


class Response(object):
    def __init__(self, body='', status='200 OK', headers=None):
        self.body = body
        self.status = status
        self.headers = headers or [(""Content-type"", ""text/plain"")]

    def __call__(self, request_handler):
        status, reason = self.status.split(' ', 1)
        request_handler.set_status(int(status), reason)
        for header, value in self.headers:
            request_handler.add_header(header, value)

        # chunked
        if isinstance(self.body, list):
            for item in self.body:
                if not isinstance(item, bytes):
                    item = item.encode('utf8')
                request_handler.write(item)
                request_handler.flush()
        else:
            body = self.body
            if not isinstance(body, bytes):
                body = body.encode('utf8')

            request_handler.write(body)


RETRY_TEST_NAMES = collections.defaultdict(int)


class TestingApp(RequestHandler):
    """"""
    Simple app that performs various operations, useful for testing an HTTP
    library.

    Given any path, it will attempt to load a corresponding local method if
    it exists. Status code 200 indicates success, 400 indicates failure. Each
    method has its own conditions for success/failure.
    """"""
    def get(self):
        """""" Handle GET requests """"""
        self._call_method()

    def post(self):
        """""" Handle POST requests """"""
        self._call_method()

    def put(self):
        """""" Handle PUT requests """"""
        self._call_method()

    def options(self):
        """""" Handle OPTIONS requests """"""
        self._call_method()

    def head(self):
        """""" Handle HEAD requests """"""
        self._call_method()

    def _call_method(self):
        """""" Call the correct method in this class based on the incoming URI """"""
        req = self.request
        req.params = {}
        for k, v in req.arguments.items():
            req.params[k] = next(iter(v))

        path = req.path[:]
        if not path.startswith('/'):
            path = urlsplit(path).path

        target = path[1:].replace('/', '_')
        method = getattr(self, target, self.index)

        resp = method(req)

        if dict(resp.headers).get('Connection') == 'close':
            # FIXME: Can we kill the connection somehow?
            pass

        resp(self)

    def index(self, _request):
        ""Render simple message""
        return Response(""Dummy server!"")

    def certificate(self, request):
        """"""Return the requester's certificate.""""""
        cert = request.get_ssl_certificate()
        subject = dict()
        if cert is not None:
            subject = dict((k, v) for (k, v) in [y for z in cert['subject']
                                                 for y in z])
        return Response(json.dumps(subject))

    def source_address(self, request):
        """"""Return the requester's IP address.""""""
        return Response(request.remote_ip)

    def set_up(self, request):
        test_type = request.params.get('test_type')
        test_id = request.params.get('test_id')
        if test_id:
            print('\nNew test %s: %s' % (test_type, test_id))
        else:
            print('\nNew test %s' % test_type)
        return Response(""Dummy server is ready!"")

    def specific_method(self, request):
        ""Confirm that the request matches the desired method type""
        method = request.params.get('method')
        if method and not isinstance(method, str):
            method = method.decode('utf8')

        if request.method != method:
            return Response(""Wrong method: %s != %s"" %
                            (method, request.method), status='400 Bad Request')
        return Response()

    def upload(self, request):
        ""Confirm that the uploaded file conforms to specification""
        # FIXME: This is a huge broken mess
        param = request.params.get('upload_param', b'myfile').decode('ascii')
        filename = request.params.get('upload_filename', b'').decode('utf-8')
        size = int(request.params.get('upload_size', '0'))
        files_ = request.files.get(param)

        if len(files_) != 1:
            return Response(""Expected 1 file for '%s', not %d"" % (param, len(files_)),
                            status='400 Bad Request')
        file_ = files_[0]

        data = file_['body']
        if int(size) != len(data):
            return Response(""Wrong size: %d != %d"" %
                            (size, len(data)), status='400 Bad Request')

        if filename != file_['filename']:
            return Response(""Wrong filename: %s != %s"" %
                            (filename, file_.filename),
                            status='400 Bad Request')

        return Response()

    def redirect(self, request):
        ""Perform a redirect to ``target``""
        target = request.params.get('target', '/')
        status = request.params.get('status', '303 See Other')
        if len(status) == 3:
            status = '%s Redirect' % status.decode('latin-1')

        headers = [('Location', target)]
        return Response(status=status, headers=headers)

    def not_found(self, request):
        return Response('Not found', status='404 Not Found')

    def multi_redirect(self, request):
        ""Performs a redirect chain based on ``redirect_codes``""
        codes = request.params.get('redirect_codes', b'200').decode('utf-8')
        head, tail = codes.split(',', 1) if "","" in codes else (codes, None)
        status = ""{0} {1}"".format(head, responses[int(head)])
        if not tail:
            return Response(""Done redirecting"", status=status)

        headers = [('Location', '/multi_redirect?redirect_codes=%s' % tail)]
        return Response(status=status, headers=headers)

    def keepalive(self, request):
        if request.params.get('close', b'0') == b'1':
            headers = [('Connection', 'close')]
            return Response('Closing', headers=headers)

        headers = [('Connection', 'keep-alive')]
        return Response('Keeping alive', headers=headers)

    def sleep(self, request):
        ""Sleep for a specified amount of ``seconds``""
        # DO NOT USE THIS, IT'S DEPRECATED.
        # FIXME: Delete this once appengine tests are fixed to not use this handler.
        seconds = float(request.params.get('seconds', '1'))
        time.sleep(seconds)
        return Response()

    def echo(self, request):
        ""Echo back the params""
        if request.method == 'GET':
            return Response(request.query)

        return Response(request.body)

    def encodingrequest(self, request):
        ""Check for UA accepting gzip/deflate encoding""
        data = b""hello, world!""
        encoding = request.headers.get('Accept-Encoding', '')
        headers = None
        if encoding == 'gzip':
            headers = [('Content-Encoding', 'gzip')]
            file_ = BytesIO()
            with contextlib.closing(gzip.GzipFile('', mode='w', fileobj=file_)) as zipfile:
                zipfile.write(data)
            data = file_.getvalue()
        elif encoding == 'deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = zlib.compress(data)
        elif encoding == 'garbage-gzip':
            headers = [('Content-Encoding', 'gzip')]
            data = 'garbage'
        elif encoding == 'garbage-deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = 'garbage'
        return Response(data, headers=headers)

    def headers(self, request):
        return Response(json.dumps(dict(request.headers)))

    def successful_retry(self, request):
        """""" Handler which will return an error and then success

        It's not currently very flexible as the number of retries is hard-coded.
        """"""
        test_name = request.headers.get('test-name', None)
        if not test_name:
            return Response(""test-name header not set"",
                            status=""400 Bad Request"")

        RETRY_TEST_NAMES[test_name] += 1

        if RETRY_TEST_NAMES[test_name] >= 2:
            return Response(""Retry successful!"")
        else:
            return Response(""need to keep retrying!"", status=""418 I'm A Teapot"")

    def chunked(self, request):
        return Response(['123'] * 4)

    def chunked_gzip(self, request):
        chunks = []
        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)

        for uncompressed in [b'123'] * 4:
            chunks.append(compressor.compress(uncompressed))

        chunks.append(compressor.flush())

        return Response(chunks, headers=[('Content-Encoding', 'gzip')])

    def nbytes(self, request):
        length = int(request.params.get('length'))
        data = b'1' * length
        return Response(
            data,
            headers=[('Content-Type', 'application/octet-stream')])

    def status(self, request):
        status = request.params.get(""status"", ""200 OK"")

        return Response(status=status)

    def retry_after(self, request):
        if datetime.now() - self.application.last_req < timedelta(seconds=1):
            status = request.params.get(""status"", b""429 Too Many Requests"")
            return Response(
                    status=status.decode('utf-8'),
                    headers=[('Retry-After', '1')])

        self.application.last_req = datetime.now()

        return Response(status=""200 OK"")

    def redirect_after(self, request):
        ""Perform a redirect to ``target``""
        date = request.params.get('date')
        if date:
            retry_after = str(httputil.format_timestamp(
                    datetime.fromtimestamp(float(date))))
        else:
            retry_after = '1'
        target = request.params.get('target', '/')
        headers = [('Location', target), ('Retry-After', retry_after)]
        return Response(status='303 See Other', headers=headers)

    def shutdown(self, request):
        sys.exit()


# RFC2231-aware replacement of internal tornado function
def _parse_header(line):
    r""""""Parse a Content-type like header.

    Return the main content-type and a dictionary of options.

    >>> d = _parse_header(""CD: fd; foo=\""bar\""; file*=utf-8''T%C3%A4st"")[1]
    >>> d['file'] == 'T\u00e4st'
    True
    >>> d['foo']
    'bar'
    """"""
    import tornado.httputil
    import email.utils
    from urllib3.packages import six
    if not six.PY3:
        line = line.encode('utf-8')
    parts = tornado.httputil._parseparam(';' + line)
    key = next(parts)
    # decode_params treats first argument special, but we already stripped key
    params = [('Dummy', 'value')]
    for p in parts:
        i = p.find('=')
        if i >= 0:
            name = p[:i].strip().lower()
            value = p[i + 1:].strip()
            params.append((name, value))
    params = email.utils.decode_params(params)
    params.pop(0)  # get rid of the dummy again
    pdict = {}
    for name, value in params:
        value = email.utils.collapse_rfc2231_value(value)
        if len(value) >= 2 and value[0] == '""' and value[-1] == '""':
            value = value[1:-1]
        pdict[name] = value
    return key, pdict


# TODO: make the following conditional as soon as we know a version
#       which does not require this fix.
#       See https://github.com/facebook/tornado/issues/868
if True:
    import tornado.httputil
    tornado.httputil._parse_header = _parse_header",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR, VAR='', VAR='200 VAR', VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR [(""VAR-VAR"", ""VAR/VAR"")] VAR VAR(VAR, VAR): VAR, VAR = VAR.VAR.VAR(' ', 1) VAR.VAR(VAR(VAR), VAR) VAR VAR, VAR VAR VAR.VAR: VAR.VAR(VAR, VAR)  VAR VAR(VAR.VAR, VAR): VAR VAR VAR VAR.VAR: VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR.VAR() VAR: VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR 200 VAR VAR, 400 VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR/VAR. """""" VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR.VAR VAR.VAR = {} VAR VAR, VAR VAR VAR.VAR.VAR(): VAR.VAR[VAR] = VAR(VAR(VAR)) VAR = VAR.VAR[:] VAR VAR VAR.VAR('/'): VAR = VAR(VAR).VAR VAR = VAR[1:].VAR('/', 'VAR') VAR = VAR(VAR, VAR, VAR.VAR) VAR = VAR(VAR) VAR VAR(VAR.VAR).VAR('VAR') == 'VAR':  VAR VAR(VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR"" VAR VAR(""VAR VAR!"") VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR."""""" VAR = VAR.VAR() VAR = VAR() VAR VAR VAR VAR VAR: VAR = VAR((VAR, VAR) VAR (VAR, VAR) VAR [VAR VAR VAR VAR VAR['VAR'] VAR VAR VAR VAR]) VAR VAR(VAR.VAR(VAR)) VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR VAR."""""" VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR('VAR') VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR('\VAR VAR %VAR: %VAR' % (VAR, VAR)) VAR: VAR('\VAR VAR %VAR' % VAR) VAR VAR(""VAR VAR VAR VAR!"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR = VAR.VAR.VAR('VAR') VAR VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR VAR.VAR != VAR: VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR""  VAR = VAR.VAR.VAR('VAR', VAR'VAR').VAR('VAR') VAR = VAR.VAR.VAR('VAR', VAR'').VAR('VAR-8') VAR = VAR(VAR.VAR.VAR('VAR', '0')) VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) != 1: VAR VAR(""VAR 1 VAR VAR '%VAR', VAR %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR = VAR[0] VAR = VAR['VAR'] VAR VAR(VAR) != VAR(VAR): VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR VAR != VAR['VAR']: VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', '/') VAR = VAR.VAR.VAR('VAR', '303 VAR VAR') VAR VAR(VAR) == 3: VAR = '%VAR VAR' % VAR.VAR('VAR-1') VAR = [('VAR', VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR('VAR VAR', VAR='404 VAR VAR') VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', VAR'200').VAR('VAR-8') VAR, VAR = VAR.VAR(',', 1) VAR "","" VAR VAR VAR (VAR, VAR) VAR = ""{0} {1}"".VAR(VAR, VAR[VAR(VAR)]) VAR VAR VAR: VAR VAR(""VAR VAR"", VAR=VAR) VAR = [('VAR', '/VAR?VAR=%VAR' % VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR('VAR', VAR'0') == VAR'1': VAR = [('VAR', 'VAR')] VAR VAR('VAR', VAR=VAR) VAR = [('VAR', 'VAR-VAR')] VAR VAR('VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``""   VAR = VAR(VAR.VAR.VAR('VAR', '1')) VAR.VAR(VAR) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR"" VAR VAR.VAR == 'VAR': VAR VAR(VAR.VAR) VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR/VAR VAR"" VAR = VAR""VAR, VAR!"" VAR = VAR.VAR.VAR('VAR-VAR', '') VAR = VAR VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR() VAR VAR.VAR(VAR.VAR('', VAR='VAR', VAR=VAR)) VAR VAR: VAR.VAR(VAR) VAR = VAR.VAR() VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR.VAR(VAR) VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR(VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR(VAR.VAR(VAR(VAR.VAR))) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR', VAR) VAR VAR VAR: VAR VAR(""VAR-VAR VAR VAR VAR"", VAR=""400 VAR VAR"") VAR[VAR] += 1 VAR VAR[VAR] >= 2: VAR VAR(""VAR VAR!"") VAR: VAR VAR(""VAR VAR VAR VAR!"", VAR=""418 VAR'VAR VAR VAR"") VAR VAR(VAR, VAR): VAR VAR(['123'] * 4) VAR VAR(VAR, VAR): VAR = [] VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR VAR VAR [VAR'123'] * 4: VAR.VAR(VAR.VAR(VAR)) VAR.VAR(VAR.VAR()) VAR VAR(VAR, VAR=[('VAR-VAR', 'VAR')]) VAR VAR(VAR, VAR): VAR = VAR(VAR.VAR.VAR('VAR')) VAR = VAR'1' * VAR VAR VAR( VAR, VAR=[('VAR-VAR', 'VAR/VAR-VAR')]) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(""VAR"", ""200 VAR"") VAR VAR(VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR() - VAR.VAR.VAR < VAR(VAR=1): VAR = VAR.VAR.VAR(""VAR"", VAR""429 VAR VAR VAR"") VAR VAR( VAR=VAR.VAR('VAR-8'), VAR=[('VAR-VAR', '1')]) VAR.VAR.VAR = VAR.VAR() VAR VAR(VAR=""200 VAR"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR = VAR(VAR.VAR( VAR.VAR(VAR(VAR)))) VAR: VAR = '1' VAR = VAR.VAR.VAR('VAR', '/') VAR = [('VAR', VAR), ('VAR-VAR', VAR)] VAR VAR(VAR='303 VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): VAR.VAR()  VAR VAR(VAR): VAR""""""VAR VAR VAR-VAR VAR VAR. VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR. >>> VAR = VAR(""VAR: VAR; VAR=\""VAR\""; VAR*=VAR-8''VAR%VAR%VAR"")[1] >>> VAR['VAR'] == 'VAR\VAR' VAR >>> VAR['VAR'] 'VAR' """""" VAR VAR.VAR VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR VAR.VAR: VAR = VAR.VAR('VAR-8') VAR = VAR.VAR.VAR(';' + VAR) VAR = VAR(VAR)  VAR = [('VAR', 'VAR')] VAR VAR VAR VAR: VAR = VAR.VAR('=') VAR VAR >= 0: VAR = VAR[:VAR].VAR().VAR() VAR = VAR[VAR + 1:].VAR() VAR.VAR((VAR, VAR)) VAR = VAR.VAR.VAR(VAR) VAR.VAR(0)  VAR = {} VAR VAR, VAR VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) >= 2 VAR VAR[0] == '""' VAR VAR[-1] == '""': VAR = VAR[1:-1] VAR[VAR] = VAR VAR VAR, VAR    VAR VAR: VAR VAR.VAR VAR.VAR.VAR = VAR ",8
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/appengine/test_urlfetch.py,"""""""These tests ensure that when running in App Engine standard with the
App Engine sandbox enabled that urllib3 appropriately uses the App
Engine-patched version of httplib to make requests.""""""

import httplib
import StringIO
import unittest

from mock import patch
import pytest

from ..test_no_ssl import TestWithoutSSL


class MockResponse(object):
    def __init__(self, content, status_code, content_was_truncated, final_url,
                 headers):

        self.content = content
        self.status_code = status_code
        self.content_was_truncated = content_was_truncated
        self.final_url = final_url
        self.header_msg = httplib.HTTPMessage(StringIO.StringIO(''.join(
            [""%s: %s\n"" % (k, v) for k, v in headers.iteritems()] + [""\n""])))
        self.headers = headers


@pytest.mark.usefixtures('sandbox')
class TestHTTP(TestWithoutSSL):
    def test_urlfetch_called_with_http(self):
        """"""Check that URLFetch is used to fetch non-https resources.""""""
        resp = MockResponse(
            'OK',
            200,
            False,
            'http://www.google.com',
            {'content-type': 'text/plain'})
        fetch_patch = patch(
            'google.appengine.api.urlfetch.fetch', return_value=resp
        )
        with fetch_patch as fetch_mock:
            import urllib3
            pool = urllib3.HTTPConnectionPool('www.google.com', '80')
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200, r.data)
            self.assertEqual(fetch_mock.call_count, 1)


@pytest.mark.usefixtures('sandbox')
class TestHTTPS(unittest.TestCase):
    @pytest.mark.xfail(
        reason='This is not yet supported by urlfetch, presence of the ssl '
               'module will bypass urlfetch.')
    def test_urlfetch_called_with_https(self):
        """"""
        Check that URLFetch is used when fetching https resources
        """"""
        resp = MockResponse(
            'OK',
            200,
            False,
            'https://www.google.com',
            {'content-type': 'text/plain'})
        fetch_patch = patch(
            'google.appengine.api.urlfetch.fetch', return_value=resp
        )
        with fetch_patch as fetch_mock:
            import urllib3
            pool = urllib3.HTTPSConnectionPool('www.google.com', '443')
            pool.ConnectionCls = urllib3.connection.UnverifiedHTTPSConnection
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200, r.data)
            self.assertEqual(fetch_mock.call_count, 1)",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"""""""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ..VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR, VAR, VAR, VAR, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR.VAR(VAR.VAR(''.VAR( [""%VAR: %VAR\VAR"" % (VAR, VAR) VAR VAR, VAR VAR VAR.VAR()] + [""\VAR""]))) VAR.VAR = VAR @VAR.VAR.VAR('VAR') VAR VAR(VAR): VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR."""""" VAR = VAR( 'VAR', 200, VAR, 'VAR: {'VAR-VAR': 'VAR/VAR'}) VAR = VAR( 'VAR.VAR.VAR.VAR.VAR', VAR=VAR ) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR('VAR.VAR.VAR', '80') VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR.VAR(VAR.VAR, 1) @VAR.VAR.VAR('VAR') VAR VAR(VAR.VAR): @VAR.VAR.VAR( VAR='VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR ' 'VAR VAR VAR VAR.') VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR( 'VAR', 200, VAR, 'VAR: {'VAR-VAR': 'VAR/VAR'}) VAR = VAR( 'VAR.VAR.VAR.VAR.VAR', VAR=VAR ) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR('VAR.VAR.VAR', '443') VAR.VAR = VAR.VAR.VAR VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR.VAR(VAR.VAR, 1) ",8
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/contritest_socks.py,"import threading
import socket

from urllib3.contrib import socks
from urllib3.exceptions import ConnectTimeoutError, NewConnectionError

from dummyserver.server import DEFAULT_CERTS
from dummyserver.testcase import IPV4SocketDummyServerTestCase

import pytest

try:
    import ssl
    from urllib3.util import ssl_ as better_ssl
    HAS_SSL = True
except ImportError:
    ssl = None
    better_ssl = None
    HAS_SSL = False


SOCKS_NEGOTIATION_NONE = b'\x00'
SOCKS_NEGOTIATION_PASSWORD = b'\x02'

SOCKS_VERSION_SOCKS4 = b'\x04'
SOCKS_VERSION_SOCKS5 = b'\x05'


def _get_free_port(host):
    """"""
    Gets a free port by opening a socket, binding it, checking the assigned
    port, and then closing it.
    """"""
    s = socket.socket()
    s.bind((host, 0))
    port = s.getsockname()[1]
    s.close()
    return port


def _read_exactly(sock, amt):
    """"""
    Read *exactly* ``amt`` bytes from the socket ``sock``.
    """"""
    data = b''

    while amt > 0:
        chunk = sock.recv(amt)
        data += chunk
        amt -= len(chunk)

    return data


def _read_until(sock, char):
    """"""
    Read from the socket until the character is received.
    """"""
    chunks = []
    while True:
        chunk = sock.recv(1)
        chunks.append(chunk)
        if chunk == char:
            break

    return b''.join(chunks)


def _address_from_socket(sock):
    """"""
    Returns the address from the SOCKS socket
    """"""
    addr_type = sock.recv(1)

    if addr_type == b'\x01':
        ipv4_addr = _read_exactly(sock, 4)
        return socket.inet_ntoa(ipv4_addr)
    elif addr_type == b'\x04':
        ipv6_addr = _read_exactly(sock, 16)
        return socket.inet_ntop(socket.AF_INET6, ipv6_addr)
    elif addr_type == b'\x03':
        addr_len = ord(sock.recv(1))
        return _read_exactly(sock, addr_len)
    else:
        raise RuntimeError(""Unexpected addr type: %r"" % addr_type)


def handle_socks5_negotiation(sock, negotiate, username=None,
                              password=None):
    """"""
    Handle the SOCKS5 handshake.

    Returns a generator object that allows us to break the handshake into
    steps so that the test code can intervene at certain useful points.
    """"""
    received_version = sock.recv(1)
    assert received_version == SOCKS_VERSION_SOCKS5
    nmethods = ord(sock.recv(1))
    methods = _read_exactly(sock, nmethods)

    if negotiate:
        assert SOCKS_NEGOTIATION_PASSWORD in methods
        send_data = SOCKS_VERSION_SOCKS5 + SOCKS_NEGOTIATION_PASSWORD
        sock.sendall(send_data)

        # This is the password negotiation.
        negotiation_version = sock.recv(1)
        assert negotiation_version == b'\x01'
        ulen = ord(sock.recv(1))
        provided_username = _read_exactly(sock, ulen)
        plen = ord(sock.recv(1))
        provided_password = _read_exactly(sock, plen)

        if username == provided_username and password == provided_password:
            sock.sendall(b'\x01\x00')
        else:
            sock.sendall(b'\x01\x01')
            sock.close()
            yield False
            return
    else:
        assert SOCKS_NEGOTIATION_NONE in methods
        send_data = SOCKS_VERSION_SOCKS5 + SOCKS_NEGOTIATION_NONE
        sock.sendall(send_data)

    # Client sends where they want to go.
    received_version = sock.recv(1)
    command = sock.recv(1)
    reserved = sock.recv(1)
    addr = _address_from_socket(sock)
    port = _read_exactly(sock, 2)
    port = (ord(port[0:1]) << 8) + (ord(port[1:2]))

    # Check some basic stuff.
    assert received_version == SOCKS_VERSION_SOCKS5
    assert command == b'\x01'  # Only support connect, not bind.
    assert reserved == b'\x00'

    # Yield the address port tuple.
    succeed = yield addr, port

    if succeed:
        # Hard-coded response for now.
        response = (
            SOCKS_VERSION_SOCKS5 + b'\x00\x00\x01\x7f\x00\x00\x01\xea\x60'
        )
    else:
        # Hard-coded response for now.
        response = SOCKS_VERSION_SOCKS5 + b'\x01\00'

    sock.sendall(response)
    yield True  # Avoid StopIteration exceptions getting fired.


def handle_socks4_negotiation(sock, username=None):
    """"""
    Handle the SOCKS4 handshake.

    Returns a generator object that allows us to break the handshake into
    steps so that the test code can intervene at certain useful points.
    """"""
    received_version = sock.recv(1)
    command = sock.recv(1)
    port = _read_exactly(sock, 2)
    port = (ord(port[0:1]) << 8) + (ord(port[1:2]))
    addr = _read_exactly(sock, 4)
    provided_username = _read_until(sock, b'\x00')[:-1]  # Strip trailing null.

    if addr == b'\x00\x00\x00\x01':
        # Magic string: means DNS name.
        addr = _read_until(sock, b'\x00')[:-1]  # Strip trailing null.
    else:
        addr = socket.inet_ntoa(addr)

    # Check some basic stuff.
    assert received_version == SOCKS_VERSION_SOCKS4
    assert command == b'\x01'  # Only support connect, not bind.

    if username is not None and username != provided_username:
        sock.sendall(b'\x00\x5d\x00\x00\x00\x00\x00\x00')
        sock.close()
        yield False
        return

    # Yield the address port tuple.
    succeed = yield addr, port

    if succeed:
        response = b'\x00\x5a\xea\x60\x7f\x00\x00\x01'
    else:
        response = b'\x00\x5b\x00\x00\x00\x00\x00\x00'

    sock.sendall(response)
    yield True  # Avoid StopIteration exceptions getting fired.


class TestSOCKSProxyManager(object):

    def test_invalid_socks_version_is_valueerror(self):
        with pytest.raises(ValueError) as e:
            socks.SOCKSProxyManager(proxy_url='http://example.org')
        assert 'Unable to determine SOCKS version' in e.value.args[0]


class TestSocks5Proxy(IPV4SocketDummyServerTestCase):
    """"""
    Test the SOCKS proxy in SOCKS5 mode.
    """"""
    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_local_dns(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertIn(addr, ['127.0.0.1', '::1'])
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://localhost')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_correct_header_line(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, b'example.com')
            self.assertEqual(port, 80)
            handler.send(True)

            buf = b''
            while True:
                buf += sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            self.assertTrue(buf.startswith(b'GET / HTTP/1.1'))
            self.assertIn(b'Host: example.com', buf)

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://example.com')
        self.assertEqual(response.status, 200)

    def test_connection_timeouts(self):
        event = threading.Event()

        def request_handler(listener):
            event.wait()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        self.assertRaises(
            ConnectTimeoutError, pm.request, 'GET', 'http://example.com',
            timeout=0.001, retries=False
        )
        event.set()

    def test_connection_failure(self):
        event = threading.Event()

        def request_handler(listener):
            listener.close()
            event.set()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        event.wait()
        self.assertRaises(
            NewConnectionError, pm.request, 'GET', 'http://example.com',
            retries=False
        )

    def test_proxy_rejection(self):
        evt = threading.Event()

        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)
            handler.send(False)

            evt.wait()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        self.assertRaises(
            NewConnectionError, pm.request, 'GET', 'http://example.com',
            retries=False
        )
        evt.set()

    def test_socks_with_password(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b'user', password=b'pass'
            )
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='user',
                                     password='pass')
        self.addCleanup(pm.clear)

        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_socks_with_auth_in_url(self):
        """"""
        Test when we have auth info in url, i.e.
        socks5://user:pass@host:port and no username/password as params
        """"""
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b'user', password=b'pass'
            )
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://user:pass@%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_socks_with_invalid_password(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b'user', password=b'pass'
            )
            next(handler)

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='user',
                                     password='badpass')
        self.addCleanup(pm.clear)

        try:
            pm.request('GET', 'http://example.com', retries=False)
        except NewConnectionError as e:
            self.assertIn(""SOCKS5 authentication failed"", str(e))
        else:
            self.fail(""Did not raise"")

    def test_source_address_works(self):
        expected_port = _get_free_port(self.host)

        def request_handler(listener):
            sock = listener.accept()[0]
            self.assertEqual(sock.getpeername()[0], '127.0.0.1')
            self.assertEqual(sock.getpeername()[1], expected_port)

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(
            proxy_url, source_address=('127.0.0.1', expected_port)
        )
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')
        self.assertEqual(response.status, 200)


class TestSOCKS4Proxy(IPV4SocketDummyServerTestCase):
    """"""
    Test the SOCKS proxy in SOCKS4 mode.

    Has relatively fewer tests than the SOCKS5 case, mostly because once the
    negotiation is done the two cases behave identically.
    """"""
    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.headers['Server'], 'SocksTestServer')
        self.assertEqual(response.data, b'')

    def test_local_dns(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            self.assertEqual(addr, '127.0.0.1')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://localhost')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.headers['Server'], 'SocksTestServer')
        self.assertEqual(response.data, b'')

    def test_correct_header_line(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            self.assertEqual(addr, b'example.com')
            self.assertEqual(port, 80)
            handler.send(True)

            buf = b''
            while True:
                buf += sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            self.assertTrue(buf.startswith(b'GET / HTTP/1.1'))
            self.assertIn(b'Host: example.com', buf)

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://example.com')
        self.assertEqual(response.status, 200)

    def test_proxy_rejection(self):
        evt = threading.Event()

        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)
            handler.send(False)

            evt.wait()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        self.assertRaises(
            NewConnectionError, pm.request, 'GET', 'http://example.com',
            retries=False
        )
        evt.set()

    def test_socks4_with_username(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock, username=b'user')
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='user')
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_socks_with_invalid_username(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock, username=b'user')
            next(handler)

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='baduser')
        self.addCleanup(pm.clear)

        try:
            pm.request('GET', 'http://example.com', retries=False)
        except NewConnectionError as e:
            self.assertIn(""different user-ids"", str(e))
        else:
            self.fail(""Did not raise"")


class TestSOCKSWithTLS(IPV4SocketDummyServerTestCase):
    """"""
    Test that TLS behaves properly for SOCKS proxies.
    """"""
    @pytest.mark.skipif(not HAS_SSL, reason='No TLS available')
    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, b'localhost')
            self.assertEqual(port, 443)
            handler.send(True)

            # Wrap in TLS
            context = better_ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            context.load_cert_chain(
                DEFAULT_CERTS['certfile'], DEFAULT_CERTS['keyfile']
            )
            tls = context.wrap_socket(sock, server_side=True)
            buf = b''

            while True:
                buf += tls.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            self.assertTrue(buf.startswith(b'GET / HTTP/1.1\r\n'))

            tls.sendall(b'HTTP/1.1 200 OK\r\n'
                        b'Server: SocksTestServer\r\n'
                        b'Content-Length: 0\r\n'
                        b'\r\n')
            tls.close()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'https://localhost')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR = VAR VAR VAR: VAR = VAR VAR = VAR VAR = VAR VAR = VAR'\VAR' VAR = VAR'\VAR' VAR = VAR'\VAR' VAR = VAR'\VAR' VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR.VAR((VAR, 0)) VAR = VAR.VAR()[1] VAR.VAR() VAR VAR VAR VAR(VAR, VAR): """""" VAR *VAR* ``VAR`` VAR VAR VAR VAR ``VAR``. """""" VAR = VAR'' VAR VAR > 0: VAR = VAR.VAR(VAR) VAR += VAR VAR -= VAR(VAR) VAR VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = [] VAR VAR: VAR = VAR.VAR(1) VAR.VAR(VAR) VAR VAR == VAR: VAR VAR VAR''.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR.VAR(1) VAR VAR == VAR'\VAR': VAR = VAR(VAR, 4) VAR VAR.VAR(VAR) VAR VAR == VAR'\VAR': VAR = VAR(VAR, 16) VAR VAR.VAR(VAR.VAR, VAR) VAR VAR == VAR'\VAR': VAR = VAR(VAR.VAR(1)) VAR VAR(VAR, VAR) VAR: VAR VAR(""VAR VAR VAR: %VAR"" % VAR) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): """""" VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(1) VAR VAR == VAR VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR VAR: VAR VAR VAR VAR VAR = VAR + VAR VAR.VAR(VAR)  VAR = VAR.VAR(1) VAR VAR == VAR'\VAR' VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR VAR == VAR VAR VAR == VAR: VAR.VAR(VAR'\VAR\VAR') VAR: VAR.VAR(VAR'\VAR\VAR') VAR.VAR() VAR VAR VAR VAR: VAR VAR VAR VAR VAR = VAR + VAR VAR.VAR(VAR)  VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR(VAR) VAR = VAR(VAR, 2) VAR = (VAR(VAR[0:1]) << 8) + (VAR(VAR[1:2]))  VAR VAR == VAR VAR VAR == VAR'\VAR'  VAR VAR == VAR'\VAR'  VAR = VAR VAR, VAR VAR VAR:  VAR = ( VAR + VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ) VAR:  VAR = VAR + VAR'\VAR\00' VAR.VAR(VAR) VAR VAR  VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR(VAR, 2) VAR = (VAR(VAR[0:1]) << 8) + (VAR(VAR[1:2])) VAR = VAR(VAR, 4) VAR = VAR(VAR, VAR'\VAR')[:-1]  VAR VAR == VAR'\VAR\VAR\VAR\VAR':  VAR = VAR(VAR, VAR'\VAR')[:-1]  VAR: VAR = VAR.VAR(VAR)  VAR VAR == VAR VAR VAR == VAR'\VAR'  VAR VAR VAR VAR VAR VAR VAR != VAR: VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR') VAR.VAR() VAR VAR VAR  VAR = VAR VAR, VAR VAR VAR: VAR = VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR: VAR = VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR.VAR(VAR) VAR VAR  VAR VAR(VAR): VAR VAR(VAR): VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(VAR='VAR: VAR 'VAR VAR VAR VAR VAR' VAR VAR.VAR.VAR[0] VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, ['127.0.0.1', '::1']) VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, VAR'VAR.VAR') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR = VAR'' VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR.VAR(VAR'VAR / VAR/1.1')) VAR.VAR(VAR'VAR: VAR.VAR', VAR) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=0.001, VAR=VAR ) VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR() VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR ) VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR ) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR'VAR', VAR=VAR'VAR' ) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR', VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR.VAR. VAR: """""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR'VAR', VAR=VAR'VAR' ) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR'VAR', VAR=VAR'VAR' ) VAR(VAR) VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR', VAR='VAR') VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', 'VAR: VAR VAR VAR VAR: VAR.VAR(""VAR VAR VAR"", VAR(VAR)) VAR: VAR.VAR(""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR(VAR.VAR()[0], '127.0.0.1') VAR.VAR(VAR.VAR()[1], VAR) VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR( VAR, VAR=('127.0.0.1', VAR) ) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR.VAR(VAR.VAR, VAR'') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '127.0.0.1') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR.VAR(VAR.VAR, VAR'') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, VAR'VAR.VAR') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR = VAR'' VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR.VAR(VAR'VAR / VAR/1.1')) VAR.VAR(VAR'VAR: VAR.VAR', VAR) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR ) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR'VAR') VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR'VAR') VAR(VAR) VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', 'VAR: VAR VAR VAR VAR: VAR.VAR(""VAR VAR-VAR"", VAR(VAR)) VAR: VAR.VAR(""VAR VAR VAR"") VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. """""" @VAR.VAR.VAR(VAR VAR, VAR='VAR VAR VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, VAR'VAR') VAR.VAR(VAR, 443) VAR.VAR(VAR)  VAR = VAR.VAR(VAR.VAR) VAR.VAR( VAR['VAR'], VAR['VAR'] ) VAR = VAR.VAR(VAR, VAR=VAR) VAR = VAR'' VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR.VAR(VAR'VAR / VAR/1.1\VAR\VAR')) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') ",8
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/with_dummyserver/test_connectionpool.py,"import io
import logging
import socket
import sys
import unittest
import time
import warnings
import pytest

import mock

from .. import (
    TARPIT_HOST, VALID_SOURCE_ADDRESSES, INVALID_SOURCE_ADDRESSES,
)
from ..port_helpers import find_unused_port
from urllib3 import (
    encode_multipart_formdata,
    HTTPConnectionPool,
)
from urllib3.exceptions import (
    ConnectTimeoutError,
    EmptyPoolError,
    DecodeError,
    MaxRetryError,
    ReadTimeoutError,
    NewConnectionError,
    UnrewindableBodyError,
)
from urllib3.packages.six import b, u
from urllib3.packages.six.moves.urllib.parse import urlencode
from urllib3.util.retry import Retry, RequestHistory
from urllib3.util.timeout import Timeout

from dummyserver.testcase import HTTPDummyServerTestCase, SocketDummyServerTestCase
from dummyserver.server import NoIPv6Warning, HAS_IPV6_AND_DNS

from threading import Event

log = logging.getLogger('urllib3.connectionpool')
log.setLevel(logging.NOTSET)
log.addHandler(logging.StreamHandler(sys.stdout))


SHORT_TIMEOUT = 0.001
LONG_TIMEOUT = 0.03


def wait_for_socket(ready_event):
    ready_event.wait()
    ready_event.clear()


class TestConnectionPoolTimeouts(SocketDummyServerTestCase):

    def test_timeout_float(self):
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=2)

        # Pool-global timeout
        pool = HTTPConnectionPool(self.host, self.port, timeout=SHORT_TIMEOUT, retries=False)
        self.addCleanup(pool.close)
        wait_for_socket(ready_event)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')
        block_event.set()  # Release block

        # Shouldn't raise this time
        wait_for_socket(ready_event)
        block_event.set()  # Pre-release block
        pool.request('GET', '/')

    def test_conn_closed(self):
        block_event = Event()
        self.start_basic_handler(block_send=block_event, num=1)

        pool = HTTPConnectionPool(self.host, self.port, timeout=SHORT_TIMEOUT, retries=False)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        pool._put_conn(conn)
        try:
            pool.urlopen('GET', '/')
            self.fail(""The request should fail with a timeout error."")
        except ReadTimeoutError:
            if conn.sock:
                self.assertRaises(socket.error, conn.sock.recv, 1024)
        finally:
            pool._put_conn(conn)

        block_event.set()

    def test_timeout(self):
        # Requests should time out when expected
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=6)

        # Pool-global timeout
        timeout = Timeout(read=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)

        wait_for_socket(ready_event)
        conn = pool._get_conn()
        self.assertRaises(ReadTimeoutError, pool._make_request, conn, 'GET', '/')
        pool._put_conn(conn)
        block_event.set()  # Release request

        wait_for_socket(ready_event)
        block_event.clear()
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')
        block_event.set()  # Release request

        # Request-specific timeouts should raise errors
        pool = HTTPConnectionPool(self.host, self.port, timeout=LONG_TIMEOUT, retries=False)
        self.addCleanup(pool.close)

        conn = pool._get_conn()
        wait_for_socket(ready_event)
        now = time.time()
        self.assertRaises(ReadTimeoutError, pool._make_request, conn, 'GET', '/', timeout=timeout)
        delta = time.time() - now
        block_event.set()  # Release request

        message = ""timeout was pool-level LONG_TIMEOUT rather than request-level SHORT_TIMEOUT""
        self.assertLess(delta, LONG_TIMEOUT, message)
        pool._put_conn(conn)

        wait_for_socket(ready_event)
        now = time.time()
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/', timeout=timeout)
        delta = time.time() - now

        message = ""timeout was pool-level LONG_TIMEOUT rather than request-level SHORT_TIMEOUT""
        self.assertLess(delta, LONG_TIMEOUT, message)
        block_event.set()  # Release request

        # Timeout int/float passed directly to request and _make_request should
        # raise a request timeout
        wait_for_socket(ready_event)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/', timeout=SHORT_TIMEOUT)
        block_event.set()  # Release request

        wait_for_socket(ready_event)
        conn = pool._new_conn()
        # FIXME: This assert flakes sometimes. Not sure why.
        self.assertRaises(ReadTimeoutError,
                          pool._make_request,
                          conn, 'GET', '/',
                          timeout=SHORT_TIMEOUT)
        block_event.set()  # Release request

    def test_connect_timeout(self):
        url = '/'
        host, port = TARPIT_HOST, 80
        timeout = Timeout(connect=SHORT_TIMEOUT)

        # Pool-global timeout
        pool = HTTPConnectionPool(host, port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.assertRaises(ConnectTimeoutError, pool._make_request, conn, 'GET', url)

        # Retries
        retries = Retry(connect=0)
        self.assertRaises(MaxRetryError, pool.request, 'GET', url, retries=retries)

        # Request-specific connection timeouts
        big_timeout = Timeout(read=LONG_TIMEOUT, connect=LONG_TIMEOUT)
        pool = HTTPConnectionPool(host, port, timeout=big_timeout, retries=False)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.assertRaises(ConnectTimeoutError,
                          pool._make_request,
                          conn, 'GET', url,
                          timeout=timeout)

        pool._put_conn(conn)
        self.assertRaises(ConnectTimeoutError, pool.request, 'GET', url, timeout=timeout)

    def test_total_applies_connect(self):
        host, port = TARPIT_HOST, 80

        timeout = Timeout(total=None, connect=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(host, port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        self.assertRaises(ConnectTimeoutError, pool._make_request, conn, 'GET', '/')

        timeout = Timeout(connect=3, read=5, total=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(host, port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        self.assertRaises(ConnectTimeoutError, pool._make_request, conn, 'GET', '/')

    def test_total_timeout(self):
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=2)

        wait_for_socket(ready_event)
        # This will get the socket to raise an EAGAIN on the read
        timeout = Timeout(connect=3, read=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')

        block_event.set()
        wait_for_socket(ready_event)
        block_event.clear()

        # The connect should succeed and this should hit the read timeout
        timeout = Timeout(connect=3, read=5, total=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')

    def test_create_connection_timeout(self):
        timeout = Timeout(connect=SHORT_TIMEOUT, total=LONG_TIMEOUT)
        pool = HTTPConnectionPool(TARPIT_HOST, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)
        conn = pool._new_conn()
        self.assertRaises(ConnectTimeoutError, conn.connect)


class TestConnectionPool(HTTPDummyServerTestCase):

    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(self.pool.close)

    def test_get(self):
        r = self.pool.request('GET', '/specific_method',
                              fields={'method': 'GET'})
        self.assertEqual(r.status, 200, r.data)

    def test_post_url(self):
        r = self.pool.request('POST', '/specific_method',
                              fields={'method': 'POST'})
        self.assertEqual(r.status, 200, r.data)

    def test_urlopen_put(self):
        r = self.pool.urlopen('PUT', '/specific_method?method=PUT')
        self.assertEqual(r.status, 200, r.data)

    def test_wrong_specific_method(self):
        # To make sure the dummy server is actually returning failed responses
        r = self.pool.request('GET', '/specific_method',
                              fields={'method': 'POST'})
        self.assertEqual(r.status, 400, r.data)

        r = self.pool.request('POST', '/specific_method',
                              fields={'method': 'GET'})
        self.assertEqual(r.status, 400, r.data)

    def test_upload(self):
        data = ""I'm in ur multipart form-data, hazing a cheezburgr""
        fields = {
            'upload_param': 'filefield',
            'upload_filename': 'lolcat.txt',
            'upload_size': len(data),
            'filefield': ('lolcat.txt', data),
        }

        r = self.pool.request('POST', '/upload', fields=fields)
        self.assertEqual(r.status, 200, r.data)

    def test_one_name_multiple_values(self):
        fields = [
            ('foo', 'a'),
            ('foo', 'b'),
        ]

        # urlencode
        r = self.pool.request('GET', '/echo', fields=fields)
        self.assertEqual(r.data, b'foo=a&foo=b')

        # multipart
        r = self.pool.request('POST', '/echo', fields=fields)
        self.assertEqual(r.data.count(b'name=""foo""'), 2)

    def test_request_method_body(self):
        body = b'hi'
        r = self.pool.request('POST', '/echo', body=body)
        self.assertEqual(r.data, body)

        fields = [('hi', 'hello')]
        self.assertRaises(TypeError, self.pool.request, 'POST', '/echo', body=body, fields=fields)

    def test_unicode_upload(self):
        fieldname = u('myfile')
        filename = u('\xe2\x99\xa5.txt')
        data = u('\xe2\x99\xa5').encode('utf8')
        size = len(data)

        fields = {
            u('upload_param'): fieldname,
            u('upload_filename'): filename,
            u('upload_size'): size,
            fieldname: (filename, data),
        }

        r = self.pool.request('POST', '/upload', fields=fields)
        self.assertEqual(r.status, 200, r.data)

    def test_nagle(self):
        """""" Test that connections have TCP_NODELAY turned on """"""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        pool._make_request(conn, 'GET', '/')
        tcp_nodelay_setting = conn.sock.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)
        self.assertTrue(tcp_nodelay_setting)

    def test_socket_options(self):
        """"""Test that connections accept socket options.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries to
        # connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port, socket_options=[
            (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
        ])
        s = pool._new_conn()._new_conn()  # Get the socket
        using_keepalive = s.getsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE) > 0
        self.assertTrue(using_keepalive)
        s.close()

    def test_disable_default_socket_options(self):
        """"""Test that passing None disables all socket options.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port, socket_options=None)
        s = pool._new_conn()._new_conn()
        using_nagle = s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY) == 0
        self.assertTrue(using_nagle)
        s.close()

    def test_defaults_are_applied(self):
        """"""Test that modifying the default socket options works.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        # Get the HTTPConnection instance
        conn = pool._new_conn()
        self.addCleanup(conn.close)
        # Update the default socket options
        conn.default_socket_options += [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]
        s = conn._new_conn()
        self.addCleanup(s.close)
        nagle_disabled = s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY) > 0
        using_keepalive = s.getsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE) > 0
        self.assertTrue(nagle_disabled)
        self.assertTrue(using_keepalive)

    def test_connection_error_retries(self):
        """""" ECONNREFUSED error should raise a connection error, with retries """"""
        port = find_unused_port()
        pool = HTTPConnectionPool(self.host, port)
        try:
            pool.request('GET', '/', retries=Retry(connect=3))
            self.fail(""Should have failed with a connection error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), NewConnectionError)

    def test_timeout_success(self):
        timeout = Timeout(connect=3, read=5, total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        pool.request('GET', '/')
        # This should not raise a ""Timeout already started"" error
        pool.request('GET', '/')

        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        # This should also not raise a ""Timeout already started"" error
        pool.request('GET', '/')

        timeout = Timeout(total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        pool.request('GET', '/')

    def test_tunnel(self):
        # note the actual httplib.py has no tests for this functionality
        timeout = Timeout(total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        conn.set_tunnel(self.host, self.port)

        conn._tunnel = mock.Mock(return_value=None)
        pool._make_request(conn, 'GET', '/')
        conn._tunnel.assert_called_once_with()

        # test that it's not called when tunnel is not set
        timeout = Timeout(total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)

        conn._tunnel = mock.Mock(return_value=None)
        pool._make_request(conn, 'GET', '/')
        self.assertFalse(conn._tunnel.called)

    def test_redirect(self):
        r = self.pool.request('GET', '/redirect', fields={'target': '/'}, redirect=False)
        self.assertEqual(r.status, 303)

        r = self.pool.request('GET', '/redirect', fields={'target': '/'})
        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_bad_connect(self):
        pool = HTTPConnectionPool('badhost.invalid', self.port)
        try:
            pool.request('GET', '/', retries=5)
            self.fail(""should raise timeout exception here"")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), NewConnectionError)

    def test_keepalive(self):
        pool = HTTPConnectionPool(self.host, self.port, block=True, maxsize=1)
        self.addCleanup(pool.close)

        r = pool.request('GET', '/keepalive?close=0')
        r = pool.request('GET', '/keepalive?close=0')

        self.assertEqual(r.status, 200)
        self.assertEqual(pool.num_connections, 1)
        self.assertEqual(pool.num_requests, 2)

    def test_keepalive_close(self):
        pool = HTTPConnectionPool(self.host, self.port,
                                  block=True, maxsize=1, timeout=2)
        self.addCleanup(pool.close)

        r = pool.request('GET', '/keepalive?close=1', retries=0,
                         headers={
                             ""Connection"": ""close"",
                         })

        self.assertEqual(pool.num_connections, 1)

        # The dummyserver will have responded with Connection:close,
        # and httplib will properly cleanup the socket.

        # We grab the HTTPConnection object straight from the Queue,
        # because _get_conn() is where the check & reset occurs
        # pylint: disable-msg=W0212
        conn = pool.pool.get()
        self.assertIsNone(conn.sock)
        pool._put_conn(conn)

        # Now with keep-alive
        r = pool.request('GET', '/keepalive?close=0', retries=0,
                         headers={
                             ""Connection"": ""keep-alive"",
                         })

        # The dummyserver responded with Connection:keep-alive, the connection
        # persists.
        conn = pool.pool.get()
        self.assertIsNotNone(conn.sock)
        pool._put_conn(conn)

        # Another request asking the server to close the connection. This one
        # should get cleaned up for the next request.
        r = pool.request('GET', '/keepalive?close=1', retries=0,
                         headers={
                             ""Connection"": ""close"",
                         })

        self.assertEqual(r.status, 200)

        conn = pool.pool.get()
        self.assertIsNone(conn.sock)
        pool._put_conn(conn)

        # Next request
        r = pool.request('GET', '/keepalive?close=0')

    def test_post_with_urlencode(self):
        data = {'banana': 'hammock', 'lol': 'cat'}
        r = self.pool.request('POST', '/echo', fields=data, encode_multipart=False)
        self.assertEqual(r.data.decode('utf-8'), urlencode(data))

    def test_post_with_multipart(self):
        data = {'banana': 'hammock', 'lol': 'cat'}
        r = self.pool.request('POST', '/echo',
                              fields=data,
                              encode_multipart=True)
        body = r.data.split(b'\r\n')

        encoded_data = encode_multipart_formdata(data)[0]
        expected_body = encoded_data.split(b'\r\n')

        # TODO: Get rid of extra parsing stuff when you can specify
        # a custom boundary to encode_multipart_formdata
        """"""
        We need to loop the return lines because a timestamp is attached
        from within encode_multipart_formdata. When the server echos back
        the data, it has the timestamp from when the data was encoded, which
        is not equivalent to when we run encode_multipart_formdata on
        the data again.
        """"""
        for i, line in enumerate(body):
            if line.startswith(b'--'):
                continue

            self.assertEqual(body[i], expected_body[i])

    def test_post_with_multipart__iter__(self):
        data = {'hello': 'world'}
        r = self.pool.request('POST', '/echo',
                              fields=data,
                              preload_content=False,
                              multipart_boundary=""boundary"",
                              encode_multipart=True)

        chunks = [chunk for chunk in r]
        assert chunks == [
            b""--boundary\r\n"",
            b'Content-Disposition: form-data; name=""hello""\r\n',
            b'\r\n',
            b'world\r\n',
            b""--boundary--\r\n""
        ]

    def test_check_gzip(self):
        r = self.pool.request('GET', '/encodingrequest',
                              headers={'accept-encoding': 'gzip'})
        self.assertEqual(r.headers.get('content-encoding'), 'gzip')
        self.assertEqual(r.data, b'hello, world!')

    def test_check_deflate(self):
        r = self.pool.request('GET', '/encodingrequest',
                              headers={'accept-encoding': 'deflate'})
        self.assertEqual(r.headers.get('content-encoding'), 'deflate')
        self.assertEqual(r.data, b'hello, world!')

    def test_bad_decode(self):
        self.assertRaises(DecodeError, self.pool.request,
                          'GET', '/encodingrequest',
                          headers={'accept-encoding': 'garbage-deflate'})

        self.assertRaises(DecodeError, self.pool.request,
                          'GET', '/encodingrequest',
                          headers={'accept-encoding': 'garbage-gzip'})

    def test_connection_count(self):
        pool = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(pool.close)

        pool.request('GET', '/')
        pool.request('GET', '/')
        pool.request('GET', '/')

        self.assertEqual(pool.num_connections, 1)
        self.assertEqual(pool.num_requests, 3)

    def test_connection_count_bigpool(self):
        http_pool = HTTPConnectionPool(self.host, self.port, maxsize=16)
        self.addCleanup(http_pool.close)

        http_pool.request('GET', '/')
        http_pool.request('GET', '/')
        http_pool.request('GET', '/')

        self.assertEqual(http_pool.num_connections, 1)
        self.assertEqual(http_pool.num_requests, 3)

    def test_partial_response(self):
        pool = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(pool.close)

        req_data = {'lol': 'cat'}
        resp_data = urlencode(req_data).encode('utf-8')

        r = pool.request('GET', '/echo', fields=req_data, preload_content=False)

        self.assertEqual(r.read(5), resp_data[:5])
        self.assertEqual(r.read(), resp_data[5:])

    def test_lazy_load_twice(self):
        # This test is sad and confusing. Need to figure out what's
        # going on with partial reads and socket reuse.

        pool = HTTPConnectionPool(self.host, self.port, block=True, maxsize=1, timeout=2)

        payload_size = 1024 * 2
        first_chunk = 512

        boundary = 'foo'

        req_data = {'count': 'a' * payload_size}
        resp_data = encode_multipart_formdata(req_data, boundary=boundary)[0]

        req2_data = {'count': 'b' * payload_size}
        resp2_data = encode_multipart_formdata(req2_data, boundary=boundary)[0]

        r1 = pool.request('POST', '/echo',
                          fields=req_data,
                          multipart_boundary=boundary,
                          preload_content=False)

        self.assertEqual(r1.read(first_chunk), resp_data[:first_chunk])

        try:
            r2 = pool.request('POST', '/echo', fields=req2_data, multipart_boundary=boundary,
                              preload_content=False, pool_timeout=0.001)

            # This branch should generally bail here, but maybe someday it will
            # work? Perhaps by some sort of magic. Consider it a TODO.

            self.assertEqual(r2.read(first_chunk), resp2_data[:first_chunk])

            self.assertEqual(r1.read(), resp_data[first_chunk:])
            self.assertEqual(r2.read(), resp2_data[first_chunk:])
            self.assertEqual(pool.num_requests, 2)

        except EmptyPoolError:
            self.assertEqual(r1.read(), resp_data[first_chunk:])
            self.assertEqual(pool.num_requests, 1)

        self.assertEqual(pool.num_connections, 1)

    def test_for_double_release(self):
        MAXSIZE = 5

        # Check default state
        pool = HTTPConnectionPool(self.host, self.port, maxsize=MAXSIZE)
        self.addCleanup(pool.close)
        self.assertEqual(pool.num_connections, 0)
        self.assertEqual(pool.pool.qsize(), MAXSIZE)

        # Make an empty slot for testing
        pool.pool.get()
        self.assertEqual(pool.pool.qsize(), MAXSIZE-1)

        # Check state after simple request
        pool.urlopen('GET', '/')
        self.assertEqual(pool.pool.qsize(), MAXSIZE-1)

        # Check state without release
        pool.urlopen('GET', '/', preload_content=False)
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

        pool.urlopen('GET', '/')
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

        # Check state after read
        pool.urlopen('GET', '/').data
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

        pool.urlopen('GET', '/')
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

    def test_release_conn_parameter(self):
        MAXSIZE = 5
        pool = HTTPConnectionPool(self.host, self.port, maxsize=MAXSIZE)
        self.assertEqual(pool.pool.qsize(), MAXSIZE)

        # Make request without releasing connection
        pool.request('GET', '/', release_conn=False, preload_content=False)
        self.assertEqual(pool.pool.qsize(), MAXSIZE-1)

    def test_dns_error(self):
        pool = HTTPConnectionPool('thishostdoesnotexist.invalid', self.port, timeout=0.001)
        self.assertRaises(MaxRetryError, pool.request, 'GET', '/test', retries=2)

    def test_source_address(self):
        for addr, is_ipv6 in VALID_SOURCE_ADDRESSES:
            if is_ipv6 and not HAS_IPV6_AND_DNS:
                warnings.warn(""No IPv6 support: skipping."",
                              NoIPv6Warning)
                continue
            pool = HTTPConnectionPool(self.host, self.port,
                                      source_address=addr, retries=False)
            self.addCleanup(pool.close)
            r = pool.request('GET', '/source_address')
            self.assertEqual(r.data, b(addr[0]))

    def test_source_address_error(self):
        for addr in INVALID_SOURCE_ADDRESSES:
            pool = HTTPConnectionPool(self.host, self.port, source_address=addr, retries=False)
            # FIXME: This assert flakes sometimes. Not sure why.
            self.assertRaises(NewConnectionError,
                              pool.request,
                              'GET', '/source_address?{0}'.format(addr))

    def test_stream_keepalive(self):
        x = 2

        for _ in range(x):
            response = self.pool.request(
                    'GET',
                    '/chunked',
                    headers={
                        'Connection': 'keep-alive',
                        },
                    preload_content=False,
                    retries=False,
                    )
            for chunk in response.stream():
                self.assertEqual(chunk, b'123')

        self.assertEqual(self.pool.num_connections, 1)
        self.assertEqual(self.pool.num_requests, x)

    def test_read_chunked_short_circuit(self):
        response = self.pool.request(
            'GET',
            '/chunked',
            preload_content=False
        )
        response.read()
        with pytest.raises(StopIteration):
            next(response.read_chunked())

    def test_read_chunked_on_closed_response(self):
        response = self.pool.request(
            'GET',
            '/chunked',
            preload_content=False
        )
        response.close()
        with pytest.raises(StopIteration):
            next(response.read_chunked())

    def test_chunked_gzip(self):
        response = self.pool.request(
                'GET',
                '/chunked_gzip',
                preload_content=False,
                decode_content=True,
                )

        self.assertEqual(b'123' * 4, response.read())

    def test_cleanup_on_connection_error(self):
        '''
        Test that connections are recycled to the pool on
        connection errors where no http response is received.
        '''
        poolsize = 3
        with HTTPConnectionPool(self.host, self.port, maxsize=poolsize, block=True) as http:
            self.assertEqual(http.pool.qsize(), poolsize)

            # force a connection error by supplying a non-existent
            # url. We won't get a response for this  and so the
            # conn won't be implicitly returned to the pool.
            self.assertRaises(MaxRetryError,
                              http.request,
                              'GET', '/redirect',
                              fields={'target': '/'}, release_conn=False, retries=0)

            r = http.request('GET', '/redirect',
                             fields={'target': '/'},
                             release_conn=False,
                             retries=1)
            r.release_conn()

            # the pool should still contain poolsize elements
            self.assertEqual(http.pool.qsize(), http.pool.maxsize)

    def test_mixed_case_hostname(self):
        pool = HTTPConnectionPool(""LoCaLhOsT"", self.port)
        self.addCleanup(pool.close)
        response = pool.request('GET', ""http://LoCaLhOsT:%d/"" % self.port)
        self.assertEqual(response.status, 200)


class TestRetry(HTTPDummyServerTestCase):
    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(self.pool.close)

    def test_max_retry(self):
        try:
            r = self.pool.request('GET', '/redirect',
                                  fields={'target': '/'},
                                  retries=0)
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

    def test_disabled_retry(self):
        """""" Disabled retries should disable redirect handling. """"""
        r = self.pool.request('GET', '/redirect',
                              fields={'target': '/'},
                              retries=False)
        self.assertEqual(r.status, 303)

        r = self.pool.request('GET', '/redirect',
                              fields={'target': '/'},
                              retries=Retry(redirect=False))
        self.assertEqual(r.status, 303)

        pool = HTTPConnectionPool('thishostdoesnotexist.invalid', self.port, timeout=0.001)
        self.assertRaises(NewConnectionError, pool.request, 'GET', '/test', retries=False)

    def test_read_retries(self):
        """""" Should retry for status codes in the whitelist """"""
        retry = Retry(read=1, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers={'test-name': 'test_read_retries'},
                                 retries=retry)
        self.assertEqual(resp.status, 200)

    def test_read_total_retries(self):
        """""" HTTP response w/ status code in the whitelist should be retried """"""
        headers = {'test-name': 'test_read_total_retries'}
        retry = Retry(total=1, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)

    def test_retries_wrong_whitelist(self):
        """"""HTTP response w/ status code not in whitelist shouldn't be retried""""""
        retry = Retry(total=1, status_forcelist=[202])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers={'test-name': 'test_wrong_whitelist'},
                                 retries=retry)
        self.assertEqual(resp.status, 418)

    def test_default_method_whitelist_retried(self):
        """""" urllib3 should retry methods in the default method whitelist """"""
        retry = Retry(total=1, status_forcelist=[418])
        resp = self.pool.request('OPTIONS', '/successful_retry',
                                 headers={'test-name': 'test_default_whitelist'},
                                 retries=retry)
        self.assertEqual(resp.status, 200)

    def test_retries_wrong_method_list(self):
        """"""Method not in our whitelist should not be retried, even if code matches""""""
        headers = {'test-name': 'test_wrong_method_whitelist'}
        retry = Retry(total=1, status_forcelist=[418],
                      method_whitelist=['POST'])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 418)

    def test_read_retries_unsuccessful(self):
        headers = {'test-name': 'test_read_retries_unsuccessful'}
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=1)
        self.assertEqual(resp.status, 418)

    def test_retry_reuse_safe(self):
        """""" It should be possible to reuse a Retry object across requests """"""
        headers = {'test-name': 'test_retry_safe'}
        retry = Retry(total=1, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)

    def test_retry_return_in_response(self):
        headers = {'test-name': 'test_retry_return_in_response'}
        retry = Retry(total=2, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)
        self.assertEqual(resp.retries.total, 1)
        self.assertEqual(resp.retries.history,
                         (RequestHistory('GET', '/successful_retry', None, 418, None),))

    def test_retry_redirect_history(self):
        resp = self.pool.request('GET', '/redirect', fields={'target': '/'})
        self.assertEqual(resp.status, 200)
        self.assertEqual(resp.retries.history,
                         (RequestHistory('GET', '/redirect?target=%2F', None, 303, '/'),))

    def test_multi_redirect_history(self):
        r = self.pool.request('GET', '/multi_redirect',
                              fields={'redirect_codes': '303,302,200'},
                              redirect=False)
        self.assertEqual(r.status, 303)
        self.assertEqual(r.retries.history, tuple())

        r = self.pool.request('GET', '/multi_redirect', retries=10,
                              fields={'redirect_codes': '303,302,301,307,302,200'})
        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Done redirecting')

        expected = [(303, '/multi_redirect?redirect_codes=302,301,307,302,200'),
                    (302, '/multi_redirect?redirect_codes=301,307,302,200'),
                    (301, '/multi_redirect?redirect_codes=307,302,200'),
                    (307, '/multi_redirect?redirect_codes=302,200'),
                    (302, '/multi_redirect?redirect_codes=200')]
        actual = [(history.status, history.redirect_location) for history in r.retries.history]
        self.assertEqual(actual, expected)


class TestRetryAfter(HTTPDummyServerTestCase):
    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(self.pool.close)

    def test_retry_after(self):
        # Request twice in a second to get a 429 response.
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '429 Too Many Requests'},
                              retries=False)
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '429 Too Many Requests'},
                              retries=False)
        self.assertEqual(r.status, 429)

        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '429 Too Many Requests'},
                              retries=True)
        self.assertEqual(r.status, 200)

        # Request twice in a second to get a 503 response.
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '503 Service Unavailable'},
                              retries=False)
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '503 Service Unavailable'},
                              retries=False)
        self.assertEqual(r.status, 503)

        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '503 Service Unavailable'},
                              retries=True)
        self.assertEqual(r.status, 200)

        # Ignore Retry-After header on status which is not defined in
        # Retry.RETRY_AFTER_STATUS_CODES.
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': ""418 I'm a teapot""},
                              retries=True)
        self.assertEqual(r.status, 418)

    def test_redirect_after(self):
        r = self.pool.request('GET', '/redirect_after', retries=False)
        self.assertEqual(r.status, 303)

        t = time.time()
        r = self.pool.request('GET', '/redirect_after')
        self.assertEqual(r.status, 200)
        delta = time.time() - t
        self.assertGreaterEqual(delta, 1)

        t = time.time()
        timestamp = t + 2
        r = self.pool.request('GET', '/redirect_after?date=' + str(timestamp))
        self.assertEqual(r.status, 200)
        delta = time.time() - t
        self.assertGreaterEqual(delta, 1)

        # Retry-After is past
        t = time.time()
        timestamp = t - 1
        r = self.pool.request('GET', '/redirect_after?date=' + str(timestamp))
        delta = time.time() - t
        self.assertEqual(r.status, 200)
        self.assertLess(delta, 1)


class TestFileBodiesOnRetryOrRedirect(HTTPDummyServerTestCase):
    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port, timeout=0.1)
        self.addCleanup(self.pool.close)

    def test_retries_put_filehandle(self):
        """"""HTTP PUT retry with a file-like object should not timeout""""""
        retry = Retry(total=3, status_forcelist=[418])
        # httplib reads in 8k chunks; use a larger content length
        content_length = 65535
        data = b'A' * content_length
        uploaded_file = io.BytesIO(data)
        headers = {'test-name': 'test_retries_put_filehandle',
                   'Content-Length': str(content_length)}
        resp = self.pool.urlopen('PUT', '/successful_retry',
                                 headers=headers,
                                 retries=retry,
                                 body=uploaded_file,
                                 assert_same_host=False, redirect=False)
        self.assertEqual(resp.status, 200)

    def test_redirect_put_file(self):
        """"""PUT with file object should work with a redirection response""""""
        retry = Retry(total=3, status_forcelist=[418])
        # httplib reads in 8k chunks; use a larger content length
        content_length = 65535
        data = b'A' * content_length
        uploaded_file = io.BytesIO(data)
        headers = {'test-name': 'test_redirect_put_file',
                   'Content-Length': str(content_length)}
        url = '/redirect?target=/echo&status=307'
        resp = self.pool.urlopen('PUT', url,
                                 headers=headers,
                                 retries=retry,
                                 body=uploaded_file,
                                 assert_same_host=False, redirect=True)
        self.assertEqual(resp.status, 200)
        self.assertEqual(resp.data, data)

    def test_redirect_with_failed_tell(self):
        """"""Abort request if failed to get a position from tell()""""""
        class BadTellObject(io.BytesIO):

            def tell(self):
                raise IOError

        body = BadTellObject(b'the data')
        url = '/redirect?target=/successful_retry'
        # httplib uses fileno if Content-Length isn't supplied,
        # which is unsupported by BytesIO.
        headers = {'Content-Length': '8'}
        try:
            self.pool.urlopen('PUT', url, headers=headers, body=body)
            self.fail('PUT successful despite failed rewind.')
        except UnrewindableBodyError as e:
            self.assertIn('Unable to record file position for', str(e))


class TestRetryPoolSize(HTTPDummyServerTestCase):
    def setUp(self):
        retries = Retry(
            total=1,
            raise_on_status=False,
            status_forcelist=[404],
        )
        self.pool = HTTPConnectionPool(self.host, self.port, maxsize=10,
                                       retries=retries, block=True)
        self.addCleanup(self.pool.close)

    def test_pool_size_retry(self):
        self.pool.urlopen('GET', '/not_found', preload_content=False)
        assert self.pool.num_connections == 1


class TestRedirectPoolSize(HTTPDummyServerTestCase):
    def setUp(self):
        retries = Retry(
            total=1,
            raise_on_status=False,
            status_forcelist=[404],
            redirect=True,
        )
        self.pool = HTTPConnectionPool(self.host, self.port, maxsize=10,
                                       retries=retries, block=True)
        self.addCleanup(self.pool.close)

    def test_pool_size_redirect(self):
        self.pool.urlopen('GET', '/redirect', preload_content=False)
        assert self.pool.num_connections == 1


if __name__ == '__main__':
    unittest.main()",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .. VAR ( VAR, VAR, VAR, ) VAR ..VAR VAR VAR VAR VAR VAR ( VAR, VAR, ) VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR, VAR VAR VAR VAR VAR VAR = VAR.VAR('VAR.VAR') VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR(VAR.VAR)) VAR = 0.001 VAR = 0.03 VAR VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=2)  VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR(VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR()   VAR(VAR) VAR.VAR()  VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR=VAR, VAR=1) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR.VAR, 1024) VAR: VAR.VAR(VAR) VAR.VAR() VAR VAR(VAR):  VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=6)  VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR.VAR(VAR) VAR.VAR()  VAR(VAR) VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR()   VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/', VAR=VAR) VAR = VAR.VAR() - VAR VAR.VAR()  VAR = ""VAR VAR VAR-VAR VAR VAR VAR VAR-VAR VAR"" VAR.VAR(VAR, VAR, VAR) VAR.VAR(VAR) VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR) VAR = VAR.VAR() - VAR VAR = ""VAR VAR VAR-VAR VAR VAR VAR VAR-VAR VAR"" VAR.VAR(VAR, VAR, VAR) VAR.VAR()    VAR(VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR) VAR.VAR()  VAR(VAR) VAR = VAR.VAR()  VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/', VAR=VAR) VAR.VAR()  VAR VAR(VAR): VAR = '/' VAR, VAR = VAR, 80 VAR = VAR(VAR=VAR)  VAR = VAR(VAR, VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', VAR)  VAR = VAR(VAR=0) VAR.VAR(VAR, VAR.VAR, 'VAR', VAR, VAR=VAR)  VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR(VAR, VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', VAR, VAR=VAR) VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', VAR, VAR=VAR) VAR VAR(VAR): VAR, VAR = VAR, 80 VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR(VAR, VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR = VAR(VAR, VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR VAR(VAR): VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=2) VAR(VAR)  VAR = VAR(VAR=3, VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR() VAR(VAR) VAR.VAR()  VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR VAR(VAR): VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR?VAR=VAR') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR):  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 400, VAR.VAR) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 400, VAR.VAR) VAR VAR(VAR): VAR = ""VAR'VAR VAR VAR VAR VAR-VAR, VAR VAR VAR"" VAR = { 'VAR': 'VAR', 'VAR': 'VAR.VAR', 'VAR': VAR(VAR), 'VAR': ('VAR.VAR', VAR), } VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR = [ ('VAR', 'VAR'), ('VAR', 'VAR'), ]  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, VAR'VAR=VAR&VAR=VAR')  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR.VAR(VAR'VAR=""VAR""'), 2) VAR VAR(VAR): VAR = VAR'VAR' VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, VAR) VAR = [('VAR', 'VAR')] VAR.VAR(VAR, VAR.VAR.VAR, 'VAR', '/VAR', VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = VAR('VAR') VAR = VAR('\VAR\VAR\VAR.VAR') VAR = VAR('\VAR\VAR\VAR').VAR('VAR') VAR = VAR(VAR) VAR = { VAR('VAR'): VAR, VAR('VAR'): VAR, VAR('VAR'): VAR, VAR: (VAR, VAR), } VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR """"""   VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, 'VAR', '/') VAR = VAR.VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR.""""""   VAR = VAR(VAR.VAR, VAR.VAR, VAR=[ (VAR.VAR, VAR.VAR, 1) ]) VAR = VAR.VAR().VAR()  VAR = VAR.VAR(VAR.VAR, VAR.VAR) > 0 VAR.VAR(VAR) VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR.""""""   VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR = VAR.VAR().VAR() VAR = VAR.VAR(VAR.VAR, VAR.VAR) == 0 VAR.VAR(VAR) VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR.""""""   VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR)  VAR = VAR.VAR() VAR.VAR(VAR.VAR)  VAR.VAR += [(VAR.VAR, VAR.VAR, 1)] VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) > 0 VAR = VAR.VAR(VAR.VAR, VAR.VAR) > 0 VAR.VAR(VAR) VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR, VAR VAR """""" VAR = VAR() VAR = VAR(VAR.VAR, VAR) VAR: VAR.VAR('VAR', '/', VAR=VAR(VAR=3)) VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/')  VAR.VAR('VAR', '/') VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR)  VAR.VAR('VAR', '/') VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR VAR(VAR):  VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR.VAR(VAR=VAR) VAR.VAR(VAR, 'VAR', '/') VAR.VAR.VAR()  VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR = VAR.VAR(VAR=VAR) VAR.VAR(VAR, 'VAR', '/') VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR('VAR.VAR', VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=5) VAR.VAR(""VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=1) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/VAR?VAR=0') VAR = VAR.VAR('VAR', '/VAR?VAR=0') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 2) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=1, VAR=2) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/VAR?VAR=1', VAR=0, VAR={ ""VAR"": ""VAR"", }) VAR.VAR(VAR.VAR, 1)      VAR = VAR.VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR)  VAR = VAR.VAR('VAR', '/VAR?VAR=0', VAR=0, VAR={ ""VAR"": ""VAR-VAR"", })   VAR = VAR.VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR)   VAR = VAR.VAR('VAR', '/VAR?VAR=1', VAR=0, VAR={ ""VAR"": ""VAR"", }) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR)  VAR = VAR.VAR('VAR', '/VAR?VAR=0') VAR VAR(VAR): VAR = {'VAR': 'VAR', 'VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR('VAR-8'), VAR(VAR)) VAR VAR(VAR): VAR = {'VAR': 'VAR', 'VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR = VAR.VAR.VAR(VAR'\VAR\VAR') VAR = VAR(VAR)[0] VAR = VAR.VAR(VAR'\VAR\VAR')   """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR, VAR VAR VAR(VAR): VAR VAR.VAR(VAR'--'): VAR VAR.VAR(VAR[VAR], VAR[VAR]) VAR VAR(VAR): VAR = {'VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=""VAR"", VAR=VAR) VAR = [VAR VAR VAR VAR VAR] VAR VAR == [ VAR""--VAR\VAR\VAR"", VAR'VAR-VAR: VAR-VAR; VAR=""VAR""\VAR\VAR', VAR'\VAR\VAR', VAR'VAR\VAR\VAR', VAR""--VAR--\VAR\VAR"" ] VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}) VAR.VAR(VAR.VAR.VAR('VAR-VAR'), 'VAR') VAR.VAR(VAR.VAR, VAR'VAR, VAR!') VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}) VAR.VAR(VAR.VAR.VAR('VAR-VAR'), 'VAR') VAR.VAR(VAR.VAR, VAR'VAR, VAR!') VAR VAR(VAR): VAR.VAR(VAR, VAR.VAR.VAR, 'VAR', '/VAR', VAR={'VAR-VAR': 'VAR-VAR'}) VAR.VAR(VAR, VAR.VAR.VAR, 'VAR', '/VAR', VAR={'VAR-VAR': 'VAR-VAR'}) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 3) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=16) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 3) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR) VAR = {'VAR': 'VAR'} VAR = VAR(VAR).VAR('VAR-8') VAR = VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR(5), VAR[:5]) VAR.VAR(VAR.VAR(), VAR[5:]) VAR VAR(VAR):   VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=1, VAR=2) VAR = 1024 * 2 VAR = 512 VAR = 'VAR' VAR = {'VAR': 'VAR' * VAR} VAR = VAR(VAR, VAR=VAR)[0] VAR = {'VAR': 'VAR' * VAR} VAR = VAR(VAR, VAR=VAR)[0] VAR = VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR(VAR), VAR[:VAR]) VAR: VAR = VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=VAR, VAR=0.001)   VAR.VAR(VAR.VAR(VAR), VAR[:VAR]) VAR.VAR(VAR.VAR(), VAR[VAR:]) VAR.VAR(VAR.VAR(), VAR[VAR:]) VAR.VAR(VAR.VAR, 2) VAR VAR: VAR.VAR(VAR.VAR(), VAR[VAR:]) VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 1) VAR VAR(VAR): VAR = 5  VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR, 0) VAR.VAR(VAR.VAR.VAR(), VAR)  VAR.VAR.VAR() VAR.VAR(VAR.VAR.VAR(), VAR-1)  VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR.VAR(), VAR-1)  VAR.VAR('VAR', '/', VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR-2) VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR.VAR(), VAR-2)  VAR.VAR('VAR', '/').VAR VAR.VAR(VAR.VAR.VAR(), VAR-2) VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR.VAR(), VAR-2) VAR VAR(VAR): VAR = 5 VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR)  VAR.VAR('VAR', '/', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR-1) VAR VAR(VAR): VAR = VAR('VAR.VAR', VAR.VAR, VAR=0.001) VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR', VAR=2) VAR VAR(VAR): VAR VAR, VAR VAR VAR: VAR VAR VAR VAR VAR: VAR.VAR(""VAR VAR VAR: VAR."", VAR) VAR VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/VAR') VAR.VAR(VAR.VAR, VAR(VAR[0])) VAR VAR(VAR): VAR VAR VAR VAR: VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR)  VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR?{0}'.VAR(VAR)) VAR VAR(VAR): VAR = 2 VAR VAR VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR={ 'VAR': 'VAR-VAR', }, VAR=VAR, VAR=VAR, ) VAR VAR VAR VAR.VAR(): VAR.VAR(VAR, VAR'123') VAR.VAR(VAR.VAR.VAR, 1) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR=VAR ) VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR=VAR ) VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR=VAR, VAR=VAR, ) VAR.VAR(VAR'123' * 4, VAR.VAR()) VAR VAR(VAR): ''' VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ''' VAR = 3 VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR VAR: VAR.VAR(VAR.VAR.VAR(), VAR)    VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR, VAR=0) VAR = VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR, VAR=1) VAR.VAR()  VAR.VAR(VAR.VAR.VAR(), VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR(""VAR"", VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', ""VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR: VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=0) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR(VAR=VAR)) VAR.VAR(VAR.VAR, 303) VAR = VAR('VAR.VAR', VAR.VAR, VAR=0.001) VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR', VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """""" VAR VAR VAR/ VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """"""VAR VAR VAR/ VAR VAR VAR VAR VAR VAR'VAR VAR VAR"""""" VAR = VAR(VAR=1, VAR=[202]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR"""""" VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=1, VAR=[418], VAR=['VAR']) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=1) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=2, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR.VAR, 1) VAR.VAR(VAR.VAR.VAR, (VAR('VAR', '/VAR', VAR, 418, VAR),)) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR.VAR, (VAR('VAR', '/VAR?VAR=%2F', VAR, 303, '/'),)) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '303,302,200'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR.VAR(VAR.VAR.VAR, VAR()) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=10, VAR={'VAR': '303,302,301,307,302,200'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR') VAR = [(303, '/VAR?VAR=302,301,307,302,200'), (302, '/VAR?VAR=301,307,302,200'), (301, '/VAR?VAR=307,302,200'), (307, '/VAR?VAR=302,200'), (302, '/VAR?VAR=200')] VAR = [(VAR.VAR, VAR.VAR) VAR VAR VAR VAR.VAR.VAR] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR):  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '429 VAR VAR VAR'}, VAR=VAR) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '429 VAR VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 429) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '429 VAR VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200)  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '503 VAR VAR'}, VAR=VAR) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '503 VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 503) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '503 VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200)   VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': ""418 VAR'VAR VAR VAR""}, VAR=VAR) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR() VAR = VAR.VAR.VAR('VAR', '/VAR') VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR() - VAR VAR.VAR(VAR, 1) VAR = VAR.VAR() VAR = VAR + 2 VAR = VAR.VAR.VAR('VAR', '/VAR?VAR=' + VAR(VAR)) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR() - VAR VAR.VAR(VAR, 1)  VAR = VAR.VAR() VAR = VAR - 1 VAR = VAR.VAR.VAR('VAR', '/VAR?VAR=' + VAR(VAR)) VAR = VAR.VAR() - VAR VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR, 1) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.1) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR"""""" VAR = VAR(VAR=3, VAR=[418])  VAR = 65535 VAR = VAR'VAR' * VAR VAR = VAR.VAR(VAR) VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': VAR(VAR)} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR = VAR(VAR=3, VAR=[418])  VAR = 65535 VAR = VAR'VAR' * VAR VAR = VAR.VAR(VAR) VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': VAR(VAR)} VAR = '/VAR?VAR=/VAR&VAR=307' VAR = VAR.VAR.VAR('VAR', VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR()"""""" VAR VAR(VAR.VAR): VAR VAR(VAR): VAR VAR VAR = VAR(VAR'VAR VAR') VAR = '/VAR?VAR=/VAR'   VAR = {'VAR-VAR': '8'} VAR: VAR.VAR.VAR('VAR', VAR, VAR=VAR, VAR=VAR) VAR.VAR('VAR VAR VAR VAR VAR.') VAR VAR VAR VAR: VAR.VAR('VAR VAR VAR VAR VAR VAR', VAR(VAR)) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR( VAR=1, VAR=VAR, VAR=[404], ) VAR.VAR = VAR(VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR.VAR.VAR == 1 VAR VAR(VAR): VAR VAR(VAR): VAR = VAR( VAR=1, VAR=VAR, VAR=[404], VAR=VAR, ) VAR.VAR = VAR(VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR.VAR.VAR == 1 VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/with_dummyserver/test_https.py,"import datetime
import json
import logging
import ssl
import sys
import unittest
import warnings

import mock
import pytest

from dummyserver.testcase import (
    HTTPSDummyServerTestCase, IPV6HTTPSDummyServerTestCase
)
from dummyserver.server import (DEFAULT_CA, DEFAULT_CA_BAD, DEFAULT_CERTS,
                                DEFAULT_CLIENT_CERTS,
                                DEFAULT_CLIENT_NO_INTERMEDIATE_CERTS,
                                NO_SAN_CERTS, NO_SAN_CA, DEFAULT_CA_DIR,
                                IPV6_ADDR_CERTS, IPV6_ADDR_CA, HAS_IPV6,
                                IP_SAN_CERTS)

from test import (
    onlyPy279OrNewer,
    notSecureTransport,
    notOpenSSL098,
    requires_network,
    fails_on_travis_gce,
    TARPIT_HOST,
)
from urllib3 import HTTPSConnectionPool
from urllib3.connection import (
    VerifiedHTTPSConnection,
    UnverifiedHTTPSConnection,
    RECENT_DATE,
)
from urllib3.exceptions import (
    SSLError,
    ConnectTimeoutError,
    InsecureRequestWarning,
    SystemTimeWarning,
    InsecurePlatformWarning,
    MaxRetryError,
    ProtocolError,
)
from urllib3.packages import six
from urllib3.util.timeout import Timeout
import urllib3.util as util


ResourceWarning = getattr(
        six.moves.builtins,
        'ResourceWarning', type('ResourceWarning', (), {}))


log = logging.getLogger('urllib3.connectionpool')
log.setLevel(logging.NOTSET)
log.addHandler(logging.StreamHandler(sys.stdout))


class TestHTTPS(HTTPSDummyServerTestCase):
    def setUp(self):
        self._pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(self._pool.close)

    def test_simple(self):
        r = self._pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)

    @fails_on_travis_gce
    def test_dotted_fqdn(self):
        pool = HTTPSConnectionPool(self.host + '.', self.port)
        r = pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)

    def test_set_ssl_version_to_tlsv1(self):
        self._pool.ssl_version = ssl.PROTOCOL_TLSv1
        r = self._pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)

    def test_client_intermediate(self):
        client_cert, client_key = (
            DEFAULT_CLIENT_CERTS['certfile'],
            DEFAULT_CLIENT_CERTS['keyfile'],
        )
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         key_file=client_key,
                                         cert_file=client_cert)
        r = https_pool.request('GET', '/certificate')
        subject = json.loads(r.data.decode('utf-8'))
        assert subject['organizationalUnitName'].startswith(
            'Testing server cert')

    def test_client_no_intermediate(self):
        client_cert, client_key = (
            DEFAULT_CLIENT_NO_INTERMEDIATE_CERTS['certfile'],
            DEFAULT_CLIENT_NO_INTERMEDIATE_CERTS['keyfile']
        )
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_file=client_cert,
                                         key_file=client_key)
        try:
            https_pool.request('GET', '/certificate', retries=False)
        except SSLError as e:
            if not ('alert unknown ca' in str(e) or
                    'invalid certificate chain' in str(e) or
                    'unknown Cert Authority' in str(e) or
                    # https://github.com/urllib3/urllib3/issues/1422
                    'connection closed via error' in str(e) or
                    'WSAECONNRESET' in str(e)):
                raise
        except ProtocolError as e:
            # https://github.com/urllib3/urllib3/issues/1422
            if not ('An existing connection was forcibly closed by the remote host' in str(e)):
                raise

    def test_verified(self):
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)

            # Modern versions of Python, or systems using PyOpenSSL, don't
            # emit warnings.
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                self.assertFalse(warn.called, warn.call_args_list)
            else:
                self.assertTrue(warn.called)
                if util.HAS_SNI:
                    call = warn.call_args_list[0]
                else:
                    call = warn.call_args_list[1]
                error = call[0][1]
                self.assertEqual(error, InsecurePlatformWarning)

    def test_verified_with_context(self):
        ctx = util.ssl_.create_urllib3_context(cert_reqs=ssl.CERT_REQUIRED)
        ctx.load_verify_locations(cafile=DEFAULT_CA)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         ssl_context=ctx)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)

            # Modern versions of Python, or systems using PyOpenSSL, don't
            # emit warnings.
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                self.assertFalse(warn.called, warn.call_args_list)
            else:
                self.assertTrue(warn.called)
                if util.HAS_SNI:
                    call = warn.call_args_list[0]
                else:
                    call = warn.call_args_list[1]
                error = call[0][1]
                self.assertEqual(error, InsecurePlatformWarning)

    def test_context_combines_with_ca_certs(self):
        ctx = util.ssl_.create_urllib3_context(cert_reqs=ssl.CERT_REQUIRED)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         ca_certs=DEFAULT_CA,
                                         ssl_context=ctx)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)

            # Modern versions of Python, or systems using PyOpenSSL, don't
            # emit warnings.
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                self.assertFalse(warn.called, warn.call_args_list)
            else:
                self.assertTrue(warn.called)
                if util.HAS_SNI:
                    call = warn.call_args_list[0]
                else:
                    call = warn.call_args_list[1]
                error = call[0][1]
                self.assertEqual(error, InsecurePlatformWarning)

    @onlyPy279OrNewer
    @notSecureTransport  # SecureTransport does not support cert directories
    @notOpenSSL098  # OpenSSL 0.9.8 does not support cert directories
    def test_ca_dir_verified(self):
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_cert_dir=DEFAULT_CA_DIR)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertFalse(warn.called, warn.call_args_list)

    def test_invalid_common_name(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        try:
            https_pool.request('GET', '/')
            self.fail(""Didn't raise SSL invalid common name"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertTrue(
                ""doesn't match"" in str(e.reason) or
                ""certificate verify failed"" in str(e.reason)
            )

    def test_verified_with_bad_ca_certs(self):
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(https_pool.close)

        try:
            https_pool.request('GET', '/')
            self.fail(""Didn't raise SSL error with bad CA certs"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertIn('certificate verify failed', str(e.reason),
                          ""Expected 'certificate verify failed',""
                          ""instead got: %r"" % e.reason)

    def test_verified_without_ca_certs(self):
        # default is cert_reqs=None which is ssl.CERT_NONE
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)

        try:
            https_pool.request('GET', '/')
            self.fail(""Didn't raise SSL error with no CA certs when""
                      ""CERT_REQUIRED is set"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            # there is a different error message depending on whether or
            # not pyopenssl is injected
            self.assertTrue('No root certificates specified' in str(e.reason) or
                            'certificate verify failed' in str(e.reason) or
                            'invalid certificate chain' in str(e.reason),
                            ""Expected 'No root certificates specified',  ""
                            ""'certificate verify failed', or ""
                            ""'invalid certificate chain', ""
                            ""instead got: %r"" % e.reason)

    def test_no_ssl(self):
        pool = HTTPSConnectionPool(self.host, self.port)
        pool.ConnectionCls = None
        self.addCleanup(pool.close)
        self.assertRaises(SSLError, pool._new_conn)
        with self.assertRaises(MaxRetryError) as cm:
            pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)

    def test_unverified_ssl(self):
        """""" Test that bare HTTPSConnection can connect, make requests """"""
        pool = HTTPSConnectionPool(self.host, self.port)
        pool.ConnectionCls = UnverifiedHTTPSConnection
        self.addCleanup(pool.close)

        with mock.patch('warnings.warn') as warn:
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertTrue(warn.called)

            # Modern versions of Python, or systems using PyOpenSSL, only emit
            # the unverified warning. Older systems may also emit other
            # warnings, which we want to ignore here.
            calls = warn.call_args_list
            self.assertIn(InsecureRequestWarning, [x[0][1] for x in calls])

    def test_ssl_unverified_with_ca_certs(self):
        pool = HTTPSConnectionPool(self.host, self.port,
                                   cert_reqs='CERT_NONE',
                                   ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(pool.close)

        with mock.patch('warnings.warn') as warn:
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertTrue(warn.called)

            # Modern versions of Python, or systems using PyOpenSSL, only emit
            # the unverified warning. Older systems may also emit other
            # warnings, which we want to ignore here.
            calls = warn.call_args_list
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                category = calls[0][0][1]
            elif util.HAS_SNI:
                category = calls[1][0][1]
            else:
                category = calls[2][0][1]
            self.assertEqual(category, InsecureRequestWarning)

    def test_assert_hostname_false(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_hostname = False
        https_pool.request('GET', '/')

    def test_assert_specific_hostname(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_hostname = 'localhost'
        https_pool.request('GET', '/')

    def test_server_hostname(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA,
                                         server_hostname='localhost')
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        conn.request('GET', '/')

        # Assert the wrapping socket is using the passed-through SNI name.
        # pyopenssl doesn't let you pull the server_hostname back off the
        # socket, so only add this assertion if the attribute is there (i.e.
        # the python ssl module).
        if hasattr(conn.sock, 'server_hostname'):
            self.assertEqual(conn.sock.server_hostname, ""localhost"")

    def test_assert_fingerprint_md5(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = 'F2:06:5A:42:10:3F:45:1C:17:FE:E6:' \
                                        '07:1E:8A:86:E5'

        https_pool.request('GET', '/')

    def test_assert_fingerprint_sha1(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'
        https_pool.request('GET', '/')

    def test_assert_fingerprint_sha256(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = ('C5:4D:0B:83:84:89:2E:AE:B4:58:BB:12:'
                                         'F7:A6:C4:76:05:03:88:D8:57:65:51:F3:'
                                         '1E:60:B0:8B:70:18:64:E6')
        https_pool.request('GET', '/')

    def test_assert_invalid_fingerprint(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = 'AA:AA:AA:AA:AA:AAAA:AA:AAAA:AA:' \
                                        'AA:AA:AA:AA:AA:AA:AA:AA:AA'

        def _test_request(pool):
            with self.assertRaises(MaxRetryError) as cm:
                pool.request('GET', '/', retries=0)
            self.assertIsInstance(cm.exception.reason, SSLError)

        _test_request(https_pool)
        https_pool._get_conn()

        # Uneven length
        https_pool.assert_fingerprint = 'AA:A'
        _test_request(https_pool)
        https_pool._get_conn()

        # Invalid length
        https_pool.assert_fingerprint = 'AA'
        _test_request(https_pool)

    def test_verify_none_and_bad_fingerprint(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_NONE',
                                         ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = 'AA:AA:AA:AA:AA:AAAA:AA:AAAA:AA:' \
                                        'AA:AA:AA:AA:AA:AA:AA:AA:AA'
        with self.assertRaises(MaxRetryError) as cm:
            https_pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)

    def test_verify_none_and_good_fingerprint(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_NONE',
                                         ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'
        https_pool.request('GET', '/')

    @notSecureTransport
    def test_good_fingerprint_and_hostname_mismatch(self):
        # This test doesn't run with SecureTransport because we don't turn off
        # hostname validation without turning off all validation, which this
        # test doesn't do (deliberately). We should revisit this if we make
        # new decisions.
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'
        https_pool.request('GET', '/')

    @requires_network
    def test_https_timeout(self):
        timeout = Timeout(connect=0.001)
        https_pool = HTTPSConnectionPool(TARPIT_HOST, self.port,
                                         timeout=timeout, retries=False,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)

        timeout = Timeout(total=None, connect=0.001)
        https_pool = HTTPSConnectionPool(TARPIT_HOST, self.port,
                                         timeout=timeout, retries=False,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/')

        timeout = Timeout(read=0.001)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         timeout=timeout, retries=False,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)
        https_pool.ca_certs = DEFAULT_CA
        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'

        timeout = Timeout(total=None)
        https_pool = HTTPSConnectionPool(self.host, self.port, timeout=timeout,
                                         cert_reqs='CERT_NONE')
        self.addCleanup(https_pool.close)
        https_pool.request('GET', '/')

    def test_tunnel(self):
        """""" test the _tunnel behavior """"""
        timeout = Timeout(total=None)
        https_pool = HTTPSConnectionPool(self.host, self.port, timeout=timeout,
                                         cert_reqs='CERT_NONE')
        self.addCleanup(https_pool.close)
        conn = https_pool._new_conn()
        self.addCleanup(conn.close)
        conn.set_tunnel(self.host, self.port)
        conn._tunnel = mock.Mock()
        https_pool._make_request(conn, 'GET', '/')
        conn._tunnel.assert_called_once_with()

    @requires_network
    def test_enhanced_timeout(self):
        def new_pool(timeout, cert_reqs='CERT_REQUIRED'):
            https_pool = HTTPSConnectionPool(TARPIT_HOST, self.port,
                                             timeout=timeout,
                                             retries=False,
                                             cert_reqs=cert_reqs)
            self.addCleanup(https_pool.close)
            return https_pool

        https_pool = new_pool(Timeout(connect=0.001))
        conn = https_pool._new_conn()
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/')
        self.assertRaises(ConnectTimeoutError, https_pool._make_request, conn,
                          'GET', '/')

        https_pool = new_pool(Timeout(connect=5))
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/',
                          timeout=Timeout(connect=0.001))

        t = Timeout(total=None)
        https_pool = new_pool(t)
        conn = https_pool._new_conn()
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/',
                          timeout=Timeout(total=None, connect=0.001))

    def test_enhanced_ssl_connection(self):
        fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:BF:93:CF:F9:71:CC:07:7D:0A'

        conn = VerifiedHTTPSConnection(self.host, self.port)
        self.addCleanup(conn.close)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA,
                                         assert_fingerprint=fingerprint)
        self.addCleanup(https_pool.close)

        https_pool._make_request(conn, 'GET', '/')

    @onlyPy279OrNewer
    def test_ssl_correct_system_time(self):
        self._pool.cert_reqs = 'CERT_REQUIRED'
        self._pool.ca_certs = DEFAULT_CA

        w = self._request_without_resource_warnings('GET', '/')
        self.assertEqual([], w)

    @onlyPy279OrNewer
    def test_ssl_wrong_system_time(self):
        self._pool.cert_reqs = 'CERT_REQUIRED'
        self._pool.ca_certs = DEFAULT_CA
        with mock.patch('urllib3.connection.datetime') as mock_date:
            mock_date.date.today.return_value = datetime.date(1970, 1, 1)

            w = self._request_without_resource_warnings('GET', '/')

            self.assertEqual(len(w), 1)
            warning = w[0]

            self.assertEqual(SystemTimeWarning, warning.category)
            self.assertIn(str(RECENT_DATE), warning.message.args[0])

    def _request_without_resource_warnings(self, method, url):
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter('always')
            self._pool.request(method, url)

        return [x for x in w if not isinstance(x.message, ResourceWarning)]


class TestHTTPS_TLSv1(HTTPSDummyServerTestCase):
    certs = DEFAULT_CERTS.copy()
    certs['ssl_version'] = ssl.PROTOCOL_TLSv1

    def setUp(self):
        self._pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(self._pool.close)

    def test_discards_connection_on_sslerror(self):
        self._pool.cert_reqs = 'CERT_REQUIRED'
        with self.assertRaises(MaxRetryError) as cm:
            self._pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)
        self._pool.ca_certs = DEFAULT_CA
        self._pool.request('GET', '/')

    def test_set_cert_default_cert_required(self):
        conn = VerifiedHTTPSConnection(self.host, self.port)
        conn.set_cert(ca_certs=DEFAULT_CA)
        self.assertEqual(conn.cert_reqs, 'CERT_REQUIRED')


class TestHTTPS_NoSAN(HTTPSDummyServerTestCase):
    certs = NO_SAN_CERTS

    def test_warning_for_certs_without_a_san(self):
        """"""Ensure that a warning is raised when the cert from the server has
        no Subject Alternative Name.""""""
        with mock.patch('warnings.warn') as warn:
            https_pool = HTTPSConnectionPool(self.host, self.port,
                                             cert_reqs='CERT_REQUIRED',
                                             ca_certs=NO_SAN_CA)
            self.addCleanup(https_pool.close)
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertTrue(warn.called)


class TestHTTPS_IPSAN(HTTPSDummyServerTestCase):
    certs = IP_SAN_CERTS

    def test_can_validate_ip_san(self):
        """"""Ensure that urllib3 can validate SANs with IP addresses in them.""""""
        try:
            import ipaddress  # noqa: F401
        except ImportError:
            pytest.skip(""Only runs on systems with an ipaddress module"")

        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)
        r = https_pool.request('GET', '/')
        self.assertEqual(r.status, 200)


class TestHTTPS_IPv6Addr(IPV6HTTPSDummyServerTestCase):
    certs = IPV6_ADDR_CERTS

    @pytest.mark.skipif(not HAS_IPV6, reason='Only runs on IPv6 systems')
    def test_strip_square_brackets_before_validating(self):
        """"""Test that the fix for #760 works.""""""
        https_pool = HTTPSConnectionPool('[::1]', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=IPV6_ADDR_CA)
        self.addCleanup(https_pool.close)
        r = https_pool.request('GET', '/')
        self.assertEqual(r.status, 200)


if __name__ == '__main__':
    unittest.main()",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR ) VAR VAR.VAR VAR (VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR) VAR VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, ) VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR = VAR( VAR.VAR.VAR, 'VAR', VAR('VAR', (), {})) VAR = VAR.VAR('VAR.VAR') VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR(VAR.VAR)) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) @VAR VAR VAR(VAR): VAR = VAR(VAR.VAR + '.', VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR = VAR.VAR VAR = VAR.VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR, VAR = ( VAR['VAR'], VAR['VAR'], ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR('VAR', '/VAR') VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR VAR['VAR'].VAR( 'VAR VAR VAR') VAR VAR(VAR): VAR, VAR = ( VAR['VAR'], VAR['VAR'] ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR: VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR VAR VAR: VAR VAR ('VAR VAR VAR' VAR VAR(VAR) VAR 'VAR VAR VAR' VAR VAR(VAR) VAR 'VAR VAR VAR' VAR VAR(VAR) VAR  'VAR VAR VAR VAR' VAR VAR(VAR) VAR 'VAR' VAR VAR(VAR)): VAR VAR VAR VAR VAR:  VAR VAR ('VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR(VAR)): VAR VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200)   VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR: VAR.VAR(VAR.VAR) VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR(VAR=VAR.VAR) VAR.VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200)   VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR: VAR.VAR(VAR.VAR) VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR(VAR=VAR.VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200)   VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR: VAR.VAR(VAR.VAR) VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR.VAR(VAR, VAR) @VAR @VAR  @VAR  VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR( ""VAR'VAR VAR"" VAR VAR(VAR.VAR) VAR ""VAR VAR VAR"" VAR VAR(VAR.VAR) ) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR('VAR VAR VAR', VAR(VAR.VAR), ""VAR 'VAR VAR VAR',"" ""VAR VAR: %VAR"" % VAR.VAR) VAR VAR(VAR):  VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR"" ""VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR)   VAR.VAR('VAR VAR VAR VAR' VAR VAR(VAR.VAR) VAR 'VAR VAR VAR' VAR VAR(VAR.VAR) VAR 'VAR VAR VAR' VAR VAR(VAR.VAR), ""VAR 'VAR VAR VAR VAR', "" ""'VAR VAR VAR', VAR "" ""'VAR VAR VAR', "" ""VAR VAR: %VAR"" % VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR """""" VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR VAR.VAR(VAR.VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR)    VAR = VAR.VAR VAR.VAR(VAR, [VAR[0][1] VAR VAR VAR VAR]) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR)    VAR = VAR.VAR VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR = VAR[0][0][1] VAR VAR.VAR: VAR = VAR[1][0][1] VAR: VAR = VAR[2][0][1] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = VAR VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR' VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR('VAR', '/')     VAR VAR(VAR.VAR, 'VAR'): VAR.VAR(VAR.VAR.VAR, ""VAR"") VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR:06:5A:42:10:3F:45:1C:17:VAR:VAR:' \ '07:1E:8A:86:VAR' VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = ('VAR:4D:0B:83:84:89:2E:VAR:VAR:58:VAR:12:' 'VAR:VAR:VAR:76:05:03:88:VAR:57:65:51:VAR:' '1E:60:VAR:8B:70:18:64:VAR') VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:' \ 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR' VAR VAR(VAR): VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR(VAR) VAR.VAR()  VAR.VAR = 'VAR:VAR' VAR(VAR) VAR.VAR()  VAR.VAR = 'VAR' VAR(VAR) VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:' \ 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR' VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR.VAR('VAR', '/') @VAR VAR VAR(VAR):     VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR.VAR('VAR', '/') @VAR VAR VAR(VAR): VAR = VAR(VAR=0.001) VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR(VAR=VAR, VAR=0.001) VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR = VAR(VAR=0.001) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR.VAR = VAR VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR VAR(VAR): """""" VAR VAR VAR VAR """""" VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR.VAR() VAR.VAR(VAR, 'VAR', '/') VAR.VAR.VAR() @VAR VAR VAR(VAR): VAR VAR(VAR, VAR='VAR'): VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR VAR = VAR(VAR(VAR=0.001)) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR = VAR(VAR(VAR=5)) VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR(VAR=0.001)) VAR = VAR(VAR=VAR) VAR = VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR(VAR=VAR, VAR=0.001)) VAR VAR(VAR): VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, 'VAR', '/') @VAR VAR VAR(VAR): VAR.VAR.VAR = 'VAR' VAR.VAR.VAR = VAR VAR = VAR.VAR('VAR', '/') VAR.VAR([], VAR) @VAR VAR VAR(VAR): VAR.VAR.VAR = 'VAR' VAR.VAR.VAR = VAR VAR VAR.VAR('VAR.VAR.VAR') VAR VAR: VAR.VAR.VAR.VAR = VAR.VAR(1970, 1, 1) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR(VAR), 1) VAR = VAR[0] VAR.VAR(VAR, VAR.VAR) VAR.VAR(VAR(VAR), VAR.VAR.VAR[0]) VAR VAR(VAR, VAR, VAR): VAR VAR.VAR(VAR=VAR) VAR VAR: VAR.VAR('VAR') VAR.VAR.VAR(VAR, VAR) VAR [VAR VAR VAR VAR VAR VAR VAR VAR(VAR.VAR, VAR)] VAR VAR(VAR): VAR = VAR.VAR() VAR['VAR'] = VAR.VAR VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR = 'VAR' VAR VAR.VAR(VAR) VAR VAR: VAR.VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR.VAR.VAR = VAR VAR.VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR=VAR) VAR.VAR(VAR.VAR, 'VAR') VAR VAR(VAR): VAR = VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR = VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR: VAR VAR  VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR"") VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR @VAR.VAR.VAR(VAR VAR, VAR='VAR VAR VAR VAR VAR') VAR VAR(VAR): """"""VAR VAR VAR VAR VAR  VAR = VAR('[::1]', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/with_dummyserver/test_no_ssl.py,"""""""
Test connections without the builtin ssl module

Note: Import urllib3 inside the test functions to get the importblocker to work
""""""
from ..test_no_ssl import TestWithoutSSL

from dummyserver.testcase import (
        HTTPDummyServerTestCase, HTTPSDummyServerTestCase)

import urllib3


class TestHTTPWithoutSSL(HTTPDummyServerTestCase, TestWithoutSSL):
    def test_simple(self):
        pool = urllib3.HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)


class TestHTTPSWithoutSSL(HTTPSDummyServerTestCase, TestWithoutSSL):
    def test_simple(self):
        pool = urllib3.HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        try:
            pool.request('GET', '/')
        except urllib3.exceptions.SSLError as e:
            self.assertIn('SSL module is not available', str(e))",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,""""""" VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR ..VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR) VAR VAR VAR VAR(VAR, VAR): VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR, VAR): VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR VAR.VAR.VAR VAR VAR: VAR.VAR('VAR VAR VAR VAR VAR', VAR(VAR)) ",8
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/with_dummyserver/test_poolmanager.py,"import unittest
import json

import pytest

from dummyserver.server import HAS_IPV6
from dummyserver.testcase import (HTTPDummyServerTestCase,
                                  IPv6HTTPDummyServerTestCase)
from urllib3.poolmanager import PoolManager
from urllib3.connectionpool import port_by_scheme
from urllib3.exceptions import MaxRetryError
from urllib3.util.retry import Retry


class TestPoolManager(HTTPDummyServerTestCase):

    def setUp(self):
        self.base_url = 'http://%s:%d' % (self.host, self.port)
        self.base_url_alt = 'http://%s:%d' % (self.host_alt, self.port)

    def test_redirect(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/' % self.base_url},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/' % self.base_url})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_redirect_twice(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/redirect' % self.base_url},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                       self.base_url)})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_redirect_to_relative_url(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '/redirect'},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '/redirect'})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_cross_host_redirect(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        cross_host_location = '%s/echo?a=b' % self.base_url_alt
        try:
            http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': cross_host_location},
                         timeout=1, retries=0)
            self.fail(""Request succeeded instead of raising an exception like it should."")

        except MaxRetryError:
            pass

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/echo?a=b' % self.base_url_alt},
                         timeout=1, retries=1)

        self.assertEqual(r._pool.host, self.host_alt)

    def test_too_many_redirects(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        try:
            r = http.request('GET', '%s/redirect' % self.base_url,
                             fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                           self.base_url)},
                             retries=1)
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

        try:
            r = http.request('GET', '%s/redirect' % self.base_url,
                             fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                           self.base_url)},
                             retries=Retry(total=None, redirect=1))
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

    def test_redirect_cross_host_remove_headers(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'Authorization': 'foo'})

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('Authorization', data)

    def test_redirect_cross_host_no_remove_headers(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'Authorization': 'foo'},
                         retries=Retry(remove_headers_on_redirect=[]))

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertEqual(data['Authorization'], 'foo')

    def test_redirect_cross_host_set_removed_headers(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'X-API-Secret': 'foo',
                                  'Authorization': 'bar'},
                         retries=Retry(remove_headers_on_redirect=['X-API-Secret']))

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('X-API-Secret', data)
        self.assertEqual(data['Authorization'], 'bar')

    def test_raise_on_redirect(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                       self.base_url)},
                         retries=Retry(total=None, redirect=1, raise_on_redirect=False))

        self.assertEqual(r.status, 303)

    def test_raise_on_status(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        try:
            # the default is to raise
            r = http.request('GET', '%s/status' % self.base_url,
                             fields={'status': '500 Internal Server Error'},
                             retries=Retry(total=1, status_forcelist=range(500, 600)))
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

        try:
            # raise explicitly
            r = http.request('GET', '%s/status' % self.base_url,
                             fields={'status': '500 Internal Server Error'},
                             retries=Retry(total=1,
                                           status_forcelist=range(500, 600),
                                           raise_on_status=True))
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

        # don't raise
        r = http.request('GET', '%s/status' % self.base_url,
                         fields={'status': '500 Internal Server Error'},
                         retries=Retry(total=1,
                                       status_forcelist=range(500, 600),
                                       raise_on_status=False))

        self.assertEqual(r.status, 500)

    def test_missing_port(self):
        # Can a URL that lacks an explicit port like ':80' succeed, or
        # will all such URLs fail with an error?

        http = PoolManager()
        self.addCleanup(http.clear)

        # By globally adjusting `port_by_scheme` we pretend for a moment
        # that HTTP's default port is not 80, but is the port at which
        # our test server happens to be listening.
        port_by_scheme['http'] = self.port
        try:
            r = http.request('GET', 'http://%s/' % self.host, retries=0)
        finally:
            port_by_scheme['http'] = 80

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_headers(self):
        http = PoolManager(headers={'Foo': 'bar'})
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request('POST', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request_encode_url('GET', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request_encode_body('POST', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request_encode_url('GET', '%s/headers' % self.base_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')

        r = http.request_encode_body('GET', '%s/headers' % self.base_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')

    def test_http_with_ssl_keywords(self):
        http = PoolManager(ca_certs='REQUIRED')
        self.addCleanup(http.clear)

        r = http.request('GET', 'http://%s:%s/' % (self.host, self.port))
        self.assertEqual(r.status, 200)

    def test_http_with_ca_cert_dir(self):
        http = PoolManager(ca_certs='REQUIRED', ca_cert_dir='/nosuchdir')
        self.addCleanup(http.clear)

        r = http.request('GET', 'http://%s:%s/' % (self.host, self.port))
        self.assertEqual(r.status, 200)


@pytest.mark.skipif(
    not HAS_IPV6,
    reason='IPv6 is not supported on this system'
)
class TestIPv6PoolManager(IPv6HTTPDummyServerTestCase):

    def setUp(self):
        self.base_url = 'http://[%s]:%d' % (self.host, self.port)

    def test_ipv6(self):
        http = PoolManager()
        self.addCleanup(http.clear)
        http.request('GET', self.base_url)


if __name__ == '__main__':
    unittest.main()",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR (VAR, VAR) VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '/VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '/VAR'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = '%VAR/VAR?VAR=VAR' % VAR.VAR VAR: VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': VAR}, VAR=1, VAR=0) VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=VAR' % VAR.VAR}, VAR=1, VAR=1) VAR.VAR(VAR.VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR: VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}, VAR=1) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR: VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}, VAR=VAR(VAR=VAR, VAR=1)) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR', VAR) VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR': 'VAR'}, VAR=VAR(VAR=[])) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR(VAR['VAR'], 'VAR') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR-VAR-VAR': 'VAR', 'VAR': 'VAR'}, VAR=VAR(VAR=['VAR-VAR-VAR'])) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR-VAR-VAR', VAR) VAR.VAR(VAR['VAR'], 'VAR') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}, VAR=VAR(VAR=VAR, VAR=1, VAR=VAR)) VAR.VAR(VAR.VAR, 303) VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR:  VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '500 VAR VAR VAR'}, VAR=VAR(VAR=1, VAR=VAR(500, 600))) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR:  VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '500 VAR VAR VAR'}, VAR=VAR(VAR=1, VAR=VAR(500, 600), VAR=VAR)) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR  VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '500 VAR VAR VAR'}, VAR=VAR(VAR=1, VAR=VAR(500, 600), VAR=VAR)) VAR.VAR(VAR.VAR, 500) VAR VAR(VAR):   VAR = VAR() VAR.VAR(VAR.VAR)    VAR['VAR'] = VAR.VAR VAR: VAR = VAR.VAR('VAR', 'VAR: VAR: VAR['VAR'] = 80 VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR(VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR VAR(VAR): VAR = VAR(VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR(VAR='VAR', VAR='/VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) @VAR.VAR.VAR( VAR VAR, VAR='VAR VAR VAR VAR VAR VAR VAR' ) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR.VAR('VAR', VAR.VAR) VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/with_dummyserver/test_proxy_poolmanager.py,"import json
import socket
import unittest

import pytest

from dummyserver.testcase import HTTPDummyProxyTestCase, IPv6HTTPDummyProxyTestCase
from dummyserver.server import (
    DEFAULT_CA, DEFAULT_CA_BAD, get_unreachable_address)
from .. import TARPIT_HOST, requires_network

from urllib3._collections import HTTPHeaderDict
from urllib3.poolmanager import proxy_from_url, ProxyManager
from urllib3.exceptions import (
    MaxRetryError, SSLError, ProxyError, ConnectTimeoutError)
from urllib3.connectionpool import connection_from_url, VerifiedHTTPSConnection


class TestHTTPProxyManager(HTTPDummyProxyTestCase):

    def setUp(self):
        self.http_url = 'http://%s:%d' % (self.http_host, self.http_port)
        self.http_url_alt = 'http://%s:%d' % (self.http_host_alt,
                                              self.http_port)
        self.https_url = 'https://%s:%d' % (self.https_host, self.https_port)
        self.https_url_alt = 'https://%s:%d' % (self.https_host_alt,
                                                self.https_port)
        self.proxy_url = 'http://%s:%d' % (self.proxy_host, self.proxy_port)

    def test_basic_proxy(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url)
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url)
        self.assertEqual(r.status, 200)

    def test_nagle_proxy(self):
        """""" Test that proxy connections do not have TCP_NODELAY turned on """"""
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)
        hc2 = http.connection_from_host(self.http_host, self.http_port)
        conn = hc2._get_conn()
        self.addCleanup(conn.close)
        hc2._make_request(conn, 'GET', '/')
        tcp_nodelay_setting = conn.sock.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)
        self.assertEqual(tcp_nodelay_setting, 0,
                         (""Expected TCP_NODELAY for proxies to be set ""
                          ""to zero, instead was %s"" % tcp_nodelay_setting))

    def test_proxy_conn_fail(self):
        host, port = get_unreachable_address()
        http = proxy_from_url('http://%s:%s/' % (host, port), retries=1, timeout=0.05)
        self.addCleanup(http.clear)
        self.assertRaises(MaxRetryError, http.request, 'GET',
                          '%s/' % self.https_url)
        self.assertRaises(MaxRetryError, http.request, 'GET',
                          '%s/' % self.http_url)

        try:
            http.request('GET', '%s/' % self.http_url)
            self.fail(""Failed to raise retry error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), ProxyError)

    def test_oldapi(self):
        http = ProxyManager(connection_from_url(self.proxy_url))
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url)
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url)
        self.assertEqual(r.status, 200)

    def test_proxy_verified(self):
        http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                              ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(http.clear)
        https_pool = http._new_pool('https', self.https_host,
                                    self.https_port)
        try:
            https_pool.request('GET', '/', retries=0)
            self.fail(""Didn't raise SSL error with wrong CA"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertIn('certificate verify failed', str(e.reason),
                          ""Expected 'certificate verify failed',""
                          ""instead got: %r"" % e.reason)

        http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                              ca_certs=DEFAULT_CA)
        https_pool = http._new_pool('https', self.https_host,
                                    self.https_port)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)
        https_pool.request('GET', '/')  # Should succeed without exceptions.

        http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                              ca_certs=DEFAULT_CA)
        https_fail_pool = http._new_pool('https', '127.0.0.1', self.https_port)

        try:
            https_fail_pool.request('GET', '/', retries=0)
            self.fail(""Didn't raise SSL invalid common name"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertIn(""doesn't match"", str(e.reason))

    def test_redirect(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/' % self.http_url},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/' % self.http_url})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_cross_host_redirect(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        cross_host_location = '%s/echo?a=b' % self.http_url_alt
        try:
            http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': cross_host_location},
                         timeout=1, retries=0)
            self.fail(""We don't want to follow redirects here."")

        except MaxRetryError:
            pass

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/echo?a=b' % self.http_url_alt},
                         timeout=1, retries=1)
        self.assertNotEqual(r._pool.host, self.http_host_alt)

    def test_cross_protocol_redirect(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        cross_protocol_location = '%s/echo?a=b' % self.https_url
        try:
            http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': cross_protocol_location},
                         timeout=1, retries=0)
            self.fail(""We don't want to follow redirects here."")

        except MaxRetryError:
            pass

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/echo?a=b' % self.https_url},
                         timeout=1, retries=1)
        self.assertEqual(r._pool.host, self.https_host)

    def test_headers(self):
        http = proxy_from_url(self.proxy_url, headers={'Foo': 'bar'},
                              proxy_headers={'Hickory': 'dickory'})
        self.addCleanup(http.clear)

        r = http.request_encode_url('GET', '%s/headers' % self.http_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.http_url_alt)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host_alt, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.https_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host, self.https_port))

        r = http.request_encode_url('GET', '%s/headers' % self.https_url_alt)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host_alt, self.https_port))

        r = http.request_encode_body('POST', '%s/headers' % self.http_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.http_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.https_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host, self.https_port))

        r = http.request_encode_body('GET', '%s/headers' % self.http_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_body('GET', '%s/headers' % self.https_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host, self.https_port))

    def test_headerdict(self):
        default_headers = HTTPHeaderDict(a='b')
        proxy_headers = HTTPHeaderDict()
        proxy_headers.add('foo', 'bar')

        http = proxy_from_url(
            self.proxy_url,
            headers=default_headers,
            proxy_headers=proxy_headers)
        self.addCleanup(http.clear)

        request_headers = HTTPHeaderDict(baz='quux')
        r = http.request('GET', '%s/headers' % self.http_url, headers=request_headers)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Baz'), 'quux')

    def test_proxy_pooling(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        for x in range(2):
            http.urlopen('GET', self.http_url)
        self.assertEqual(len(http.pools), 1)

        for x in range(2):
            http.urlopen('GET', self.http_url_alt)
        self.assertEqual(len(http.pools), 1)

        for x in range(2):
            http.urlopen('GET', self.https_url)
        self.assertEqual(len(http.pools), 2)

        for x in range(2):
            http.urlopen('GET', self.https_url_alt)
        self.assertEqual(len(http.pools), 3)

    def test_proxy_pooling_ext(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        hc1 = http.connection_from_url(self.http_url)
        hc2 = http.connection_from_host(self.http_host, self.http_port)
        hc3 = http.connection_from_url(self.http_url_alt)
        hc4 = http.connection_from_host(self.http_host_alt, self.http_port)
        self.assertEqual(hc1, hc2)
        self.assertEqual(hc2, hc3)
        self.assertEqual(hc3, hc4)

        sc1 = http.connection_from_url(self.https_url)
        sc2 = http.connection_from_host(self.https_host,
                                        self.https_port, scheme='https')
        sc3 = http.connection_from_url(self.https_url_alt)
        sc4 = http.connection_from_host(self.https_host_alt,
                                        self.https_port, scheme='https')
        self.assertEqual(sc1, sc2)
        self.assertNotEqual(sc2, sc3)
        self.assertEqual(sc3, sc4)

    @pytest.mark.timeout(0.5)
    @requires_network
    def test_https_proxy_timeout(self):
        https = proxy_from_url('https://{host}'.format(host=TARPIT_HOST))
        self.addCleanup(https.clear)
        try:
            https.request('GET', self.http_url, timeout=0.001)
            self.fail(""Failed to raise retry error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), ConnectTimeoutError)

    @pytest.mark.timeout(0.5)
    @requires_network
    def test_https_proxy_pool_timeout(self):
        https = proxy_from_url('https://{host}'.format(host=TARPIT_HOST),
                               timeout=0.001)
        self.addCleanup(https.clear)
        try:
            https.request('GET', self.http_url)
            self.fail(""Failed to raise retry error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), ConnectTimeoutError)

    def test_scheme_host_case_insensitive(self):
        """"""Assert that upper-case schemes and hosts are normalized.""""""
        http = proxy_from_url(self.proxy_url.upper())
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url.upper())
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url.upper())
        self.assertEqual(r.status, 200)


class TestIPv6HTTPProxyManager(IPv6HTTPDummyProxyTestCase):

    def setUp(self):
        self.http_url = 'http://%s:%d' % (self.http_host, self.http_port)
        self.http_url_alt = 'http://%s:%d' % (self.http_host_alt,
                                              self.http_port)
        self.https_url = 'https://%s:%d' % (self.https_host, self.https_port)
        self.https_url_alt = 'https://%s:%d' % (self.https_host_alt,
                                                self.https_port)
        self.proxy_url = 'http://[%s]:%d' % (self.proxy_host, self.proxy_port)

    def test_basic_ipv6_proxy(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url)
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url)
        self.assertEqual(r.status, 200)


if __name__ == '__main__':
    unittest.main()",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR) VAR .. VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR) VAR VAR.VAR VAR VAR, VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, 'VAR', '/') VAR = VAR.VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR, 0, (""VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR, VAR VAR %VAR"" % VAR)) VAR VAR(VAR): VAR, VAR = VAR() VAR = VAR('VAR: VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '%VAR/' % VAR.VAR) VAR: VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): VAR = VAR(VAR(VAR.VAR)) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', VAR.VAR, VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR('VAR VAR VAR', VAR(VAR.VAR), ""VAR 'VAR VAR VAR',"" ""VAR VAR: %VAR"" % VAR.VAR) VAR = VAR(VAR.VAR, VAR='VAR', VAR=VAR) VAR = VAR.VAR('VAR', VAR.VAR, VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR.VAR('VAR', '/')  VAR = VAR(VAR.VAR, VAR='VAR', VAR=VAR) VAR = VAR.VAR('VAR', '127.0.0.1', VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR(""VAR'VAR VAR"", VAR(VAR.VAR)) VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = '%VAR/VAR?VAR=VAR' % VAR.VAR VAR: VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': VAR}, VAR=1, VAR=0) VAR.VAR(""VAR VAR'VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=VAR' % VAR.VAR}, VAR=1, VAR=1) VAR.VAR(VAR.VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = '%VAR/VAR?VAR=VAR' % VAR.VAR VAR: VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': VAR}, VAR=1, VAR=0) VAR.VAR(""VAR VAR'VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=VAR' % VAR.VAR}, VAR=1, VAR=1) VAR.VAR(VAR.VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR={'VAR': 'VAR'}, VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR VAR(VAR): VAR = VAR(VAR='VAR') VAR = VAR() VAR.VAR('VAR', 'VAR') VAR = VAR( VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR(VAR='VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR=VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 1) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 1) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 2) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 3) VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR, VAR='VAR') VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR, VAR='VAR') VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) @VAR.VAR.VAR(0.5) @VAR VAR VAR(VAR): VAR = VAR('VAR: VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', VAR.VAR, VAR=0.001) VAR.VAR(""VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) @VAR.VAR.VAR(0.5) @VAR VAR VAR(VAR): VAR = VAR('VAR: VAR=0.001) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): """"""VAR VAR VAR-VAR VAR VAR VAR VAR VAR."""""" VAR = VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR.VAR()) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR.VAR()) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/with_dummyserver/test_socketlevel.py,"# TODO: Break this module up into pieces. Maybe group by functionality tested
# rather than the socket level-ness of it.

from urllib3 import HTTPConnectionPool, HTTPSConnectionPool
from urllib3.poolmanager import proxy_from_url
from urllib3.exceptions import (
        MaxRetryError,
        ProxyError,
        ReadTimeoutError,
        SSLError,
        ProtocolError,
)
from urllib3.response import httplib
from urllib3.util.ssl_ import HAS_SNI
from urllib3.util.timeout import Timeout
from urllib3.util.retry import Retry
from urllib3._collections import HTTPHeaderDict

from dummyserver.testcase import SocketDummyServerTestCase, consume_socket
from dummyserver.server import (
    DEFAULT_CERTS, DEFAULT_CA, COMBINED_CERT_AND_KEY, get_unreachable_address)

from .. import onlyPy3, LogRecorder

try:
    from mimetools import Message as MimeToolMessage
except ImportError:
    class MimeToolMessage(object):
        pass
from collections import OrderedDict
from threading import Event
import select
import socket
import ssl

import pytest

from test import fails_on_travis_gce


class TestCookies(SocketDummyServerTestCase):

    def test_multi_setcookie(self):
        def multicookie_response_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(b'HTTP/1.1 200 OK\r\n'
                      b'Set-Cookie: foo=1\r\n'
                      b'Set-Cookie: bar=1\r\n'
                      b'\r\n')
            sock.close()

        self._start_server(multicookie_response_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/', retries=0)
        self.assertEqual(r.headers, {'set-cookie': 'foo=1, bar=1'})
        self.assertEqual(r.headers.getlist('set-cookie'), ['foo=1', 'bar=1'])


class TestSNI(SocketDummyServerTestCase):

    @pytest.mark.skipif(not HAS_SNI, reason='SNI-support not available')
    def test_hostname_in_first_request_packet(self):
        done_receiving = Event()
        self.buf = b''

        def socket_handler(listener):
            sock = listener.accept()[0]

            self.buf = sock.recv(65536)  # We only accept one packet
            done_receiving.set()  # let the test know it can proceed
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        try:
            pool.request('GET', '/', retries=0)
        except MaxRetryError:  # We are violating the protocol
            pass
        done_receiving.wait()
        self.assertIn(self.host.encode('ascii'), self.buf,
                      ""missing hostname in SSL handshake"")


class TestClientCerts(SocketDummyServerTestCase):
    """"""
    Tests for client certificate support.
    """"""
    def _wrap_in_ssl(self, sock):
        """"""
        Given a single socket, wraps it in TLS.
        """"""
        return ssl.wrap_socket(
            sock,
            ssl_version=ssl.PROTOCOL_SSLv23,
            cert_reqs=ssl.CERT_REQUIRED,
            ca_certs=DEFAULT_CA,
            certfile=DEFAULT_CERTS['certfile'],
            keyfile=DEFAULT_CERTS['keyfile'],
            server_side=True
        )

    def test_client_certs_two_files(self):
        """"""
        Having a client cert in a separate file to its associated key works
        properly.
        """"""
        done_receiving = Event()
        client_certs = []

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock = self._wrap_in_ssl(sock)

            client_certs.append(sock.getpeercert())

            data = b''
            while not data.endswith(b'\r\n\r\n'):
                data += sock.recv(8192)

            sock.sendall(
                b'HTTP/1.1 200 OK\r\n'
                b'Server: testsocket\r\n'
                b'Connection: close\r\n'
                b'Content-Length: 6\r\n'
                b'\r\n'
                b'Valid!'
            )

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(
            self.host,
            self.port,
            cert_file=DEFAULT_CERTS['certfile'],
            key_file=DEFAULT_CERTS['keyfile'],
            cert_reqs='REQUIRED',
            ca_certs=DEFAULT_CA,
        )
        self.addCleanup(pool.close)
        pool.request('GET', '/', retries=0)
        done_receiving.set()

        self.assertEqual(len(client_certs), 1)

    def test_client_certs_one_file(self):
        """"""
        Having a client cert and its associated private key in just one file
        works properly.
        """"""
        done_receiving = Event()
        client_certs = []

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock = self._wrap_in_ssl(sock)

            client_certs.append(sock.getpeercert())

            data = b''
            while not data.endswith(b'\r\n\r\n'):
                data += sock.recv(8192)

            sock.sendall(
                b'HTTP/1.1 200 OK\r\n'
                b'Server: testsocket\r\n'
                b'Connection: close\r\n'
                b'Content-Length: 6\r\n'
                b'\r\n'
                b'Valid!'
            )

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(
            self.host,
            self.port,
            cert_file=COMBINED_CERT_AND_KEY,
            cert_reqs='REQUIRED',
            ca_certs=DEFAULT_CA,
        )
        self.addCleanup(pool.close)
        pool.request('GET', '/', retries=0)
        done_receiving.set()

        self.assertEqual(len(client_certs), 1)

    def test_missing_client_certs_raises_error(self):
        """"""
        Having client certs not be present causes an error.
        """"""
        done_receiving = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            try:
                self._wrap_in_ssl(sock)
            except ssl.SSLError:
                pass

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(
            self.host,
            self.port,
            cert_reqs='REQUIRED',
            ca_certs=DEFAULT_CA,
        )
        self.addCleanup(pool.close)
        try:
            pool.request('GET', '/', retries=0)
        except MaxRetryError:
            done_receiving.set()
        else:
            done_receiving.set()
            self.fail(
                ""Expected server to reject connection due to missing client ""
                ""certificates""
            )


class TestSocketClosing(SocketDummyServerTestCase):

    def test_recovery_when_server_closes_connection(self):
        # Does the pool work seamlessly if an open connection in the
        # connection pool gets hung up on by the server, then reaches
        # the front of the queue again?

        done_closing = Event()

        def socket_handler(listener):
            for i in 0, 1:
                sock = listener.accept()[0]

                buf = b''
                while not buf.endswith(b'\r\n\r\n'):
                    buf = sock.recv(65536)

                body = 'Response %d' % i
                sock.send(('HTTP/1.1 200 OK\r\n'
                           'Content-Type: text/plain\r\n'
                           'Content-Length: %d\r\n'
                           '\r\n'
                           '%s' % (len(body), body)).encode('utf-8'))

                sock.close()  # simulate a server timing out, closing socket
                done_closing.set()  # let the test know it can proceed

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.request('GET', '/', retries=0)
        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'Response 0')

        done_closing.wait()  # wait until the socket in our pool gets closed

        response = pool.request('GET', '/', retries=0)
        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'Response 1')

    def test_connection_refused(self):
        # Does the pool retry if there is no listener on the port?
        host, port = get_unreachable_address()
        http = HTTPConnectionPool(host, port, maxsize=3, block=True)
        self.addCleanup(http.close)
        self.assertRaises(MaxRetryError, http.request, 'GET', '/', retries=0, release_conn=False)
        self.assertEqual(http.pool.qsize(), http.pool.maxsize)

    def test_connection_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            while not sock.recv(65536).endswith(b'\r\n\r\n'):
                pass

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        http = HTTPConnectionPool(self.host, self.port,
                                  timeout=0.001,
                                  retries=False,
                                  maxsize=3,
                                  block=True)
        self.addCleanup(http.close)

        try:
            self.assertRaises(ReadTimeoutError, http.request, 'GET', '/', release_conn=False)
        finally:
            timed_out.set()

        self.assertEqual(http.pool.qsize(), http.pool.maxsize)

    def test_read_timeout_dont_retry_method_not_in_whitelist(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock.recv(65536)
            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port, timeout=0.001, retries=True)
        self.addCleanup(pool.close)

        try:
            self.assertRaises(ReadTimeoutError, pool.request, 'POST', '/')
        finally:
            timed_out.set()

    def test_https_connection_read_timeout(self):
        """""" Handshake timeouts should fail with a Timeout""""""
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            while not sock.recv(65536):
                pass

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port, timeout=0.001, retries=False)
        self.addCleanup(pool.close)
        try:
            self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')
        finally:
            timed_out.set()

    def test_timeout_errors_cause_retries(self):
        def socket_handler(listener):
            sock_timeout = listener.accept()[0]

            # Wait for a second request before closing the first socket.
            sock = listener.accept()[0]
            sock_timeout.close()

            # Second request.
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            # Now respond immediately.
            body = 'Response 2'
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(body), body)).encode('utf-8'))

            sock.close()

        # In situations where the main thread throws an exception, the server
        # thread can hang on an accept() call. This ensures everything times
        # out within 1 second. This should be long enough for any socket
        # operations in the test suite to complete
        default_timeout = socket.getdefaulttimeout()
        socket.setdefaulttimeout(1)

        try:
            self._start_server(socket_handler)
            t = Timeout(connect=0.001, read=0.001)
            pool = HTTPConnectionPool(self.host, self.port, timeout=t)
            self.addCleanup(pool.close)

            response = pool.request('GET', '/', retries=1)
            self.assertEqual(response.status, 200)
            self.assertEqual(response.data, b'Response 2')
        finally:
            socket.setdefaulttimeout(default_timeout)

    def test_delayed_body_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b''
            body = 'Hi'
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n' % len(body)).encode('utf-8'))

            timed_out.wait()
            sock.send(body.encode('utf-8'))
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.urlopen('GET', '/', retries=0, preload_content=False,
                                timeout=Timeout(connect=1, read=0.001))
        try:
            self.assertRaises(ReadTimeoutError, response.read)
        finally:
            timed_out.set()

    def test_delayed_body_read_timeout_with_preload(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b''
            body = 'Hi'
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n' % len(body)).encode('utf-8'))

            timed_out.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        try:
            self.assertRaises(ReadTimeoutError, pool.urlopen,
                              'GET', '/', retries=False,
                              timeout=Timeout(connect=1, read=0.001))
        finally:
            timed_out.set()

    def test_incomplete_response(self):
        body = 'Response'
        partial_body = body[:2]

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)

            # Send partial response and close socket.
            sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: %d\r\n'
                '\r\n'
                '%s' % (len(body), partial_body)).encode('utf-8')
            )
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.request('GET', '/', retries=0, preload_content=False)
        self.assertRaises(ProtocolError, response.read)

    def test_retry_weird_http_version(self):
        """""" Retry class should handle httplib.BadStatusLine errors properly """"""

        def socket_handler(listener):
            sock = listener.accept()[0]
            # First request.
            # Pause before responding so the first request times out.
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            # send unknown http protocol
            body = ""bad http 0.5 response""
            sock.send(('HTTP/0.5 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(body), body)).encode('utf-8'))
            sock.close()

            # Second request.
            sock = listener.accept()[0]
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            # Now respond immediately.
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       'foo' % (len('foo'))).encode('utf-8'))

            sock.close()  # Close the socket.

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        retry = Retry(read=1)
        response = pool.request('GET', '/', retries=retry)
        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'foo')

    def test_connection_cleanup_on_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b''
            body = 'Hi'
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n' % len(body)).encode('utf-8'))

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            poolsize = pool.pool.qsize()
            response = pool.urlopen('GET', '/', retries=0, preload_content=False,
                                    timeout=Timeout(connect=1, read=0.001))
            try:
                self.assertRaises(ReadTimeoutError, response.read)
                self.assertEqual(poolsize, pool.pool.qsize())
            finally:
                timed_out.set()

    def test_connection_cleanup_on_protocol_error_during_read(self):
        body = 'Response'
        partial_body = body[:2]

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)

            # Send partial response and close socket.
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(body), partial_body)).encode('utf-8'))
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            poolsize = pool.pool.qsize()
            response = pool.request('GET', '/', retries=0, preload_content=False)

            self.assertRaises(ProtocolError, response.read)
            self.assertEqual(poolsize, pool.pool.qsize())

    def test_connection_closed_on_read_timeout_preload_false(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65535)

            # Send partial chunked response and then hang.
            sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Transfer-Encoding: chunked\r\n'
                '\r\n'
                '8\r\n'
                '12345678\r\n').encode('utf-8')
            )
            timed_out.wait(5)

            # Expect a new request, but keep hold of the old socket to avoid
            # leaking it. Because we don't want to hang this thread, we
            # actually use select.select to confirm that a new request is
            # coming in: this lets us time the thread out.
            rlist, _, _ = select.select([listener], [], [], 1)
            assert rlist
            new_sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = new_sock.recv(65535)

            # Send complete chunked response.
            new_sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Transfer-Encoding: chunked\r\n'
                '\r\n'
                '8\r\n'
                '12345678\r\n'
                '0\r\n\r\n').encode('utf-8')
            )

            new_sock.close()
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            # First request should fail.
            response = pool.urlopen('GET', '/', retries=0,
                                    preload_content=False,
                                    timeout=Timeout(connect=1, read=0.001))
            try:
                self.assertRaises(ReadTimeoutError, response.read)
            finally:
                timed_out.set()

            # Second should succeed.
            response = pool.urlopen('GET', '/', retries=0,
                                    preload_content=False,
                                    timeout=Timeout(connect=1, read=0.1))
            self.assertEqual(len(response.read()), 8)

    def test_closing_response_actually_closes_connection(self):
        done_closing = Event()
        complete = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: 0\r\n'
                       '\r\n').encode('utf-8'))

            # Wait for the socket to close.
            done_closing.wait(timeout=1)

            # Look for the empty string to show that the connection got closed.
            # Don't get stuck in a timeout.
            sock.settimeout(1)
            new_data = sock.recv(65536)
            self.assertFalse(new_data)
            sock.close()
            complete.set()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.request('GET', '/', retries=0, preload_content=False)
        self.assertEqual(response.status, 200)
        response.close()

        done_closing.set()  # wait until the socket in our pool gets closed
        successful = complete.wait(timeout=1)
        if not successful:
            self.fail(""Timed out waiting for connection close"")

    def test_release_conn_param_is_respected_after_timeout_retry(self):
        """"""For successful ```urlopen(release_conn=False)```,
        the connection isn't released, even after a retry.

        This test allows a retry: one request fails, the next request succeeds.

        This is a regression test for issue #651 [1], where the connection
        would be released if the initial request failed, even if a retry
        succeeded.

        [1] <https://github.com/shazow/urllib3/issues/651>
        """"""
        def socket_handler(listener):
            sock = listener.accept()[0]
            consume_socket(sock)

            # Close the connection, without sending any response (not even the
            # HTTP status line). This will trigger a `Timeout` on the client,
            # inside `urlopen()`.
            sock.close()

            # Expect a new request. Because we don't want to hang this thread,
            # we actually use select.select to confirm that a new request is
            # coming in: this lets us time the thread out.
            rlist, _, _ = select.select([listener], [], [], 5)
            assert rlist
            sock = listener.accept()[0]
            consume_socket(sock)

            # Send complete chunked response.
            sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Transfer-Encoding: chunked\r\n'
                '\r\n'
                '8\r\n'
                '12345678\r\n'
                '0\r\n\r\n').encode('utf-8')
            )

            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port, maxsize=1) as pool:
            # First request should fail, but the timeout and `retries=1` should
            # save it.
            response = pool.urlopen('GET', '/', retries=1,
                                    release_conn=False, preload_content=False,
                                    timeout=Timeout(connect=1, read=0.001))

            # The connection should still be on the response object, and none
            # should be in the pool. We opened two though.
            self.assertEqual(pool.num_connections, 2)
            self.assertEqual(pool.pool.qsize(), 0)
            self.assertIsNotNone(response.connection)

            # Consume the data. This should put the connection back.
            response.read()
            self.assertEqual(pool.pool.qsize(), 1)
            self.assertIsNone(response.connection)


class TestProxyManager(SocketDummyServerTestCase):

    def test_simple(self):
        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(buf), buf.decode('utf-8'))).encode('utf-8'))
            sock.close()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)
        proxy = proxy_from_url(base_url)
        self.addCleanup(proxy.clear)

        r = proxy.request('GET', 'http://google.com/')

        self.assertEqual(r.status, 200)
        # FIXME: The order of the headers is not predictable right now. We
        # should fix that someday (maybe when we migrate to
        # OrderedDict/MultiDict).
        self.assertEqual(sorted(r.data.split(b'\r\n')),
                         sorted([
                             b'GET http://google.com/ HTTP/1.1',
                             b'Host: google.com',
                             b'Accept-Encoding: identity',
                             b'Accept: */*',
                             b'',
                             b'',
                         ]))

    def test_headers(self):
        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(buf), buf.decode('utf-8'))).encode('utf-8'))
            sock.close()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        # Define some proxy headers.
        proxy_headers = HTTPHeaderDict({'For The Proxy': 'YEAH!'})
        proxy = proxy_from_url(base_url, proxy_headers=proxy_headers)
        self.addCleanup(proxy.clear)

        conn = proxy.connection_from_url('http://www.google.com/')

        r = conn.urlopen('GET', 'http://www.google.com/', assert_same_host=False)

        self.assertEqual(r.status, 200)
        # FIXME: The order of the headers is not predictable right now. We
        # should fix that someday (maybe when we migrate to
        # OrderedDict/MultiDict).
        self.assertIn(b'For The Proxy: YEAH!\r\n', r.data)

    def test_retries(self):
        close_event = Event()

        def echo_socket_handler(listener):
            sock = listener.accept()[0]
            # First request, which should fail
            sock.close()

            # Second request
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(buf), buf.decode('utf-8'))).encode('utf-8'))
            sock.close()
            close_event.set()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        proxy = proxy_from_url(base_url)
        self.addCleanup(proxy.clear)
        conn = proxy.connection_from_url('http://www.google.com')

        r = conn.urlopen('GET', 'http://www.google.com',
                         assert_same_host=False, retries=1)
        self.assertEqual(r.status, 200)

        close_event.wait(timeout=1)
        self.assertRaises(ProxyError, conn.urlopen, 'GET',
                          'http://www.google.com',
                          assert_same_host=False, retries=False)

    def test_connect_reconn(self):
        def proxy_ssl_one(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)
            s = buf.decode('utf-8')
            if not s.startswith('CONNECT '):
                sock.send(('HTTP/1.1 405 Method not allowed\r\n'
                           'Allow: CONNECT\r\n\r\n').encode('utf-8'))
                sock.close()
                return

            if not s.startswith('CONNECT %s:443' % (self.host,)):
                sock.send(('HTTP/1.1 403 Forbidden\r\n\r\n').encode('utf-8'))
                sock.close()
                return

            sock.send(('HTTP/1.1 200 Connection Established\r\n\r\n').encode('utf-8'))
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'],
                                       ca_certs=DEFAULT_CA)

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            ssl_sock.send(('HTTP/1.1 200 OK\r\n'
                           'Content-Type: text/plain\r\n'
                           'Content-Length: 2\r\n'
                           'Connection: close\r\n'
                           '\r\n'
                           'Hi').encode('utf-8'))
            ssl_sock.close()

        def echo_socket_handler(listener):
            proxy_ssl_one(listener)
            proxy_ssl_one(listener)

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        proxy = proxy_from_url(base_url)
        self.addCleanup(proxy.clear)

        url = 'https://{0}'.format(self.host)
        conn = proxy.connection_from_url(url)
        r = conn.urlopen('GET', url, retries=0)
        self.assertEqual(r.status, 200)
        r = conn.urlopen('GET', url, retries=0)
        self.assertEqual(r.status, 200)

    def test_connect_ipv6_addr(self):
        ipv6_addr = '2001:4998:c:a06::2:4008'

        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)
            s = buf.decode('utf-8')

            if s.startswith('CONNECT [%s]:443' % (ipv6_addr,)):
                sock.send(b'HTTP/1.1 200 Connection Established\r\n\r\n')
                ssl_sock = ssl.wrap_socket(sock,
                                           server_side=True,
                                           keyfile=DEFAULT_CERTS['keyfile'],
                                           certfile=DEFAULT_CERTS['certfile'])
                buf = b''
                while not buf.endswith(b'\r\n\r\n'):
                    buf += ssl_sock.recv(65536)

                ssl_sock.send(b'HTTP/1.1 200 OK\r\n'
                              b'Content-Type: text/plain\r\n'
                              b'Content-Length: 2\r\n'
                              b'Connection: close\r\n'
                              b'\r\n'
                              b'Hi')
                ssl_sock.close()
            else:
                sock.close()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        proxy = proxy_from_url(base_url)
        self.addCleanup(proxy.clear)

        url = 'https://[{0}]'.format(ipv6_addr)
        conn = proxy.connection_from_url(url)
        try:
            r = conn.urlopen('GET', url, retries=0)
            self.assertEqual(r.status, 200)
        except MaxRetryError:
            self.fail('Invalid IPv6 format in HTTP CONNECT request')


class TestSSL(SocketDummyServerTestCase):

    def test_ssl_failure_midway_through_conn(self):
        def socket_handler(listener):
            sock = listener.accept()[0]
            sock2 = sock.dup()
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'],
                                       ca_certs=DEFAULT_CA)

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            # Deliberately send from the non-SSL socket.
            sock2.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: 2\r\n'
                '\r\n'
                'Hi').encode('utf-8'))
            sock2.close()
            ssl_sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        with self.assertRaises(MaxRetryError) as cm:
            pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)

    def test_ssl_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'],
                                       ca_certs=DEFAULT_CA)

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            # Send incomplete message (note Content-Length)
            ssl_sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: 10\r\n'
                '\r\n'
                'Hi-').encode('utf-8'))
            timed_out.wait()

            sock.close()
            ssl_sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.urlopen('GET', '/', retries=0, preload_content=False,
                                timeout=Timeout(connect=1, read=0.001))
        try:
            self.assertRaises(ReadTimeoutError, response.read)
        finally:
            timed_out.set()

    def test_ssl_failed_fingerprint_verification(self):
        def socket_handler(listener):
            for i in range(2):
                sock = listener.accept()[0]
                ssl_sock = ssl.wrap_socket(sock,
                                           server_side=True,
                                           keyfile=DEFAULT_CERTS['keyfile'],
                                           certfile=DEFAULT_CERTS['certfile'],
                                           ca_certs=DEFAULT_CA)

                ssl_sock.send(b'HTTP/1.1 200 OK\r\n'
                              b'Content-Type: text/plain\r\n'
                              b'Content-Length: 5\r\n\r\n'
                              b'Hello')

                ssl_sock.close()
                sock.close()

        self._start_server(socket_handler)
        # GitHub's fingerprint. Valid, but not matching.
        fingerprint = ('A0:C4:A7:46:00:ED:A7:2D:C0:BE:CB'
                       ':9A:8C:B6:07:CA:58:EE:74:5E')

        def request():
            pool = HTTPSConnectionPool(self.host, self.port,
                                       assert_fingerprint=fingerprint)
            try:
                response = pool.urlopen('GET', '/', preload_content=False,
                                        timeout=Timeout(connect=1, read=0.001),
                                        retries=0)
                response.read()
            finally:
                pool.close()

        with self.assertRaises(MaxRetryError) as cm:
            request()
        self.assertIsInstance(cm.exception.reason, SSLError)
        # Should not hang, see https://github.com/shazow/urllib3/issues/529
        self.assertRaises(MaxRetryError, request)

    def test_retry_ssl_error(self):
        def socket_handler(listener):
            # first request, trigger an SSLError
            sock = listener.accept()[0]
            sock2 = sock.dup()
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'])
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            # Deliberately send from the non-SSL socket to trigger an SSLError
            sock2.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: 4\r\n'
                '\r\n'
                'Fail').encode('utf-8'))
            sock2.close()
            ssl_sock.close()

            # retried request
            sock = listener.accept()[0]
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'])
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)
            ssl_sock.send(b'HTTP/1.1 200 OK\r\n'
                          b'Content-Type: text/plain\r\n'
                          b'Content-Length: 7\r\n\r\n'
                          b'Success')
            ssl_sock.close()

        self._start_server(socket_handler)

        pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        response = pool.urlopen('GET', '/', retries=1)
        self.assertEqual(response.data, b'Success')


class TestErrorWrapping(SocketDummyServerTestCase):

    def test_bad_statusline(self):
        self.start_response_handler(
           b'HTTP/1.1 Omg What Is This?\r\n'
           b'Content-Length: 0\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ProtocolError, pool.request, 'GET', '/')

    def test_unknown_protocol(self):
        self.start_response_handler(
           b'HTTP/1000 200 OK\r\n'
           b'Content-Length: 0\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ProtocolError, pool.request, 'GET', '/')


class TestHeaders(SocketDummyServerTestCase):
    @onlyPy3
    def test_httplib_headers_case_insensitive(self):
        self.start_response_handler(
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 0\r\n'
           b'Content-type: text/plain\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        HEADERS = {'Content-Length': '0', 'Content-type': 'text/plain'}
        r = pool.request('GET', '/')
        self.assertEqual(HEADERS, dict(r.headers.items()))  # to preserve case sensitivity

    def test_headers_are_sent_with_the_original_case(self):
        headers = {'foo': 'bar', 'bAz': 'quux'}
        parsed_headers = {}

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            headers_list = [header for header in buf.split(b'\r\n')[1:] if header]

            for header in headers_list:
                (key, value) = header.split(b': ')
                parsed_headers[key.decode('ascii')] = value.decode('ascii')

            sock.send((
                'HTTP/1.1 204 No Content\r\n'
                'Content-Length: 0\r\n'
                '\r\n').encode('utf-8'))

            sock.close()

        self._start_server(socket_handler)
        expected_headers = {'Accept-Encoding': 'identity',
                            'Host': '{0}:{1}'.format(self.host, self.port)}
        expected_headers.update(headers)

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.request('GET', '/', headers=HTTPHeaderDict(headers))
        self.assertEqual(expected_headers, parsed_headers)

    def test_request_headers_are_sent_in_the_original_order(self):
        # NOTE: Probability this test gives a false negative is 1/(K!)
        K = 16
        # NOTE: Provide headers in non-sorted order (i.e. reversed)
        #       so that if the internal implementation tries to sort them,
        #       a change will be detected.
        expected_request_headers = [(u'X-Header-%d' % i, str(i)) for i in reversed(range(K))]

        actual_request_headers = []

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            headers_list = [header for header in buf.split(b'\r\n')[1:] if header]

            for header in headers_list:
                (key, value) = header.split(b': ')
                if not key.decode('ascii').startswith(u'X-Header-'):
                    continue
                actual_request_headers.append((key.decode('ascii'), value.decode('ascii')))

            sock.send((
                u'HTTP/1.1 204 No Content\r\n'
                u'Content-Length: 0\r\n'
                u'\r\n').encode('ascii'))

            sock.close()

        self._start_server(socket_handler)

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.request('GET', '/', headers=OrderedDict(expected_request_headers))
        self.assertEqual(expected_request_headers, actual_request_headers)

    @fails_on_travis_gce
    def test_request_host_header_ignores_fqdn_dot(self):

        received_headers = []

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            for header in buf.split(b'\r\n')[1:]:
                if header:
                    received_headers.append(header)

            sock.send((
                u'HTTP/1.1 204 No Content\r\n'
                u'Content-Length: 0\r\n'
                u'\r\n').encode('ascii'))

            sock.close()

        self._start_server(socket_handler)

        pool = HTTPConnectionPool(self.host + '.', self.port, retries=False)
        self.addCleanup(pool.close)
        pool.request('GET', '/')
        self.assert_header_received(
            received_headers, 'Host', '%s:%s' % (self.host, self.port)
        )

    def test_response_headers_are_returned_in_the_original_order(self):
        # NOTE: Probability this test gives a false negative is 1/(K!)
        K = 16
        # NOTE: Provide headers in non-sorted order (i.e. reversed)
        #       so that if the internal implementation tries to sort them,
        #       a change will be detected.
        expected_response_headers = [('X-Header-%d' % i, str(i)) for i in reversed(range(K))]

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(b'HTTP/1.1 200 OK\r\n' +
                      b'\r\n'.join([
                          (k.encode('utf8') + b': ' + v.encode('utf8'))
                          for (k, v) in expected_response_headers
                      ]) +
                      b'\r\n')
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/', retries=0)
        actual_response_headers = [
            (k, v) for (k, v) in r.headers.items()
            if k.startswith('X-Header-')
        ]
        self.assertEqual(expected_response_headers, actual_response_headers)


@pytest.mark.skipif(
    issubclass(httplib.HTTPMessage, MimeToolMessage),
    reason='Header parsing errors not available'
)
class TestBrokenHeaders(SocketDummyServerTestCase):

    def _test_broken_header_parsing(self, headers, unparsed_data_check=None):
        self.start_response_handler((
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 0\r\n'
           b'Content-type: text/plain\r\n'
           ) + b'\r\n'.join(headers) + b'\r\n\r\n'
        )

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)

        with LogRecorder() as logs:
            pool.request('GET', '/')

        for record in logs:
            if 'Failed to parse headers' in record.msg and \
                    pool._absolute_url('/') == record.args[0]:
                if unparsed_data_check is None or unparsed_data_check in record.getMessage():
                    return
        self.fail('Missing log about unparsed headers')

    def test_header_without_name(self):
        self._test_broken_header_parsing([
            b': Value',
            b'Another: Header',
        ])

    def test_header_without_name_or_value(self):
        self._test_broken_header_parsing([
            b':',
            b'Another: Header',
        ])

    def test_header_without_colon_or_value(self):
        self._test_broken_header_parsing([
            b'Broken Header',
            b'Another: Header',
        ], 'Broken Header')


class TestHeaderParsingContentType(SocketDummyServerTestCase):

    def _test_okay_header_parsing(self, header):
        self.start_response_handler((
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 0\r\n'
           ) + header + b'\r\n\r\n'
        )

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)

        with LogRecorder() as logs:
            pool.request('GET', '/')

        for record in logs:
            assert 'Failed to parse headers' not in record.msg

    def test_header_text_plain(self):
        self._test_okay_header_parsing(b'Content-type: text/plain')

    def test_header_message_rfc822(self):
        self._test_okay_header_parsing(b'Content-type: message/rfc822')


class TestHEAD(SocketDummyServerTestCase):
    def test_chunked_head_response_does_not_hang(self):
        self.start_response_handler(
           b'HTTP/1.1 200 OK\r\n'
           b'Transfer-Encoding: chunked\r\n'
           b'Content-type: text/plain\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        r = pool.request('HEAD', '/', timeout=1, preload_content=False)

        # stream will use the read_chunked method here.
        self.assertEqual([], list(r.stream()))

    def test_empty_head_response_does_not_hang(self):
        self.start_response_handler(
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 256\r\n'
           b'Content-type: text/plain\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        r = pool.request('HEAD', '/', timeout=1, preload_content=False)

        # stream will use the read method here.
        self.assertEqual([], list(r.stream()))


class TestStream(SocketDummyServerTestCase):
    def test_stream_none_unchunked_response_does_not_hang(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(
                b'HTTP/1.1 200 OK\r\n'
                b'Content-Length: 12\r\n'
                b'Content-type: text/plain\r\n'
                b'\r\n'
                b'hello, world'
            )
            done_event.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/', timeout=1, preload_content=False)

        # Stream should read to the end.
        self.assertEqual([b'hello, world'], list(r.stream(None)))

        done_event.set()


class TestBadContentLength(SocketDummyServerTestCase):
    def test_enforce_content_length_get(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(
                b'HTTP/1.1 200 OK\r\n'
                b'Content-Length: 22\r\n'
                b'Content-type: text/plain\r\n'
                b'\r\n'
                b'hello, world'
            )
            done_event.wait(1)
            sock.close()

        self._start_server(socket_handler)
        conn = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(conn.close)

        # Test stream read when content length less than headers claim
        get_response = conn.request('GET', url='/', preload_content=False,
                                    enforce_content_length=True)
        data = get_response.stream(100)
        # Read ""good"" data before we try to read again.
        # This won't trigger till generator is exhausted.
        next(data)
        try:
            next(data)
            self.assertFail()
        except ProtocolError as e:
            self.assertIn('12 bytes read, 10 more expected', str(e))

        done_event.set()

    def test_enforce_content_length_no_body(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(
                b'HTTP/1.1 200 OK\r\n'
                b'Content-Length: 22\r\n'
                b'Content-type: text/plain\r\n'
                b'\r\n'
            )
            done_event.wait(1)
            sock.close()

        self._start_server(socket_handler)
        conn = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(conn.close)

        # Test stream on 0 length body
        head_response = conn.request('HEAD', url='/', preload_content=False,
                                     enforce_content_length=True)
        data = [chunk for chunk in head_response.stream(1)]
        self.assertEqual(len(data), 0)

        done_event.set()


class TestRetryPoolSizeDrainFail(SocketDummyServerTestCase):

    def test_pool_size_retry_drain_fail(self):
        def socket_handler(listener):
            for _ in range(2):
                sock = listener.accept()[0]
                while not sock.recv(65536).endswith(b'\r\n\r\n'):
                    pass

                # send a response with an invalid content length -- this causes
                # a ProtocolError to raise when trying to drain the connection
                sock.send(
                    b'HTTP/1.1 404 NOT FOUND\r\n'
                    b'Content-Length: 1000\r\n'
                    b'Content-Type: text/plain\r\n'
                    b'\r\n'
                )
                sock.close()

        self._start_server(socket_handler)
        retries = Retry(
            total=1,
            raise_on_status=False,
            status_forcelist=[404],
        )
        pool = HTTPConnectionPool(self.host, self.port, maxsize=10,
                                  retries=retries, block=True)
        self.addCleanup(pool.close)

        pool.urlopen('GET', '/not_found', preload_content=False)
        assert pool.num_connections == 1",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"  VAR VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR) VAR .. VAR VAR, VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR(VAR): VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR=1\VAR\VAR' VAR'VAR-VAR: VAR=1\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR, {'VAR-VAR': 'VAR=1, VAR=1'}) VAR.VAR(VAR.VAR.VAR('VAR-VAR'), ['VAR=1', 'VAR=1']) VAR VAR(VAR): @VAR.VAR.VAR(VAR VAR, VAR='VAR-VAR VAR VAR') VAR VAR(VAR): VAR = VAR() VAR.VAR = VAR'' VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR = VAR.VAR(65536)  VAR.VAR()  VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR VAR:  VAR VAR.VAR() VAR.VAR(VAR.VAR.VAR('VAR'), VAR.VAR, ""VAR VAR VAR VAR VAR"") VAR VAR(VAR): """""" VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR VAR.VAR( VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR()) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(8192) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 6\VAR\VAR' VAR'\VAR\VAR' VAR'VAR!' ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR.VAR, VAR.VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR='VAR', VAR=VAR, ) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=0) VAR.VAR() VAR.VAR(VAR(VAR), 1) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR()) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(8192) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 6\VAR\VAR' VAR'\VAR\VAR' VAR'VAR!' ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR='VAR', VAR=VAR, ) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=0) VAR.VAR() VAR.VAR(VAR(VAR), 1) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR: VAR.VAR(VAR) VAR VAR.VAR: VAR VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR, ) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR VAR: VAR.VAR() VAR: VAR.VAR() VAR.VAR( ""VAR VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR"" ) VAR VAR(VAR): VAR VAR(VAR):    VAR = VAR() VAR VAR(VAR): VAR VAR VAR 0, 1: VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR = 'VAR %VAR' % VAR VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR()  VAR.VAR()  VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR 0') VAR.VAR()  VAR = VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR 1') VAR VAR(VAR):  VAR, VAR = VAR() VAR = VAR(VAR, VAR, VAR=3, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536).VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.001, VAR=VAR, VAR=3, VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR) VAR: VAR.VAR() VAR.VAR(VAR.VAR.VAR(), VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR(65536) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.001, VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR: VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR"""""" VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536): VAR VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.001, VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR.VAR()[0] VAR.VAR()  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR = 'VAR 2' VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR()     VAR = VAR.VAR() VAR.VAR(1) VAR: VAR.VAR(VAR) VAR = VAR(VAR=0.001, VAR=0.001) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR 2') VAR: VAR.VAR(VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR = 'VAR' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' % VAR(VAR)).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR.VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.001)) VAR: VAR.VAR(VAR, VAR.VAR) VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR = 'VAR' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' % VAR(VAR)).VAR('VAR-8')) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR, VAR=VAR(VAR=1, VAR=0.001)) VAR: VAR.VAR() VAR VAR(VAR): VAR = 'VAR' VAR = VAR[:2] VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8') ) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR, VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR.VAR VAR VAR """""" VAR VAR(VAR): VAR = VAR.VAR()[0]   VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR = ""VAR VAR 0.5 VAR"" VAR.VAR(('VAR/0.5 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' 'VAR' % (VAR('VAR'))).VAR('VAR-8')) VAR.VAR()  VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR(VAR=1) VAR = VAR.VAR('VAR', '/', VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR') VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR = 'VAR' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' % VAR(VAR)).VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR() VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.001)) VAR: VAR.VAR(VAR, VAR.VAR) VAR.VAR(VAR, VAR.VAR.VAR()) VAR: VAR.VAR() VAR VAR(VAR): VAR = 'VAR' VAR = VAR[:2] VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536)  VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR() VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(VAR, VAR.VAR.VAR()) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65535)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: VAR\VAR\VAR' '\VAR\VAR' '8\VAR\VAR' '12345678\VAR\VAR').VAR('VAR-8') ) VAR.VAR(5)     VAR, VAR, VAR = VAR.VAR([VAR], [], [], 1) VAR VAR VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65535)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: VAR\VAR\VAR' '\VAR\VAR' '8\VAR\VAR' '12345678\VAR\VAR' '0\VAR\VAR\VAR\VAR').VAR('VAR-8') ) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR:  VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.001)) VAR: VAR.VAR(VAR, VAR.VAR) VAR: VAR.VAR()  VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.1)) VAR.VAR(VAR(VAR.VAR()), 8) VAR VAR(VAR): VAR = VAR() VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 0\VAR\VAR' '\VAR\VAR').VAR('VAR-8'))  VAR.VAR(VAR=1)   VAR.VAR(1) VAR = VAR.VAR(65536) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR() VAR.VAR()  VAR = VAR.VAR(VAR=1) VAR VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR): """"""VAR VAR ```VAR(VAR=VAR)```, VAR VAR VAR'VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR: VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR  VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR. [1] <VAR: """""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR(VAR)    VAR.VAR()    VAR, VAR, VAR = VAR.VAR([VAR], [], [], 5) VAR VAR VAR = VAR.VAR()[0] VAR(VAR)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: VAR\VAR\VAR' '\VAR\VAR' '8\VAR\VAR' '12345678\VAR\VAR' '0\VAR\VAR\VAR\VAR').VAR('VAR-8') ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=1) VAR VAR:   VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR, VAR=VAR, VAR=VAR(VAR=1, VAR=0.001))   VAR.VAR(VAR.VAR, 2) VAR.VAR(VAR.VAR.VAR(), 0) VAR.VAR(VAR.VAR)  VAR.VAR() VAR.VAR(VAR.VAR.VAR(), 1) VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR.VAR('VAR-8'))).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200)    VAR.VAR(VAR(VAR.VAR.VAR(VAR'\VAR\VAR')), VAR([ VAR'VAR VAR: VAR'VAR: VAR.VAR', VAR'VAR-VAR: VAR', VAR'VAR: */*', VAR'', VAR'', ])) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR.VAR('VAR-8'))).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = 'VAR:  VAR = VAR({'VAR VAR VAR': 'VAR!'}) VAR = VAR(VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR: VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200)    VAR.VAR(VAR'VAR VAR VAR: VAR!\VAR\VAR', VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR.VAR('VAR-8'))).VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR: VAR = VAR.VAR('VAR', 'VAR: VAR=VAR, VAR=1) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR=1) VAR.VAR(VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = VAR.VAR('VAR-8') VAR VAR VAR.VAR('VAR '): VAR.VAR(('VAR/1.1 405 VAR VAR VAR\VAR\VAR' 'VAR: VAR\VAR\VAR\VAR\VAR').VAR('VAR-8')) VAR.VAR() VAR VAR VAR VAR.VAR('VAR %VAR:443' % (VAR.VAR,)): VAR.VAR(('VAR/1.1 403 VAR\VAR\VAR\VAR\VAR').VAR('VAR-8')) VAR.VAR() VAR VAR.VAR(('VAR/1.1 200 VAR VAR\VAR\VAR\VAR\VAR').VAR('VAR-8')) VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 2\VAR\VAR' 'VAR: VAR\VAR\VAR' '\VAR\VAR' 'VAR').VAR('VAR-8')) VAR.VAR() VAR VAR(VAR): VAR(VAR) VAR(VAR) VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR) VAR.VAR(VAR.VAR) VAR = 'VAR: VAR = VAR.VAR(VAR) VAR = VAR.VAR('VAR', VAR, VAR=0) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', VAR, VAR=0) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = '2001:4998:VAR:VAR::2:4008' VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = VAR.VAR('VAR-8') VAR VAR.VAR('VAR [%VAR]:443' % (VAR,)): VAR.VAR(VAR'VAR/1.1 200 VAR VAR\VAR\VAR\VAR\VAR') VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR']) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 2\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'\VAR\VAR' VAR'VAR') VAR.VAR() VAR: VAR.VAR() VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR) VAR.VAR(VAR.VAR) VAR = 'VAR: VAR = VAR.VAR(VAR) VAR: VAR = VAR.VAR('VAR', VAR, VAR=0) VAR.VAR(VAR.VAR, 200) VAR VAR: VAR.VAR('VAR VAR VAR VAR VAR VAR VAR') VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR() VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 2\VAR\VAR' '\VAR\VAR' 'VAR').VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 10\VAR\VAR' '\VAR\VAR' 'VAR-').VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.001)) VAR: VAR.VAR(VAR, VAR.VAR) VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 5\VAR\VAR\VAR\VAR' VAR'VAR') VAR.VAR() VAR.VAR() VAR.VAR(VAR)  VAR = ('VAR:VAR:VAR:46:00:VAR:VAR:2D:VAR:VAR:VAR' ':9A:8C:VAR:07:VAR:58:VAR:74:5E') VAR VAR(): VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR: VAR = VAR.VAR('VAR', '/', VAR=VAR, VAR=VAR(VAR=1, VAR=0.001), VAR=0) VAR.VAR() VAR: VAR.VAR() VAR VAR.VAR(VAR) VAR VAR: VAR() VAR.VAR(VAR.VAR.VAR, VAR)  VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR VAR(VAR):  VAR = VAR.VAR()[0] VAR = VAR.VAR() VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR']) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 4\VAR\VAR' '\VAR\VAR' 'VAR').VAR('VAR-8')) VAR.VAR() VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR']) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 7\VAR\VAR\VAR\VAR' VAR'VAR') VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1) VAR.VAR(VAR.VAR, VAR'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 VAR VAR VAR VAR?\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR VAR(VAR): VAR.VAR( VAR'VAR/1000 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR VAR(VAR): @VAR VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = {'VAR-VAR': '0', 'VAR-VAR': 'VAR/VAR'} VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR, VAR(VAR.VAR.VAR()))  VAR VAR(VAR): VAR = {'VAR': 'VAR', 'VAR': 'VAR'} VAR = {} VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = [VAR VAR VAR VAR VAR.VAR(VAR'\VAR\VAR')[1:] VAR VAR] VAR VAR VAR VAR: (VAR, VAR) = VAR.VAR(VAR': ') VAR[VAR.VAR('VAR')] = VAR.VAR('VAR') VAR.VAR(( 'VAR/1.1 204 VAR VAR\VAR\VAR' 'VAR-VAR: 0\VAR\VAR' '\VAR\VAR').VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = {'VAR-VAR': 'VAR', 'VAR': '{0}:{1}'.VAR(VAR.VAR, VAR.VAR)} VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=VAR(VAR)) VAR.VAR(VAR, VAR) VAR VAR(VAR):  VAR = 16    VAR = [(VAR'VAR-VAR-%VAR' % VAR, VAR(VAR)) VAR VAR VAR VAR(VAR(VAR))] VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = [VAR VAR VAR VAR VAR.VAR(VAR'\VAR\VAR')[1:] VAR VAR] VAR VAR VAR VAR: (VAR, VAR) = VAR.VAR(VAR': ') VAR VAR VAR.VAR('VAR').VAR(VAR'VAR-VAR-'): VAR VAR.VAR((VAR.VAR('VAR'), VAR.VAR('VAR'))) VAR.VAR(( VAR'VAR/1.1 204 VAR VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR').VAR('VAR')) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=VAR(VAR)) VAR.VAR(VAR, VAR) @VAR VAR VAR(VAR): VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR VAR VAR VAR.VAR(VAR'\VAR\VAR')[1:]: VAR VAR: VAR.VAR(VAR) VAR.VAR(( VAR'VAR/1.1 204 VAR VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR').VAR('VAR')) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR + '.', VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR.VAR( VAR, 'VAR', '%VAR:%VAR' % (VAR.VAR, VAR.VAR) ) VAR VAR(VAR):  VAR = 16    VAR = [('VAR-VAR-%VAR' % VAR, VAR(VAR)) VAR VAR VAR VAR(VAR(VAR))] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' + VAR'\VAR\VAR'.VAR([ (VAR.VAR('VAR') + VAR': ' + VAR.VAR('VAR')) VAR (VAR, VAR) VAR VAR ]) + VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0) VAR = [ (VAR, VAR) VAR (VAR, VAR) VAR VAR.VAR.VAR() VAR VAR.VAR('VAR-VAR-') ] VAR.VAR(VAR, VAR) @VAR.VAR.VAR( VAR(VAR.VAR, VAR), VAR='VAR VAR VAR VAR VAR' ) VAR VAR(VAR): VAR VAR(VAR, VAR, VAR=VAR): VAR.VAR(( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' ) + VAR'\VAR\VAR'.VAR(VAR) + VAR'\VAR\VAR\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR() VAR VAR: VAR.VAR('VAR', '/') VAR VAR VAR VAR: VAR 'VAR VAR VAR VAR' VAR VAR.VAR VAR \ VAR.VAR('/') == VAR.VAR[0]: VAR VAR VAR VAR VAR VAR VAR VAR.VAR(): VAR VAR.VAR('VAR VAR VAR VAR VAR') VAR VAR(VAR): VAR.VAR([ VAR': VAR', VAR'VAR: VAR', ]) VAR VAR(VAR): VAR.VAR([ VAR':', VAR'VAR: VAR', ]) VAR VAR(VAR): VAR.VAR([ VAR'VAR VAR', VAR'VAR: VAR', ], 'VAR VAR') VAR VAR(VAR): VAR VAR(VAR, VAR): VAR.VAR(( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' ) + VAR + VAR'\VAR\VAR\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR() VAR VAR: VAR.VAR('VAR', '/') VAR VAR VAR VAR: VAR 'VAR VAR VAR VAR' VAR VAR VAR.VAR VAR VAR(VAR): VAR.VAR(VAR'VAR-VAR: VAR/VAR') VAR VAR(VAR): VAR.VAR(VAR'VAR-VAR: VAR/VAR') VAR VAR(VAR): VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR)  VAR.VAR([], VAR(VAR.VAR())) VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 256\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR)  VAR.VAR([], VAR(VAR.VAR())) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 12\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' VAR'VAR, VAR' ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR)  VAR.VAR([VAR'VAR, VAR'], VAR(VAR.VAR(VAR))) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 22\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' VAR'VAR, VAR' ) VAR.VAR(1) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR)  VAR = VAR.VAR('VAR', VAR='/', VAR=VAR, VAR=VAR) VAR = VAR.VAR(100)   VAR(VAR) VAR: VAR(VAR) VAR.VAR() VAR VAR VAR VAR: VAR.VAR('12 VAR VAR, 10 VAR VAR', VAR(VAR)) VAR.VAR() VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 22\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR.VAR(1) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR)  VAR = VAR.VAR('VAR', VAR='/', VAR=VAR, VAR=VAR) VAR = [VAR VAR VAR VAR VAR.VAR(1)] VAR.VAR(VAR(VAR), 0) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536).VAR(VAR'\VAR\VAR\VAR\VAR'): VAR   VAR.VAR( VAR'VAR/1.1 404 VAR VAR\VAR\VAR' VAR'VAR-VAR: 1000\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR=1, VAR=VAR, VAR=[404], ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR.VAR == 1 ",8
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,dummyserver/handlers.py,"from __future__ import print_function

import collections
import contextlib
import gzip
import json
import logging
import sys
import time
import zlib
from datetime import datetime, timedelta
from io import BytesIO

from tornado import httputil
from tornado.web import RequestHandler

from urllib3.packages.six import binary_type, ensure_str
from urllib3.packages.six.moves.http_client import responses
from urllib3.packages.six.moves.urllib.parse import urlsplit

log = logging.getLogger(__name__)


class Response(object):
    def __init__(self, body="""", status=""200 OK"", headers=None):
        self.body = body
        self.status = status
        self.headers = headers or [(""Content-type"", ""text/plain"")]

    def __call__(self, request_handler):
        status, reason = self.status.split("" "", 1)
        request_handler.set_status(int(status), reason)
        for header, value in self.headers:
            request_handler.add_header(header, value)

        # chunked
        if isinstance(self.body, list):
            for item in self.body:
                if not isinstance(item, bytes):
                    item = item.encode(""utf8"")
                request_handler.write(item)
                request_handler.flush()
        else:
            body = self.body
            if not isinstance(body, bytes):
                body = body.encode(""utf8"")

            request_handler.write(body)


RETRY_TEST_NAMES = collections.defaultdict(int)


class TestingApp(RequestHandler):
    """"""
    Simple app that performs various operations, useful for testing an HTTP
    library.

    Given any path, it will attempt to load a corresponding local method if
    it exists. Status code 200 indicates success, 400 indicates failure. Each
    method has its own conditions for success/failure.
    """"""

    def get(self):
        """"""Handle GET requests""""""
        self._call_method()

    def post(self):
        """"""Handle POST requests""""""
        self._call_method()

    def put(self):
        """"""Handle PUT requests""""""
        self._call_method()

    def options(self):
        """"""Handle OPTIONS requests""""""
        self._call_method()

    def head(self):
        """"""Handle HEAD requests""""""
        self._call_method()

    def _call_method(self):
        """"""Call the correct method in this class based on the incoming URI""""""
        req = self.request
        req.params = {}
        for k, v in req.arguments.items():
            req.params[k] = next(iter(v))

        path = req.path[:]
        if not path.startswith(""/""):
            path = urlsplit(path).path

        target = path[1:].split(""/"", 1)[0]
        method = getattr(self, target, self.index)

        resp = method(req)

        if dict(resp.headers).get(""Connection"") == ""close"":
            # FIXME: Can we kill the connection somehow?
            pass

        resp(self)

    def index(self, _request):
        ""Render simple message""
        return Response(""Dummy server!"")

    def certificate(self, request):
        """"""Return the requester's certificate.""""""
        cert = request.get_ssl_certificate()
        subject = dict()
        if cert is not None:
            subject = dict((k, v) for (k, v) in [y for z in cert[""subject""] for y in z])
        return Response(json.dumps(subject))

    def alpn_protocol(self, request):
        """"""Return the selected ALPN protocol.""""""
        proto = request.connection.stream.socket.selected_alpn_protocol()
        return Response(proto.encode(""utf8"") if proto is not None else u"""")

    def source_address(self, request):
        """"""Return the requester's IP address.""""""
        return Response(request.remote_ip)

    def set_up(self, request):
        test_type = request.params.get(""test_type"")
        test_id = request.params.get(""test_id"")
        if test_id:
            print(""\nNew test %s: %s"" % (test_type, test_id))
        else:
            print(""\nNew test %s"" % test_type)
        return Response(""Dummy server is ready!"")

    def specific_method(self, request):
        ""Confirm that the request matches the desired method type""
        method = request.params.get(""method"")
        if method and not isinstance(method, str):
            method = method.decode(""utf8"")

        if request.method != method:
            return Response(
                ""Wrong method: %s != %s"" % (method, request.method),
                status=""400 Bad Request"",
            )
        return Response()

    def upload(self, request):
        ""Confirm that the uploaded file conforms to specification""
        # FIXME: This is a huge broken mess
        param = request.params.get(""upload_param"", b""myfile"").decode(""ascii"")
        filename = request.params.get(""upload_filename"", b"""").decode(""utf-8"")
        size = int(request.params.get(""upload_size"", ""0""))
        files_ = request.files.get(param)

        if len(files_) != 1:
            return Response(
                ""Expected 1 file for '%s', not %d"" % (param, len(files_)),
                status=""400 Bad Request"",
            )
        file_ = files_[0]

        data = file_[""body""]
        if int(size) != len(data):
            return Response(
                ""Wrong size: %d != %d"" % (size, len(data)), status=""400 Bad Request""
            )

        got_filename = file_[""filename""]
        if isinstance(got_filename, binary_type):
            got_filename = got_filename.decode(""utf-8"")

        # Tornado can leave the trailing \n in place on the filename.
        if filename != got_filename:
            return Response(
                u""Wrong filename: %s != %s"" % (filename, file_.filename),
                status=""400 Bad Request"",
            )

        return Response()

    def redirect(self, request):
        ""Perform a redirect to ``target``""
        target = request.params.get(""target"", ""/"")
        status = request.params.get(""status"", ""303 See Other"")
        if len(status) == 3:
            status = ""%s Redirect"" % status.decode(""latin-1"")

        headers = [(""Location"", target)]
        return Response(status=status, headers=headers)

    def not_found(self, request):
        return Response(""Not found"", status=""404 Not Found"")

    def multi_redirect(self, request):
        ""Performs a redirect chain based on ``redirect_codes``""
        codes = request.params.get(""redirect_codes"", b""200"").decode(""utf-8"")
        head, tail = codes.split("","", 1) if "","" in codes else (codes, None)
        status = ""{0} {1}"".format(head, responses[int(head)])
        if not tail:
            return Response(""Done redirecting"", status=status)

        headers = [(""Location"", ""/multi_redirect?redirect_codes=%s"" % tail)]
        return Response(status=status, headers=headers)

    def keepalive(self, request):
        if request.params.get(""close"", b""0"") == b""1"":
            headers = [(""Connection"", ""close"")]
            return Response(""Closing"", headers=headers)

        headers = [(""Connection"", ""keep-alive"")]
        return Response(""Keeping alive"", headers=headers)

    def echo_params(self, request):
        params = sorted(
            [(ensure_str(k), ensure_str(v)) for k, v in request.params.items()]
        )
        return Response(repr(params))

    def sleep(self, request):
        ""Sleep for a specified amount of ``seconds``""
        # DO NOT USE THIS, IT'S DEPRECATED.
        # FIXME: Delete this once appengine tests are fixed to not use this handler.
        seconds = float(request.params.get(""seconds"", ""1""))
        time.sleep(seconds)
        return Response()

    def echo(self, request):
        ""Echo back the params""
        if request.method == ""GET"":
            return Response(request.query)

        return Response(request.body)

    def echo_uri(self, request):
        ""Echo back the requested URI""
        return Response(request.uri)

    def encodingrequest(self, request):
        ""Check for UA accepting gzip/deflate encoding""
        data = b""hello, world!""
        encoding = request.headers.get(""Accept-Encoding"", """")
        headers = None
        if encoding == ""gzip"":
            headers = [(""Content-Encoding"", ""gzip"")]
            file_ = BytesIO()
            with contextlib.closing(
                gzip.GzipFile("""", mode=""w"", fileobj=file_)
            ) as zipfile:
                zipfile.write(data)
            data = file_.getvalue()
        elif encoding == ""deflate"":
            headers = [(""Content-Encoding"", ""deflate"")]
            data = zlib.compress(data)
        elif encoding == ""garbage-gzip"":
            headers = [(""Content-Encoding"", ""gzip"")]
            data = ""garbage""
        elif encoding == ""garbage-deflate"":
            headers = [(""Content-Encoding"", ""deflate"")]
            data = ""garbage""
        return Response(data, headers=headers)

    def headers(self, request):
        return Response(json.dumps(dict(request.headers)))

    def successful_retry(self, request):
        """"""Handler which will return an error and then success

        It's not currently very flexible as the number of retries is hard-coded.
        """"""
        test_name = request.headers.get(""test-name"", None)
        if not test_name:
            return Response(""test-name header not set"", status=""400 Bad Request"")

        RETRY_TEST_NAMES[test_name] += 1

        if RETRY_TEST_NAMES[test_name] >= 2:
            return Response(""Retry successful!"")
        else:
            return Response(""need to keep retrying!"", status=""418 I'm A Teapot"")

    def chunked(self, request):
        return Response([""123""] * 4)

    def chunked_gzip(self, request):
        chunks = []
        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)

        for uncompressed in [b""123""] * 4:
            chunks.append(compressor.compress(uncompressed))

        chunks.append(compressor.flush())

        return Response(chunks, headers=[(""Content-Encoding"", ""gzip"")])

    def nbytes(self, request):
        length = int(request.params.get(""length""))
        data = b""1"" * length
        return Response(data, headers=[(""Content-Type"", ""application/octet-stream"")])

    def status(self, request):
        status = request.params.get(""status"", ""200 OK"")

        return Response(status=status)

    def retry_after(self, request):
        if datetime.now() - self.application.last_req < timedelta(seconds=1):
            status = request.params.get(""status"", b""429 Too Many Requests"")
            return Response(
                status=status.decode(""utf-8""), headers=[(""Retry-After"", ""1"")]
            )

        self.application.last_req = datetime.now()

        return Response(status=""200 OK"")

    def redirect_after(self, request):
        ""Perform a redirect to ``target``""
        date = request.params.get(""date"")
        if date:
            retry_after = str(
                httputil.format_timestamp(datetime.utcfromtimestamp(float(date)))
            )
        else:
            retry_after = ""1""
        target = request.params.get(""target"", ""/"")
        headers = [(""Location"", target), (""Retry-After"", retry_after)]
        return Response(status=""303 See Other"", headers=headers)

    def shutdown(self, request):
        sys.exit()",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR, VAR="""", VAR=""200 VAR"", VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR [(""VAR-VAR"", ""VAR/VAR"")] VAR VAR(VAR, VAR): VAR, VAR = VAR.VAR.VAR("" "", 1) VAR.VAR(VAR(VAR), VAR) VAR VAR, VAR VAR VAR.VAR: VAR.VAR(VAR, VAR)  VAR VAR(VAR.VAR, VAR): VAR VAR VAR VAR.VAR: VAR VAR VAR(VAR, VAR): VAR = VAR.VAR(""VAR"") VAR.VAR(VAR) VAR.VAR() VAR: VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR(""VAR"") VAR.VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR 200 VAR VAR, 400 VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR/VAR. """""" VAR VAR(VAR): """"""VAR VAR VAR"""""" VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR"""""" VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR"""""" VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR"""""" VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR"""""" VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR = VAR.VAR VAR.VAR = {} VAR VAR, VAR VAR VAR.VAR.VAR(): VAR.VAR[VAR] = VAR(VAR(VAR)) VAR = VAR.VAR[:] VAR VAR VAR.VAR(""/""): VAR = VAR(VAR).VAR VAR = VAR[1:].VAR(""/"", 1)[0] VAR = VAR(VAR, VAR, VAR.VAR) VAR = VAR(VAR) VAR VAR(VAR.VAR).VAR(""VAR"") == ""VAR"":  VAR VAR(VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR"" VAR VAR(""VAR VAR!"") VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR."""""" VAR = VAR.VAR() VAR = VAR() VAR VAR VAR VAR VAR: VAR = VAR((VAR, VAR) VAR (VAR, VAR) VAR [VAR VAR VAR VAR VAR[""VAR""] VAR VAR VAR VAR]) VAR VAR(VAR.VAR(VAR)) VAR VAR(VAR, VAR): """"""VAR VAR VAR VAR VAR."""""" VAR = VAR.VAR.VAR.VAR.VAR() VAR VAR(VAR.VAR(""VAR"") VAR VAR VAR VAR VAR VAR VAR"""") VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR VAR."""""" VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(""VAR"") VAR = VAR.VAR.VAR(""VAR"") VAR VAR: VAR(""\VAR VAR %VAR: %VAR"" % (VAR, VAR)) VAR: VAR(""\VAR VAR %VAR"" % VAR) VAR VAR(""VAR VAR VAR VAR!"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR = VAR.VAR.VAR(""VAR"") VAR VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR(""VAR"") VAR VAR.VAR != VAR: VAR VAR( ""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR=""400 VAR VAR"", ) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR""  VAR = VAR.VAR.VAR(""VAR"", VAR""VAR"").VAR(""VAR"") VAR = VAR.VAR.VAR(""VAR"", VAR"""").VAR(""VAR-8"") VAR = VAR(VAR.VAR.VAR(""VAR"", ""0"")) VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) != 1: VAR VAR( ""VAR 1 VAR VAR '%VAR', VAR %VAR"" % (VAR, VAR(VAR)), VAR=""400 VAR VAR"", ) VAR = VAR[0] VAR = VAR[""VAR""] VAR VAR(VAR) != VAR(VAR): VAR VAR( ""VAR VAR: %VAR != %VAR"" % (VAR, VAR(VAR)), VAR=""400 VAR VAR"" ) VAR = VAR[""VAR""] VAR VAR(VAR, VAR): VAR = VAR.VAR(""VAR-8"")  VAR VAR != VAR: VAR VAR( VAR""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR=""400 VAR VAR"", ) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR(""VAR"", ""/"") VAR = VAR.VAR.VAR(""VAR"", ""303 VAR VAR"") VAR VAR(VAR) == 3: VAR = ""%VAR VAR"" % VAR.VAR(""VAR-1"") VAR = [(""VAR"", VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR(""VAR VAR"", VAR=""404 VAR VAR"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR(""VAR"", VAR""200"").VAR(""VAR-8"") VAR, VAR = VAR.VAR("","", 1) VAR "","" VAR VAR VAR (VAR, VAR) VAR = ""{0} {1}"".VAR(VAR, VAR[VAR(VAR)]) VAR VAR VAR: VAR VAR(""VAR VAR"", VAR=VAR) VAR = [(""VAR"", ""/VAR?VAR=%VAR"" % VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR(""VAR"", VAR""0"") == VAR""1"": VAR = [(""VAR"", ""VAR"")] VAR VAR(""VAR"", VAR=VAR) VAR = [(""VAR"", ""VAR-VAR"")] VAR VAR(""VAR VAR"", VAR=VAR) VAR VAR(VAR, VAR): VAR = VAR( [(VAR(VAR), VAR(VAR)) VAR VAR, VAR VAR VAR.VAR.VAR()] ) VAR VAR(VAR(VAR)) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``""   VAR = VAR(VAR.VAR.VAR(""VAR"", ""1"")) VAR.VAR(VAR) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR"" VAR VAR.VAR == ""VAR"": VAR VAR(VAR.VAR) VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR"" VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR/VAR VAR"" VAR = VAR""VAR, VAR!"" VAR = VAR.VAR.VAR(""VAR-VAR"", """") VAR = VAR VAR VAR == ""VAR"": VAR = [(""VAR-VAR"", ""VAR"")] VAR = VAR() VAR VAR.VAR( VAR.VAR("""", VAR=""VAR"", VAR=VAR) ) VAR VAR: VAR.VAR(VAR) VAR = VAR.VAR() VAR VAR == ""VAR"": VAR = [(""VAR-VAR"", ""VAR"")] VAR = VAR.VAR(VAR) VAR VAR == ""VAR-VAR"": VAR = [(""VAR-VAR"", ""VAR"")] VAR = ""VAR"" VAR VAR == ""VAR-VAR"": VAR = [(""VAR-VAR"", ""VAR"")] VAR = ""VAR"" VAR VAR(VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR(VAR.VAR(VAR(VAR.VAR))) VAR VAR(VAR, VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR. """""" VAR = VAR.VAR.VAR(""VAR-VAR"", VAR) VAR VAR VAR: VAR VAR(""VAR-VAR VAR VAR VAR"", VAR=""400 VAR VAR"") VAR[VAR] += 1 VAR VAR[VAR] >= 2: VAR VAR(""VAR VAR!"") VAR: VAR VAR(""VAR VAR VAR VAR!"", VAR=""418 VAR'VAR VAR VAR"") VAR VAR(VAR, VAR): VAR VAR([""123""] * 4) VAR VAR(VAR, VAR): VAR = [] VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR VAR VAR [VAR""123""] * 4: VAR.VAR(VAR.VAR(VAR)) VAR.VAR(VAR.VAR()) VAR VAR(VAR, VAR=[(""VAR-VAR"", ""VAR"")]) VAR VAR(VAR, VAR): VAR = VAR(VAR.VAR.VAR(""VAR"")) VAR = VAR""1"" * VAR VAR VAR(VAR, VAR=[(""VAR-VAR"", ""VAR/VAR-VAR"")]) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(""VAR"", ""200 VAR"") VAR VAR(VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR() - VAR.VAR.VAR < VAR(VAR=1): VAR = VAR.VAR.VAR(""VAR"", VAR""429 VAR VAR VAR"") VAR VAR( VAR=VAR.VAR(""VAR-8""), VAR=[(""VAR-VAR"", ""1"")] ) VAR.VAR.VAR = VAR.VAR() VAR VAR(VAR=""200 VAR"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR(""VAR"") VAR VAR: VAR = VAR( VAR.VAR(VAR.VAR(VAR(VAR))) ) VAR: VAR = ""1"" VAR = VAR.VAR.VAR(""VAR"", ""/"") VAR = [(""VAR"", VAR), (""VAR-VAR"", VAR)] VAR VAR(VAR=""303 VAR VAR"", VAR=VAR) VAR VAR(VAR, VAR): VAR.VAR() ",8
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/appengine/test_urlfetch.py,"""""""These tests ensure that when running in App Engine standard with the
App Engine sandbox enabled that urllib3 appropriately uses the App
Engine-patched version of httplib to make requests.""""""

import httplib
import pytest
import StringIO
from mock import patch

from ..test_no_ssl import TestWithoutSSL


class MockResponse(object):
    def __init__(self, content, status_code, content_was_truncated, final_url, headers):

        self.content = content
        self.status_code = status_code
        self.content_was_truncated = content_was_truncated
        self.final_url = final_url
        self.header_msg = httplib.HTTPMessage(
            StringIO.StringIO(
                """".join([""%s: %s\n"" % (k, v) for k, v in headers.iteritems()] + [""\n""])
            )
        )
        self.headers = headers


@pytest.mark.usefixtures(""sandbox"")
class TestHTTP(TestWithoutSSL):
    def test_urlfetch_called_with_http(self):
        """"""Check that URLFetch is used to fetch non-https resources.""""""
        resp = MockResponse(
            ""OK"", 200, False, ""http://www.google.com"", {""content-type"": ""text/plain""}
        )
        fetch_patch = patch(""google.appengine.api.urlfetch.fetch"", return_value=resp)
        with fetch_patch as fetch_mock:
            import urllib3

            pool = urllib3.HTTPConnectionPool(""www.google.com"", ""80"")
            r = pool.request(""GET"", ""/"")
            assert r.status == 200, r.data
            assert fetch_mock.call_count == 1


@pytest.mark.usefixtures(""sandbox"")
class TestHTTPS(object):
    @pytest.mark.xfail(
        reason=""This is not yet supported by urlfetch, presence of the ssl ""
        ""module will bypass urlfetch.""
    )
    def test_urlfetch_called_with_https(self):
        """"""
        Check that URLFetch is used when fetching https resources
        """"""
        resp = MockResponse(
            ""OK"", 200, False, ""https://www.google.com"", {""content-type"": ""text/plain""}
        )
        fetch_patch = patch(""google.appengine.api.urlfetch.fetch"", return_value=resp)
        with fetch_patch as fetch_mock:
            import urllib3

            pool = urllib3.HTTPSConnectionPool(""www.google.com"", ""443"")
            pool.ConnectionCls = urllib3.connection.UnverifiedHTTPSConnection
            r = pool.request(""GET"", ""/"")
            assert r.status == 200, r.data
            assert fetch_mock.call_count == 1",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"""""""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ..VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR, VAR, VAR, VAR, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR.VAR( VAR.VAR( """".VAR([""%VAR: %VAR\VAR"" % (VAR, VAR) VAR VAR, VAR VAR VAR.VAR()] + [""\VAR""]) ) ) VAR.VAR = VAR @VAR.VAR.VAR(""VAR"") VAR VAR(VAR): VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR."""""" VAR = VAR( ""VAR"", 200, VAR, ""VAR: ) VAR = VAR(""VAR.VAR.VAR.VAR.VAR"", VAR=VAR) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR(""VAR.VAR.VAR"", ""80"") VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200, VAR.VAR VAR VAR.VAR == 1 @VAR.VAR.VAR(""VAR"") VAR VAR(VAR): @VAR.VAR.VAR( VAR=""VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR "" ""VAR VAR VAR VAR."" ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR( ""VAR"", 200, VAR, ""VAR: ) VAR = VAR(""VAR.VAR.VAR.VAR.VAR"", VAR=VAR) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR(""VAR.VAR.VAR"", ""443"") VAR.VAR = VAR.VAR.VAR VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200, VAR.VAR VAR VAR.VAR == 1 ",8
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/contritest_socks.py,"import socket
import threading
from test import SHORT_TIMEOUT

import pytest

from dummyserver.server import DEFAULT_CA, DEFAULT_CERTS
from dummyserver.testcase import IPV4SocketDummyServerTestCase
from urllib3.contrib import socks
from urllib3.exceptions import ConnectTimeoutError, NewConnectionError

try:
    import ssl

    from urllib3.util import ssl_ as better_ssl

    HAS_SSL = True
except ImportError:
    ssl = None
    better_ssl = None
    HAS_SSL = False


SOCKS_NEGOTIATION_NONE = b""\x00""
SOCKS_NEGOTIATION_PASSWORD = b""\x02""

SOCKS_VERSION_SOCKS4 = b""\x04""
SOCKS_VERSION_SOCKS5 = b""\x05""


def _get_free_port(host):
    """"""
    Gets a free port by opening a socket, binding it, checking the assigned
    port, and then closing it.
    """"""
    s = socket.socket()
    s.bind((host, 0))
    port = s.getsockname()[1]
    s.close()
    return port


def _read_exactly(sock, amt):
    """"""
    Read *exactly* ``amt`` bytes from the socket ``sock``.
    """"""
    data = b""""

    while amt > 0:
        chunk = sock.recv(amt)
        data += chunk
        amt -= len(chunk)

    return data


def _read_until(sock, char):
    """"""
    Read from the socket until the character is received.
    """"""
    chunks = []
    while True:
        chunk = sock.recv(1)
        chunks.append(chunk)
        if chunk == char:
            break

    return b"""".join(chunks)


def _address_from_socket(sock):
    """"""
    Returns the address from the SOCKS socket
    """"""
    addr_type = sock.recv(1)

    if addr_type == b""\x01"":
        ipv4_addr = _read_exactly(sock, 4)
        return socket.inet_ntoa(ipv4_addr)
    elif addr_type == b""\x04"":
        ipv6_addr = _read_exactly(sock, 16)
        return socket.inet_ntop(socket.AF_INET6, ipv6_addr)
    elif addr_type == b""\x03"":
        addr_len = ord(sock.recv(1))
        return _read_exactly(sock, addr_len)
    else:
        raise RuntimeError(""Unexpected addr type: %r"" % addr_type)


def handle_socks5_negotiation(sock, negotiate, username=None, password=None):
    """"""
    Handle the SOCKS5 handshake.

    Returns a generator object that allows us to break the handshake into
    steps so that the test code can intervene at certain useful points.
    """"""
    received_version = sock.recv(1)
    assert received_version == SOCKS_VERSION_SOCKS5
    nmethods = ord(sock.recv(1))
    methods = _read_exactly(sock, nmethods)

    if negotiate:
        assert SOCKS_NEGOTIATION_PASSWORD in methods
        send_data = SOCKS_VERSION_SOCKS5 + SOCKS_NEGOTIATION_PASSWORD
        sock.sendall(send_data)

        # This is the password negotiation.
        negotiation_version = sock.recv(1)
        assert negotiation_version == b""\x01""
        ulen = ord(sock.recv(1))
        provided_username = _read_exactly(sock, ulen)
        plen = ord(sock.recv(1))
        provided_password = _read_exactly(sock, plen)

        if username == provided_username and password == provided_password:
            sock.sendall(b""\x01\x00"")
        else:
            sock.sendall(b""\x01\x01"")
            sock.close()
            yield False
            return
    else:
        assert SOCKS_NEGOTIATION_NONE in methods
        send_data = SOCKS_VERSION_SOCKS5 + SOCKS_NEGOTIATION_NONE
        sock.sendall(send_data)

    # Client sends where they want to go.
    received_version = sock.recv(1)
    command = sock.recv(1)
    reserved = sock.recv(1)
    addr = _address_from_socket(sock)
    port = _read_exactly(sock, 2)
    port = (ord(port[0:1]) << 8) + (ord(port[1:2]))

    # Check some basic stuff.
    assert received_version == SOCKS_VERSION_SOCKS5
    assert command == b""\x01""  # Only support connect, not bind.
    assert reserved == b""\x00""

    # Yield the address port tuple.
    succeed = yield addr, port

    if succeed:
        # Hard-coded response for now.
        response = SOCKS_VERSION_SOCKS5 + b""\x00\x00\x01\x7f\x00\x00\x01\xea\x60""
    else:
        # Hard-coded response for now.
        response = SOCKS_VERSION_SOCKS5 + b""\x01\00""

    sock.sendall(response)
    yield True  # Avoid StopIteration exceptions getting fired.


def handle_socks4_negotiation(sock, username=None):
    """"""
    Handle the SOCKS4 handshake.

    Returns a generator object that allows us to break the handshake into
    steps so that the test code can intervene at certain useful points.
    """"""
    received_version = sock.recv(1)
    command = sock.recv(1)
    port = _read_exactly(sock, 2)
    port = (ord(port[0:1]) << 8) + (ord(port[1:2]))
    addr = _read_exactly(sock, 4)
    provided_username = _read_until(sock, b""\x00"")[:-1]  # Strip trailing null.

    if addr == b""\x00\x00\x00\x01"":
        # Magic string: means DNS name.
        addr = _read_until(sock, b""\x00"")[:-1]  # Strip trailing null.
    else:
        addr = socket.inet_ntoa(addr)

    # Check some basic stuff.
    assert received_version == SOCKS_VERSION_SOCKS4
    assert command == b""\x01""  # Only support connect, not bind.

    if username is not None and username != provided_username:
        sock.sendall(b""\x00\x5d\x00\x00\x00\x00\x00\x00"")
        sock.close()
        yield False
        return

    # Yield the address port tuple.
    succeed = yield addr, port

    if succeed:
        response = b""\x00\x5a\xea\x60\x7f\x00\x00\x01""
    else:
        response = b""\x00\x5b\x00\x00\x00\x00\x00\x00""

    sock.sendall(response)
    yield True  # Avoid StopIteration exceptions getting fired.


class TestSOCKSProxyManager(object):
    def test_invalid_socks_version_is_valueerror(self):
        with pytest.raises(ValueError) as e:
            socks.SOCKSProxyManager(proxy_url=""http://example.org"")
        assert ""Unable to determine SOCKS version"" in e.value.args[0]


class TestSocks5Proxy(IPV4SocketDummyServerTestCase):
    """"""
    Test the SOCKS proxy in SOCKS5 mode.
    """"""

    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            assert addr == ""16.17.18.19""
            assert port == 80
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            response = pm.request(""GET"", ""http://16.17.18.19"")

            assert response.status == 200
            assert response.data == b""""
            assert response.headers[""Server""] == ""SocksTestServer""

    def test_local_dns(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            assert addr in [""127.0.0.1"", ""::1""]
            assert port == 80
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            response = pm.request(""GET"", ""http://localhost"")

            assert response.status == 200
            assert response.data == b""""
            assert response.headers[""Server""] == ""SocksTestServer""

    def test_correct_header_line(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            assert addr == b""example.com""
            assert port == 80
            handler.send(True)

            buf = b""""
            while True:
                buf += sock.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            assert buf.startswith(b""GET / HTTP/1.1"")
            assert b""Host: example.com"" in buf

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            response = pm.request(""GET"", ""http://example.com"")
            assert response.status == 200

    def test_connection_timeouts(self):
        event = threading.Event()

        def request_handler(listener):
            event.wait()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            with pytest.raises(ConnectTimeoutError):
                pm.request(
                    ""GET"", ""http://example.com"", timeout=SHORT_TIMEOUT, retries=False
                )
            event.set()

    def test_connection_failure(self):
        event = threading.Event()

        def request_handler(listener):
            listener.close()
            event.set()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            event.wait()
            with pytest.raises(NewConnectionError):
                pm.request(""GET"", ""http://example.com"", retries=False)

    def test_proxy_rejection(self):
        evt = threading.Event()

        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)
            handler.send(False)

            evt.wait()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            with pytest.raises(NewConnectionError):
                pm.request(""GET"", ""http://example.com"", retries=False)
            evt.set()

    def test_socks_with_password(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b""user"", password=b""pass""
            )
            addr, port = next(handler)

            assert addr == ""16.17.18.19""
            assert port == 80
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url, username=""user"", password=""pass"") as pm:
            response = pm.request(""GET"", ""http://16.17.18.19"")

            assert response.status == 200
            assert response.data == b""""
            assert response.headers[""Server""] == ""SocksTestServer""

    def test_socks_with_auth_in_url(self):
        """"""
        Test when we have auth info in url, i.e.
        socks5://user:pass@host:port and no username/password as params
        """"""

        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b""user"", password=b""pass""
            )
            addr, port = next(handler)

            assert addr == ""16.17.18.19""
            assert port == 80
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://user:pass@%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            response = pm.request(""GET"", ""http://16.17.18.19"")

            assert response.status == 200
            assert response.data == b""""
            assert response.headers[""Server""] == ""SocksTestServer""

    def test_socks_with_invalid_password(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b""user"", password=b""pass""
            )
            next(handler)

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(
            proxy_url, username=""user"", password=""badpass""
        ) as pm:
            with pytest.raises(NewConnectionError) as e:
                pm.request(""GET"", ""http://example.com"", retries=False)
            assert ""SOCKS5 authentication failed"" in str(e.value)

    def test_source_address_works(self):
        expected_port = _get_free_port(self.host)

        def request_handler(listener):
            sock = listener.accept()[0]
            assert sock.getpeername()[0] == ""127.0.0.1""
            assert sock.getpeername()[1] == expected_port

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            assert addr == ""16.17.18.19""
            assert port == 80
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(
            proxy_url, source_address=(""127.0.0.1"", expected_port)
        ) as pm:
            response = pm.request(""GET"", ""http://16.17.18.19"")
            assert response.status == 200


class TestSOCKS4Proxy(IPV4SocketDummyServerTestCase):
    """"""
    Test the SOCKS proxy in SOCKS4 mode.

    Has relatively fewer tests than the SOCKS5 case, mostly because once the
    negotiation is done the two cases behave identically.
    """"""

    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            assert addr == ""16.17.18.19""
            assert port == 80
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            response = pm.request(""GET"", ""http://16.17.18.19"")

            assert response.status == 200
            assert response.headers[""Server""] == ""SocksTestServer""
            assert response.data == b""""

    def test_local_dns(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            assert addr == ""127.0.0.1""
            assert port == 80
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            response = pm.request(""GET"", ""http://localhost"")

            assert response.status == 200
            assert response.headers[""Server""] == ""SocksTestServer""
            assert response.data == b""""

    def test_correct_header_line(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            assert addr == b""example.com""
            assert port == 80
            handler.send(True)

            buf = b""""
            while True:
                buf += sock.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            assert buf.startswith(b""GET / HTTP/1.1"")
            assert b""Host: example.com"" in buf

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            response = pm.request(""GET"", ""http://example.com"")
            assert response.status == 200

    def test_proxy_rejection(self):
        evt = threading.Event()

        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)
            handler.send(False)

            evt.wait()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url) as pm:
            with pytest.raises(NewConnectionError):
                pm.request(""GET"", ""http://example.com"", retries=False)
            evt.set()

    def test_socks4_with_username(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock, username=b""user"")
            addr, port = next(handler)

            assert addr == ""16.17.18.19""
            assert port == 80
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url, username=""user"") as pm:
            response = pm.request(""GET"", ""http://16.17.18.19"")

            assert response.status == 200
            assert response.data == b""""
            assert response.headers[""Server""] == ""SocksTestServer""

    def test_socks_with_invalid_username(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock, username=b""user"")
            next(handler)

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url, username=""baduser"") as pm:
            with pytest.raises(NewConnectionError) as e:
                pm.request(""GET"", ""http://example.com"", retries=False)
                assert ""different user-ids"" in str(e.value)


class TestSOCKSWithTLS(IPV4SocketDummyServerTestCase):
    """"""
    Test that TLS behaves properly for SOCKS proxies.
    """"""

    @pytest.mark.skipif(not HAS_SSL, reason=""No TLS available"")
    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            assert addr == b""localhost""
            assert port == 443
            handler.send(True)

            # Wrap in TLS
            context = better_ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            context.load_cert_chain(DEFAULT_CERTS[""certfile""], DEFAULT_CERTS[""keyfile""])
            tls = context.wrap_socket(sock, server_side=True)
            buf = b""""

            while True:
                buf += tls.recv(65535)
                if buf.endswith(b""\r\n\r\n""):
                    break

            assert buf.startswith(b""GET / HTTP/1.1\r\n"")

            tls.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: SocksTestServer\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            tls.close()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        with socks.SOCKSProxyManager(proxy_url, ca_certs=DEFAULT_CA) as pm:
            response = pm.request(""GET"", ""https://localhost"")

            assert response.status == 200
            assert response.data == b""""
            assert response.headers[""Server""] == ""SocksTestServer""",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR: VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR = VAR VAR VAR: VAR = VAR VAR = VAR VAR = VAR VAR = VAR""\VAR"" VAR = VAR""\VAR"" VAR = VAR""\VAR"" VAR = VAR""\VAR"" VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR.VAR((VAR, 0)) VAR = VAR.VAR()[1] VAR.VAR() VAR VAR VAR VAR(VAR, VAR): """""" VAR *VAR* ``VAR`` VAR VAR VAR VAR ``VAR``. """""" VAR = VAR"""" VAR VAR > 0: VAR = VAR.VAR(VAR) VAR += VAR VAR -= VAR(VAR) VAR VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = [] VAR VAR: VAR = VAR.VAR(1) VAR.VAR(VAR) VAR VAR == VAR: VAR VAR VAR"""".VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR.VAR(1) VAR VAR == VAR""\VAR"": VAR = VAR(VAR, 4) VAR VAR.VAR(VAR) VAR VAR == VAR""\VAR"": VAR = VAR(VAR, 16) VAR VAR.VAR(VAR.VAR, VAR) VAR VAR == VAR""\VAR"": VAR = VAR(VAR.VAR(1)) VAR VAR(VAR, VAR) VAR: VAR VAR(""VAR VAR VAR: %VAR"" % VAR) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): """""" VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(1) VAR VAR == VAR VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR VAR: VAR VAR VAR VAR VAR = VAR + VAR VAR.VAR(VAR)  VAR = VAR.VAR(1) VAR VAR == VAR""\VAR"" VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR VAR == VAR VAR VAR == VAR: VAR.VAR(VAR""\VAR\VAR"") VAR: VAR.VAR(VAR""\VAR\VAR"") VAR.VAR() VAR VAR VAR VAR: VAR VAR VAR VAR VAR = VAR + VAR VAR.VAR(VAR)  VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR(VAR) VAR = VAR(VAR, 2) VAR = (VAR(VAR[0:1]) << 8) + (VAR(VAR[1:2]))  VAR VAR == VAR VAR VAR == VAR""\VAR""  VAR VAR == VAR""\VAR""  VAR = VAR VAR, VAR VAR VAR:  VAR = VAR + VAR""\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR"" VAR:  VAR = VAR + VAR""\VAR\00"" VAR.VAR(VAR) VAR VAR  VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR(VAR, 2) VAR = (VAR(VAR[0:1]) << 8) + (VAR(VAR[1:2])) VAR = VAR(VAR, 4) VAR = VAR(VAR, VAR""\VAR"")[:-1]  VAR VAR == VAR""\VAR\VAR\VAR\VAR"":  VAR = VAR(VAR, VAR""\VAR"")[:-1]  VAR: VAR = VAR.VAR(VAR)  VAR VAR == VAR VAR VAR == VAR""\VAR""  VAR VAR VAR VAR VAR VAR VAR != VAR: VAR.VAR(VAR""\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR"") VAR.VAR() VAR VAR VAR  VAR = VAR VAR, VAR VAR VAR: VAR = VAR""\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR"" VAR: VAR = VAR""\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR"" VAR.VAR(VAR) VAR VAR  VAR VAR(VAR): VAR VAR(VAR): VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(VAR=""VAR: VAR ""VAR VAR VAR VAR VAR"" VAR VAR.VAR.VAR[0] VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR VAR == ""16.17.18.19"" VAR VAR == 80 VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR.VAR == VAR"""" VAR VAR.VAR[""VAR""] == ""VAR"" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR VAR VAR [""127.0.0.1"", ""::1""] VAR VAR == 80 VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR.VAR == VAR"""" VAR VAR.VAR[""VAR""] == ""VAR"" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR VAR == VAR""VAR.VAR"" VAR VAR == 80 VAR.VAR(VAR) VAR = VAR"""" VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR VAR.VAR(VAR""VAR / VAR/1.1"") VAR VAR""VAR: VAR.VAR"" VAR VAR VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""VAR: ) VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""VAR: VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR""VAR"", VAR=VAR""VAR"" ) VAR, VAR = VAR(VAR) VAR VAR == ""16.17.18.19"" VAR VAR == 80 VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR, VAR=""VAR"", VAR=""VAR"") VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR.VAR == VAR"""" VAR VAR.VAR[""VAR""] == ""VAR"" VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR.VAR. VAR: """""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR""VAR"", VAR=VAR""VAR"" ) VAR, VAR = VAR(VAR) VAR VAR == ""16.17.18.19"" VAR VAR == 80 VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR.VAR == VAR"""" VAR VAR.VAR[""VAR""] == ""VAR"" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR""VAR"", VAR=VAR""VAR"" ) VAR(VAR) VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR( VAR, VAR=""VAR"", VAR=""VAR"" ) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""VAR: VAR ""VAR VAR VAR"" VAR VAR(VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR.VAR()[0] == ""127.0.0.1"" VAR VAR.VAR()[1] == VAR VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR VAR == ""16.17.18.19"" VAR VAR == 80 VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR( VAR, VAR=(""127.0.0.1"", VAR) ) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR VAR == ""16.17.18.19"" VAR VAR == 80 VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR.VAR[""VAR""] == ""VAR"" VAR VAR.VAR == VAR"""" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR VAR == ""127.0.0.1"" VAR VAR == 80 VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR.VAR[""VAR""] == ""VAR"" VAR VAR.VAR == VAR"""" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR VAR == VAR""VAR.VAR"" VAR VAR == 80 VAR.VAR(VAR) VAR = VAR"""" VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR VAR.VAR(VAR""VAR / VAR/1.1"") VAR VAR""VAR: VAR.VAR"" VAR VAR VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR""VAR"") VAR, VAR = VAR(VAR) VAR VAR == ""16.17.18.19"" VAR VAR == 80 VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR, VAR=""VAR"") VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR.VAR == VAR"""" VAR VAR.VAR[""VAR""] == ""VAR"" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR""VAR"") VAR(VAR) VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR, VAR=""VAR"") VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""VAR: VAR ""VAR VAR-VAR"" VAR VAR(VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. """""" @VAR.VAR.VAR(VAR VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR VAR == VAR""VAR"" VAR VAR == 443 VAR.VAR(VAR)  VAR = VAR.VAR(VAR.VAR) VAR.VAR(VAR[""VAR""], VAR[""VAR""]) VAR = VAR.VAR(VAR, VAR=VAR) VAR = VAR"""" VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR VAR.VAR(VAR""VAR / VAR/1.1\VAR\VAR"") VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR.VAR(VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR.VAR == VAR"""" VAR VAR.VAR[""VAR""] == ""VAR"" ",8
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/with_dummyserver/test_chunked_transfer.py,"# -*- coding: utf-8 -*-

import pytest

from dummyserver.testcase import (
    ConnectionMarker,
    SocketDummyServerTestCase,
    consume_socket,
)
from urllib3 import HTTPConnectionPool
from urllib3.util import SKIP_HEADER
from urllib3.util.retry import Retry

# Retry failed tests
pytestmark = pytest.mark.flaky


class TestChunkedTransfer(SocketDummyServerTestCase):
    def start_chunked_handler(self):
        self.buffer = b""""

        def socket_handler(listener):
            sock = listener.accept()[0]

            while not self.buffer.endswith(b""\r\n0\r\n\r\n""):
                self.buffer += sock.recv(65536)

            sock.send(
                b""HTTP/1.1 200 OK\r\n""
                b""Content-type: text/plain\r\n""
                b""Content-Length: 0\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(socket_handler)

    def test_chunks(self):
        self.start_chunked_handler()
        chunks = [""foo"", ""bar"", """", ""bazzzzzzzzzzzzzzzzzzzzzz""]
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            pool.urlopen(""GET"", ""/"", chunks, headers=dict(DNT=""1""), chunked=True)

            assert b""Transfer-Encoding"" in self.buffer
            body = self.buffer.split(b""\r\n\r\n"", 1)[1]
            lines = body.split(b""\r\n"")
            # Empty chunks should have been skipped, as this could not be distinguished
            # from terminating the transmission
            for i, chunk in enumerate([c for c in chunks if c]):
                assert lines[i * 2] == hex(len(chunk))[2:].encode(""utf-8"")
                assert lines[i * 2 + 1] == chunk.encode(""utf-8"")

    def _test_body(self, data):
        self.start_chunked_handler()
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            pool.urlopen(""GET"", ""/"", data, chunked=True)
            header, body = self.buffer.split(b""\r\n\r\n"", 1)

            assert b""Transfer-Encoding: chunked"" in header.split(b""\r\n"")
            if data:
                bdata = data if isinstance(data, bytes) else data.encode(""utf-8"")
                assert b""\r\n"" + bdata + b""\r\n"" in body
                assert body.endswith(b""\r\n0\r\n\r\n"")

                len_str = body.split(b""\r\n"", 1)[0]
                stated_len = int(len_str, 16)
                assert stated_len == len(bdata)
            else:
                assert body == b""0\r\n\r\n""

    def test_bytestring_body(self):
        self._test_body(b""thisshouldbeonechunk\r\nasdf"")

    def test_unicode_body(self):
        self._test_body(u""thisshouldbeonechunk\r\n"")

    def test_empty_body(self):
        self._test_body(None)

    def test_empty_string_body(self):
        self._test_body("""")

    def test_empty_iterable_body(self):
        self._test_body([])

    def _get_header_lines(self, prefix):
        header_block = self.buffer.split(b""\r\n\r\n"", 1)[0].lower()
        header_lines = header_block.split(b""\r\n"")[1:]
        return [x for x in header_lines if x.startswith(prefix)]

    def test_removes_duplicate_host_header(self):
        self.start_chunked_handler()
        chunks = [""foo"", ""bar"", """", ""bazzzzzzzzzzzzzzzzzzzzzz""]
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            pool.urlopen(""GET"", ""/"", chunks, headers={""Host"": ""test.org""}, chunked=True)

            host_headers = self._get_header_lines(b""host"")
            assert len(host_headers) == 1

    def test_provides_default_host_header(self):
        self.start_chunked_handler()
        chunks = [""foo"", ""bar"", """", ""bazzzzzzzzzzzzzzzzzzzzzz""]
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            pool.urlopen(""GET"", ""/"", chunks, chunked=True)

            host_headers = self._get_header_lines(b""host"")
            assert len(host_headers) == 1

    def test_provides_default_user_agent_header(self):
        self.start_chunked_handler()
        chunks = [""foo"", ""bar"", """", ""bazzzzzzzzzzzzzzzzzzzzzz""]
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            pool.urlopen(""GET"", ""/"", chunks, chunked=True)

            ua_headers = self._get_header_lines(b""user-agent"")
            assert len(ua_headers) == 1

    def test_remove_user_agent_header(self):
        self.start_chunked_handler()
        chunks = [""foo"", ""bar"", """", ""bazzzzzzzzzzzzzzzzzzzzzz""]
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            pool.urlopen(
                ""GET"",
                ""/"",
                chunks,
                headers={""User-Agent"": SKIP_HEADER},
                chunked=True,
            )

            ua_headers = self._get_header_lines(b""user-agent"")
            assert len(ua_headers) == 0

    def test_preserve_chunked_on_retry_after(self):
        self.chunked_requests = 0
        self.socks = []

        def socket_handler(listener):
            for _ in range(2):
                sock = listener.accept()[0]
                self.socks.append(sock)
                request = consume_socket(sock)
                if b""Transfer-Encoding: chunked"" in request.split(b""\r\n""):
                    self.chunked_requests += 1

                sock.send(
                    b""HTTP/1.1 429 Too Many Requests\r\n""
                    b""Content-Type: text/plain\r\n""
                    b""Retry-After: 1\r\n""
                    b""Content-Length: 0\r\n""
                    b""Connection: close\r\n""
                    b""\r\n""
                )

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            retries = Retry(total=1)
            pool.urlopen(""GET"", ""/"", chunked=True, retries=retries)
            for sock in self.socks:
                sock.close()
        assert self.chunked_requests == 2

    def test_preserve_chunked_on_redirect(self, monkeypatch):
        self.chunked_requests = 0

        def socket_handler(listener):
            for i in range(2):
                sock = listener.accept()[0]
                request = ConnectionMarker.consume_request(sock)
                if b""Transfer-Encoding: chunked"" in request.split(b""\r\n""):
                    self.chunked_requests += 1

                if i == 0:
                    sock.sendall(
                        b""HTTP/1.1 301 Moved Permanently\r\n""
                        b""Location: /redirect\r\n\r\n""
                    )
                else:
                    sock.sendall(b""HTTP/1.1 200 OK\r\n\r\n"")
                sock.close()

        self._start_server(socket_handler)
        with ConnectionMarker.mark(monkeypatch):
            with HTTPConnectionPool(self.host, self.port) as pool:
                retries = Retry(redirect=1)
                pool.urlopen(
                    ""GET"", ""/"", chunked=True, preload_content=False, retries=retries
                )
        assert self.chunked_requests == 2

    def test_preserve_chunked_on_broken_connection(self, monkeypatch):
        self.chunked_requests = 0

        def socket_handler(listener):
            for i in range(2):
                sock = listener.accept()[0]
                request = ConnectionMarker.consume_request(sock)
                if b""Transfer-Encoding: chunked"" in request.split(b""\r\n""):
                    self.chunked_requests += 1

                if i == 0:
                    # Bad HTTP version will trigger a connection close
                    sock.sendall(b""HTTP/0.5 200 OK\r\n\r\n"")
                else:
                    sock.sendall(b""HTTP/1.1 200 OK\r\n\r\n"")
                sock.close()

        self._start_server(socket_handler)
        with ConnectionMarker.mark(monkeypatch):
            with HTTPConnectionPool(self.host, self.port) as pool:
                retries = Retry(read=1)
                pool.urlopen(
                    ""GET"", ""/"", chunked=True, preload_content=False, retries=retries
                )
            assert self.chunked_requests == 2",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED," VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, ) VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR  VAR = VAR.VAR.VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR"""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR.VAR(VAR""\VAR\VAR\VAR\VAR\VAR\VAR""): VAR.VAR += VAR.VAR(65536) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR() VAR = [""VAR"", ""VAR"", """", ""VAR""] VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR, VAR=VAR(VAR=""1""), VAR=VAR) VAR VAR""VAR-VAR"" VAR VAR.VAR VAR = VAR.VAR.VAR(VAR""\VAR\VAR\VAR\VAR"", 1)[1] VAR = VAR.VAR(VAR""\VAR\VAR"")   VAR VAR, VAR VAR VAR([VAR VAR VAR VAR VAR VAR VAR]): VAR VAR[VAR * 2] == VAR(VAR(VAR))[2:].VAR(""VAR-8"") VAR VAR[VAR * 2 + 1] == VAR.VAR(""VAR-8"") VAR VAR(VAR, VAR): VAR.VAR() VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR, VAR=VAR) VAR, VAR = VAR.VAR.VAR(VAR""\VAR\VAR\VAR\VAR"", 1) VAR VAR""VAR-VAR: VAR"" VAR VAR.VAR(VAR""\VAR\VAR"") VAR VAR: VAR = VAR VAR VAR(VAR, VAR) VAR VAR.VAR(""VAR-8"") VAR VAR""\VAR\VAR"" + VAR + VAR""\VAR\VAR"" VAR VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR\VAR\VAR"") VAR = VAR.VAR(VAR""\VAR\VAR"", 1)[0] VAR = VAR(VAR, 16) VAR VAR == VAR(VAR) VAR: VAR VAR == VAR""0\VAR\VAR\VAR\VAR"" VAR VAR(VAR): VAR.VAR(VAR""VAR\VAR\VAR"") VAR VAR(VAR): VAR.VAR(VAR""VAR\VAR\n"") VAR VAR(VAR): VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR("""") VAR VAR(VAR): VAR.VAR([]) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(VAR""\VAR\VAR\VAR\VAR"", 1)[0].VAR() VAR = VAR.VAR(VAR""\VAR\VAR"")[1:] VAR [VAR VAR VAR VAR VAR VAR VAR.VAR(VAR)] VAR VAR(VAR): VAR.VAR() VAR = [""VAR"", ""VAR"", """", ""VAR""] VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR, VAR={""VAR"": ""VAR.VAR""}, VAR=VAR) VAR = VAR.VAR(VAR""VAR"") VAR VAR(VAR) == 1 VAR VAR(VAR): VAR.VAR() VAR = [""VAR"", ""VAR"", """", ""VAR""] VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR, VAR=VAR) VAR = VAR.VAR(VAR""VAR"") VAR VAR(VAR) == 1 VAR VAR(VAR): VAR.VAR() VAR = [""VAR"", ""VAR"", """", ""VAR""] VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR, VAR=VAR) VAR = VAR.VAR(VAR""VAR-VAR"") VAR VAR(VAR) == 1 VAR VAR(VAR): VAR.VAR() VAR = [""VAR"", ""VAR"", """", ""VAR""] VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR( ""VAR"", ""/"", VAR, VAR={""VAR-VAR"": VAR}, VAR=VAR, ) VAR = VAR.VAR(VAR""VAR-VAR"") VAR VAR(VAR) == 0 VAR VAR(VAR): VAR.VAR = 0 VAR.VAR = [] VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR.VAR.VAR(VAR) VAR = VAR(VAR) VAR VAR""VAR-VAR: VAR"" VAR VAR.VAR(VAR""\VAR\VAR""): VAR.VAR += 1 VAR.VAR( VAR""VAR/1.1 429 VAR VAR VAR\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""VAR-VAR: 1\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR(VAR=1) VAR.VAR(""VAR"", ""/"", VAR=VAR, VAR=VAR) VAR VAR VAR VAR.VAR: VAR.VAR() VAR VAR.VAR == 2 VAR VAR(VAR, VAR): VAR.VAR = 0 VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR VAR""VAR-VAR: VAR"" VAR VAR.VAR(VAR""\VAR\VAR""): VAR.VAR += 1 VAR VAR == 0: VAR.VAR( VAR""VAR/1.1 301 VAR VAR\VAR\VAR"" VAR""VAR: /VAR\VAR\VAR\VAR\VAR"" ) VAR: VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR"") VAR.VAR() VAR.VAR(VAR) VAR VAR.VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR(VAR=1) VAR.VAR( ""VAR"", ""/"", VAR=VAR, VAR=VAR, VAR=VAR ) VAR VAR.VAR == 2 VAR VAR(VAR, VAR): VAR.VAR = 0 VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR VAR""VAR-VAR: VAR"" VAR VAR.VAR(VAR""\VAR\VAR""): VAR.VAR += 1 VAR VAR == 0:  VAR.VAR(VAR""VAR/0.5 200 VAR\VAR\VAR\VAR\VAR"") VAR: VAR.VAR(VAR""VAR/1.1 200 VAR\VAR\VAR\VAR\VAR"") VAR.VAR() VAR.VAR(VAR) VAR VAR.VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR(VAR=1) VAR.VAR( ""VAR"", ""/"", VAR=VAR, VAR=VAR, VAR=VAR ) VAR VAR.VAR == 2 ",8
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/with_dummyserver/test_connectionpool.py,"# -*- coding: utf-8 -*-

import io
import json
import logging
import socket
import sys
import time
import warnings
from test import LONG_TIMEOUT, SHORT_TIMEOUT, onlyPy2
from threading import Event

import mock
import pytest
import six

from dummyserver.server import HAS_IPV6_AND_DNS, NoIPv6Warning
from dummyserver.testcase import HTTPDummyServerTestCase, SocketDummyServerTestCase
from urllib3 import HTTPConnectionPool, encode_multipart_formdata
from urllib3._collections import HTTPHeaderDict
from urllib3.connection import _get_default_user_agent
from urllib3.exceptions import (
    ConnectTimeoutError,
    DecodeError,
    EmptyPoolError,
    MaxRetryError,
    NewConnectionError,
    ReadTimeoutError,
    UnrewindableBodyError,
)
from urllib3.packages.six import b, u
from urllib3.packages.six.moves.urllib.parse import urlencode
from urllib3.util import SKIP_HEADER, SKIPPABLE_HEADERS
from urllib3.util.retry import RequestHistory, Retry
from urllib3.util.timeout import Timeout

from .. import INVALID_SOURCE_ADDRESSES, TARPIT_HOST, VALID_SOURCE_ADDRESSES
from ..port_helpers import find_unused_port

pytestmark = pytest.mark.flaky

log = logging.getLogger(""urllib3.connectionpool"")
log.setLevel(logging.NOTSET)
log.addHandler(logging.StreamHandler(sys.stdout))


def wait_for_socket(ready_event):
    ready_event.wait()
    ready_event.clear()


class TestConnectionPoolTimeouts(SocketDummyServerTestCase):
    def test_timeout_float(self):
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=2)

        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            wait_for_socket(ready_event)
            with pytest.raises(ReadTimeoutError):
                pool.request(""GET"", ""/"", timeout=SHORT_TIMEOUT)
            block_event.set()  # Release block

            # Shouldn't raise this time
            wait_for_socket(ready_event)
            block_event.set()  # Pre-release block
            pool.request(""GET"", ""/"", timeout=LONG_TIMEOUT)

    def test_conn_closed(self):
        block_event = Event()
        self.start_basic_handler(block_send=block_event, num=1)

        with HTTPConnectionPool(
            self.host, self.port, timeout=SHORT_TIMEOUT, retries=False
        ) as pool:
            conn = pool._get_conn()
            pool._put_conn(conn)
            try:
                with pytest.raises(ReadTimeoutError):
                    pool.urlopen(""GET"", ""/"")
                if conn.sock:
                    with pytest.raises(socket.error):
                        conn.sock.recv(1024)
            finally:
                pool._put_conn(conn)

            block_event.set()

    def test_timeout(self):
        # Requests should time out when expected
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=3)

        # Pool-global timeout
        short_timeout = Timeout(read=SHORT_TIMEOUT)
        with HTTPConnectionPool(
            self.host, self.port, timeout=short_timeout, retries=False
        ) as pool:
            wait_for_socket(ready_event)
            block_event.clear()
            with pytest.raises(ReadTimeoutError):
                pool.request(""GET"", ""/"")
            block_event.set()  # Release request

        # Request-specific timeouts should raise errors
        with HTTPConnectionPool(
            self.host, self.port, timeout=short_timeout, retries=False
        ) as pool:
            wait_for_socket(ready_event)
            now = time.time()
            with pytest.raises(ReadTimeoutError):
                pool.request(""GET"", ""/"", timeout=LONG_TIMEOUT)
            delta = time.time() - now

            message = ""timeout was pool-level SHORT_TIMEOUT rather than request-level LONG_TIMEOUT""
            assert delta >= LONG_TIMEOUT, message
            block_event.set()  # Release request

            # Timeout passed directly to request should raise a request timeout
            wait_for_socket(ready_event)
            with pytest.raises(ReadTimeoutError):
                pool.request(""GET"", ""/"", timeout=SHORT_TIMEOUT)
            block_event.set()  # Release request

    def test_connect_timeout(self):
        url = ""/""
        host, port = TARPIT_HOST, 80
        timeout = Timeout(connect=SHORT_TIMEOUT)

        # Pool-global timeout
        with HTTPConnectionPool(host, port, timeout=timeout) as pool:
            conn = pool._get_conn()
            with pytest.raises(ConnectTimeoutError):
                pool._make_request(conn, ""GET"", url)

            # Retries
            retries = Retry(connect=0)
            with pytest.raises(MaxRetryError):
                pool.request(""GET"", url, retries=retries)

        # Request-specific connection timeouts
        big_timeout = Timeout(read=LONG_TIMEOUT, connect=LONG_TIMEOUT)
        with HTTPConnectionPool(host, port, timeout=big_timeout, retries=False) as pool:
            conn = pool._get_conn()
            with pytest.raises(ConnectTimeoutError):
                pool._make_request(conn, ""GET"", url, timeout=timeout)

            pool._put_conn(conn)
            with pytest.raises(ConnectTimeoutError):
                pool.request(""GET"", url, timeout=timeout)

    def test_total_applies_connect(self):
        host, port = TARPIT_HOST, 80

        timeout = Timeout(total=None, connect=SHORT_TIMEOUT)
        with HTTPConnectionPool(host, port, timeout=timeout) as pool:
            conn = pool._get_conn()
            try:
                with pytest.raises(ConnectTimeoutError):
                    pool._make_request(conn, ""GET"", ""/"")
            finally:
                conn.close()

        timeout = Timeout(connect=3, read=5, total=SHORT_TIMEOUT)
        with HTTPConnectionPool(host, port, timeout=timeout) as pool:
            conn = pool._get_conn()
            try:
                with pytest.raises(ConnectTimeoutError):
                    pool._make_request(conn, ""GET"", ""/"")
            finally:
                conn.close()

    def test_total_timeout(self):
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=2)

        wait_for_socket(ready_event)
        # This will get the socket to raise an EAGAIN on the read
        timeout = Timeout(connect=3, read=SHORT_TIMEOUT)
        with HTTPConnectionPool(
            self.host, self.port, timeout=timeout, retries=False
        ) as pool:
            with pytest.raises(ReadTimeoutError):
                pool.request(""GET"", ""/"")

            block_event.set()
            wait_for_socket(ready_event)
            block_event.clear()

        # The connect should succeed and this should hit the read timeout
        timeout = Timeout(connect=3, read=5, total=SHORT_TIMEOUT)
        with HTTPConnectionPool(
            self.host, self.port, timeout=timeout, retries=False
        ) as pool:
            with pytest.raises(ReadTimeoutError):
                pool.request(""GET"", ""/"")

    def test_create_connection_timeout(self):
        self.start_basic_handler(block_send=Event(), num=0)  # needed for self.port

        timeout = Timeout(connect=SHORT_TIMEOUT, total=LONG_TIMEOUT)
        with HTTPConnectionPool(
            TARPIT_HOST, self.port, timeout=timeout, retries=False
        ) as pool:
            conn = pool._new_conn()
            with pytest.raises(ConnectTimeoutError):
                conn.connect()


class TestConnectionPool(HTTPDummyServerTestCase):
    def test_get(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/specific_method"", fields={""method"": ""GET""})
            assert r.status == 200, r.data

    def test_post_url(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""POST"", ""/specific_method"", fields={""method"": ""POST""})
            assert r.status == 200, r.data

    def test_urlopen_put(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.urlopen(""PUT"", ""/specific_method?method=PUT"")
            assert r.status == 200, r.data

    def test_wrong_specific_method(self):
        # To make sure the dummy server is actually returning failed responses
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/specific_method"", fields={""method"": ""POST""})
            assert r.status == 400, r.data

        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""POST"", ""/specific_method"", fields={""method"": ""GET""})
            assert r.status == 400, r.data

    def test_upload(self):
        data = ""I'm in ur multipart form-data, hazing a cheezburgr""
        fields = {
            ""upload_param"": ""filefield"",
            ""upload_filename"": ""lolcat.txt"",
            ""upload_size"": len(data),
            ""filefield"": (""lolcat.txt"", data),
        }

        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""POST"", ""/upload"", fields=fields)
            assert r.status == 200, r.data

    def test_one_name_multiple_values(self):
        fields = [(""foo"", ""a""), (""foo"", ""b"")]

        with HTTPConnectionPool(self.host, self.port) as pool:
            # urlencode
            r = pool.request(""GET"", ""/echo"", fields=fields)
            assert r.data == b""foo=a&foo=b""

            # multipart
            r = pool.request(""POST"", ""/echo"", fields=fields)
            assert r.data.count(b'name=""foo""') == 2

    def test_request_method_body(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            body = b""hi""
            r = pool.request(""POST"", ""/echo"", body=body)
            assert r.data == body

            fields = [(""hi"", ""hello"")]
            with pytest.raises(TypeError):
                pool.request(""POST"", ""/echo"", body=body, fields=fields)

    def test_unicode_upload(self):
        fieldname = u(""myfile"")
        filename = u(""\xe2\x99\xa5.txt"")
        data = u(""\xe2\x99\xa5"").encode(""utf8"")
        size = len(data)

        fields = {
            u(""upload_param""): fieldname,
            u(""upload_filename""): filename,
            u(""upload_size""): size,
            fieldname: (filename, data),
        }
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""POST"", ""/upload"", fields=fields)
            assert r.status == 200, r.data

    def test_nagle(self):
        """"""Test that connections have TCP_NODELAY turned on""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        with HTTPConnectionPool(self.host, self.port) as pool:
            conn = pool._get_conn()
            try:
                pool._make_request(conn, ""GET"", ""/"")
                tcp_nodelay_setting = conn.sock.getsockopt(
                    socket.IPPROTO_TCP, socket.TCP_NODELAY
                )
                assert tcp_nodelay_setting
            finally:
                conn.close()

    def test_socket_options(self):
        """"""Test that connections accept socket options.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries to
        # connect to the host provided so we need a dummyserver to be running.
        with HTTPConnectionPool(
            self.host,
            self.port,
            socket_options=[(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)],
        ) as pool:
            s = pool._new_conn()._new_conn()  # Get the socket
            try:
                using_keepalive = (
                    s.getsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE) > 0
                )
                assert using_keepalive
            finally:
                s.close()

    def test_disable_default_socket_options(self):
        """"""Test that passing None disables all socket options.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        with HTTPConnectionPool(self.host, self.port, socket_options=None) as pool:
            s = pool._new_conn()._new_conn()
            try:
                using_nagle = s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY) == 0
                assert using_nagle
            finally:
                s.close()

    def test_defaults_are_applied(self):
        """"""Test that modifying the default socket options works.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        with HTTPConnectionPool(self.host, self.port) as pool:
            # Get the HTTPConnection instance
            conn = pool._new_conn()
            try:
                # Update the default socket options
                conn.default_socket_options += [
                    (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
                ]
                s = conn._new_conn()
                nagle_disabled = (
                    s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY) > 0
                )
                using_keepalive = (
                    s.getsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE) > 0
                )
                assert nagle_disabled
                assert using_keepalive
            finally:
                conn.close()
                s.close()

    def test_connection_error_retries(self):
        """"""ECONNREFUSED error should raise a connection error, with retries""""""
        port = find_unused_port()
        with HTTPConnectionPool(self.host, port) as pool:
            with pytest.raises(MaxRetryError) as e:
                pool.request(""GET"", ""/"", retries=Retry(connect=3))
            assert type(e.value.reason) == NewConnectionError

    def test_timeout_success(self):
        timeout = Timeout(connect=3, read=5, total=None)
        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:
            pool.request(""GET"", ""/"")
            # This should not raise a ""Timeout already started"" error
            pool.request(""GET"", ""/"")

        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:
            # This should also not raise a ""Timeout already started"" error
            pool.request(""GET"", ""/"")

        timeout = Timeout(total=None)
        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:
            pool.request(""GET"", ""/"")

    def test_tunnel(self):
        # note the actual httplib.py has no tests for this functionality
        timeout = Timeout(total=None)
        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:
            conn = pool._get_conn()
            try:
                conn.set_tunnel(self.host, self.port)
                conn._tunnel = mock.Mock(return_value=None)
                pool._make_request(conn, ""GET"", ""/"")
                conn._tunnel.assert_called_once_with()
            finally:
                conn.close()

        # test that it's not called when tunnel is not set
        timeout = Timeout(total=None)
        with HTTPConnectionPool(self.host, self.port, timeout=timeout) as pool:
            conn = pool._get_conn()
            try:
                conn._tunnel = mock.Mock(return_value=None)
                pool._make_request(conn, ""GET"", ""/"")
                assert not conn._tunnel.called
            finally:
                conn.close()

    def test_redirect(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/redirect"", fields={""target"": ""/""}, redirect=False)
            assert r.status == 303

            r = pool.request(""GET"", ""/redirect"", fields={""target"": ""/""})
            assert r.status == 200
            assert r.data == b""Dummy server!""

    def test_bad_connect(self):
        with HTTPConnectionPool(""badhost.invalid"", self.port) as pool:
            with pytest.raises(MaxRetryError) as e:
                pool.request(""GET"", ""/"", retries=5)
            assert type(e.value.reason) == NewConnectionError

    def test_keepalive(self):
        with HTTPConnectionPool(self.host, self.port, block=True, maxsize=1) as pool:
            r = pool.request(""GET"", ""/keepalive?close=0"")
            r = pool.request(""GET"", ""/keepalive?close=0"")

            assert r.status == 200
            assert pool.num_connections == 1
            assert pool.num_requests == 2

    def test_keepalive_close(self):
        with HTTPConnectionPool(
            self.host, self.port, block=True, maxsize=1, timeout=2
        ) as pool:
            r = pool.request(
                ""GET"", ""/keepalive?close=1"", retries=0, headers={""Connection"": ""close""}
            )

            assert pool.num_connections == 1

            # The dummyserver will have responded with Connection:close,
            # and httplib will properly cleanup the socket.

            # We grab the HTTPConnection object straight from the Queue,
            # because _get_conn() is where the check & reset occurs
            # pylint: disable-msg=W0212
            conn = pool.pool.get()
            assert conn.sock is None
            pool._put_conn(conn)

            # Now with keep-alive
            r = pool.request(
                ""GET"",
                ""/keepalive?close=0"",
                retries=0,
                headers={""Connection"": ""keep-alive""},
            )

            # The dummyserver responded with Connection:keep-alive, the connection
            # persists.
            conn = pool.pool.get()
            assert conn.sock is not None
            pool._put_conn(conn)

            # Another request asking the server to close the connection. This one
            # should get cleaned up for the next request.
            r = pool.request(
                ""GET"", ""/keepalive?close=1"", retries=0, headers={""Connection"": ""close""}
            )

            assert r.status == 200

            conn = pool.pool.get()
            assert conn.sock is None
            pool._put_conn(conn)

            # Next request
            r = pool.request(""GET"", ""/keepalive?close=0"")

    def test_post_with_urlencode(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            data = {""banana"": ""hammock"", ""lol"": ""cat""}
            r = pool.request(""POST"", ""/echo"", fields=data, encode_multipart=False)
            assert r.data.decode(""utf-8"") == urlencode(data)

    def test_post_with_multipart(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            data = {""banana"": ""hammock"", ""lol"": ""cat""}
            r = pool.request(""POST"", ""/echo"", fields=data, encode_multipart=True)
            body = r.data.split(b""\r\n"")

            encoded_data = encode_multipart_formdata(data)[0]
            expected_body = encoded_data.split(b""\r\n"")

            # TODO: Get rid of extra parsing stuff when you can specify
            # a custom boundary to encode_multipart_formdata
            """"""
            We need to loop the return lines because a timestamp is attached
            from within encode_multipart_formdata. When the server echos back
            the data, it has the timestamp from when the data was encoded, which
            is not equivalent to when we run encode_multipart_formdata on
            the data again.
            """"""
            for i, line in enumerate(body):
                if line.startswith(b""--""):
                    continue

                assert body[i] == expected_body[i]

    def test_post_with_multipart__iter__(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            data = {""hello"": ""world""}
            r = pool.request(
                ""POST"",
                ""/echo"",
                fields=data,
                preload_content=False,
                multipart_boundary=""boundary"",
                encode_multipart=True,
            )

            chunks = [chunk for chunk in r]
            assert chunks == [
                b""--boundary\r\n"",
                b'Content-Disposition: form-data; name=""hello""\r\n',
                b""\r\n"",
                b""world\r\n"",
                b""--boundary--\r\n"",
            ]

    def test_check_gzip(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(
                ""GET"", ""/encodingrequest"", headers={""accept-encoding"": ""gzip""}
            )
            assert r.headers.get(""content-encoding"") == ""gzip""
            assert r.data == b""hello, world!""

    def test_check_deflate(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(
                ""GET"", ""/encodingrequest"", headers={""accept-encoding"": ""deflate""}
            )
            assert r.headers.get(""content-encoding"") == ""deflate""
            assert r.data == b""hello, world!""

    def test_bad_decode(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            with pytest.raises(DecodeError):
                pool.request(
                    ""GET"",
                    ""/encodingrequest"",
                    headers={""accept-encoding"": ""garbage-deflate""},
                )

            with pytest.raises(DecodeError):
                pool.request(
                    ""GET"",
                    ""/encodingrequest"",
                    headers={""accept-encoding"": ""garbage-gzip""},
                )

    def test_connection_count(self):
        with HTTPConnectionPool(self.host, self.port, maxsize=1) as pool:
            pool.request(""GET"", ""/"")
            pool.request(""GET"", ""/"")
            pool.request(""GET"", ""/"")

            assert pool.num_connections == 1
            assert pool.num_requests == 3

    def test_connection_count_bigpool(self):
        with HTTPConnectionPool(self.host, self.port, maxsize=16) as http_pool:
            http_pool.request(""GET"", ""/"")
            http_pool.request(""GET"", ""/"")
            http_pool.request(""GET"", ""/"")

            assert http_pool.num_connections == 1
            assert http_pool.num_requests == 3

    def test_partial_response(self):
        with HTTPConnectionPool(self.host, self.port, maxsize=1) as pool:
            req_data = {""lol"": ""cat""}
            resp_data = urlencode(req_data).encode(""utf-8"")

            r = pool.request(""GET"", ""/echo"", fields=req_data, preload_content=False)

            assert r.read(5) == resp_data[:5]
            assert r.read() == resp_data[5:]

    def test_lazy_load_twice(self):
        # This test is sad and confusing. Need to figure out what's
        # going on with partial reads and socket reuse.

        with HTTPConnectionPool(
            self.host, self.port, block=True, maxsize=1, timeout=2
        ) as pool:
            payload_size = 1024 * 2
            first_chunk = 512

            boundary = ""foo""

            req_data = {""count"": ""a"" * payload_size}
            resp_data = encode_multipart_formdata(req_data, boundary=boundary)[0]

            req2_data = {""count"": ""b"" * payload_size}
            resp2_data = encode_multipart_formdata(req2_data, boundary=boundary)[0]

            r1 = pool.request(
                ""POST"",
                ""/echo"",
                fields=req_data,
                multipart_boundary=boundary,
                preload_content=False,
            )

            assert r1.read(first_chunk) == resp_data[:first_chunk]

            try:
                r2 = pool.request(
                    ""POST"",
                    ""/echo"",
                    fields=req2_data,
                    multipart_boundary=boundary,
                    preload_content=False,
                    pool_timeout=0.001,
                )

                # This branch should generally bail here, but maybe someday it will
                # work? Perhaps by some sort of magic. Consider it a TODO.

                assert r2.read(first_chunk) == resp2_data[:first_chunk]

                assert r1.read() == resp_data[first_chunk:]
                assert r2.read() == resp2_data[first_chunk:]
                assert pool.num_requests == 2

            except EmptyPoolError:
                assert r1.read() == resp_data[first_chunk:]
                assert pool.num_requests == 1

            assert pool.num_connections == 1

    def test_for_double_release(self):
        MAXSIZE = 5

        # Check default state
        with HTTPConnectionPool(self.host, self.port, maxsize=MAXSIZE) as pool:
            assert pool.num_connections == 0
            assert pool.pool.qsize() == MAXSIZE

            # Make an empty slot for testing
            pool.pool.get()
            assert pool.pool.qsize() == MAXSIZE - 1

            # Check state after simple request
            pool.urlopen(""GET"", ""/"")
            assert pool.pool.qsize() == MAXSIZE - 1

            # Check state without release
            pool.urlopen(""GET"", ""/"", preload_content=False)
            assert pool.pool.qsize() == MAXSIZE - 2

            pool.urlopen(""GET"", ""/"")
            assert pool.pool.qsize() == MAXSIZE - 2

            # Check state after read
            pool.urlopen(""GET"", ""/"").data
            assert pool.pool.qsize() == MAXSIZE - 2

            pool.urlopen(""GET"", ""/"")
            assert pool.pool.qsize() == MAXSIZE - 2

    def test_release_conn_parameter(self):
        MAXSIZE = 5
        with HTTPConnectionPool(self.host, self.port, maxsize=MAXSIZE) as pool:
            assert pool.pool.qsize() == MAXSIZE

            # Make request without releasing connection
            pool.request(""GET"", ""/"", release_conn=False, preload_content=False)
            assert pool.pool.qsize() == MAXSIZE - 1

    def test_dns_error(self):
        with HTTPConnectionPool(
            ""thishostdoesnotexist.invalid"", self.port, timeout=0.001
        ) as pool:
            with pytest.raises(MaxRetryError):
                pool.request(""GET"", ""/test"", retries=2)

    @pytest.mark.parametrize(""char"", ["" "", ""\r"", ""\n"", ""\x00""])
    def test_invalid_method_not_allowed(self, char):
        with pytest.raises(ValueError):
            with HTTPConnectionPool(self.host, self.port) as pool:
                pool.request(""GET"" + char, ""/"")

    def test_percent_encode_invalid_target_chars(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/echo_params?q=\r&k=\n \n"")
            assert r.data == b""[('k', '\\n \\n'), ('q', '\\r')]""

    def test_source_address(self):
        for addr, is_ipv6 in VALID_SOURCE_ADDRESSES:
            if is_ipv6 and not HAS_IPV6_AND_DNS:
                warnings.warn(""No IPv6 support: skipping."", NoIPv6Warning)
                continue
            with HTTPConnectionPool(
                self.host, self.port, source_address=addr, retries=False
            ) as pool:
                r = pool.request(""GET"", ""/source_address"")
                assert r.data == b(addr[0])

    def test_source_address_error(self):
        for addr in INVALID_SOURCE_ADDRESSES:
            with HTTPConnectionPool(
                self.host, self.port, source_address=addr, retries=False
            ) as pool:
                with pytest.raises(NewConnectionError):
                    pool.request(""GET"", ""/source_address?{0}"".format(addr))

    def test_stream_keepalive(self):
        x = 2

        with HTTPConnectionPool(self.host, self.port) as pool:
            for _ in range(x):
                response = pool.request(
                    ""GET"",
                    ""/chunked"",
                    headers={""Connection"": ""keep-alive""},
                    preload_content=False,
                    retries=False,
                )
                for chunk in response.stream():
                    assert chunk == b""123""

            assert pool.num_connections == 1
            assert pool.num_requests == x

    def test_read_chunked_short_circuit(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            response = pool.request(""GET"", ""/chunked"", preload_content=False)
            response.read()
            with pytest.raises(StopIteration):
                next(response.read_chunked())

    def test_read_chunked_on_closed_response(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            response = pool.request(""GET"", ""/chunked"", preload_content=False)
            response.close()
            with pytest.raises(StopIteration):
                next(response.read_chunked())

    def test_chunked_gzip(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            response = pool.request(
                ""GET"", ""/chunked_gzip"", preload_content=False, decode_content=True
            )

            assert b""123"" * 4 == response.read()

    def test_cleanup_on_connection_error(self):
        """"""
        Test that connections are recycled to the pool on
        connection errors where no http response is received.
        """"""
        poolsize = 3
        with HTTPConnectionPool(
            self.host, self.port, maxsize=poolsize, block=True
        ) as http:
            assert http.pool.qsize() == poolsize

            # force a connection error by supplying a non-existent
            # url. We won't get a response for this  and so the
            # conn won't be implicitly returned to the pool.
            with pytest.raises(MaxRetryError):
                http.request(
                    ""GET"",
                    ""/redirect"",
                    fields={""target"": ""/""},
                    release_conn=False,
                    retries=0,
                )

            r = http.request(
                ""GET"",
                ""/redirect"",
                fields={""target"": ""/""},
                release_conn=False,
                retries=1,
            )
            r.release_conn()

            # the pool should still contain poolsize elements
            assert http.pool.qsize() == http.pool.maxsize

    def test_mixed_case_hostname(self):
        with HTTPConnectionPool(""LoCaLhOsT"", self.port) as pool:
            response = pool.request(""GET"", ""http://LoCaLhOsT:%d/"" % self.port)
            assert response.status == 200

    def test_preserves_path_dot_segments(self):
        """"""ConnectionPool preserves dot segments in the URI""""""
        with HTTPConnectionPool(self.host, self.port) as pool:
            response = pool.request(""GET"", ""/echo_uri/seg0/../seg2"")
            assert response.data == b""/echo_uri/seg0/../seg2""

    def test_default_user_agent_header(self):
        """"""ConnectionPool has a default user agent""""""
        default_ua = _get_default_user_agent()
        custom_ua = ""I'm not a web scraper, what are you talking about?""
        custom_ua2 = ""Yet Another User Agent""
        with HTTPConnectionPool(self.host, self.port) as pool:
            # Use default user agent if no user agent was specified.
            r = pool.request(""GET"", ""/headers"")
            request_headers = json.loads(r.data.decode(""utf8""))
            assert request_headers.get(""User-Agent"") == _get_default_user_agent()

            # Prefer the request user agent over the default.
            headers = {""UsEr-AGENt"": custom_ua}
            r = pool.request(""GET"", ""/headers"", headers=headers)
            request_headers = json.loads(r.data.decode(""utf8""))
            assert request_headers.get(""User-Agent"") == custom_ua

            # Do not modify pool headers when using the default user agent.
            pool_headers = {""foo"": ""bar""}
            pool.headers = pool_headers
            r = pool.request(""GET"", ""/headers"")
            request_headers = json.loads(r.data.decode(""utf8""))
            assert request_headers.get(""User-Agent"") == default_ua
            assert ""User-Agent"" not in pool_headers

            pool.headers.update({""User-Agent"": custom_ua2})
            r = pool.request(""GET"", ""/headers"")
            request_headers = json.loads(r.data.decode(""utf8""))
            assert request_headers.get(""User-Agent"") == custom_ua2

    @pytest.mark.parametrize(
        ""headers"",
        [
            None,
            {},
            {""User-Agent"": ""key""},
            {""user-agent"": ""key""},
            {b""uSeR-AgEnT"": b""key""},
            {b""user-agent"": ""key""},
        ],
    )
    @pytest.mark.parametrize(""chunked"", [True, False])
    def test_user_agent_header_not_sent_twice(self, headers, chunked):
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/headers"", headers=headers, chunked=chunked)
            request_headers = json.loads(r.data.decode(""utf8""))

            if not headers:
                assert request_headers[""User-Agent""].startswith(""python-urllib3/"")
                assert ""key"" not in request_headers[""User-Agent""]
            else:
                assert request_headers[""User-Agent""] == ""key""

    def test_no_user_agent_header(self):
        """"""ConnectionPool can suppress sending a user agent header""""""
        custom_ua = ""I'm not a web scraper, what are you talking about?""
        with HTTPConnectionPool(self.host, self.port) as pool:
            # Suppress user agent in the request headers.
            no_ua_headers = {""User-Agent"": SKIP_HEADER}
            r = pool.request(""GET"", ""/headers"", headers=no_ua_headers)
            request_headers = json.loads(r.data.decode(""utf8""))
            assert ""User-Agent"" not in request_headers
            assert no_ua_headers[""User-Agent""] == SKIP_HEADER

            # Suppress user agent in the pool headers.
            pool.headers = no_ua_headers
            r = pool.request(""GET"", ""/headers"")
            request_headers = json.loads(r.data.decode(""utf8""))
            assert ""User-Agent"" not in request_headers
            assert no_ua_headers[""User-Agent""] == SKIP_HEADER

            # Request headers override pool headers.
            pool_headers = {""User-Agent"": custom_ua}
            pool.headers = pool_headers
            r = pool.request(""GET"", ""/headers"", headers=no_ua_headers)
            request_headers = json.loads(r.data.decode(""utf8""))
            assert ""User-Agent"" not in request_headers
            assert no_ua_headers[""User-Agent""] == SKIP_HEADER
            assert pool_headers.get(""User-Agent"") == custom_ua

    @pytest.mark.parametrize(
        ""accept_encoding"",
        [
            ""Accept-Encoding"",
            ""accept-encoding"",
            b""Accept-Encoding"",
            b""accept-encoding"",
            None,
        ],
    )
    @pytest.mark.parametrize(""host"", [""Host"", ""host"", b""Host"", b""host"", None])
    @pytest.mark.parametrize(
        ""user_agent"", [""User-Agent"", ""user-agent"", b""User-Agent"", b""user-agent"", None]
    )
    @pytest.mark.parametrize(""chunked"", [True, False])
    def test_skip_header(self, accept_encoding, host, user_agent, chunked):
        headers = {}

        if accept_encoding is not None:
            headers[accept_encoding] = SKIP_HEADER
        if host is not None:
            headers[host] = SKIP_HEADER
        if user_agent is not None:
            headers[user_agent] = SKIP_HEADER

        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/headers"", headers=headers, chunked=chunked)
        request_headers = json.loads(r.data.decode(""utf8""))

        if accept_encoding is None:
            assert ""Accept-Encoding"" in request_headers
        else:
            assert accept_encoding not in request_headers
        if host is None:
            assert ""Host"" in request_headers
        else:
            assert host not in request_headers
        if user_agent is None:
            assert ""User-Agent"" in request_headers
        else:
            assert user_agent not in request_headers

    @pytest.mark.parametrize(""header"", [""Content-Length"", ""content-length""])
    @pytest.mark.parametrize(""chunked"", [True, False])
    def test_skip_header_non_supported(self, header, chunked):
        with HTTPConnectionPool(self.host, self.port) as pool:
            with pytest.raises(ValueError) as e:
                pool.request(
                    ""GET"", ""/headers"", headers={header: SKIP_HEADER}, chunked=chunked
                )
            assert (
                str(e.value)
                == ""urllib3.util.SKIP_HEADER only supports 'Accept-Encoding', 'Host', 'User-Agent'""
            )

            # Ensure that the error message stays up to date with 'SKIP_HEADER_SUPPORTED_HEADERS'
            assert all(
                (""'"" + header.title() + ""'"") in str(e.value)
                for header in SKIPPABLE_HEADERS
            )

    @pytest.mark.parametrize(""chunked"", [True, False])
    @pytest.mark.parametrize(""pool_request"", [True, False])
    @pytest.mark.parametrize(""header_type"", [dict, HTTPHeaderDict])
    def test_headers_not_modified_by_request(self, chunked, pool_request, header_type):
        # Test that the .request*() methods of ConnectionPool and HTTPConnection
        # don't modify the given 'headers' structure, instead they should
        # make their own internal copies at request time.
        headers = header_type()
        headers[""key""] = ""val""

        with HTTPConnectionPool(self.host, self.port) as pool:
            pool.headers = headers
            if pool_request:
                pool.request(""GET"", ""/headers"", chunked=chunked)
            else:
                conn = pool._get_conn()
                if chunked:
                    conn.request_chunked(""GET"", ""/headers"")
                else:
                    conn.request(""GET"", ""/headers"")

            assert pool.headers == {""key"": ""val""}
            assert isinstance(pool.headers, header_type)

        with HTTPConnectionPool(self.host, self.port) as pool:
            if pool_request:
                pool.request(""GET"", ""/headers"", headers=headers, chunked=chunked)
            else:
                conn = pool._get_conn()
                if chunked:
                    conn.request_chunked(""GET"", ""/headers"", headers=headers)
                else:
                    conn.request(""GET"", ""/headers"", headers=headers)

            assert headers == {""key"": ""val""}

    def test_bytes_header(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            headers = {""User-Agent"": b""test header""}
            r = pool.request(""GET"", ""/headers"", headers=headers)
            request_headers = json.loads(r.data.decode(""utf8""))
            assert ""User-Agent"" in request_headers
            assert request_headers[""User-Agent""] == ""test header""

    @pytest.mark.parametrize(
        ""user_agent"", [u""Schnefeld/1.18.0"", u""Schnefeld/1.18.0"".encode(""iso-8859-1"")]
    )
    def test_user_agent_non_ascii_user_agent(self, user_agent):
        if six.PY2 and not isinstance(user_agent, str):
            pytest.skip(
                ""Python 2 raises UnicodeEncodeError when passed a unicode header""
            )

        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            r = pool.urlopen(
                ""GET"",
                ""/headers"",
                headers={""User-Agent"": user_agent},
            )
            request_headers = json.loads(r.data.decode(""utf8""))
            assert ""User-Agent"" in request_headers
            assert request_headers[""User-Agent""] == u""Schnefeld/1.18.0""

    @onlyPy2
    def test_user_agent_non_ascii_fails_on_python_2(self):
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            with pytest.raises(UnicodeEncodeError) as e:
                pool.urlopen(
                    ""GET"",
                    ""/headers"",
                    headers={""User-Agent"": u""Schnefeld/1.18.0""},
                )
            assert str(e.value) == (
                ""'ascii' codec can't encode character u'\\xf6' in ""
                ""position 3: ordinal not in range(128)""
            )


class TestRetry(HTTPDummyServerTestCase):
    def test_max_retry(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            with pytest.raises(MaxRetryError):
                pool.request(""GET"", ""/redirect"", fields={""target"": ""/""}, retries=0)

    def test_disabled_retry(self):
        """"""Disabled retries should disable redirect handling.""""""
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/redirect"", fields={""target"": ""/""}, retries=False)
            assert r.status == 303

            r = pool.request(
                ""GET"",
                ""/redirect"",
                fields={""target"": ""/""},
                retries=Retry(redirect=False),
            )
            assert r.status == 303

        with HTTPConnectionPool(
            ""thishostdoesnotexist.invalid"", self.port, timeout=0.001
        ) as pool:
            with pytest.raises(NewConnectionError):
                pool.request(""GET"", ""/test"", retries=False)

    def test_read_retries(self):
        """"""Should retry for status codes in the whitelist""""""
        with HTTPConnectionPool(self.host, self.port) as pool:
            retry = Retry(read=1, status_forcelist=[418])
            resp = pool.request(
                ""GET"",
                ""/successful_retry"",
                headers={""test-name"": ""test_read_retries""},
                retries=retry,
            )
            assert resp.status == 200

    def test_read_total_retries(self):
        """"""HTTP response w/ status code in the whitelist should be retried""""""
        with HTTPConnectionPool(self.host, self.port) as pool:
            headers = {""test-name"": ""test_read_total_retries""}
            retry = Retry(total=1, status_forcelist=[418])
            resp = pool.request(
                ""GET"", ""/successful_retry"", headers=headers, retries=retry
            )
            assert resp.status == 200

    def test_retries_wrong_whitelist(self):
        """"""HTTP response w/ status code not in whitelist shouldn't be retried""""""
        with HTTPConnectionPool(self.host, self.port) as pool:
            retry = Retry(total=1, status_forcelist=[202])
            resp = pool.request(
                ""GET"",
                ""/successful_retry"",
                headers={""test-name"": ""test_wrong_whitelist""},
                retries=retry,
            )
            assert resp.status == 418

    def test_default_method_whitelist_retried(self):
        """"""urllib3 should retry methods in the default method whitelist""""""
        with HTTPConnectionPool(self.host, self.port) as pool:
            retry = Retry(total=1, status_forcelist=[418])
            resp = pool.request(
                ""OPTIONS"",
                ""/successful_retry"",
                headers={""test-name"": ""test_default_whitelist""},
                retries=retry,
            )
            assert resp.status == 200

    def test_retries_wrong_method_list(self):
        """"""Method not in our whitelist should not be retried, even if code matches""""""
        with HTTPConnectionPool(self.host, self.port) as pool:
            headers = {""test-name"": ""test_wrong_method_whitelist""}
            retry = Retry(total=1, status_forcelist=[418], method_whitelist=[""POST""])
            resp = pool.request(
                ""GET"", ""/successful_retry"", headers=headers, retries=retry
            )
            assert resp.status == 418

    def test_read_retries_unsuccessful(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            headers = {""test-name"": ""test_read_retries_unsuccessful""}
            resp = pool.request(""GET"", ""/successful_retry"", headers=headers, retries=1)
            assert resp.status == 418

    def test_retry_reuse_safe(self):
        """"""It should be possible to reuse a Retry object across requests""""""
        with HTTPConnectionPool(self.host, self.port) as pool:
            headers = {""test-name"": ""test_retry_safe""}
            retry = Retry(total=1, status_forcelist=[418])
            resp = pool.request(
                ""GET"", ""/successful_retry"", headers=headers, retries=retry
            )
            assert resp.status == 200

        with HTTPConnectionPool(self.host, self.port) as pool:
            resp = pool.request(
                ""GET"", ""/successful_retry"", headers=headers, retries=retry
            )
            assert resp.status == 200

    def test_retry_return_in_response(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            headers = {""test-name"": ""test_retry_return_in_response""}
            retry = Retry(total=2, status_forcelist=[418])
            resp = pool.request(
                ""GET"", ""/successful_retry"", headers=headers, retries=retry
            )
            assert resp.status == 200
            assert resp.retries.total == 1
            assert resp.retries.history == (
                RequestHistory(""GET"", ""/successful_retry"", None, 418, None),
            )

    def test_retry_redirect_history(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            resp = pool.request(""GET"", ""/redirect"", fields={""target"": ""/""})
            assert resp.status == 200
            assert resp.retries.history == (
                RequestHistory(""GET"", ""/redirect?target=%2F"", None, 303, ""/""),
            )

    def test_multi_redirect_history(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(
                ""GET"",
                ""/multi_redirect"",
                fields={""redirect_codes"": ""303,302,200""},
                redirect=False,
            )
            assert r.status == 303
            assert r.retries.history == tuple()

        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(
                ""GET"",
                ""/multi_redirect"",
                retries=10,
                fields={""redirect_codes"": ""303,302,301,307,302,200""},
            )
            assert r.status == 200
            assert r.data == b""Done redirecting""

            expected = [
                (303, ""/multi_redirect?redirect_codes=302,301,307,302,200""),
                (302, ""/multi_redirect?redirect_codes=301,307,302,200""),
                (301, ""/multi_redirect?redirect_codes=307,302,200""),
                (307, ""/multi_redirect?redirect_codes=302,200""),
                (302, ""/multi_redirect?redirect_codes=200""),
            ]
            actual = [
                (history.status, history.redirect_location)
                for history in r.retries.history
            ]
            assert actual == expected


class TestRetryAfter(HTTPDummyServerTestCase):
    def test_retry_after(self):
        # Request twice in a second to get a 429 response.
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(
                ""GET"",
                ""/retry_after"",
                fields={""status"": ""429 Too Many Requests""},
                retries=False,
            )
            r = pool.request(
                ""GET"",
                ""/retry_after"",
                fields={""status"": ""429 Too Many Requests""},
                retries=False,
            )
            assert r.status == 429

            r = pool.request(
                ""GET"",
                ""/retry_after"",
                fields={""status"": ""429 Too Many Requests""},
                retries=True,
            )
            assert r.status == 200

            # Request twice in a second to get a 503 response.
            r = pool.request(
                ""GET"",
                ""/retry_after"",
                fields={""status"": ""503 Service Unavailable""},
                retries=False,
            )
            r = pool.request(
                ""GET"",
                ""/retry_after"",
                fields={""status"": ""503 Service Unavailable""},
                retries=False,
            )
            assert r.status == 503

            r = pool.request(
                ""GET"",
                ""/retry_after"",
                fields={""status"": ""503 Service Unavailable""},
                retries=True,
            )
            assert r.status == 200

            # Ignore Retry-After header on status which is not defined in
            # Retry.RETRY_AFTER_STATUS_CODES.
            r = pool.request(
                ""GET"",
                ""/retry_after"",
                fields={""status"": ""418 I'm a teapot""},
                retries=True,
            )
            assert r.status == 418

    def test_redirect_after(self):
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/redirect_after"", retries=False)
            assert r.status == 303

            t = time.time()
            r = pool.request(""GET"", ""/redirect_after"")
            assert r.status == 200
            delta = time.time() - t
            assert delta >= 1

            t = time.time()
            timestamp = t + 2
            r = pool.request(""GET"", ""/redirect_after?date="" + str(timestamp))
            assert r.status == 200
            delta = time.time() - t
            assert delta >= 1

            # Retry-After is past
            t = time.time()
            timestamp = t - 1
            r = pool.request(""GET"", ""/redirect_after?date="" + str(timestamp))
            delta = time.time() - t
            assert r.status == 200
            assert delta < 1


class TestFileBodiesOnRetryOrRedirect(HTTPDummyServerTestCase):
    def test_retries_put_filehandle(self):
        """"""HTTP PUT retry with a file-like object should not timeout""""""
        with HTTPConnectionPool(self.host, self.port, timeout=0.1) as pool:
            retry = Retry(total=3, status_forcelist=[418])
            # httplib reads in 8k chunks; use a larger content length
            content_length = 65535
            data = b""A"" * content_length
            uploaded_file = io.BytesIO(data)
            headers = {
                ""test-name"": ""test_retries_put_filehandle"",
                ""Content-Length"": str(content_length),
            }
            resp = pool.urlopen(
                ""PUT"",
                ""/successful_retry"",
                headers=headers,
                retries=retry,
                body=uploaded_file,
                assert_same_host=False,
                redirect=False,
            )
            assert resp.status == 200

    def test_redirect_put_file(self):
        """"""PUT with file object should work with a redirection response""""""
        with HTTPConnectionPool(self.host, self.port, timeout=0.1) as pool:
            retry = Retry(total=3, status_forcelist=[418])
            # httplib reads in 8k chunks; use a larger content length
            content_length = 65535
            data = b""A"" * content_length
            uploaded_file = io.BytesIO(data)
            headers = {
                ""test-name"": ""test_redirect_put_file"",
                ""Content-Length"": str(content_length),
            }
            url = ""/redirect?target=/echo&status=307""
            resp = pool.urlopen(
                ""PUT"",
                url,
                headers=headers,
                retries=retry,
                body=uploaded_file,
                assert_same_host=False,
                redirect=True,
            )
            assert resp.status == 200
            assert resp.data == data

    def test_redirect_with_failed_tell(self):
        """"""Abort request if failed to get a position from tell()""""""

        class BadTellObject(io.BytesIO):
            def tell(self):
                raise IOError

        body = BadTellObject(b""the data"")
        url = ""/redirect?target=/successful_retry""
        # httplib uses fileno if Content-Length isn't supplied,
        # which is unsupported by BytesIO.
        headers = {""Content-Length"": ""8""}
        with HTTPConnectionPool(self.host, self.port, timeout=0.1) as pool:
            with pytest.raises(UnrewindableBodyError) as e:
                pool.urlopen(""PUT"", url, headers=headers, body=body)
            assert ""Unable to record file position for"" in str(e.value)


class TestRetryPoolSize(HTTPDummyServerTestCase):
    def test_pool_size_retry(self):
        retries = Retry(total=1, raise_on_status=False, status_forcelist=[404])
        with HTTPConnectionPool(
            self.host, self.port, maxsize=10, retries=retries, block=True
        ) as pool:
            pool.urlopen(""GET"", ""/not_found"", preload_content=False)
            assert pool.num_connections == 1


class TestRedirectPoolSize(HTTPDummyServerTestCase):
    def test_pool_size_redirect(self):
        retries = Retry(
            total=1, raise_on_status=False, status_forcelist=[404], redirect=True
        )
        with HTTPConnectionPool(
            self.host, self.port, maxsize=10, retries=retries, block=True
        ) as pool:
            pool.urlopen(""GET"", ""/redirect"", preload_content=False)
            assert pool.num_connections == 1",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED," VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR .. VAR VAR, VAR, VAR VAR ..VAR VAR VAR VAR = VAR.VAR.VAR VAR = VAR.VAR(""VAR.VAR"") VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR(VAR.VAR)) VAR VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=2) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR(VAR) VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"", VAR=VAR) VAR.VAR()   VAR(VAR) VAR.VAR()  VAR.VAR(""VAR"", ""/"", VAR=VAR) VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR=VAR, VAR=1) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR = VAR.VAR() VAR.VAR(VAR) VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"") VAR VAR.VAR: VAR VAR.VAR(VAR.VAR): VAR.VAR.VAR(1024) VAR: VAR.VAR(VAR) VAR.VAR() VAR VAR(VAR):  VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=3)  VAR = VAR(VAR=VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR(VAR) VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"") VAR.VAR()   VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR(VAR) VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"", VAR=VAR) VAR = VAR.VAR() - VAR VAR = ""VAR VAR VAR-VAR VAR VAR VAR VAR-VAR VAR"" VAR VAR >= VAR, VAR VAR.VAR()   VAR(VAR) VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"", VAR=VAR) VAR.VAR()  VAR VAR(VAR): VAR = ""/"" VAR, VAR = VAR, 80 VAR = VAR(VAR=VAR)  VAR VAR(VAR, VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR(VAR, ""VAR"", VAR)  VAR = VAR(VAR=0) VAR VAR.VAR(VAR): VAR.VAR(""VAR"", VAR, VAR=VAR)  VAR = VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR(VAR, ""VAR"", VAR, VAR=VAR) VAR.VAR(VAR) VAR VAR.VAR(VAR): VAR.VAR(""VAR"", VAR, VAR=VAR) VAR VAR(VAR): VAR, VAR = VAR, 80 VAR = VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR() VAR: VAR VAR.VAR(VAR): VAR.VAR(VAR, ""VAR"", ""/"") VAR: VAR.VAR() VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR VAR(VAR, VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR() VAR: VAR VAR.VAR(VAR): VAR.VAR(VAR, ""VAR"", ""/"") VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=2) VAR(VAR)  VAR = VAR(VAR=3, VAR=VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"") VAR.VAR() VAR(VAR) VAR.VAR()  VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"") VAR VAR(VAR): VAR.VAR(VAR=VAR(), VAR=0)  VAR = VAR(VAR=VAR, VAR=VAR) VAR VAR( VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""VAR""}) VAR VAR.VAR == 200, VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""VAR""}) VAR VAR.VAR == 200, VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR?VAR=VAR"") VAR VAR.VAR == 200, VAR.VAR VAR VAR(VAR):  VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""VAR""}) VAR VAR.VAR == 400, VAR.VAR VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""VAR""}) VAR VAR.VAR == 400, VAR.VAR VAR VAR(VAR): VAR = ""VAR'VAR VAR VAR VAR VAR-VAR, VAR VAR VAR"" VAR = { ""VAR"": ""VAR"", ""VAR"": ""VAR.VAR"", ""VAR"": VAR(VAR), ""VAR"": (""VAR.VAR"", VAR), } VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR.VAR == 200, VAR.VAR VAR VAR(VAR): VAR = [(""VAR"", ""VAR""), (""VAR"", ""VAR"")] VAR VAR(VAR.VAR, VAR.VAR) VAR VAR:  VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR.VAR == VAR""VAR=VAR&VAR=VAR""  VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR.VAR.VAR(VAR'VAR=""VAR""') == 2 VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR""VAR"" VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR.VAR == VAR VAR = [(""VAR"", ""VAR"")] VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/VAR"", VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = VAR(""VAR"") VAR = VAR(""\VAR\VAR\VAR.VAR"") VAR = VAR(""\VAR\VAR\VAR"").VAR(""VAR"") VAR = VAR(VAR) VAR = { VAR(""VAR""): VAR, VAR(""VAR""): VAR, VAR(""VAR""): VAR, VAR: (VAR, VAR), } VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR.VAR == 200, VAR.VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR""""""   VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR() VAR: VAR.VAR(VAR, ""VAR"", ""/"") VAR = VAR.VAR.VAR( VAR.VAR, VAR.VAR ) VAR VAR VAR: VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR.""""""   VAR VAR( VAR.VAR, VAR.VAR, VAR=[(VAR.VAR, VAR.VAR, 1)], ) VAR VAR: VAR = VAR.VAR().VAR()  VAR: VAR = ( VAR.VAR(VAR.VAR, VAR.VAR) > 0 ) VAR VAR VAR: VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR.""""""   VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR().VAR() VAR: VAR = VAR.VAR(VAR.VAR, VAR.VAR) == 0 VAR VAR VAR: VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR.""""""   VAR VAR(VAR.VAR, VAR.VAR) VAR VAR:  VAR = VAR.VAR() VAR:  VAR.VAR += [ (VAR.VAR, VAR.VAR, 1) ] VAR = VAR.VAR() VAR = ( VAR.VAR(VAR.VAR, VAR.VAR) > 0 ) VAR = ( VAR.VAR(VAR.VAR, VAR.VAR) > 0 ) VAR VAR VAR VAR VAR: VAR.VAR() VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR, VAR VAR"""""" VAR = VAR() VAR VAR(VAR.VAR, VAR) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=VAR(VAR=3)) VAR VAR(VAR.VAR.VAR) == VAR VAR VAR(VAR): VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"")  VAR.VAR(""VAR"", ""/"") VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR:  VAR.VAR(""VAR"", ""/"") VAR = VAR(VAR=VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"") VAR VAR(VAR):  VAR = VAR(VAR=VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR() VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR.VAR(VAR=VAR) VAR.VAR(VAR, ""VAR"", ""/"") VAR.VAR.VAR() VAR: VAR.VAR()  VAR = VAR(VAR=VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR() VAR: VAR.VAR = VAR.VAR(VAR=VAR) VAR.VAR(VAR, ""VAR"", ""/"") VAR VAR VAR.VAR.VAR VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""/""}, VAR=VAR) VAR VAR.VAR == 303 VAR = VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""/""}) VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR VAR!"" VAR VAR(VAR): VAR VAR(""VAR.VAR"", VAR.VAR) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=5) VAR VAR(VAR.VAR.VAR) == VAR VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=1) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR?VAR=0"") VAR = VAR.VAR(""VAR"", ""/VAR?VAR=0"") VAR VAR.VAR == 200 VAR VAR.VAR == 1 VAR VAR.VAR == 2 VAR VAR(VAR): VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=1, VAR=2 ) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/VAR?VAR=1"", VAR=0, VAR={""VAR"": ""VAR""} ) VAR VAR.VAR == 1      VAR = VAR.VAR.VAR() VAR VAR.VAR VAR VAR VAR.VAR(VAR)  VAR = VAR.VAR( ""VAR"", ""/VAR?VAR=0"", VAR=0, VAR={""VAR"": ""VAR-VAR""}, )   VAR = VAR.VAR.VAR() VAR VAR.VAR VAR VAR VAR VAR.VAR(VAR)   VAR = VAR.VAR( ""VAR"", ""/VAR?VAR=1"", VAR=0, VAR={""VAR"": ""VAR""} ) VAR VAR.VAR == 200 VAR = VAR.VAR.VAR() VAR VAR.VAR VAR VAR VAR.VAR(VAR)  VAR = VAR.VAR(""VAR"", ""/VAR?VAR=0"") VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = {""VAR"": ""VAR"", ""VAR"": ""VAR""} VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR, VAR=VAR) VAR VAR.VAR.VAR(""VAR-8"") == VAR(VAR) VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = {""VAR"": ""VAR"", ""VAR"": ""VAR""} VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR, VAR=VAR) VAR = VAR.VAR.VAR(VAR""\VAR\VAR"") VAR = VAR(VAR)[0] VAR = VAR.VAR(VAR""\VAR\VAR"")   """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR, VAR VAR VAR(VAR): VAR VAR.VAR(VAR""--""): VAR VAR VAR[VAR] == VAR[VAR] VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = {""VAR"": ""VAR""} VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=VAR, VAR=VAR, VAR=""VAR"", VAR=VAR, ) VAR = [VAR VAR VAR VAR VAR] VAR VAR == [ VAR""--VAR\VAR\VAR"", VAR'VAR-VAR: VAR-VAR; VAR=""VAR""\VAR\VAR', VAR""\VAR\VAR"", VAR""VAR\VAR\VAR"", VAR""--VAR--\VAR\VAR"", ] VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR-VAR"": ""VAR""} ) VAR VAR.VAR.VAR(""VAR-VAR"") == ""VAR"" VAR VAR.VAR == VAR""VAR, VAR!"" VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR-VAR"": ""VAR""} ) VAR VAR.VAR.VAR(""VAR-VAR"") == ""VAR"" VAR VAR.VAR == VAR""VAR, VAR!"" VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR-VAR"": ""VAR-VAR""}, ) VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR-VAR"": ""VAR-VAR""}, ) VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR, VAR=1) VAR VAR: VAR.VAR(""VAR"", ""/"") VAR.VAR(""VAR"", ""/"") VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 1 VAR VAR.VAR == 3 VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR, VAR=16) VAR VAR: VAR.VAR(""VAR"", ""/"") VAR.VAR(""VAR"", ""/"") VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 1 VAR VAR.VAR == 3 VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR, VAR=1) VAR VAR: VAR = {""VAR"": ""VAR""} VAR = VAR(VAR).VAR(""VAR-8"") VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR, VAR=VAR) VAR VAR.VAR(5) == VAR[:5] VAR VAR.VAR() == VAR[5:] VAR VAR(VAR):   VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=1, VAR=2 ) VAR VAR: VAR = 1024 * 2 VAR = 512 VAR = ""VAR"" VAR = {""VAR"": ""VAR"" * VAR} VAR = VAR(VAR, VAR=VAR)[0] VAR = {""VAR"": ""VAR"" * VAR} VAR = VAR(VAR, VAR=VAR)[0] VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=VAR, VAR=VAR, VAR=VAR, ) VAR VAR.VAR(VAR) == VAR[:VAR] VAR: VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=VAR, VAR=VAR, VAR=VAR, VAR=0.001, )   VAR VAR.VAR(VAR) == VAR[:VAR] VAR VAR.VAR() == VAR[VAR:] VAR VAR.VAR() == VAR[VAR:] VAR VAR.VAR == 2 VAR VAR: VAR VAR.VAR() == VAR[VAR:] VAR VAR.VAR == 1 VAR VAR.VAR == 1 VAR VAR(VAR): VAR = 5  VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR VAR.VAR == 0 VAR VAR.VAR.VAR() == VAR  VAR.VAR.VAR() VAR VAR.VAR.VAR() == VAR - 1  VAR.VAR(""VAR"", ""/"") VAR VAR.VAR.VAR() == VAR - 1  VAR.VAR(""VAR"", ""/"", VAR=VAR) VAR VAR.VAR.VAR() == VAR - 2 VAR.VAR(""VAR"", ""/"") VAR VAR.VAR.VAR() == VAR - 2  VAR.VAR(""VAR"", ""/"").VAR VAR VAR.VAR.VAR() == VAR - 2 VAR.VAR(""VAR"", ""/"") VAR VAR.VAR.VAR() == VAR - 2 VAR VAR(VAR): VAR = 5 VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR VAR.VAR.VAR() == VAR  VAR.VAR(""VAR"", ""/"", VAR=VAR, VAR=VAR) VAR VAR.VAR.VAR() == VAR - 1 VAR VAR(VAR): VAR VAR( ""VAR.VAR"", VAR.VAR, VAR=0.001 ) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/VAR"", VAR=2) @VAR.VAR.VAR(""VAR"", ["" "", ""\VAR"", ""\VAR"", ""\VAR""]) VAR VAR(VAR, VAR): VAR VAR.VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR(""VAR"" + VAR, ""/"") VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR?VAR=\VAR&VAR=\VAR \VAR"") VAR VAR.VAR == VAR""[('VAR', '\\VAR \\VAR'), ('VAR', '\\VAR')]"" VAR VAR(VAR): VAR VAR, VAR VAR VAR: VAR VAR VAR VAR VAR: VAR.VAR(""VAR VAR VAR: VAR."", VAR) VAR VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"") VAR VAR.VAR == VAR(VAR[0]) VAR VAR(VAR): VAR VAR VAR VAR: VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/VAR?{0}"".VAR(VAR)) VAR VAR(VAR): VAR = 2 VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR VAR VAR VAR(VAR): VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""VAR-VAR""}, VAR=VAR, VAR=VAR, ) VAR VAR VAR VAR.VAR(): VAR VAR == VAR""123"" VAR VAR.VAR == 1 VAR VAR.VAR == VAR VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=VAR, VAR=VAR ) VAR VAR""123"" * 4 == VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = 3 VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR VAR.VAR.VAR() == VAR    VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""/""}, VAR=VAR, VAR=0, ) VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""/""}, VAR=VAR, VAR=1, ) VAR.VAR()  VAR VAR.VAR.VAR() == VAR.VAR.VAR VAR VAR(VAR): VAR VAR(""VAR"", VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR"""""" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR/VAR/../VAR"") VAR VAR.VAR == VAR""/VAR/VAR/../VAR"" VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR"""""" VAR = VAR() VAR = ""VAR'VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR?"" VAR = ""VAR VAR VAR VAR"" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR:  VAR = VAR.VAR(""VAR"", ""/VAR"") VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR VAR.VAR(""VAR-VAR"") == VAR()  VAR = {""VAR-VAR"": VAR} VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR VAR.VAR(""VAR-VAR"") == VAR  VAR = {""VAR"": ""VAR""} VAR.VAR = VAR VAR = VAR.VAR(""VAR"", ""/VAR"") VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR VAR.VAR(""VAR-VAR"") == VAR VAR ""VAR-VAR"" VAR VAR VAR VAR.VAR.VAR({""VAR-VAR"": VAR}) VAR = VAR.VAR(""VAR"", ""/VAR"") VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR VAR.VAR(""VAR-VAR"") == VAR @VAR.VAR.VAR( ""VAR"", [ VAR, {}, {""VAR-VAR"": ""VAR""}, {""VAR-VAR"": ""VAR""}, {VAR""VAR-VAR"": VAR""VAR""}, {VAR""VAR-VAR"": ""VAR""}, ], ) @VAR.VAR.VAR(""VAR"", [VAR, VAR]) VAR VAR(VAR, VAR, VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR, VAR=VAR) VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR VAR VAR: VAR VAR[""VAR-VAR""].VAR(""VAR-VAR/"") VAR ""VAR"" VAR VAR VAR[""VAR-VAR""] VAR: VAR VAR[""VAR-VAR""] == ""VAR"" VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR = ""VAR'VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR?"" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR:  VAR = {""VAR-VAR"": VAR} VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR ""VAR-VAR"" VAR VAR VAR VAR VAR[""VAR-VAR""] == VAR  VAR.VAR = VAR VAR = VAR.VAR(""VAR"", ""/VAR"") VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR ""VAR-VAR"" VAR VAR VAR VAR VAR[""VAR-VAR""] == VAR  VAR = {""VAR-VAR"": VAR} VAR.VAR = VAR VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR ""VAR-VAR"" VAR VAR VAR VAR VAR[""VAR-VAR""] == VAR VAR VAR.VAR(""VAR-VAR"") == VAR @VAR.VAR.VAR( ""VAR"", [ ""VAR-VAR"", ""VAR-VAR"", VAR""VAR-VAR"", VAR""VAR-VAR"", VAR, ], ) @VAR.VAR.VAR(""VAR"", [""VAR"", ""VAR"", VAR""VAR"", VAR""VAR"", VAR]) @VAR.VAR.VAR( ""VAR"", [""VAR-VAR"", ""VAR-VAR"", VAR""VAR-VAR"", VAR""VAR-VAR"", VAR] ) @VAR.VAR.VAR(""VAR"", [VAR, VAR]) VAR VAR(VAR, VAR, VAR, VAR, VAR): VAR = {} VAR VAR VAR VAR VAR: VAR[VAR] = VAR VAR VAR VAR VAR VAR: VAR[VAR] = VAR VAR VAR VAR VAR VAR: VAR[VAR] = VAR VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR, VAR=VAR) VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR VAR VAR VAR: VAR ""VAR-VAR"" VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR ""VAR"" VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR ""VAR-VAR"" VAR VAR VAR: VAR VAR VAR VAR VAR @VAR.VAR.VAR(""VAR"", [""VAR-VAR"", ""VAR-VAR""]) @VAR.VAR.VAR(""VAR"", [VAR, VAR]) VAR VAR(VAR, VAR, VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR( ""VAR"", ""/VAR"", VAR={VAR: VAR}, VAR=VAR ) VAR ( VAR(VAR.VAR) == ""VAR.VAR.VAR VAR VAR 'VAR-VAR', 'VAR', 'VAR-VAR'"" )  VAR VAR( (""'"" + VAR.VAR() + ""'"") VAR VAR(VAR.VAR) VAR VAR VAR VAR ) @VAR.VAR.VAR(""VAR"", [VAR, VAR]) @VAR.VAR.VAR(""VAR"", [VAR, VAR]) @VAR.VAR.VAR(""VAR"", [VAR, VAR]) VAR VAR(VAR, VAR, VAR, VAR):    VAR = VAR() VAR[""VAR""] = ""VAR"" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR = VAR VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR: VAR = VAR.VAR() VAR VAR: VAR.VAR(""VAR"", ""/VAR"") VAR: VAR.VAR(""VAR"", ""/VAR"") VAR VAR.VAR == {""VAR"": ""VAR""} VAR VAR(VAR.VAR, VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR=VAR, VAR=VAR) VAR: VAR = VAR.VAR() VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR: VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR == {""VAR"": ""VAR""} VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = {""VAR-VAR"": VAR""VAR VAR""} VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR ""VAR-VAR"" VAR VAR VAR VAR[""VAR-VAR""] == ""VAR VAR"" @VAR.VAR.VAR( ""VAR"", [VAR""Schnefeld/1.18.0"", VAR""Schnefeld/1.18.0"".VAR(""VAR-8859-1"")] ) VAR VAR(VAR, VAR): VAR VAR.VAR VAR VAR VAR(VAR, VAR): VAR.VAR( ""VAR 2 VAR VAR VAR VAR VAR VAR VAR"" ) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR-VAR"": VAR}, ) VAR = VAR.VAR(VAR.VAR.VAR(""VAR"")) VAR ""VAR-VAR"" VAR VAR VAR VAR[""VAR-VAR""] == VAR""Schnefeld/1.18.0"" @VAR VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR-VAR"": VAR""Schnefeld/1.18.0""}, ) VAR VAR(VAR.VAR) == ( ""'VAR' VAR VAR'VAR VAR VAR VAR'\\VAR' VAR "" ""VAR 3: VAR VAR VAR VAR(128)"" ) VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""/""}, VAR=0) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR."""""" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""/""}, VAR=VAR) VAR VAR.VAR == 303 VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""/""}, VAR=VAR(VAR=VAR), ) VAR VAR.VAR == 303 VAR VAR( ""VAR.VAR"", VAR.VAR, VAR=0.001 ) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR-VAR"": ""VAR""}, VAR=VAR, ) VAR VAR.VAR == 200 VAR VAR(VAR): """"""VAR VAR VAR/ VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = {""VAR-VAR"": ""VAR""} VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=VAR, VAR=VAR ) VAR VAR.VAR == 200 VAR VAR(VAR): """"""VAR VAR VAR/ VAR VAR VAR VAR VAR VAR'VAR VAR VAR"""""" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR(VAR=1, VAR=[202]) VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR-VAR"": ""VAR""}, VAR=VAR, ) VAR VAR.VAR == 418 VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR-VAR"": ""VAR""}, VAR=VAR, ) VAR VAR.VAR == 200 VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR"""""" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = {""VAR-VAR"": ""VAR""} VAR = VAR(VAR=1, VAR=[418], VAR=[""VAR""]) VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=VAR, VAR=VAR ) VAR VAR.VAR == 418 VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = {""VAR-VAR"": ""VAR""} VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR, VAR=1) VAR VAR.VAR == 418 VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = {""VAR-VAR"": ""VAR""} VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=VAR, VAR=VAR ) VAR VAR.VAR == 200 VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=VAR, VAR=VAR ) VAR VAR.VAR == 200 VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = {""VAR-VAR"": ""VAR""} VAR = VAR(VAR=2, VAR=[418]) VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=VAR, VAR=VAR ) VAR VAR.VAR == 200 VAR VAR.VAR.VAR == 1 VAR VAR.VAR.VAR == ( VAR(""VAR"", ""/VAR"", VAR, 418, VAR), ) VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""/""}) VAR VAR.VAR == 200 VAR VAR.VAR.VAR == ( VAR(""VAR"", ""/VAR?VAR=%2F"", VAR, 303, ""/""), ) VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""303,302,200""}, VAR=VAR, ) VAR VAR.VAR == 303 VAR VAR.VAR.VAR == VAR() VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=10, VAR={""VAR"": ""303,302,301,307,302,200""}, ) VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR VAR"" VAR = [ (303, ""/VAR?VAR=302,301,307,302,200""), (302, ""/VAR?VAR=301,307,302,200""), (301, ""/VAR?VAR=307,302,200""), (307, ""/VAR?VAR=302,200""), (302, ""/VAR?VAR=200""), ] VAR = [ (VAR.VAR, VAR.VAR) VAR VAR VAR VAR.VAR.VAR ] VAR VAR == VAR VAR VAR(VAR): VAR VAR(VAR):  VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""429 VAR VAR VAR""}, VAR=VAR, ) VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""429 VAR VAR VAR""}, VAR=VAR, ) VAR VAR.VAR == 429 VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""429 VAR VAR VAR""}, VAR=VAR, ) VAR VAR.VAR == 200  VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""503 VAR VAR""}, VAR=VAR, ) VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""503 VAR VAR""}, VAR=VAR, ) VAR VAR.VAR == 503 VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""503 VAR VAR""}, VAR=VAR, ) VAR VAR.VAR == 200   VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR={""VAR"": ""418 VAR'VAR VAR VAR""}, VAR=VAR, ) VAR VAR.VAR == 418 VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR.VAR == 303 VAR = VAR.VAR() VAR = VAR.VAR(""VAR"", ""/VAR"") VAR VAR.VAR == 200 VAR = VAR.VAR() - VAR VAR VAR >= 1 VAR = VAR.VAR() VAR = VAR + 2 VAR = VAR.VAR(""VAR"", ""/VAR?VAR="" + VAR(VAR)) VAR VAR.VAR == 200 VAR = VAR.VAR() - VAR VAR VAR >= 1  VAR = VAR.VAR() VAR = VAR - 1 VAR = VAR.VAR(""VAR"", ""/VAR?VAR="" + VAR(VAR)) VAR = VAR.VAR() - VAR VAR VAR.VAR == 200 VAR VAR < 1 VAR VAR(VAR): VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR"""""" VAR VAR(VAR.VAR, VAR.VAR, VAR=0.1) VAR VAR: VAR = VAR(VAR=3, VAR=[418])  VAR = 65535 VAR = VAR""VAR"" * VAR VAR = VAR.VAR(VAR) VAR = { ""VAR-VAR"": ""VAR"", ""VAR-VAR"": VAR(VAR), } VAR = VAR.VAR( ""VAR"", ""/VAR"", VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, ) VAR VAR.VAR == 200 VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR VAR(VAR.VAR, VAR.VAR, VAR=0.1) VAR VAR: VAR = VAR(VAR=3, VAR=[418])  VAR = 65535 VAR = VAR""VAR"" * VAR VAR = VAR.VAR(VAR) VAR = { ""VAR-VAR"": ""VAR"", ""VAR-VAR"": VAR(VAR), } VAR = ""/VAR?VAR=/VAR&VAR=307"" VAR = VAR.VAR( ""VAR"", VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, ) VAR VAR.VAR == 200 VAR VAR.VAR == VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR()"""""" VAR VAR(VAR.VAR): VAR VAR(VAR): VAR VAR VAR = VAR(VAR""VAR VAR"") VAR = ""/VAR?VAR=/VAR""   VAR = {""VAR-VAR"": ""8""} VAR VAR(VAR.VAR, VAR.VAR, VAR=0.1) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", VAR, VAR=VAR, VAR=VAR) VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR(VAR.VAR) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR(VAR=1, VAR=VAR, VAR=[404]) VAR VAR( VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR ) VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR.VAR == 1 VAR VAR(VAR): VAR VAR(VAR): VAR = VAR( VAR=1, VAR=VAR, VAR=[404], VAR=VAR ) VAR VAR( VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR ) VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR.VAR == 1 ",8
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/with_dummyserver/test_https.py,"import datetime
import json
import logging
import os.path
import shutil
import ssl
import sys
import tempfile
import warnings
from test import (
    LONG_TIMEOUT,
    SHORT_TIMEOUT,
    TARPIT_HOST,
    notOpenSSL098,
    notSecureTransport,
    onlyPy279OrNewer,
    requires_network,
    requires_ssl_context_keyfile_password,
    resolvesLocalhostFQDN,
)

import mock
import pytest
import trustme

import urllib3.util as util
from dummyserver.server import (
    DEFAULT_CA,
    DEFAULT_CA_KEY,
    DEFAULT_CERTS,
    encrypt_key_pem,
)
from dummyserver.testcase import HTTPSDummyServerTestCase
from urllib3 import HTTPSConnectionPool
from urllib3.connection import RECENT_DATE, VerifiedHTTPSConnection
from urllib3.exceptions import (
    ConnectTimeoutError,
    InsecurePlatformWarning,
    InsecureRequestWarning,
    MaxRetryError,
    ProtocolError,
    SSLError,
    SystemTimeWarning,
)
from urllib3.packages import six
from urllib3.util.timeout import Timeout

from .. import has_alpn

# Retry failed tests
pytestmark = pytest.mark.flaky

ResourceWarning = getattr(
    six.moves.builtins, ""ResourceWarning"", type(""ResourceWarning"", (), {})
)


log = logging.getLogger(""urllib3.connectionpool"")
log.setLevel(logging.NOTSET)
log.addHandler(logging.StreamHandler(sys.stdout))


TLSv1_CERTS = DEFAULT_CERTS.copy()
TLSv1_CERTS[""ssl_version""] = getattr(ssl, ""PROTOCOL_TLSv1"", None)

TLSv1_1_CERTS = DEFAULT_CERTS.copy()
TLSv1_1_CERTS[""ssl_version""] = getattr(ssl, ""PROTOCOL_TLSv1_1"", None)

TLSv1_2_CERTS = DEFAULT_CERTS.copy()
TLSv1_2_CERTS[""ssl_version""] = getattr(ssl, ""PROTOCOL_TLSv1_2"", None)

TLSv1_3_CERTS = DEFAULT_CERTS.copy()
TLSv1_3_CERTS[""ssl_version""] = getattr(ssl, ""PROTOCOL_TLS"", None)


CLIENT_INTERMEDIATE_PEM = ""client_intermediate.pem""
CLIENT_NO_INTERMEDIATE_PEM = ""client_no_intermediate.pem""
CLIENT_INTERMEDIATE_KEY = ""client_intermediate.key""
PASSWORD_CLIENT_KEYFILE = ""client_password.key""
CLIENT_CERT = CLIENT_INTERMEDIATE_PEM


class TestHTTPS(HTTPSDummyServerTestCase):
    tls_protocol_name = None

    def tls_protocol_deprecated(self):
        return self.tls_protocol_name in {""TLSv1"", ""TLSv1.1""}

    @classmethod
    def setup_class(cls):
        super(TestHTTPS, cls).setup_class()

        cls.certs_dir = tempfile.mkdtemp()
        # Start from existing root CA as we don't want to change the server certificate yet
        with open(DEFAULT_CA, ""rb"") as crt, open(DEFAULT_CA_KEY, ""rb"") as key:
            root_ca = trustme.CA.from_pem(crt.read(), key.read())

        # Generate another CA to test verification failure
        bad_ca = trustme.CA()
        cls.bad_ca_path = os.path.join(cls.certs_dir, ""ca_bad.pem"")
        bad_ca.cert_pem.write_to_path(cls.bad_ca_path)

        # client cert chain
        intermediate_ca = root_ca.create_child_ca()
        cert = intermediate_ca.issue_cert(u""example.com"")
        encrypted_key = encrypt_key_pem(cert.private_key_pem, b""letmein"")

        cert.private_key_pem.write_to_path(
            os.path.join(cls.certs_dir, CLIENT_INTERMEDIATE_KEY)
        )
        encrypted_key.write_to_path(
            os.path.join(cls.certs_dir, PASSWORD_CLIENT_KEYFILE)
        )
        # Write the client cert and the intermediate CA
        client_cert = os.path.join(cls.certs_dir, CLIENT_INTERMEDIATE_PEM)
        cert.cert_chain_pems[0].write_to_path(client_cert)
        cert.cert_chain_pems[1].write_to_path(client_cert, append=True)
        # Write only the client cert
        cert.cert_chain_pems[0].write_to_path(
            os.path.join(cls.certs_dir, CLIENT_NO_INTERMEDIATE_PEM)
        )

    @classmethod
    def teardown_class(cls):
        super(TestHTTPS, cls).teardown_class()

        shutil.rmtree(cls.certs_dir)

    def test_simple(self):
        with HTTPSConnectionPool(
            self.host, self.port, ca_certs=DEFAULT_CA
        ) as https_pool:
            r = https_pool.request(""GET"", ""/"")
            assert r.status == 200, r.data

    @resolvesLocalhostFQDN
    def test_dotted_fqdn(self):
        with HTTPSConnectionPool(
            self.host + ""."", self.port, ca_certs=DEFAULT_CA
        ) as pool:
            r = pool.request(""GET"", ""/"")
            assert r.status == 200, r.data

    def test_client_intermediate(self):
        """"""Check that certificate chains work well with client certs

        We generate an intermediate CA from the root CA, and issue a client certificate
        from that intermediate CA. Since the server only knows about the root CA, we
        need to send it the certificate *and* the intermediate CA, so that it can check
        the whole chain.
        """"""
        with HTTPSConnectionPool(
            self.host,
            self.port,
            key_file=os.path.join(self.certs_dir, CLIENT_INTERMEDIATE_KEY),
            cert_file=os.path.join(self.certs_dir, CLIENT_INTERMEDIATE_PEM),
            ca_certs=DEFAULT_CA,
        ) as https_pool:
            r = https_pool.request(""GET"", ""/certificate"")
            subject = json.loads(r.data.decode(""utf-8""))
            assert subject[""organizationalUnitName""].startswith(""Testing cert"")

    def test_client_no_intermediate(self):
        """"""Check that missing links in certificate chains indeed break

        The only difference with test_client_intermediate is that we don't send the
        intermediate CA to the server, only the client cert.
        """"""
        with HTTPSConnectionPool(
            self.host,
            self.port,
            cert_file=os.path.join(self.certs_dir, CLIENT_NO_INTERMEDIATE_PEM),
            key_file=os.path.join(self.certs_dir, CLIENT_INTERMEDIATE_KEY),
            ca_certs=DEFAULT_CA,
        ) as https_pool:
            with pytest.raises((SSLError, ProtocolError)):
                https_pool.request(""GET"", ""/certificate"", retries=False)

    @requires_ssl_context_keyfile_password
    def test_client_key_password(self):
        with HTTPSConnectionPool(
            self.host,
            self.port,
            ca_certs=DEFAULT_CA,
            key_file=os.path.join(self.certs_dir, PASSWORD_CLIENT_KEYFILE),
            cert_file=os.path.join(self.certs_dir, CLIENT_CERT),
            key_password=""letmein"",
        ) as https_pool:
            r = https_pool.request(""GET"", ""/certificate"")
            subject = json.loads(r.data.decode(""utf-8""))
            assert subject[""organizationalUnitName""].startswith(""Testing cert"")

    @requires_ssl_context_keyfile_password
    def test_client_encrypted_key_requires_password(self):
        with HTTPSConnectionPool(
            self.host,
            self.port,
            key_file=os.path.join(self.certs_dir, PASSWORD_CLIENT_KEYFILE),
            cert_file=os.path.join(self.certs_dir, CLIENT_CERT),
            key_password=None,
        ) as https_pool:
            with pytest.raises(MaxRetryError) as e:
                https_pool.request(""GET"", ""/certificate"")

            assert ""password is required"" in str(e.value)
            assert isinstance(e.value.reason, SSLError)

    def test_verified(self):
        with HTTPSConnectionPool(
            self.host, self.port, cert_reqs=""CERT_REQUIRED"", ca_certs=DEFAULT_CA
        ) as https_pool:
            conn = https_pool._new_conn()
            assert conn.__class__ == VerifiedHTTPSConnection

            with warnings.catch_warnings(record=True) as w:
                r = https_pool.request(""GET"", ""/"")
                assert r.status == 200

            # If we're using a deprecated TLS version we can remove 'DeprecationWarning'
            if self.tls_protocol_deprecated():
                w = [x for x in w if x.category != DeprecationWarning]

            # Modern versions of Python, or systems using PyOpenSSL, don't
            # emit warnings.
            if (
                sys.version_info >= (2, 7, 9)
                or util.IS_PYOPENSSL
                or util.IS_SECURETRANSPORT
            ):
                assert w == []
            else:
                assert len(w) > 1
                assert any(x.category == InsecureRequestWarning for x in w)

    def test_verified_with_context(self):
        ctx = util.ssl_.create_urllib3_context(cert_reqs=ssl.CERT_REQUIRED)
        ctx.load_verify_locations(cafile=DEFAULT_CA)
        with HTTPSConnectionPool(self.host, self.port, ssl_context=ctx) as https_pool:
            conn = https_pool._new_conn()
            assert conn.__class__ == VerifiedHTTPSConnection

            with mock.patch(""warnings.warn"") as warn:
                r = https_pool.request(""GET"", ""/"")
                assert r.status == 200

                # Modern versions of Python, or systems using PyOpenSSL, don't
                # emit warnings.
                if (
                    sys.version_info >= (2, 7, 9)
                    or util.IS_PYOPENSSL
                    or util.IS_SECURETRANSPORT
                ):
                    assert not warn.called, warn.call_args_list
                else:
                    assert warn.called
                    if util.HAS_SNI:
                        call = warn.call_args_list[0]
                    else:
                        call = warn.call_args_list[1]
                    error = call[0][1]
                    assert error == InsecurePlatformWarning

    def test_context_combines_with_ca_certs(self):
        ctx = util.ssl_.create_urllib3_context(cert_reqs=ssl.CERT_REQUIRED)
        with HTTPSConnectionPool(
            self.host, self.port, ca_certs=DEFAULT_CA, ssl_context=ctx
        ) as https_pool:
            conn = https_pool._new_conn()
            assert conn.__class__ == VerifiedHTTPSConnection

            with mock.patch(""warnings.warn"") as warn:
                r = https_pool.request(""GET"", ""/"")
                assert r.status == 200

                # Modern versions of Python, or systems using PyOpenSSL, don't
                # emit warnings.
                if (
                    sys.version_info >= (2, 7, 9)
                    or util.IS_PYOPENSSL
                    or util.IS_SECURETRANSPORT
                ):
                    assert not warn.called, warn.call_args_list
                else:
                    assert warn.called
                    if util.HAS_SNI:
                        call = warn.call_args_list[0]
                    else:
                        call = warn.call_args_list[1]
                    error = call[0][1]
                    assert error == InsecurePlatformWarning

    @onlyPy279OrNewer
    @notSecureTransport  # SecureTransport does not support cert directories
    @notOpenSSL098  # OpenSSL 0.9.8 does not support cert directories
    def test_ca_dir_verified(self, tmpdir):
        # OpenSSL looks up certificates by the hash for their name, see c_rehash
        # TODO infer the bytes using `cryptography.x509.Name.public_bytes`.
        # https://github.com/pyca/cryptography/pull/3236
        shutil.copyfile(DEFAULT_CA, str(tmpdir / ""81deb5f7.0""))

        with HTTPSConnectionPool(
            self.host, self.port, cert_reqs=""CERT_REQUIRED"", ca_cert_dir=str(tmpdir)
        ) as https_pool:
            conn = https_pool._new_conn()
            assert conn.__class__ == VerifiedHTTPSConnection

            with warnings.catch_warnings(record=True) as w:
                r = https_pool.request(""GET"", ""/"")
                assert r.status == 200

            # If we're using a deprecated TLS version we can remove 'DeprecationWarning'
            if self.tls_protocol_deprecated():
                w = [x for x in w if x.category != DeprecationWarning]

            assert w == []

    def test_invalid_common_name(self):
        with HTTPSConnectionPool(
            ""127.0.0.1"", self.port, cert_reqs=""CERT_REQUIRED"", ca_certs=DEFAULT_CA
        ) as https_pool:
            with pytest.raises(MaxRetryError) as e:
                https_pool.request(""GET"", ""/"")
            assert isinstance(e.value.reason, SSLError)
            assert ""doesn't match"" in str(
                e.value.reason
            ) or ""certificate verify failed"" in str(e.value.reason)

    def test_verified_with_bad_ca_certs(self):
        with HTTPSConnectionPool(
            self.host, self.port, cert_reqs=""CERT_REQUIRED"", ca_certs=self.bad_ca_path
        ) as https_pool:
            with pytest.raises(MaxRetryError) as e:
                https_pool.request(""GET"", ""/"")
            assert isinstance(e.value.reason, SSLError)
            assert ""certificate verify failed"" in str(e.value.reason), (
                ""Expected 'certificate verify failed', instead got: %r"" % e.value.reason
            )

    def test_verified_without_ca_certs(self):
        # default is cert_reqs=None which is ssl.CERT_NONE
        with HTTPSConnectionPool(
            self.host, self.port, cert_reqs=""CERT_REQUIRED""
        ) as https_pool:
            with pytest.raises(MaxRetryError) as e:
                https_pool.request(""GET"", ""/"")
            assert isinstance(e.value.reason, SSLError)
            # there is a different error message depending on whether or
            # not pyopenssl is injected
            assert (
                ""No root certificates specified"" in str(e.value.reason)
                # PyPy sometimes uses all-caps here
                or ""certificate verify failed"" in str(e.value.reason).lower()
                or ""invalid certificate chain"" in str(e.value.reason)
            ), (
                ""Expected 'No root certificates specified',  ""
                ""'certificate verify failed', or ""
                ""'invalid certificate chain', ""
                ""instead got: %r"" % e.value.reason
            )

    def test_no_ssl(self):
        with HTTPSConnectionPool(self.host, self.port) as pool:
            pool.ConnectionCls = None
            with pytest.raises(SSLError):
                pool._new_conn()
            with pytest.raises(MaxRetryError) as cm:
                pool.request(""GET"", ""/"", retries=0)
            assert isinstance(cm.value.reason, SSLError)

    def test_unverified_ssl(self):
        """"""Test that bare HTTPSConnection can connect, make requests""""""
        with HTTPSConnectionPool(self.host, self.port, cert_reqs=ssl.CERT_NONE) as pool:
            with mock.patch(""warnings.warn"") as warn:
                r = pool.request(""GET"", ""/"")
                assert r.status == 200
                assert warn.called

                # Modern versions of Python, or systems using PyOpenSSL, only emit
                # the unverified warning. Older systems may also emit other
                # warnings, which we want to ignore here.
                calls = warn.call_args_list
                assert InsecureRequestWarning in [x[0][1] for x in calls]

    def test_ssl_unverified_with_ca_certs(self):
        with HTTPSConnectionPool(
            self.host, self.port, cert_reqs=""CERT_NONE"", ca_certs=self.bad_ca_path
        ) as pool:
            with mock.patch(""warnings.warn"") as warn:
                r = pool.request(""GET"", ""/"")
                assert r.status == 200
                assert warn.called

                # Modern versions of Python, or systems using PyOpenSSL, only emit
                # the unverified warning. Older systems may also emit other
                # warnings, which we want to ignore here.
                calls = warn.call_args_list

                # If we're using a deprecated TLS version we can remove 'DeprecationWarning'
                if self.tls_protocol_deprecated():
                    calls = [call for call in calls if call[0][1] != DeprecationWarning]

                if (
                    sys.version_info >= (2, 7, 9)
                    or util.IS_PYOPENSSL
                    or util.IS_SECURETRANSPORT
                ):
                    category = calls[0][0][1]
                elif util.HAS_SNI:
                    category = calls[1][0][1]
                else:
                    category = calls[2][0][1]
                assert category == InsecureRequestWarning

    def test_assert_hostname_false(self):
        with HTTPSConnectionPool(
            ""localhost"", self.port, cert_reqs=""CERT_REQUIRED"", ca_certs=DEFAULT_CA
        ) as https_pool:
            https_pool.assert_hostname = False
            https_pool.request(""GET"", ""/"")

    def test_assert_specific_hostname(self):
        with HTTPSConnectionPool(
            ""localhost"", self.port, cert_reqs=""CERT_REQUIRED"", ca_certs=DEFAULT_CA
        ) as https_pool:
            https_pool.assert_hostname = ""localhost""
            https_pool.request(""GET"", ""/"")

    def test_server_hostname(self):
        with HTTPSConnectionPool(
            ""127.0.0.1"",
            self.port,
            cert_reqs=""CERT_REQUIRED"",
            ca_certs=DEFAULT_CA,
            server_hostname=""localhost"",
        ) as https_pool:
            conn = https_pool._new_conn()
            conn.request(""GET"", ""/"")

            # Assert the wrapping socket is using the passed-through SNI name.
            # pyopenssl doesn't let you pull the server_hostname back off the
            # socket, so only add this assertion if the attribute is there (i.e.
            # the python ssl module).
            if hasattr(conn.sock, ""server_hostname""):
                assert conn.sock.server_hostname == ""localhost""

    def test_assert_fingerprint_md5(self):
        with HTTPSConnectionPool(
            ""localhost"", self.port, cert_reqs=""CERT_REQUIRED"", ca_certs=DEFAULT_CA
        ) as https_pool:
            https_pool.assert_fingerprint = (
                ""55:39:BF:70:05:12:43:FA:1F:D1:BF:4E:E8:1B:07:1D""
            )

            https_pool.request(""GET"", ""/"")

    def test_assert_fingerprint_sha1(self):
        with HTTPSConnectionPool(
            ""localhost"", self.port, cert_reqs=""CERT_REQUIRED"", ca_certs=DEFAULT_CA
        ) as https_pool:
            https_pool.assert_fingerprint = (
                ""72:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A""
            )
            https_pool.request(""GET"", ""/"")

    def test_assert_fingerprint_sha256(self):
        with HTTPSConnectionPool(
            ""localhost"", self.port, cert_reqs=""CERT_REQUIRED"", ca_certs=DEFAULT_CA
        ) as https_pool:
            https_pool.assert_fingerprint = (
                ""E3:59:8E:69:FF:C5:9F:C7:88:87:44:58:22:7F:90:8D:D9:BC:12:C4:90:79:D5:""
                ""DC:A8:5D:4F:60:40:1E:A6:D2""
            )
            https_pool.request(""GET"", ""/"")

    def test_assert_invalid_fingerprint(self):
        def _test_request(pool):
            with pytest.raises(MaxRetryError) as cm:
                pool.request(""GET"", ""/"", retries=0)
            assert isinstance(cm.value.reason, SSLError)
            return cm.value.reason

        with HTTPSConnectionPool(
            self.host, self.port, cert_reqs=""CERT_REQUIRED"", ca_certs=DEFAULT_CA
        ) as https_pool:

            https_pool.assert_fingerprint = (
                ""AA:AA:AA:AA:AA:AAAA:AA:AAAA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA""
            )
            e = _test_request(https_pool)
            assert ""Fingerprints did not match."" in str(e)

            # Uneven length
            https_pool.assert_fingerprint = ""AA:A""
            e = _test_request(https_pool)
            assert ""Fingerprint of invalid length:"" in str(e)

            # Invalid length
            https_pool.assert_fingerprint = ""AA""
            e = _test_request(https_pool)
            assert ""Fingerprint of invalid length:"" in str(e)

    def test_verify_none_and_bad_fingerprint(self):
        with HTTPSConnectionPool(
            ""127.0.0.1"", self.port, cert_reqs=""CERT_NONE"", ca_certs=self.bad_ca_path
        ) as https_pool:
            https_pool.assert_fingerprint = (
                ""AA:AA:AA:AA:AA:AAAA:AA:AAAA:AA:AA:AA:AA:AA:AA:AA:AA:AA:AA""
            )
            with pytest.raises(MaxRetryError) as cm:
                https_pool.request(""GET"", ""/"", retries=0)
            assert isinstance(cm.value.reason, SSLError)

    def test_verify_none_and_good_fingerprint(self):
        with HTTPSConnectionPool(
            ""127.0.0.1"", self.port, cert_reqs=""CERT_NONE"", ca_certs=self.bad_ca_path
        ) as https_pool:
            https_pool.assert_fingerprint = (
                ""72:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A""
            )
            https_pool.request(""GET"", ""/"")

    @notSecureTransport
    def test_good_fingerprint_and_hostname_mismatch(self):
        # This test doesn't run with SecureTransport because we don't turn off
        # hostname validation without turning off all validation, which this
        # test doesn't do (deliberately). We should revisit this if we make
        # new decisions.
        with HTTPSConnectionPool(
            ""127.0.0.1"", self.port, cert_reqs=""CERT_REQUIRED"", ca_certs=DEFAULT_CA
        ) as https_pool:
            https_pool.assert_fingerprint = (
                ""72:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A""
            )
            https_pool.request(""GET"", ""/"")

    @requires_network
    def test_https_timeout(self):

        timeout = Timeout(total=None, connect=SHORT_TIMEOUT)
        with HTTPSConnectionPool(
            TARPIT_HOST,
            self.port,
            timeout=timeout,
            retries=False,
            cert_reqs=""CERT_REQUIRED"",
        ) as https_pool:
            with pytest.raises(ConnectTimeoutError):
                https_pool.request(""GET"", ""/"")

        timeout = Timeout(read=0.01)
        with HTTPSConnectionPool(
            self.host,
            self.port,
            timeout=timeout,
            retries=False,
            cert_reqs=""CERT_REQUIRED"",
        ) as https_pool:
            https_pool.ca_certs = DEFAULT_CA
            https_pool.assert_fingerprint = (
                ""72:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A""
            )

        timeout = Timeout(total=None)
        with HTTPSConnectionPool(
            self.host, self.port, timeout=timeout, cert_reqs=""CERT_NONE""
        ) as https_pool:
            https_pool.request(""GET"", ""/"")

    def test_tunnel(self):
        """"""test the _tunnel behavior""""""
        timeout = Timeout(total=None)
        with HTTPSConnectionPool(
            self.host, self.port, timeout=timeout, cert_reqs=""CERT_NONE""
        ) as https_pool:
            conn = https_pool._new_conn()
            try:
                conn.set_tunnel(self.host, self.port)
                conn._tunnel = mock.Mock()
                https_pool._make_request(conn, ""GET"", ""/"")
                conn._tunnel.assert_called_once_with()
            finally:
                conn.close()

    @requires_network
    def test_enhanced_timeout(self):
        with HTTPSConnectionPool(
            TARPIT_HOST,
            self.port,
            timeout=Timeout(connect=SHORT_TIMEOUT),
            retries=False,
            cert_reqs=""CERT_REQUIRED"",
        ) as https_pool:
            conn = https_pool._new_conn()
            try:
                with pytest.raises(ConnectTimeoutError):
                    https_pool.request(""GET"", ""/"")
                with pytest.raises(ConnectTimeoutError):
                    https_pool._make_request(conn, ""GET"", ""/"")
            finally:
                conn.close()

        with HTTPSConnectionPool(
            TARPIT_HOST,
            self.port,
            timeout=Timeout(connect=LONG_TIMEOUT),
            retries=False,
            cert_reqs=""CERT_REQUIRED"",
        ) as https_pool:
            with pytest.raises(ConnectTimeoutError):
                https_pool.request(""GET"", ""/"", timeout=Timeout(connect=SHORT_TIMEOUT))

        with HTTPSConnectionPool(
            TARPIT_HOST,
            self.port,
            timeout=Timeout(total=None),
            retries=False,
            cert_reqs=""CERT_REQUIRED"",
        ) as https_pool:
            conn = https_pool._new_conn()
            try:
                with pytest.raises(ConnectTimeoutError):
                    https_pool.request(
                        ""GET"", ""/"", timeout=Timeout(total=None, connect=SHORT_TIMEOUT)
                    )
            finally:
                conn.close()

    def test_enhanced_ssl_connection(self):
        fingerprint = ""72:8B:55:4C:9A:FC:1E:88:A1:1C:AD:1B:B2:E7:CC:3E:DB:C8:F9:8A""

        with HTTPSConnectionPool(
            self.host,
            self.port,
            cert_reqs=""CERT_REQUIRED"",
            ca_certs=DEFAULT_CA,
            assert_fingerprint=fingerprint,
        ) as https_pool:
            r = https_pool.request(""GET"", ""/"")
            assert r.status == 200

    @onlyPy279OrNewer
    def test_ssl_correct_system_time(self):
        with HTTPSConnectionPool(
            self.host, self.port, ca_certs=DEFAULT_CA
        ) as https_pool:
            https_pool.cert_reqs = ""CERT_REQUIRED""
            https_pool.ca_certs = DEFAULT_CA

            w = self._request_without_resource_warnings(""GET"", ""/"")
            assert [] == w

    @onlyPy279OrNewer
    def test_ssl_wrong_system_time(self):
        with HTTPSConnectionPool(
            self.host, self.port, ca_certs=DEFAULT_CA
        ) as https_pool:
            https_pool.cert_reqs = ""CERT_REQUIRED""
            https_pool.ca_certs = DEFAULT_CA
            with mock.patch(""urllib3.connection.datetime"") as mock_date:
                mock_date.date.today.return_value = datetime.date(1970, 1, 1)

                w = self._request_without_resource_warnings(""GET"", ""/"")

                assert len(w) == 1
                warning = w[0]

                assert SystemTimeWarning == warning.category
                assert str(RECENT_DATE) in warning.message.args[0]

    def _request_without_resource_warnings(self, method, url):
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter(""always"")
            with HTTPSConnectionPool(
                self.host, self.port, ca_certs=DEFAULT_CA
            ) as https_pool:
                https_pool.request(method, url)

        w = [x for x in w if not isinstance(x.message, ResourceWarning)]

        # If we're using a deprecated TLS version we can remove 'DeprecationWarning'
        if self.tls_protocol_deprecated():
            w = [x for x in w if x.category != DeprecationWarning]

        return w

    def test_set_ssl_version_to_tls_version(self):
        if self.tls_protocol_name is None:
            pytest.skip(""Skipping base test class"")

        with HTTPSConnectionPool(
            self.host, self.port, ca_certs=DEFAULT_CA
        ) as https_pool:
            https_pool.ssl_version = self.certs[""ssl_version""]
            r = https_pool.request(""GET"", ""/"")
            assert r.status == 200, r.data

    def test_set_cert_default_cert_required(self):
        conn = VerifiedHTTPSConnection(self.host, self.port)
        conn.set_cert()
        assert conn.cert_reqs == ssl.CERT_REQUIRED

    def test_tls_protocol_name_of_socket(self):
        if self.tls_protocol_name is None:
            pytest.skip(""Skipping base test class"")

        with HTTPSConnectionPool(
            self.host, self.port, ca_certs=DEFAULT_CA
        ) as https_pool:
            conn = https_pool._get_conn()
            try:
                conn.connect()
                if not hasattr(conn.sock, ""version""):
                    pytest.skip(""SSLSocket.version() not available"")
                assert conn.sock.version() == self.tls_protocol_name
            finally:
                conn.close()

    def test_default_tls_version_deprecations(self):
        if self.tls_protocol_name is None:
            pytest.skip(""Skipping base test class"")

        with HTTPSConnectionPool(
            self.host, self.port, ca_certs=DEFAULT_CA
        ) as https_pool:
            conn = https_pool._get_conn()
            try:
                with warnings.catch_warnings(record=True) as w:
                    conn.connect()
                    if not hasattr(conn.sock, ""version""):
                        pytest.skip(""SSLSocket.version() not available"")
            finally:
                conn.close()

        if self.tls_protocol_deprecated():
            assert len(w) == 1
            assert str(w[0].message) == (
                ""Negotiating TLSv1/TLSv1.1 by default is deprecated ""
                ""and will be disabled in urllib3 v2.0.0. Connecting to ""
                ""'%s' with '%s' can be enabled by explicitly opting-in ""
                ""with 'ssl_version'"" % (self.host, self.tls_protocol_name)
            )
        else:
            assert w == []

    def test_no_tls_version_deprecation_with_ssl_version(self):
        if self.tls_protocol_name is None:
            pytest.skip(""Skipping base test class"")

        with HTTPSConnectionPool(
            self.host, self.port, ca_certs=DEFAULT_CA, ssl_version=util.PROTOCOL_TLS
        ) as https_pool:
            conn = https_pool._get_conn()
            try:
                with warnings.catch_warnings(record=True) as w:
                    conn.connect()
            finally:
                conn.close()

        assert w == []

    def test_no_tls_version_deprecation_with_ssl_context(self):
        if self.tls_protocol_name is None:
            pytest.skip(""Skipping base test class"")

        with HTTPSConnectionPool(
            self.host,
            self.port,
            ca_certs=DEFAULT_CA,
            ssl_context=util.ssl_.create_urllib3_context(),
        ) as https_pool:
            conn = https_pool._get_conn()
            try:
                with warnings.catch_warnings(record=True) as w:
                    conn.connect()
            finally:
                conn.close()

        assert w == []

    @pytest.mark.skipif(sys.version_info < (3, 8), reason=""requires python 3.8+"")
    def test_sslkeylogfile(self, tmpdir, monkeypatch):
        if not hasattr(util.SSLContext, ""keylog_filename""):
            pytest.skip(""requires OpenSSL 1.1.1+"")
        keylog_file = tmpdir.join(""keylogfile.txt"")
        monkeypatch.setenv(""SSLKEYLOGFILE"", str(keylog_file))
        with HTTPSConnectionPool(
            self.host, self.port, ca_certs=DEFAULT_CA
        ) as https_pool:
            r = https_pool.request(""GET"", ""/"")
            assert r.status == 200, r.data
            assert keylog_file.check(file=1), ""keylogfile '%s' should exist"" % str(
                keylog_file
            )
            assert keylog_file.read().startswith(
                ""# TLS secrets log file""
            ), ""keylogfile '%s' should start with '# TLS secrets log file'"" % str(
                keylog_file
            )

    @pytest.mark.parametrize(""sslkeylogfile"", [None, """"])
    def test_sslkeylogfile_empty(self, monkeypatch, sslkeylogfile):
        # Assert that an HTTPS connection doesn't error out when given
        # no SSLKEYLOGFILE or an empty value (ie 'SSLKEYLOGFILE=')
        if sslkeylogfile is not None:
            monkeypatch.setenv(""SSLKEYLOGFILE"", sslkeylogfile)
        else:
            monkeypatch.delenv(""SSLKEYLOGFILE"", raising=False)
        with HTTPSConnectionPool(self.host, self.port, ca_certs=DEFAULT_CA) as pool:
            r = pool.request(""GET"", ""/"")
            assert r.status == 200, r.data

    def test_alpn_default(self):
        """"""Default ALPN protocols are sent by default.""""""
        if not has_alpn() or not has_alpn(ssl.SSLContext):
            pytest.skip(""ALPN-support not available"")
        with HTTPSConnectionPool(self.host, self.port, ca_certs=DEFAULT_CA) as pool:
            r = pool.request(""GET"", ""/alpn_protocol"", retries=0)
            assert r.status == 200
            assert r.data.decode(""utf-8"") == util.ALPN_PROTOCOLS[0]


@pytest.mark.usefixtures(""requires_tlsv1"")
class TestHTTPS_TLSv1(TestHTTPS):
    tls_protocol_name = ""TLSv1""
    certs = TLSv1_CERTS


@pytest.mark.usefixtures(""requires_tlsv1_1"")
class TestHTTPS_TLSv1_1(TestHTTPS):
    tls_protocol_name = ""TLSv1.1""
    certs = TLSv1_1_CERTS


@pytest.mark.usefixtures(""requires_tlsv1_2"")
class TestHTTPS_TLSv1_2(TestHTTPS):
    tls_protocol_name = ""TLSv1.2""
    certs = TLSv1_2_CERTS


@pytest.mark.usefixtures(""requires_tlsv1_3"")
class TestHTTPS_TLSv1_3(TestHTTPS):
    tls_protocol_name = ""TLSv1.3""
    certs = TLSv1_3_CERTS


class TestHTTPS_NoSAN:
    def test_warning_for_certs_without_a_san(self, no_san_server):
        """"""Ensure that a warning is raised when the cert from the server has
        no Subject Alternative Name.""""""
        with mock.patch(""warnings.warn"") as warn:
            with HTTPSConnectionPool(
                no_san_server.host,
                no_san_server.port,
                cert_reqs=""CERT_REQUIRED"",
                ca_certs=no_san_server.ca_certs,
            ) as https_pool:
                r = https_pool.request(""GET"", ""/"")
                assert r.status == 200
                assert warn.called


class TestHTTPS_IPSAN:
    def test_can_validate_ip_san(self, ip_san_server):
        """"""Ensure that urllib3 can validate SANs with IP addresses in them.""""""
        try:
            import ipaddress  # noqa: F401
        except ImportError:
            pytest.skip(""Only runs on systems with an ipaddress module"")

        with HTTPSConnectionPool(
            ip_san_server.host,
            ip_san_server.port,
            cert_reqs=""CERT_REQUIRED"",
            ca_certs=ip_san_server.ca_certs,
        ) as https_pool:
            r = https_pool.request(""GET"", ""/"")
            assert r.status == 200


class TestHTTPS_IPv6Addr:
    def test_strip_square_brackets_before_validating(self, ipv6_addr_server):
        """"""Test that the fix for #760 works.""""""
        with HTTPSConnectionPool(
            ""[::1]"",
            ipv6_addr_server.port,
            cert_reqs=""CERT_REQUIRED"",
            ca_certs=ipv6_addr_server.ca_certs,
        ) as https_pool:
            r = https_pool.request(""GET"", ""/"")
            assert r.status == 200


class TestHTTPS_IPV6SAN:
    def test_can_validate_ipv6_san(self, ipv6_san_server):
        """"""Ensure that urllib3 can validate SANs with IPv6 addresses in them.""""""
        try:
            import ipaddress  # noqa: F401
        except ImportError:
            pytest.skip(""Only runs on systems with an ipaddress module"")

        with HTTPSConnectionPool(
            ""[::1]"",
            ipv6_san_server.port,
            cert_reqs=""CERT_REQUIRED"",
            ca_certs=ipv6_san_server.ca_certs,
        ) as https_pool:
            r = https_pool.request(""GET"", ""/"")
            assert r.status == 200",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, ) VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR .. VAR VAR  VAR = VAR.VAR.VAR VAR = VAR( VAR.VAR.VAR, ""VAR"", VAR(""VAR"", (), {}) ) VAR = VAR.VAR(""VAR.VAR"") VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR(VAR.VAR)) VAR = VAR.VAR() VAR[""VAR""] = VAR(VAR, ""VAR"", VAR) VAR = VAR.VAR() VAR[""VAR""] = VAR(VAR, ""VAR"", VAR) VAR = VAR.VAR() VAR[""VAR""] = VAR(VAR, ""VAR"", VAR) VAR = VAR.VAR() VAR[""VAR""] = VAR(VAR, ""VAR"", VAR) VAR = ""VAR.VAR"" VAR = ""VAR.VAR"" VAR = ""VAR.VAR"" VAR = ""VAR.VAR"" VAR = VAR VAR VAR(VAR): VAR = VAR VAR VAR(VAR): VAR VAR.VAR VAR {""VAR"", ""VAR.1""} @VAR VAR VAR(VAR): VAR(VAR, VAR).VAR() VAR.VAR = VAR.VAR()  VAR VAR(VAR, ""VAR"") VAR VAR, VAR(VAR, ""VAR"") VAR VAR: VAR = VAR.VAR.VAR(VAR.VAR(), VAR.VAR())  VAR = VAR.VAR() VAR.VAR = VAR.VAR.VAR(VAR.VAR, ""VAR.VAR"") VAR.VAR.VAR(VAR.VAR)  VAR = VAR.VAR() VAR = VAR.VAR(VAR""VAR.VAR"") VAR = VAR(VAR.VAR, VAR""VAR"") VAR.VAR.VAR( VAR.VAR.VAR(VAR.VAR, VAR) ) VAR.VAR( VAR.VAR.VAR(VAR.VAR, VAR) )  VAR = VAR.VAR.VAR(VAR.VAR, VAR) VAR.VAR[0].VAR(VAR) VAR.VAR[1].VAR(VAR, VAR=VAR)  VAR.VAR[0].VAR( VAR.VAR.VAR(VAR.VAR, VAR) ) @VAR VAR VAR(VAR): VAR(VAR, VAR).VAR() VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200, VAR.VAR @VAR VAR VAR(VAR): VAR VAR( VAR.VAR + ""."", VAR.VAR, VAR=VAR ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200, VAR.VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR *VAR* VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR.VAR.VAR(VAR.VAR, VAR), VAR=VAR.VAR.VAR(VAR.VAR, VAR), VAR=VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"") VAR = VAR.VAR(VAR.VAR.VAR(""VAR-8"")) VAR VAR[""VAR""].VAR(""VAR VAR"") VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR.VAR.VAR(VAR.VAR, VAR), VAR=VAR.VAR.VAR(VAR.VAR, VAR), VAR=VAR, ) VAR VAR: VAR VAR.VAR((VAR, VAR)): VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) @VAR VAR VAR(VAR): VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR.VAR.VAR(VAR.VAR, VAR), VAR=VAR.VAR.VAR(VAR.VAR, VAR), VAR=""VAR"", ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"") VAR = VAR.VAR(VAR.VAR.VAR(""VAR-8"")) VAR VAR[""VAR""].VAR(""VAR VAR"") @VAR VAR VAR(VAR): VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR.VAR.VAR(VAR.VAR, VAR), VAR=VAR.VAR.VAR(VAR.VAR, VAR), VAR=VAR, ) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/VAR"") VAR ""VAR VAR VAR"" VAR VAR(VAR.VAR) VAR VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR VAR: VAR = VAR.VAR() VAR VAR.VAR == VAR VAR VAR.VAR(VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200  VAR VAR.VAR(): VAR = [VAR VAR VAR VAR VAR VAR VAR.VAR != VAR]   VAR ( VAR.VAR >= (2, 7, 9) VAR VAR.VAR VAR VAR.VAR ): VAR VAR == [] VAR: VAR VAR(VAR) > 1 VAR VAR(VAR.VAR == VAR VAR VAR VAR VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR(VAR=VAR.VAR) VAR.VAR(VAR=VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR() VAR VAR.VAR == VAR VAR VAR.VAR(""VAR.VAR"") VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200   VAR ( VAR.VAR >= (2, 7, 9) VAR VAR.VAR VAR VAR.VAR ): VAR VAR VAR.VAR, VAR.VAR VAR: VAR VAR.VAR VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR VAR == VAR VAR VAR(VAR): VAR = VAR.VAR.VAR(VAR=VAR.VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR = VAR.VAR() VAR VAR.VAR == VAR VAR VAR.VAR(""VAR.VAR"") VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200   VAR ( VAR.VAR >= (2, 7, 9) VAR VAR.VAR VAR VAR.VAR ): VAR VAR VAR.VAR, VAR.VAR VAR: VAR VAR.VAR VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR VAR == VAR @VAR @VAR  @VAR  VAR VAR(VAR, VAR):    VAR.VAR(VAR, VAR(VAR / ""81deb5f7.0"")) VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"", VAR=VAR(VAR) ) VAR VAR: VAR = VAR.VAR() VAR VAR.VAR == VAR VAR VAR.VAR(VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200  VAR VAR.VAR(): VAR = [VAR VAR VAR VAR VAR VAR VAR.VAR != VAR] VAR VAR == [] VAR VAR(VAR): VAR VAR( ""127.0.0.1"", VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"") VAR VAR(VAR.VAR.VAR, VAR) VAR ""VAR'VAR VAR"" VAR VAR( VAR.VAR.VAR ) VAR ""VAR VAR VAR"" VAR VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"", VAR=VAR.VAR ) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"") VAR VAR(VAR.VAR.VAR, VAR) VAR ""VAR VAR VAR"" VAR VAR(VAR.VAR.VAR), ( ""VAR 'VAR VAR VAR', VAR VAR: %VAR"" % VAR.VAR.VAR ) VAR VAR(VAR):  VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"" ) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"") VAR VAR(VAR.VAR.VAR, VAR)   VAR ( ""VAR VAR VAR VAR"" VAR VAR(VAR.VAR.VAR)  VAR ""VAR VAR VAR"" VAR VAR(VAR.VAR.VAR).VAR() VAR ""VAR VAR VAR"" VAR VAR(VAR.VAR.VAR) ), ( ""VAR 'VAR VAR VAR VAR', "" ""'VAR VAR VAR', VAR "" ""'VAR VAR VAR', "" ""VAR VAR: %VAR"" % VAR.VAR.VAR ) VAR VAR(VAR): VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR = VAR VAR VAR.VAR(VAR): VAR.VAR() VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR, VAR VAR"""""" VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR.VAR) VAR VAR: VAR VAR.VAR(""VAR.VAR"") VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200 VAR VAR.VAR    VAR = VAR.VAR VAR VAR VAR [VAR[0][1] VAR VAR VAR VAR] VAR VAR(VAR): VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"", VAR=VAR.VAR ) VAR VAR: VAR VAR.VAR(""VAR.VAR"") VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200 VAR VAR.VAR    VAR = VAR.VAR  VAR VAR.VAR(): VAR = [VAR VAR VAR VAR VAR VAR VAR[0][1] != VAR] VAR ( VAR.VAR >= (2, 7, 9) VAR VAR.VAR VAR VAR.VAR ): VAR = VAR[0][0][1] VAR VAR.VAR: VAR = VAR[1][0][1] VAR: VAR = VAR[2][0][1] VAR VAR == VAR VAR VAR(VAR): VAR VAR( ""VAR"", VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR VAR: VAR.VAR = VAR VAR.VAR(""VAR"", ""/"") VAR VAR(VAR): VAR VAR( ""VAR"", VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR VAR: VAR.VAR = ""VAR"" VAR.VAR(""VAR"", ""/"") VAR VAR(VAR): VAR VAR( ""127.0.0.1"", VAR.VAR, VAR=""VAR"", VAR=VAR, VAR=""VAR"", ) VAR VAR: VAR = VAR.VAR() VAR.VAR(""VAR"", ""/"")     VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR == ""VAR"" VAR VAR(VAR): VAR VAR( ""VAR"", VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR VAR: VAR.VAR = ( ""55:39:VAR:70:05:12:43:VAR:1F:VAR:VAR:4E:VAR:1B:07:1D"" ) VAR.VAR(""VAR"", ""/"") VAR VAR(VAR): VAR VAR( ""VAR"", VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR VAR: VAR.VAR = ( ""72:8B:55:4C:9A:VAR:1E:88:VAR:1C:VAR:1B:VAR:VAR:VAR:3E:VAR:VAR:VAR:8A"" ) VAR.VAR(""VAR"", ""/"") VAR VAR(VAR): VAR VAR( ""VAR"", VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR VAR: VAR.VAR = ( ""VAR:59:8E:69:VAR:VAR:9F:VAR:88:87:44:58:22:7F:90:8D:VAR:VAR:12:VAR:90:79:VAR:"" ""VAR:VAR:5D:4F:60:40:1E:VAR:VAR"" ) VAR.VAR(""VAR"", ""/"") VAR VAR(VAR): VAR VAR(VAR): VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR(VAR.VAR.VAR, VAR) VAR VAR.VAR.VAR VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR VAR: VAR.VAR = ( ""VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR"" ) VAR = VAR(VAR) VAR ""VAR VAR VAR VAR."" VAR VAR(VAR)  VAR.VAR = ""VAR:VAR"" VAR = VAR(VAR) VAR ""VAR VAR VAR VAR:"" VAR VAR(VAR)  VAR.VAR = ""VAR"" VAR = VAR(VAR) VAR ""VAR VAR VAR VAR:"" VAR VAR(VAR) VAR VAR(VAR): VAR VAR( ""127.0.0.1"", VAR.VAR, VAR=""VAR"", VAR=VAR.VAR ) VAR VAR: VAR.VAR = ( ""VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR"" ) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR VAR( ""127.0.0.1"", VAR.VAR, VAR=""VAR"", VAR=VAR.VAR ) VAR VAR: VAR.VAR = ( ""72:8B:55:4C:9A:VAR:1E:88:VAR:1C:VAR:1B:VAR:VAR:VAR:3E:VAR:VAR:VAR:8A"" ) VAR.VAR(""VAR"", ""/"") @VAR VAR VAR(VAR):     VAR VAR( ""127.0.0.1"", VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR VAR: VAR.VAR = ( ""72:8B:55:4C:9A:VAR:1E:88:VAR:1C:VAR:1B:VAR:VAR:VAR:3E:VAR:VAR:VAR:8A"" ) VAR.VAR(""VAR"", ""/"") @VAR VAR VAR(VAR): VAR = VAR(VAR=VAR, VAR=VAR) VAR VAR( VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR=""VAR"", ) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"") VAR = VAR(VAR=0.01) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR=""VAR"", ) VAR VAR: VAR.VAR = VAR VAR.VAR = ( ""72:8B:55:4C:9A:VAR:1E:88:VAR:1C:VAR:1B:VAR:VAR:VAR:3E:VAR:VAR:VAR:8A"" ) VAR = VAR(VAR=VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=""VAR"" ) VAR VAR: VAR.VAR(""VAR"", ""/"") VAR VAR(VAR): """"""VAR VAR VAR VAR"""""" VAR = VAR(VAR=VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=""VAR"" ) VAR VAR: VAR = VAR.VAR() VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR.VAR() VAR.VAR(VAR, ""VAR"", ""/"") VAR.VAR.VAR() VAR: VAR.VAR() @VAR VAR VAR(VAR): VAR VAR( VAR, VAR.VAR, VAR=VAR(VAR=VAR), VAR=VAR, VAR=""VAR"", ) VAR VAR: VAR = VAR.VAR() VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"") VAR VAR.VAR(VAR): VAR.VAR(VAR, ""VAR"", ""/"") VAR: VAR.VAR() VAR VAR( VAR, VAR.VAR, VAR=VAR(VAR=VAR), VAR=VAR, VAR=""VAR"", ) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"", VAR=VAR(VAR=VAR)) VAR VAR( VAR, VAR.VAR, VAR=VAR(VAR=VAR), VAR=VAR, VAR=""VAR"", ) VAR VAR: VAR = VAR.VAR() VAR: VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""/"", VAR=VAR(VAR=VAR, VAR=VAR) ) VAR: VAR.VAR() VAR VAR(VAR): VAR = ""72:8B:55:4C:9A:VAR:1E:88:VAR:1C:VAR:1B:VAR:VAR:VAR:3E:VAR:VAR:VAR:8A"" VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"", VAR=VAR, VAR=VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200 @VAR VAR VAR(VAR): VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR ) VAR VAR: VAR.VAR = ""VAR"" VAR.VAR = VAR VAR = VAR.VAR(""VAR"", ""/"") VAR [] == VAR @VAR VAR VAR(VAR): VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR ) VAR VAR: VAR.VAR = ""VAR"" VAR.VAR = VAR VAR VAR.VAR(""VAR.VAR.VAR"") VAR VAR: VAR.VAR.VAR.VAR = VAR.VAR(1970, 1, 1) VAR = VAR.VAR(""VAR"", ""/"") VAR VAR(VAR) == 1 VAR = VAR[0] VAR VAR == VAR.VAR VAR VAR(VAR) VAR VAR.VAR.VAR[0] VAR VAR(VAR, VAR, VAR): VAR VAR.VAR(VAR=VAR) VAR VAR: VAR.VAR(""VAR"") VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR ) VAR VAR: VAR.VAR(VAR, VAR) VAR = [VAR VAR VAR VAR VAR VAR VAR VAR(VAR.VAR, VAR)]  VAR VAR.VAR(): VAR = [VAR VAR VAR VAR VAR VAR VAR.VAR != VAR] VAR VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR.VAR(""VAR VAR VAR VAR"") VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR ) VAR VAR: VAR.VAR = VAR.VAR[""VAR""] VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200, VAR.VAR VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR() VAR VAR.VAR == VAR.VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR.VAR(""VAR VAR VAR VAR"") VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR ) VAR VAR: VAR = VAR.VAR() VAR: VAR.VAR() VAR VAR VAR(VAR.VAR, ""VAR""): VAR.VAR(""VAR.VAR() VAR VAR"") VAR VAR.VAR.VAR() == VAR.VAR VAR: VAR.VAR() VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR.VAR(""VAR VAR VAR VAR"") VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR ) VAR VAR: VAR = VAR.VAR() VAR: VAR VAR.VAR(VAR=VAR) VAR VAR: VAR.VAR() VAR VAR VAR(VAR.VAR, ""VAR""): VAR.VAR(""VAR.VAR() VAR VAR"") VAR: VAR.VAR() VAR VAR.VAR(): VAR VAR(VAR) == 1 VAR VAR(VAR[0].VAR) == ( ""VAR VAR/VAR.1 VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR VAR VAR.0.0. VAR VAR "" ""'%VAR' VAR '%VAR' VAR VAR VAR VAR VAR VAR-VAR "" ""VAR 'VAR'"" % (VAR.VAR, VAR.VAR) ) VAR: VAR VAR == [] VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR.VAR(""VAR VAR VAR VAR"") VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR.VAR ) VAR VAR: VAR = VAR.VAR() VAR: VAR VAR.VAR(VAR=VAR) VAR VAR: VAR.VAR() VAR: VAR.VAR() VAR VAR == [] VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR.VAR(""VAR VAR VAR VAR"") VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR.VAR.VAR(), ) VAR VAR: VAR = VAR.VAR() VAR: VAR VAR.VAR(VAR=VAR) VAR VAR: VAR.VAR() VAR: VAR.VAR() VAR VAR == [] @VAR.VAR.VAR(VAR.VAR < (3, 8), VAR=""VAR VAR 3.8+"") VAR VAR(VAR, VAR, VAR): VAR VAR VAR(VAR.VAR, ""VAR""): VAR.VAR(""VAR VAR 1.1.1+"") VAR = VAR.VAR(""VAR.VAR"") VAR.VAR(""VAR"", VAR(VAR)) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200, VAR.VAR VAR VAR.VAR(VAR=1), ""VAR '%VAR' VAR VAR"" % VAR( VAR ) VAR VAR.VAR().VAR( "" ), ""VAR '%VAR' VAR VAR VAR ' VAR ) @VAR.VAR.VAR(""VAR"", [VAR, """"]) VAR VAR(VAR, VAR, VAR):   VAR VAR VAR VAR VAR: VAR.VAR(""VAR"", VAR) VAR: VAR.VAR(""VAR"", VAR=VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200, VAR.VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR VAR() VAR VAR VAR(VAR.VAR): VAR.VAR(""VAR-VAR VAR VAR"") VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=0) VAR VAR.VAR == 200 VAR VAR.VAR.VAR(""VAR-8"") == VAR.VAR[0] @VAR.VAR.VAR(""VAR"") VAR VAR(VAR): VAR = ""VAR"" VAR = VAR @VAR.VAR.VAR(""VAR"") VAR VAR(VAR): VAR = ""VAR.1"" VAR = VAR @VAR.VAR.VAR(""VAR"") VAR VAR(VAR): VAR = ""VAR.2"" VAR = VAR @VAR.VAR.VAR(""VAR"") VAR VAR(VAR): VAR = ""VAR.3"" VAR = VAR VAR VAR: VAR VAR(VAR, VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR.VAR(""VAR.VAR"") VAR VAR: VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"", VAR=VAR.VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200 VAR VAR.VAR VAR VAR: VAR VAR(VAR, VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR: VAR VAR  VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"", VAR=VAR.VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200 VAR VAR: VAR VAR(VAR, VAR): """"""VAR VAR VAR VAR VAR  VAR VAR( ""[::1]"", VAR.VAR, VAR=""VAR"", VAR=VAR.VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200 VAR VAR: VAR VAR(VAR, VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR: VAR VAR  VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR( ""[::1]"", VAR.VAR, VAR=""VAR"", VAR=VAR.VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200 ",8
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/with_dummyserver/test_no_ssl.py,"""""""
Test connections without the builtin ssl module

Note: Import urllib3 inside the test functions to get the importblocker to work
""""""
import pytest

import urllib3
from dummyserver.testcase import HTTPDummyServerTestCase, HTTPSDummyServerTestCase

from ..test_no_ssl import TestWithoutSSL

# Retry failed tests
pytestmark = pytest.mark.flaky


class TestHTTPWithoutSSL(HTTPDummyServerTestCase, TestWithoutSSL):
    def test_simple(self):
        with urllib3.HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/"")
            assert r.status == 200, r.data


class TestHTTPSWithoutSSL(HTTPSDummyServerTestCase, TestWithoutSSL):
    def test_simple(self):
        with urllib3.HTTPSConnectionPool(
            self.host, self.port, cert_reqs=""NONE""
        ) as pool:
            try:
                pool.request(""GET"", ""/"")
            except urllib3.exceptions.SSLError as e:
                assert ""SSL module is not available"" in str(e)",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,""""""" VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR ..VAR VAR VAR  VAR = VAR.VAR.VAR VAR VAR(VAR, VAR): VAR VAR(VAR): VAR VAR.VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 200, VAR.VAR VAR VAR(VAR, VAR): VAR VAR(VAR): VAR VAR.VAR( VAR.VAR, VAR.VAR, VAR=""VAR"" ) VAR VAR: VAR: VAR.VAR(""VAR"", ""/"") VAR VAR.VAR.VAR VAR VAR: VAR ""VAR VAR VAR VAR VAR"" VAR VAR(VAR) ",8
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/with_dummyserver/test_poolmanager.py,"import json
from test import LONG_TIMEOUT

import pytest

from dummyserver.server import HAS_IPV6
from dummyserver.testcase import HTTPDummyServerTestCase, IPv6HTTPDummyServerTestCase
from urllib3.connectionpool import port_by_scheme
from urllib3.exceptions import MaxRetryError, URLSchemeUnknown
from urllib3.poolmanager import PoolManager
from urllib3.util.retry import Retry

# Retry failed tests
pytestmark = pytest.mark.flaky


class TestPoolManager(HTTPDummyServerTestCase):
    @classmethod
    def setup_class(cls):
        super(TestPoolManager, cls).setup_class()
        cls.base_url = ""http://%s:%d"" % (cls.host, cls.port)
        cls.base_url_alt = ""http://%s:%d"" % (cls.host_alt, cls.port)

    def test_redirect(self):
        with PoolManager() as http:
            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": ""%s/"" % self.base_url},
                redirect=False,
            )

            assert r.status == 303

            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": ""%s/"" % self.base_url},
            )

            assert r.status == 200
            assert r.data == b""Dummy server!""

    def test_redirect_twice(self):
        with PoolManager() as http:
            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": ""%s/redirect"" % self.base_url},
                redirect=False,
            )

            assert r.status == 303

            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={
                    ""target"": ""%s/redirect?target=%s/"" % (self.base_url, self.base_url)
                },
            )

            assert r.status == 200
            assert r.data == b""Dummy server!""

    def test_redirect_to_relative_url(self):
        with PoolManager() as http:
            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": ""/redirect""},
                redirect=False,
            )

            assert r.status == 303

            r = http.request(
                ""GET"", ""%s/redirect"" % self.base_url, fields={""target"": ""/redirect""}
            )

            assert r.status == 200
            assert r.data == b""Dummy server!""

    def test_cross_host_redirect(self):
        with PoolManager() as http:
            cross_host_location = ""%s/echo?a=b"" % self.base_url_alt
            with pytest.raises(MaxRetryError):
                http.request(
                    ""GET"",
                    ""%s/redirect"" % self.base_url,
                    fields={""target"": cross_host_location},
                    timeout=LONG_TIMEOUT,
                    retries=0,
                )

            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": ""%s/echo?a=b"" % self.base_url_alt},
                timeout=LONG_TIMEOUT,
                retries=1,
            )

            assert r._pool.host == self.host_alt

    def test_too_many_redirects(self):
        with PoolManager() as http:
            with pytest.raises(MaxRetryError):
                http.request(
                    ""GET"",
                    ""%s/redirect"" % self.base_url,
                    fields={
                        ""target"": ""%s/redirect?target=%s/""
                        % (self.base_url, self.base_url)
                    },
                    retries=1,
                    preload_content=False,
                )

            with pytest.raises(MaxRetryError):
                http.request(
                    ""GET"",
                    ""%s/redirect"" % self.base_url,
                    fields={
                        ""target"": ""%s/redirect?target=%s/""
                        % (self.base_url, self.base_url)
                    },
                    retries=Retry(total=None, redirect=1),
                    preload_content=False,
                )

            # Even with preload_content=False and raise on redirects, we reused the same
            # connection
            assert len(http.pools) == 1
            pool = http.connection_from_host(self.host, self.port)
            assert pool.num_connections == 1

    def test_redirect_cross_host_remove_headers(self):
        with PoolManager() as http:
            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": ""%s/headers"" % self.base_url_alt},
                headers={""Authorization"": ""foo""},
            )

            assert r.status == 200

            data = json.loads(r.data.decode(""utf-8""))

            assert ""Authorization"" not in data

            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": ""%s/headers"" % self.base_url_alt},
                headers={""authorization"": ""foo""},
            )

            assert r.status == 200

            data = json.loads(r.data.decode(""utf-8""))

            assert ""authorization"" not in data
            assert ""Authorization"" not in data

    def test_redirect_cross_host_no_remove_headers(self):
        with PoolManager() as http:
            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": ""%s/headers"" % self.base_url_alt},
                headers={""Authorization"": ""foo""},
                retries=Retry(remove_headers_on_redirect=[]),
            )

            assert r.status == 200

            data = json.loads(r.data.decode(""utf-8""))

            assert data[""Authorization""] == ""foo""

    def test_redirect_cross_host_set_removed_headers(self):
        with PoolManager() as http:
            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": ""%s/headers"" % self.base_url_alt},
                headers={""X-API-Secret"": ""foo"", ""Authorization"": ""bar""},
                retries=Retry(remove_headers_on_redirect=[""X-API-Secret""]),
            )

            assert r.status == 200

            data = json.loads(r.data.decode(""utf-8""))

            assert ""X-API-Secret"" not in data
            assert data[""Authorization""] == ""bar""

            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": ""%s/headers"" % self.base_url_alt},
                headers={""x-api-secret"": ""foo"", ""authorization"": ""bar""},
                retries=Retry(remove_headers_on_redirect=[""X-API-Secret""]),
            )

            assert r.status == 200

            data = json.loads(r.data.decode(""utf-8""))

            assert ""x-api-secret"" not in data
            assert ""X-API-Secret"" not in data
            assert data[""Authorization""] == ""bar""

    def test_redirect_without_preload_releases_connection(self):
        with PoolManager(block=True, maxsize=2) as http:
            r = http.request(
                ""GET"", ""%s/redirect"" % self.base_url, preload_content=False
            )
            assert r._pool.num_requests == 2
            assert r._pool.num_connections == 1
            assert len(http.pools) == 1

    def test_unknown_scheme(self):
        with PoolManager() as http:
            unknown_scheme = ""unknown""
            unknown_scheme_url = ""%s://host"" % unknown_scheme
            with pytest.raises(URLSchemeUnknown) as e:
                r = http.request(""GET"", unknown_scheme_url)
            assert e.value.scheme == unknown_scheme
            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={""target"": unknown_scheme_url},
                redirect=False,
            )
            assert r.status == 303
            assert r.headers.get(""Location"") == unknown_scheme_url
            with pytest.raises(URLSchemeUnknown) as e:
                r = http.request(
                    ""GET"",
                    ""%s/redirect"" % self.base_url,
                    fields={""target"": unknown_scheme_url},
                )
            assert e.value.scheme == unknown_scheme

    def test_raise_on_redirect(self):
        with PoolManager() as http:
            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.base_url,
                fields={
                    ""target"": ""%s/redirect?target=%s/"" % (self.base_url, self.base_url)
                },
                retries=Retry(total=None, redirect=1, raise_on_redirect=False),
            )

            assert r.status == 303

    def test_raise_on_status(self):
        with PoolManager() as http:
            with pytest.raises(MaxRetryError):
                # the default is to raise
                r = http.request(
                    ""GET"",
                    ""%s/status"" % self.base_url,
                    fields={""status"": ""500 Internal Server Error""},
                    retries=Retry(total=1, status_forcelist=range(500, 600)),
                )

            with pytest.raises(MaxRetryError):
                # raise explicitly
                r = http.request(
                    ""GET"",
                    ""%s/status"" % self.base_url,
                    fields={""status"": ""500 Internal Server Error""},
                    retries=Retry(
                        total=1, status_forcelist=range(500, 600), raise_on_status=True
                    ),
                )

            # don't raise
            r = http.request(
                ""GET"",
                ""%s/status"" % self.base_url,
                fields={""status"": ""500 Internal Server Error""},
                retries=Retry(
                    total=1, status_forcelist=range(500, 600), raise_on_status=False
                ),
            )

            assert r.status == 500

    def test_missing_port(self):
        # Can a URL that lacks an explicit port like ':80' succeed, or
        # will all such URLs fail with an error?

        with PoolManager() as http:
            # By globally adjusting `port_by_scheme` we pretend for a moment
            # that HTTP's default port is not 80, but is the port at which
            # our test server happens to be listening.
            port_by_scheme[""http""] = self.port
            try:
                r = http.request(""GET"", ""http://%s/"" % self.host, retries=0)
            finally:
                port_by_scheme[""http""] = 80

            assert r.status == 200
            assert r.data == b""Dummy server!""

    def test_headers(self):
        with PoolManager(headers={""Foo"": ""bar""}) as http:
            r = http.request(""GET"", ""%s/headers"" % self.base_url)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""

            r = http.request(""POST"", ""%s/headers"" % self.base_url)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""

            r = http.request_encode_url(""GET"", ""%s/headers"" % self.base_url)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""

            r = http.request_encode_body(""POST"", ""%s/headers"" % self.base_url)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""

            r = http.request_encode_url(
                ""GET"", ""%s/headers"" % self.base_url, headers={""Baz"": ""quux""}
            )
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") is None
            assert returned_headers.get(""Baz"") == ""quux""

            r = http.request_encode_body(
                ""GET"", ""%s/headers"" % self.base_url, headers={""Baz"": ""quux""}
            )
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") is None
            assert returned_headers.get(""Baz"") == ""quux""

    def test_http_with_ssl_keywords(self):
        with PoolManager(ca_certs=""REQUIRED"") as http:
            r = http.request(""GET"", ""http://%s:%s/"" % (self.host, self.port))
            assert r.status == 200

    def test_http_with_ca_cert_dir(self):
        with PoolManager(ca_certs=""REQUIRED"", ca_cert_dir=""/nosuchdir"") as http:
            r = http.request(""GET"", ""http://%s:%s/"" % (self.host, self.port))
            assert r.status == 200

    @pytest.mark.parametrize(
        [""target"", ""expected_target""],
        [
            (""/echo_uri?q=1#fragment"", b""/echo_uri?q=1""),
            (""/echo_uri?#"", b""/echo_uri?""),
            (""/echo_uri#?"", b""/echo_uri""),
            (""/echo_uri#?#"", b""/echo_uri""),
            (""/echo_uri??#"", b""/echo_uri??""),
            (""/echo_uri?%3f#"", b""/echo_uri?%3F""),
            (""/echo_uri?%3F#"", b""/echo_uri?%3F""),
            (""/echo_uri?[]"", b""/echo_uri?%5B%5D""),
        ],
    )
    def test_encode_http_target(self, target, expected_target):
        with PoolManager() as http:
            url = ""http://%s:%d%s"" % (self.host, self.port, target)
            r = http.request(""GET"", url)
            assert r.data == expected_target


@pytest.mark.skipif(not HAS_IPV6, reason=""IPv6 is not supported on this system"")
class TestIPv6PoolManager(IPv6HTTPDummyServerTestCase):
    @classmethod
    def setup_class(cls):
        super(TestIPv6PoolManager, cls).setup_class()
        cls.base_url = ""http://[%s]:%d"" % (cls.host, cls.port)

    def test_ipv6(self):
        with PoolManager() as http:
            http.request(""GET"", self.base_url)",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR  VAR = VAR.VAR.VAR VAR VAR(VAR): @VAR VAR VAR(VAR): VAR(VAR, VAR).VAR() VAR.VAR = ""VAR: VAR.VAR = ""VAR: VAR VAR(VAR): VAR VAR() VAR VAR: VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/"" % VAR.VAR}, VAR=VAR, ) VAR VAR.VAR == 303 VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/"" % VAR.VAR}, ) VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR VAR!"" VAR VAR(VAR): VAR VAR() VAR VAR: VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/VAR"" % VAR.VAR}, VAR=VAR, ) VAR VAR.VAR == 303 VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={ ""VAR"": ""%VAR/VAR?VAR=%VAR/"" % (VAR.VAR, VAR.VAR) }, ) VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR VAR!"" VAR VAR(VAR): VAR VAR() VAR VAR: VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""/VAR""}, VAR=VAR, ) VAR VAR.VAR == 303 VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""/VAR""} ) VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR VAR!"" VAR VAR(VAR): VAR VAR() VAR VAR: VAR = ""%VAR/VAR?VAR=VAR"" % VAR.VAR VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": VAR}, VAR=VAR, VAR=0, ) VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/VAR?VAR=VAR"" % VAR.VAR}, VAR=VAR, VAR=1, ) VAR VAR.VAR.VAR == VAR.VAR VAR VAR(VAR): VAR VAR() VAR VAR: VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={ ""VAR"": ""%VAR/VAR?VAR=%VAR/"" % (VAR.VAR, VAR.VAR) }, VAR=1, VAR=VAR, ) VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={ ""VAR"": ""%VAR/VAR?VAR=%VAR/"" % (VAR.VAR, VAR.VAR) }, VAR=VAR(VAR=VAR, VAR=1), VAR=VAR, )   VAR VAR(VAR.VAR) == 1 VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR VAR.VAR == 1 VAR VAR(VAR): VAR VAR() VAR VAR: VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/VAR"" % VAR.VAR}, VAR={""VAR"": ""VAR""}, ) VAR VAR.VAR == 200 VAR = VAR.VAR(VAR.VAR.VAR(""VAR-8"")) VAR ""VAR"" VAR VAR VAR VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/VAR"" % VAR.VAR}, VAR={""VAR"": ""VAR""}, ) VAR VAR.VAR == 200 VAR = VAR.VAR(VAR.VAR.VAR(""VAR-8"")) VAR ""VAR"" VAR VAR VAR VAR ""VAR"" VAR VAR VAR VAR VAR(VAR): VAR VAR() VAR VAR: VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/VAR"" % VAR.VAR}, VAR={""VAR"": ""VAR""}, VAR=VAR(VAR=[]), ) VAR VAR.VAR == 200 VAR = VAR.VAR(VAR.VAR.VAR(""VAR-8"")) VAR VAR[""VAR""] == ""VAR"" VAR VAR(VAR): VAR VAR() VAR VAR: VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/VAR"" % VAR.VAR}, VAR={""VAR-VAR-VAR"": ""VAR"", ""VAR"": ""VAR""}, VAR=VAR(VAR=[""VAR-VAR-VAR""]), ) VAR VAR.VAR == 200 VAR = VAR.VAR(VAR.VAR.VAR(""VAR-8"")) VAR ""VAR-VAR-VAR"" VAR VAR VAR VAR VAR[""VAR""] == ""VAR"" VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/VAR"" % VAR.VAR}, VAR={""VAR-VAR-VAR"": ""VAR"", ""VAR"": ""VAR""}, VAR=VAR(VAR=[""VAR-VAR-VAR""]), ) VAR VAR.VAR == 200 VAR = VAR.VAR(VAR.VAR.VAR(""VAR-8"")) VAR ""VAR-VAR-VAR"" VAR VAR VAR VAR ""VAR-VAR-VAR"" VAR VAR VAR VAR VAR[""VAR""] == ""VAR"" VAR VAR(VAR): VAR VAR(VAR=VAR, VAR=2) VAR VAR: VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR=VAR ) VAR VAR.VAR.VAR == 2 VAR VAR.VAR.VAR == 1 VAR VAR(VAR.VAR) == 1 VAR VAR(VAR): VAR VAR() VAR VAR: VAR = ""VAR"" VAR = ""%VAR: VAR VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(""VAR"", VAR) VAR VAR.VAR.VAR == VAR VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": VAR}, VAR=VAR, ) VAR VAR.VAR == 303 VAR VAR.VAR.VAR(""VAR"") == VAR VAR VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": VAR}, ) VAR VAR.VAR.VAR == VAR VAR VAR(VAR): VAR VAR() VAR VAR: VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={ ""VAR"": ""%VAR/VAR?VAR=%VAR/"" % (VAR.VAR, VAR.VAR) }, VAR=VAR(VAR=VAR, VAR=1, VAR=VAR), ) VAR VAR.VAR == 303 VAR VAR(VAR): VAR VAR() VAR VAR: VAR VAR.VAR(VAR):  VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""500 VAR VAR VAR""}, VAR=VAR(VAR=1, VAR=VAR(500, 600)), ) VAR VAR.VAR(VAR):  VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""500 VAR VAR VAR""}, VAR=VAR( VAR=1, VAR=VAR(500, 600), VAR=VAR ), )  VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""500 VAR VAR VAR""}, VAR=VAR( VAR=1, VAR=VAR(500, 600), VAR=VAR ), ) VAR VAR.VAR == 500 VAR VAR(VAR):   VAR VAR() VAR VAR:    VAR[""VAR""] = VAR.VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR: VAR[""VAR""] = 80 VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR VAR!"" VAR VAR(VAR): VAR VAR(VAR={""VAR"": ""VAR""}) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""VAR""} ) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""VAR"" VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""VAR""} ) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR(VAR): VAR VAR(VAR=""VAR"") VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 VAR VAR(VAR): VAR VAR(VAR=""VAR"", VAR=""/VAR"") VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200 @VAR.VAR.VAR( [""VAR"", ""VAR""], [ (""/VAR?VAR=1 (""/VAR? (""/VAR (""/VAR (""/VAR?? (""/VAR?%3f (""/VAR?%3F (""/VAR?[]"", VAR""/VAR?%5B%5D""), ], ) VAR VAR(VAR, VAR, VAR): VAR VAR() VAR VAR: VAR = ""VAR: VAR = VAR.VAR(""VAR"", VAR) VAR VAR.VAR == VAR @VAR.VAR.VAR(VAR VAR, VAR=""VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR): @VAR VAR VAR(VAR): VAR(VAR, VAR).VAR() VAR.VAR = ""VAR: VAR VAR(VAR): VAR VAR() VAR VAR: VAR.VAR(""VAR"", VAR.VAR) ",8
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/with_dummyserver/test_proxy_poolmanager.py,"import json
import os.path
import shutil
import socket
import tempfile
from test import (
    LONG_TIMEOUT,
    SHORT_TIMEOUT,
    onlyPy2,
    onlyPy3,
    onlySecureTransport,
    withPyOpenSSL,
)

import pytest
import trustme

from dummyserver.server import DEFAULT_CA, HAS_IPV6, get_unreachable_address
from dummyserver.testcase import HTTPDummyProxyTestCase, IPv6HTTPDummyProxyTestCase
from urllib3._collections import HTTPHeaderDict
from urllib3.connectionpool import VerifiedHTTPSConnection, connection_from_url
from urllib3.exceptions import (
    ConnectTimeoutError,
    MaxRetryError,
    ProxyError,
    ProxySchemeUnknown,
    ProxySchemeUnsupported,
    SSLError,
)
from urllib3.poolmanager import ProxyManager, proxy_from_url
from urllib3.util.ssl_ import create_urllib3_context

from .. import TARPIT_HOST, requires_network

# Retry failed tests
pytestmark = pytest.mark.flaky


class TestHTTPProxyManager(HTTPDummyProxyTestCase):
    @classmethod
    def setup_class(cls):
        super(TestHTTPProxyManager, cls).setup_class()
        cls.http_url = ""http://%s:%d"" % (cls.http_host, cls.http_port)
        cls.http_url_alt = ""http://%s:%d"" % (cls.http_host_alt, cls.http_port)
        cls.https_url = ""https://%s:%d"" % (cls.https_host, cls.https_port)
        cls.https_url_alt = ""https://%s:%d"" % (cls.https_host_alt, cls.https_port)
        cls.proxy_url = ""http://%s:%d"" % (cls.proxy_host, cls.proxy_port)
        cls.https_proxy_url = ""https://%s:%d"" % (
            cls.proxy_host,
            cls.https_proxy_port,
        )

        # Generate another CA to test verification failure
        cls.certs_dir = tempfile.mkdtemp()
        bad_ca = trustme.CA()

        cls.bad_ca_path = os.path.join(cls.certs_dir, ""ca_bad.pem"")
        bad_ca.cert_pem.write_to_path(cls.bad_ca_path)

    @classmethod
    def teardown_class(cls):
        super(TestHTTPProxyManager, cls).teardown_class()
        shutil.rmtree(cls.certs_dir)

    def test_basic_proxy(self):
        with proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA) as http:
            r = http.request(""GET"", ""%s/"" % self.http_url)
            assert r.status == 200

            r = http.request(""GET"", ""%s/"" % self.https_url)
            assert r.status == 200

    @onlyPy3
    def test_https_proxy(self):
        with proxy_from_url(self.https_proxy_url, ca_certs=DEFAULT_CA) as https:
            r = https.request(""GET"", ""%s/"" % self.https_url)
            assert r.status == 200

            r = https.request(""GET"", ""%s/"" % self.http_url)
            assert r.status == 200

    @onlyPy3
    def test_https_proxy_with_proxy_ssl_context(self):
        proxy_ssl_context = create_urllib3_context()
        proxy_ssl_context.load_verify_locations(DEFAULT_CA)
        with proxy_from_url(
            self.https_proxy_url,
            proxy_ssl_context=proxy_ssl_context,
            ca_certs=DEFAULT_CA,
        ) as https:
            r = https.request(""GET"", ""%s/"" % self.https_url)
            assert r.status == 200

            r = https.request(""GET"", ""%s/"" % self.http_url)
            assert r.status == 200

    @onlyPy2
    def test_https_proxy_not_supported(self):
        with proxy_from_url(self.https_proxy_url, ca_certs=DEFAULT_CA) as https:
            r = https.request(""GET"", ""%s/"" % self.http_url)
            assert r.status == 200

            with pytest.raises(ProxySchemeUnsupported) as excinfo:
                https.request(""GET"", ""%s/"" % self.https_url)

            assert ""is not supported in Python 2"" in str(excinfo.value)

    @withPyOpenSSL
    @onlyPy3
    def test_https_proxy_pyopenssl_not_supported(self):
        with proxy_from_url(self.https_proxy_url, ca_certs=DEFAULT_CA) as https:
            r = https.request(""GET"", ""%s/"" % self.http_url)
            assert r.status == 200

            with pytest.raises(ProxySchemeUnsupported) as excinfo:
                https.request(""GET"", ""%s/"" % self.https_url)

            assert ""isn't available on non-native SSLContext"" in str(excinfo.value)

    @onlySecureTransport
    @onlyPy3
    def test_https_proxy_securetransport_not_supported(self):
        with proxy_from_url(self.https_proxy_url, ca_certs=DEFAULT_CA) as https:
            r = https.request(""GET"", ""%s/"" % self.http_url)
            assert r.status == 200

            with pytest.raises(ProxySchemeUnsupported) as excinfo:
                https.request(""GET"", ""%s/"" % self.https_url)

            assert ""isn't available on non-native SSLContext"" in str(excinfo.value)

    def test_https_proxy_forwarding_for_https(self):
        with proxy_from_url(
            self.https_proxy_url,
            ca_certs=DEFAULT_CA,
            use_forwarding_for_https=True,
        ) as https:
            r = https.request(""GET"", ""%s/"" % self.http_url)
            assert r.status == 200

            r = https.request(""GET"", ""%s/"" % self.https_url)
            assert r.status == 200

    def test_nagle_proxy(self):
        """"""Test that proxy connections do not have TCP_NODELAY turned on""""""
        with ProxyManager(self.proxy_url) as http:
            hc2 = http.connection_from_host(self.http_host, self.http_port)
            conn = hc2._get_conn()
            try:
                hc2._make_request(conn, ""GET"", ""/"")
                tcp_nodelay_setting = conn.sock.getsockopt(
                    socket.IPPROTO_TCP, socket.TCP_NODELAY
                )
                assert tcp_nodelay_setting == 0, (
                    ""Expected TCP_NODELAY for proxies to be set ""
                    ""to zero, instead was %s"" % tcp_nodelay_setting
                )
            finally:
                conn.close()

    def test_proxy_conn_fail(self):
        host, port = get_unreachable_address()
        with proxy_from_url(
            ""http://%s:%s/"" % (host, port), retries=1, timeout=LONG_TIMEOUT
        ) as http:
            with pytest.raises(MaxRetryError):
                http.request(""GET"", ""%s/"" % self.https_url)
            with pytest.raises(MaxRetryError):
                http.request(""GET"", ""%s/"" % self.http_url)

            with pytest.raises(MaxRetryError) as e:
                http.request(""GET"", ""%s/"" % self.http_url)
            assert type(e.value.reason) == ProxyError

    def test_oldapi(self):
        with ProxyManager(
            connection_from_url(self.proxy_url), ca_certs=DEFAULT_CA
        ) as http:
            r = http.request(""GET"", ""%s/"" % self.http_url)
            assert r.status == 200

            r = http.request(""GET"", ""%s/"" % self.https_url)
            assert r.status == 200

    def test_proxy_verified(self):
        with proxy_from_url(
            self.proxy_url, cert_reqs=""REQUIRED"", ca_certs=self.bad_ca_path
        ) as http:
            https_pool = http._new_pool(""https"", self.https_host, self.https_port)
            with pytest.raises(MaxRetryError) as e:
                https_pool.request(""GET"", ""/"", retries=0)
            assert isinstance(e.value.reason, SSLError)
            assert ""certificate verify failed"" in str(e.value.reason), (
                ""Expected 'certificate verify failed', instead got: %r"" % e.value.reason
            )

            http = proxy_from_url(
                self.proxy_url, cert_reqs=""REQUIRED"", ca_certs=DEFAULT_CA
            )
            https_pool = http._new_pool(""https"", self.https_host, self.https_port)

            conn = https_pool._new_conn()
            assert conn.__class__ == VerifiedHTTPSConnection
            https_pool.request(""GET"", ""/"")  # Should succeed without exceptions.

            http = proxy_from_url(
                self.proxy_url, cert_reqs=""REQUIRED"", ca_certs=DEFAULT_CA
            )
            https_fail_pool = http._new_pool(""https"", ""127.0.0.1"", self.https_port)

            with pytest.raises(MaxRetryError) as e:
                https_fail_pool.request(""GET"", ""/"", retries=0)
            assert isinstance(e.value.reason, SSLError)
            assert ""doesn't match"" in str(e.value.reason)

    def test_redirect(self):
        with proxy_from_url(self.proxy_url) as http:
            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.http_url,
                fields={""target"": ""%s/"" % self.http_url},
                redirect=False,
            )

            assert r.status == 303

            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.http_url,
                fields={""target"": ""%s/"" % self.http_url},
            )

            assert r.status == 200
            assert r.data == b""Dummy server!""

    def test_cross_host_redirect(self):
        with proxy_from_url(self.proxy_url) as http:
            cross_host_location = ""%s/echo?a=b"" % self.http_url_alt
            with pytest.raises(MaxRetryError):
                http.request(
                    ""GET"",
                    ""%s/redirect"" % self.http_url,
                    fields={""target"": cross_host_location},
                    retries=0,
                )

            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.http_url,
                fields={""target"": ""%s/echo?a=b"" % self.http_url_alt},
                retries=1,
            )
            assert r._pool.host != self.http_host_alt

    def test_cross_protocol_redirect(self):
        with proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA) as http:
            cross_protocol_location = ""%s/echo?a=b"" % self.https_url
            with pytest.raises(MaxRetryError):
                http.request(
                    ""GET"",
                    ""%s/redirect"" % self.http_url,
                    fields={""target"": cross_protocol_location},
                    retries=0,
                )

            r = http.request(
                ""GET"",
                ""%s/redirect"" % self.http_url,
                fields={""target"": ""%s/echo?a=b"" % self.https_url},
                retries=1,
            )
            assert r._pool.host == self.https_host

    def test_headers(self):
        with proxy_from_url(
            self.proxy_url,
            headers={""Foo"": ""bar""},
            proxy_headers={""Hickory"": ""dickory""},
            ca_certs=DEFAULT_CA,
        ) as http:

            r = http.request_encode_url(""GET"", ""%s/headers"" % self.http_url)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""
            assert returned_headers.get(""Hickory"") == ""dickory""
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.http_host,
                self.http_port,
            )

            r = http.request_encode_url(""GET"", ""%s/headers"" % self.http_url_alt)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""
            assert returned_headers.get(""Hickory"") == ""dickory""
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.http_host_alt,
                self.http_port,
            )

            r = http.request_encode_url(""GET"", ""%s/headers"" % self.https_url)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""
            assert returned_headers.get(""Hickory"") is None
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.https_host,
                self.https_port,
            )

            r = http.request_encode_body(""POST"", ""%s/headers"" % self.http_url)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""
            assert returned_headers.get(""Hickory"") == ""dickory""
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.http_host,
                self.http_port,
            )

            r = http.request_encode_url(
                ""GET"", ""%s/headers"" % self.http_url, headers={""Baz"": ""quux""}
            )
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") is None
            assert returned_headers.get(""Baz"") == ""quux""
            assert returned_headers.get(""Hickory"") == ""dickory""
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.http_host,
                self.http_port,
            )

            r = http.request_encode_url(
                ""GET"", ""%s/headers"" % self.https_url, headers={""Baz"": ""quux""}
            )
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") is None
            assert returned_headers.get(""Baz"") == ""quux""
            assert returned_headers.get(""Hickory"") is None
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.https_host,
                self.https_port,
            )

            r = http.request_encode_body(
                ""GET"", ""%s/headers"" % self.http_url, headers={""Baz"": ""quux""}
            )
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") is None
            assert returned_headers.get(""Baz"") == ""quux""
            assert returned_headers.get(""Hickory"") == ""dickory""
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.http_host,
                self.http_port,
            )

            r = http.request_encode_body(
                ""GET"", ""%s/headers"" % self.https_url, headers={""Baz"": ""quux""}
            )
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") is None
            assert returned_headers.get(""Baz"") == ""quux""
            assert returned_headers.get(""Hickory"") is None
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.https_host,
                self.https_port,
            )

    @onlyPy3
    def test_https_headers(self):
        with proxy_from_url(
            self.https_proxy_url,
            headers={""Foo"": ""bar""},
            proxy_headers={""Hickory"": ""dickory""},
            ca_certs=DEFAULT_CA,
        ) as http:

            r = http.request_encode_url(""GET"", ""%s/headers"" % self.http_url)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""
            assert returned_headers.get(""Hickory"") == ""dickory""
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.http_host,
                self.http_port,
            )

            r = http.request_encode_url(""GET"", ""%s/headers"" % self.http_url_alt)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""
            assert returned_headers.get(""Hickory"") == ""dickory""
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.http_host_alt,
                self.http_port,
            )

            r = http.request_encode_body(
                ""GET"", ""%s/headers"" % self.https_url, headers={""Baz"": ""quux""}
            )
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") is None
            assert returned_headers.get(""Baz"") == ""quux""
            assert returned_headers.get(""Hickory"") is None
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.https_host,
                self.https_port,
            )

    def test_https_headers_forwarding_for_https(self):
        with proxy_from_url(
            self.https_proxy_url,
            headers={""Foo"": ""bar""},
            proxy_headers={""Hickory"": ""dickory""},
            ca_certs=DEFAULT_CA,
            use_forwarding_for_https=True,
        ) as http:

            r = http.request_encode_url(""GET"", ""%s/headers"" % self.https_url)
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""
            assert returned_headers.get(""Hickory"") == ""dickory""
            assert returned_headers.get(""Host"") == ""%s:%s"" % (
                self.https_host,
                self.https_port,
            )

    def test_headerdict(self):
        default_headers = HTTPHeaderDict(a=""b"")
        proxy_headers = HTTPHeaderDict()
        proxy_headers.add(""foo"", ""bar"")

        with proxy_from_url(
            self.proxy_url, headers=default_headers, proxy_headers=proxy_headers
        ) as http:
            request_headers = HTTPHeaderDict(baz=""quux"")
            r = http.request(
                ""GET"", ""%s/headers"" % self.http_url, headers=request_headers
            )
            returned_headers = json.loads(r.data.decode())
            assert returned_headers.get(""Foo"") == ""bar""
            assert returned_headers.get(""Baz"") == ""quux""

    def test_proxy_pooling(self):
        with proxy_from_url(self.proxy_url, cert_reqs=""NONE"") as http:
            for x in range(2):
                http.urlopen(""GET"", self.http_url)
            assert len(http.pools) == 1

            for x in range(2):
                http.urlopen(""GET"", self.http_url_alt)
            assert len(http.pools) == 1

            for x in range(2):
                http.urlopen(""GET"", self.https_url)
            assert len(http.pools) == 2

            for x in range(2):
                http.urlopen(""GET"", self.https_url_alt)
            assert len(http.pools) == 3

    def test_proxy_pooling_ext(self):
        with proxy_from_url(self.proxy_url) as http:
            hc1 = http.connection_from_url(self.http_url)
            hc2 = http.connection_from_host(self.http_host, self.http_port)
            hc3 = http.connection_from_url(self.http_url_alt)
            hc4 = http.connection_from_host(self.http_host_alt, self.http_port)
            assert hc1 == hc2
            assert hc2 == hc3
            assert hc3 == hc4

            sc1 = http.connection_from_url(self.https_url)
            sc2 = http.connection_from_host(
                self.https_host, self.https_port, scheme=""https""
            )
            sc3 = http.connection_from_url(self.https_url_alt)
            sc4 = http.connection_from_host(
                self.https_host_alt, self.https_port, scheme=""https""
            )
            assert sc1 == sc2
            assert sc2 != sc3
            assert sc3 == sc4

    @pytest.mark.timeout(0.5)
    @requires_network
    def test_https_proxy_timeout(self):
        with proxy_from_url(""https://{host}"".format(host=TARPIT_HOST)) as https:
            with pytest.raises(MaxRetryError) as e:
                https.request(""GET"", self.http_url, timeout=SHORT_TIMEOUT)
            assert type(e.value.reason) == ConnectTimeoutError

    @pytest.mark.timeout(0.5)
    @requires_network
    def test_https_proxy_pool_timeout(self):
        with proxy_from_url(
            ""https://{host}"".format(host=TARPIT_HOST), timeout=SHORT_TIMEOUT
        ) as https:
            with pytest.raises(MaxRetryError) as e:
                https.request(""GET"", self.http_url)
            assert type(e.value.reason) == ConnectTimeoutError

    def test_scheme_host_case_insensitive(self):
        """"""Assert that upper-case schemes and hosts are normalized.""""""
        with proxy_from_url(self.proxy_url.upper(), ca_certs=DEFAULT_CA) as http:
            r = http.request(""GET"", ""%s/"" % self.http_url.upper())
            assert r.status == 200

            r = http.request(""GET"", ""%s/"" % self.https_url.upper())
            assert r.status == 200

    @pytest.mark.parametrize(
        ""url, error_msg"",
        [
            (
                ""127.0.0.1"",
                ""Proxy URL had no scheme, should start with http:// or https://"",
            ),
            (
                ""localhost:8080"",
                ""Proxy URL had no scheme, should start with http:// or https://"",
            ),
            (
                ""ftp://google.com"",
                ""Proxy URL had unsupported scheme ftp, should use http:// or https://"",
            ),
        ],
    )
    def test_invalid_schema(self, url, error_msg):
        with pytest.raises(ProxySchemeUnknown, match=error_msg):
            proxy_from_url(url)


@pytest.mark.skipif(not HAS_IPV6, reason=""Only runs on IPv6 systems"")
class TestIPv6HTTPProxyManager(IPv6HTTPDummyProxyTestCase):
    @classmethod
    def setup_class(cls):
        HTTPDummyProxyTestCase.setup_class()
        cls.http_url = ""http://%s:%d"" % (cls.http_host, cls.http_port)
        cls.http_url_alt = ""http://%s:%d"" % (cls.http_host_alt, cls.http_port)
        cls.https_url = ""https://%s:%d"" % (cls.https_host, cls.https_port)
        cls.https_url_alt = ""https://%s:%d"" % (cls.https_host_alt, cls.https_port)
        cls.proxy_url = ""http://[%s]:%d"" % (cls.proxy_host, cls.proxy_port)

    def test_basic_ipv6_proxy(self):
        with proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA) as http:
            r = http.request(""GET"", ""%s/"" % self.http_url)
            assert r.status == 200

            r = http.request(""GET"", ""%s/"" % self.https_url)
            assert r.status == 200


class TestHTTPSProxyVerification:
    @onlyPy3
    def test_https_proxy_hostname_verification(self, no_localhost_san_server):
        bad_server = no_localhost_san_server
        bad_proxy_url = ""https://%s:%s"" % (bad_server.host, bad_server.port)

        # An exception will be raised before we contact the destination domain.
        test_url = ""testing.com""
        with proxy_from_url(bad_proxy_url, ca_certs=bad_server.ca_certs) as https:
            with pytest.raises(MaxRetryError) as e:
                https.request(""GET"", ""http://%s/"" % test_url)
            assert isinstance(e.value.reason, SSLError)
            assert ""hostname 'localhost' doesn't match"" in str(e.value.reason)

            with pytest.raises(MaxRetryError) as e:
                https.request(""GET"", ""https://%s/"" % test_url)
            assert isinstance(e.value.reason, SSLError)
            assert ""hostname 'localhost' doesn't match"" in str(
                e.value.reason
            ) or ""Hostname mismatch"" in str(e.value.reason)",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR, VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR .. VAR VAR, VAR  VAR = VAR.VAR.VAR VAR VAR(VAR): @VAR VAR VAR(VAR): VAR(VAR, VAR).VAR() VAR.VAR = ""VAR: VAR.VAR = ""VAR: VAR.VAR = ""VAR: VAR.VAR = ""VAR: VAR.VAR = ""VAR: VAR.VAR = ""VAR: VAR.VAR, VAR.VAR, )  VAR.VAR = VAR.VAR() VAR = VAR.VAR() VAR.VAR = VAR.VAR.VAR(VAR.VAR, ""VAR.VAR"") VAR.VAR.VAR(VAR.VAR) @VAR VAR VAR(VAR): VAR(VAR, VAR).VAR() VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR VAR(VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 @VAR VAR VAR(VAR): VAR VAR(VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 @VAR VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR) VAR VAR( VAR.VAR, VAR=VAR, VAR=VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 @VAR VAR VAR(VAR): VAR VAR(VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR ""VAR VAR VAR VAR VAR 2"" VAR VAR(VAR.VAR) @VAR @VAR VAR VAR(VAR): VAR VAR(VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR ""VAR'VAR VAR VAR VAR-VAR VAR"" VAR VAR(VAR.VAR) @VAR @VAR VAR VAR(VAR): VAR VAR(VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR ""VAR'VAR VAR VAR VAR-VAR VAR"" VAR VAR(VAR.VAR) VAR VAR(VAR): VAR VAR( VAR.VAR, VAR=VAR, VAR=VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR VAR(VAR.VAR) VAR VAR: VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR = VAR.VAR() VAR: VAR.VAR(VAR, ""VAR"", ""/"") VAR = VAR.VAR.VAR( VAR.VAR, VAR.VAR ) VAR VAR == 0, ( ""VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR, VAR VAR %VAR"" % VAR ) VAR: VAR.VAR() VAR VAR(VAR): VAR, VAR = VAR() VAR VAR( ""VAR: ) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR(VAR.VAR.VAR) == VAR VAR VAR(VAR): VAR VAR( VAR(VAR.VAR), VAR=VAR ) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR VAR(VAR): VAR VAR( VAR.VAR, VAR=""VAR"", VAR=VAR.VAR ) VAR VAR: VAR = VAR.VAR(""VAR"", VAR.VAR, VAR.VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR(VAR.VAR.VAR, VAR) VAR ""VAR VAR VAR"" VAR VAR(VAR.VAR.VAR), ( ""VAR 'VAR VAR VAR', VAR VAR: %VAR"" % VAR.VAR.VAR ) VAR = VAR( VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR = VAR.VAR(""VAR"", VAR.VAR, VAR.VAR) VAR = VAR.VAR() VAR VAR.VAR == VAR VAR.VAR(""VAR"", ""/"")  VAR = VAR( VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR = VAR.VAR(""VAR"", ""127.0.0.1"", VAR.VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR(VAR.VAR.VAR, VAR) VAR ""VAR'VAR VAR"" VAR VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/"" % VAR.VAR}, VAR=VAR, ) VAR VAR.VAR == 303 VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/"" % VAR.VAR}, ) VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR VAR!"" VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR: VAR = ""%VAR/VAR?VAR=VAR"" % VAR.VAR VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": VAR}, VAR=0, ) VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/VAR?VAR=VAR"" % VAR.VAR}, VAR=1, ) VAR VAR.VAR.VAR != VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR, VAR=VAR) VAR VAR: VAR = ""%VAR/VAR?VAR=VAR"" % VAR.VAR VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": VAR}, VAR=0, ) VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""%VAR/VAR?VAR=VAR"" % VAR.VAR}, VAR=1, ) VAR VAR.VAR.VAR == VAR.VAR VAR VAR(VAR): VAR VAR( VAR.VAR, VAR={""VAR"": ""VAR""}, VAR={""VAR"": ""VAR""}, VAR=VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""VAR""} ) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""VAR""} ) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""VAR""} ) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""VAR""} ) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) @VAR VAR VAR(VAR): VAR VAR( VAR.VAR, VAR={""VAR"": ""VAR""}, VAR={""VAR"": ""VAR""}, VAR=VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR={""VAR"": ""VAR""} ) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") VAR VAR VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR VAR(VAR): VAR VAR( VAR.VAR, VAR={""VAR"": ""VAR""}, VAR={""VAR"": ""VAR""}, VAR=VAR, VAR=VAR, ) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/VAR"" % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""%VAR:%VAR"" % ( VAR.VAR, VAR.VAR, ) VAR VAR(VAR): VAR = VAR(VAR=""VAR"") VAR = VAR() VAR.VAR(""VAR"", ""VAR"") VAR VAR( VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR = VAR(VAR=""VAR"") VAR = VAR.VAR( ""VAR"", ""%VAR/VAR"" % VAR.VAR, VAR=VAR ) VAR = VAR.VAR(VAR.VAR.VAR()) VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR.VAR(""VAR"") == ""VAR"" VAR VAR(VAR): VAR VAR(VAR.VAR, VAR=""VAR"") VAR VAR: VAR VAR VAR VAR(2): VAR.VAR(""VAR"", VAR.VAR) VAR VAR(VAR.VAR) == 1 VAR VAR VAR VAR(2): VAR.VAR(""VAR"", VAR.VAR) VAR VAR(VAR.VAR) == 1 VAR VAR VAR VAR(2): VAR.VAR(""VAR"", VAR.VAR) VAR VAR(VAR.VAR) == 2 VAR VAR VAR VAR(2): VAR.VAR(""VAR"", VAR.VAR) VAR VAR(VAR.VAR) == 3 VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR: VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR VAR == VAR VAR VAR == VAR VAR VAR == VAR VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR( VAR.VAR, VAR.VAR, VAR=""VAR"" ) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR( VAR.VAR, VAR.VAR, VAR=""VAR"" ) VAR VAR == VAR VAR VAR != VAR VAR VAR == VAR @VAR.VAR.VAR(0.5) @VAR VAR VAR(VAR): VAR VAR(""VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", VAR.VAR, VAR=VAR) VAR VAR(VAR.VAR.VAR) == VAR @VAR.VAR.VAR(0.5) @VAR VAR VAR(VAR): VAR VAR( ""VAR: ) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", VAR.VAR) VAR VAR(VAR.VAR.VAR) == VAR VAR VAR(VAR): """"""VAR VAR VAR-VAR VAR VAR VAR VAR VAR."""""" VAR VAR(VAR.VAR.VAR(), VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR.VAR()) VAR VAR.VAR == 200 VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR.VAR()) VAR VAR.VAR == 200 @VAR.VAR.VAR( ""VAR, VAR"", [ ( ""127.0.0.1"", ""VAR VAR VAR VAR VAR, VAR VAR VAR VAR: ), ( ""VAR:8080"", ""VAR VAR VAR VAR VAR, VAR VAR VAR VAR: ), ( ""VAR: ""VAR VAR VAR VAR VAR VAR, VAR VAR VAR: ), ], ) VAR VAR(VAR, VAR, VAR): VAR VAR.VAR(VAR, VAR=VAR): VAR(VAR) @VAR.VAR.VAR(VAR VAR, VAR=""VAR VAR VAR VAR VAR"") VAR VAR(VAR): @VAR VAR VAR(VAR): VAR.VAR() VAR.VAR = ""VAR: VAR.VAR = ""VAR: VAR.VAR = ""VAR: VAR.VAR = ""VAR: VAR.VAR = ""VAR: VAR VAR(VAR): VAR VAR(VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR = VAR.VAR(""VAR"", ""%VAR/"" % VAR.VAR) VAR VAR.VAR == 200 VAR VAR: @VAR VAR VAR(VAR, VAR): VAR = VAR VAR = ""VAR:  VAR = ""VAR.VAR"" VAR VAR(VAR, VAR=VAR.VAR) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""VAR: VAR VAR(VAR.VAR.VAR, VAR) VAR ""VAR 'VAR' VAR'VAR VAR"" VAR VAR(VAR.VAR.VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""VAR: VAR VAR(VAR.VAR.VAR, VAR) VAR ""VAR 'VAR' VAR'VAR VAR"" VAR VAR( VAR.VAR.VAR ) VAR ""VAR VAR"" VAR VAR(VAR.VAR.VAR) ",8
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/with_dummyserver/test_socketlevel.py,"# TODO: Break this module up into pieces. Maybe group by functionality tested
# rather than the socket level-ness of it.
from dummyserver.server import (
    DEFAULT_CA,
    DEFAULT_CERTS,
    encrypt_key_pem,
    get_unreachable_address,
)
from dummyserver.testcase import SocketDummyServerTestCase, consume_socket
from urllib3 import HTTPConnectionPool, HTTPSConnectionPool, util
from urllib3._collections import HTTPHeaderDict
from urllib3.connection import HTTPConnection, _get_default_user_agent
from urllib3.exceptions import (
    MaxRetryError,
    ProtocolError,
    ProxyError,
    ReadTimeoutError,
    SSLError,
)
from urllib3.packages.six.moves import http_client as httplib
from urllib3.poolmanager import proxy_from_url
from urllib3.util import ssl_, ssl_wrap_socket
from urllib3.util.retry import Retry
from urllib3.util.timeout import Timeout

from .. import LogRecorder, has_alpn, onlyPy3

try:
    from mimetools import Message as MimeToolMessage
except ImportError:

    class MimeToolMessage(object):
        pass


import os
import os.path
import select
import shutil
import socket
import ssl
import tempfile
from collections import OrderedDict
from test import (
    LONG_TIMEOUT,
    SHORT_TIMEOUT,
    notPyPy2,
    notSecureTransport,
    notWindows,
    requires_ssl_context_keyfile_password,
    resolvesLocalhostFQDN,
)
from threading import Event

import mock
import pytest
import trustme

# Retry failed tests
pytestmark = pytest.mark.flaky


class TestCookies(SocketDummyServerTestCase):
    def test_multi_setcookie(self):
        def multicookie_response_handler(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            sock.send(
                b""HTTP/1.1 200 OK\r\n""
                b""Set-Cookie: foo=1\r\n""
                b""Set-Cookie: bar=1\r\n""
                b""\r\n""
            )
            sock.close()

        self._start_server(multicookie_response_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/"", retries=0)
            assert r.headers == {""set-cookie"": ""foo=1, bar=1""}
            assert r.headers.getlist(""set-cookie"") == [""foo=1"", ""bar=1""]


class TestSNI(SocketDummyServerTestCase):
    def test_hostname_in_first_request_packet(self):
        if not util.HAS_SNI:
            pytest.skip(""SNI-support not available"")
        done_receiving = Event()
        self.buf = b""""

        def socket_handler(listener):
            sock = listener.accept()[0]

            self.buf = sock.recv(65536)  # We only accept one packet
            done_receiving.set()  # let the test know it can proceed
            sock.close()

        self._start_server(socket_handler)
        with HTTPSConnectionPool(self.host, self.port) as pool:
            try:
                pool.request(""GET"", ""/"", retries=0)
            except MaxRetryError:  # We are violating the protocol
                pass
            successful = done_receiving.wait(LONG_TIMEOUT)
            assert successful, ""Timed out waiting for connection accept""
            assert (
                self.host.encode(""ascii"") in self.buf
            ), ""missing hostname in SSL handshake""


class TestALPN(SocketDummyServerTestCase):
    def test_alpn_protocol_in_first_request_packet(self):
        if not has_alpn():
            pytest.skip(""ALPN-support not available"")

        done_receiving = Event()
        self.buf = b""""

        def socket_handler(listener):
            sock = listener.accept()[0]

            self.buf = sock.recv(65536)  # We only accept one packet
            done_receiving.set()  # let the test know it can proceed
            sock.close()

        self._start_server(socket_handler)
        with HTTPSConnectionPool(self.host, self.port) as pool:
            try:
                pool.request(""GET"", ""/"", retries=0)
            except MaxRetryError:  # We are violating the protocol
                pass
            successful = done_receiving.wait(LONG_TIMEOUT)
            assert successful, ""Timed out waiting for connection accept""
            for protocol in util.ALPN_PROTOCOLS:
                assert (
                    protocol.encode(""ascii"") in self.buf
                ), ""missing ALPN protocol in SSL handshake""


class TestClientCerts(SocketDummyServerTestCase):
    """"""
    Tests for client certificate support.
    """"""

    @classmethod
    def setup_class(cls):
        cls.tmpdir = tempfile.mkdtemp()
        ca = trustme.CA()
        cert = ca.issue_cert(u""localhost"")
        encrypted_key = encrypt_key_pem(cert.private_key_pem, b""letmein"")

        cls.ca_path = os.path.join(cls.tmpdir, ""ca.pem"")
        cls.cert_combined_path = os.path.join(cls.tmpdir, ""server.combined.pem"")
        cls.cert_path = os.path.join(cls.tmpdir, ""server.pem"")
        cls.key_path = os.path.join(cls.tmpdir, ""key.pem"")
        cls.password_key_path = os.path.join(cls.tmpdir, ""password_key.pem"")

        ca.cert_pem.write_to_path(cls.ca_path)
        cert.private_key_and_cert_chain_pem.write_to_path(cls.cert_combined_path)
        cert.cert_chain_pems[0].write_to_path(cls.cert_path)
        cert.private_key_pem.write_to_path(cls.key_path)
        encrypted_key.write_to_path(cls.password_key_path)

    def teardown_class(cls):
        shutil.rmtree(cls.tmpdir)

    def _wrap_in_ssl(self, sock):
        """"""
        Given a single socket, wraps it in TLS.
        """"""
        return ssl.wrap_socket(
            sock,
            ssl_version=ssl.PROTOCOL_SSLv23,
            cert_reqs=ssl.CERT_REQUIRED,
            ca_certs=self.ca_path,
            certfile=self.cert_path,
            keyfile=self.key_path,
            server_side=True,
        )

    def test_client_certs_two_files(self):
        """"""
        Having a client cert in a separate file to its associated key works
        properly.
        """"""
        done_receiving = Event()
        client_certs = []

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock = self._wrap_in_ssl(sock)

            client_certs.append(sock.getpeercert())

            data = b""""
            while not data.endswith(b""\r\n\r\n""):
                data += sock.recv(8192)

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: testsocket\r\n""
                b""Connection: close\r\n""
                b""Content-Length: 6\r\n""
                b""\r\n""
                b""Valid!""
            )

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        with HTTPSConnectionPool(
            self.host,
            self.port,
            cert_file=self.cert_path,
            key_file=self.key_path,
            cert_reqs=""REQUIRED"",
            ca_certs=self.ca_path,
        ) as pool:
            pool.request(""GET"", ""/"", retries=0)
            done_receiving.set()

            assert len(client_certs) == 1

    def test_client_certs_one_file(self):
        """"""
        Having a client cert and its associated private key in just one file
        works properly.
        """"""
        done_receiving = Event()
        client_certs = []

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock = self._wrap_in_ssl(sock)

            client_certs.append(sock.getpeercert())

            data = b""""
            while not data.endswith(b""\r\n\r\n""):
                data += sock.recv(8192)

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: testsocket\r\n""
                b""Connection: close\r\n""
                b""Content-Length: 6\r\n""
                b""\r\n""
                b""Valid!""
            )

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        with HTTPSConnectionPool(
            self.host,
            self.port,
            cert_file=self.cert_combined_path,
            cert_reqs=""REQUIRED"",
            ca_certs=self.ca_path,
        ) as pool:
            pool.request(""GET"", ""/"", retries=0)
            done_receiving.set()

            assert len(client_certs) == 1

    def test_missing_client_certs_raises_error(self):
        """"""
        Having client certs not be present causes an error.
        """"""
        done_receiving = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            try:
                self._wrap_in_ssl(sock)
            except ssl.SSLError:
                pass

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        with HTTPSConnectionPool(
            self.host, self.port, cert_reqs=""REQUIRED"", ca_certs=self.ca_path
        ) as pool:
            with pytest.raises(MaxRetryError):
                pool.request(""GET"", ""/"", retries=0)
                done_receiving.set()
            done_receiving.set()

    @requires_ssl_context_keyfile_password
    def test_client_cert_with_string_password(self):
        self.run_client_cert_with_password_test(u""letmein"")

    @requires_ssl_context_keyfile_password
    def test_client_cert_with_bytes_password(self):
        self.run_client_cert_with_password_test(b""letmein"")

    def run_client_cert_with_password_test(self, password):
        """"""
        Tests client certificate password functionality
        """"""
        done_receiving = Event()
        client_certs = []

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock = self._wrap_in_ssl(sock)

            client_certs.append(sock.getpeercert())

            data = b""""
            while not data.endswith(b""\r\n\r\n""):
                data += sock.recv(8192)

            sock.sendall(
                b""HTTP/1.1 200 OK\r\n""
                b""Server: testsocket\r\n""
                b""Connection: close\r\n""
                b""Content-Length: 6\r\n""
                b""\r\n""
                b""Valid!""
            )

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        ssl_context = ssl_.SSLContext(ssl_.PROTOCOL_SSLv23)
        ssl_context.load_cert_chain(
            certfile=self.cert_path, keyfile=self.password_key_path, password=password
        )

        with HTTPSConnectionPool(
            self.host,
            self.port,
            ssl_context=ssl_context,
            cert_reqs=""REQUIRED"",
            ca_certs=self.ca_path,
        ) as pool:
            pool.request(""GET"", ""/"", retries=0)
            done_receiving.set()

            assert len(client_certs) == 1

    @requires_ssl_context_keyfile_password
    def test_load_keyfile_with_invalid_password(self):
        context = ssl_.SSLContext(ssl_.PROTOCOL_SSLv23)

        # Different error is raised depending on context.
        if ssl_.IS_PYOPENSSL:
            from OpenSSL.SSL import Error

            expected_error = Error
        else:
            expected_error = ssl.SSLError

        with pytest.raises(expected_error):
            context.load_cert_chain(
                certfile=self.cert_path,
                keyfile=self.password_key_path,
                password=b""letmei"",
            )


class TestSocketClosing(SocketDummyServerTestCase):
    def test_recovery_when_server_closes_connection(self):
        # Does the pool work seamlessly if an open connection in the
        # connection pool gets hung up on by the server, then reaches
        # the front of the queue again?

        done_closing = Event()

        def socket_handler(listener):
            for i in 0, 1:
                sock = listener.accept()[0]

                buf = b""""
                while not buf.endswith(b""\r\n\r\n""):
                    buf = sock.recv(65536)

                body = ""Response %d"" % i
                sock.send(
                    (
                        ""HTTP/1.1 200 OK\r\n""
                        ""Content-Type: text/plain\r\n""
                        ""Content-Length: %d\r\n""
                        ""\r\n""
                        ""%s"" % (len(body), body)
                    ).encode(""utf-8"")
                )

                sock.close()  # simulate a server timing out, closing socket
                done_closing.set()  # let the test know it can proceed

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            response = pool.request(""GET"", ""/"", retries=0)
            assert response.status == 200
            assert response.data == b""Response 0""

            done_closing.wait()  # wait until the socket in our pool gets closed

            response = pool.request(""GET"", ""/"", retries=0)
            assert response.status == 200
            assert response.data == b""Response 1""

    def test_connection_refused(self):
        # Does the pool retry if there is no listener on the port?
        host, port = get_unreachable_address()
        with HTTPConnectionPool(host, port, maxsize=3, block=True) as http:
            with pytest.raises(MaxRetryError):
                http.request(""GET"", ""/"", retries=0, release_conn=False)
            assert http.pool.qsize() == http.pool.maxsize

    def test_connection_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            while not sock.recv(65536).endswith(b""\r\n\r\n""):
                pass

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(
            self.host,
            self.port,
            timeout=SHORT_TIMEOUT,
            retries=False,
            maxsize=3,
            block=True,
        ) as http:
            try:
                with pytest.raises(ReadTimeoutError):
                    http.request(""GET"", ""/"", release_conn=False)
            finally:
                timed_out.set()

            assert http.pool.qsize() == http.pool.maxsize

    def test_read_timeout_dont_retry_method_not_in_allowlist(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock.recv(65536)
            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(
            self.host, self.port, timeout=LONG_TIMEOUT, retries=True
        ) as pool:
            try:
                with pytest.raises(ReadTimeoutError):
                    pool.request(""POST"", ""/"")
            finally:
                timed_out.set()

    def test_https_connection_read_timeout(self):
        """"""Handshake timeouts should fail with a Timeout""""""
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            while not sock.recv(65536):
                pass

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        with HTTPSConnectionPool(
            self.host, self.port, timeout=LONG_TIMEOUT, retries=False
        ) as pool:
            try:
                with pytest.raises(ReadTimeoutError):
                    pool.request(""GET"", ""/"")
            finally:
                timed_out.set()

    def test_timeout_errors_cause_retries(self):
        def socket_handler(listener):
            sock_timeout = listener.accept()[0]

            # Wait for a second request before closing the first socket.
            sock = listener.accept()[0]
            sock_timeout.close()

            # Second request.
            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            # Now respond immediately.
            body = ""Response 2""
            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n""
                    ""%s"" % (len(body), body)
                ).encode(""utf-8"")
            )

            sock.close()

        # In situations where the main thread throws an exception, the server
        # thread can hang on an accept() call. This ensures everything times
        # out within 1 second. This should be long enough for any socket
        # operations in the test suite to complete
        default_timeout = socket.getdefaulttimeout()
        socket.setdefaulttimeout(1)

        try:
            self._start_server(socket_handler)
            t = Timeout(connect=LONG_TIMEOUT, read=LONG_TIMEOUT)
            with HTTPConnectionPool(self.host, self.port, timeout=t) as pool:
                response = pool.request(""GET"", ""/"", retries=1)
                assert response.status == 200
                assert response.data == b""Response 2""
        finally:
            socket.setdefaulttimeout(default_timeout)

    def test_delayed_body_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b""""
            body = ""Hi""
            while not buf.endswith(b""\r\n\r\n""):
                buf = sock.recv(65536)
            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n"" % len(body)
                ).encode(""utf-8"")
            )

            timed_out.wait()
            sock.send(body.encode(""utf-8""))
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            response = pool.urlopen(
                ""GET"",
                ""/"",
                retries=0,
                preload_content=False,
                timeout=Timeout(connect=1, read=LONG_TIMEOUT),
            )
            try:
                with pytest.raises(ReadTimeoutError):
                    response.read()
            finally:
                timed_out.set()

    def test_delayed_body_read_timeout_with_preload(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b""""
            body = ""Hi""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)
            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n"" % len(body)
                ).encode(""utf-8"")
            )

            timed_out.wait(5)
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            try:
                with pytest.raises(ReadTimeoutError):
                    timeout = Timeout(connect=LONG_TIMEOUT, read=SHORT_TIMEOUT)
                    pool.urlopen(""GET"", ""/"", retries=False, timeout=timeout)
            finally:
                timed_out.set()

    def test_incomplete_response(self):
        body = ""Response""
        partial_body = body[:2]

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf = sock.recv(65536)

            # Send partial response and close socket.
            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n""
                    ""%s"" % (len(body), partial_body)
                ).encode(""utf-8"")
            )
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            response = pool.request(""GET"", ""/"", retries=0, preload_content=False)
            with pytest.raises(ProtocolError):
                response.read()

    def test_retry_weird_http_version(self):
        """"""Retry class should handle httplib.BadStatusLine errors properly""""""

        def socket_handler(listener):
            sock = listener.accept()[0]
            # First request.
            # Pause before responding so the first request times out.
            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            # send unknown http protocol
            body = ""bad http 0.5 response""
            sock.send(
                (
                    ""HTTP/0.5 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n""
                    ""%s"" % (len(body), body)
                ).encode(""utf-8"")
            )
            sock.close()

            # Second request.
            sock = listener.accept()[0]
            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            # Now respond immediately.
            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n""
                    ""foo"" % (len(""foo""))
                ).encode(""utf-8"")
            )

            sock.close()  # Close the socket.

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            retry = Retry(read=1)
            response = pool.request(""GET"", ""/"", retries=retry)
            assert response.status == 200
            assert response.data == b""foo""

    def test_connection_cleanup_on_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b""""
            body = ""Hi""
            while not buf.endswith(b""\r\n\r\n""):
                buf = sock.recv(65536)
            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n"" % len(body)
                ).encode(""utf-8"")
            )

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            poolsize = pool.pool.qsize()
            response = pool.urlopen(
                ""GET"", ""/"", retries=0, preload_content=False, timeout=LONG_TIMEOUT
            )
            try:
                with pytest.raises(ReadTimeoutError):
                    response.read()
                assert poolsize == pool.pool.qsize()
            finally:
                timed_out.set()

    def test_connection_cleanup_on_protocol_error_during_read(self):
        body = ""Response""
        partial_body = body[:2]

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf = sock.recv(65536)

            # Send partial response and close socket.
            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n""
                    ""%s"" % (len(body), partial_body)
                ).encode(""utf-8"")
            )
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            poolsize = pool.pool.qsize()
            response = pool.request(""GET"", ""/"", retries=0, preload_content=False)

            with pytest.raises(ProtocolError):
                response.read()
            assert poolsize == pool.pool.qsize()

    def test_connection_closed_on_read_timeout_preload_false(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf = sock.recv(65535)

            # Send partial chunked response and then hang.
            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Transfer-Encoding: chunked\r\n""
                    ""\r\n""
                    ""8\r\n""
                    ""12345678\r\n""
                ).encode(""utf-8"")
            )
            timed_out.wait(5)

            # Expect a new request, but keep hold of the old socket to avoid
            # leaking it. Because we don't want to hang this thread, we
            # actually use select.select to confirm that a new request is
            # coming in: this lets us time the thread out.
            rlist, _, _ = select.select([listener], [], [], 1)
            assert rlist
            new_sock = listener.accept()[0]

            # Consume request
            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf = new_sock.recv(65535)

            # Send complete chunked response.
            new_sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Transfer-Encoding: chunked\r\n""
                    ""\r\n""
                    ""8\r\n""
                    ""12345678\r\n""
                    ""0\r\n\r\n""
                ).encode(""utf-8"")
            )

            new_sock.close()
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            # First request should fail.
            response = pool.urlopen(
                ""GET"", ""/"", retries=0, preload_content=False, timeout=LONG_TIMEOUT
            )
            try:
                with pytest.raises(ReadTimeoutError):
                    response.read()
            finally:
                timed_out.set()

            # Second should succeed.
            response = pool.urlopen(
                ""GET"", ""/"", retries=0, preload_content=False, timeout=LONG_TIMEOUT
            )
            assert len(response.read()) == 8

    def test_closing_response_actually_closes_connection(self):
        done_closing = Event()
        complete = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf = sock.recv(65536)

            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: 0\r\n""
                    ""\r\n""
                ).encode(""utf-8"")
            )

            # Wait for the socket to close.
            done_closing.wait(timeout=LONG_TIMEOUT)

            # Look for the empty string to show that the connection got closed.
            # Don't get stuck in a timeout.
            sock.settimeout(LONG_TIMEOUT)
            new_data = sock.recv(65536)
            assert not new_data
            sock.close()
            complete.set()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            response = pool.request(""GET"", ""/"", retries=0, preload_content=False)
            assert response.status == 200
            response.close()

            done_closing.set()  # wait until the socket in our pool gets closed
            successful = complete.wait(timeout=LONG_TIMEOUT)
            assert successful, ""Timed out waiting for connection close""

    def test_release_conn_param_is_respected_after_timeout_retry(self):
        """"""For successful ```urlopen(release_conn=False)```,
        the connection isn't released, even after a retry.

        This test allows a retry: one request fails, the next request succeeds.

        This is a regression test for issue #651 [1], where the connection
        would be released if the initial request failed, even if a retry
        succeeded.

        [1] <https://github.com/urllib3/urllib3/issues/651>
        """"""

        def socket_handler(listener):
            sock = listener.accept()[0]
            consume_socket(sock)

            # Close the connection, without sending any response (not even the
            # HTTP status line). This will trigger a `Timeout` on the client,
            # inside `urlopen()`.
            sock.close()

            # Expect a new request. Because we don't want to hang this thread,
            # we actually use select.select to confirm that a new request is
            # coming in: this lets us time the thread out.
            rlist, _, _ = select.select([listener], [], [], 5)
            assert rlist
            sock = listener.accept()[0]
            consume_socket(sock)

            # Send complete chunked response.
            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Transfer-Encoding: chunked\r\n""
                    ""\r\n""
                    ""8\r\n""
                    ""12345678\r\n""
                    ""0\r\n\r\n""
                ).encode(""utf-8"")
            )

            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port, maxsize=1) as pool:
            # First request should fail, but the timeout and `retries=1` should
            # save it.
            response = pool.urlopen(
                ""GET"",
                ""/"",
                retries=1,
                release_conn=False,
                preload_content=False,
                timeout=LONG_TIMEOUT,
            )

            # The connection should still be on the response object, and none
            # should be in the pool. We opened two though.
            assert pool.num_connections == 2
            assert pool.pool.qsize() == 0
            assert response.connection is not None

            # Consume the data. This should put the connection back.
            response.read()
            assert pool.pool.qsize() == 1
            assert response.connection is None


class TestProxyManager(SocketDummyServerTestCase):
    def test_simple(self):
        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n""
                    ""%s"" % (len(buf), buf.decode(""utf-8""))
                ).encode(""utf-8"")
            )
            sock.close()

        self._start_server(echo_socket_handler)
        base_url = ""http://%s:%d"" % (self.host, self.port)
        with proxy_from_url(base_url) as proxy:
            r = proxy.request(""GET"", ""http://google.com/"")

            assert r.status == 200
            # FIXME: The order of the headers is not predictable right now. We
            # should fix that someday (maybe when we migrate to
            # OrderedDict/MultiDict).
            assert sorted(r.data.split(b""\r\n"")) == sorted(
                [
                    b""GET http://google.com/ HTTP/1.1"",
                    b""Host: google.com"",
                    b""Accept-Encoding: identity"",
                    b""Accept: */*"",
                    b""User-Agent: "" + _get_default_user_agent().encode(""utf-8""),
                    b"""",
                    b"""",
                ]
            )

    def test_headers(self):
        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n""
                    ""%s"" % (len(buf), buf.decode(""utf-8""))
                ).encode(""utf-8"")
            )
            sock.close()

        self._start_server(echo_socket_handler)
        base_url = ""http://%s:%d"" % (self.host, self.port)

        # Define some proxy headers.
        proxy_headers = HTTPHeaderDict({""For The Proxy"": ""YEAH!""})
        with proxy_from_url(base_url, proxy_headers=proxy_headers) as proxy:
            conn = proxy.connection_from_url(""http://www.google.com/"")

            r = conn.urlopen(""GET"", ""http://www.google.com/"", assert_same_host=False)

            assert r.status == 200
            # FIXME: The order of the headers is not predictable right now. We
            # should fix that someday (maybe when we migrate to
            # OrderedDict/MultiDict).
            assert b""For The Proxy: YEAH!\r\n"" in r.data

    def test_retries(self):
        close_event = Event()

        def echo_socket_handler(listener):
            sock = listener.accept()[0]
            # First request, which should fail
            sock.close()

            # Second request
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: %d\r\n""
                    ""\r\n""
                    ""%s"" % (len(buf), buf.decode(""utf-8""))
                ).encode(""utf-8"")
            )
            sock.close()
            close_event.set()

        self._start_server(echo_socket_handler)
        base_url = ""http://%s:%d"" % (self.host, self.port)

        with proxy_from_url(base_url) as proxy:
            conn = proxy.connection_from_url(""http://www.google.com"")

            r = conn.urlopen(
                ""GET"", ""http://www.google.com"", assert_same_host=False, retries=1
            )
            assert r.status == 200

            close_event.wait(timeout=LONG_TIMEOUT)
            with pytest.raises(ProxyError):
                conn.urlopen(
                    ""GET"",
                    ""http://www.google.com"",
                    assert_same_host=False,
                    retries=False,
                )

    def test_connect_reconn(self):
        def proxy_ssl_one(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)
            s = buf.decode(""utf-8"")
            if not s.startswith(""CONNECT ""):
                sock.send(
                    (
                        ""HTTP/1.1 405 Method not allowed\r\nAllow: CONNECT\r\n\r\n""
                    ).encode(""utf-8"")
                )
                sock.close()
                return

            if not s.startswith(""CONNECT %s:443"" % (self.host,)):
                sock.send((""HTTP/1.1 403 Forbidden\r\n\r\n"").encode(""utf-8""))
                sock.close()
                return

            sock.send((""HTTP/1.1 200 Connection Established\r\n\r\n"").encode(""utf-8""))
            ssl_sock = ssl.wrap_socket(
                sock,
                server_side=True,
                keyfile=DEFAULT_CERTS[""keyfile""],
                certfile=DEFAULT_CERTS[""certfile""],
                ca_certs=DEFAULT_CA,
            )

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += ssl_sock.recv(65536)

            ssl_sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: 2\r\n""
                    ""Connection: close\r\n""
                    ""\r\n""
                    ""Hi""
                ).encode(""utf-8"")
            )
            ssl_sock.close()

        def echo_socket_handler(listener):
            proxy_ssl_one(listener)
            proxy_ssl_one(listener)

        self._start_server(echo_socket_handler)
        base_url = ""http://%s:%d"" % (self.host, self.port)

        with proxy_from_url(base_url, ca_certs=DEFAULT_CA) as proxy:
            url = ""https://{0}"".format(self.host)
            conn = proxy.connection_from_url(url)
            r = conn.urlopen(""GET"", url, retries=0)
            assert r.status == 200
            r = conn.urlopen(""GET"", url, retries=0)
            assert r.status == 200

    def test_connect_ipv6_addr(self):
        ipv6_addr = ""2001:4998:c:a06::2:4008""

        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)
            s = buf.decode(""utf-8"")

            if s.startswith(""CONNECT [%s]:443"" % (ipv6_addr,)):
                sock.send(b""HTTP/1.1 200 Connection Established\r\n\r\n"")
                ssl_sock = ssl.wrap_socket(
                    sock,
                    server_side=True,
                    keyfile=DEFAULT_CERTS[""keyfile""],
                    certfile=DEFAULT_CERTS[""certfile""],
                )
                buf = b""""
                while not buf.endswith(b""\r\n\r\n""):
                    buf += ssl_sock.recv(65536)

                ssl_sock.send(
                    b""HTTP/1.1 200 OK\r\n""
                    b""Content-Type: text/plain\r\n""
                    b""Content-Length: 2\r\n""
                    b""Connection: close\r\n""
                    b""\r\n""
                    b""Hi""
                )
                ssl_sock.close()
            else:
                sock.close()

        self._start_server(echo_socket_handler)
        base_url = ""http://%s:%d"" % (self.host, self.port)

        with proxy_from_url(base_url, cert_reqs=""NONE"") as proxy:
            url = ""https://[{0}]"".format(ipv6_addr)
            conn = proxy.connection_from_url(url)
            try:
                r = conn.urlopen(""GET"", url, retries=0)
                assert r.status == 200
            except MaxRetryError:
                self.fail(""Invalid IPv6 format in HTTP CONNECT request"")


class TestSSL(SocketDummyServerTestCase):
    def test_ssl_failure_midway_through_conn(self):
        def socket_handler(listener):
            sock = listener.accept()[0]
            sock2 = sock.dup()
            ssl_sock = ssl.wrap_socket(
                sock,
                server_side=True,
                keyfile=DEFAULT_CERTS[""keyfile""],
                certfile=DEFAULT_CERTS[""certfile""],
                ca_certs=DEFAULT_CA,
            )

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += ssl_sock.recv(65536)

            # Deliberately send from the non-SSL socket.
            sock2.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: 2\r\n""
                    ""\r\n""
                    ""Hi""
                ).encode(""utf-8"")
            )
            sock2.close()
            ssl_sock.close()

        self._start_server(socket_handler)
        with HTTPSConnectionPool(self.host, self.port) as pool:
            with pytest.raises(MaxRetryError) as cm:
                pool.request(""GET"", ""/"", retries=0)
            assert isinstance(cm.value.reason, SSLError)

    @notSecureTransport
    def test_ssl_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            ssl_sock = ssl.wrap_socket(
                sock,
                server_side=True,
                keyfile=DEFAULT_CERTS[""keyfile""],
                certfile=DEFAULT_CERTS[""certfile""],
            )

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += ssl_sock.recv(65536)

            # Send incomplete message (note Content-Length)
            ssl_sock.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: 10\r\n""
                    ""\r\n""
                    ""Hi-""
                ).encode(""utf-8"")
            )
            timed_out.wait()

            sock.close()
            ssl_sock.close()

        self._start_server(socket_handler)
        with HTTPSConnectionPool(self.host, self.port, ca_certs=DEFAULT_CA) as pool:
            response = pool.urlopen(
                ""GET"", ""/"", retries=0, preload_content=False, timeout=LONG_TIMEOUT
            )
            try:
                with pytest.raises(ReadTimeoutError):
                    response.read()
            finally:
                timed_out.set()

    def test_ssl_failed_fingerprint_verification(self):
        def socket_handler(listener):
            for i in range(2):
                sock = listener.accept()[0]
                ssl_sock = ssl.wrap_socket(
                    sock,
                    server_side=True,
                    keyfile=DEFAULT_CERTS[""keyfile""],
                    certfile=DEFAULT_CERTS[""certfile""],
                    ca_certs=DEFAULT_CA,
                )

                ssl_sock.send(
                    b""HTTP/1.1 200 OK\r\n""
                    b""Content-Type: text/plain\r\n""
                    b""Content-Length: 5\r\n\r\n""
                    b""Hello""
                )

                ssl_sock.close()
                sock.close()

        self._start_server(socket_handler)
        # GitHub's fingerprint. Valid, but not matching.
        fingerprint = ""A0:C4:A7:46:00:ED:A7:2D:C0:BE:CB:9A:8C:B6:07:CA:58:EE:74:5E""

        def request():
            pool = HTTPSConnectionPool(
                self.host, self.port, assert_fingerprint=fingerprint
            )
            try:
                timeout = Timeout(connect=LONG_TIMEOUT, read=SHORT_TIMEOUT)
                response = pool.urlopen(
                    ""GET"", ""/"", preload_content=False, retries=0, timeout=timeout
                )
                response.read()
            finally:
                pool.close()

        with pytest.raises(MaxRetryError) as cm:
            request()
        assert isinstance(cm.value.reason, SSLError)
        # Should not hang, see https://github.com/urllib3/urllib3/issues/529
        with pytest.raises(MaxRetryError):
            request()

    def test_retry_ssl_error(self):
        def socket_handler(listener):
            # first request, trigger an SSLError
            sock = listener.accept()[0]
            sock2 = sock.dup()
            ssl_sock = ssl.wrap_socket(
                sock,
                server_side=True,
                keyfile=DEFAULT_CERTS[""keyfile""],
                certfile=DEFAULT_CERTS[""certfile""],
            )
            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += ssl_sock.recv(65536)

            # Deliberately send from the non-SSL socket to trigger an SSLError
            sock2.send(
                (
                    ""HTTP/1.1 200 OK\r\n""
                    ""Content-Type: text/plain\r\n""
                    ""Content-Length: 4\r\n""
                    ""\r\n""
                    ""Fail""
                ).encode(""utf-8"")
            )
            sock2.close()
            ssl_sock.close()

            # retried request
            sock = listener.accept()[0]
            ssl_sock = ssl.wrap_socket(
                sock,
                server_side=True,
                keyfile=DEFAULT_CERTS[""keyfile""],
                certfile=DEFAULT_CERTS[""certfile""],
            )
            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += ssl_sock.recv(65536)
            ssl_sock.send(
                b""HTTP/1.1 200 OK\r\n""
                b""Content-Type: text/plain\r\n""
                b""Content-Length: 7\r\n\r\n""
                b""Success""
            )
            ssl_sock.close()

        self._start_server(socket_handler)

        with HTTPSConnectionPool(self.host, self.port, ca_certs=DEFAULT_CA) as pool:
            response = pool.urlopen(""GET"", ""/"", retries=1)
            assert response.data == b""Success""

    def test_ssl_load_default_certs_when_empty(self):
        def socket_handler(listener):
            sock = listener.accept()[0]
            ssl_sock = ssl.wrap_socket(
                sock,
                server_side=True,
                keyfile=DEFAULT_CERTS[""keyfile""],
                certfile=DEFAULT_CERTS[""certfile""],
                ca_certs=DEFAULT_CA,
            )

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += ssl_sock.recv(65536)

            ssl_sock.send(
                b""HTTP/1.1 200 OK\r\n""
                b""Content-Type: text/plain\r\n""
                b""Content-Length: 5\r\n\r\n""
                b""Hello""
            )

            ssl_sock.close()
            sock.close()

        context = mock.create_autospec(ssl_.SSLContext)
        context.load_default_certs = mock.Mock()
        context.options = 0

        with mock.patch(""urllib3.util.ssl_.SSLContext"", lambda *_, **__: context):
            self._start_server(socket_handler)
            with HTTPSConnectionPool(self.host, self.port) as pool:
                with pytest.raises(MaxRetryError):
                    pool.request(""GET"", ""/"", timeout=SHORT_TIMEOUT)
                context.load_default_certs.assert_called_with()

    @notPyPy2
    def test_ssl_dont_load_default_certs_when_given(self):
        def socket_handler(listener):
            sock = listener.accept()[0]
            ssl_sock = ssl.wrap_socket(
                sock,
                server_side=True,
                keyfile=DEFAULT_CERTS[""keyfile""],
                certfile=DEFAULT_CERTS[""certfile""],
                ca_certs=DEFAULT_CA,
            )

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += ssl_sock.recv(65536)

            ssl_sock.send(
                b""HTTP/1.1 200 OK\r\n""
                b""Content-Type: text/plain\r\n""
                b""Content-Length: 5\r\n\r\n""
                b""Hello""
            )

            ssl_sock.close()
            sock.close()

        context = mock.create_autospec(ssl_.SSLContext)
        context.load_default_certs = mock.Mock()
        context.options = 0

        with mock.patch(""urllib3.util.ssl_.SSLContext"", lambda *_, **__: context):
            for kwargs in [
                {""ca_certs"": ""/a""},
                {""ca_cert_dir"": ""/a""},
                {""ca_certs"": ""a"", ""ca_cert_dir"": ""a""},
                {""ssl_context"": context},
            ]:

                self._start_server(socket_handler)

                with HTTPSConnectionPool(self.host, self.port, **kwargs) as pool:
                    with pytest.raises(MaxRetryError):
                        pool.request(""GET"", ""/"", timeout=SHORT_TIMEOUT)
                    context.load_default_certs.assert_not_called()

    def test_load_verify_locations_exception(self):
        """"""
        Ensure that load_verify_locations raises SSLError for all backends
        """"""
        with pytest.raises(SSLError):
            ssl_wrap_socket(None, ca_certs=""/tmp/fake-file"")

    def test_ssl_custom_validation_failure_terminates(self, tmpdir):
        """"""
        Ensure that the underlying socket is terminated if custom validation fails.
        """"""
        server_closed = Event()

        def is_closed_socket(sock):
            try:
                sock.settimeout(SHORT_TIMEOUT)  # Python 3
                sock.recv(1)  # Python 2
            except (OSError, socket.error):
                return True
            return False

        def socket_handler(listener):
            sock = listener.accept()[0]
            try:
                _ = ssl.wrap_socket(
                    sock,
                    server_side=True,
                    keyfile=DEFAULT_CERTS[""keyfile""],
                    certfile=DEFAULT_CERTS[""certfile""],
                    ca_certs=DEFAULT_CA,
                )
            except ssl.SSLError as e:
                assert ""alert unknown ca"" in str(e)
                if is_closed_socket(sock):
                    server_closed.set()

        self._start_server(socket_handler)

        # client uses a different ca
        other_ca = trustme.CA()
        other_ca_path = str(tmpdir / ""ca.pem"")
        other_ca.cert_pem.write_to_path(other_ca_path)

        with HTTPSConnectionPool(
            self.host, self.port, cert_reqs=""REQUIRED"", ca_certs=other_ca_path
        ) as pool:
            with pytest.raises(SSLError):
                pool.request(""GET"", ""/"", retries=False, timeout=LONG_TIMEOUT)
        assert server_closed.wait(LONG_TIMEOUT), ""The socket was not terminated""


class TestErrorWrapping(SocketDummyServerTestCase):
    def test_bad_statusline(self):
        self.start_response_handler(
            b""HTTP/1.1 Omg What Is This?\r\n"" b""Content-Length: 0\r\n"" b""\r\n""
        )
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            with pytest.raises(ProtocolError):
                pool.request(""GET"", ""/"")

    def test_unknown_protocol(self):
        self.start_response_handler(
            b""HTTP/1000 200 OK\r\n"" b""Content-Length: 0\r\n"" b""\r\n""
        )
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            with pytest.raises(ProtocolError):
                pool.request(""GET"", ""/"")


class TestHeaders(SocketDummyServerTestCase):
    @onlyPy3
    def test_httplib_headers_case_insensitive(self):
        self.start_response_handler(
            b""HTTP/1.1 200 OK\r\n""
            b""Content-Length: 0\r\n""
            b""Content-type: text/plain\r\n""
            b""\r\n""
        )
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            HEADERS = {""Content-Length"": ""0"", ""Content-type"": ""text/plain""}
            r = pool.request(""GET"", ""/"")
            assert HEADERS == dict(r.headers.items())  # to preserve case sensitivity

    def start_parsing_handler(self):
        self.parsed_headers = OrderedDict()
        self.received_headers = []

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            self.received_headers = [
                header for header in buf.split(b""\r\n"")[1:] if header
            ]

            for header in self.received_headers:
                (key, value) = header.split(b"": "")
                self.parsed_headers[key.decode(""ascii"")] = value.decode(""ascii"")

            sock.send(
                (""HTTP/1.1 204 No Content\r\nContent-Length: 0\r\n\r\n"").encode(""utf-8"")
            )

            sock.close()

        self._start_server(socket_handler)

    def test_headers_are_sent_with_the_original_case(self):
        headers = {""foo"": ""bar"", ""bAz"": ""quux""}

        self.start_parsing_handler()
        expected_headers = {
            ""Accept-Encoding"": ""identity"",
            ""Host"": ""{0}:{1}"".format(self.host, self.port),
            ""User-Agent"": _get_default_user_agent(),
        }
        expected_headers.update(headers)

        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            pool.request(""GET"", ""/"", headers=HTTPHeaderDict(headers))
            assert expected_headers == self.parsed_headers

    def test_ua_header_can_be_overridden(self):
        headers = {""uSeR-AgENt"": ""Definitely not urllib3!""}

        self.start_parsing_handler()
        expected_headers = {
            ""Accept-Encoding"": ""identity"",
            ""Host"": ""{0}:{1}"".format(self.host, self.port),
        }
        expected_headers.update(headers)

        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            pool.request(""GET"", ""/"", headers=HTTPHeaderDict(headers))
            assert expected_headers == self.parsed_headers

    def test_request_headers_are_sent_in_the_original_order(self):
        # NOTE: Probability this test gives a false negative is 1/(K!)
        K = 16
        # NOTE: Provide headers in non-sorted order (i.e. reversed)
        #       so that if the internal implementation tries to sort them,
        #       a change will be detected.
        expected_request_headers = [
            (u""X-Header-%d"" % i, str(i)) for i in reversed(range(K))
        ]

        def filter_non_x_headers(d):
            return [(k, v) for (k, v) in d.items() if k.startswith(""X-Header-"")]

        request_headers = OrderedDict()

        self.start_parsing_handler()

        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            pool.request(""GET"", ""/"", headers=OrderedDict(expected_request_headers))
            request_headers = filter_non_x_headers(self.parsed_headers)
            assert expected_request_headers == request_headers

    @resolvesLocalhostFQDN
    def test_request_host_header_ignores_fqdn_dot(self):
        self.start_parsing_handler()

        with HTTPConnectionPool(self.host + ""."", self.port, retries=False) as pool:
            pool.request(""GET"", ""/"")
            self.assert_header_received(
                self.received_headers, ""Host"", ""%s:%s"" % (self.host, self.port)
            )

    def test_response_headers_are_returned_in_the_original_order(self):
        # NOTE: Probability this test gives a false negative is 1/(K!)
        K = 16
        # NOTE: Provide headers in non-sorted order (i.e. reversed)
        #       so that if the internal implementation tries to sort them,
        #       a change will be detected.
        expected_response_headers = [
            (""X-Header-%d"" % i, str(i)) for i in reversed(range(K))
        ]

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            sock.send(
                b""HTTP/1.1 200 OK\r\n""
                + b""\r\n"".join(
                    [
                        (k.encode(""utf8"") + b"": "" + v.encode(""utf8""))
                        for (k, v) in expected_response_headers
                    ]
                )
                + b""\r\n""
            )
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""GET"", ""/"", retries=0)
            actual_response_headers = [
                (k, v) for (k, v) in r.headers.items() if k.startswith(""X-Header-"")
            ]
            assert expected_response_headers == actual_response_headers


@pytest.mark.skipif(
    issubclass(httplib.HTTPMessage, MimeToolMessage),
    reason=""Header parsing errors not available"",
)
class TestBrokenHeaders(SocketDummyServerTestCase):
    def _test_broken_header_parsing(self, headers, unparsed_data_check=None):
        self.start_response_handler(
            (
                b""HTTP/1.1 200 OK\r\n""
                b""Content-Length: 0\r\n""
                b""Content-type: text/plain\r\n""
            )
            + b""\r\n"".join(headers)
            + b""\r\n\r\n""
        )

        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            with LogRecorder() as logs:
                pool.request(""GET"", ""/"")

            for record in logs:
                if (
                    ""Failed to parse headers"" in record.msg
                    and pool._absolute_url(""/"") == record.args[0]
                ):
                    if (
                        unparsed_data_check is None
                        or unparsed_data_check in record.getMessage()
                    ):
                        return
            self.fail(""Missing log about unparsed headers"")

    def test_header_without_name(self):
        self._test_broken_header_parsing([b"": Value"", b""Another: Header""])

    def test_header_without_name_or_value(self):
        self._test_broken_header_parsing([b"":"", b""Another: Header""])

    def test_header_without_colon_or_value(self):
        self._test_broken_header_parsing(
            [b""Broken Header"", b""Another: Header""], ""Broken Header""
        )


class TestHeaderParsingContentType(SocketDummyServerTestCase):
    def _test_okay_header_parsing(self, header):
        self.start_response_handler(
            (b""HTTP/1.1 200 OK\r\n"" b""Content-Length: 0\r\n"") + header + b""\r\n\r\n""
        )

        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            with LogRecorder() as logs:
                pool.request(""GET"", ""/"")

            for record in logs:
                assert ""Failed to parse headers"" not in record.msg

    def test_header_text_plain(self):
        self._test_okay_header_parsing(b""Content-type: text/plain"")

    def test_header_message_rfc822(self):
        self._test_okay_header_parsing(b""Content-type: message/rfc822"")


class TestHEAD(SocketDummyServerTestCase):
    def test_chunked_head_response_does_not_hang(self):
        self.start_response_handler(
            b""HTTP/1.1 200 OK\r\n""
            b""Transfer-Encoding: chunked\r\n""
            b""Content-type: text/plain\r\n""
            b""\r\n""
        )
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            r = pool.request(""HEAD"", ""/"", timeout=LONG_TIMEOUT, preload_content=False)

            # stream will use the read_chunked method here.
            assert [] == list(r.stream())

    def test_empty_head_response_does_not_hang(self):
        self.start_response_handler(
            b""HTTP/1.1 200 OK\r\n""
            b""Content-Length: 256\r\n""
            b""Content-type: text/plain\r\n""
            b""\r\n""
        )
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            r = pool.request(""HEAD"", ""/"", timeout=LONG_TIMEOUT, preload_content=False)

            # stream will use the read method here.
            assert [] == list(r.stream())


class TestStream(SocketDummyServerTestCase):
    def test_stream_none_unchunked_response_does_not_hang(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            sock.send(
                b""HTTP/1.1 200 OK\r\n""
                b""Content-Length: 12\r\n""
                b""Content-type: text/plain\r\n""
                b""\r\n""
                b""hello, world""
            )
            done_event.wait(5)
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port, retries=False) as pool:
            r = pool.request(""GET"", ""/"", timeout=LONG_TIMEOUT, preload_content=False)

            # Stream should read to the end.
            assert [b""hello, world""] == list(r.stream(None))

            done_event.set()


class TestBadContentLength(SocketDummyServerTestCase):
    def test_enforce_content_length_get(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            sock.send(
                b""HTTP/1.1 200 OK\r\n""
                b""Content-Length: 22\r\n""
                b""Content-type: text/plain\r\n""
                b""\r\n""
                b""hello, world""
            )
            done_event.wait(LONG_TIMEOUT)
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port, maxsize=1) as conn:
            # Test stream read when content length less than headers claim
            get_response = conn.request(
                ""GET"", url=""/"", preload_content=False, enforce_content_length=True
            )
            data = get_response.stream(100)
            # Read ""good"" data before we try to read again.
            # This won't trigger till generator is exhausted.
            next(data)
            try:
                next(data)
                assert False
            except ProtocolError as e:
                assert ""12 bytes read, 10 more expected"" in str(e)

            done_event.set()

    def test_enforce_content_length_no_body(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b""""
            while not buf.endswith(b""\r\n\r\n""):
                buf += sock.recv(65536)

            sock.send(
                b""HTTP/1.1 200 OK\r\n""
                b""Content-Length: 22\r\n""
                b""Content-type: text/plain\r\n""
                b""\r\n""
            )
            done_event.wait(1)
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port, maxsize=1) as conn:
            # Test stream on 0 length body
            head_response = conn.request(
                ""HEAD"", url=""/"", preload_content=False, enforce_content_length=True
            )
            data = [chunk for chunk in head_response.stream(1)]
            assert len(data) == 0

            done_event.set()


class TestRetryPoolSizeDrainFail(SocketDummyServerTestCase):
    def test_pool_size_retry_drain_fail(self):
        def socket_handler(listener):
            for _ in range(2):
                sock = listener.accept()[0]
                while not sock.recv(65536).endswith(b""\r\n\r\n""):
                    pass

                # send a response with an invalid content length -- this causes
                # a ProtocolError to raise when trying to drain the connection
                sock.send(
                    b""HTTP/1.1 404 NOT FOUND\r\n""
                    b""Content-Length: 1000\r\n""
                    b""Content-Type: text/plain\r\n""
                    b""\r\n""
                )
                sock.close()

        self._start_server(socket_handler)
        retries = Retry(total=1, raise_on_status=False, status_forcelist=[404])
        with HTTPConnectionPool(
            self.host, self.port, maxsize=10, retries=retries, block=True
        ) as pool:
            pool.urlopen(""GET"", ""/not_found"", preload_content=False)
            assert pool.num_connections == 1


class TestBrokenPipe(SocketDummyServerTestCase):
    @notWindows
    def test_ignore_broken_pipe_errors(self, monkeypatch):
        # On Windows an aborted connection raises an error on
        # attempts to read data out of a socket that's been closed.
        sock_shut = Event()
        orig_connect = HTTPConnection.connect
        # a buffer that will cause two sendall calls
        buf = ""a"" * 1024 * 1024 * 4

        def connect_and_wait(*args, **kw):
            ret = orig_connect(*args, **kw)
            assert sock_shut.wait(5)
            return ret

        def socket_handler(listener):
            for i in range(2):
                sock = listener.accept()[0]
                sock.send(
                    b""HTTP/1.1 404 Not Found\r\n""
                    b""Connection: close\r\n""
                    b""Content-Length: 10\r\n""
                    b""\r\n""
                    b""xxxxxxxxxx""
                )
                sock.shutdown(socket.SHUT_RDWR)
                sock_shut.set()
                sock.close()

        monkeypatch.setattr(HTTPConnection, ""connect"", connect_and_wait)
        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            r = pool.request(""POST"", ""/"", body=buf)
            assert r.status == 404
            assert r.headers[""content-length""] == ""10""
            assert r.data == b""xxxxxxxxxx""

            r = pool.request(""POST"", ""/admin"", chunked=True, body=buf)
            assert r.status == 404
            assert r.headers[""content-length""] == ""10""
            assert r.data == b""xxxxxxxxxx""


class TestMultipartResponse(SocketDummyServerTestCase):
    def test_multipart_assert_header_parsing_no_defects(self):
        def socket_handler(listener):
            for _ in range(2):
                sock = listener.accept()[0]
                while not sock.recv(65536).endswith(b""\r\n\r\n""):
                    pass

                sock.sendall(
                    b""HTTP/1.1 404 Not Found\r\n""
                    b""Server: example.com\r\n""
                    b""Content-Type: multipart/mixed; boundary=36eeb8c4e26d842a\r\n""
                    b""Content-Length: 73\r\n""
                    b""\r\n""
                    b""--36eeb8c4e26d842a\r\n""
                    b""Content-Type: text/plain\r\n""
                    b""\r\n""
                    b""1\r\n""
                    b""--36eeb8c4e26d842a--\r\n"",
                )
                sock.close()

        self._start_server(socket_handler)
        from urllib3.connectionpool import log

        with mock.patch.object(log, ""warning"") as log_warning:
            with HTTPConnectionPool(self.host, self.port, timeout=3) as pool:
                resp = pool.urlopen(""GET"", ""/"")
                assert resp.status == 404
                assert (
                    resp.headers[""content-type""]
                    == ""multipart/mixed; boundary=36eeb8c4e26d842a""
                )
                assert len(resp.data) == 73
                log_warning.assert_not_called()",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"  VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, ) VAR VAR.VAR VAR VAR, VAR VAR VAR VAR VAR, VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR .. VAR VAR, VAR, VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR(VAR): VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR  VAR = VAR.VAR.VAR VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: VAR=1\VAR\VAR"" VAR""VAR-VAR: VAR=1\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR.VAR == {""VAR-VAR"": ""VAR=1, VAR=1""} VAR VAR.VAR.VAR(""VAR-VAR"") == [""VAR=1"", ""VAR=1""] VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR.VAR: VAR.VAR(""VAR-VAR VAR VAR"") VAR = VAR() VAR.VAR = VAR"""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR = VAR.VAR(65536)  VAR.VAR()  VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR:  VAR VAR = VAR.VAR(VAR) VAR VAR, ""VAR VAR VAR VAR VAR VAR"" VAR ( VAR.VAR.VAR(""VAR"") VAR VAR.VAR ), ""VAR VAR VAR VAR VAR"" VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR(): VAR.VAR(""VAR-VAR VAR VAR"") VAR = VAR() VAR.VAR = VAR"""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR = VAR.VAR(65536)  VAR.VAR()  VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR:  VAR VAR = VAR.VAR(VAR) VAR VAR, ""VAR VAR VAR VAR VAR VAR"" VAR VAR VAR VAR.VAR: VAR ( VAR.VAR(""VAR"") VAR VAR.VAR ), ""VAR VAR VAR VAR VAR VAR"" VAR VAR(VAR): """""" VAR VAR VAR VAR VAR. """""" @VAR VAR VAR(VAR): VAR.VAR = VAR.VAR() VAR = VAR.VAR() VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR.VAR, VAR""VAR"") VAR.VAR = VAR.VAR.VAR(VAR.VAR, ""VAR.VAR"") VAR.VAR = VAR.VAR.VAR(VAR.VAR, ""VAR.VAR.VAR"") VAR.VAR = VAR.VAR.VAR(VAR.VAR, ""VAR.VAR"") VAR.VAR = VAR.VAR.VAR(VAR.VAR, ""VAR.VAR"") VAR.VAR = VAR.VAR.VAR(VAR.VAR, ""VAR.VAR"") VAR.VAR.VAR(VAR.VAR) VAR.VAR.VAR(VAR.VAR) VAR.VAR[0].VAR(VAR.VAR) VAR.VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR.VAR(VAR.VAR) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR VAR.VAR( VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR()) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(8192) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 6\VAR\VAR"" VAR""\VAR\VAR"" VAR""VAR!"" ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=""VAR"", VAR=VAR.VAR, ) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR.VAR() VAR VAR(VAR) == 1 VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR()) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(8192) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 6\VAR\VAR"" VAR""\VAR\VAR"" VAR""VAR!"" ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR.VAR, VAR=""VAR"", VAR=VAR.VAR, ) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR.VAR() VAR VAR(VAR) == 1 VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR: VAR.VAR(VAR) VAR VAR.VAR: VAR VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"", VAR=VAR.VAR ) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"", VAR=0) VAR.VAR() VAR.VAR() @VAR VAR VAR(VAR): VAR.VAR(VAR""VAR"") @VAR VAR VAR(VAR): VAR.VAR(VAR""VAR"") VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR """""" VAR = VAR() VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR()) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(8192) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 6\VAR\VAR"" VAR""\VAR\VAR"" VAR""VAR!"" ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR.VAR(VAR.VAR) VAR.VAR( VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR ) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=""VAR"", VAR=VAR.VAR, ) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR.VAR() VAR VAR(VAR) == 1 @VAR VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR)  VAR VAR.VAR: VAR VAR.VAR VAR VAR VAR = VAR VAR: VAR = VAR.VAR VAR VAR.VAR(VAR): VAR.VAR( VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR""VAR"", ) VAR VAR(VAR): VAR VAR(VAR):    VAR = VAR() VAR VAR(VAR): VAR VAR VAR 0, 1: VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR = VAR.VAR(65536) VAR = ""VAR %VAR"" % VAR VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" ""%VAR"" % (VAR(VAR), VAR) ).VAR(""VAR-8"") ) VAR.VAR()  VAR.VAR()  VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR 0"" VAR.VAR()  VAR = VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR 1"" VAR VAR(VAR):  VAR, VAR = VAR() VAR VAR(VAR, VAR, VAR=3, VAR=VAR) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"", VAR=0, VAR=VAR) VAR VAR.VAR.VAR() == VAR.VAR.VAR VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536).VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR=3, VAR=VAR, ) VAR VAR: VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"", VAR=VAR) VAR: VAR.VAR() VAR VAR.VAR.VAR() == VAR.VAR.VAR VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR(65536) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"") VAR: VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR"""""" VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536): VAR VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"") VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR.VAR()[0] VAR.VAR()  VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536)  VAR = ""VAR 2"" VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" ""%VAR"" % (VAR(VAR), VAR) ).VAR(""VAR-8"") ) VAR.VAR()     VAR = VAR.VAR() VAR.VAR(1) VAR: VAR.VAR(VAR) VAR = VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=1) VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR 2"" VAR: VAR.VAR(VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR = ""VAR"" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR = VAR.VAR(65536) VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" % VAR(VAR) ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR(VAR.VAR(""VAR-8"")) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/"", VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=VAR), ) VAR: VAR VAR.VAR(VAR): VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR = ""VAR"" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" % VAR(VAR) ).VAR(""VAR-8"") ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR: VAR VAR.VAR(VAR): VAR = VAR(VAR=VAR, VAR=VAR) VAR.VAR(""VAR"", ""/"", VAR=VAR, VAR=VAR) VAR: VAR.VAR() VAR VAR(VAR): VAR = ""VAR"" VAR = VAR[:2] VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR = VAR.VAR(65536)  VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" ""%VAR"" % (VAR(VAR), VAR) ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=0, VAR=VAR) VAR VAR.VAR(VAR): VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR.VAR VAR VAR"""""" VAR VAR(VAR): VAR = VAR.VAR()[0]   VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536)  VAR = ""VAR VAR 0.5 VAR"" VAR.VAR( ( ""VAR/0.5 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" ""%VAR"" % (VAR(VAR), VAR) ).VAR(""VAR-8"") ) VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536)  VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" ""VAR"" % (VAR(""VAR"")) ).VAR(""VAR-8"") ) VAR.VAR()  VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR(VAR=1) VAR = VAR.VAR(""VAR"", ""/"", VAR=VAR) VAR VAR.VAR == 200 VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR = ""VAR"" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR = VAR.VAR(65536) VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" % VAR(VAR) ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR() VAR = VAR.VAR( ""VAR"", ""/"", VAR=0, VAR=VAR, VAR=VAR ) VAR: VAR VAR.VAR(VAR): VAR.VAR() VAR VAR == VAR.VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR = ""VAR"" VAR = VAR[:2] VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR = VAR.VAR(65536)  VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" ""%VAR"" % (VAR(VAR), VAR) ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR() VAR = VAR.VAR(""VAR"", ""/"", VAR=0, VAR=VAR) VAR VAR.VAR(VAR): VAR.VAR() VAR VAR == VAR.VAR.VAR() VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR = VAR.VAR(65535)  VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: VAR\VAR\VAR"" ""\VAR\VAR"" ""8\VAR\VAR"" ""12345678\VAR\VAR"" ).VAR(""VAR-8"") ) VAR.VAR(5)     VAR, VAR, VAR = VAR.VAR([VAR], [], [], 1) VAR VAR VAR = VAR.VAR()[0]  VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR = VAR.VAR(65535)  VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: VAR\VAR\VAR"" ""\VAR\VAR"" ""8\VAR\VAR"" ""12345678\VAR\VAR"" ""0\VAR\VAR\VAR\VAR"" ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR:  VAR = VAR.VAR( ""VAR"", ""/"", VAR=0, VAR=VAR, VAR=VAR ) VAR: VAR VAR.VAR(VAR): VAR.VAR() VAR: VAR.VAR()  VAR = VAR.VAR( ""VAR"", ""/"", VAR=0, VAR=VAR, VAR=VAR ) VAR VAR(VAR.VAR()) == 8 VAR VAR(VAR): VAR = VAR() VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR = VAR.VAR(65536) VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: 0\VAR\VAR"" ""\VAR\VAR"" ).VAR(""VAR-8"") )  VAR.VAR(VAR=VAR)   VAR.VAR(VAR) VAR = VAR.VAR(65536) VAR VAR VAR VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=0, VAR=VAR) VAR VAR.VAR == 200 VAR.VAR() VAR.VAR()  VAR = VAR.VAR(VAR=VAR) VAR VAR, ""VAR VAR VAR VAR VAR VAR"" VAR VAR(VAR): """"""VAR VAR ```VAR(VAR=VAR)```, VAR VAR VAR'VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR: VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR  VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR. [1] <VAR: """""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR(VAR)    VAR.VAR()    VAR, VAR, VAR = VAR.VAR([VAR], [], [], 5) VAR VAR VAR = VAR.VAR()[0] VAR(VAR)  VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: VAR\VAR\VAR"" ""\VAR\VAR"" ""8\VAR\VAR"" ""12345678\VAR\VAR"" ""0\VAR\VAR\VAR\VAR"" ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=1) VAR VAR:   VAR = VAR.VAR( ""VAR"", ""/"", VAR=1, VAR=VAR, VAR=VAR, VAR=VAR, )   VAR VAR.VAR == 2 VAR VAR.VAR.VAR() == 0 VAR VAR.VAR VAR VAR VAR  VAR.VAR() VAR VAR.VAR.VAR() == 1 VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" ""%VAR"" % (VAR(VAR), VAR.VAR(""VAR-8"")) ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR(VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200    VAR VAR(VAR.VAR.VAR(VAR""\VAR\VAR"")) == VAR( [ VAR""VAR VAR: VAR""VAR: VAR.VAR"", VAR""VAR-VAR: VAR"", VAR""VAR: */*"", VAR""VAR-VAR: "" + VAR().VAR(""VAR-8""), VAR"""", VAR"""", ] ) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" ""%VAR"" % (VAR(VAR), VAR.VAR(""VAR-8"")) ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR(VAR) VAR = ""VAR:  VAR = VAR({""VAR VAR VAR"": ""VAR!""}) VAR VAR(VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR: VAR = VAR.VAR(""VAR"", ""VAR: VAR VAR.VAR == 200    VAR VAR""VAR VAR VAR: VAR!\VAR\VAR"" VAR VAR.VAR VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: %VAR\VAR\VAR"" ""\VAR\VAR"" ""%VAR"" % (VAR(VAR), VAR.VAR(""VAR-8"")) ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR(VAR) VAR VAR: VAR = VAR.VAR(""VAR: VAR = VAR.VAR( ""VAR"", ""VAR: ) VAR VAR.VAR == 200 VAR.VAR(VAR=VAR) VAR VAR.VAR(VAR): VAR.VAR( ""VAR"", ""VAR: VAR=VAR, VAR=VAR, ) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR = VAR.VAR(""VAR-8"") VAR VAR VAR.VAR(""VAR ""): VAR.VAR( ( ""VAR/1.1 405 VAR VAR VAR\VAR\VAR: VAR\VAR\VAR\VAR\VAR"" ).VAR(""VAR-8"") ) VAR.VAR() VAR VAR VAR VAR.VAR(""VAR %VAR:443"" % (VAR.VAR,)): VAR.VAR((""VAR/1.1 403 VAR\VAR\VAR\VAR\VAR"").VAR(""VAR-8"")) VAR.VAR() VAR VAR.VAR((""VAR/1.1 200 VAR VAR\VAR\VAR\VAR\VAR"").VAR(""VAR-8"")) VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR[""VAR""], VAR=VAR[""VAR""], VAR=VAR, ) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: 2\VAR\VAR"" ""VAR: VAR\VAR\VAR"" ""\VAR\VAR"" ""VAR"" ).VAR(""VAR-8"") ) VAR.VAR() VAR VAR(VAR): VAR(VAR) VAR(VAR) VAR.VAR(VAR) VAR = ""VAR: VAR VAR(VAR, VAR=VAR) VAR VAR: VAR = ""VAR: VAR = VAR.VAR(VAR) VAR = VAR.VAR(""VAR"", VAR, VAR=0) VAR VAR.VAR == 200 VAR = VAR.VAR(""VAR"", VAR, VAR=0) VAR VAR.VAR == 200 VAR VAR(VAR): VAR = ""2001:4998:VAR:VAR::2:4008"" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR = VAR.VAR(""VAR-8"") VAR VAR.VAR(""VAR [%VAR]:443"" % (VAR,)): VAR.VAR(VAR""VAR/1.1 200 VAR VAR\VAR\VAR\VAR\VAR"") VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR[""VAR""], VAR=VAR[""VAR""], ) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""VAR-VAR: 2\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""\VAR\VAR"" VAR""VAR"" ) VAR.VAR() VAR: VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR VAR(VAR, VAR=""VAR"") VAR VAR: VAR = ""VAR: VAR = VAR.VAR(VAR) VAR: VAR = VAR.VAR(""VAR"", VAR, VAR=0) VAR VAR.VAR == 200 VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR() VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR[""VAR""], VAR=VAR[""VAR""], VAR=VAR, ) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536)  VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: 2\VAR\VAR"" ""\VAR\VAR"" ""VAR"" ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=0) VAR VAR(VAR.VAR.VAR, VAR) @VAR VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR[""VAR""], VAR=VAR[""VAR""], ) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536)  VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: 10\VAR\VAR"" ""\VAR\VAR"" ""VAR-"" ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR( ""VAR"", ""/"", VAR=0, VAR=VAR, VAR=VAR ) VAR: VAR VAR.VAR(VAR): VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR[""VAR""], VAR=VAR[""VAR""], VAR=VAR, ) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""VAR-VAR: 5\VAR\VAR\VAR\VAR"" VAR""VAR"" ) VAR.VAR() VAR.VAR() VAR.VAR(VAR)  VAR = ""VAR:VAR:VAR:46:00:VAR:VAR:2D:VAR:VAR:VAR:9A:8C:VAR:07:VAR:58:VAR:74:5E"" VAR VAR(): VAR = VAR( VAR.VAR, VAR.VAR, VAR=VAR ) VAR: VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR.VAR( ""VAR"", ""/"", VAR=VAR, VAR=0, VAR=VAR ) VAR.VAR() VAR: VAR.VAR() VAR VAR.VAR(VAR) VAR VAR: VAR() VAR VAR(VAR.VAR.VAR, VAR)  VAR VAR.VAR(VAR): VAR() VAR VAR(VAR): VAR VAR(VAR):  VAR = VAR.VAR()[0] VAR = VAR.VAR() VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR[""VAR""], VAR=VAR[""VAR""], ) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536)  VAR.VAR( ( ""VAR/1.1 200 VAR\VAR\VAR"" ""VAR-VAR: VAR/VAR\VAR\VAR"" ""VAR-VAR: 4\VAR\VAR"" ""\VAR\VAR"" ""VAR"" ).VAR(""VAR-8"") ) VAR.VAR() VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR[""VAR""], VAR=VAR[""VAR""], ) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""VAR-VAR: 7\VAR\VAR\VAR\VAR"" VAR""VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=1) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR[""VAR""], VAR=VAR[""VAR""], VAR=VAR, ) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""VAR-VAR: 5\VAR\VAR\VAR\VAR"" VAR""VAR"" ) VAR.VAR() VAR.VAR() VAR = VAR.VAR(VAR.VAR) VAR.VAR = VAR.VAR() VAR.VAR = 0 VAR VAR.VAR(""VAR.VAR.VAR.VAR"", VAR *VAR, **VAR: VAR): VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"", VAR=VAR) VAR.VAR.VAR() @VAR VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR[""VAR""], VAR=VAR[""VAR""], VAR=VAR, ) VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""VAR-VAR: 5\VAR\VAR\VAR\VAR"" VAR""VAR"" ) VAR.VAR() VAR.VAR() VAR = VAR.VAR(VAR.VAR) VAR.VAR = VAR.VAR() VAR.VAR = 0 VAR VAR.VAR(""VAR.VAR.VAR.VAR"", VAR *VAR, **VAR: VAR): VAR VAR VAR [ {""VAR"": ""/VAR""}, {""VAR"": ""/VAR""}, {""VAR"": ""VAR"", ""VAR"": ""VAR""}, {""VAR"": VAR}, ]: VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, **VAR) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"", VAR=VAR) VAR.VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR VAR.VAR(VAR): VAR(VAR, VAR=""/VAR/VAR-VAR"") VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR VAR(VAR): VAR: VAR.VAR(VAR)  VAR.VAR(1)  VAR (VAR, VAR.VAR): VAR VAR VAR VAR VAR VAR(VAR): VAR = VAR.VAR()[0] VAR: VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR[""VAR""], VAR=VAR[""VAR""], VAR=VAR, ) VAR VAR.VAR VAR VAR: VAR ""VAR VAR VAR"" VAR VAR(VAR) VAR VAR(VAR): VAR.VAR() VAR.VAR(VAR)  VAR = VAR.VAR() VAR = VAR(VAR / ""VAR.VAR"") VAR.VAR.VAR(VAR) VAR VAR( VAR.VAR, VAR.VAR, VAR=""VAR"", VAR=VAR ) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"", VAR=VAR, VAR=VAR) VAR VAR.VAR(VAR), ""VAR VAR VAR VAR VAR"" VAR VAR(VAR): VAR VAR(VAR): VAR.VAR( VAR""VAR/1.1 VAR VAR VAR VAR?\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"") VAR VAR(VAR): VAR.VAR( VAR""VAR/1000 200 VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""\VAR\VAR"" ) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR VAR.VAR(VAR): VAR.VAR(""VAR"", ""/"") VAR VAR(VAR): @VAR VAR VAR(VAR): VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""\VAR\VAR"" ) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = {""VAR-VAR"": ""0"", ""VAR-VAR"": ""VAR/VAR""} VAR = VAR.VAR(""VAR"", ""/"") VAR VAR == VAR(VAR.VAR.VAR())  VAR VAR(VAR): VAR.VAR = VAR() VAR.VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR = [ VAR VAR VAR VAR VAR.VAR(VAR""\VAR\VAR"")[1:] VAR VAR ] VAR VAR VAR VAR.VAR: (VAR, VAR) = VAR.VAR(VAR"": "") VAR.VAR[VAR.VAR(""VAR"")] = VAR.VAR(""VAR"") VAR.VAR( (""VAR/1.1 204 VAR VAR\VAR\VAR-VAR: 0\VAR\VAR\VAR\VAR"").VAR(""VAR-8"") ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR): VAR = {""VAR"": ""VAR"", ""VAR"": ""VAR""} VAR.VAR() VAR = { ""VAR-VAR"": ""VAR"", ""VAR"": ""{0}:{1}"".VAR(VAR.VAR, VAR.VAR), ""VAR-VAR"": VAR(), } VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=VAR(VAR)) VAR VAR == VAR.VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""VAR VAR VAR!""} VAR.VAR() VAR = { ""VAR-VAR"": ""VAR"", ""VAR"": ""{0}:{1}"".VAR(VAR.VAR, VAR.VAR), } VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=VAR(VAR)) VAR VAR == VAR.VAR VAR VAR(VAR):  VAR = 16    VAR = [ (VAR""VAR-VAR-%VAR"" % VAR, VAR(VAR)) VAR VAR VAR VAR(VAR(VAR)) ] VAR VAR(VAR): VAR [(VAR, VAR) VAR (VAR, VAR) VAR VAR.VAR() VAR VAR.VAR(""VAR-VAR-"")] VAR = VAR() VAR.VAR() VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"", VAR=VAR(VAR)) VAR = VAR(VAR.VAR) VAR VAR == VAR @VAR VAR VAR(VAR): VAR.VAR() VAR VAR(VAR.VAR + ""."", VAR.VAR, VAR=VAR) VAR VAR: VAR.VAR(""VAR"", ""/"") VAR.VAR( VAR.VAR, ""VAR"", ""%VAR:%VAR"" % (VAR.VAR, VAR.VAR) ) VAR VAR(VAR):  VAR = 16    VAR = [ (""VAR-VAR-%VAR"" % VAR, VAR(VAR)) VAR VAR VAR VAR(VAR(VAR)) ] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" + VAR""\VAR\VAR"".VAR( [ (VAR.VAR(""VAR"") + VAR"": "" + VAR.VAR(""VAR"")) VAR (VAR, VAR) VAR VAR ] ) + VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=0) VAR = [ (VAR, VAR) VAR (VAR, VAR) VAR VAR.VAR.VAR() VAR VAR.VAR(""VAR-VAR-"") ] VAR VAR == VAR @VAR.VAR.VAR( VAR(VAR.VAR, VAR), VAR=""VAR VAR VAR VAR VAR"", ) VAR VAR(VAR): VAR VAR(VAR, VAR, VAR=VAR): VAR.VAR( ( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" ) + VAR""\VAR\VAR"".VAR(VAR) + VAR""\VAR\VAR\VAR\VAR"" ) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR VAR() VAR VAR: VAR.VAR(""VAR"", ""/"") VAR VAR VAR VAR: VAR ( ""VAR VAR VAR VAR"" VAR VAR.VAR VAR VAR.VAR(""/"") == VAR.VAR[0] ): VAR ( VAR VAR VAR VAR VAR VAR VAR.VAR() ): VAR VAR.VAR(""VAR VAR VAR VAR VAR"") VAR VAR(VAR): VAR.VAR([VAR"": VAR"", VAR""VAR: VAR""]) VAR VAR(VAR): VAR.VAR([VAR"":"", VAR""VAR: VAR""]) VAR VAR(VAR): VAR.VAR( [VAR""VAR VAR"", VAR""VAR: VAR""], ""VAR VAR"" ) VAR VAR(VAR): VAR VAR(VAR, VAR): VAR.VAR( (VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: 0\VAR\VAR"") + VAR + VAR""\VAR\VAR\VAR\VAR"" ) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR VAR() VAR VAR: VAR.VAR(""VAR"", ""/"") VAR VAR VAR VAR: VAR ""VAR VAR VAR VAR"" VAR VAR VAR.VAR VAR VAR(VAR): VAR.VAR(VAR""VAR-VAR: VAR/VAR"") VAR VAR(VAR): VAR.VAR(VAR""VAR-VAR: VAR/VAR"") VAR VAR(VAR): VAR VAR(VAR): VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: VAR\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""\VAR\VAR"" ) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=VAR, VAR=VAR)  VAR [] == VAR(VAR.VAR()) VAR VAR(VAR): VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: 256\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""\VAR\VAR"" ) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=VAR, VAR=VAR)  VAR [] == VAR(VAR.VAR()) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: 12\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""\VAR\VAR"" VAR""VAR, VAR"" ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=VAR, VAR=VAR)  VAR [VAR""VAR, VAR""] == VAR(VAR.VAR(VAR)) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: 22\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""\VAR\VAR"" VAR""VAR, VAR"" ) VAR.VAR(VAR) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=1) VAR VAR:  VAR = VAR.VAR( ""VAR"", VAR=""/"", VAR=VAR, VAR=VAR ) VAR = VAR.VAR(100)   VAR(VAR) VAR: VAR(VAR) VAR VAR VAR VAR VAR VAR: VAR ""12 VAR VAR, 10 VAR VAR"" VAR VAR(VAR) VAR.VAR() VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR"""" VAR VAR VAR.VAR(VAR""\VAR\VAR\VAR\VAR""): VAR += VAR.VAR(65536) VAR.VAR( VAR""VAR/1.1 200 VAR\VAR\VAR"" VAR""VAR-VAR: 22\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR(1) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=1) VAR VAR:  VAR = VAR.VAR( ""VAR"", VAR=""/"", VAR=VAR, VAR=VAR ) VAR = [VAR VAR VAR VAR VAR.VAR(1)] VAR VAR(VAR) == 0 VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536).VAR(VAR""\VAR\VAR\VAR\VAR""): VAR   VAR.VAR( VAR""VAR/1.1 404 VAR VAR\VAR\VAR"" VAR""VAR-VAR: 1000\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""\VAR\VAR"" ) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR=1, VAR=VAR, VAR=[404]) VAR VAR( VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR ) VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR=VAR) VAR VAR.VAR == 1 VAR VAR(VAR): @VAR VAR VAR(VAR, VAR):   VAR = VAR() VAR = VAR.VAR  VAR = ""VAR"" * 1024 * 1024 * 4 VAR VAR(*VAR, **VAR): VAR = VAR(*VAR, **VAR) VAR VAR.VAR(5) VAR VAR VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR.VAR( VAR""VAR/1.1 404 VAR VAR\VAR\VAR"" VAR""VAR: VAR\VAR\VAR"" VAR""VAR-VAR: 10\VAR\VAR"" VAR""\VAR\VAR"" VAR""VAR"" ) VAR.VAR(VAR.VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR, ""VAR"", VAR) VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"", VAR=VAR) VAR VAR.VAR == 404 VAR VAR.VAR[""VAR-VAR""] == ""10"" VAR VAR.VAR == VAR""VAR"" VAR = VAR.VAR(""VAR"", ""/VAR"", VAR=VAR, VAR=VAR) VAR VAR.VAR == 404 VAR VAR.VAR[""VAR-VAR""] == ""10"" VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536).VAR(VAR""\VAR\VAR\VAR\VAR""): VAR VAR.VAR( VAR""VAR/1.1 404 VAR VAR\VAR\VAR"" VAR""VAR: VAR.VAR\VAR\VAR"" VAR""VAR-VAR: VAR/VAR; VAR=36eeb8c4e26d842a\VAR\VAR"" VAR""VAR-VAR: 73\VAR\VAR"" VAR""\VAR\VAR"" VAR""--36eeb8c4e26d842a\VAR\VAR"" VAR""VAR-VAR: VAR/VAR\VAR\VAR"" VAR""\VAR\VAR"" VAR""1\VAR\VAR"" VAR""--36eeb8c4e26d842a--\VAR\VAR"", ) VAR.VAR() VAR.VAR(VAR) VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR(VAR, ""VAR"") VAR VAR: VAR VAR(VAR.VAR, VAR.VAR, VAR=3) VAR VAR: VAR = VAR.VAR(""VAR"", ""/"") VAR VAR.VAR == 404 VAR ( VAR.VAR[""VAR-VAR""] == ""VAR/VAR; VAR=36eeb8c4e26d842a"" ) VAR VAR(VAR.VAR) == 73 VAR.VAR() ",8
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,dummyserver/handlers.py,"from __future__ import print_function

import collections
import contextlib
import gzip
import json
import logging
import sys
import time
import zlib

from io import BytesIO
from tornado.web import RequestHandler
from tornado import httputil
from datetime import datetime
from datetime import timedelta

from urllib3.packages.six.moves.http_client import responses
from urllib3.packages.six.moves.urllib.parse import urlsplit

log = logging.getLogger(__name__)


class Response(object):
    def __init__(self, body='', status='200 OK', headers=None):
        self.body = body
        self.status = status
        self.headers = headers or [(""Content-type"", ""text/plain"")]

    def __call__(self, request_handler):
        status, reason = self.status.split(' ', 1)
        request_handler.set_status(int(status), reason)
        for header, value in self.headers:
            request_handler.add_header(header, value)

        # chunked
        if isinstance(self.body, list):
            for item in self.body:
                if not isinstance(item, bytes):
                    item = item.encode('utf8')
                request_handler.write(item)
                request_handler.flush()
        else:
            body = self.body
            if not isinstance(body, bytes):
                body = body.encode('utf8')

            request_handler.write(body)


RETRY_TEST_NAMES = collections.defaultdict(int)


class TestingApp(RequestHandler):
    """"""
    Simple app that performs various operations, useful for testing an HTTP
    library.

    Given any path, it will attempt to load a corresponding local method if
    it exists. Status code 200 indicates success, 400 indicates failure. Each
    method has its own conditions for success/failure.
    """"""
    def get(self):
        """""" Handle GET requests """"""
        self._call_method()

    def post(self):
        """""" Handle POST requests """"""
        self._call_method()

    def put(self):
        """""" Handle PUT requests """"""
        self._call_method()

    def options(self):
        """""" Handle OPTIONS requests """"""
        self._call_method()

    def head(self):
        """""" Handle HEAD requests """"""
        self._call_method()

    def _call_method(self):
        """""" Call the correct method in this class based on the incoming URI """"""
        req = self.request
        req.params = {}
        for k, v in req.arguments.items():
            req.params[k] = next(iter(v))

        path = req.path[:]
        if not path.startswith('/'):
            path = urlsplit(path).path

        target = path[1:].replace('/', '_')
        method = getattr(self, target, self.index)

        resp = method(req)

        if dict(resp.headers).get('Connection') == 'close':
            # FIXME: Can we kill the connection somehow?
            pass

        resp(self)

    def index(self, _request):
        ""Render simple message""
        return Response(""Dummy server!"")

    def certificate(self, request):
        """"""Return the requester's certificate.""""""
        cert = request.get_ssl_certificate()
        subject = dict()
        if cert is not None:
            subject = dict((k, v) for (k, v) in [y for z in cert['subject']
                                                 for y in z])
        return Response(json.dumps(subject))

    def source_address(self, request):
        """"""Return the requester's IP address.""""""
        return Response(request.remote_ip)

    def set_up(self, request):
        test_type = request.params.get('test_type')
        test_id = request.params.get('test_id')
        if test_id:
            print('\nNew test %s: %s' % (test_type, test_id))
        else:
            print('\nNew test %s' % test_type)
        return Response(""Dummy server is ready!"")

    def specific_method(self, request):
        ""Confirm that the request matches the desired method type""
        method = request.params.get('method')
        if method and not isinstance(method, str):
            method = method.decode('utf8')

        if request.method != method:
            return Response(""Wrong method: %s != %s"" %
                            (method, request.method), status='400 Bad Request')
        return Response()

    def upload(self, request):
        ""Confirm that the uploaded file conforms to specification""
        # FIXME: This is a huge broken mess
        param = request.params.get('upload_param', b'myfile').decode('ascii')
        filename = request.params.get('upload_filename', b'').decode('utf-8')
        size = int(request.params.get('upload_size', '0'))
        files_ = request.files.get(param)

        if len(files_) != 1:
            return Response(""Expected 1 file for '%s', not %d"" % (param, len(files_)),
                            status='400 Bad Request')
        file_ = files_[0]

        data = file_['body']
        if int(size) != len(data):
            return Response(""Wrong size: %d != %d"" %
                            (size, len(data)), status='400 Bad Request')

        if filename != file_['filename']:
            return Response(""Wrong filename: %s != %s"" %
                            (filename, file_.filename),
                            status='400 Bad Request')

        return Response()

    def redirect(self, request):
        ""Perform a redirect to ``target``""
        target = request.params.get('target', '/')
        status = request.params.get('status', '303 See Other')
        if len(status) == 3:
            status = '%s Redirect' % status.decode('latin-1')

        headers = [('Location', target)]
        return Response(status=status, headers=headers)

    def not_found(self, request):
        return Response('Not found', status='404 Not Found')

    def multi_redirect(self, request):
        ""Performs a redirect chain based on ``redirect_codes``""
        codes = request.params.get('redirect_codes', b'200').decode('utf-8')
        head, tail = codes.split(',', 1) if "","" in codes else (codes, None)
        status = ""{0} {1}"".format(head, responses[int(head)])
        if not tail:
            return Response(""Done redirecting"", status=status)

        headers = [('Location', '/multi_redirect?redirect_codes=%s' % tail)]
        return Response(status=status, headers=headers)

    def keepalive(self, request):
        if request.params.get('close', b'0') == b'1':
            headers = [('Connection', 'close')]
            return Response('Closing', headers=headers)

        headers = [('Connection', 'keep-alive')]
        return Response('Keeping alive', headers=headers)

    def sleep(self, request):
        ""Sleep for a specified amount of ``seconds``""
        # DO NOT USE THIS, IT'S DEPRECATED.
        # FIXME: Delete this once appengine tests are fixed to not use this handler.
        seconds = float(request.params.get('seconds', '1'))
        time.sleep(seconds)
        return Response()

    def echo(self, request):
        ""Echo back the params""
        if request.method == 'GET':
            return Response(request.query)

        return Response(request.body)

    def encodingrequest(self, request):
        ""Check for UA accepting gzip/deflate encoding""
        data = b""hello, world!""
        encoding = request.headers.get('Accept-Encoding', '')
        headers = None
        if encoding == 'gzip':
            headers = [('Content-Encoding', 'gzip')]
            file_ = BytesIO()
            with contextlib.closing(gzip.GzipFile('', mode='w', fileobj=file_)) as zipfile:
                zipfile.write(data)
            data = file_.getvalue()
        elif encoding == 'deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = zlib.compress(data)
        elif encoding == 'garbage-gzip':
            headers = [('Content-Encoding', 'gzip')]
            data = 'garbage'
        elif encoding == 'garbage-deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = 'garbage'
        return Response(data, headers=headers)

    def headers(self, request):
        return Response(json.dumps(dict(request.headers)))

    def successful_retry(self, request):
        """""" Handler which will return an error and then success

        It's not currently very flexible as the number of retries is hard-coded.
        """"""
        test_name = request.headers.get('test-name', None)
        if not test_name:
            return Response(""test-name header not set"",
                            status=""400 Bad Request"")

        RETRY_TEST_NAMES[test_name] += 1

        if RETRY_TEST_NAMES[test_name] >= 2:
            return Response(""Retry successful!"")
        else:
            return Response(""need to keep retrying!"", status=""418 I'm A Teapot"")

    def chunked(self, request):
        return Response(['123'] * 4)

    def chunked_gzip(self, request):
        chunks = []
        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)

        for uncompressed in [b'123'] * 4:
            chunks.append(compressor.compress(uncompressed))

        chunks.append(compressor.flush())

        return Response(chunks, headers=[('Content-Encoding', 'gzip')])

    def nbytes(self, request):
        length = int(request.params.get('length'))
        data = b'1' * length
        return Response(
            data,
            headers=[('Content-Type', 'application/octet-stream')])

    def status(self, request):
        status = request.params.get(""status"", ""200 OK"")

        return Response(status=status)

    def retry_after(self, request):
        if datetime.now() - self.application.last_req < timedelta(seconds=1):
            status = request.params.get(""status"", b""429 Too Many Requests"")
            return Response(
                    status=status.decode('utf-8'),
                    headers=[('Retry-After', '1')])

        self.application.last_req = datetime.now()

        return Response(status=""200 OK"")

    def redirect_after(self, request):
        ""Perform a redirect to ``target``""
        date = request.params.get('date')
        if date:
            retry_after = str(httputil.format_timestamp(
                    datetime.fromtimestamp(float(date))))
        else:
            retry_after = '1'
        target = request.params.get('target', '/')
        headers = [('Location', target), ('Retry-After', retry_after)]
        return Response(status='303 See Other', headers=headers)

    def shutdown(self, request):
        sys.exit()


# RFC2231-aware replacement of internal tornado function
def _parse_header(line):
    r""""""Parse a Content-type like header.

    Return the main content-type and a dictionary of options.

    >>> d = _parse_header(""CD: fd; foo=\""bar\""; file*=utf-8''T%C3%A4st"")[1]
    >>> d['file'] == 'T\u00e4st'
    True
    >>> d['foo']
    'bar'
    """"""
    import tornado.httputil
    import email.utils
    from urllib3.packages import six
    if not six.PY3:
        line = line.encode('utf-8')
    parts = tornado.httputil._parseparam(';' + line)
    key = next(parts)
    # decode_params treats first argument special, but we already stripped key
    params = [('Dummy', 'value')]
    for p in parts:
        i = p.find('=')
        if i >= 0:
            name = p[:i].strip().lower()
            value = p[i + 1:].strip()
            params.append((name, value))
    params = email.utils.decode_params(params)
    params.pop(0)  # get rid of the dummy again
    pdict = {}
    for name, value in params:
        value = email.utils.collapse_rfc2231_value(value)
        if len(value) >= 2 and value[0] == '""' and value[-1] == '""':
            value = value[1:-1]
        pdict[name] = value
    return key, pdict


# TODO: make the following conditional as soon as we know a version
#       which does not require this fix.
#       See https://github.com/facebook/tornado/issues/868
if True:
    import tornado.httputil
    tornado.httputil._parse_header = _parse_header",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR, VAR='', VAR='200 VAR', VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR [(""VAR-VAR"", ""VAR/VAR"")] VAR VAR(VAR, VAR): VAR, VAR = VAR.VAR.VAR(' ', 1) VAR.VAR(VAR(VAR), VAR) VAR VAR, VAR VAR VAR.VAR: VAR.VAR(VAR, VAR)  VAR VAR(VAR.VAR, VAR): VAR VAR VAR VAR.VAR: VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR.VAR() VAR: VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR 200 VAR VAR, 400 VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR/VAR. """""" VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR.VAR VAR.VAR = {} VAR VAR, VAR VAR VAR.VAR.VAR(): VAR.VAR[VAR] = VAR(VAR(VAR)) VAR = VAR.VAR[:] VAR VAR VAR.VAR('/'): VAR = VAR(VAR).VAR VAR = VAR[1:].VAR('/', 'VAR') VAR = VAR(VAR, VAR, VAR.VAR) VAR = VAR(VAR) VAR VAR(VAR.VAR).VAR('VAR') == 'VAR':  VAR VAR(VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR"" VAR VAR(""VAR VAR!"") VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR."""""" VAR = VAR.VAR() VAR = VAR() VAR VAR VAR VAR VAR: VAR = VAR((VAR, VAR) VAR (VAR, VAR) VAR [VAR VAR VAR VAR VAR['VAR'] VAR VAR VAR VAR]) VAR VAR(VAR.VAR(VAR)) VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR VAR."""""" VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR('VAR') VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR('\VAR VAR %VAR: %VAR' % (VAR, VAR)) VAR: VAR('\VAR VAR %VAR' % VAR) VAR VAR(""VAR VAR VAR VAR!"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR = VAR.VAR.VAR('VAR') VAR VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR VAR.VAR != VAR: VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR""  VAR = VAR.VAR.VAR('VAR', VAR'VAR').VAR('VAR') VAR = VAR.VAR.VAR('VAR', VAR'').VAR('VAR-8') VAR = VAR(VAR.VAR.VAR('VAR', '0')) VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) != 1: VAR VAR(""VAR 1 VAR VAR '%VAR', VAR %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR = VAR[0] VAR = VAR['VAR'] VAR VAR(VAR) != VAR(VAR): VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR VAR != VAR['VAR']: VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', '/') VAR = VAR.VAR.VAR('VAR', '303 VAR VAR') VAR VAR(VAR) == 3: VAR = '%VAR VAR' % VAR.VAR('VAR-1') VAR = [('VAR', VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR('VAR VAR', VAR='404 VAR VAR') VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', VAR'200').VAR('VAR-8') VAR, VAR = VAR.VAR(',', 1) VAR "","" VAR VAR VAR (VAR, VAR) VAR = ""{0} {1}"".VAR(VAR, VAR[VAR(VAR)]) VAR VAR VAR: VAR VAR(""VAR VAR"", VAR=VAR) VAR = [('VAR', '/VAR?VAR=%VAR' % VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR('VAR', VAR'0') == VAR'1': VAR = [('VAR', 'VAR')] VAR VAR('VAR', VAR=VAR) VAR = [('VAR', 'VAR-VAR')] VAR VAR('VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``""   VAR = VAR(VAR.VAR.VAR('VAR', '1')) VAR.VAR(VAR) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR"" VAR VAR.VAR == 'VAR': VAR VAR(VAR.VAR) VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR/VAR VAR"" VAR = VAR""VAR, VAR!"" VAR = VAR.VAR.VAR('VAR-VAR', '') VAR = VAR VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR() VAR VAR.VAR(VAR.VAR('', VAR='VAR', VAR=VAR)) VAR VAR: VAR.VAR(VAR) VAR = VAR.VAR() VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR.VAR(VAR) VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR(VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR(VAR.VAR(VAR(VAR.VAR))) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR', VAR) VAR VAR VAR: VAR VAR(""VAR-VAR VAR VAR VAR"", VAR=""400 VAR VAR"") VAR[VAR] += 1 VAR VAR[VAR] >= 2: VAR VAR(""VAR VAR!"") VAR: VAR VAR(""VAR VAR VAR VAR!"", VAR=""418 VAR'VAR VAR VAR"") VAR VAR(VAR, VAR): VAR VAR(['123'] * 4) VAR VAR(VAR, VAR): VAR = [] VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR VAR VAR [VAR'123'] * 4: VAR.VAR(VAR.VAR(VAR)) VAR.VAR(VAR.VAR()) VAR VAR(VAR, VAR=[('VAR-VAR', 'VAR')]) VAR VAR(VAR, VAR): VAR = VAR(VAR.VAR.VAR('VAR')) VAR = VAR'1' * VAR VAR VAR( VAR, VAR=[('VAR-VAR', 'VAR/VAR-VAR')]) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(""VAR"", ""200 VAR"") VAR VAR(VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR() - VAR.VAR.VAR < VAR(VAR=1): VAR = VAR.VAR.VAR(""VAR"", VAR""429 VAR VAR VAR"") VAR VAR( VAR=VAR.VAR('VAR-8'), VAR=[('VAR-VAR', '1')]) VAR.VAR.VAR = VAR.VAR() VAR VAR(VAR=""200 VAR"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR = VAR(VAR.VAR( VAR.VAR(VAR(VAR)))) VAR: VAR = '1' VAR = VAR.VAR.VAR('VAR', '/') VAR = [('VAR', VAR), ('VAR-VAR', VAR)] VAR VAR(VAR='303 VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): VAR.VAR()  VAR VAR(VAR): VAR""""""VAR VAR VAR-VAR VAR VAR. VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR. >>> VAR = VAR(""VAR: VAR; VAR=\""VAR\""; VAR*=VAR-8''VAR%VAR%VAR"")[1] >>> VAR['VAR'] == 'VAR\VAR' VAR >>> VAR['VAR'] 'VAR' """""" VAR VAR.VAR VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR VAR.VAR: VAR = VAR.VAR('VAR-8') VAR = VAR.VAR.VAR(';' + VAR) VAR = VAR(VAR)  VAR = [('VAR', 'VAR')] VAR VAR VAR VAR: VAR = VAR.VAR('=') VAR VAR >= 0: VAR = VAR[:VAR].VAR().VAR() VAR = VAR[VAR + 1:].VAR() VAR.VAR((VAR, VAR)) VAR = VAR.VAR.VAR(VAR) VAR.VAR(0)  VAR = {} VAR VAR, VAR VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) >= 2 VAR VAR[0] == '""' VAR VAR[-1] == '""': VAR = VAR[1:-1] VAR[VAR] = VAR VAR VAR, VAR    VAR VAR: VAR VAR.VAR VAR.VAR.VAR = VAR ",8
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/appengine/test_urlfetch.py,"""""""These tests ensure that when running in App Engine standard with the
App Engine sandbox enabled that urllib3 appropriately uses the App
Engine-patched version of httplib to make requests.""""""

import httplib
import StringIO
import unittest

from mock import patch
import pytest

from ..test_no_ssl import TestWithoutSSL


class MockResponse(object):
    def __init__(self, content, status_code, content_was_truncated, final_url,
                 headers):

        self.content = content
        self.status_code = status_code
        self.content_was_truncated = content_was_truncated
        self.final_url = final_url
        self.header_msg = httplib.HTTPMessage(StringIO.StringIO(''.join(
            [""%s: %s\n"" % (k, v) for k, v in headers.iteritems()] + [""\n""])))
        self.headers = headers


@pytest.mark.usefixtures('sandbox')
class TestHTTP(TestWithoutSSL):
    def test_urlfetch_called_with_http(self):
        """"""Check that URLFetch is used to fetch non-https resources.""""""
        resp = MockResponse(
            'OK',
            200,
            False,
            'http://www.google.com',
            {'content-type': 'text/plain'})
        fetch_patch = patch(
            'google.appengine.api.urlfetch.fetch', return_value=resp
        )
        with fetch_patch as fetch_mock:
            import urllib3
            pool = urllib3.HTTPConnectionPool('www.google.com', '80')
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200, r.data)
            self.assertEqual(fetch_mock.call_count, 1)


@pytest.mark.usefixtures('sandbox')
class TestHTTPS(unittest.TestCase):
    @pytest.mark.xfail(
        reason='This is not yet supported by urlfetch, presence of the ssl '
               'module will bypass urlfetch.')
    def test_urlfetch_called_with_https(self):
        """"""
        Check that URLFetch is used when fetching https resources
        """"""
        resp = MockResponse(
            'OK',
            200,
            False,
            'https://www.google.com',
            {'content-type': 'text/plain'})
        fetch_patch = patch(
            'google.appengine.api.urlfetch.fetch', return_value=resp
        )
        with fetch_patch as fetch_mock:
            import urllib3
            pool = urllib3.HTTPSConnectionPool('www.google.com', '443')
            pool.ConnectionCls = urllib3.connection.UnverifiedHTTPSConnection
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200, r.data)
            self.assertEqual(fetch_mock.call_count, 1)",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"""""""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ..VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR, VAR, VAR, VAR, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR.VAR(VAR.VAR(''.VAR( [""%VAR: %VAR\VAR"" % (VAR, VAR) VAR VAR, VAR VAR VAR.VAR()] + [""\VAR""]))) VAR.VAR = VAR @VAR.VAR.VAR('VAR') VAR VAR(VAR): VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR."""""" VAR = VAR( 'VAR', 200, VAR, 'VAR: {'VAR-VAR': 'VAR/VAR'}) VAR = VAR( 'VAR.VAR.VAR.VAR.VAR', VAR=VAR ) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR('VAR.VAR.VAR', '80') VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR.VAR(VAR.VAR, 1) @VAR.VAR.VAR('VAR') VAR VAR(VAR.VAR): @VAR.VAR.VAR( VAR='VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR ' 'VAR VAR VAR VAR.') VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR( 'VAR', 200, VAR, 'VAR: {'VAR-VAR': 'VAR/VAR'}) VAR = VAR( 'VAR.VAR.VAR.VAR.VAR', VAR=VAR ) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR('VAR.VAR.VAR', '443') VAR.VAR = VAR.VAR.VAR VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR.VAR(VAR.VAR, 1) ",8
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/contritest_socks.py,"import threading
import socket

from urllib3.contrib import socks
from urllib3.exceptions import ConnectTimeoutError, NewConnectionError

from dummyserver.server import DEFAULT_CERTS
from dummyserver.testcase import IPV4SocketDummyServerTestCase

import pytest

try:
    import ssl
    from urllib3.util import ssl_ as better_ssl
    HAS_SSL = True
except ImportError:
    ssl = None
    better_ssl = None
    HAS_SSL = False


SOCKS_NEGOTIATION_NONE = b'\x00'
SOCKS_NEGOTIATION_PASSWORD = b'\x02'

SOCKS_VERSION_SOCKS4 = b'\x04'
SOCKS_VERSION_SOCKS5 = b'\x05'


def _get_free_port(host):
    """"""
    Gets a free port by opening a socket, binding it, checking the assigned
    port, and then closing it.
    """"""
    s = socket.socket()
    s.bind((host, 0))
    port = s.getsockname()[1]
    s.close()
    return port


def _read_exactly(sock, amt):
    """"""
    Read *exactly* ``amt`` bytes from the socket ``sock``.
    """"""
    data = b''

    while amt > 0:
        chunk = sock.recv(amt)
        data += chunk
        amt -= len(chunk)

    return data


def _read_until(sock, char):
    """"""
    Read from the socket until the character is received.
    """"""
    chunks = []
    while True:
        chunk = sock.recv(1)
        chunks.append(chunk)
        if chunk == char:
            break

    return b''.join(chunks)


def _address_from_socket(sock):
    """"""
    Returns the address from the SOCKS socket
    """"""
    addr_type = sock.recv(1)

    if addr_type == b'\x01':
        ipv4_addr = _read_exactly(sock, 4)
        return socket.inet_ntoa(ipv4_addr)
    elif addr_type == b'\x04':
        ipv6_addr = _read_exactly(sock, 16)
        return socket.inet_ntop(socket.AF_INET6, ipv6_addr)
    elif addr_type == b'\x03':
        addr_len = ord(sock.recv(1))
        return _read_exactly(sock, addr_len)
    else:
        raise RuntimeError(""Unexpected addr type: %r"" % addr_type)


def handle_socks5_negotiation(sock, negotiate, username=None,
                              password=None):
    """"""
    Handle the SOCKS5 handshake.

    Returns a generator object that allows us to break the handshake into
    steps so that the test code can intervene at certain useful points.
    """"""
    received_version = sock.recv(1)
    assert received_version == SOCKS_VERSION_SOCKS5
    nmethods = ord(sock.recv(1))
    methods = _read_exactly(sock, nmethods)

    if negotiate:
        assert SOCKS_NEGOTIATION_PASSWORD in methods
        send_data = SOCKS_VERSION_SOCKS5 + SOCKS_NEGOTIATION_PASSWORD
        sock.sendall(send_data)

        # This is the password negotiation.
        negotiation_version = sock.recv(1)
        assert negotiation_version == b'\x01'
        ulen = ord(sock.recv(1))
        provided_username = _read_exactly(sock, ulen)
        plen = ord(sock.recv(1))
        provided_password = _read_exactly(sock, plen)

        if username == provided_username and password == provided_password:
            sock.sendall(b'\x01\x00')
        else:
            sock.sendall(b'\x01\x01')
            sock.close()
            yield False
            return
    else:
        assert SOCKS_NEGOTIATION_NONE in methods
        send_data = SOCKS_VERSION_SOCKS5 + SOCKS_NEGOTIATION_NONE
        sock.sendall(send_data)

    # Client sends where they want to go.
    received_version = sock.recv(1)
    command = sock.recv(1)
    reserved = sock.recv(1)
    addr = _address_from_socket(sock)
    port = _read_exactly(sock, 2)
    port = (ord(port[0:1]) << 8) + (ord(port[1:2]))

    # Check some basic stuff.
    assert received_version == SOCKS_VERSION_SOCKS5
    assert command == b'\x01'  # Only support connect, not bind.
    assert reserved == b'\x00'

    # Yield the address port tuple.
    succeed = yield addr, port

    if succeed:
        # Hard-coded response for now.
        response = (
            SOCKS_VERSION_SOCKS5 + b'\x00\x00\x01\x7f\x00\x00\x01\xea\x60'
        )
    else:
        # Hard-coded response for now.
        response = SOCKS_VERSION_SOCKS5 + b'\x01\00'

    sock.sendall(response)
    yield True  # Avoid StopIteration exceptions getting fired.


def handle_socks4_negotiation(sock, username=None):
    """"""
    Handle the SOCKS4 handshake.

    Returns a generator object that allows us to break the handshake into
    steps so that the test code can intervene at certain useful points.
    """"""
    received_version = sock.recv(1)
    command = sock.recv(1)
    port = _read_exactly(sock, 2)
    port = (ord(port[0:1]) << 8) + (ord(port[1:2]))
    addr = _read_exactly(sock, 4)
    provided_username = _read_until(sock, b'\x00')[:-1]  # Strip trailing null.

    if addr == b'\x00\x00\x00\x01':
        # Magic string: means DNS name.
        addr = _read_until(sock, b'\x00')[:-1]  # Strip trailing null.
    else:
        addr = socket.inet_ntoa(addr)

    # Check some basic stuff.
    assert received_version == SOCKS_VERSION_SOCKS4
    assert command == b'\x01'  # Only support connect, not bind.

    if username is not None and username != provided_username:
        sock.sendall(b'\x00\x5d\x00\x00\x00\x00\x00\x00')
        sock.close()
        yield False
        return

    # Yield the address port tuple.
    succeed = yield addr, port

    if succeed:
        response = b'\x00\x5a\xea\x60\x7f\x00\x00\x01'
    else:
        response = b'\x00\x5b\x00\x00\x00\x00\x00\x00'

    sock.sendall(response)
    yield True  # Avoid StopIteration exceptions getting fired.


class TestSOCKSProxyManager(object):

    def test_invalid_socks_version_is_valueerror(self):
        with pytest.raises(ValueError) as e:
            socks.SOCKSProxyManager(proxy_url='http://example.org')
        assert 'Unable to determine SOCKS version' in e.value.args[0]


class TestSocks5Proxy(IPV4SocketDummyServerTestCase):
    """"""
    Test the SOCKS proxy in SOCKS5 mode.
    """"""
    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_local_dns(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertIn(addr, ['127.0.0.1', '::1'])
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://localhost')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_correct_header_line(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, b'example.com')
            self.assertEqual(port, 80)
            handler.send(True)

            buf = b''
            while True:
                buf += sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            self.assertTrue(buf.startswith(b'GET / HTTP/1.1'))
            self.assertIn(b'Host: example.com', buf)

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://example.com')
        self.assertEqual(response.status, 200)

    def test_connection_timeouts(self):
        event = threading.Event()

        def request_handler(listener):
            event.wait()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        self.assertRaises(
            ConnectTimeoutError, pm.request, 'GET', 'http://example.com',
            timeout=0.001, retries=False
        )
        event.set()

    def test_connection_failure(self):
        event = threading.Event()

        def request_handler(listener):
            listener.close()
            event.set()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        event.wait()
        self.assertRaises(
            NewConnectionError, pm.request, 'GET', 'http://example.com',
            retries=False
        )

    def test_proxy_rejection(self):
        evt = threading.Event()

        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)
            handler.send(False)

            evt.wait()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        self.assertRaises(
            NewConnectionError, pm.request, 'GET', 'http://example.com',
            retries=False
        )
        evt.set()

    def test_socks_with_password(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b'user', password=b'pass'
            )
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='user',
                                     password='pass')
        self.addCleanup(pm.clear)

        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_socks_with_auth_in_url(self):
        """"""
        Test when we have auth info in url, i.e.
        socks5://user:pass@host:port and no username/password as params
        """"""
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b'user', password=b'pass'
            )
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://user:pass@%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_socks_with_invalid_password(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b'user', password=b'pass'
            )
            next(handler)

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='user',
                                     password='badpass')
        self.addCleanup(pm.clear)

        try:
            pm.request('GET', 'http://example.com', retries=False)
        except NewConnectionError as e:
            self.assertIn(""SOCKS5 authentication failed"", str(e))
        else:
            self.fail(""Did not raise"")

    def test_source_address_works(self):
        expected_port = _get_free_port(self.host)

        def request_handler(listener):
            sock = listener.accept()[0]
            self.assertEqual(sock.getpeername()[0], '127.0.0.1')
            self.assertEqual(sock.getpeername()[1], expected_port)

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(
            proxy_url, source_address=('127.0.0.1', expected_port)
        )
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')
        self.assertEqual(response.status, 200)


class TestSOCKS4Proxy(IPV4SocketDummyServerTestCase):
    """"""
    Test the SOCKS proxy in SOCKS4 mode.

    Has relatively fewer tests than the SOCKS5 case, mostly because once the
    negotiation is done the two cases behave identically.
    """"""
    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.headers['Server'], 'SocksTestServer')
        self.assertEqual(response.data, b'')

    def test_local_dns(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            self.assertEqual(addr, '127.0.0.1')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://localhost')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.headers['Server'], 'SocksTestServer')
        self.assertEqual(response.data, b'')

    def test_correct_header_line(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            self.assertEqual(addr, b'example.com')
            self.assertEqual(port, 80)
            handler.send(True)

            buf = b''
            while True:
                buf += sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            self.assertTrue(buf.startswith(b'GET / HTTP/1.1'))
            self.assertIn(b'Host: example.com', buf)

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://example.com')
        self.assertEqual(response.status, 200)

    def test_proxy_rejection(self):
        evt = threading.Event()

        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)
            handler.send(False)

            evt.wait()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        self.assertRaises(
            NewConnectionError, pm.request, 'GET', 'http://example.com',
            retries=False
        )
        evt.set()

    def test_socks4_with_username(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock, username=b'user')
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='user')
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_socks_with_invalid_username(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock, username=b'user')
            next(handler)

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='baduser')
        self.addCleanup(pm.clear)

        try:
            pm.request('GET', 'http://example.com', retries=False)
        except NewConnectionError as e:
            self.assertIn(""different user-ids"", str(e))
        else:
            self.fail(""Did not raise"")


class TestSOCKSWithTLS(IPV4SocketDummyServerTestCase):
    """"""
    Test that TLS behaves properly for SOCKS proxies.
    """"""
    @pytest.mark.skipif(not HAS_SSL, reason='No TLS available')
    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, b'localhost')
            self.assertEqual(port, 443)
            handler.send(True)

            # Wrap in TLS
            context = better_ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            context.load_cert_chain(
                DEFAULT_CERTS['certfile'], DEFAULT_CERTS['keyfile']
            )
            tls = context.wrap_socket(sock, server_side=True)
            buf = b''

            while True:
                buf += tls.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            self.assertTrue(buf.startswith(b'GET / HTTP/1.1\r\n'))

            tls.sendall(b'HTTP/1.1 200 OK\r\n'
                        b'Server: SocksTestServer\r\n'
                        b'Content-Length: 0\r\n'
                        b'\r\n')
            tls.close()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'https://localhost')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR = VAR VAR VAR: VAR = VAR VAR = VAR VAR = VAR VAR = VAR'\VAR' VAR = VAR'\VAR' VAR = VAR'\VAR' VAR = VAR'\VAR' VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR.VAR((VAR, 0)) VAR = VAR.VAR()[1] VAR.VAR() VAR VAR VAR VAR(VAR, VAR): """""" VAR *VAR* ``VAR`` VAR VAR VAR VAR ``VAR``. """""" VAR = VAR'' VAR VAR > 0: VAR = VAR.VAR(VAR) VAR += VAR VAR -= VAR(VAR) VAR VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = [] VAR VAR: VAR = VAR.VAR(1) VAR.VAR(VAR) VAR VAR == VAR: VAR VAR VAR''.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR.VAR(1) VAR VAR == VAR'\VAR': VAR = VAR(VAR, 4) VAR VAR.VAR(VAR) VAR VAR == VAR'\VAR': VAR = VAR(VAR, 16) VAR VAR.VAR(VAR.VAR, VAR) VAR VAR == VAR'\VAR': VAR = VAR(VAR.VAR(1)) VAR VAR(VAR, VAR) VAR: VAR VAR(""VAR VAR VAR: %VAR"" % VAR) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): """""" VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(1) VAR VAR == VAR VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR VAR: VAR VAR VAR VAR VAR = VAR + VAR VAR.VAR(VAR)  VAR = VAR.VAR(1) VAR VAR == VAR'\VAR' VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR VAR == VAR VAR VAR == VAR: VAR.VAR(VAR'\VAR\VAR') VAR: VAR.VAR(VAR'\VAR\VAR') VAR.VAR() VAR VAR VAR VAR: VAR VAR VAR VAR VAR = VAR + VAR VAR.VAR(VAR)  VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR(VAR) VAR = VAR(VAR, 2) VAR = (VAR(VAR[0:1]) << 8) + (VAR(VAR[1:2]))  VAR VAR == VAR VAR VAR == VAR'\VAR'  VAR VAR == VAR'\VAR'  VAR = VAR VAR, VAR VAR VAR:  VAR = ( VAR + VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ) VAR:  VAR = VAR + VAR'\VAR\00' VAR.VAR(VAR) VAR VAR  VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR(VAR, 2) VAR = (VAR(VAR[0:1]) << 8) + (VAR(VAR[1:2])) VAR = VAR(VAR, 4) VAR = VAR(VAR, VAR'\VAR')[:-1]  VAR VAR == VAR'\VAR\VAR\VAR\VAR':  VAR = VAR(VAR, VAR'\VAR')[:-1]  VAR: VAR = VAR.VAR(VAR)  VAR VAR == VAR VAR VAR == VAR'\VAR'  VAR VAR VAR VAR VAR VAR VAR != VAR: VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR') VAR.VAR() VAR VAR VAR  VAR = VAR VAR, VAR VAR VAR: VAR = VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR: VAR = VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR.VAR(VAR) VAR VAR  VAR VAR(VAR): VAR VAR(VAR): VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(VAR='VAR: VAR 'VAR VAR VAR VAR VAR' VAR VAR.VAR.VAR[0] VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, ['127.0.0.1', '::1']) VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, VAR'VAR.VAR') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR = VAR'' VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR.VAR(VAR'VAR / VAR/1.1')) VAR.VAR(VAR'VAR: VAR.VAR', VAR) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=0.001, VAR=VAR ) VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR() VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR ) VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR ) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR'VAR', VAR=VAR'VAR' ) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR', VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR.VAR. VAR: """""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR'VAR', VAR=VAR'VAR' ) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR'VAR', VAR=VAR'VAR' ) VAR(VAR) VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR', VAR='VAR') VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', 'VAR: VAR VAR VAR VAR: VAR.VAR(""VAR VAR VAR"", VAR(VAR)) VAR: VAR.VAR(""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR(VAR.VAR()[0], '127.0.0.1') VAR.VAR(VAR.VAR()[1], VAR) VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR( VAR, VAR=('127.0.0.1', VAR) ) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR.VAR(VAR.VAR, VAR'') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '127.0.0.1') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR.VAR(VAR.VAR, VAR'') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, VAR'VAR.VAR') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR = VAR'' VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR.VAR(VAR'VAR / VAR/1.1')) VAR.VAR(VAR'VAR: VAR.VAR', VAR) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR ) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR'VAR') VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR'VAR') VAR(VAR) VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', 'VAR: VAR VAR VAR VAR: VAR.VAR(""VAR VAR-VAR"", VAR(VAR)) VAR: VAR.VAR(""VAR VAR VAR"") VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. """""" @VAR.VAR.VAR(VAR VAR, VAR='VAR VAR VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, VAR'VAR') VAR.VAR(VAR, 443) VAR.VAR(VAR)  VAR = VAR.VAR(VAR.VAR) VAR.VAR( VAR['VAR'], VAR['VAR'] ) VAR = VAR.VAR(VAR, VAR=VAR) VAR = VAR'' VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR.VAR(VAR'VAR / VAR/1.1\VAR\VAR')) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') ",8
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/with_dummyserver/test_connectionpool.py,"import io
import logging
import socket
import sys
import unittest
import time
import warnings
import pytest

import mock

from .. import (
    TARPIT_HOST, VALID_SOURCE_ADDRESSES, INVALID_SOURCE_ADDRESSES,
)
from ..port_helpers import find_unused_port
from urllib3 import (
    encode_multipart_formdata,
    HTTPConnectionPool,
)
from urllib3.exceptions import (
    ConnectTimeoutError,
    EmptyPoolError,
    DecodeError,
    MaxRetryError,
    ReadTimeoutError,
    NewConnectionError,
    UnrewindableBodyError,
)
from urllib3.packages.six import b, u
from urllib3.packages.six.moves.urllib.parse import urlencode
from urllib3.util.retry import Retry, RequestHistory
from urllib3.util.timeout import Timeout

from dummyserver.testcase import HTTPDummyServerTestCase, SocketDummyServerTestCase
from dummyserver.server import NoIPv6Warning, HAS_IPV6_AND_DNS

from threading import Event

log = logging.getLogger('urllib3.connectionpool')
log.setLevel(logging.NOTSET)
log.addHandler(logging.StreamHandler(sys.stdout))


SHORT_TIMEOUT = 0.001
LONG_TIMEOUT = 0.03


def wait_for_socket(ready_event):
    ready_event.wait()
    ready_event.clear()


class TestConnectionPoolTimeouts(SocketDummyServerTestCase):

    def test_timeout_float(self):
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=2)

        # Pool-global timeout
        pool = HTTPConnectionPool(self.host, self.port, timeout=SHORT_TIMEOUT, retries=False)
        self.addCleanup(pool.close)
        wait_for_socket(ready_event)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')
        block_event.set()  # Release block

        # Shouldn't raise this time
        wait_for_socket(ready_event)
        block_event.set()  # Pre-release block
        pool.request('GET', '/')

    def test_conn_closed(self):
        block_event = Event()
        self.start_basic_handler(block_send=block_event, num=1)

        pool = HTTPConnectionPool(self.host, self.port, timeout=SHORT_TIMEOUT, retries=False)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        pool._put_conn(conn)
        try:
            pool.urlopen('GET', '/')
            self.fail(""The request should fail with a timeout error."")
        except ReadTimeoutError:
            if conn.sock:
                self.assertRaises(socket.error, conn.sock.recv, 1024)
        finally:
            pool._put_conn(conn)

        block_event.set()

    def test_timeout(self):
        # Requests should time out when expected
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=6)

        # Pool-global timeout
        timeout = Timeout(read=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)

        wait_for_socket(ready_event)
        conn = pool._get_conn()
        self.assertRaises(ReadTimeoutError, pool._make_request, conn, 'GET', '/')
        pool._put_conn(conn)
        block_event.set()  # Release request

        wait_for_socket(ready_event)
        block_event.clear()
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')
        block_event.set()  # Release request

        # Request-specific timeouts should raise errors
        pool = HTTPConnectionPool(self.host, self.port, timeout=LONG_TIMEOUT, retries=False)
        self.addCleanup(pool.close)

        conn = pool._get_conn()
        wait_for_socket(ready_event)
        now = time.time()
        self.assertRaises(ReadTimeoutError, pool._make_request, conn, 'GET', '/', timeout=timeout)
        delta = time.time() - now
        block_event.set()  # Release request

        message = ""timeout was pool-level LONG_TIMEOUT rather than request-level SHORT_TIMEOUT""
        self.assertLess(delta, LONG_TIMEOUT, message)
        pool._put_conn(conn)

        wait_for_socket(ready_event)
        now = time.time()
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/', timeout=timeout)
        delta = time.time() - now

        message = ""timeout was pool-level LONG_TIMEOUT rather than request-level SHORT_TIMEOUT""
        self.assertLess(delta, LONG_TIMEOUT, message)
        block_event.set()  # Release request

        # Timeout int/float passed directly to request and _make_request should
        # raise a request timeout
        wait_for_socket(ready_event)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/', timeout=SHORT_TIMEOUT)
        block_event.set()  # Release request

        wait_for_socket(ready_event)
        conn = pool._new_conn()
        # FIXME: This assert flakes sometimes. Not sure why.
        self.assertRaises(ReadTimeoutError,
                          pool._make_request,
                          conn, 'GET', '/',
                          timeout=SHORT_TIMEOUT)
        block_event.set()  # Release request

    def test_connect_timeout(self):
        url = '/'
        host, port = TARPIT_HOST, 80
        timeout = Timeout(connect=SHORT_TIMEOUT)

        # Pool-global timeout
        pool = HTTPConnectionPool(host, port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.assertRaises(ConnectTimeoutError, pool._make_request, conn, 'GET', url)

        # Retries
        retries = Retry(connect=0)
        self.assertRaises(MaxRetryError, pool.request, 'GET', url, retries=retries)

        # Request-specific connection timeouts
        big_timeout = Timeout(read=LONG_TIMEOUT, connect=LONG_TIMEOUT)
        pool = HTTPConnectionPool(host, port, timeout=big_timeout, retries=False)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.assertRaises(ConnectTimeoutError,
                          pool._make_request,
                          conn, 'GET', url,
                          timeout=timeout)

        pool._put_conn(conn)
        self.assertRaises(ConnectTimeoutError, pool.request, 'GET', url, timeout=timeout)

    def test_total_applies_connect(self):
        host, port = TARPIT_HOST, 80

        timeout = Timeout(total=None, connect=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(host, port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        self.assertRaises(ConnectTimeoutError, pool._make_request, conn, 'GET', '/')

        timeout = Timeout(connect=3, read=5, total=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(host, port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        self.assertRaises(ConnectTimeoutError, pool._make_request, conn, 'GET', '/')

    def test_total_timeout(self):
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=2)

        wait_for_socket(ready_event)
        # This will get the socket to raise an EAGAIN on the read
        timeout = Timeout(connect=3, read=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')

        block_event.set()
        wait_for_socket(ready_event)
        block_event.clear()

        # The connect should succeed and this should hit the read timeout
        timeout = Timeout(connect=3, read=5, total=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')

    def test_create_connection_timeout(self):
        timeout = Timeout(connect=SHORT_TIMEOUT, total=LONG_TIMEOUT)
        pool = HTTPConnectionPool(TARPIT_HOST, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)
        conn = pool._new_conn()
        self.assertRaises(ConnectTimeoutError, conn.connect)


class TestConnectionPool(HTTPDummyServerTestCase):

    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(self.pool.close)

    def test_get(self):
        r = self.pool.request('GET', '/specific_method',
                              fields={'method': 'GET'})
        self.assertEqual(r.status, 200, r.data)

    def test_post_url(self):
        r = self.pool.request('POST', '/specific_method',
                              fields={'method': 'POST'})
        self.assertEqual(r.status, 200, r.data)

    def test_urlopen_put(self):
        r = self.pool.urlopen('PUT', '/specific_method?method=PUT')
        self.assertEqual(r.status, 200, r.data)

    def test_wrong_specific_method(self):
        # To make sure the dummy server is actually returning failed responses
        r = self.pool.request('GET', '/specific_method',
                              fields={'method': 'POST'})
        self.assertEqual(r.status, 400, r.data)

        r = self.pool.request('POST', '/specific_method',
                              fields={'method': 'GET'})
        self.assertEqual(r.status, 400, r.data)

    def test_upload(self):
        data = ""I'm in ur multipart form-data, hazing a cheezburgr""
        fields = {
            'upload_param': 'filefield',
            'upload_filename': 'lolcat.txt',
            'upload_size': len(data),
            'filefield': ('lolcat.txt', data),
        }

        r = self.pool.request('POST', '/upload', fields=fields)
        self.assertEqual(r.status, 200, r.data)

    def test_one_name_multiple_values(self):
        fields = [
            ('foo', 'a'),
            ('foo', 'b'),
        ]

        # urlencode
        r = self.pool.request('GET', '/echo', fields=fields)
        self.assertEqual(r.data, b'foo=a&foo=b')

        # multipart
        r = self.pool.request('POST', '/echo', fields=fields)
        self.assertEqual(r.data.count(b'name=""foo""'), 2)

    def test_request_method_body(self):
        body = b'hi'
        r = self.pool.request('POST', '/echo', body=body)
        self.assertEqual(r.data, body)

        fields = [('hi', 'hello')]
        self.assertRaises(TypeError, self.pool.request, 'POST', '/echo', body=body, fields=fields)

    def test_unicode_upload(self):
        fieldname = u('myfile')
        filename = u('\xe2\x99\xa5.txt')
        data = u('\xe2\x99\xa5').encode('utf8')
        size = len(data)

        fields = {
            u('upload_param'): fieldname,
            u('upload_filename'): filename,
            u('upload_size'): size,
            fieldname: (filename, data),
        }

        r = self.pool.request('POST', '/upload', fields=fields)
        self.assertEqual(r.status, 200, r.data)

    def test_nagle(self):
        """""" Test that connections have TCP_NODELAY turned on """"""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        pool._make_request(conn, 'GET', '/')
        tcp_nodelay_setting = conn.sock.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)
        self.assertTrue(tcp_nodelay_setting)

    def test_socket_options(self):
        """"""Test that connections accept socket options.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries to
        # connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port, socket_options=[
            (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
        ])
        s = pool._new_conn()._new_conn()  # Get the socket
        using_keepalive = s.getsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE) > 0
        self.assertTrue(using_keepalive)
        s.close()

    def test_disable_default_socket_options(self):
        """"""Test that passing None disables all socket options.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port, socket_options=None)
        s = pool._new_conn()._new_conn()
        using_nagle = s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY) == 0
        self.assertTrue(using_nagle)
        s.close()

    def test_defaults_are_applied(self):
        """"""Test that modifying the default socket options works.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        # Get the HTTPConnection instance
        conn = pool._new_conn()
        self.addCleanup(conn.close)
        # Update the default socket options
        conn.default_socket_options += [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]
        s = conn._new_conn()
        self.addCleanup(s.close)
        nagle_disabled = s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY) > 0
        using_keepalive = s.getsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE) > 0
        self.assertTrue(nagle_disabled)
        self.assertTrue(using_keepalive)

    def test_connection_error_retries(self):
        """""" ECONNREFUSED error should raise a connection error, with retries """"""
        port = find_unused_port()
        pool = HTTPConnectionPool(self.host, port)
        try:
            pool.request('GET', '/', retries=Retry(connect=3))
            self.fail(""Should have failed with a connection error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), NewConnectionError)

    def test_timeout_success(self):
        timeout = Timeout(connect=3, read=5, total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        pool.request('GET', '/')
        # This should not raise a ""Timeout already started"" error
        pool.request('GET', '/')

        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        # This should also not raise a ""Timeout already started"" error
        pool.request('GET', '/')

        timeout = Timeout(total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        pool.request('GET', '/')

    def test_tunnel(self):
        # note the actual httplib.py has no tests for this functionality
        timeout = Timeout(total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        conn.set_tunnel(self.host, self.port)

        conn._tunnel = mock.Mock(return_value=None)
        pool._make_request(conn, 'GET', '/')
        conn._tunnel.assert_called_once_with()

        # test that it's not called when tunnel is not set
        timeout = Timeout(total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)

        conn._tunnel = mock.Mock(return_value=None)
        pool._make_request(conn, 'GET', '/')
        self.assertFalse(conn._tunnel.called)

    def test_redirect(self):
        r = self.pool.request('GET', '/redirect', fields={'target': '/'}, redirect=False)
        self.assertEqual(r.status, 303)

        r = self.pool.request('GET', '/redirect', fields={'target': '/'})
        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_bad_connect(self):
        pool = HTTPConnectionPool('badhost.invalid', self.port)
        try:
            pool.request('GET', '/', retries=5)
            self.fail(""should raise timeout exception here"")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), NewConnectionError)

    def test_keepalive(self):
        pool = HTTPConnectionPool(self.host, self.port, block=True, maxsize=1)
        self.addCleanup(pool.close)

        r = pool.request('GET', '/keepalive?close=0')
        r = pool.request('GET', '/keepalive?close=0')

        self.assertEqual(r.status, 200)
        self.assertEqual(pool.num_connections, 1)
        self.assertEqual(pool.num_requests, 2)

    def test_keepalive_close(self):
        pool = HTTPConnectionPool(self.host, self.port,
                                  block=True, maxsize=1, timeout=2)
        self.addCleanup(pool.close)

        r = pool.request('GET', '/keepalive?close=1', retries=0,
                         headers={
                             ""Connection"": ""close"",
                         })

        self.assertEqual(pool.num_connections, 1)

        # The dummyserver will have responded with Connection:close,
        # and httplib will properly cleanup the socket.

        # We grab the HTTPConnection object straight from the Queue,
        # because _get_conn() is where the check & reset occurs
        # pylint: disable-msg=W0212
        conn = pool.pool.get()
        self.assertIsNone(conn.sock)
        pool._put_conn(conn)

        # Now with keep-alive
        r = pool.request('GET', '/keepalive?close=0', retries=0,
                         headers={
                             ""Connection"": ""keep-alive"",
                         })

        # The dummyserver responded with Connection:keep-alive, the connection
        # persists.
        conn = pool.pool.get()
        self.assertIsNotNone(conn.sock)
        pool._put_conn(conn)

        # Another request asking the server to close the connection. This one
        # should get cleaned up for the next request.
        r = pool.request('GET', '/keepalive?close=1', retries=0,
                         headers={
                             ""Connection"": ""close"",
                         })

        self.assertEqual(r.status, 200)

        conn = pool.pool.get()
        self.assertIsNone(conn.sock)
        pool._put_conn(conn)

        # Next request
        r = pool.request('GET', '/keepalive?close=0')

    def test_post_with_urlencode(self):
        data = {'banana': 'hammock', 'lol': 'cat'}
        r = self.pool.request('POST', '/echo', fields=data, encode_multipart=False)
        self.assertEqual(r.data.decode('utf-8'), urlencode(data))

    def test_post_with_multipart(self):
        data = {'banana': 'hammock', 'lol': 'cat'}
        r = self.pool.request('POST', '/echo',
                              fields=data,
                              encode_multipart=True)
        body = r.data.split(b'\r\n')

        encoded_data = encode_multipart_formdata(data)[0]
        expected_body = encoded_data.split(b'\r\n')

        # TODO: Get rid of extra parsing stuff when you can specify
        # a custom boundary to encode_multipart_formdata
        """"""
        We need to loop the return lines because a timestamp is attached
        from within encode_multipart_formdata. When the server echos back
        the data, it has the timestamp from when the data was encoded, which
        is not equivalent to when we run encode_multipart_formdata on
        the data again.
        """"""
        for i, line in enumerate(body):
            if line.startswith(b'--'):
                continue

            self.assertEqual(body[i], expected_body[i])

    def test_check_gzip(self):
        r = self.pool.request('GET', '/encodingrequest',
                              headers={'accept-encoding': 'gzip'})
        self.assertEqual(r.headers.get('content-encoding'), 'gzip')
        self.assertEqual(r.data, b'hello, world!')

    def test_check_deflate(self):
        r = self.pool.request('GET', '/encodingrequest',
                              headers={'accept-encoding': 'deflate'})
        self.assertEqual(r.headers.get('content-encoding'), 'deflate')
        self.assertEqual(r.data, b'hello, world!')

    def test_bad_decode(self):
        self.assertRaises(DecodeError, self.pool.request,
                          'GET', '/encodingrequest',
                          headers={'accept-encoding': 'garbage-deflate'})

        self.assertRaises(DecodeError, self.pool.request,
                          'GET', '/encodingrequest',
                          headers={'accept-encoding': 'garbage-gzip'})

    def test_connection_count(self):
        pool = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(pool.close)

        pool.request('GET', '/')
        pool.request('GET', '/')
        pool.request('GET', '/')

        self.assertEqual(pool.num_connections, 1)
        self.assertEqual(pool.num_requests, 3)

    def test_connection_count_bigpool(self):
        http_pool = HTTPConnectionPool(self.host, self.port, maxsize=16)
        self.addCleanup(http_pool.close)

        http_pool.request('GET', '/')
        http_pool.request('GET', '/')
        http_pool.request('GET', '/')

        self.assertEqual(http_pool.num_connections, 1)
        self.assertEqual(http_pool.num_requests, 3)

    def test_partial_response(self):
        pool = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(pool.close)

        req_data = {'lol': 'cat'}
        resp_data = urlencode(req_data).encode('utf-8')

        r = pool.request('GET', '/echo', fields=req_data, preload_content=False)

        self.assertEqual(r.read(5), resp_data[:5])
        self.assertEqual(r.read(), resp_data[5:])

    def test_lazy_load_twice(self):
        # This test is sad and confusing. Need to figure out what's
        # going on with partial reads and socket reuse.

        pool = HTTPConnectionPool(self.host, self.port, block=True, maxsize=1, timeout=2)

        payload_size = 1024 * 2
        first_chunk = 512

        boundary = 'foo'

        req_data = {'count': 'a' * payload_size}
        resp_data = encode_multipart_formdata(req_data, boundary=boundary)[0]

        req2_data = {'count': 'b' * payload_size}
        resp2_data = encode_multipart_formdata(req2_data, boundary=boundary)[0]

        r1 = pool.request('POST', '/echo',
                          fields=req_data,
                          multipart_boundary=boundary,
                          preload_content=False)

        self.assertEqual(r1.read(first_chunk), resp_data[:first_chunk])

        try:
            r2 = pool.request('POST', '/echo', fields=req2_data, multipart_boundary=boundary,
                              preload_content=False, pool_timeout=0.001)

            # This branch should generally bail here, but maybe someday it will
            # work? Perhaps by some sort of magic. Consider it a TODO.

            self.assertEqual(r2.read(first_chunk), resp2_data[:first_chunk])

            self.assertEqual(r1.read(), resp_data[first_chunk:])
            self.assertEqual(r2.read(), resp2_data[first_chunk:])
            self.assertEqual(pool.num_requests, 2)

        except EmptyPoolError:
            self.assertEqual(r1.read(), resp_data[first_chunk:])
            self.assertEqual(pool.num_requests, 1)

        self.assertEqual(pool.num_connections, 1)

    def test_for_double_release(self):
        MAXSIZE = 5

        # Check default state
        pool = HTTPConnectionPool(self.host, self.port, maxsize=MAXSIZE)
        self.addCleanup(pool.close)
        self.assertEqual(pool.num_connections, 0)
        self.assertEqual(pool.pool.qsize(), MAXSIZE)

        # Make an empty slot for testing
        pool.pool.get()
        self.assertEqual(pool.pool.qsize(), MAXSIZE-1)

        # Check state after simple request
        pool.urlopen('GET', '/')
        self.assertEqual(pool.pool.qsize(), MAXSIZE-1)

        # Check state without release
        pool.urlopen('GET', '/', preload_content=False)
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

        pool.urlopen('GET', '/')
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

        # Check state after read
        pool.urlopen('GET', '/').data
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

        pool.urlopen('GET', '/')
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

    def test_release_conn_parameter(self):
        MAXSIZE = 5
        pool = HTTPConnectionPool(self.host, self.port, maxsize=MAXSIZE)
        self.assertEqual(pool.pool.qsize(), MAXSIZE)

        # Make request without releasing connection
        pool.request('GET', '/', release_conn=False, preload_content=False)
        self.assertEqual(pool.pool.qsize(), MAXSIZE-1)

    def test_dns_error(self):
        pool = HTTPConnectionPool('thishostdoesnotexist.invalid', self.port, timeout=0.001)
        self.assertRaises(MaxRetryError, pool.request, 'GET', '/test', retries=2)

    def test_source_address(self):
        for addr, is_ipv6 in VALID_SOURCE_ADDRESSES:
            if is_ipv6 and not HAS_IPV6_AND_DNS:
                warnings.warn(""No IPv6 support: skipping."",
                              NoIPv6Warning)
                continue
            pool = HTTPConnectionPool(self.host, self.port,
                                      source_address=addr, retries=False)
            self.addCleanup(pool.close)
            r = pool.request('GET', '/source_address')
            self.assertEqual(r.data, b(addr[0]))

    def test_source_address_error(self):
        for addr in INVALID_SOURCE_ADDRESSES:
            pool = HTTPConnectionPool(self.host, self.port, source_address=addr, retries=False)
            # FIXME: This assert flakes sometimes. Not sure why.
            self.assertRaises(NewConnectionError,
                              pool.request,
                              'GET', '/source_address?{0}'.format(addr))

    def test_stream_keepalive(self):
        x = 2

        for _ in range(x):
            response = self.pool.request(
                    'GET',
                    '/chunked',
                    headers={
                        'Connection': 'keep-alive',
                        },
                    preload_content=False,
                    retries=False,
                    )
            for chunk in response.stream():
                self.assertEqual(chunk, b'123')

        self.assertEqual(self.pool.num_connections, 1)
        self.assertEqual(self.pool.num_requests, x)

    def test_read_chunked_short_circuit(self):
        response = self.pool.request(
            'GET',
            '/chunked',
            preload_content=False
        )
        response.read()
        with pytest.raises(StopIteration):
            next(response.read_chunked())

    def test_read_chunked_on_closed_response(self):
        response = self.pool.request(
            'GET',
            '/chunked',
            preload_content=False
        )
        response.close()
        with pytest.raises(StopIteration):
            next(response.read_chunked())

    def test_chunked_gzip(self):
        response = self.pool.request(
                'GET',
                '/chunked_gzip',
                preload_content=False,
                decode_content=True,
                )

        self.assertEqual(b'123' * 4, response.read())

    def test_cleanup_on_connection_error(self):
        '''
        Test that connections are recycled to the pool on
        connection errors where no http response is received.
        '''
        poolsize = 3
        with HTTPConnectionPool(self.host, self.port, maxsize=poolsize, block=True) as http:
            self.assertEqual(http.pool.qsize(), poolsize)

            # force a connection error by supplying a non-existent
            # url. We won't get a response for this  and so the
            # conn won't be implicitly returned to the pool.
            self.assertRaises(MaxRetryError,
                              http.request,
                              'GET', '/redirect',
                              fields={'target': '/'}, release_conn=False, retries=0)

            r = http.request('GET', '/redirect',
                             fields={'target': '/'},
                             release_conn=False,
                             retries=1)
            r.release_conn()

            # the pool should still contain poolsize elements
            self.assertEqual(http.pool.qsize(), http.pool.maxsize)

    def test_mixed_case_hostname(self):
        pool = HTTPConnectionPool(""LoCaLhOsT"", self.port)
        self.addCleanup(pool.close)
        response = pool.request('GET', ""http://LoCaLhOsT:%d/"" % self.port)
        self.assertEqual(response.status, 200)


class TestRetry(HTTPDummyServerTestCase):
    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(self.pool.close)

    def test_max_retry(self):
        try:
            r = self.pool.request('GET', '/redirect',
                                  fields={'target': '/'},
                                  retries=0)
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

    def test_disabled_retry(self):
        """""" Disabled retries should disable redirect handling. """"""
        r = self.pool.request('GET', '/redirect',
                              fields={'target': '/'},
                              retries=False)
        self.assertEqual(r.status, 303)

        r = self.pool.request('GET', '/redirect',
                              fields={'target': '/'},
                              retries=Retry(redirect=False))
        self.assertEqual(r.status, 303)

        pool = HTTPConnectionPool('thishostdoesnotexist.invalid', self.port, timeout=0.001)
        self.assertRaises(NewConnectionError, pool.request, 'GET', '/test', retries=False)

    def test_read_retries(self):
        """""" Should retry for status codes in the whitelist """"""
        retry = Retry(read=1, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers={'test-name': 'test_read_retries'},
                                 retries=retry)
        self.assertEqual(resp.status, 200)

    def test_read_total_retries(self):
        """""" HTTP response w/ status code in the whitelist should be retried """"""
        headers = {'test-name': 'test_read_total_retries'}
        retry = Retry(total=1, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)

    def test_retries_wrong_whitelist(self):
        """"""HTTP response w/ status code not in whitelist shouldn't be retried""""""
        retry = Retry(total=1, status_forcelist=[202])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers={'test-name': 'test_wrong_whitelist'},
                                 retries=retry)
        self.assertEqual(resp.status, 418)

    def test_default_method_whitelist_retried(self):
        """""" urllib3 should retry methods in the default method whitelist """"""
        retry = Retry(total=1, status_forcelist=[418])
        resp = self.pool.request('OPTIONS', '/successful_retry',
                                 headers={'test-name': 'test_default_whitelist'},
                                 retries=retry)
        self.assertEqual(resp.status, 200)

    def test_retries_wrong_method_list(self):
        """"""Method not in our whitelist should not be retried, even if code matches""""""
        headers = {'test-name': 'test_wrong_method_whitelist'}
        retry = Retry(total=1, status_forcelist=[418],
                      method_whitelist=['POST'])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 418)

    def test_read_retries_unsuccessful(self):
        headers = {'test-name': 'test_read_retries_unsuccessful'}
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=1)
        self.assertEqual(resp.status, 418)

    def test_retry_reuse_safe(self):
        """""" It should be possible to reuse a Retry object across requests """"""
        headers = {'test-name': 'test_retry_safe'}
        retry = Retry(total=1, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)

    def test_retry_return_in_response(self):
        headers = {'test-name': 'test_retry_return_in_response'}
        retry = Retry(total=2, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)
        self.assertEqual(resp.retries.total, 1)
        self.assertEqual(resp.retries.history,
                         (RequestHistory('GET', '/successful_retry', None, 418, None),))

    def test_retry_redirect_history(self):
        resp = self.pool.request('GET', '/redirect', fields={'target': '/'})
        self.assertEqual(resp.status, 200)
        self.assertEqual(resp.retries.history,
                         (RequestHistory('GET', '/redirect?target=%2F', None, 303, '/'),))

    def test_multi_redirect_history(self):
        r = self.pool.request('GET', '/multi_redirect',
                              fields={'redirect_codes': '303,302,200'},
                              redirect=False)
        self.assertEqual(r.status, 303)
        self.assertEqual(r.retries.history, tuple())

        r = self.pool.request('GET', '/multi_redirect', retries=10,
                              fields={'redirect_codes': '303,302,301,307,302,200'})
        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Done redirecting')

        expected = [(303, '/multi_redirect?redirect_codes=302,301,307,302,200'),
                    (302, '/multi_redirect?redirect_codes=301,307,302,200'),
                    (301, '/multi_redirect?redirect_codes=307,302,200'),
                    (307, '/multi_redirect?redirect_codes=302,200'),
                    (302, '/multi_redirect?redirect_codes=200')]
        actual = [(history.status, history.redirect_location) for history in r.retries.history]
        self.assertEqual(actual, expected)


class TestRetryAfter(HTTPDummyServerTestCase):
    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(self.pool.close)

    def test_retry_after(self):
        # Request twice in a second to get a 429 response.
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '429 Too Many Requests'},
                              retries=False)
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '429 Too Many Requests'},
                              retries=False)
        self.assertEqual(r.status, 429)

        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '429 Too Many Requests'},
                              retries=True)
        self.assertEqual(r.status, 200)

        # Request twice in a second to get a 503 response.
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '503 Service Unavailable'},
                              retries=False)
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '503 Service Unavailable'},
                              retries=False)
        self.assertEqual(r.status, 503)

        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '503 Service Unavailable'},
                              retries=True)
        self.assertEqual(r.status, 200)

        # Ignore Retry-After header on status which is not defined in
        # Retry.RETRY_AFTER_STATUS_CODES.
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': ""418 I'm a teapot""},
                              retries=True)
        self.assertEqual(r.status, 418)

    def test_redirect_after(self):
        r = self.pool.request('GET', '/redirect_after', retries=False)
        self.assertEqual(r.status, 303)

        t = time.time()
        r = self.pool.request('GET', '/redirect_after')
        self.assertEqual(r.status, 200)
        delta = time.time() - t
        self.assertGreaterEqual(delta, 1)

        t = time.time()
        timestamp = t + 2
        r = self.pool.request('GET', '/redirect_after?date=' + str(timestamp))
        self.assertEqual(r.status, 200)
        delta = time.time() - t
        self.assertGreaterEqual(delta, 1)

        # Retry-After is past
        t = time.time()
        timestamp = t - 1
        r = self.pool.request('GET', '/redirect_after?date=' + str(timestamp))
        delta = time.time() - t
        self.assertEqual(r.status, 200)
        self.assertLess(delta, 1)


class TestFileBodiesOnRetryOrRedirect(HTTPDummyServerTestCase):
    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port, timeout=0.1)
        self.addCleanup(self.pool.close)

    def test_retries_put_filehandle(self):
        """"""HTTP PUT retry with a file-like object should not timeout""""""
        retry = Retry(total=3, status_forcelist=[418])
        # httplib reads in 8k chunks; use a larger content length
        content_length = 65535
        data = b'A' * content_length
        uploaded_file = io.BytesIO(data)
        headers = {'test-name': 'test_retries_put_filehandle',
                   'Content-Length': str(content_length)}
        resp = self.pool.urlopen('PUT', '/successful_retry',
                                 headers=headers,
                                 retries=retry,
                                 body=uploaded_file,
                                 assert_same_host=False, redirect=False)
        self.assertEqual(resp.status, 200)

    def test_redirect_put_file(self):
        """"""PUT with file object should work with a redirection response""""""
        retry = Retry(total=3, status_forcelist=[418])
        # httplib reads in 8k chunks; use a larger content length
        content_length = 65535
        data = b'A' * content_length
        uploaded_file = io.BytesIO(data)
        headers = {'test-name': 'test_redirect_put_file',
                   'Content-Length': str(content_length)}
        url = '/redirect?target=/echo&status=307'
        resp = self.pool.urlopen('PUT', url,
                                 headers=headers,
                                 retries=retry,
                                 body=uploaded_file,
                                 assert_same_host=False, redirect=True)
        self.assertEqual(resp.status, 200)
        self.assertEqual(resp.data, data)

    def test_redirect_with_failed_tell(self):
        """"""Abort request if failed to get a position from tell()""""""
        class BadTellObject(io.BytesIO):

            def tell(self):
                raise IOError

        body = BadTellObject(b'the data')
        url = '/redirect?target=/successful_retry'
        # httplib uses fileno if Content-Length isn't supplied,
        # which is unsupported by BytesIO.
        headers = {'Content-Length': '8'}
        try:
            self.pool.urlopen('PUT', url, headers=headers, body=body)
            self.fail('PUT successful despite failed rewind.')
        except UnrewindableBodyError as e:
            self.assertIn('Unable to record file position for', str(e))


class TestRetryPoolSize(HTTPDummyServerTestCase):
    def setUp(self):
        retries = Retry(
            total=1,
            raise_on_status=False,
            status_forcelist=[404],
        )
        self.pool = HTTPConnectionPool(self.host, self.port, maxsize=10,
                                       retries=retries, block=True)
        self.addCleanup(self.pool.close)

    def test_pool_size_retry(self):
        self.pool.urlopen('GET', '/not_found', preload_content=False)
        assert self.pool.num_connections == 1


class TestRedirectPoolSize(HTTPDummyServerTestCase):
    def setUp(self):
        retries = Retry(
            total=1,
            raise_on_status=False,
            status_forcelist=[404],
            redirect=True,
        )
        self.pool = HTTPConnectionPool(self.host, self.port, maxsize=10,
                                       retries=retries, block=True)
        self.addCleanup(self.pool.close)

    def test_pool_size_redirect(self):
        self.pool.urlopen('GET', '/redirect', preload_content=False)
        assert self.pool.num_connections == 1


if __name__ == '__main__':
    unittest.main()",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .. VAR ( VAR, VAR, VAR, ) VAR ..VAR VAR VAR VAR VAR VAR ( VAR, VAR, ) VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR, VAR VAR VAR VAR VAR VAR = VAR.VAR('VAR.VAR') VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR(VAR.VAR)) VAR = 0.001 VAR = 0.03 VAR VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=2)  VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR(VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR()   VAR(VAR) VAR.VAR()  VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR=VAR, VAR=1) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR.VAR, 1024) VAR: VAR.VAR(VAR) VAR.VAR() VAR VAR(VAR):  VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=6)  VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR.VAR(VAR) VAR.VAR()  VAR(VAR) VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR()   VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/', VAR=VAR) VAR = VAR.VAR() - VAR VAR.VAR()  VAR = ""VAR VAR VAR-VAR VAR VAR VAR VAR-VAR VAR"" VAR.VAR(VAR, VAR, VAR) VAR.VAR(VAR) VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR) VAR = VAR.VAR() - VAR VAR = ""VAR VAR VAR-VAR VAR VAR VAR VAR-VAR VAR"" VAR.VAR(VAR, VAR, VAR) VAR.VAR()    VAR(VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR) VAR.VAR()  VAR(VAR) VAR = VAR.VAR()  VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/', VAR=VAR) VAR.VAR()  VAR VAR(VAR): VAR = '/' VAR, VAR = VAR, 80 VAR = VAR(VAR=VAR)  VAR = VAR(VAR, VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', VAR)  VAR = VAR(VAR=0) VAR.VAR(VAR, VAR.VAR, 'VAR', VAR, VAR=VAR)  VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR(VAR, VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', VAR, VAR=VAR) VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', VAR, VAR=VAR) VAR VAR(VAR): VAR, VAR = VAR, 80 VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR(VAR, VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR = VAR(VAR, VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR VAR(VAR): VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=2) VAR(VAR)  VAR = VAR(VAR=3, VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR() VAR(VAR) VAR.VAR()  VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR VAR(VAR): VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR?VAR=VAR') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR):  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 400, VAR.VAR) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 400, VAR.VAR) VAR VAR(VAR): VAR = ""VAR'VAR VAR VAR VAR VAR-VAR, VAR VAR VAR"" VAR = { 'VAR': 'VAR', 'VAR': 'VAR.VAR', 'VAR': VAR(VAR), 'VAR': ('VAR.VAR', VAR), } VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR = [ ('VAR', 'VAR'), ('VAR', 'VAR'), ]  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, VAR'VAR=VAR&VAR=VAR')  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR.VAR(VAR'VAR=""VAR""'), 2) VAR VAR(VAR): VAR = VAR'VAR' VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, VAR) VAR = [('VAR', 'VAR')] VAR.VAR(VAR, VAR.VAR.VAR, 'VAR', '/VAR', VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = VAR('VAR') VAR = VAR('\VAR\VAR\VAR.VAR') VAR = VAR('\VAR\VAR\VAR').VAR('VAR') VAR = VAR(VAR) VAR = { VAR('VAR'): VAR, VAR('VAR'): VAR, VAR('VAR'): VAR, VAR: (VAR, VAR), } VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR """"""   VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, 'VAR', '/') VAR = VAR.VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR.""""""   VAR = VAR(VAR.VAR, VAR.VAR, VAR=[ (VAR.VAR, VAR.VAR, 1) ]) VAR = VAR.VAR().VAR()  VAR = VAR.VAR(VAR.VAR, VAR.VAR) > 0 VAR.VAR(VAR) VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR.""""""   VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR = VAR.VAR().VAR() VAR = VAR.VAR(VAR.VAR, VAR.VAR) == 0 VAR.VAR(VAR) VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR.""""""   VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR)  VAR = VAR.VAR() VAR.VAR(VAR.VAR)  VAR.VAR += [(VAR.VAR, VAR.VAR, 1)] VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) > 0 VAR = VAR.VAR(VAR.VAR, VAR.VAR) > 0 VAR.VAR(VAR) VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR, VAR VAR """""" VAR = VAR() VAR = VAR(VAR.VAR, VAR) VAR: VAR.VAR('VAR', '/', VAR=VAR(VAR=3)) VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/')  VAR.VAR('VAR', '/') VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR)  VAR.VAR('VAR', '/') VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR VAR(VAR):  VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR.VAR(VAR=VAR) VAR.VAR(VAR, 'VAR', '/') VAR.VAR.VAR()  VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR = VAR.VAR(VAR=VAR) VAR.VAR(VAR, 'VAR', '/') VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR('VAR.VAR', VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=5) VAR.VAR(""VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=1) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/VAR?VAR=0') VAR = VAR.VAR('VAR', '/VAR?VAR=0') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 2) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=1, VAR=2) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/VAR?VAR=1', VAR=0, VAR={ ""VAR"": ""VAR"", }) VAR.VAR(VAR.VAR, 1)      VAR = VAR.VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR)  VAR = VAR.VAR('VAR', '/VAR?VAR=0', VAR=0, VAR={ ""VAR"": ""VAR-VAR"", })   VAR = VAR.VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR)   VAR = VAR.VAR('VAR', '/VAR?VAR=1', VAR=0, VAR={ ""VAR"": ""VAR"", }) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR)  VAR = VAR.VAR('VAR', '/VAR?VAR=0') VAR VAR(VAR): VAR = {'VAR': 'VAR', 'VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR('VAR-8'), VAR(VAR)) VAR VAR(VAR): VAR = {'VAR': 'VAR', 'VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR = VAR.VAR.VAR(VAR'\VAR\VAR') VAR = VAR(VAR)[0] VAR = VAR.VAR(VAR'\VAR\VAR')   """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR, VAR VAR VAR(VAR): VAR VAR.VAR(VAR'--'): VAR VAR.VAR(VAR[VAR], VAR[VAR]) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}) VAR.VAR(VAR.VAR.VAR('VAR-VAR'), 'VAR') VAR.VAR(VAR.VAR, VAR'VAR, VAR!') VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}) VAR.VAR(VAR.VAR.VAR('VAR-VAR'), 'VAR') VAR.VAR(VAR.VAR, VAR'VAR, VAR!') VAR VAR(VAR): VAR.VAR(VAR, VAR.VAR.VAR, 'VAR', '/VAR', VAR={'VAR-VAR': 'VAR-VAR'}) VAR.VAR(VAR, VAR.VAR.VAR, 'VAR', '/VAR', VAR={'VAR-VAR': 'VAR-VAR'}) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 3) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=16) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 3) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR) VAR = {'VAR': 'VAR'} VAR = VAR(VAR).VAR('VAR-8') VAR = VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR(5), VAR[:5]) VAR.VAR(VAR.VAR(), VAR[5:]) VAR VAR(VAR):   VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=1, VAR=2) VAR = 1024 * 2 VAR = 512 VAR = 'VAR' VAR = {'VAR': 'VAR' * VAR} VAR = VAR(VAR, VAR=VAR)[0] VAR = {'VAR': 'VAR' * VAR} VAR = VAR(VAR, VAR=VAR)[0] VAR = VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR(VAR), VAR[:VAR]) VAR: VAR = VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=VAR, VAR=0.001)   VAR.VAR(VAR.VAR(VAR), VAR[:VAR]) VAR.VAR(VAR.VAR(), VAR[VAR:]) VAR.VAR(VAR.VAR(), VAR[VAR:]) VAR.VAR(VAR.VAR, 2) VAR VAR: VAR.VAR(VAR.VAR(), VAR[VAR:]) VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 1) VAR VAR(VAR): VAR = 5  VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR, 0) VAR.VAR(VAR.VAR.VAR(), VAR)  VAR.VAR.VAR() VAR.VAR(VAR.VAR.VAR(), VAR-1)  VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR.VAR(), VAR-1)  VAR.VAR('VAR', '/', VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR-2) VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR.VAR(), VAR-2)  VAR.VAR('VAR', '/').VAR VAR.VAR(VAR.VAR.VAR(), VAR-2) VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR.VAR(), VAR-2) VAR VAR(VAR): VAR = 5 VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR)  VAR.VAR('VAR', '/', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR-1) VAR VAR(VAR): VAR = VAR('VAR.VAR', VAR.VAR, VAR=0.001) VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR', VAR=2) VAR VAR(VAR): VAR VAR, VAR VAR VAR: VAR VAR VAR VAR VAR: VAR.VAR(""VAR VAR VAR: VAR."", VAR) VAR VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/VAR') VAR.VAR(VAR.VAR, VAR(VAR[0])) VAR VAR(VAR): VAR VAR VAR VAR: VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR)  VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR?{0}'.VAR(VAR)) VAR VAR(VAR): VAR = 2 VAR VAR VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR={ 'VAR': 'VAR-VAR', }, VAR=VAR, VAR=VAR, ) VAR VAR VAR VAR.VAR(): VAR.VAR(VAR, VAR'123') VAR.VAR(VAR.VAR.VAR, 1) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR=VAR ) VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR=VAR ) VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR=VAR, VAR=VAR, ) VAR.VAR(VAR'123' * 4, VAR.VAR()) VAR VAR(VAR): ''' VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ''' VAR = 3 VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR VAR: VAR.VAR(VAR.VAR.VAR(), VAR)    VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR, VAR=0) VAR = VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR, VAR=1) VAR.VAR()  VAR.VAR(VAR.VAR.VAR(), VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR(""VAR"", VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', ""VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR: VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=0) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR(VAR=VAR)) VAR.VAR(VAR.VAR, 303) VAR = VAR('VAR.VAR', VAR.VAR, VAR=0.001) VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR', VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """""" VAR VAR VAR/ VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """"""VAR VAR VAR/ VAR VAR VAR VAR VAR VAR'VAR VAR VAR"""""" VAR = VAR(VAR=1, VAR=[202]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR"""""" VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=1, VAR=[418], VAR=['VAR']) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=1) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=2, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR.VAR, 1) VAR.VAR(VAR.VAR.VAR, (VAR('VAR', '/VAR', VAR, 418, VAR),)) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR.VAR, (VAR('VAR', '/VAR?VAR=%2F', VAR, 303, '/'),)) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '303,302,200'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR.VAR(VAR.VAR.VAR, VAR()) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=10, VAR={'VAR': '303,302,301,307,302,200'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR') VAR = [(303, '/VAR?VAR=302,301,307,302,200'), (302, '/VAR?VAR=301,307,302,200'), (301, '/VAR?VAR=307,302,200'), (307, '/VAR?VAR=302,200'), (302, '/VAR?VAR=200')] VAR = [(VAR.VAR, VAR.VAR) VAR VAR VAR VAR.VAR.VAR] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR):  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '429 VAR VAR VAR'}, VAR=VAR) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '429 VAR VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 429) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '429 VAR VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200)  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '503 VAR VAR'}, VAR=VAR) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '503 VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 503) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '503 VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200)   VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': ""418 VAR'VAR VAR VAR""}, VAR=VAR) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR() VAR = VAR.VAR.VAR('VAR', '/VAR') VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR() - VAR VAR.VAR(VAR, 1) VAR = VAR.VAR() VAR = VAR + 2 VAR = VAR.VAR.VAR('VAR', '/VAR?VAR=' + VAR(VAR)) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR() - VAR VAR.VAR(VAR, 1)  VAR = VAR.VAR() VAR = VAR - 1 VAR = VAR.VAR.VAR('VAR', '/VAR?VAR=' + VAR(VAR)) VAR = VAR.VAR() - VAR VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR, 1) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.1) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR"""""" VAR = VAR(VAR=3, VAR=[418])  VAR = 65535 VAR = VAR'VAR' * VAR VAR = VAR.VAR(VAR) VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': VAR(VAR)} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR = VAR(VAR=3, VAR=[418])  VAR = 65535 VAR = VAR'VAR' * VAR VAR = VAR.VAR(VAR) VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': VAR(VAR)} VAR = '/VAR?VAR=/VAR&VAR=307' VAR = VAR.VAR.VAR('VAR', VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR()"""""" VAR VAR(VAR.VAR): VAR VAR(VAR): VAR VAR VAR = VAR(VAR'VAR VAR') VAR = '/VAR?VAR=/VAR'   VAR = {'VAR-VAR': '8'} VAR: VAR.VAR.VAR('VAR', VAR, VAR=VAR, VAR=VAR) VAR.VAR('VAR VAR VAR VAR VAR.') VAR VAR VAR VAR: VAR.VAR('VAR VAR VAR VAR VAR VAR', VAR(VAR)) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR( VAR=1, VAR=VAR, VAR=[404], ) VAR.VAR = VAR(VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR.VAR.VAR == 1 VAR VAR(VAR): VAR VAR(VAR): VAR = VAR( VAR=1, VAR=VAR, VAR=[404], VAR=VAR, ) VAR.VAR = VAR(VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR.VAR.VAR == 1 VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/with_dummyserver/test_https.py,"import datetime
import json
import logging
import ssl
import sys
import unittest
import warnings

import mock
import pytest

from dummyserver.testcase import (
    HTTPSDummyServerTestCase, IPV6HTTPSDummyServerTestCase
)
from dummyserver.server import (DEFAULT_CA, DEFAULT_CA_BAD, DEFAULT_CERTS,
                                DEFAULT_CLIENT_CERTS,
                                DEFAULT_CLIENT_NO_INTERMEDIATE_CERTS,
                                NO_SAN_CERTS, NO_SAN_CA, DEFAULT_CA_DIR,
                                IPV6_ADDR_CERTS, IPV6_ADDR_CA, HAS_IPV6,
                                IP_SAN_CERTS, IPV6_SAN_CA, IPV6_SAN_CERTS)

from test import (
    onlyPy279OrNewer,
    notSecureTransport,
    notOpenSSL098,
    requires_network,
    fails_on_travis_gce,
    TARPIT_HOST,
)
from urllib3 import HTTPSConnectionPool
from urllib3.connection import (
    VerifiedHTTPSConnection,
    UnverifiedHTTPSConnection,
    RECENT_DATE,
)
from urllib3.exceptions import (
    SSLError,
    ConnectTimeoutError,
    InsecureRequestWarning,
    SystemTimeWarning,
    InsecurePlatformWarning,
    MaxRetryError,
    ProtocolError,
)
from urllib3.packages import six
from urllib3.util.timeout import Timeout
import urllib3.util as util


ResourceWarning = getattr(
        six.moves.builtins,
        'ResourceWarning', type('ResourceWarning', (), {}))


log = logging.getLogger('urllib3.connectionpool')
log.setLevel(logging.NOTSET)
log.addHandler(logging.StreamHandler(sys.stdout))


class TestHTTPS(HTTPSDummyServerTestCase):
    def setUp(self):
        self._pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(self._pool.close)

    def test_simple(self):
        r = self._pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)

    @fails_on_travis_gce
    def test_dotted_fqdn(self):
        pool = HTTPSConnectionPool(self.host + '.', self.port)
        r = pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)

    def test_set_ssl_version_to_tlsv1(self):
        self._pool.ssl_version = ssl.PROTOCOL_TLSv1
        r = self._pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)

    def test_client_intermediate(self):
        client_cert, client_key = (
            DEFAULT_CLIENT_CERTS['certfile'],
            DEFAULT_CLIENT_CERTS['keyfile'],
        )
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         key_file=client_key,
                                         cert_file=client_cert)
        r = https_pool.request('GET', '/certificate')
        subject = json.loads(r.data.decode('utf-8'))
        assert subject['organizationalUnitName'].startswith(
            'Testing server cert')

    def test_client_no_intermediate(self):
        client_cert, client_key = (
            DEFAULT_CLIENT_NO_INTERMEDIATE_CERTS['certfile'],
            DEFAULT_CLIENT_NO_INTERMEDIATE_CERTS['keyfile']
        )
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_file=client_cert,
                                         key_file=client_key)
        try:
            https_pool.request('GET', '/certificate', retries=False)
        except SSLError as e:
            if not ('alert unknown ca' in str(e) or
                    'invalid certificate chain' in str(e) or
                    'unknown Cert Authority' in str(e) or
                    # https://github.com/urllib3/urllib3/issues/1422
                    'connection closed via error' in str(e) or
                    'WSAECONNRESET' in str(e)):
                raise
        except ProtocolError as e:
            # https://github.com/urllib3/urllib3/issues/1422
            if not ('An existing connection was forcibly closed by the remote host' in str(e)):
                raise

    def test_verified(self):
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)

            # Modern versions of Python, or systems using PyOpenSSL, don't
            # emit warnings.
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                self.assertFalse(warn.called, warn.call_args_list)
            else:
                self.assertTrue(warn.called)
                if util.HAS_SNI:
                    call = warn.call_args_list[0]
                else:
                    call = warn.call_args_list[1]
                error = call[0][1]
                self.assertEqual(error, InsecurePlatformWarning)

    def test_verified_with_context(self):
        ctx = util.ssl_.create_urllib3_context(cert_reqs=ssl.CERT_REQUIRED)
        ctx.load_verify_locations(cafile=DEFAULT_CA)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         ssl_context=ctx)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)

            # Modern versions of Python, or systems using PyOpenSSL, don't
            # emit warnings.
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                self.assertFalse(warn.called, warn.call_args_list)
            else:
                self.assertTrue(warn.called)
                if util.HAS_SNI:
                    call = warn.call_args_list[0]
                else:
                    call = warn.call_args_list[1]
                error = call[0][1]
                self.assertEqual(error, InsecurePlatformWarning)

    def test_context_combines_with_ca_certs(self):
        ctx = util.ssl_.create_urllib3_context(cert_reqs=ssl.CERT_REQUIRED)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         ca_certs=DEFAULT_CA,
                                         ssl_context=ctx)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)

            # Modern versions of Python, or systems using PyOpenSSL, don't
            # emit warnings.
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                self.assertFalse(warn.called, warn.call_args_list)
            else:
                self.assertTrue(warn.called)
                if util.HAS_SNI:
                    call = warn.call_args_list[0]
                else:
                    call = warn.call_args_list[1]
                error = call[0][1]
                self.assertEqual(error, InsecurePlatformWarning)

    @onlyPy279OrNewer
    @notSecureTransport  # SecureTransport does not support cert directories
    @notOpenSSL098  # OpenSSL 0.9.8 does not support cert directories
    def test_ca_dir_verified(self):
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_cert_dir=DEFAULT_CA_DIR)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertFalse(warn.called, warn.call_args_list)

    def test_invalid_common_name(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        try:
            https_pool.request('GET', '/')
            self.fail(""Didn't raise SSL invalid common name"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertTrue(
                ""doesn't match"" in str(e.reason) or
                ""certificate verify failed"" in str(e.reason)
            )

    def test_verified_with_bad_ca_certs(self):
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(https_pool.close)

        try:
            https_pool.request('GET', '/')
            self.fail(""Didn't raise SSL error with bad CA certs"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertIn('certificate verify failed', str(e.reason),
                          ""Expected 'certificate verify failed',""
                          ""instead got: %r"" % e.reason)

    def test_verified_without_ca_certs(self):
        # default is cert_reqs=None which is ssl.CERT_NONE
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)

        try:
            https_pool.request('GET', '/')
            self.fail(""Didn't raise SSL error with no CA certs when""
                      ""CERT_REQUIRED is set"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            # there is a different error message depending on whether or
            # not pyopenssl is injected
            self.assertTrue('No root certificates specified' in str(e.reason) or
                            'certificate verify failed' in str(e.reason) or
                            'invalid certificate chain' in str(e.reason),
                            ""Expected 'No root certificates specified',  ""
                            ""'certificate verify failed', or ""
                            ""'invalid certificate chain', ""
                            ""instead got: %r"" % e.reason)

    def test_no_ssl(self):
        pool = HTTPSConnectionPool(self.host, self.port)
        pool.ConnectionCls = None
        self.addCleanup(pool.close)
        self.assertRaises(SSLError, pool._new_conn)
        with self.assertRaises(MaxRetryError) as cm:
            pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)

    def test_unverified_ssl(self):
        """""" Test that bare HTTPSConnection can connect, make requests """"""
        pool = HTTPSConnectionPool(self.host, self.port)
        pool.ConnectionCls = UnverifiedHTTPSConnection
        self.addCleanup(pool.close)

        with mock.patch('warnings.warn') as warn:
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertTrue(warn.called)

            # Modern versions of Python, or systems using PyOpenSSL, only emit
            # the unverified warning. Older systems may also emit other
            # warnings, which we want to ignore here.
            calls = warn.call_args_list
            self.assertIn(InsecureRequestWarning, [x[0][1] for x in calls])

    def test_ssl_unverified_with_ca_certs(self):
        pool = HTTPSConnectionPool(self.host, self.port,
                                   cert_reqs='CERT_NONE',
                                   ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(pool.close)

        with mock.patch('warnings.warn') as warn:
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertTrue(warn.called)

            # Modern versions of Python, or systems using PyOpenSSL, only emit
            # the unverified warning. Older systems may also emit other
            # warnings, which we want to ignore here.
            calls = warn.call_args_list
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                category = calls[0][0][1]
            elif util.HAS_SNI:
                category = calls[1][0][1]
            else:
                category = calls[2][0][1]
            self.assertEqual(category, InsecureRequestWarning)

    def test_assert_hostname_false(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_hostname = False
        https_pool.request('GET', '/')

    def test_assert_specific_hostname(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_hostname = 'localhost'
        https_pool.request('GET', '/')

    def test_server_hostname(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA,
                                         server_hostname='localhost')
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        conn.request('GET', '/')

        # Assert the wrapping socket is using the passed-through SNI name.
        # pyopenssl doesn't let you pull the server_hostname back off the
        # socket, so only add this assertion if the attribute is there (i.e.
        # the python ssl module).
        if hasattr(conn.sock, 'server_hostname'):
            self.assertEqual(conn.sock.server_hostname, ""localhost"")

    def test_assert_fingerprint_md5(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = 'F2:06:5A:42:10:3F:45:1C:17:FE:E6:' \
                                        '07:1E:8A:86:E5'

        https_pool.request('GET', '/')

    def test_assert_fingerprint_sha1(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'
        https_pool.request('GET', '/')

    def test_assert_fingerprint_sha256(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = ('C5:4D:0B:83:84:89:2E:AE:B4:58:BB:12:'
                                         'F7:A6:C4:76:05:03:88:D8:57:65:51:F3:'
                                         '1E:60:B0:8B:70:18:64:E6')
        https_pool.request('GET', '/')

    def test_assert_invalid_fingerprint(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = 'AA:AA:AA:AA:AA:AAAA:AA:AAAA:AA:' \
                                        'AA:AA:AA:AA:AA:AA:AA:AA:AA'

        def _test_request(pool):
            with self.assertRaises(MaxRetryError) as cm:
                pool.request('GET', '/', retries=0)
            self.assertIsInstance(cm.exception.reason, SSLError)

        _test_request(https_pool)
        https_pool._get_conn()

        # Uneven length
        https_pool.assert_fingerprint = 'AA:A'
        _test_request(https_pool)
        https_pool._get_conn()

        # Invalid length
        https_pool.assert_fingerprint = 'AA'
        _test_request(https_pool)

    def test_verify_none_and_bad_fingerprint(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_NONE',
                                         ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = 'AA:AA:AA:AA:AA:AAAA:AA:AAAA:AA:' \
                                        'AA:AA:AA:AA:AA:AA:AA:AA:AA'
        with self.assertRaises(MaxRetryError) as cm:
            https_pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)

    def test_verify_none_and_good_fingerprint(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_NONE',
                                         ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'
        https_pool.request('GET', '/')

    @notSecureTransport
    def test_good_fingerprint_and_hostname_mismatch(self):
        # This test doesn't run with SecureTransport because we don't turn off
        # hostname validation without turning off all validation, which this
        # test doesn't do (deliberately). We should revisit this if we make
        # new decisions.
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'
        https_pool.request('GET', '/')

    @requires_network
    def test_https_timeout(self):
        timeout = Timeout(connect=0.001)
        https_pool = HTTPSConnectionPool(TARPIT_HOST, self.port,
                                         timeout=timeout, retries=False,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)

        timeout = Timeout(total=None, connect=0.001)
        https_pool = HTTPSConnectionPool(TARPIT_HOST, self.port,
                                         timeout=timeout, retries=False,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/')

        timeout = Timeout(read=0.001)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         timeout=timeout, retries=False,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)
        https_pool.ca_certs = DEFAULT_CA
        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'

        timeout = Timeout(total=None)
        https_pool = HTTPSConnectionPool(self.host, self.port, timeout=timeout,
                                         cert_reqs='CERT_NONE')
        self.addCleanup(https_pool.close)
        https_pool.request('GET', '/')

    def test_tunnel(self):
        """""" test the _tunnel behavior """"""
        timeout = Timeout(total=None)
        https_pool = HTTPSConnectionPool(self.host, self.port, timeout=timeout,
                                         cert_reqs='CERT_NONE')
        self.addCleanup(https_pool.close)
        conn = https_pool._new_conn()
        self.addCleanup(conn.close)
        conn.set_tunnel(self.host, self.port)
        conn._tunnel = mock.Mock()
        https_pool._make_request(conn, 'GET', '/')
        conn._tunnel.assert_called_once_with()

    @requires_network
    def test_enhanced_timeout(self):
        def new_pool(timeout, cert_reqs='CERT_REQUIRED'):
            https_pool = HTTPSConnectionPool(TARPIT_HOST, self.port,
                                             timeout=timeout,
                                             retries=False,
                                             cert_reqs=cert_reqs)
            self.addCleanup(https_pool.close)
            return https_pool

        https_pool = new_pool(Timeout(connect=0.001))
        conn = https_pool._new_conn()
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/')
        self.assertRaises(ConnectTimeoutError, https_pool._make_request, conn,
                          'GET', '/')

        https_pool = new_pool(Timeout(connect=5))
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/',
                          timeout=Timeout(connect=0.001))

        t = Timeout(total=None)
        https_pool = new_pool(t)
        conn = https_pool._new_conn()
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/',
                          timeout=Timeout(total=None, connect=0.001))

    def test_enhanced_ssl_connection(self):
        fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:BF:93:CF:F9:71:CC:07:7D:0A'

        conn = VerifiedHTTPSConnection(self.host, self.port)
        self.addCleanup(conn.close)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA,
                                         assert_fingerprint=fingerprint)
        self.addCleanup(https_pool.close)

        https_pool._make_request(conn, 'GET', '/')

    @onlyPy279OrNewer
    def test_ssl_correct_system_time(self):
        self._pool.cert_reqs = 'CERT_REQUIRED'
        self._pool.ca_certs = DEFAULT_CA

        w = self._request_without_resource_warnings('GET', '/')
        self.assertEqual([], w)

    @onlyPy279OrNewer
    def test_ssl_wrong_system_time(self):
        self._pool.cert_reqs = 'CERT_REQUIRED'
        self._pool.ca_certs = DEFAULT_CA
        with mock.patch('urllib3.connection.datetime') as mock_date:
            mock_date.date.today.return_value = datetime.date(1970, 1, 1)

            w = self._request_without_resource_warnings('GET', '/')

            self.assertEqual(len(w), 1)
            warning = w[0]

            self.assertEqual(SystemTimeWarning, warning.category)
            self.assertIn(str(RECENT_DATE), warning.message.args[0])

    def _request_without_resource_warnings(self, method, url):
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter('always')
            self._pool.request(method, url)

        return [x for x in w if not isinstance(x.message, ResourceWarning)]


class TestHTTPS_TLSv1(HTTPSDummyServerTestCase):
    certs = DEFAULT_CERTS.copy()
    certs['ssl_version'] = ssl.PROTOCOL_TLSv1

    def setUp(self):
        self._pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(self._pool.close)

    def test_discards_connection_on_sslerror(self):
        self._pool.cert_reqs = 'CERT_REQUIRED'
        with self.assertRaises(MaxRetryError) as cm:
            self._pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)
        self._pool.ca_certs = DEFAULT_CA
        self._pool.request('GET', '/')

    def test_set_cert_default_cert_required(self):
        conn = VerifiedHTTPSConnection(self.host, self.port)
        conn.set_cert(ca_certs=DEFAULT_CA)
        self.assertEqual(conn.cert_reqs, 'CERT_REQUIRED')


class TestHTTPS_NoSAN(HTTPSDummyServerTestCase):
    certs = NO_SAN_CERTS

    def test_warning_for_certs_without_a_san(self):
        """"""Ensure that a warning is raised when the cert from the server has
        no Subject Alternative Name.""""""
        with mock.patch('warnings.warn') as warn:
            https_pool = HTTPSConnectionPool(self.host, self.port,
                                             cert_reqs='CERT_REQUIRED',
                                             ca_certs=NO_SAN_CA)
            self.addCleanup(https_pool.close)
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertTrue(warn.called)


class TestHTTPS_IPSAN(HTTPSDummyServerTestCase):
    certs = IP_SAN_CERTS

    def test_can_validate_ip_san(self):
        """"""Ensure that urllib3 can validate SANs with IP addresses in them.""""""
        try:
            import ipaddress  # noqa: F401
        except ImportError:
            pytest.skip(""Only runs on systems with an ipaddress module"")

        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)
        r = https_pool.request('GET', '/')
        self.assertEqual(r.status, 200)


class TestHTTPS_IPv6Addr(IPV6HTTPSDummyServerTestCase):
    certs = IPV6_ADDR_CERTS

    @pytest.mark.skipif(not HAS_IPV6, reason='Only runs on IPv6 systems')
    def test_strip_square_brackets_before_validating(self):
        """"""Test that the fix for #760 works.""""""
        https_pool = HTTPSConnectionPool('[::1]', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=IPV6_ADDR_CA)
        self.addCleanup(https_pool.close)
        r = https_pool.request('GET', '/')
        self.assertEqual(r.status, 200)


class TestHTTPS_IPV6SAN(IPV6HTTPSDummyServerTestCase):
    certs = IPV6_SAN_CERTS

    def test_can_validate_ipv6_san(self):
        """"""Ensure that urllib3 can validate SANs with IPv6 addresses in them.""""""
        try:
            import ipaddress  # noqa: F401
        except ImportError:
            pytest.skip(""Only runs on systems with an ipaddress module"")

        https_pool = HTTPSConnectionPool('[::1]', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=IPV6_SAN_CA)
        self.addCleanup(https_pool.close)
        r = https_pool.request('GET', '/')
        self.assertEqual(r.status, 200)


if __name__ == '__main__':
    unittest.main()",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR ) VAR VAR.VAR VAR (VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR) VAR VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, ) VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR = VAR( VAR.VAR.VAR, 'VAR', VAR('VAR', (), {})) VAR = VAR.VAR('VAR.VAR') VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR(VAR.VAR)) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) @VAR VAR VAR(VAR): VAR = VAR(VAR.VAR + '.', VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR = VAR.VAR VAR = VAR.VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR, VAR = ( VAR['VAR'], VAR['VAR'], ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR('VAR', '/VAR') VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR VAR['VAR'].VAR( 'VAR VAR VAR') VAR VAR(VAR): VAR, VAR = ( VAR['VAR'], VAR['VAR'] ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR: VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR VAR VAR: VAR VAR ('VAR VAR VAR' VAR VAR(VAR) VAR 'VAR VAR VAR' VAR VAR(VAR) VAR 'VAR VAR VAR' VAR VAR(VAR) VAR  'VAR VAR VAR VAR' VAR VAR(VAR) VAR 'VAR' VAR VAR(VAR)): VAR VAR VAR VAR VAR:  VAR VAR ('VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR(VAR)): VAR VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200)   VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR: VAR.VAR(VAR.VAR) VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR(VAR=VAR.VAR) VAR.VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200)   VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR: VAR.VAR(VAR.VAR) VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR(VAR=VAR.VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200)   VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR: VAR.VAR(VAR.VAR) VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR.VAR(VAR, VAR) @VAR @VAR  @VAR  VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR( ""VAR'VAR VAR"" VAR VAR(VAR.VAR) VAR ""VAR VAR VAR"" VAR VAR(VAR.VAR) ) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR('VAR VAR VAR', VAR(VAR.VAR), ""VAR 'VAR VAR VAR',"" ""VAR VAR: %VAR"" % VAR.VAR) VAR VAR(VAR):  VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR"" ""VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR)   VAR.VAR('VAR VAR VAR VAR' VAR VAR(VAR.VAR) VAR 'VAR VAR VAR' VAR VAR(VAR.VAR) VAR 'VAR VAR VAR' VAR VAR(VAR.VAR), ""VAR 'VAR VAR VAR VAR', "" ""'VAR VAR VAR', VAR "" ""'VAR VAR VAR', "" ""VAR VAR: %VAR"" % VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR """""" VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR VAR.VAR(VAR.VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR)    VAR = VAR.VAR VAR.VAR(VAR, [VAR[0][1] VAR VAR VAR VAR]) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR)    VAR = VAR.VAR VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR = VAR[0][0][1] VAR VAR.VAR: VAR = VAR[1][0][1] VAR: VAR = VAR[2][0][1] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = VAR VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR' VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR('VAR', '/')     VAR VAR(VAR.VAR, 'VAR'): VAR.VAR(VAR.VAR.VAR, ""VAR"") VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR:06:5A:42:10:3F:45:1C:17:VAR:VAR:' \ '07:1E:8A:86:VAR' VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = ('VAR:4D:0B:83:84:89:2E:VAR:VAR:58:VAR:12:' 'VAR:VAR:VAR:76:05:03:88:VAR:57:65:51:VAR:' '1E:60:VAR:8B:70:18:64:VAR') VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:' \ 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR' VAR VAR(VAR): VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR(VAR) VAR.VAR()  VAR.VAR = 'VAR:VAR' VAR(VAR) VAR.VAR()  VAR.VAR = 'VAR' VAR(VAR) VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:' \ 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR' VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR.VAR('VAR', '/') @VAR VAR VAR(VAR):     VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR.VAR('VAR', '/') @VAR VAR VAR(VAR): VAR = VAR(VAR=0.001) VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR(VAR=VAR, VAR=0.001) VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR = VAR(VAR=0.001) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR.VAR = VAR VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR VAR(VAR): """""" VAR VAR VAR VAR """""" VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR.VAR() VAR.VAR(VAR, 'VAR', '/') VAR.VAR.VAR() @VAR VAR VAR(VAR): VAR VAR(VAR, VAR='VAR'): VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR VAR = VAR(VAR(VAR=0.001)) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR = VAR(VAR(VAR=5)) VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR(VAR=0.001)) VAR = VAR(VAR=VAR) VAR = VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR(VAR=VAR, VAR=0.001)) VAR VAR(VAR): VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, 'VAR', '/') @VAR VAR VAR(VAR): VAR.VAR.VAR = 'VAR' VAR.VAR.VAR = VAR VAR = VAR.VAR('VAR', '/') VAR.VAR([], VAR) @VAR VAR VAR(VAR): VAR.VAR.VAR = 'VAR' VAR.VAR.VAR = VAR VAR VAR.VAR('VAR.VAR.VAR') VAR VAR: VAR.VAR.VAR.VAR = VAR.VAR(1970, 1, 1) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR(VAR), 1) VAR = VAR[0] VAR.VAR(VAR, VAR.VAR) VAR.VAR(VAR(VAR), VAR.VAR.VAR[0]) VAR VAR(VAR, VAR, VAR): VAR VAR.VAR(VAR=VAR) VAR VAR: VAR.VAR('VAR') VAR.VAR.VAR(VAR, VAR) VAR [VAR VAR VAR VAR VAR VAR VAR VAR(VAR.VAR, VAR)] VAR VAR(VAR): VAR = VAR.VAR() VAR['VAR'] = VAR.VAR VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR = 'VAR' VAR VAR.VAR(VAR) VAR VAR: VAR.VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR.VAR.VAR = VAR VAR.VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR=VAR) VAR.VAR(VAR.VAR, 'VAR') VAR VAR(VAR): VAR = VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR = VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR: VAR VAR  VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR"") VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR @VAR.VAR.VAR(VAR VAR, VAR='VAR VAR VAR VAR VAR') VAR VAR(VAR): """"""VAR VAR VAR VAR VAR  VAR = VAR('[::1]', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR: VAR VAR  VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR"") VAR = VAR('[::1]', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/with_dummyserver/test_no_ssl.py,"""""""
Test connections without the builtin ssl module

Note: Import urllib3 inside the test functions to get the importblocker to work
""""""
from ..test_no_ssl import TestWithoutSSL

from dummyserver.testcase import (
        HTTPDummyServerTestCase, HTTPSDummyServerTestCase)

import urllib3


class TestHTTPWithoutSSL(HTTPDummyServerTestCase, TestWithoutSSL):
    def test_simple(self):
        pool = urllib3.HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)


class TestHTTPSWithoutSSL(HTTPSDummyServerTestCase, TestWithoutSSL):
    def test_simple(self):
        pool = urllib3.HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        try:
            pool.request('GET', '/')
        except urllib3.exceptions.SSLError as e:
            self.assertIn('SSL module is not available', str(e))",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,""""""" VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR ..VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR) VAR VAR VAR VAR(VAR, VAR): VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR, VAR): VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR VAR.VAR.VAR VAR VAR: VAR.VAR('VAR VAR VAR VAR VAR', VAR(VAR)) ",8
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/with_dummyserver/test_poolmanager.py,"import unittest
import json

import pytest

from dummyserver.server import HAS_IPV6
from dummyserver.testcase import (HTTPDummyServerTestCase,
                                  IPv6HTTPDummyServerTestCase)
from urllib3.poolmanager import PoolManager
from urllib3.connectionpool import port_by_scheme
from urllib3.exceptions import MaxRetryError
from urllib3.util.retry import Retry


class TestPoolManager(HTTPDummyServerTestCase):

    def setUp(self):
        self.base_url = 'http://%s:%d' % (self.host, self.port)
        self.base_url_alt = 'http://%s:%d' % (self.host_alt, self.port)

    def test_redirect(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/' % self.base_url},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/' % self.base_url})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_redirect_twice(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/redirect' % self.base_url},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                       self.base_url)})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_redirect_to_relative_url(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '/redirect'},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '/redirect'})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_cross_host_redirect(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        cross_host_location = '%s/echo?a=b' % self.base_url_alt
        try:
            http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': cross_host_location},
                         timeout=1, retries=0)
            self.fail(""Request succeeded instead of raising an exception like it should."")

        except MaxRetryError:
            pass

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/echo?a=b' % self.base_url_alt},
                         timeout=1, retries=1)

        self.assertEqual(r._pool.host, self.host_alt)

    def test_too_many_redirects(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        try:
            r = http.request('GET', '%s/redirect' % self.base_url,
                             fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                           self.base_url)},
                             retries=1)
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

        try:
            r = http.request('GET', '%s/redirect' % self.base_url,
                             fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                           self.base_url)},
                             retries=Retry(total=None, redirect=1))
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

    def test_redirect_cross_host_remove_headers(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'Authorization': 'foo'})

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('Authorization', data)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'authorization': 'foo'})

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('authorization', data)
        self.assertNotIn('Authorization', data)

    def test_redirect_cross_host_no_remove_headers(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'Authorization': 'foo'},
                         retries=Retry(remove_headers_on_redirect=[]))

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertEqual(data['Authorization'], 'foo')

    def test_redirect_cross_host_set_removed_headers(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'X-API-Secret': 'foo',
                                  'Authorization': 'bar'},
                         retries=Retry(remove_headers_on_redirect=['X-API-Secret']))

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('X-API-Secret', data)
        self.assertEqual(data['Authorization'], 'bar')

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'x-api-secret': 'foo',
                                  'authorization': 'bar'},
                         retries=Retry(remove_headers_on_redirect=['X-API-Secret']))

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('x-api-secret', data)
        self.assertNotIn('X-API-Secret', data)

        self.assertEqual(data['Authorization'], 'bar')

    def test_raise_on_redirect(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                       self.base_url)},
                         retries=Retry(total=None, redirect=1, raise_on_redirect=False))

        self.assertEqual(r.status, 303)

    def test_raise_on_status(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        try:
            # the default is to raise
            r = http.request('GET', '%s/status' % self.base_url,
                             fields={'status': '500 Internal Server Error'},
                             retries=Retry(total=1, status_forcelist=range(500, 600)))
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

        try:
            # raise explicitly
            r = http.request('GET', '%s/status' % self.base_url,
                             fields={'status': '500 Internal Server Error'},
                             retries=Retry(total=1,
                                           status_forcelist=range(500, 600),
                                           raise_on_status=True))
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

        # don't raise
        r = http.request('GET', '%s/status' % self.base_url,
                         fields={'status': '500 Internal Server Error'},
                         retries=Retry(total=1,
                                       status_forcelist=range(500, 600),
                                       raise_on_status=False))

        self.assertEqual(r.status, 500)

    def test_missing_port(self):
        # Can a URL that lacks an explicit port like ':80' succeed, or
        # will all such URLs fail with an error?

        http = PoolManager()
        self.addCleanup(http.clear)

        # By globally adjusting `port_by_scheme` we pretend for a moment
        # that HTTP's default port is not 80, but is the port at which
        # our test server happens to be listening.
        port_by_scheme['http'] = self.port
        try:
            r = http.request('GET', 'http://%s/' % self.host, retries=0)
        finally:
            port_by_scheme['http'] = 80

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_headers(self):
        http = PoolManager(headers={'Foo': 'bar'})
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request('POST', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request_encode_url('GET', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request_encode_body('POST', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request_encode_url('GET', '%s/headers' % self.base_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')

        r = http.request_encode_body('GET', '%s/headers' % self.base_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')

    def test_http_with_ssl_keywords(self):
        http = PoolManager(ca_certs='REQUIRED')
        self.addCleanup(http.clear)

        r = http.request('GET', 'http://%s:%s/' % (self.host, self.port))
        self.assertEqual(r.status, 200)

    def test_http_with_ca_cert_dir(self):
        http = PoolManager(ca_certs='REQUIRED', ca_cert_dir='/nosuchdir')
        self.addCleanup(http.clear)

        r = http.request('GET', 'http://%s:%s/' % (self.host, self.port))
        self.assertEqual(r.status, 200)


@pytest.mark.skipif(
    not HAS_IPV6,
    reason='IPv6 is not supported on this system'
)
class TestIPv6PoolManager(IPv6HTTPDummyServerTestCase):

    def setUp(self):
        self.base_url = 'http://[%s]:%d' % (self.host, self.port)

    def test_ipv6(self):
        http = PoolManager()
        self.addCleanup(http.clear)
        http.request('GET', self.base_url)


if __name__ == '__main__':
    unittest.main()",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR (VAR, VAR) VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '/VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '/VAR'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = '%VAR/VAR?VAR=VAR' % VAR.VAR VAR: VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': VAR}, VAR=1, VAR=0) VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=VAR' % VAR.VAR}, VAR=1, VAR=1) VAR.VAR(VAR.VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR: VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}, VAR=1) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR: VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}, VAR=VAR(VAR=VAR, VAR=1)) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR', VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR', VAR) VAR.VAR('VAR', VAR) VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR': 'VAR'}, VAR=VAR(VAR=[])) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR(VAR['VAR'], 'VAR') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR-VAR-VAR': 'VAR', 'VAR': 'VAR'}, VAR=VAR(VAR=['VAR-VAR-VAR'])) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR-VAR-VAR', VAR) VAR.VAR(VAR['VAR'], 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR-VAR-VAR': 'VAR', 'VAR': 'VAR'}, VAR=VAR(VAR=['VAR-VAR-VAR'])) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR-VAR-VAR', VAR) VAR.VAR('VAR-VAR-VAR', VAR) VAR.VAR(VAR['VAR'], 'VAR') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}, VAR=VAR(VAR=VAR, VAR=1, VAR=VAR)) VAR.VAR(VAR.VAR, 303) VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR:  VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '500 VAR VAR VAR'}, VAR=VAR(VAR=1, VAR=VAR(500, 600))) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR:  VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '500 VAR VAR VAR'}, VAR=VAR(VAR=1, VAR=VAR(500, 600), VAR=VAR)) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR  VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '500 VAR VAR VAR'}, VAR=VAR(VAR=1, VAR=VAR(500, 600), VAR=VAR)) VAR.VAR(VAR.VAR, 500) VAR VAR(VAR):   VAR = VAR() VAR.VAR(VAR.VAR)    VAR['VAR'] = VAR.VAR VAR: VAR = VAR.VAR('VAR', 'VAR: VAR: VAR['VAR'] = 80 VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR(VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR VAR(VAR): VAR = VAR(VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR(VAR='VAR', VAR='/VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) @VAR.VAR.VAR( VAR VAR, VAR='VAR VAR VAR VAR VAR VAR VAR' ) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR.VAR('VAR', VAR.VAR) VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/with_dummyserver/test_proxy_poolmanager.py,"import json
import socket
import unittest

import pytest

from dummyserver.testcase import HTTPDummyProxyTestCase, IPv6HTTPDummyProxyTestCase
from dummyserver.server import (
    DEFAULT_CA, DEFAULT_CA_BAD, get_unreachable_address)
from .. import TARPIT_HOST, requires_network

from urllib3._collections import HTTPHeaderDict
from urllib3.poolmanager import proxy_from_url, ProxyManager
from urllib3.exceptions import (
    MaxRetryError, SSLError, ProxyError, ConnectTimeoutError)
from urllib3.connectionpool import connection_from_url, VerifiedHTTPSConnection


class TestHTTPProxyManager(HTTPDummyProxyTestCase):

    def setUp(self):
        self.http_url = 'http://%s:%d' % (self.http_host, self.http_port)
        self.http_url_alt = 'http://%s:%d' % (self.http_host_alt,
                                              self.http_port)
        self.https_url = 'https://%s:%d' % (self.https_host, self.https_port)
        self.https_url_alt = 'https://%s:%d' % (self.https_host_alt,
                                                self.https_port)
        self.proxy_url = 'http://%s:%d' % (self.proxy_host, self.proxy_port)

    def test_basic_proxy(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url)
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url)
        self.assertEqual(r.status, 200)

    def test_nagle_proxy(self):
        """""" Test that proxy connections do not have TCP_NODELAY turned on """"""
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)
        hc2 = http.connection_from_host(self.http_host, self.http_port)
        conn = hc2._get_conn()
        self.addCleanup(conn.close)
        hc2._make_request(conn, 'GET', '/')
        tcp_nodelay_setting = conn.sock.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)
        self.assertEqual(tcp_nodelay_setting, 0,
                         (""Expected TCP_NODELAY for proxies to be set ""
                          ""to zero, instead was %s"" % tcp_nodelay_setting))

    def test_proxy_conn_fail(self):
        host, port = get_unreachable_address()
        http = proxy_from_url('http://%s:%s/' % (host, port), retries=1, timeout=0.05)
        self.addCleanup(http.clear)
        self.assertRaises(MaxRetryError, http.request, 'GET',
                          '%s/' % self.https_url)
        self.assertRaises(MaxRetryError, http.request, 'GET',
                          '%s/' % self.http_url)

        try:
            http.request('GET', '%s/' % self.http_url)
            self.fail(""Failed to raise retry error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), ProxyError)

    def test_oldapi(self):
        http = ProxyManager(connection_from_url(self.proxy_url))
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url)
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url)
        self.assertEqual(r.status, 200)

    def test_proxy_verified(self):
        http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                              ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(http.clear)
        https_pool = http._new_pool('https', self.https_host,
                                    self.https_port)
        try:
            https_pool.request('GET', '/', retries=0)
            self.fail(""Didn't raise SSL error with wrong CA"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertIn('certificate verify failed', str(e.reason),
                          ""Expected 'certificate verify failed',""
                          ""instead got: %r"" % e.reason)

        http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                              ca_certs=DEFAULT_CA)
        https_pool = http._new_pool('https', self.https_host,
                                    self.https_port)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)
        https_pool.request('GET', '/')  # Should succeed without exceptions.

        http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                              ca_certs=DEFAULT_CA)
        https_fail_pool = http._new_pool('https', '127.0.0.1', self.https_port)

        try:
            https_fail_pool.request('GET', '/', retries=0)
            self.fail(""Didn't raise SSL invalid common name"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertIn(""doesn't match"", str(e.reason))

    def test_redirect(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/' % self.http_url},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/' % self.http_url})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_cross_host_redirect(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        cross_host_location = '%s/echo?a=b' % self.http_url_alt
        try:
            http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': cross_host_location},
                         timeout=1, retries=0)
            self.fail(""We don't want to follow redirects here."")

        except MaxRetryError:
            pass

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/echo?a=b' % self.http_url_alt},
                         timeout=1, retries=1)
        self.assertNotEqual(r._pool.host, self.http_host_alt)

    def test_cross_protocol_redirect(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        cross_protocol_location = '%s/echo?a=b' % self.https_url
        try:
            http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': cross_protocol_location},
                         timeout=1, retries=0)
            self.fail(""We don't want to follow redirects here."")

        except MaxRetryError:
            pass

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/echo?a=b' % self.https_url},
                         timeout=1, retries=1)
        self.assertEqual(r._pool.host, self.https_host)

    def test_headers(self):
        http = proxy_from_url(self.proxy_url, headers={'Foo': 'bar'},
                              proxy_headers={'Hickory': 'dickory'})
        self.addCleanup(http.clear)

        r = http.request_encode_url('GET', '%s/headers' % self.http_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.http_url_alt)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host_alt, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.https_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host, self.https_port))

        r = http.request_encode_url('GET', '%s/headers' % self.https_url_alt)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host_alt, self.https_port))

        r = http.request_encode_body('POST', '%s/headers' % self.http_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.http_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.https_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host, self.https_port))

        r = http.request_encode_body('GET', '%s/headers' % self.http_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_body('GET', '%s/headers' % self.https_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host, self.https_port))

    def test_headerdict(self):
        default_headers = HTTPHeaderDict(a='b')
        proxy_headers = HTTPHeaderDict()
        proxy_headers.add('foo', 'bar')

        http = proxy_from_url(
            self.proxy_url,
            headers=default_headers,
            proxy_headers=proxy_headers)
        self.addCleanup(http.clear)

        request_headers = HTTPHeaderDict(baz='quux')
        r = http.request('GET', '%s/headers' % self.http_url, headers=request_headers)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Baz'), 'quux')

    def test_proxy_pooling(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        for x in range(2):
            http.urlopen('GET', self.http_url)
        self.assertEqual(len(http.pools), 1)

        for x in range(2):
            http.urlopen('GET', self.http_url_alt)
        self.assertEqual(len(http.pools), 1)

        for x in range(2):
            http.urlopen('GET', self.https_url)
        self.assertEqual(len(http.pools), 2)

        for x in range(2):
            http.urlopen('GET', self.https_url_alt)
        self.assertEqual(len(http.pools), 3)

    def test_proxy_pooling_ext(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        hc1 = http.connection_from_url(self.http_url)
        hc2 = http.connection_from_host(self.http_host, self.http_port)
        hc3 = http.connection_from_url(self.http_url_alt)
        hc4 = http.connection_from_host(self.http_host_alt, self.http_port)
        self.assertEqual(hc1, hc2)
        self.assertEqual(hc2, hc3)
        self.assertEqual(hc3, hc4)

        sc1 = http.connection_from_url(self.https_url)
        sc2 = http.connection_from_host(self.https_host,
                                        self.https_port, scheme='https')
        sc3 = http.connection_from_url(self.https_url_alt)
        sc4 = http.connection_from_host(self.https_host_alt,
                                        self.https_port, scheme='https')
        self.assertEqual(sc1, sc2)
        self.assertNotEqual(sc2, sc3)
        self.assertEqual(sc3, sc4)

    @pytest.mark.timeout(0.5)
    @requires_network
    def test_https_proxy_timeout(self):
        https = proxy_from_url('https://{host}'.format(host=TARPIT_HOST))
        self.addCleanup(https.clear)
        try:
            https.request('GET', self.http_url, timeout=0.001)
            self.fail(""Failed to raise retry error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), ConnectTimeoutError)

    @pytest.mark.timeout(0.5)
    @requires_network
    def test_https_proxy_pool_timeout(self):
        https = proxy_from_url('https://{host}'.format(host=TARPIT_HOST),
                               timeout=0.001)
        self.addCleanup(https.clear)
        try:
            https.request('GET', self.http_url)
            self.fail(""Failed to raise retry error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), ConnectTimeoutError)

    def test_scheme_host_case_insensitive(self):
        """"""Assert that upper-case schemes and hosts are normalized.""""""
        http = proxy_from_url(self.proxy_url.upper())
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url.upper())
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url.upper())
        self.assertEqual(r.status, 200)


class TestIPv6HTTPProxyManager(IPv6HTTPDummyProxyTestCase):

    def setUp(self):
        self.http_url = 'http://%s:%d' % (self.http_host, self.http_port)
        self.http_url_alt = 'http://%s:%d' % (self.http_host_alt,
                                              self.http_port)
        self.https_url = 'https://%s:%d' % (self.https_host, self.https_port)
        self.https_url_alt = 'https://%s:%d' % (self.https_host_alt,
                                                self.https_port)
        self.proxy_url = 'http://[%s]:%d' % (self.proxy_host, self.proxy_port)

    def test_basic_ipv6_proxy(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url)
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url)
        self.assertEqual(r.status, 200)


if __name__ == '__main__':
    unittest.main()",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR) VAR .. VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR) VAR VAR.VAR VAR VAR, VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, 'VAR', '/') VAR = VAR.VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR, 0, (""VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR, VAR VAR %VAR"" % VAR)) VAR VAR(VAR): VAR, VAR = VAR() VAR = VAR('VAR: VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '%VAR/' % VAR.VAR) VAR: VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): VAR = VAR(VAR(VAR.VAR)) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', VAR.VAR, VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR('VAR VAR VAR', VAR(VAR.VAR), ""VAR 'VAR VAR VAR',"" ""VAR VAR: %VAR"" % VAR.VAR) VAR = VAR(VAR.VAR, VAR='VAR', VAR=VAR) VAR = VAR.VAR('VAR', VAR.VAR, VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR.VAR('VAR', '/')  VAR = VAR(VAR.VAR, VAR='VAR', VAR=VAR) VAR = VAR.VAR('VAR', '127.0.0.1', VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR(""VAR'VAR VAR"", VAR(VAR.VAR)) VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = '%VAR/VAR?VAR=VAR' % VAR.VAR VAR: VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': VAR}, VAR=1, VAR=0) VAR.VAR(""VAR VAR'VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=VAR' % VAR.VAR}, VAR=1, VAR=1) VAR.VAR(VAR.VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = '%VAR/VAR?VAR=VAR' % VAR.VAR VAR: VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': VAR}, VAR=1, VAR=0) VAR.VAR(""VAR VAR'VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=VAR' % VAR.VAR}, VAR=1, VAR=1) VAR.VAR(VAR.VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR={'VAR': 'VAR'}, VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR VAR(VAR): VAR = VAR(VAR='VAR') VAR = VAR() VAR.VAR('VAR', 'VAR') VAR = VAR( VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR(VAR='VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR=VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 1) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 1) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 2) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 3) VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR, VAR='VAR') VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR, VAR='VAR') VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) @VAR.VAR.VAR(0.5) @VAR VAR VAR(VAR): VAR = VAR('VAR: VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', VAR.VAR, VAR=0.001) VAR.VAR(""VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) @VAR.VAR.VAR(0.5) @VAR VAR VAR(VAR): VAR = VAR('VAR: VAR=0.001) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): """"""VAR VAR VAR-VAR VAR VAR VAR VAR VAR."""""" VAR = VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR.VAR()) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR.VAR()) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/with_dummyserver/test_socketlevel.py,"# TODO: Break this module up into pieces. Maybe group by functionality tested
# rather than the socket level-ness of it.

from urllib3 import HTTPConnectionPool, HTTPSConnectionPool
from urllib3.poolmanager import proxy_from_url
from urllib3.exceptions import (
        MaxRetryError,
        ProxyError,
        ReadTimeoutError,
        SSLError,
        ProtocolError,
)
from urllib3.response import httplib
from urllib3.util.ssl_ import HAS_SNI
from urllib3.util.timeout import Timeout
from urllib3.util.retry import Retry
from urllib3._collections import HTTPHeaderDict

from test import fails_on_travis_gce
from dummyserver.testcase import SocketDummyServerTestCase, consume_socket
from dummyserver.server import (
    DEFAULT_CERTS, DEFAULT_CA, COMBINED_CERT_AND_KEY, get_unreachable_address)

from .. import onlyPy3, LogRecorder

try:
    from mimetools import Message as MimeToolMessage
except ImportError:
    class MimeToolMessage(object):
        pass
from collections import OrderedDict
from threading import Event
import select
import socket
import ssl

import pytest


class TestCookies(SocketDummyServerTestCase):

    def test_multi_setcookie(self):
        def multicookie_response_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(b'HTTP/1.1 200 OK\r\n'
                      b'Set-Cookie: foo=1\r\n'
                      b'Set-Cookie: bar=1\r\n'
                      b'\r\n')
            sock.close()

        self._start_server(multicookie_response_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/', retries=0)
        self.assertEqual(r.headers, {'set-cookie': 'foo=1, bar=1'})
        self.assertEqual(r.headers.getlist('set-cookie'), ['foo=1', 'bar=1'])


class TestSNI(SocketDummyServerTestCase):

    @pytest.mark.skipif(not HAS_SNI, reason='SNI-support not available')
    def test_hostname_in_first_request_packet(self):
        done_receiving = Event()
        self.buf = b''

        def socket_handler(listener):
            sock = listener.accept()[0]

            self.buf = sock.recv(65536)  # We only accept one packet
            done_receiving.set()  # let the test know it can proceed
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        try:
            pool.request('GET', '/', retries=0)
        except MaxRetryError:  # We are violating the protocol
            pass
        done_receiving.wait()
        self.assertIn(self.host.encode('ascii'), self.buf,
                      ""missing hostname in SSL handshake"")


class TestClientCerts(SocketDummyServerTestCase):
    """"""
    Tests for client certificate support.
    """"""
    def _wrap_in_ssl(self, sock):
        """"""
        Given a single socket, wraps it in TLS.
        """"""
        return ssl.wrap_socket(
            sock,
            ssl_version=ssl.PROTOCOL_SSLv23,
            cert_reqs=ssl.CERT_REQUIRED,
            ca_certs=DEFAULT_CA,
            certfile=DEFAULT_CERTS['certfile'],
            keyfile=DEFAULT_CERTS['keyfile'],
            server_side=True
        )

    def test_client_certs_two_files(self):
        """"""
        Having a client cert in a separate file to its associated key works
        properly.
        """"""
        done_receiving = Event()
        client_certs = []

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock = self._wrap_in_ssl(sock)

            client_certs.append(sock.getpeercert())

            data = b''
            while not data.endswith(b'\r\n\r\n'):
                data += sock.recv(8192)

            sock.sendall(
                b'HTTP/1.1 200 OK\r\n'
                b'Server: testsocket\r\n'
                b'Connection: close\r\n'
                b'Content-Length: 6\r\n'
                b'\r\n'
                b'Valid!'
            )

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(
            self.host,
            self.port,
            cert_file=DEFAULT_CERTS['certfile'],
            key_file=DEFAULT_CERTS['keyfile'],
            cert_reqs='REQUIRED',
            ca_certs=DEFAULT_CA,
        )
        self.addCleanup(pool.close)
        pool.request('GET', '/', retries=0)
        done_receiving.set()

        self.assertEqual(len(client_certs), 1)

    def test_client_certs_one_file(self):
        """"""
        Having a client cert and its associated private key in just one file
        works properly.
        """"""
        done_receiving = Event()
        client_certs = []

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock = self._wrap_in_ssl(sock)

            client_certs.append(sock.getpeercert())

            data = b''
            while not data.endswith(b'\r\n\r\n'):
                data += sock.recv(8192)

            sock.sendall(
                b'HTTP/1.1 200 OK\r\n'
                b'Server: testsocket\r\n'
                b'Connection: close\r\n'
                b'Content-Length: 6\r\n'
                b'\r\n'
                b'Valid!'
            )

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(
            self.host,
            self.port,
            cert_file=COMBINED_CERT_AND_KEY,
            cert_reqs='REQUIRED',
            ca_certs=DEFAULT_CA,
        )
        self.addCleanup(pool.close)
        pool.request('GET', '/', retries=0)
        done_receiving.set()

        self.assertEqual(len(client_certs), 1)

    def test_missing_client_certs_raises_error(self):
        """"""
        Having client certs not be present causes an error.
        """"""
        done_receiving = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            try:
                self._wrap_in_ssl(sock)
            except ssl.SSLError:
                pass

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(
            self.host,
            self.port,
            cert_reqs='REQUIRED',
            ca_certs=DEFAULT_CA,
        )
        self.addCleanup(pool.close)
        try:
            pool.request('GET', '/', retries=0)
        except MaxRetryError:
            done_receiving.set()
        else:
            done_receiving.set()
            self.fail(
                ""Expected server to reject connection due to missing client ""
                ""certificates""
            )


class TestSocketClosing(SocketDummyServerTestCase):

    def test_recovery_when_server_closes_connection(self):
        # Does the pool work seamlessly if an open connection in the
        # connection pool gets hung up on by the server, then reaches
        # the front of the queue again?

        done_closing = Event()

        def socket_handler(listener):
            for i in 0, 1:
                sock = listener.accept()[0]

                buf = b''
                while not buf.endswith(b'\r\n\r\n'):
                    buf = sock.recv(65536)

                body = 'Response %d' % i
                sock.send(('HTTP/1.1 200 OK\r\n'
                           'Content-Type: text/plain\r\n'
                           'Content-Length: %d\r\n'
                           '\r\n'
                           '%s' % (len(body), body)).encode('utf-8'))

                sock.close()  # simulate a server timing out, closing socket
                done_closing.set()  # let the test know it can proceed

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.request('GET', '/', retries=0)
        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'Response 0')

        done_closing.wait()  # wait until the socket in our pool gets closed

        response = pool.request('GET', '/', retries=0)
        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'Response 1')

    def test_connection_refused(self):
        # Does the pool retry if there is no listener on the port?
        host, port = get_unreachable_address()
        http = HTTPConnectionPool(host, port, maxsize=3, block=True)
        self.addCleanup(http.close)
        self.assertRaises(MaxRetryError, http.request, 'GET', '/', retries=0, release_conn=False)
        self.assertEqual(http.pool.qsize(), http.pool.maxsize)

    def test_connection_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            while not sock.recv(65536).endswith(b'\r\n\r\n'):
                pass

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        http = HTTPConnectionPool(self.host, self.port,
                                  timeout=0.001,
                                  retries=False,
                                  maxsize=3,
                                  block=True)
        self.addCleanup(http.close)

        try:
            self.assertRaises(ReadTimeoutError, http.request, 'GET', '/', release_conn=False)
        finally:
            timed_out.set()

        self.assertEqual(http.pool.qsize(), http.pool.maxsize)

    def test_read_timeout_dont_retry_method_not_in_whitelist(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock.recv(65536)
            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port, timeout=0.001, retries=True)
        self.addCleanup(pool.close)

        try:
            self.assertRaises(ReadTimeoutError, pool.request, 'POST', '/')
        finally:
            timed_out.set()

    def test_https_connection_read_timeout(self):
        """""" Handshake timeouts should fail with a Timeout""""""
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            while not sock.recv(65536):
                pass

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port, timeout=0.001, retries=False)
        self.addCleanup(pool.close)
        try:
            self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')
        finally:
            timed_out.set()

    def test_timeout_errors_cause_retries(self):
        def socket_handler(listener):
            sock_timeout = listener.accept()[0]

            # Wait for a second request before closing the first socket.
            sock = listener.accept()[0]
            sock_timeout.close()

            # Second request.
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            # Now respond immediately.
            body = 'Response 2'
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(body), body)).encode('utf-8'))

            sock.close()

        # In situations where the main thread throws an exception, the server
        # thread can hang on an accept() call. This ensures everything times
        # out within 1 second. This should be long enough for any socket
        # operations in the test suite to complete
        default_timeout = socket.getdefaulttimeout()
        socket.setdefaulttimeout(1)

        try:
            self._start_server(socket_handler)
            t = Timeout(connect=0.001, read=0.001)
            pool = HTTPConnectionPool(self.host, self.port, timeout=t)
            self.addCleanup(pool.close)

            response = pool.request('GET', '/', retries=1)
            self.assertEqual(response.status, 200)
            self.assertEqual(response.data, b'Response 2')
        finally:
            socket.setdefaulttimeout(default_timeout)

    def test_delayed_body_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b''
            body = 'Hi'
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n' % len(body)).encode('utf-8'))

            timed_out.wait()
            sock.send(body.encode('utf-8'))
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.urlopen('GET', '/', retries=0, preload_content=False,
                                timeout=Timeout(connect=1, read=0.001))
        try:
            self.assertRaises(ReadTimeoutError, response.read)
        finally:
            timed_out.set()

    def test_delayed_body_read_timeout_with_preload(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b''
            body = 'Hi'
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n' % len(body)).encode('utf-8'))

            timed_out.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        try:
            self.assertRaises(ReadTimeoutError, pool.urlopen,
                              'GET', '/', retries=False,
                              timeout=Timeout(connect=1, read=0.001))
        finally:
            timed_out.set()

    def test_incomplete_response(self):
        body = 'Response'
        partial_body = body[:2]

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)

            # Send partial response and close socket.
            sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: %d\r\n'
                '\r\n'
                '%s' % (len(body), partial_body)).encode('utf-8')
            )
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.request('GET', '/', retries=0, preload_content=False)
        self.assertRaises(ProtocolError, response.read)

    def test_retry_weird_http_version(self):
        """""" Retry class should handle httplib.BadStatusLine errors properly """"""

        def socket_handler(listener):
            sock = listener.accept()[0]
            # First request.
            # Pause before responding so the first request times out.
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            # send unknown http protocol
            body = ""bad http 0.5 response""
            sock.send(('HTTP/0.5 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(body), body)).encode('utf-8'))
            sock.close()

            # Second request.
            sock = listener.accept()[0]
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            # Now respond immediately.
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       'foo' % (len('foo'))).encode('utf-8'))

            sock.close()  # Close the socket.

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        retry = Retry(read=1)
        response = pool.request('GET', '/', retries=retry)
        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'foo')

    def test_connection_cleanup_on_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b''
            body = 'Hi'
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n' % len(body)).encode('utf-8'))

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            poolsize = pool.pool.qsize()
            response = pool.urlopen('GET', '/', retries=0, preload_content=False,
                                    timeout=Timeout(connect=1, read=0.001))
            try:
                self.assertRaises(ReadTimeoutError, response.read)
                self.assertEqual(poolsize, pool.pool.qsize())
            finally:
                timed_out.set()

    def test_connection_cleanup_on_protocol_error_during_read(self):
        body = 'Response'
        partial_body = body[:2]

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)

            # Send partial response and close socket.
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(body), partial_body)).encode('utf-8'))
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            poolsize = pool.pool.qsize()
            response = pool.request('GET', '/', retries=0, preload_content=False)

            self.assertRaises(ProtocolError, response.read)
            self.assertEqual(poolsize, pool.pool.qsize())

    def test_connection_closed_on_read_timeout_preload_false(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65535)

            # Send partial chunked response and then hang.
            sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Transfer-Encoding: chunked\r\n'
                '\r\n'
                '8\r\n'
                '12345678\r\n').encode('utf-8')
            )
            timed_out.wait(5)

            # Expect a new request, but keep hold of the old socket to avoid
            # leaking it. Because we don't want to hang this thread, we
            # actually use select.select to confirm that a new request is
            # coming in: this lets us time the thread out.
            rlist, _, _ = select.select([listener], [], [], 1)
            assert rlist
            new_sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = new_sock.recv(65535)

            # Send complete chunked response.
            new_sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Transfer-Encoding: chunked\r\n'
                '\r\n'
                '8\r\n'
                '12345678\r\n'
                '0\r\n\r\n').encode('utf-8')
            )

            new_sock.close()
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            # First request should fail.
            response = pool.urlopen('GET', '/', retries=0,
                                    preload_content=False,
                                    timeout=Timeout(connect=1, read=0.001))
            try:
                self.assertRaises(ReadTimeoutError, response.read)
            finally:
                timed_out.set()

            # Second should succeed.
            response = pool.urlopen('GET', '/', retries=0,
                                    preload_content=False,
                                    timeout=Timeout(connect=1, read=0.1))
            self.assertEqual(len(response.read()), 8)

    def test_closing_response_actually_closes_connection(self):
        done_closing = Event()
        complete = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: 0\r\n'
                       '\r\n').encode('utf-8'))

            # Wait for the socket to close.
            done_closing.wait(timeout=1)

            # Look for the empty string to show that the connection got closed.
            # Don't get stuck in a timeout.
            sock.settimeout(1)
            new_data = sock.recv(65536)
            self.assertFalse(new_data)
            sock.close()
            complete.set()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.request('GET', '/', retries=0, preload_content=False)
        self.assertEqual(response.status, 200)
        response.close()

        done_closing.set()  # wait until the socket in our pool gets closed
        successful = complete.wait(timeout=1)
        if not successful:
            self.fail(""Timed out waiting for connection close"")

    def test_release_conn_param_is_respected_after_timeout_retry(self):
        """"""For successful ```urlopen(release_conn=False)```,
        the connection isn't released, even after a retry.

        This test allows a retry: one request fails, the next request succeeds.

        This is a regression test for issue #651 [1], where the connection
        would be released if the initial request failed, even if a retry
        succeeded.

        [1] <https://github.com/shazow/urllib3/issues/651>
        """"""
        def socket_handler(listener):
            sock = listener.accept()[0]
            consume_socket(sock)

            # Close the connection, without sending any response (not even the
            # HTTP status line). This will trigger a `Timeout` on the client,
            # inside `urlopen()`.
            sock.close()

            # Expect a new request. Because we don't want to hang this thread,
            # we actually use select.select to confirm that a new request is
            # coming in: this lets us time the thread out.
            rlist, _, _ = select.select([listener], [], [], 5)
            assert rlist
            sock = listener.accept()[0]
            consume_socket(sock)

            # Send complete chunked response.
            sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Transfer-Encoding: chunked\r\n'
                '\r\n'
                '8\r\n'
                '12345678\r\n'
                '0\r\n\r\n').encode('utf-8')
            )

            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port, maxsize=1) as pool:
            # First request should fail, but the timeout and `retries=1` should
            # save it.
            response = pool.urlopen('GET', '/', retries=1,
                                    release_conn=False, preload_content=False,
                                    timeout=Timeout(connect=1, read=0.001))

            # The connection should still be on the response object, and none
            # should be in the pool. We opened two though.
            self.assertEqual(pool.num_connections, 2)
            self.assertEqual(pool.pool.qsize(), 0)
            self.assertIsNotNone(response.connection)

            # Consume the data. This should put the connection back.
            response.read()
            self.assertEqual(pool.pool.qsize(), 1)
            self.assertIsNone(response.connection)


class TestProxyManager(SocketDummyServerTestCase):

    def test_simple(self):
        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(buf), buf.decode('utf-8'))).encode('utf-8'))
            sock.close()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)
        proxy = proxy_from_url(base_url)
        self.addCleanup(proxy.clear)

        r = proxy.request('GET', 'http://google.com/')

        self.assertEqual(r.status, 200)
        # FIXME: The order of the headers is not predictable right now. We
        # should fix that someday (maybe when we migrate to
        # OrderedDict/MultiDict).
        self.assertEqual(sorted(r.data.split(b'\r\n')),
                         sorted([
                             b'GET http://google.com/ HTTP/1.1',
                             b'Host: google.com',
                             b'Accept-Encoding: identity',
                             b'Accept: */*',
                             b'',
                             b'',
                         ]))

    def test_headers(self):
        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(buf), buf.decode('utf-8'))).encode('utf-8'))
            sock.close()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        # Define some proxy headers.
        proxy_headers = HTTPHeaderDict({'For The Proxy': 'YEAH!'})
        proxy = proxy_from_url(base_url, proxy_headers=proxy_headers)
        self.addCleanup(proxy.clear)

        conn = proxy.connection_from_url('http://www.google.com/')

        r = conn.urlopen('GET', 'http://www.google.com/', assert_same_host=False)

        self.assertEqual(r.status, 200)
        # FIXME: The order of the headers is not predictable right now. We
        # should fix that someday (maybe when we migrate to
        # OrderedDict/MultiDict).
        self.assertIn(b'For The Proxy: YEAH!\r\n', r.data)

    def test_retries(self):
        close_event = Event()

        def echo_socket_handler(listener):
            sock = listener.accept()[0]
            # First request, which should fail
            sock.close()

            # Second request
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(buf), buf.decode('utf-8'))).encode('utf-8'))
            sock.close()
            close_event.set()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        proxy = proxy_from_url(base_url)
        self.addCleanup(proxy.clear)
        conn = proxy.connection_from_url('http://www.google.com')

        r = conn.urlopen('GET', 'http://www.google.com',
                         assert_same_host=False, retries=1)
        self.assertEqual(r.status, 200)

        close_event.wait(timeout=1)
        self.assertRaises(ProxyError, conn.urlopen, 'GET',
                          'http://www.google.com',
                          assert_same_host=False, retries=False)

    def test_connect_reconn(self):
        def proxy_ssl_one(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)
            s = buf.decode('utf-8')
            if not s.startswith('CONNECT '):
                sock.send(('HTTP/1.1 405 Method not allowed\r\n'
                           'Allow: CONNECT\r\n\r\n').encode('utf-8'))
                sock.close()
                return

            if not s.startswith('CONNECT %s:443' % (self.host,)):
                sock.send(('HTTP/1.1 403 Forbidden\r\n\r\n').encode('utf-8'))
                sock.close()
                return

            sock.send(('HTTP/1.1 200 Connection Established\r\n\r\n').encode('utf-8'))
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'],
                                       ca_certs=DEFAULT_CA)

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            ssl_sock.send(('HTTP/1.1 200 OK\r\n'
                           'Content-Type: text/plain\r\n'
                           'Content-Length: 2\r\n'
                           'Connection: close\r\n'
                           '\r\n'
                           'Hi').encode('utf-8'))
            ssl_sock.close()

        def echo_socket_handler(listener):
            proxy_ssl_one(listener)
            proxy_ssl_one(listener)

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        proxy = proxy_from_url(base_url)
        self.addCleanup(proxy.clear)

        url = 'https://{0}'.format(self.host)
        conn = proxy.connection_from_url(url)
        r = conn.urlopen('GET', url, retries=0)
        self.assertEqual(r.status, 200)
        r = conn.urlopen('GET', url, retries=0)
        self.assertEqual(r.status, 200)

    def test_connect_ipv6_addr(self):
        ipv6_addr = '2001:4998:c:a06::2:4008'

        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)
            s = buf.decode('utf-8')

            if s.startswith('CONNECT [%s]:443' % (ipv6_addr,)):
                sock.send(b'HTTP/1.1 200 Connection Established\r\n\r\n')
                ssl_sock = ssl.wrap_socket(sock,
                                           server_side=True,
                                           keyfile=DEFAULT_CERTS['keyfile'],
                                           certfile=DEFAULT_CERTS['certfile'])
                buf = b''
                while not buf.endswith(b'\r\n\r\n'):
                    buf += ssl_sock.recv(65536)

                ssl_sock.send(b'HTTP/1.1 200 OK\r\n'
                              b'Content-Type: text/plain\r\n'
                              b'Content-Length: 2\r\n'
                              b'Connection: close\r\n'
                              b'\r\n'
                              b'Hi')
                ssl_sock.close()
            else:
                sock.close()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        proxy = proxy_from_url(base_url)
        self.addCleanup(proxy.clear)

        url = 'https://[{0}]'.format(ipv6_addr)
        conn = proxy.connection_from_url(url)
        try:
            r = conn.urlopen('GET', url, retries=0)
            self.assertEqual(r.status, 200)
        except MaxRetryError:
            self.fail('Invalid IPv6 format in HTTP CONNECT request')


class TestSSL(SocketDummyServerTestCase):

    def test_ssl_failure_midway_through_conn(self):
        def socket_handler(listener):
            sock = listener.accept()[0]
            sock2 = sock.dup()
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'],
                                       ca_certs=DEFAULT_CA)

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            # Deliberately send from the non-SSL socket.
            sock2.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: 2\r\n'
                '\r\n'
                'Hi').encode('utf-8'))
            sock2.close()
            ssl_sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        with self.assertRaises(MaxRetryError) as cm:
            pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)

    def test_ssl_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'],
                                       ca_certs=DEFAULT_CA)

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            # Send incomplete message (note Content-Length)
            ssl_sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: 10\r\n'
                '\r\n'
                'Hi-').encode('utf-8'))
            timed_out.wait()

            sock.close()
            ssl_sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.urlopen('GET', '/', retries=0, preload_content=False,
                                timeout=Timeout(connect=1, read=0.001))
        try:
            self.assertRaises(ReadTimeoutError, response.read)
        finally:
            timed_out.set()

    def test_ssl_failed_fingerprint_verification(self):
        def socket_handler(listener):
            for i in range(2):
                sock = listener.accept()[0]
                ssl_sock = ssl.wrap_socket(sock,
                                           server_side=True,
                                           keyfile=DEFAULT_CERTS['keyfile'],
                                           certfile=DEFAULT_CERTS['certfile'],
                                           ca_certs=DEFAULT_CA)

                ssl_sock.send(b'HTTP/1.1 200 OK\r\n'
                              b'Content-Type: text/plain\r\n'
                              b'Content-Length: 5\r\n\r\n'
                              b'Hello')

                ssl_sock.close()
                sock.close()

        self._start_server(socket_handler)
        # GitHub's fingerprint. Valid, but not matching.
        fingerprint = ('A0:C4:A7:46:00:ED:A7:2D:C0:BE:CB'
                       ':9A:8C:B6:07:CA:58:EE:74:5E')

        def request():
            pool = HTTPSConnectionPool(self.host, self.port,
                                       assert_fingerprint=fingerprint)
            try:
                response = pool.urlopen('GET', '/', preload_content=False,
                                        timeout=Timeout(connect=1, read=0.001),
                                        retries=0)
                response.read()
            finally:
                pool.close()

        with self.assertRaises(MaxRetryError) as cm:
            request()
        self.assertIsInstance(cm.exception.reason, SSLError)
        # Should not hang, see https://github.com/shazow/urllib3/issues/529
        self.assertRaises(MaxRetryError, request)

    def test_retry_ssl_error(self):
        def socket_handler(listener):
            # first request, trigger an SSLError
            sock = listener.accept()[0]
            sock2 = sock.dup()
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'])
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            # Deliberately send from the non-SSL socket to trigger an SSLError
            sock2.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: 4\r\n'
                '\r\n'
                'Fail').encode('utf-8'))
            sock2.close()
            ssl_sock.close()

            # retried request
            sock = listener.accept()[0]
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'])
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)
            ssl_sock.send(b'HTTP/1.1 200 OK\r\n'
                          b'Content-Type: text/plain\r\n'
                          b'Content-Length: 7\r\n\r\n'
                          b'Success')
            ssl_sock.close()

        self._start_server(socket_handler)

        pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        response = pool.urlopen('GET', '/', retries=1)
        self.assertEqual(response.data, b'Success')


class TestErrorWrapping(SocketDummyServerTestCase):

    def test_bad_statusline(self):
        self.start_response_handler(
           b'HTTP/1.1 Omg What Is This?\r\n'
           b'Content-Length: 0\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ProtocolError, pool.request, 'GET', '/')

    def test_unknown_protocol(self):
        self.start_response_handler(
           b'HTTP/1000 200 OK\r\n'
           b'Content-Length: 0\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ProtocolError, pool.request, 'GET', '/')


class TestHeaders(SocketDummyServerTestCase):
    @onlyPy3
    def test_httplib_headers_case_insensitive(self):
        self.start_response_handler(
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 0\r\n'
           b'Content-type: text/plain\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        HEADERS = {'Content-Length': '0', 'Content-type': 'text/plain'}
        r = pool.request('GET', '/')
        self.assertEqual(HEADERS, dict(r.headers.items()))  # to preserve case sensitivity

    def test_headers_are_sent_with_the_original_case(self):
        headers = {'foo': 'bar', 'bAz': 'quux'}
        parsed_headers = {}

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            headers_list = [header for header in buf.split(b'\r\n')[1:] if header]

            for header in headers_list:
                (key, value) = header.split(b': ')
                parsed_headers[key.decode('ascii')] = value.decode('ascii')

            sock.send((
                'HTTP/1.1 204 No Content\r\n'
                'Content-Length: 0\r\n'
                '\r\n').encode('utf-8'))

            sock.close()

        self._start_server(socket_handler)
        expected_headers = {'Accept-Encoding': 'identity',
                            'Host': '{0}:{1}'.format(self.host, self.port)}
        expected_headers.update(headers)

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.request('GET', '/', headers=HTTPHeaderDict(headers))
        self.assertEqual(expected_headers, parsed_headers)

    def test_request_headers_are_sent_in_the_original_order(self):
        # NOTE: Probability this test gives a false negative is 1/(K!)
        K = 16
        # NOTE: Provide headers in non-sorted order (i.e. reversed)
        #       so that if the internal implementation tries to sort them,
        #       a change will be detected.
        expected_request_headers = [(u'X-Header-%d' % i, str(i)) for i in reversed(range(K))]

        actual_request_headers = []

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            headers_list = [header for header in buf.split(b'\r\n')[1:] if header]

            for header in headers_list:
                (key, value) = header.split(b': ')
                if not key.decode('ascii').startswith(u'X-Header-'):
                    continue
                actual_request_headers.append((key.decode('ascii'), value.decode('ascii')))

            sock.send((
                u'HTTP/1.1 204 No Content\r\n'
                u'Content-Length: 0\r\n'
                u'\r\n').encode('ascii'))

            sock.close()

        self._start_server(socket_handler)

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.request('GET', '/', headers=OrderedDict(expected_request_headers))
        self.assertEqual(expected_request_headers, actual_request_headers)

    @fails_on_travis_gce
    def test_request_host_header_ignores_fqdn_dot(self):

        received_headers = []

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            for header in buf.split(b'\r\n')[1:]:
                if header:
                    received_headers.append(header)

            sock.send((
                u'HTTP/1.1 204 No Content\r\n'
                u'Content-Length: 0\r\n'
                u'\r\n').encode('ascii'))

            sock.close()

        self._start_server(socket_handler)

        pool = HTTPConnectionPool(self.host + '.', self.port, retries=False)
        self.addCleanup(pool.close)
        pool.request('GET', '/')
        self.assert_header_received(
            received_headers, 'Host', '%s:%s' % (self.host, self.port)
        )

    def test_response_headers_are_returned_in_the_original_order(self):
        # NOTE: Probability this test gives a false negative is 1/(K!)
        K = 16
        # NOTE: Provide headers in non-sorted order (i.e. reversed)
        #       so that if the internal implementation tries to sort them,
        #       a change will be detected.
        expected_response_headers = [('X-Header-%d' % i, str(i)) for i in reversed(range(K))]

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(b'HTTP/1.1 200 OK\r\n' +
                      b'\r\n'.join([
                          (k.encode('utf8') + b': ' + v.encode('utf8'))
                          for (k, v) in expected_response_headers
                      ]) +
                      b'\r\n')
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/', retries=0)
        actual_response_headers = [
            (k, v) for (k, v) in r.headers.items()
            if k.startswith('X-Header-')
        ]
        self.assertEqual(expected_response_headers, actual_response_headers)


@pytest.mark.skipif(
    issubclass(httplib.HTTPMessage, MimeToolMessage),
    reason='Header parsing errors not available'
)
class TestBrokenHeaders(SocketDummyServerTestCase):

    def _test_broken_header_parsing(self, headers, unparsed_data_check=None):
        self.start_response_handler((
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 0\r\n'
           b'Content-type: text/plain\r\n'
           ) + b'\r\n'.join(headers) + b'\r\n\r\n'
        )

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)

        with LogRecorder() as logs:
            pool.request('GET', '/')

        for record in logs:
            if 'Failed to parse headers' in record.msg and \
                    pool._absolute_url('/') == record.args[0]:
                if unparsed_data_check is None or unparsed_data_check in record.getMessage():
                    return
        self.fail('Missing log about unparsed headers')

    def test_header_without_name(self):
        self._test_broken_header_parsing([
            b': Value',
            b'Another: Header',
        ])

    def test_header_without_name_or_value(self):
        self._test_broken_header_parsing([
            b':',
            b'Another: Header',
        ])

    def test_header_without_colon_or_value(self):
        self._test_broken_header_parsing([
            b'Broken Header',
            b'Another: Header',
        ], 'Broken Header')


class TestHeaderParsingContentType(SocketDummyServerTestCase):

    def _test_okay_header_parsing(self, header):
        self.start_response_handler((
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 0\r\n'
           ) + header + b'\r\n\r\n'
        )

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)

        with LogRecorder() as logs:
            pool.request('GET', '/')

        for record in logs:
            assert 'Failed to parse headers' not in record.msg

    def test_header_text_plain(self):
        self._test_okay_header_parsing(b'Content-type: text/plain')

    def test_header_message_rfc822(self):
        self._test_okay_header_parsing(b'Content-type: message/rfc822')


class TestHEAD(SocketDummyServerTestCase):
    def test_chunked_head_response_does_not_hang(self):
        self.start_response_handler(
           b'HTTP/1.1 200 OK\r\n'
           b'Transfer-Encoding: chunked\r\n'
           b'Content-type: text/plain\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        r = pool.request('HEAD', '/', timeout=1, preload_content=False)

        # stream will use the read_chunked method here.
        self.assertEqual([], list(r.stream()))

    def test_empty_head_response_does_not_hang(self):
        self.start_response_handler(
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 256\r\n'
           b'Content-type: text/plain\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        r = pool.request('HEAD', '/', timeout=1, preload_content=False)

        # stream will use the read method here.
        self.assertEqual([], list(r.stream()))


class TestStream(SocketDummyServerTestCase):
    def test_stream_none_unchunked_response_does_not_hang(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(
                b'HTTP/1.1 200 OK\r\n'
                b'Content-Length: 12\r\n'
                b'Content-type: text/plain\r\n'
                b'\r\n'
                b'hello, world'
            )
            done_event.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/', timeout=1, preload_content=False)

        # Stream should read to the end.
        self.assertEqual([b'hello, world'], list(r.stream(None)))

        done_event.set()


class TestBadContentLength(SocketDummyServerTestCase):
    def test_enforce_content_length_get(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(
                b'HTTP/1.1 200 OK\r\n'
                b'Content-Length: 22\r\n'
                b'Content-type: text/plain\r\n'
                b'\r\n'
                b'hello, world'
            )
            done_event.wait(1)
            sock.close()

        self._start_server(socket_handler)
        conn = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(conn.close)

        # Test stream read when content length less than headers claim
        get_response = conn.request('GET', url='/', preload_content=False,
                                    enforce_content_length=True)
        data = get_response.stream(100)
        # Read ""good"" data before we try to read again.
        # This won't trigger till generator is exhausted.
        next(data)
        try:
            next(data)
            self.assertFail()
        except ProtocolError as e:
            self.assertIn('12 bytes read, 10 more expected', str(e))

        done_event.set()

    def test_enforce_content_length_no_body(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(
                b'HTTP/1.1 200 OK\r\n'
                b'Content-Length: 22\r\n'
                b'Content-type: text/plain\r\n'
                b'\r\n'
            )
            done_event.wait(1)
            sock.close()

        self._start_server(socket_handler)
        conn = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(conn.close)

        # Test stream on 0 length body
        head_response = conn.request('HEAD', url='/', preload_content=False,
                                     enforce_content_length=True)
        data = [chunk for chunk in head_response.stream(1)]
        self.assertEqual(len(data), 0)

        done_event.set()


class TestRetryPoolSizeDrainFail(SocketDummyServerTestCase):

    def test_pool_size_retry_drain_fail(self):
        def socket_handler(listener):
            for _ in range(2):
                sock = listener.accept()[0]
                while not sock.recv(65536).endswith(b'\r\n\r\n'):
                    pass

                # send a response with an invalid content length -- this causes
                # a ProtocolError to raise when trying to drain the connection
                sock.send(
                    b'HTTP/1.1 404 NOT FOUND\r\n'
                    b'Content-Length: 1000\r\n'
                    b'Content-Type: text/plain\r\n'
                    b'\r\n'
                )
                sock.close()

        self._start_server(socket_handler)
        retries = Retry(
            total=1,
            raise_on_status=False,
            status_forcelist=[404],
        )
        pool = HTTPConnectionPool(self.host, self.port, maxsize=10,
                                  retries=retries, block=True)
        self.addCleanup(pool.close)

        pool.urlopen('GET', '/not_found', preload_content=False)
        assert pool.num_connections == 1",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"  VAR VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR) VAR .. VAR VAR, VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR(VAR): VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR=1\VAR\VAR' VAR'VAR-VAR: VAR=1\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR, {'VAR-VAR': 'VAR=1, VAR=1'}) VAR.VAR(VAR.VAR.VAR('VAR-VAR'), ['VAR=1', 'VAR=1']) VAR VAR(VAR): @VAR.VAR.VAR(VAR VAR, VAR='VAR-VAR VAR VAR') VAR VAR(VAR): VAR = VAR() VAR.VAR = VAR'' VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR = VAR.VAR(65536)  VAR.VAR()  VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR VAR:  VAR VAR.VAR() VAR.VAR(VAR.VAR.VAR('VAR'), VAR.VAR, ""VAR VAR VAR VAR VAR"") VAR VAR(VAR): """""" VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR VAR.VAR( VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR()) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(8192) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 6\VAR\VAR' VAR'\VAR\VAR' VAR'VAR!' ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR.VAR, VAR.VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR='VAR', VAR=VAR, ) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=0) VAR.VAR() VAR.VAR(VAR(VAR), 1) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR()) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(8192) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 6\VAR\VAR' VAR'\VAR\VAR' VAR'VAR!' ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR='VAR', VAR=VAR, ) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=0) VAR.VAR() VAR.VAR(VAR(VAR), 1) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR: VAR.VAR(VAR) VAR VAR.VAR: VAR VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR, ) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR VAR: VAR.VAR() VAR: VAR.VAR() VAR.VAR( ""VAR VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR"" ) VAR VAR(VAR): VAR VAR(VAR):    VAR = VAR() VAR VAR(VAR): VAR VAR VAR 0, 1: VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR = 'VAR %VAR' % VAR VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR()  VAR.VAR()  VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR 0') VAR.VAR()  VAR = VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR 1') VAR VAR(VAR):  VAR, VAR = VAR() VAR = VAR(VAR, VAR, VAR=3, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536).VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.001, VAR=VAR, VAR=3, VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR) VAR: VAR.VAR() VAR.VAR(VAR.VAR.VAR(), VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR(65536) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.001, VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR: VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR"""""" VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536): VAR VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.001, VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR.VAR()[0] VAR.VAR()  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR = 'VAR 2' VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR()     VAR = VAR.VAR() VAR.VAR(1) VAR: VAR.VAR(VAR) VAR = VAR(VAR=0.001, VAR=0.001) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR 2') VAR: VAR.VAR(VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR = 'VAR' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' % VAR(VAR)).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR.VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.001)) VAR: VAR.VAR(VAR, VAR.VAR) VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR = 'VAR' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' % VAR(VAR)).VAR('VAR-8')) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR, VAR=VAR(VAR=1, VAR=0.001)) VAR: VAR.VAR() VAR VAR(VAR): VAR = 'VAR' VAR = VAR[:2] VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8') ) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR, VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR.VAR VAR VAR """""" VAR VAR(VAR): VAR = VAR.VAR()[0]   VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR = ""VAR VAR 0.5 VAR"" VAR.VAR(('VAR/0.5 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' 'VAR' % (VAR('VAR'))).VAR('VAR-8')) VAR.VAR()  VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR(VAR=1) VAR = VAR.VAR('VAR', '/', VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR') VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR = 'VAR' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' % VAR(VAR)).VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR() VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.001)) VAR: VAR.VAR(VAR, VAR.VAR) VAR.VAR(VAR, VAR.VAR.VAR()) VAR: VAR.VAR() VAR VAR(VAR): VAR = 'VAR' VAR = VAR[:2] VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536)  VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR() VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(VAR, VAR.VAR.VAR()) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65535)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: VAR\VAR\VAR' '\VAR\VAR' '8\VAR\VAR' '12345678\VAR\VAR').VAR('VAR-8') ) VAR.VAR(5)     VAR, VAR, VAR = VAR.VAR([VAR], [], [], 1) VAR VAR VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65535)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: VAR\VAR\VAR' '\VAR\VAR' '8\VAR\VAR' '12345678\VAR\VAR' '0\VAR\VAR\VAR\VAR').VAR('VAR-8') ) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR:  VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.001)) VAR: VAR.VAR(VAR, VAR.VAR) VAR: VAR.VAR()  VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.1)) VAR.VAR(VAR(VAR.VAR()), 8) VAR VAR(VAR): VAR = VAR() VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 0\VAR\VAR' '\VAR\VAR').VAR('VAR-8'))  VAR.VAR(VAR=1)   VAR.VAR(1) VAR = VAR.VAR(65536) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR() VAR.VAR()  VAR = VAR.VAR(VAR=1) VAR VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR): """"""VAR VAR ```VAR(VAR=VAR)```, VAR VAR VAR'VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR: VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR  VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR. [1] <VAR: """""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR(VAR)    VAR.VAR()    VAR, VAR, VAR = VAR.VAR([VAR], [], [], 5) VAR VAR VAR = VAR.VAR()[0] VAR(VAR)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: VAR\VAR\VAR' '\VAR\VAR' '8\VAR\VAR' '12345678\VAR\VAR' '0\VAR\VAR\VAR\VAR').VAR('VAR-8') ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=1) VAR VAR:   VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR, VAR=VAR, VAR=VAR(VAR=1, VAR=0.001))   VAR.VAR(VAR.VAR, 2) VAR.VAR(VAR.VAR.VAR(), 0) VAR.VAR(VAR.VAR)  VAR.VAR() VAR.VAR(VAR.VAR.VAR(), 1) VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR.VAR('VAR-8'))).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200)    VAR.VAR(VAR(VAR.VAR.VAR(VAR'\VAR\VAR')), VAR([ VAR'VAR VAR: VAR'VAR: VAR.VAR', VAR'VAR-VAR: VAR', VAR'VAR: */*', VAR'', VAR'', ])) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR.VAR('VAR-8'))).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = 'VAR:  VAR = VAR({'VAR VAR VAR': 'VAR!'}) VAR = VAR(VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR: VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200)    VAR.VAR(VAR'VAR VAR VAR: VAR!\VAR\VAR', VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR.VAR('VAR-8'))).VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR: VAR = VAR.VAR('VAR', 'VAR: VAR=VAR, VAR=1) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR=1) VAR.VAR(VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = VAR.VAR('VAR-8') VAR VAR VAR.VAR('VAR '): VAR.VAR(('VAR/1.1 405 VAR VAR VAR\VAR\VAR' 'VAR: VAR\VAR\VAR\VAR\VAR').VAR('VAR-8')) VAR.VAR() VAR VAR VAR VAR.VAR('VAR %VAR:443' % (VAR.VAR,)): VAR.VAR(('VAR/1.1 403 VAR\VAR\VAR\VAR\VAR').VAR('VAR-8')) VAR.VAR() VAR VAR.VAR(('VAR/1.1 200 VAR VAR\VAR\VAR\VAR\VAR').VAR('VAR-8')) VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 2\VAR\VAR' 'VAR: VAR\VAR\VAR' '\VAR\VAR' 'VAR').VAR('VAR-8')) VAR.VAR() VAR VAR(VAR): VAR(VAR) VAR(VAR) VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR) VAR.VAR(VAR.VAR) VAR = 'VAR: VAR = VAR.VAR(VAR) VAR = VAR.VAR('VAR', VAR, VAR=0) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', VAR, VAR=0) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = '2001:4998:VAR:VAR::2:4008' VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = VAR.VAR('VAR-8') VAR VAR.VAR('VAR [%VAR]:443' % (VAR,)): VAR.VAR(VAR'VAR/1.1 200 VAR VAR\VAR\VAR\VAR\VAR') VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR']) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 2\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'\VAR\VAR' VAR'VAR') VAR.VAR() VAR: VAR.VAR() VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR) VAR.VAR(VAR.VAR) VAR = 'VAR: VAR = VAR.VAR(VAR) VAR: VAR = VAR.VAR('VAR', VAR, VAR=0) VAR.VAR(VAR.VAR, 200) VAR VAR: VAR.VAR('VAR VAR VAR VAR VAR VAR VAR') VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR() VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 2\VAR\VAR' '\VAR\VAR' 'VAR').VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 10\VAR\VAR' '\VAR\VAR' 'VAR-').VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.001)) VAR: VAR.VAR(VAR, VAR.VAR) VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 5\VAR\VAR\VAR\VAR' VAR'VAR') VAR.VAR() VAR.VAR() VAR.VAR(VAR)  VAR = ('VAR:VAR:VAR:46:00:VAR:VAR:2D:VAR:VAR:VAR' ':9A:8C:VAR:07:VAR:58:VAR:74:5E') VAR VAR(): VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR: VAR = VAR.VAR('VAR', '/', VAR=VAR, VAR=VAR(VAR=1, VAR=0.001), VAR=0) VAR.VAR() VAR: VAR.VAR() VAR VAR.VAR(VAR) VAR VAR: VAR() VAR.VAR(VAR.VAR.VAR, VAR)  VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR VAR(VAR):  VAR = VAR.VAR()[0] VAR = VAR.VAR() VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR']) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 4\VAR\VAR' '\VAR\VAR' 'VAR').VAR('VAR-8')) VAR.VAR() VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR']) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 7\VAR\VAR\VAR\VAR' VAR'VAR') VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1) VAR.VAR(VAR.VAR, VAR'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 VAR VAR VAR VAR?\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR VAR(VAR): VAR.VAR( VAR'VAR/1000 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR VAR(VAR): @VAR VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = {'VAR-VAR': '0', 'VAR-VAR': 'VAR/VAR'} VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR, VAR(VAR.VAR.VAR()))  VAR VAR(VAR): VAR = {'VAR': 'VAR', 'VAR': 'VAR'} VAR = {} VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = [VAR VAR VAR VAR VAR.VAR(VAR'\VAR\VAR')[1:] VAR VAR] VAR VAR VAR VAR: (VAR, VAR) = VAR.VAR(VAR': ') VAR[VAR.VAR('VAR')] = VAR.VAR('VAR') VAR.VAR(( 'VAR/1.1 204 VAR VAR\VAR\VAR' 'VAR-VAR: 0\VAR\VAR' '\VAR\VAR').VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = {'VAR-VAR': 'VAR', 'VAR': '{0}:{1}'.VAR(VAR.VAR, VAR.VAR)} VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=VAR(VAR)) VAR.VAR(VAR, VAR) VAR VAR(VAR):  VAR = 16    VAR = [(VAR'VAR-VAR-%VAR' % VAR, VAR(VAR)) VAR VAR VAR VAR(VAR(VAR))] VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = [VAR VAR VAR VAR VAR.VAR(VAR'\VAR\VAR')[1:] VAR VAR] VAR VAR VAR VAR: (VAR, VAR) = VAR.VAR(VAR': ') VAR VAR VAR.VAR('VAR').VAR(VAR'VAR-VAR-'): VAR VAR.VAR((VAR.VAR('VAR'), VAR.VAR('VAR'))) VAR.VAR(( VAR'VAR/1.1 204 VAR VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR').VAR('VAR')) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=VAR(VAR)) VAR.VAR(VAR, VAR) @VAR VAR VAR(VAR): VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR VAR VAR VAR.VAR(VAR'\VAR\VAR')[1:]: VAR VAR: VAR.VAR(VAR) VAR.VAR(( VAR'VAR/1.1 204 VAR VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR').VAR('VAR')) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR + '.', VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR.VAR( VAR, 'VAR', '%VAR:%VAR' % (VAR.VAR, VAR.VAR) ) VAR VAR(VAR):  VAR = 16    VAR = [('VAR-VAR-%VAR' % VAR, VAR(VAR)) VAR VAR VAR VAR(VAR(VAR))] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' + VAR'\VAR\VAR'.VAR([ (VAR.VAR('VAR') + VAR': ' + VAR.VAR('VAR')) VAR (VAR, VAR) VAR VAR ]) + VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0) VAR = [ (VAR, VAR) VAR (VAR, VAR) VAR VAR.VAR.VAR() VAR VAR.VAR('VAR-VAR-') ] VAR.VAR(VAR, VAR) @VAR.VAR.VAR( VAR(VAR.VAR, VAR), VAR='VAR VAR VAR VAR VAR' ) VAR VAR(VAR): VAR VAR(VAR, VAR, VAR=VAR): VAR.VAR(( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' ) + VAR'\VAR\VAR'.VAR(VAR) + VAR'\VAR\VAR\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR() VAR VAR: VAR.VAR('VAR', '/') VAR VAR VAR VAR: VAR 'VAR VAR VAR VAR' VAR VAR.VAR VAR \ VAR.VAR('/') == VAR.VAR[0]: VAR VAR VAR VAR VAR VAR VAR VAR.VAR(): VAR VAR.VAR('VAR VAR VAR VAR VAR') VAR VAR(VAR): VAR.VAR([ VAR': VAR', VAR'VAR: VAR', ]) VAR VAR(VAR): VAR.VAR([ VAR':', VAR'VAR: VAR', ]) VAR VAR(VAR): VAR.VAR([ VAR'VAR VAR', VAR'VAR: VAR', ], 'VAR VAR') VAR VAR(VAR): VAR VAR(VAR, VAR): VAR.VAR(( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' ) + VAR + VAR'\VAR\VAR\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR() VAR VAR: VAR.VAR('VAR', '/') VAR VAR VAR VAR: VAR 'VAR VAR VAR VAR' VAR VAR VAR.VAR VAR VAR(VAR): VAR.VAR(VAR'VAR-VAR: VAR/VAR') VAR VAR(VAR): VAR.VAR(VAR'VAR-VAR: VAR/VAR') VAR VAR(VAR): VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR)  VAR.VAR([], VAR(VAR.VAR())) VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 256\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR)  VAR.VAR([], VAR(VAR.VAR())) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 12\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' VAR'VAR, VAR' ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR)  VAR.VAR([VAR'VAR, VAR'], VAR(VAR.VAR(VAR))) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 22\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' VAR'VAR, VAR' ) VAR.VAR(1) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR)  VAR = VAR.VAR('VAR', VAR='/', VAR=VAR, VAR=VAR) VAR = VAR.VAR(100)   VAR(VAR) VAR: VAR(VAR) VAR.VAR() VAR VAR VAR VAR: VAR.VAR('12 VAR VAR, 10 VAR VAR', VAR(VAR)) VAR.VAR() VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 22\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR.VAR(1) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR)  VAR = VAR.VAR('VAR', VAR='/', VAR=VAR, VAR=VAR) VAR = [VAR VAR VAR VAR VAR.VAR(1)] VAR.VAR(VAR(VAR), 0) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536).VAR(VAR'\VAR\VAR\VAR\VAR'): VAR   VAR.VAR( VAR'VAR/1.1 404 VAR VAR\VAR\VAR' VAR'VAR-VAR: 1000\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR=1, VAR=VAR, VAR=[404], ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR.VAR == 1 ",8
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,dummyserver/handlers.py,"from __future__ import print_function

import collections
import contextlib
import gzip
import json
import logging
import sys
import time
import zlib

from io import BytesIO
from tornado.web import RequestHandler
from tornado import httputil
from datetime import datetime
from datetime import timedelta

from urllib3.packages.six.moves.http_client import responses
from urllib3.packages.six.moves.urllib.parse import urlsplit
from urllib3.packages.six import binary_type

log = logging.getLogger(__name__)


class Response(object):
    def __init__(self, body='', status='200 OK', headers=None):
        self.body = body
        self.status = status
        self.headers = headers or [(""Content-type"", ""text/plain"")]

    def __call__(self, request_handler):
        status, reason = self.status.split(' ', 1)
        request_handler.set_status(int(status), reason)
        for header, value in self.headers:
            request_handler.add_header(header, value)

        # chunked
        if isinstance(self.body, list):
            for item in self.body:
                if not isinstance(item, bytes):
                    item = item.encode('utf8')
                request_handler.write(item)
                request_handler.flush()
        else:
            body = self.body
            if not isinstance(body, bytes):
                body = body.encode('utf8')

            request_handler.write(body)


RETRY_TEST_NAMES = collections.defaultdict(int)


class TestingApp(RequestHandler):
    """"""
    Simple app that performs various operations, useful for testing an HTTP
    library.

    Given any path, it will attempt to load a corresponding local method if
    it exists. Status code 200 indicates success, 400 indicates failure. Each
    method has its own conditions for success/failure.
    """"""
    def get(self):
        """""" Handle GET requests """"""
        self._call_method()

    def post(self):
        """""" Handle POST requests """"""
        self._call_method()

    def put(self):
        """""" Handle PUT requests """"""
        self._call_method()

    def options(self):
        """""" Handle OPTIONS requests """"""
        self._call_method()

    def head(self):
        """""" Handle HEAD requests """"""
        self._call_method()

    def _call_method(self):
        """""" Call the correct method in this class based on the incoming URI """"""
        req = self.request
        req.params = {}
        for k, v in req.arguments.items():
            req.params[k] = next(iter(v))

        path = req.path[:]
        if not path.startswith('/'):
            path = urlsplit(path).path

        target = path[1:].replace('/', '_')
        method = getattr(self, target, self.index)

        resp = method(req)

        if dict(resp.headers).get('Connection') == 'close':
            # FIXME: Can we kill the connection somehow?
            pass

        resp(self)

    def index(self, _request):
        ""Render simple message""
        return Response(""Dummy server!"")

    def certificate(self, request):
        """"""Return the requester's certificate.""""""
        cert = request.get_ssl_certificate()
        subject = dict()
        if cert is not None:
            subject = dict((k, v) for (k, v) in [y for z in cert['subject']
                                                 for y in z])
        return Response(json.dumps(subject))

    def source_address(self, request):
        """"""Return the requester's IP address.""""""
        return Response(request.remote_ip)

    def set_up(self, request):
        test_type = request.params.get('test_type')
        test_id = request.params.get('test_id')
        if test_id:
            print('\nNew test %s: %s' % (test_type, test_id))
        else:
            print('\nNew test %s' % test_type)
        return Response(""Dummy server is ready!"")

    def specific_method(self, request):
        ""Confirm that the request matches the desired method type""
        method = request.params.get('method')
        if method and not isinstance(method, str):
            method = method.decode('utf8')

        if request.method != method:
            return Response(""Wrong method: %s != %s"" %
                            (method, request.method), status='400 Bad Request')
        return Response()

    def upload(self, request):
        ""Confirm that the uploaded file conforms to specification""
        # FIXME: This is a huge broken mess
        param = request.params.get('upload_param', b'myfile').decode('ascii')
        filename = request.params.get('upload_filename', b'').decode('utf-8')
        size = int(request.params.get('upload_size', '0'))
        files_ = request.files.get(param)

        if len(files_) != 1:
            return Response(""Expected 1 file for '%s', not %d"" % (param, len(files_)),
                            status='400 Bad Request')
        file_ = files_[0]

        data = file_['body']
        if int(size) != len(data):
            return Response(""Wrong size: %d != %d"" %
                            (size, len(data)), status='400 Bad Request')

        got_filename = file_['filename']
        if(isinstance(got_filename, binary_type)):
            got_filename = got_filename.decode('utf-8')

        # Tornado can leave the trailing \n in place on the filename.
        if filename != got_filename:
            return Response(
                u""Wrong filename: %s != %s"" % (filename, file_.filename),
                status='400 Bad Request')

        return Response()

    def redirect(self, request):
        ""Perform a redirect to ``target``""
        target = request.params.get('target', '/')
        status = request.params.get('status', '303 See Other')
        if len(status) == 3:
            status = '%s Redirect' % status.decode('latin-1')

        headers = [('Location', target)]
        return Response(status=status, headers=headers)

    def not_found(self, request):
        return Response('Not found', status='404 Not Found')

    def multi_redirect(self, request):
        ""Performs a redirect chain based on ``redirect_codes``""
        codes = request.params.get('redirect_codes', b'200').decode('utf-8')
        head, tail = codes.split(',', 1) if "","" in codes else (codes, None)
        status = ""{0} {1}"".format(head, responses[int(head)])
        if not tail:
            return Response(""Done redirecting"", status=status)

        headers = [('Location', '/multi_redirect?redirect_codes=%s' % tail)]
        return Response(status=status, headers=headers)

    def keepalive(self, request):
        if request.params.get('close', b'0') == b'1':
            headers = [('Connection', 'close')]
            return Response('Closing', headers=headers)

        headers = [('Connection', 'keep-alive')]
        return Response('Keeping alive', headers=headers)

    def sleep(self, request):
        ""Sleep for a specified amount of ``seconds``""
        # DO NOT USE THIS, IT'S DEPRECATED.
        # FIXME: Delete this once appengine tests are fixed to not use this handler.
        seconds = float(request.params.get('seconds', '1'))
        time.sleep(seconds)
        return Response()

    def echo(self, request):
        ""Echo back the params""
        if request.method == 'GET':
            return Response(request.query)

        return Response(request.body)

    def encodingrequest(self, request):
        ""Check for UA accepting gzip/deflate encoding""
        data = b""hello, world!""
        encoding = request.headers.get('Accept-Encoding', '')
        headers = None
        if encoding == 'gzip':
            headers = [('Content-Encoding', 'gzip')]
            file_ = BytesIO()
            with contextlib.closing(gzip.GzipFile('', mode='w', fileobj=file_)) as zipfile:
                zipfile.write(data)
            data = file_.getvalue()
        elif encoding == 'deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = zlib.compress(data)
        elif encoding == 'garbage-gzip':
            headers = [('Content-Encoding', 'gzip')]
            data = 'garbage'
        elif encoding == 'garbage-deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = 'garbage'
        return Response(data, headers=headers)

    def headers(self, request):
        return Response(json.dumps(dict(request.headers)))

    def successful_retry(self, request):
        """""" Handler which will return an error and then success

        It's not currently very flexible as the number of retries is hard-coded.
        """"""
        test_name = request.headers.get('test-name', None)
        if not test_name:
            return Response(""test-name header not set"",
                            status=""400 Bad Request"")

        RETRY_TEST_NAMES[test_name] += 1

        if RETRY_TEST_NAMES[test_name] >= 2:
            return Response(""Retry successful!"")
        else:
            return Response(""need to keep retrying!"", status=""418 I'm A Teapot"")

    def chunked(self, request):
        return Response(['123'] * 4)

    def chunked_gzip(self, request):
        chunks = []
        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)

        for uncompressed in [b'123'] * 4:
            chunks.append(compressor.compress(uncompressed))

        chunks.append(compressor.flush())

        return Response(chunks, headers=[('Content-Encoding', 'gzip')])

    def nbytes(self, request):
        length = int(request.params.get('length'))
        data = b'1' * length
        return Response(
            data,
            headers=[('Content-Type', 'application/octet-stream')])

    def status(self, request):
        status = request.params.get(""status"", ""200 OK"")

        return Response(status=status)

    def retry_after(self, request):
        if datetime.now() - self.application.last_req < timedelta(seconds=1):
            status = request.params.get(""status"", b""429 Too Many Requests"")
            return Response(
                    status=status.decode('utf-8'),
                    headers=[('Retry-After', '1')])

        self.application.last_req = datetime.now()

        return Response(status=""200 OK"")

    def redirect_after(self, request):
        ""Perform a redirect to ``target``""
        date = request.params.get('date')
        if date:
            retry_after = str(httputil.format_timestamp(
                    datetime.fromtimestamp(float(date))))
        else:
            retry_after = '1'
        target = request.params.get('target', '/')
        headers = [('Location', target), ('Retry-After', retry_after)]
        return Response(status='303 See Other', headers=headers)

    def shutdown(self, request):
        sys.exit()",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR, VAR='', VAR='200 VAR', VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR [(""VAR-VAR"", ""VAR/VAR"")] VAR VAR(VAR, VAR): VAR, VAR = VAR.VAR.VAR(' ', 1) VAR.VAR(VAR(VAR), VAR) VAR VAR, VAR VAR VAR.VAR: VAR.VAR(VAR, VAR)  VAR VAR(VAR.VAR, VAR): VAR VAR VAR VAR.VAR: VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR.VAR() VAR: VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR 200 VAR VAR, 400 VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR/VAR. """""" VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR.VAR VAR.VAR = {} VAR VAR, VAR VAR VAR.VAR.VAR(): VAR.VAR[VAR] = VAR(VAR(VAR)) VAR = VAR.VAR[:] VAR VAR VAR.VAR('/'): VAR = VAR(VAR).VAR VAR = VAR[1:].VAR('/', 'VAR') VAR = VAR(VAR, VAR, VAR.VAR) VAR = VAR(VAR) VAR VAR(VAR.VAR).VAR('VAR') == 'VAR':  VAR VAR(VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR"" VAR VAR(""VAR VAR!"") VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR."""""" VAR = VAR.VAR() VAR = VAR() VAR VAR VAR VAR VAR: VAR = VAR((VAR, VAR) VAR (VAR, VAR) VAR [VAR VAR VAR VAR VAR['VAR'] VAR VAR VAR VAR]) VAR VAR(VAR.VAR(VAR)) VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR VAR."""""" VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR('VAR') VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR('\VAR VAR %VAR: %VAR' % (VAR, VAR)) VAR: VAR('\VAR VAR %VAR' % VAR) VAR VAR(""VAR VAR VAR VAR!"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR = VAR.VAR.VAR('VAR') VAR VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR VAR.VAR != VAR: VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR""  VAR = VAR.VAR.VAR('VAR', VAR'VAR').VAR('VAR') VAR = VAR.VAR.VAR('VAR', VAR'').VAR('VAR-8') VAR = VAR(VAR.VAR.VAR('VAR', '0')) VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) != 1: VAR VAR(""VAR 1 VAR VAR '%VAR', VAR %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR = VAR[0] VAR = VAR['VAR'] VAR VAR(VAR) != VAR(VAR): VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR = VAR['VAR'] VAR(VAR(VAR, VAR)): VAR = VAR.VAR('VAR-8')  VAR VAR != VAR: VAR VAR( VAR""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', '/') VAR = VAR.VAR.VAR('VAR', '303 VAR VAR') VAR VAR(VAR) == 3: VAR = '%VAR VAR' % VAR.VAR('VAR-1') VAR = [('VAR', VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR('VAR VAR', VAR='404 VAR VAR') VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', VAR'200').VAR('VAR-8') VAR, VAR = VAR.VAR(',', 1) VAR "","" VAR VAR VAR (VAR, VAR) VAR = ""{0} {1}"".VAR(VAR, VAR[VAR(VAR)]) VAR VAR VAR: VAR VAR(""VAR VAR"", VAR=VAR) VAR = [('VAR', '/VAR?VAR=%VAR' % VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR('VAR', VAR'0') == VAR'1': VAR = [('VAR', 'VAR')] VAR VAR('VAR', VAR=VAR) VAR = [('VAR', 'VAR-VAR')] VAR VAR('VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``""   VAR = VAR(VAR.VAR.VAR('VAR', '1')) VAR.VAR(VAR) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR"" VAR VAR.VAR == 'VAR': VAR VAR(VAR.VAR) VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR/VAR VAR"" VAR = VAR""VAR, VAR!"" VAR = VAR.VAR.VAR('VAR-VAR', '') VAR = VAR VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR() VAR VAR.VAR(VAR.VAR('', VAR='VAR', VAR=VAR)) VAR VAR: VAR.VAR(VAR) VAR = VAR.VAR() VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR.VAR(VAR) VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR(VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR(VAR.VAR(VAR(VAR.VAR))) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR', VAR) VAR VAR VAR: VAR VAR(""VAR-VAR VAR VAR VAR"", VAR=""400 VAR VAR"") VAR[VAR] += 1 VAR VAR[VAR] >= 2: VAR VAR(""VAR VAR!"") VAR: VAR VAR(""VAR VAR VAR VAR!"", VAR=""418 VAR'VAR VAR VAR"") VAR VAR(VAR, VAR): VAR VAR(['123'] * 4) VAR VAR(VAR, VAR): VAR = [] VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR VAR VAR [VAR'123'] * 4: VAR.VAR(VAR.VAR(VAR)) VAR.VAR(VAR.VAR()) VAR VAR(VAR, VAR=[('VAR-VAR', 'VAR')]) VAR VAR(VAR, VAR): VAR = VAR(VAR.VAR.VAR('VAR')) VAR = VAR'1' * VAR VAR VAR( VAR, VAR=[('VAR-VAR', 'VAR/VAR-VAR')]) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(""VAR"", ""200 VAR"") VAR VAR(VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR() - VAR.VAR.VAR < VAR(VAR=1): VAR = VAR.VAR.VAR(""VAR"", VAR""429 VAR VAR VAR"") VAR VAR( VAR=VAR.VAR('VAR-8'), VAR=[('VAR-VAR', '1')]) VAR.VAR.VAR = VAR.VAR() VAR VAR(VAR=""200 VAR"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR = VAR(VAR.VAR( VAR.VAR(VAR(VAR)))) VAR: VAR = '1' VAR = VAR.VAR.VAR('VAR', '/') VAR = [('VAR', VAR), ('VAR-VAR', VAR)] VAR VAR(VAR='303 VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): VAR.VAR() ",8
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/appengine/test_urlfetch.py,"""""""These tests ensure that when running in App Engine standard with the
App Engine sandbox enabled that urllib3 appropriately uses the App
Engine-patched version of httplib to make requests.""""""

import httplib
import StringIO
import unittest

from mock import patch
import pytest

from ..test_no_ssl import TestWithoutSSL


class MockResponse(object):
    def __init__(self, content, status_code, content_was_truncated, final_url,
                 headers):

        self.content = content
        self.status_code = status_code
        self.content_was_truncated = content_was_truncated
        self.final_url = final_url
        self.header_msg = httplib.HTTPMessage(StringIO.StringIO(''.join(
            [""%s: %s\n"" % (k, v) for k, v in headers.iteritems()] + [""\n""])))
        self.headers = headers


@pytest.mark.usefixtures('sandbox')
class TestHTTP(TestWithoutSSL):
    def test_urlfetch_called_with_http(self):
        """"""Check that URLFetch is used to fetch non-https resources.""""""
        resp = MockResponse(
            'OK',
            200,
            False,
            'http://www.google.com',
            {'content-type': 'text/plain'})
        fetch_patch = patch(
            'google.appengine.api.urlfetch.fetch', return_value=resp
        )
        with fetch_patch as fetch_mock:
            import urllib3
            pool = urllib3.HTTPConnectionPool('www.google.com', '80')
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200, r.data)
            self.assertEqual(fetch_mock.call_count, 1)


@pytest.mark.usefixtures('sandbox')
class TestHTTPS(unittest.TestCase):
    @pytest.mark.xfail(
        reason='This is not yet supported by urlfetch, presence of the ssl '
               'module will bypass urlfetch.')
    def test_urlfetch_called_with_https(self):
        """"""
        Check that URLFetch is used when fetching https resources
        """"""
        resp = MockResponse(
            'OK',
            200,
            False,
            'https://www.google.com',
            {'content-type': 'text/plain'})
        fetch_patch = patch(
            'google.appengine.api.urlfetch.fetch', return_value=resp
        )
        with fetch_patch as fetch_mock:
            import urllib3
            pool = urllib3.HTTPSConnectionPool('www.google.com', '443')
            pool.ConnectionCls = urllib3.connection.UnverifiedHTTPSConnection
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200, r.data)
            self.assertEqual(fetch_mock.call_count, 1)",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"""""""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ..VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR, VAR, VAR, VAR, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR.VAR(VAR.VAR(''.VAR( [""%VAR: %VAR\VAR"" % (VAR, VAR) VAR VAR, VAR VAR VAR.VAR()] + [""\VAR""]))) VAR.VAR = VAR @VAR.VAR.VAR('VAR') VAR VAR(VAR): VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR."""""" VAR = VAR( 'VAR', 200, VAR, 'VAR: {'VAR-VAR': 'VAR/VAR'}) VAR = VAR( 'VAR.VAR.VAR.VAR.VAR', VAR=VAR ) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR('VAR.VAR.VAR', '80') VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR.VAR(VAR.VAR, 1) @VAR.VAR.VAR('VAR') VAR VAR(VAR.VAR): @VAR.VAR.VAR( VAR='VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR ' 'VAR VAR VAR VAR.') VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR( 'VAR', 200, VAR, 'VAR: {'VAR-VAR': 'VAR/VAR'}) VAR = VAR( 'VAR.VAR.VAR.VAR.VAR', VAR=VAR ) VAR VAR VAR VAR: VAR VAR VAR = VAR.VAR('VAR.VAR.VAR', '443') VAR.VAR = VAR.VAR.VAR VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR.VAR(VAR.VAR, 1) ",8
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/contritest_socks.py,"import threading
import socket

from urllib3.contrib import socks
from urllib3.exceptions import ConnectTimeoutError, NewConnectionError

from dummyserver.server import DEFAULT_CERTS, DEFAULT_CA
from dummyserver.testcase import IPV4SocketDummyServerTestCase

import pytest

try:
    import ssl
    from urllib3.util import ssl_ as better_ssl
    HAS_SSL = True
except ImportError:
    ssl = None
    better_ssl = None
    HAS_SSL = False


SOCKS_NEGOTIATION_NONE = b'\x00'
SOCKS_NEGOTIATION_PASSWORD = b'\x02'

SOCKS_VERSION_SOCKS4 = b'\x04'
SOCKS_VERSION_SOCKS5 = b'\x05'


def _get_free_port(host):
    """"""
    Gets a free port by opening a socket, binding it, checking the assigned
    port, and then closing it.
    """"""
    s = socket.socket()
    s.bind((host, 0))
    port = s.getsockname()[1]
    s.close()
    return port


def _read_exactly(sock, amt):
    """"""
    Read *exactly* ``amt`` bytes from the socket ``sock``.
    """"""
    data = b''

    while amt > 0:
        chunk = sock.recv(amt)
        data += chunk
        amt -= len(chunk)

    return data


def _read_until(sock, char):
    """"""
    Read from the socket until the character is received.
    """"""
    chunks = []
    while True:
        chunk = sock.recv(1)
        chunks.append(chunk)
        if chunk == char:
            break

    return b''.join(chunks)


def _address_from_socket(sock):
    """"""
    Returns the address from the SOCKS socket
    """"""
    addr_type = sock.recv(1)

    if addr_type == b'\x01':
        ipv4_addr = _read_exactly(sock, 4)
        return socket.inet_ntoa(ipv4_addr)
    elif addr_type == b'\x04':
        ipv6_addr = _read_exactly(sock, 16)
        return socket.inet_ntop(socket.AF_INET6, ipv6_addr)
    elif addr_type == b'\x03':
        addr_len = ord(sock.recv(1))
        return _read_exactly(sock, addr_len)
    else:
        raise RuntimeError(""Unexpected addr type: %r"" % addr_type)


def handle_socks5_negotiation(sock, negotiate, username=None,
                              password=None):
    """"""
    Handle the SOCKS5 handshake.

    Returns a generator object that allows us to break the handshake into
    steps so that the test code can intervene at certain useful points.
    """"""
    received_version = sock.recv(1)
    assert received_version == SOCKS_VERSION_SOCKS5
    nmethods = ord(sock.recv(1))
    methods = _read_exactly(sock, nmethods)

    if negotiate:
        assert SOCKS_NEGOTIATION_PASSWORD in methods
        send_data = SOCKS_VERSION_SOCKS5 + SOCKS_NEGOTIATION_PASSWORD
        sock.sendall(send_data)

        # This is the password negotiation.
        negotiation_version = sock.recv(1)
        assert negotiation_version == b'\x01'
        ulen = ord(sock.recv(1))
        provided_username = _read_exactly(sock, ulen)
        plen = ord(sock.recv(1))
        provided_password = _read_exactly(sock, plen)

        if username == provided_username and password == provided_password:
            sock.sendall(b'\x01\x00')
        else:
            sock.sendall(b'\x01\x01')
            sock.close()
            yield False
            return
    else:
        assert SOCKS_NEGOTIATION_NONE in methods
        send_data = SOCKS_VERSION_SOCKS5 + SOCKS_NEGOTIATION_NONE
        sock.sendall(send_data)

    # Client sends where they want to go.
    received_version = sock.recv(1)
    command = sock.recv(1)
    reserved = sock.recv(1)
    addr = _address_from_socket(sock)
    port = _read_exactly(sock, 2)
    port = (ord(port[0:1]) << 8) + (ord(port[1:2]))

    # Check some basic stuff.
    assert received_version == SOCKS_VERSION_SOCKS5
    assert command == b'\x01'  # Only support connect, not bind.
    assert reserved == b'\x00'

    # Yield the address port tuple.
    succeed = yield addr, port

    if succeed:
        # Hard-coded response for now.
        response = (
            SOCKS_VERSION_SOCKS5 + b'\x00\x00\x01\x7f\x00\x00\x01\xea\x60'
        )
    else:
        # Hard-coded response for now.
        response = SOCKS_VERSION_SOCKS5 + b'\x01\00'

    sock.sendall(response)
    yield True  # Avoid StopIteration exceptions getting fired.


def handle_socks4_negotiation(sock, username=None):
    """"""
    Handle the SOCKS4 handshake.

    Returns a generator object that allows us to break the handshake into
    steps so that the test code can intervene at certain useful points.
    """"""
    received_version = sock.recv(1)
    command = sock.recv(1)
    port = _read_exactly(sock, 2)
    port = (ord(port[0:1]) << 8) + (ord(port[1:2]))
    addr = _read_exactly(sock, 4)
    provided_username = _read_until(sock, b'\x00')[:-1]  # Strip trailing null.

    if addr == b'\x00\x00\x00\x01':
        # Magic string: means DNS name.
        addr = _read_until(sock, b'\x00')[:-1]  # Strip trailing null.
    else:
        addr = socket.inet_ntoa(addr)

    # Check some basic stuff.
    assert received_version == SOCKS_VERSION_SOCKS4
    assert command == b'\x01'  # Only support connect, not bind.

    if username is not None and username != provided_username:
        sock.sendall(b'\x00\x5d\x00\x00\x00\x00\x00\x00')
        sock.close()
        yield False
        return

    # Yield the address port tuple.
    succeed = yield addr, port

    if succeed:
        response = b'\x00\x5a\xea\x60\x7f\x00\x00\x01'
    else:
        response = b'\x00\x5b\x00\x00\x00\x00\x00\x00'

    sock.sendall(response)
    yield True  # Avoid StopIteration exceptions getting fired.


class TestSOCKSProxyManager(object):

    def test_invalid_socks_version_is_valueerror(self):
        with pytest.raises(ValueError) as e:
            socks.SOCKSProxyManager(proxy_url='http://example.org')
        assert 'Unable to determine SOCKS version' in e.value.args[0]


class TestSocks5Proxy(IPV4SocketDummyServerTestCase):
    """"""
    Test the SOCKS proxy in SOCKS5 mode.
    """"""
    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_local_dns(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertIn(addr, ['127.0.0.1', '::1'])
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://localhost')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_correct_header_line(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, b'example.com')
            self.assertEqual(port, 80)
            handler.send(True)

            buf = b''
            while True:
                buf += sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            self.assertTrue(buf.startswith(b'GET / HTTP/1.1'))
            self.assertIn(b'Host: example.com', buf)

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://example.com')
        self.assertEqual(response.status, 200)

    def test_connection_timeouts(self):
        event = threading.Event()

        def request_handler(listener):
            event.wait()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        self.assertRaises(
            ConnectTimeoutError, pm.request, 'GET', 'http://example.com',
            timeout=0.001, retries=False
        )
        event.set()

    def test_connection_failure(self):
        event = threading.Event()

        def request_handler(listener):
            listener.close()
            event.set()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        event.wait()
        self.assertRaises(
            NewConnectionError, pm.request, 'GET', 'http://example.com',
            retries=False
        )

    def test_proxy_rejection(self):
        evt = threading.Event()

        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)
            handler.send(False)

            evt.wait()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        self.assertRaises(
            NewConnectionError, pm.request, 'GET', 'http://example.com',
            retries=False
        )
        evt.set()

    def test_socks_with_password(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b'user', password=b'pass'
            )
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='user',
                                     password='pass')
        self.addCleanup(pm.clear)

        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_socks_with_auth_in_url(self):
        """"""
        Test when we have auth info in url, i.e.
        socks5://user:pass@host:port and no username/password as params
        """"""
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b'user', password=b'pass'
            )
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://user:pass@%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_socks_with_invalid_password(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(
                sock, negotiate=True, username=b'user', password=b'pass'
            )
            next(handler)

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='user',
                                     password='badpass')
        self.addCleanup(pm.clear)

        try:
            pm.request('GET', 'http://example.com', retries=False)
        except NewConnectionError as e:
            self.assertIn(""SOCKS5 authentication failed"", str(e))
        else:
            self.fail(""Did not raise"")

    def test_source_address_works(self):
        expected_port = _get_free_port(self.host)

        def request_handler(listener):
            sock = listener.accept()[0]
            self.assertEqual(sock.getpeername()[0], '127.0.0.1')
            self.assertEqual(sock.getpeername()[1], expected_port)

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(
            proxy_url, source_address=('127.0.0.1', expected_port)
        )
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')
        self.assertEqual(response.status, 200)


class TestSOCKS4Proxy(IPV4SocketDummyServerTestCase):
    """"""
    Test the SOCKS proxy in SOCKS4 mode.

    Has relatively fewer tests than the SOCKS5 case, mostly because once the
    negotiation is done the two cases behave identically.
    """"""
    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.headers['Server'], 'SocksTestServer')
        self.assertEqual(response.data, b'')

    def test_local_dns(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            self.assertEqual(addr, '127.0.0.1')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://localhost')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.headers['Server'], 'SocksTestServer')
        self.assertEqual(response.data, b'')

    def test_correct_header_line(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)

            self.assertEqual(addr, b'example.com')
            self.assertEqual(port, 80)
            handler.send(True)

            buf = b''
            while True:
                buf += sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            self.assertTrue(buf.startswith(b'GET / HTTP/1.1'))
            self.assertIn(b'Host: example.com', buf)

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://example.com')
        self.assertEqual(response.status, 200)

    def test_proxy_rejection(self):
        evt = threading.Event()

        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock)
            addr, port = next(handler)
            handler.send(False)

            evt.wait()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url)
        self.addCleanup(pm.clear)

        self.assertRaises(
            NewConnectionError, pm.request, 'GET', 'http://example.com',
            retries=False
        )
        evt.set()

    def test_socks4_with_username(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock, username=b'user')
            addr, port = next(handler)

            self.assertEqual(addr, '16.17.18.19')
            self.assertEqual(port, 80)
            handler.send(True)

            while True:
                buf = sock.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            sock.sendall(b'HTTP/1.1 200 OK\r\n'
                         b'Server: SocksTestServer\r\n'
                         b'Content-Length: 0\r\n'
                         b'\r\n')
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks4://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='user')
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'http://16.17.18.19')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')

    def test_socks_with_invalid_username(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks4_negotiation(sock, username=b'user')
            next(handler)

        self._start_server(request_handler)
        proxy_url = ""socks4a://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, username='baduser')
        self.addCleanup(pm.clear)

        try:
            pm.request('GET', 'http://example.com', retries=False)
        except NewConnectionError as e:
            self.assertIn(""different user-ids"", str(e))
        else:
            self.fail(""Did not raise"")


class TestSOCKSWithTLS(IPV4SocketDummyServerTestCase):
    """"""
    Test that TLS behaves properly for SOCKS proxies.
    """"""
    @pytest.mark.skipif(not HAS_SSL, reason='No TLS available')
    def test_basic_request(self):
        def request_handler(listener):
            sock = listener.accept()[0]

            handler = handle_socks5_negotiation(sock, negotiate=False)
            addr, port = next(handler)

            self.assertEqual(addr, b'localhost')
            self.assertEqual(port, 443)
            handler.send(True)

            # Wrap in TLS
            context = better_ssl.SSLContext(ssl.PROTOCOL_SSLv23)
            context.load_cert_chain(
                DEFAULT_CERTS['certfile'], DEFAULT_CERTS['keyfile']
            )
            tls = context.wrap_socket(sock, server_side=True)
            buf = b''

            while True:
                buf += tls.recv(65535)
                if buf.endswith(b'\r\n\r\n'):
                    break

            self.assertTrue(buf.startswith(b'GET / HTTP/1.1\r\n'))

            tls.sendall(b'HTTP/1.1 200 OK\r\n'
                        b'Server: SocksTestServer\r\n'
                        b'Content-Length: 0\r\n'
                        b'\r\n')
            tls.close()
            sock.close()

        self._start_server(request_handler)
        proxy_url = ""socks5h://%s:%s"" % (self.host, self.port)
        pm = socks.SOCKSProxyManager(proxy_url, ca_certs=DEFAULT_CA)
        self.addCleanup(pm.clear)
        response = pm.request('GET', 'https://localhost')

        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'')
        self.assertEqual(response.headers['Server'], 'SocksTestServer')",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR = VAR VAR VAR: VAR = VAR VAR = VAR VAR = VAR VAR = VAR'\VAR' VAR = VAR'\VAR' VAR = VAR'\VAR' VAR = VAR'\VAR' VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR.VAR((VAR, 0)) VAR = VAR.VAR()[1] VAR.VAR() VAR VAR VAR VAR(VAR, VAR): """""" VAR *VAR* ``VAR`` VAR VAR VAR VAR ``VAR``. """""" VAR = VAR'' VAR VAR > 0: VAR = VAR.VAR(VAR) VAR += VAR VAR -= VAR(VAR) VAR VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = [] VAR VAR: VAR = VAR.VAR(1) VAR.VAR(VAR) VAR VAR == VAR: VAR VAR VAR''.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR.VAR(1) VAR VAR == VAR'\VAR': VAR = VAR(VAR, 4) VAR VAR.VAR(VAR) VAR VAR == VAR'\VAR': VAR = VAR(VAR, 16) VAR VAR.VAR(VAR.VAR, VAR) VAR VAR == VAR'\VAR': VAR = VAR(VAR.VAR(1)) VAR VAR(VAR, VAR) VAR: VAR VAR(""VAR VAR VAR: %VAR"" % VAR) VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): """""" VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(1) VAR VAR == VAR VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR VAR: VAR VAR VAR VAR VAR = VAR + VAR VAR.VAR(VAR)  VAR = VAR.VAR(1) VAR VAR == VAR'\VAR' VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR = VAR(VAR.VAR(1)) VAR = VAR(VAR, VAR) VAR VAR == VAR VAR VAR == VAR: VAR.VAR(VAR'\VAR\VAR') VAR: VAR.VAR(VAR'\VAR\VAR') VAR.VAR() VAR VAR VAR VAR: VAR VAR VAR VAR VAR = VAR + VAR VAR.VAR(VAR)  VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR(VAR) VAR = VAR(VAR, 2) VAR = (VAR(VAR[0:1]) << 8) + (VAR(VAR[1:2]))  VAR VAR == VAR VAR VAR == VAR'\VAR'  VAR VAR == VAR'\VAR'  VAR = VAR VAR, VAR VAR VAR:  VAR = ( VAR + VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ) VAR:  VAR = VAR + VAR'\VAR\00' VAR.VAR(VAR) VAR VAR  VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(1) VAR = VAR.VAR(1) VAR = VAR(VAR, 2) VAR = (VAR(VAR[0:1]) << 8) + (VAR(VAR[1:2])) VAR = VAR(VAR, 4) VAR = VAR(VAR, VAR'\VAR')[:-1]  VAR VAR == VAR'\VAR\VAR\VAR\VAR':  VAR = VAR(VAR, VAR'\VAR')[:-1]  VAR: VAR = VAR.VAR(VAR)  VAR VAR == VAR VAR VAR == VAR'\VAR'  VAR VAR VAR VAR VAR VAR VAR != VAR: VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR') VAR.VAR() VAR VAR VAR  VAR = VAR VAR, VAR VAR VAR: VAR = VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR: VAR = VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR.VAR(VAR) VAR VAR  VAR VAR(VAR): VAR VAR(VAR): VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(VAR='VAR: VAR 'VAR VAR VAR VAR VAR' VAR VAR.VAR.VAR[0] VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, ['127.0.0.1', '::1']) VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, VAR'VAR.VAR') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR = VAR'' VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR.VAR(VAR'VAR / VAR/1.1')) VAR.VAR(VAR'VAR: VAR.VAR', VAR) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=0.001, VAR=VAR ) VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR() VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR ) VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR ) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR'VAR', VAR=VAR'VAR' ) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR', VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR.VAR. VAR: """""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR'VAR', VAR=VAR'VAR' ) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR( VAR, VAR=VAR, VAR=VAR'VAR', VAR=VAR'VAR' ) VAR(VAR) VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR', VAR='VAR') VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', 'VAR: VAR VAR VAR VAR: VAR.VAR(""VAR VAR VAR"", VAR(VAR)) VAR: VAR.VAR(""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR(VAR.VAR()[0], '127.0.0.1') VAR.VAR(VAR.VAR()[1], VAR) VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR( VAR, VAR=('127.0.0.1', VAR) ) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR.VAR(VAR.VAR, VAR'') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, '127.0.0.1') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR.VAR(VAR.VAR, VAR'') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, VAR'VAR.VAR') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR = VAR'' VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR.VAR(VAR'VAR / VAR/1.1')) VAR.VAR(VAR'VAR: VAR.VAR', VAR) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR) VAR.VAR( VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR ) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR'VAR') VAR, VAR = VAR(VAR) VAR.VAR(VAR, '16.17.18.19') VAR.VAR(VAR, 80) VAR.VAR(VAR) VAR VAR: VAR = VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR'VAR') VAR(VAR) VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', 'VAR: VAR VAR VAR VAR: VAR.VAR(""VAR VAR-VAR"", VAR(VAR)) VAR: VAR.VAR(""VAR VAR VAR"") VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. """""" @VAR.VAR.VAR(VAR VAR, VAR='VAR VAR VAR') VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR(VAR, VAR=VAR) VAR, VAR = VAR(VAR) VAR.VAR(VAR, VAR'VAR') VAR.VAR(VAR, 443) VAR.VAR(VAR)  VAR = VAR.VAR(VAR.VAR) VAR.VAR( VAR['VAR'], VAR['VAR'] ) VAR = VAR.VAR(VAR, VAR=VAR) VAR = VAR'' VAR VAR: VAR += VAR.VAR(65535) VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR(VAR.VAR(VAR'VAR / VAR/1.1\VAR\VAR')) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = ""VAR: VAR = VAR.VAR(VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'') VAR.VAR(VAR.VAR['VAR'], 'VAR') ",8
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/with_dummyserver/test_connectionpool.py,"import io
import logging
import socket
import sys
import unittest
import time
import warnings
import pytest

import mock

from .. import (
    TARPIT_HOST, VALID_SOURCE_ADDRESSES, INVALID_SOURCE_ADDRESSES,
)
from ..port_helpers import find_unused_port
from urllib3 import (
    encode_multipart_formdata,
    HTTPConnectionPool,
)
from urllib3.exceptions import (
    ConnectTimeoutError,
    EmptyPoolError,
    DecodeError,
    MaxRetryError,
    ReadTimeoutError,
    NewConnectionError,
    UnrewindableBodyError,
)
from urllib3.packages.six import b, u
from urllib3.packages.six.moves.urllib.parse import urlencode
from urllib3.util.retry import Retry, RequestHistory
from urllib3.util.timeout import Timeout

from dummyserver.testcase import HTTPDummyServerTestCase, SocketDummyServerTestCase
from dummyserver.server import NoIPv6Warning, HAS_IPV6_AND_DNS

from threading import Event

log = logging.getLogger('urllib3.connectionpool')
log.setLevel(logging.NOTSET)
log.addHandler(logging.StreamHandler(sys.stdout))


SHORT_TIMEOUT = 0.001
LONG_TIMEOUT = 0.03


def wait_for_socket(ready_event):
    ready_event.wait()
    ready_event.clear()


class TestConnectionPoolTimeouts(SocketDummyServerTestCase):

    def test_timeout_float(self):
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=2)

        # Pool-global timeout
        pool = HTTPConnectionPool(self.host, self.port, timeout=SHORT_TIMEOUT, retries=False)
        self.addCleanup(pool.close)
        wait_for_socket(ready_event)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')
        block_event.set()  # Release block

        # Shouldn't raise this time
        wait_for_socket(ready_event)
        block_event.set()  # Pre-release block
        pool.request('GET', '/')

    def test_conn_closed(self):
        block_event = Event()
        self.start_basic_handler(block_send=block_event, num=1)

        pool = HTTPConnectionPool(self.host, self.port, timeout=SHORT_TIMEOUT, retries=False)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        pool._put_conn(conn)
        try:
            pool.urlopen('GET', '/')
            self.fail(""The request should fail with a timeout error."")
        except ReadTimeoutError:
            if conn.sock:
                self.assertRaises(socket.error, conn.sock.recv, 1024)
        finally:
            pool._put_conn(conn)

        block_event.set()

    def test_timeout(self):
        # Requests should time out when expected
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=6)

        # Pool-global timeout
        timeout = Timeout(read=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)

        wait_for_socket(ready_event)
        conn = pool._get_conn()
        self.assertRaises(ReadTimeoutError, pool._make_request, conn, 'GET', '/')
        pool._put_conn(conn)
        block_event.set()  # Release request

        wait_for_socket(ready_event)
        block_event.clear()
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')
        block_event.set()  # Release request

        # Request-specific timeouts should raise errors
        pool = HTTPConnectionPool(self.host, self.port, timeout=LONG_TIMEOUT, retries=False)
        self.addCleanup(pool.close)

        conn = pool._get_conn()
        wait_for_socket(ready_event)
        now = time.time()
        self.assertRaises(ReadTimeoutError, pool._make_request, conn, 'GET', '/', timeout=timeout)
        delta = time.time() - now
        block_event.set()  # Release request

        message = ""timeout was pool-level LONG_TIMEOUT rather than request-level SHORT_TIMEOUT""
        self.assertLess(delta, LONG_TIMEOUT, message)
        pool._put_conn(conn)

        wait_for_socket(ready_event)
        now = time.time()
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/', timeout=timeout)
        delta = time.time() - now

        message = ""timeout was pool-level LONG_TIMEOUT rather than request-level SHORT_TIMEOUT""
        self.assertLess(delta, LONG_TIMEOUT, message)
        block_event.set()  # Release request

        # Timeout int/float passed directly to request and _make_request should
        # raise a request timeout
        wait_for_socket(ready_event)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/', timeout=SHORT_TIMEOUT)
        block_event.set()  # Release request

        wait_for_socket(ready_event)
        conn = pool._new_conn()
        # FIXME: This assert flakes sometimes. Not sure why.
        self.assertRaises(ReadTimeoutError,
                          pool._make_request,
                          conn, 'GET', '/',
                          timeout=SHORT_TIMEOUT)
        block_event.set()  # Release request

    def test_connect_timeout(self):
        url = '/'
        host, port = TARPIT_HOST, 80
        timeout = Timeout(connect=SHORT_TIMEOUT)

        # Pool-global timeout
        pool = HTTPConnectionPool(host, port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.assertRaises(ConnectTimeoutError, pool._make_request, conn, 'GET', url)

        # Retries
        retries = Retry(connect=0)
        self.assertRaises(MaxRetryError, pool.request, 'GET', url, retries=retries)

        # Request-specific connection timeouts
        big_timeout = Timeout(read=LONG_TIMEOUT, connect=LONG_TIMEOUT)
        pool = HTTPConnectionPool(host, port, timeout=big_timeout, retries=False)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.assertRaises(ConnectTimeoutError,
                          pool._make_request,
                          conn, 'GET', url,
                          timeout=timeout)

        pool._put_conn(conn)
        self.assertRaises(ConnectTimeoutError, pool.request, 'GET', url, timeout=timeout)

    def test_total_applies_connect(self):
        host, port = TARPIT_HOST, 80

        timeout = Timeout(total=None, connect=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(host, port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        self.assertRaises(ConnectTimeoutError, pool._make_request, conn, 'GET', '/')

        timeout = Timeout(connect=3, read=5, total=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(host, port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        self.assertRaises(ConnectTimeoutError, pool._make_request, conn, 'GET', '/')

    def test_total_timeout(self):
        block_event = Event()
        ready_event = self.start_basic_handler(block_send=block_event, num=2)

        wait_for_socket(ready_event)
        # This will get the socket to raise an EAGAIN on the read
        timeout = Timeout(connect=3, read=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')

        block_event.set()
        wait_for_socket(ready_event)
        block_event.clear()

        # The connect should succeed and this should hit the read timeout
        timeout = Timeout(connect=3, read=5, total=SHORT_TIMEOUT)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')

    def test_create_connection_timeout(self):
        self.start_basic_handler(block_send=Event(), num=0)  # needed for self.port

        timeout = Timeout(connect=SHORT_TIMEOUT, total=LONG_TIMEOUT)
        pool = HTTPConnectionPool(TARPIT_HOST, self.port, timeout=timeout, retries=False)
        self.addCleanup(pool.close)
        conn = pool._new_conn()
        self.assertRaises(ConnectTimeoutError, conn.connect)


class TestConnectionPool(HTTPDummyServerTestCase):

    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(self.pool.close)

    def test_get(self):
        r = self.pool.request('GET', '/specific_method',
                              fields={'method': 'GET'})
        self.assertEqual(r.status, 200, r.data)

    def test_post_url(self):
        r = self.pool.request('POST', '/specific_method',
                              fields={'method': 'POST'})
        self.assertEqual(r.status, 200, r.data)

    def test_urlopen_put(self):
        r = self.pool.urlopen('PUT', '/specific_method?method=PUT')
        self.assertEqual(r.status, 200, r.data)

    def test_wrong_specific_method(self):
        # To make sure the dummy server is actually returning failed responses
        r = self.pool.request('GET', '/specific_method',
                              fields={'method': 'POST'})
        self.assertEqual(r.status, 400, r.data)

        r = self.pool.request('POST', '/specific_method',
                              fields={'method': 'GET'})
        self.assertEqual(r.status, 400, r.data)

    def test_upload(self):
        data = ""I'm in ur multipart form-data, hazing a cheezburgr""
        fields = {
            'upload_param': 'filefield',
            'upload_filename': 'lolcat.txt',
            'upload_size': len(data),
            'filefield': ('lolcat.txt', data),
        }

        r = self.pool.request('POST', '/upload', fields=fields)
        self.assertEqual(r.status, 200, r.data)

    def test_one_name_multiple_values(self):
        fields = [
            ('foo', 'a'),
            ('foo', 'b'),
        ]

        # urlencode
        r = self.pool.request('GET', '/echo', fields=fields)
        self.assertEqual(r.data, b'foo=a&foo=b')

        # multipart
        r = self.pool.request('POST', '/echo', fields=fields)
        self.assertEqual(r.data.count(b'name=""foo""'), 2)

    def test_request_method_body(self):
        body = b'hi'
        r = self.pool.request('POST', '/echo', body=body)
        self.assertEqual(r.data, body)

        fields = [('hi', 'hello')]
        self.assertRaises(TypeError, self.pool.request, 'POST', '/echo', body=body, fields=fields)

    def test_unicode_upload(self):
        fieldname = u('myfile')
        filename = u('\xe2\x99\xa5.txt')
        data = u('\xe2\x99\xa5').encode('utf8')
        size = len(data)

        fields = {
            u('upload_param'): fieldname,
            u('upload_filename'): filename,
            u('upload_size'): size,
            fieldname: (filename, data),
        }

        r = self.pool.request('POST', '/upload', fields=fields)
        self.assertEqual(r.status, 200, r.data)

    def test_nagle(self):
        """""" Test that connections have TCP_NODELAY turned on """"""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        pool._make_request(conn, 'GET', '/')
        tcp_nodelay_setting = conn.sock.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)
        self.assertTrue(tcp_nodelay_setting)

    def test_socket_options(self):
        """"""Test that connections accept socket options.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries to
        # connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port, socket_options=[
            (socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)
        ])
        s = pool._new_conn()._new_conn()  # Get the socket
        using_keepalive = s.getsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE) > 0
        self.assertTrue(using_keepalive)
        s.close()

    def test_disable_default_socket_options(self):
        """"""Test that passing None disables all socket options.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port, socket_options=None)
        s = pool._new_conn()._new_conn()
        using_nagle = s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY) == 0
        self.assertTrue(using_nagle)
        s.close()

    def test_defaults_are_applied(self):
        """"""Test that modifying the default socket options works.""""""
        # This test needs to be here in order to be run. socket.create_connection actually tries
        # to connect to the host provided so we need a dummyserver to be running.
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        # Get the HTTPConnection instance
        conn = pool._new_conn()
        self.addCleanup(conn.close)
        # Update the default socket options
        conn.default_socket_options += [(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)]
        s = conn._new_conn()
        self.addCleanup(s.close)
        nagle_disabled = s.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY) > 0
        using_keepalive = s.getsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE) > 0
        self.assertTrue(nagle_disabled)
        self.assertTrue(using_keepalive)

    def test_connection_error_retries(self):
        """""" ECONNREFUSED error should raise a connection error, with retries """"""
        port = find_unused_port()
        pool = HTTPConnectionPool(self.host, port)
        try:
            pool.request('GET', '/', retries=Retry(connect=3))
            self.fail(""Should have failed with a connection error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), NewConnectionError)

    def test_timeout_success(self):
        timeout = Timeout(connect=3, read=5, total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        pool.request('GET', '/')
        # This should not raise a ""Timeout already started"" error
        pool.request('GET', '/')

        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        # This should also not raise a ""Timeout already started"" error
        pool.request('GET', '/')

        timeout = Timeout(total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        pool.request('GET', '/')

    def test_tunnel(self):
        # note the actual httplib.py has no tests for this functionality
        timeout = Timeout(total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)
        conn.set_tunnel(self.host, self.port)

        conn._tunnel = mock.Mock(return_value=None)
        pool._make_request(conn, 'GET', '/')
        conn._tunnel.assert_called_once_with()

        # test that it's not called when tunnel is not set
        timeout = Timeout(total=None)
        pool = HTTPConnectionPool(self.host, self.port, timeout=timeout)
        self.addCleanup(pool.close)
        conn = pool._get_conn()
        self.addCleanup(conn.close)

        conn._tunnel = mock.Mock(return_value=None)
        pool._make_request(conn, 'GET', '/')
        self.assertFalse(conn._tunnel.called)

    def test_redirect(self):
        r = self.pool.request('GET', '/redirect', fields={'target': '/'}, redirect=False)
        self.assertEqual(r.status, 303)

        r = self.pool.request('GET', '/redirect', fields={'target': '/'})
        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_bad_connect(self):
        pool = HTTPConnectionPool('badhost.invalid', self.port)
        try:
            pool.request('GET', '/', retries=5)
            self.fail(""should raise timeout exception here"")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), NewConnectionError)

    def test_keepalive(self):
        pool = HTTPConnectionPool(self.host, self.port, block=True, maxsize=1)
        self.addCleanup(pool.close)

        r = pool.request('GET', '/keepalive?close=0')
        r = pool.request('GET', '/keepalive?close=0')

        self.assertEqual(r.status, 200)
        self.assertEqual(pool.num_connections, 1)
        self.assertEqual(pool.num_requests, 2)

    def test_keepalive_close(self):
        pool = HTTPConnectionPool(self.host, self.port,
                                  block=True, maxsize=1, timeout=2)
        self.addCleanup(pool.close)

        r = pool.request('GET', '/keepalive?close=1', retries=0,
                         headers={
                             ""Connection"": ""close"",
                         })

        self.assertEqual(pool.num_connections, 1)

        # The dummyserver will have responded with Connection:close,
        # and httplib will properly cleanup the socket.

        # We grab the HTTPConnection object straight from the Queue,
        # because _get_conn() is where the check & reset occurs
        # pylint: disable-msg=W0212
        conn = pool.pool.get()
        self.assertIsNone(conn.sock)
        pool._put_conn(conn)

        # Now with keep-alive
        r = pool.request('GET', '/keepalive?close=0', retries=0,
                         headers={
                             ""Connection"": ""keep-alive"",
                         })

        # The dummyserver responded with Connection:keep-alive, the connection
        # persists.
        conn = pool.pool.get()
        self.assertIsNotNone(conn.sock)
        pool._put_conn(conn)

        # Another request asking the server to close the connection. This one
        # should get cleaned up for the next request.
        r = pool.request('GET', '/keepalive?close=1', retries=0,
                         headers={
                             ""Connection"": ""close"",
                         })

        self.assertEqual(r.status, 200)

        conn = pool.pool.get()
        self.assertIsNone(conn.sock)
        pool._put_conn(conn)

        # Next request
        r = pool.request('GET', '/keepalive?close=0')

    def test_post_with_urlencode(self):
        data = {'banana': 'hammock', 'lol': 'cat'}
        r = self.pool.request('POST', '/echo', fields=data, encode_multipart=False)
        self.assertEqual(r.data.decode('utf-8'), urlencode(data))

    def test_post_with_multipart(self):
        data = {'banana': 'hammock', 'lol': 'cat'}
        r = self.pool.request('POST', '/echo',
                              fields=data,
                              encode_multipart=True)
        body = r.data.split(b'\r\n')

        encoded_data = encode_multipart_formdata(data)[0]
        expected_body = encoded_data.split(b'\r\n')

        # TODO: Get rid of extra parsing stuff when you can specify
        # a custom boundary to encode_multipart_formdata
        """"""
        We need to loop the return lines because a timestamp is attached
        from within encode_multipart_formdata. When the server echos back
        the data, it has the timestamp from when the data was encoded, which
        is not equivalent to when we run encode_multipart_formdata on
        the data again.
        """"""
        for i, line in enumerate(body):
            if line.startswith(b'--'):
                continue

            self.assertEqual(body[i], expected_body[i])

    def test_post_with_multipart__iter__(self):
        data = {'hello': 'world'}
        r = self.pool.request('POST', '/echo',
                              fields=data,
                              preload_content=False,
                              multipart_boundary=""boundary"",
                              encode_multipart=True)

        chunks = [chunk for chunk in r]
        assert chunks == [
            b""--boundary\r\n"",
            b'Content-Disposition: form-data; name=""hello""\r\n',
            b'\r\n',
            b'world\r\n',
            b""--boundary--\r\n""
        ]

    def test_check_gzip(self):
        r = self.pool.request('GET', '/encodingrequest',
                              headers={'accept-encoding': 'gzip'})
        self.assertEqual(r.headers.get('content-encoding'), 'gzip')
        self.assertEqual(r.data, b'hello, world!')

    def test_check_deflate(self):
        r = self.pool.request('GET', '/encodingrequest',
                              headers={'accept-encoding': 'deflate'})
        self.assertEqual(r.headers.get('content-encoding'), 'deflate')
        self.assertEqual(r.data, b'hello, world!')

    def test_bad_decode(self):
        self.assertRaises(DecodeError, self.pool.request,
                          'GET', '/encodingrequest',
                          headers={'accept-encoding': 'garbage-deflate'})

        self.assertRaises(DecodeError, self.pool.request,
                          'GET', '/encodingrequest',
                          headers={'accept-encoding': 'garbage-gzip'})

    def test_connection_count(self):
        pool = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(pool.close)

        pool.request('GET', '/')
        pool.request('GET', '/')
        pool.request('GET', '/')

        self.assertEqual(pool.num_connections, 1)
        self.assertEqual(pool.num_requests, 3)

    def test_connection_count_bigpool(self):
        http_pool = HTTPConnectionPool(self.host, self.port, maxsize=16)
        self.addCleanup(http_pool.close)

        http_pool.request('GET', '/')
        http_pool.request('GET', '/')
        http_pool.request('GET', '/')

        self.assertEqual(http_pool.num_connections, 1)
        self.assertEqual(http_pool.num_requests, 3)

    def test_partial_response(self):
        pool = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(pool.close)

        req_data = {'lol': 'cat'}
        resp_data = urlencode(req_data).encode('utf-8')

        r = pool.request('GET', '/echo', fields=req_data, preload_content=False)

        self.assertEqual(r.read(5), resp_data[:5])
        self.assertEqual(r.read(), resp_data[5:])

    def test_lazy_load_twice(self):
        # This test is sad and confusing. Need to figure out what's
        # going on with partial reads and socket reuse.

        pool = HTTPConnectionPool(self.host, self.port, block=True, maxsize=1, timeout=2)

        payload_size = 1024 * 2
        first_chunk = 512

        boundary = 'foo'

        req_data = {'count': 'a' * payload_size}
        resp_data = encode_multipart_formdata(req_data, boundary=boundary)[0]

        req2_data = {'count': 'b' * payload_size}
        resp2_data = encode_multipart_formdata(req2_data, boundary=boundary)[0]

        r1 = pool.request('POST', '/echo',
                          fields=req_data,
                          multipart_boundary=boundary,
                          preload_content=False)

        self.assertEqual(r1.read(first_chunk), resp_data[:first_chunk])

        try:
            r2 = pool.request('POST', '/echo', fields=req2_data, multipart_boundary=boundary,
                              preload_content=False, pool_timeout=0.001)

            # This branch should generally bail here, but maybe someday it will
            # work? Perhaps by some sort of magic. Consider it a TODO.

            self.assertEqual(r2.read(first_chunk), resp2_data[:first_chunk])

            self.assertEqual(r1.read(), resp_data[first_chunk:])
            self.assertEqual(r2.read(), resp2_data[first_chunk:])
            self.assertEqual(pool.num_requests, 2)

        except EmptyPoolError:
            self.assertEqual(r1.read(), resp_data[first_chunk:])
            self.assertEqual(pool.num_requests, 1)

        self.assertEqual(pool.num_connections, 1)

    def test_for_double_release(self):
        MAXSIZE = 5

        # Check default state
        pool = HTTPConnectionPool(self.host, self.port, maxsize=MAXSIZE)
        self.addCleanup(pool.close)
        self.assertEqual(pool.num_connections, 0)
        self.assertEqual(pool.pool.qsize(), MAXSIZE)

        # Make an empty slot for testing
        pool.pool.get()
        self.assertEqual(pool.pool.qsize(), MAXSIZE-1)

        # Check state after simple request
        pool.urlopen('GET', '/')
        self.assertEqual(pool.pool.qsize(), MAXSIZE-1)

        # Check state without release
        pool.urlopen('GET', '/', preload_content=False)
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

        pool.urlopen('GET', '/')
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

        # Check state after read
        pool.urlopen('GET', '/').data
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

        pool.urlopen('GET', '/')
        self.assertEqual(pool.pool.qsize(), MAXSIZE-2)

    def test_release_conn_parameter(self):
        MAXSIZE = 5
        pool = HTTPConnectionPool(self.host, self.port, maxsize=MAXSIZE)
        self.assertEqual(pool.pool.qsize(), MAXSIZE)

        # Make request without releasing connection
        pool.request('GET', '/', release_conn=False, preload_content=False)
        self.assertEqual(pool.pool.qsize(), MAXSIZE-1)

    def test_dns_error(self):
        pool = HTTPConnectionPool('thishostdoesnotexist.invalid', self.port, timeout=0.001)
        self.assertRaises(MaxRetryError, pool.request, 'GET', '/test', retries=2)

    def test_source_address(self):
        for addr, is_ipv6 in VALID_SOURCE_ADDRESSES:
            if is_ipv6 and not HAS_IPV6_AND_DNS:
                warnings.warn(""No IPv6 support: skipping."",
                              NoIPv6Warning)
                continue
            pool = HTTPConnectionPool(self.host, self.port,
                                      source_address=addr, retries=False)
            self.addCleanup(pool.close)
            r = pool.request('GET', '/source_address')
            self.assertEqual(r.data, b(addr[0]))

    def test_source_address_error(self):
        for addr in INVALID_SOURCE_ADDRESSES:
            pool = HTTPConnectionPool(self.host, self.port, source_address=addr, retries=False)
            # FIXME: This assert flakes sometimes. Not sure why.
            self.assertRaises(NewConnectionError,
                              pool.request,
                              'GET', '/source_address?{0}'.format(addr))

    def test_stream_keepalive(self):
        x = 2

        for _ in range(x):
            response = self.pool.request(
                    'GET',
                    '/chunked',
                    headers={
                        'Connection': 'keep-alive',
                        },
                    preload_content=False,
                    retries=False,
                    )
            for chunk in response.stream():
                self.assertEqual(chunk, b'123')

        self.assertEqual(self.pool.num_connections, 1)
        self.assertEqual(self.pool.num_requests, x)

    def test_read_chunked_short_circuit(self):
        response = self.pool.request(
            'GET',
            '/chunked',
            preload_content=False
        )
        response.read()
        with pytest.raises(StopIteration):
            next(response.read_chunked())

    def test_read_chunked_on_closed_response(self):
        response = self.pool.request(
            'GET',
            '/chunked',
            preload_content=False
        )
        response.close()
        with pytest.raises(StopIteration):
            next(response.read_chunked())

    def test_chunked_gzip(self):
        response = self.pool.request(
                'GET',
                '/chunked_gzip',
                preload_content=False,
                decode_content=True,
                )

        self.assertEqual(b'123' * 4, response.read())

    def test_cleanup_on_connection_error(self):
        '''
        Test that connections are recycled to the pool on
        connection errors where no http response is received.
        '''
        poolsize = 3
        with HTTPConnectionPool(self.host, self.port, maxsize=poolsize, block=True) as http:
            self.assertEqual(http.pool.qsize(), poolsize)

            # force a connection error by supplying a non-existent
            # url. We won't get a response for this  and so the
            # conn won't be implicitly returned to the pool.
            self.assertRaises(MaxRetryError,
                              http.request,
                              'GET', '/redirect',
                              fields={'target': '/'}, release_conn=False, retries=0)

            r = http.request('GET', '/redirect',
                             fields={'target': '/'},
                             release_conn=False,
                             retries=1)
            r.release_conn()

            # the pool should still contain poolsize elements
            self.assertEqual(http.pool.qsize(), http.pool.maxsize)

    def test_mixed_case_hostname(self):
        pool = HTTPConnectionPool(""LoCaLhOsT"", self.port)
        self.addCleanup(pool.close)
        response = pool.request('GET', ""http://LoCaLhOsT:%d/"" % self.port)
        self.assertEqual(response.status, 200)


class TestRetry(HTTPDummyServerTestCase):
    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(self.pool.close)

    def test_max_retry(self):
        try:
            r = self.pool.request('GET', '/redirect',
                                  fields={'target': '/'},
                                  retries=0)
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

    def test_disabled_retry(self):
        """""" Disabled retries should disable redirect handling. """"""
        r = self.pool.request('GET', '/redirect',
                              fields={'target': '/'},
                              retries=False)
        self.assertEqual(r.status, 303)

        r = self.pool.request('GET', '/redirect',
                              fields={'target': '/'},
                              retries=Retry(redirect=False))
        self.assertEqual(r.status, 303)

        pool = HTTPConnectionPool('thishostdoesnotexist.invalid', self.port, timeout=0.001)
        self.assertRaises(NewConnectionError, pool.request, 'GET', '/test', retries=False)

    def test_read_retries(self):
        """""" Should retry for status codes in the whitelist """"""
        retry = Retry(read=1, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers={'test-name': 'test_read_retries'},
                                 retries=retry)
        self.assertEqual(resp.status, 200)

    def test_read_total_retries(self):
        """""" HTTP response w/ status code in the whitelist should be retried """"""
        headers = {'test-name': 'test_read_total_retries'}
        retry = Retry(total=1, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)

    def test_retries_wrong_whitelist(self):
        """"""HTTP response w/ status code not in whitelist shouldn't be retried""""""
        retry = Retry(total=1, status_forcelist=[202])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers={'test-name': 'test_wrong_whitelist'},
                                 retries=retry)
        self.assertEqual(resp.status, 418)

    def test_default_method_whitelist_retried(self):
        """""" urllib3 should retry methods in the default method whitelist """"""
        retry = Retry(total=1, status_forcelist=[418])
        resp = self.pool.request('OPTIONS', '/successful_retry',
                                 headers={'test-name': 'test_default_whitelist'},
                                 retries=retry)
        self.assertEqual(resp.status, 200)

    def test_retries_wrong_method_list(self):
        """"""Method not in our whitelist should not be retried, even if code matches""""""
        headers = {'test-name': 'test_wrong_method_whitelist'}
        retry = Retry(total=1, status_forcelist=[418],
                      method_whitelist=['POST'])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 418)

    def test_read_retries_unsuccessful(self):
        headers = {'test-name': 'test_read_retries_unsuccessful'}
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=1)
        self.assertEqual(resp.status, 418)

    def test_retry_reuse_safe(self):
        """""" It should be possible to reuse a Retry object across requests """"""
        headers = {'test-name': 'test_retry_safe'}
        retry = Retry(total=1, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)

    def test_retry_return_in_response(self):
        headers = {'test-name': 'test_retry_return_in_response'}
        retry = Retry(total=2, status_forcelist=[418])
        resp = self.pool.request('GET', '/successful_retry',
                                 headers=headers, retries=retry)
        self.assertEqual(resp.status, 200)
        self.assertEqual(resp.retries.total, 1)
        self.assertEqual(resp.retries.history,
                         (RequestHistory('GET', '/successful_retry', None, 418, None),))

    def test_retry_redirect_history(self):
        resp = self.pool.request('GET', '/redirect', fields={'target': '/'})
        self.assertEqual(resp.status, 200)
        self.assertEqual(resp.retries.history,
                         (RequestHistory('GET', '/redirect?target=%2F', None, 303, '/'),))

    def test_multi_redirect_history(self):
        r = self.pool.request('GET', '/multi_redirect',
                              fields={'redirect_codes': '303,302,200'},
                              redirect=False)
        self.assertEqual(r.status, 303)
        self.assertEqual(r.retries.history, tuple())

        r = self.pool.request('GET', '/multi_redirect', retries=10,
                              fields={'redirect_codes': '303,302,301,307,302,200'})
        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Done redirecting')

        expected = [(303, '/multi_redirect?redirect_codes=302,301,307,302,200'),
                    (302, '/multi_redirect?redirect_codes=301,307,302,200'),
                    (301, '/multi_redirect?redirect_codes=307,302,200'),
                    (307, '/multi_redirect?redirect_codes=302,200'),
                    (302, '/multi_redirect?redirect_codes=200')]
        actual = [(history.status, history.redirect_location) for history in r.retries.history]
        self.assertEqual(actual, expected)


class TestRetryAfter(HTTPDummyServerTestCase):
    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(self.pool.close)

    def test_retry_after(self):
        # Request twice in a second to get a 429 response.
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '429 Too Many Requests'},
                              retries=False)
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '429 Too Many Requests'},
                              retries=False)
        self.assertEqual(r.status, 429)

        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '429 Too Many Requests'},
                              retries=True)
        self.assertEqual(r.status, 200)

        # Request twice in a second to get a 503 response.
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '503 Service Unavailable'},
                              retries=False)
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '503 Service Unavailable'},
                              retries=False)
        self.assertEqual(r.status, 503)

        r = self.pool.request('GET', '/retry_after',
                              fields={'status': '503 Service Unavailable'},
                              retries=True)
        self.assertEqual(r.status, 200)

        # Ignore Retry-After header on status which is not defined in
        # Retry.RETRY_AFTER_STATUS_CODES.
        r = self.pool.request('GET', '/retry_after',
                              fields={'status': ""418 I'm a teapot""},
                              retries=True)
        self.assertEqual(r.status, 418)

    def test_redirect_after(self):
        r = self.pool.request('GET', '/redirect_after', retries=False)
        self.assertEqual(r.status, 303)

        t = time.time()
        r = self.pool.request('GET', '/redirect_after')
        self.assertEqual(r.status, 200)
        delta = time.time() - t
        self.assertGreaterEqual(delta, 1)

        t = time.time()
        timestamp = t + 2
        r = self.pool.request('GET', '/redirect_after?date=' + str(timestamp))
        self.assertEqual(r.status, 200)
        delta = time.time() - t
        self.assertGreaterEqual(delta, 1)

        # Retry-After is past
        t = time.time()
        timestamp = t - 1
        r = self.pool.request('GET', '/redirect_after?date=' + str(timestamp))
        delta = time.time() - t
        self.assertEqual(r.status, 200)
        self.assertLess(delta, 1)


class TestFileBodiesOnRetryOrRedirect(HTTPDummyServerTestCase):
    def setUp(self):
        self.pool = HTTPConnectionPool(self.host, self.port, timeout=0.1)
        self.addCleanup(self.pool.close)

    def test_retries_put_filehandle(self):
        """"""HTTP PUT retry with a file-like object should not timeout""""""
        retry = Retry(total=3, status_forcelist=[418])
        # httplib reads in 8k chunks; use a larger content length
        content_length = 65535
        data = b'A' * content_length
        uploaded_file = io.BytesIO(data)
        headers = {'test-name': 'test_retries_put_filehandle',
                   'Content-Length': str(content_length)}
        resp = self.pool.urlopen('PUT', '/successful_retry',
                                 headers=headers,
                                 retries=retry,
                                 body=uploaded_file,
                                 assert_same_host=False, redirect=False)
        self.assertEqual(resp.status, 200)

    def test_redirect_put_file(self):
        """"""PUT with file object should work with a redirection response""""""
        retry = Retry(total=3, status_forcelist=[418])
        # httplib reads in 8k chunks; use a larger content length
        content_length = 65535
        data = b'A' * content_length
        uploaded_file = io.BytesIO(data)
        headers = {'test-name': 'test_redirect_put_file',
                   'Content-Length': str(content_length)}
        url = '/redirect?target=/echo&status=307'
        resp = self.pool.urlopen('PUT', url,
                                 headers=headers,
                                 retries=retry,
                                 body=uploaded_file,
                                 assert_same_host=False, redirect=True)
        self.assertEqual(resp.status, 200)
        self.assertEqual(resp.data, data)

    def test_redirect_with_failed_tell(self):
        """"""Abort request if failed to get a position from tell()""""""
        class BadTellObject(io.BytesIO):

            def tell(self):
                raise IOError

        body = BadTellObject(b'the data')
        url = '/redirect?target=/successful_retry'
        # httplib uses fileno if Content-Length isn't supplied,
        # which is unsupported by BytesIO.
        headers = {'Content-Length': '8'}
        try:
            self.pool.urlopen('PUT', url, headers=headers, body=body)
            self.fail('PUT successful despite failed rewind.')
        except UnrewindableBodyError as e:
            self.assertIn('Unable to record file position for', str(e))


class TestRetryPoolSize(HTTPDummyServerTestCase):
    def setUp(self):
        retries = Retry(
            total=1,
            raise_on_status=False,
            status_forcelist=[404],
        )
        self.pool = HTTPConnectionPool(self.host, self.port, maxsize=10,
                                       retries=retries, block=True)
        self.addCleanup(self.pool.close)

    def test_pool_size_retry(self):
        self.pool.urlopen('GET', '/not_found', preload_content=False)
        assert self.pool.num_connections == 1


class TestRedirectPoolSize(HTTPDummyServerTestCase):
    def setUp(self):
        retries = Retry(
            total=1,
            raise_on_status=False,
            status_forcelist=[404],
            redirect=True,
        )
        self.pool = HTTPConnectionPool(self.host, self.port, maxsize=10,
                                       retries=retries, block=True)
        self.addCleanup(self.pool.close)

    def test_pool_size_redirect(self):
        self.pool.urlopen('GET', '/redirect', preload_content=False)
        assert self.pool.num_connections == 1


if __name__ == '__main__':
    unittest.main()",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .. VAR ( VAR, VAR, VAR, ) VAR ..VAR VAR VAR VAR VAR VAR ( VAR, VAR, ) VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR VAR, VAR VAR VAR VAR VAR VAR = VAR.VAR('VAR.VAR') VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR(VAR.VAR)) VAR = 0.001 VAR = 0.03 VAR VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=2)  VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR(VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR()   VAR(VAR) VAR.VAR()  VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR=VAR, VAR=1) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR.VAR, 1024) VAR: VAR.VAR(VAR) VAR.VAR() VAR VAR(VAR):  VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=6)  VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR.VAR(VAR) VAR.VAR()  VAR(VAR) VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR()   VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/', VAR=VAR) VAR = VAR.VAR() - VAR VAR.VAR()  VAR = ""VAR VAR VAR-VAR VAR VAR VAR VAR-VAR VAR"" VAR.VAR(VAR, VAR, VAR) VAR.VAR(VAR) VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR) VAR = VAR.VAR() - VAR VAR = ""VAR VAR VAR-VAR VAR VAR VAR VAR-VAR VAR"" VAR.VAR(VAR, VAR, VAR) VAR.VAR()    VAR(VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR) VAR.VAR()  VAR(VAR) VAR = VAR.VAR()  VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/', VAR=VAR) VAR.VAR()  VAR VAR(VAR): VAR = '/' VAR, VAR = VAR, 80 VAR = VAR(VAR=VAR)  VAR = VAR(VAR, VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', VAR)  VAR = VAR(VAR=0) VAR.VAR(VAR, VAR.VAR, 'VAR', VAR, VAR=VAR)  VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR(VAR, VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', VAR, VAR=VAR) VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', VAR, VAR=VAR) VAR VAR(VAR): VAR, VAR = VAR, 80 VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR(VAR, VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR = VAR(VAR, VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR VAR(VAR): VAR = VAR() VAR = VAR.VAR(VAR=VAR, VAR=2) VAR(VAR)  VAR = VAR(VAR=3, VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR() VAR(VAR) VAR.VAR()  VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR VAR(VAR): VAR.VAR(VAR=VAR(), VAR=0)  VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR?VAR=VAR') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR):  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 400, VAR.VAR) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 400, VAR.VAR) VAR VAR(VAR): VAR = ""VAR'VAR VAR VAR VAR VAR-VAR, VAR VAR VAR"" VAR = { 'VAR': 'VAR', 'VAR': 'VAR.VAR', 'VAR': VAR(VAR), 'VAR': ('VAR.VAR', VAR), } VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR = [ ('VAR', 'VAR'), ('VAR', 'VAR'), ]  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, VAR'VAR=VAR&VAR=VAR')  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR.VAR(VAR'VAR=""VAR""'), 2) VAR VAR(VAR): VAR = VAR'VAR' VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, VAR) VAR = [('VAR', 'VAR')] VAR.VAR(VAR, VAR.VAR.VAR, 'VAR', '/VAR', VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = VAR('VAR') VAR = VAR('\VAR\VAR\VAR.VAR') VAR = VAR('\VAR\VAR\VAR').VAR('VAR') VAR = VAR(VAR) VAR = { VAR('VAR'): VAR, VAR('VAR'): VAR, VAR('VAR'): VAR, VAR: (VAR, VAR), } VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR """"""   VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, 'VAR', '/') VAR = VAR.VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR.""""""   VAR = VAR(VAR.VAR, VAR.VAR, VAR=[ (VAR.VAR, VAR.VAR, 1) ]) VAR = VAR.VAR().VAR()  VAR = VAR.VAR(VAR.VAR, VAR.VAR) > 0 VAR.VAR(VAR) VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR.""""""   VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR = VAR.VAR().VAR() VAR = VAR.VAR(VAR.VAR, VAR.VAR) == 0 VAR.VAR(VAR) VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR.""""""   VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR)  VAR = VAR.VAR() VAR.VAR(VAR.VAR)  VAR.VAR += [(VAR.VAR, VAR.VAR, 1)] VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) > 0 VAR = VAR.VAR(VAR.VAR, VAR.VAR) > 0 VAR.VAR(VAR) VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR, VAR VAR """""" VAR = VAR() VAR = VAR(VAR.VAR, VAR) VAR: VAR.VAR('VAR', '/', VAR=VAR(VAR=3)) VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): VAR = VAR(VAR=3, VAR=5, VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/')  VAR.VAR('VAR', '/') VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR)  VAR.VAR('VAR', '/') VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR VAR(VAR):  VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR.VAR(VAR=VAR) VAR.VAR(VAR, 'VAR', '/') VAR.VAR.VAR()  VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR = VAR.VAR(VAR=VAR) VAR.VAR(VAR, 'VAR', '/') VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR('VAR.VAR', VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=5) VAR.VAR(""VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=1) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/VAR?VAR=0') VAR = VAR.VAR('VAR', '/VAR?VAR=0') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 2) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=1, VAR=2) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/VAR?VAR=1', VAR=0, VAR={ ""VAR"": ""VAR"", }) VAR.VAR(VAR.VAR, 1)      VAR = VAR.VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR)  VAR = VAR.VAR('VAR', '/VAR?VAR=0', VAR=0, VAR={ ""VAR"": ""VAR-VAR"", })   VAR = VAR.VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR)   VAR = VAR.VAR('VAR', '/VAR?VAR=1', VAR=0, VAR={ ""VAR"": ""VAR"", }) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR)  VAR = VAR.VAR('VAR', '/VAR?VAR=0') VAR VAR(VAR): VAR = {'VAR': 'VAR', 'VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR('VAR-8'), VAR(VAR)) VAR VAR(VAR): VAR = {'VAR': 'VAR', 'VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR = VAR.VAR.VAR(VAR'\VAR\VAR') VAR = VAR(VAR)[0] VAR = VAR.VAR(VAR'\VAR\VAR')   """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR, VAR VAR VAR(VAR): VAR VAR.VAR(VAR'--'): VAR VAR.VAR(VAR[VAR], VAR[VAR]) VAR VAR(VAR): VAR = {'VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=""VAR"", VAR=VAR) VAR = [VAR VAR VAR VAR VAR] VAR VAR == [ VAR""--VAR\VAR\VAR"", VAR'VAR-VAR: VAR-VAR; VAR=""VAR""\VAR\VAR', VAR'\VAR\VAR', VAR'VAR\VAR\VAR', VAR""--VAR--\VAR\VAR"" ] VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}) VAR.VAR(VAR.VAR.VAR('VAR-VAR'), 'VAR') VAR.VAR(VAR.VAR, VAR'VAR, VAR!') VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}) VAR.VAR(VAR.VAR.VAR('VAR-VAR'), 'VAR') VAR.VAR(VAR.VAR, VAR'VAR, VAR!') VAR VAR(VAR): VAR.VAR(VAR, VAR.VAR.VAR, 'VAR', '/VAR', VAR={'VAR-VAR': 'VAR-VAR'}) VAR.VAR(VAR, VAR.VAR.VAR, 'VAR', '/VAR', VAR={'VAR-VAR': 'VAR-VAR'}) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 3) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=16) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 3) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR) VAR = {'VAR': 'VAR'} VAR = VAR(VAR).VAR('VAR-8') VAR = VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR(5), VAR[:5]) VAR.VAR(VAR.VAR(), VAR[5:]) VAR VAR(VAR):   VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=1, VAR=2) VAR = 1024 * 2 VAR = 512 VAR = 'VAR' VAR = {'VAR': 'VAR' * VAR} VAR = VAR(VAR, VAR=VAR)[0] VAR = {'VAR': 'VAR' * VAR} VAR = VAR(VAR, VAR=VAR)[0] VAR = VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR(VAR), VAR[:VAR]) VAR: VAR = VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=VAR, VAR=0.001)   VAR.VAR(VAR.VAR(VAR), VAR[:VAR]) VAR.VAR(VAR.VAR(), VAR[VAR:]) VAR.VAR(VAR.VAR(), VAR[VAR:]) VAR.VAR(VAR.VAR, 2) VAR VAR: VAR.VAR(VAR.VAR(), VAR[VAR:]) VAR.VAR(VAR.VAR, 1) VAR.VAR(VAR.VAR, 1) VAR VAR(VAR): VAR = 5  VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR, 0) VAR.VAR(VAR.VAR.VAR(), VAR)  VAR.VAR.VAR() VAR.VAR(VAR.VAR.VAR(), VAR-1)  VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR.VAR(), VAR-1)  VAR.VAR('VAR', '/', VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR-2) VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR.VAR(), VAR-2)  VAR.VAR('VAR', '/').VAR VAR.VAR(VAR.VAR.VAR(), VAR-2) VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR.VAR(), VAR-2) VAR VAR(VAR): VAR = 5 VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR)  VAR.VAR('VAR', '/', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR-1) VAR VAR(VAR): VAR = VAR('VAR.VAR', VAR.VAR, VAR=0.001) VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR', VAR=2) VAR VAR(VAR): VAR VAR, VAR VAR VAR: VAR VAR VAR VAR VAR: VAR.VAR(""VAR VAR VAR: VAR."", VAR) VAR VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/VAR') VAR.VAR(VAR.VAR, VAR(VAR[0])) VAR VAR(VAR): VAR VAR VAR VAR: VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR)  VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR?{0}'.VAR(VAR)) VAR VAR(VAR): VAR = 2 VAR VAR VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR={ 'VAR': 'VAR-VAR', }, VAR=VAR, VAR=VAR, ) VAR VAR VAR VAR.VAR(): VAR.VAR(VAR, VAR'123') VAR.VAR(VAR.VAR.VAR, 1) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR=VAR ) VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR=VAR ) VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR.VAR( 'VAR', '/VAR', VAR=VAR, VAR=VAR, ) VAR.VAR(VAR'123' * 4, VAR.VAR()) VAR VAR(VAR): ''' VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ''' VAR = 3 VAR VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR VAR: VAR.VAR(VAR.VAR.VAR(), VAR)    VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR, VAR=0) VAR = VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR, VAR=1) VAR.VAR()  VAR.VAR(VAR.VAR.VAR(), VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR(""VAR"", VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', ""VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR: VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=0) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}, VAR=VAR(VAR=VAR)) VAR.VAR(VAR.VAR, 303) VAR = VAR('VAR.VAR', VAR.VAR, VAR=0.001) VAR.VAR(VAR, VAR.VAR, 'VAR', '/VAR', VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """""" VAR VAR VAR/ VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """"""VAR VAR VAR/ VAR VAR VAR VAR VAR VAR'VAR VAR VAR"""""" VAR = VAR(VAR=1, VAR=[202]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR"""""" VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=1, VAR=[418], VAR=['VAR']) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=1) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=1, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR=2, VAR=[418]) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR.VAR, 1) VAR.VAR(VAR.VAR.VAR, (VAR('VAR', '/VAR', VAR, 418, VAR),)) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '/'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR.VAR, (VAR('VAR', '/VAR?VAR=%2F', VAR, 303, '/'),)) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '303,302,200'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR.VAR(VAR.VAR.VAR, VAR()) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=10, VAR={'VAR': '303,302,301,307,302,200'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR') VAR = [(303, '/VAR?VAR=302,301,307,302,200'), (302, '/VAR?VAR=301,307,302,200'), (301, '/VAR?VAR=307,302,200'), (307, '/VAR?VAR=302,200'), (302, '/VAR?VAR=200')] VAR = [(VAR.VAR, VAR.VAR) VAR VAR VAR VAR.VAR.VAR] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR):  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '429 VAR VAR VAR'}, VAR=VAR) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '429 VAR VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 429) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '429 VAR VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200)  VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '503 VAR VAR'}, VAR=VAR) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '503 VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 503) VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': '503 VAR VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 200)   VAR = VAR.VAR.VAR('VAR', '/VAR', VAR={'VAR': ""418 VAR'VAR VAR VAR""}, VAR=VAR) VAR.VAR(VAR.VAR, 418) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR() VAR = VAR.VAR.VAR('VAR', '/VAR') VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR() - VAR VAR.VAR(VAR, 1) VAR = VAR.VAR() VAR = VAR + 2 VAR = VAR.VAR.VAR('VAR', '/VAR?VAR=' + VAR(VAR)) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR() - VAR VAR.VAR(VAR, 1)  VAR = VAR.VAR() VAR = VAR - 1 VAR = VAR.VAR.VAR('VAR', '/VAR?VAR=' + VAR(VAR)) VAR = VAR.VAR() - VAR VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR, 1) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.1) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR"""""" VAR = VAR(VAR=3, VAR=[418])  VAR = 65535 VAR = VAR'VAR' * VAR VAR = VAR.VAR(VAR) VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': VAR(VAR)} VAR = VAR.VAR.VAR('VAR', '/VAR', VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR = VAR(VAR=3, VAR=[418])  VAR = 65535 VAR = VAR'VAR' * VAR VAR = VAR.VAR(VAR) VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': VAR(VAR)} VAR = '/VAR?VAR=/VAR&VAR=307' VAR = VAR.VAR.VAR('VAR', VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR()"""""" VAR VAR(VAR.VAR): VAR VAR(VAR): VAR VAR VAR = VAR(VAR'VAR VAR') VAR = '/VAR?VAR=/VAR'   VAR = {'VAR-VAR': '8'} VAR: VAR.VAR.VAR('VAR', VAR, VAR=VAR, VAR=VAR) VAR.VAR('VAR VAR VAR VAR VAR.') VAR VAR VAR VAR: VAR.VAR('VAR VAR VAR VAR VAR VAR', VAR(VAR)) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR( VAR=1, VAR=VAR, VAR=[404], ) VAR.VAR = VAR(VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR.VAR.VAR == 1 VAR VAR(VAR): VAR VAR(VAR): VAR = VAR( VAR=1, VAR=VAR, VAR=[404], VAR=VAR, ) VAR.VAR = VAR(VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR.VAR.VAR == 1 VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/with_dummyserver/test_https.py,"import datetime
import json
import logging
import ssl
import sys
import unittest
import warnings

import mock
import pytest

from dummyserver.testcase import (
    HTTPSDummyServerTestCase, IPV6HTTPSDummyServerTestCase
)
from dummyserver.server import (DEFAULT_CA, DEFAULT_CA_BAD, DEFAULT_CERTS,
                                DEFAULT_CLIENT_CERTS,
                                DEFAULT_CLIENT_NO_INTERMEDIATE_CERTS,
                                NO_SAN_CERTS, NO_SAN_CA, DEFAULT_CA_DIR,
                                IPV6_ADDR_CERTS, IPV6_ADDR_CA, HAS_IPV6,
                                IP_SAN_CERTS, IPV6_SAN_CERTS, IPV6_SAN_CA,
                                PASSWORD_CLIENT_KEYFILE)

from test import (
    onlyPy279OrNewer,
    notSecureTransport,
    notOpenSSL098,
    requires_network,
    requires_ssl_context_keyfile_password,
    fails_on_travis_gce,
    requiresTLSv1,
    requiresTLSv1_1,
    requiresTLSv1_2,
    requiresTLSv1_3,
    TARPIT_HOST,
)
from urllib3 import HTTPSConnectionPool
from urllib3.connection import (
    VerifiedHTTPSConnection,
    RECENT_DATE,
)
from urllib3.exceptions import (
    SSLError,
    ConnectTimeoutError,
    InsecureRequestWarning,
    SystemTimeWarning,
    InsecurePlatformWarning,
    MaxRetryError,
    ProtocolError,
)
from urllib3.packages import six
from urllib3.util.timeout import Timeout
import urllib3.util as util


ResourceWarning = getattr(
        six.moves.builtins,
        'ResourceWarning', type('ResourceWarning', (), {}))


log = logging.getLogger('urllib3.connectionpool')
log.setLevel(logging.NOTSET)
log.addHandler(logging.StreamHandler(sys.stdout))


TLSv1_CERTS = DEFAULT_CERTS.copy()
TLSv1_CERTS[""ssl_version""] = getattr(ssl, ""PROTOCOL_TLSv1"", None)

TLSv1_1_CERTS = DEFAULT_CERTS.copy()
TLSv1_1_CERTS[""ssl_version""] = getattr(ssl, ""PROTOCOL_TLSv1_1"", None)

TLSv1_2_CERTS = DEFAULT_CERTS.copy()
TLSv1_2_CERTS[""ssl_version""] = getattr(ssl, ""PROTOCOL_TLSv1_2"", None)


class TestHTTPS(HTTPSDummyServerTestCase):
    tls_protocol_name = None

    def setUp(self):
        self._pool = HTTPSConnectionPool(self.host, self.port, ca_certs=DEFAULT_CA)
        self.addCleanup(self._pool.close)

    def test_simple(self):
        r = self._pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)

    @fails_on_travis_gce
    def test_dotted_fqdn(self):
        pool = HTTPSConnectionPool(self.host + '.', self.port, ca_certs=DEFAULT_CA)
        r = pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)

    def test_client_intermediate(self):
        client_cert, client_key = (
            DEFAULT_CLIENT_CERTS['certfile'],
            DEFAULT_CLIENT_CERTS['keyfile'],
        )
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         key_file=client_key,
                                         cert_file=client_cert,
                                         ca_certs=DEFAULT_CA)
        r = https_pool.request('GET', '/certificate')
        subject = json.loads(r.data.decode('utf-8'))
        assert subject['organizationalUnitName'].startswith(
            'Testing server cert')

    def test_client_no_intermediate(self):
        client_cert, client_key = (
            DEFAULT_CLIENT_NO_INTERMEDIATE_CERTS['certfile'],
            DEFAULT_CLIENT_NO_INTERMEDIATE_CERTS['keyfile']
        )
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_file=client_cert,
                                         key_file=client_key,
                                         ca_certs=DEFAULT_CA)
        try:
            https_pool.request('GET', '/certificate', retries=False)
        except SSLError as e:
            if not ('alert unknown ca' in str(e) or
                    'invalid certificate chain' in str(e) or
                    'unknown Cert Authority' in str(e) or
                    # https://github.com/urllib3/urllib3/issues/1422
                    'connection closed via error' in str(e) or
                    'WSAECONNRESET' in str(e)):
                raise
        except ProtocolError as e:
            # https://github.com/urllib3/urllib3/issues/1422
            if not ('An existing connection was forcibly closed by the remote host' in str(e)):
                raise

    @requires_ssl_context_keyfile_password
    def test_client_key_password(self):
        client_cert, client_key = (
            DEFAULT_CLIENT_CERTS['certfile'],
            PASSWORD_CLIENT_KEYFILE,
        )
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         ca_certs=DEFAULT_CA,
                                         key_file=client_key,
                                         cert_file=client_cert,
                                         key_password=""letmein"")
        r = https_pool.request('GET', '/certificate')
        subject = json.loads(r.data.decode('utf-8'))
        assert subject['organizationalUnitName'].startswith(
            'Testing server cert')

    @requires_ssl_context_keyfile_password
    def test_client_encrypted_key_requires_password(self):
        client_cert, client_key = (
            DEFAULT_CLIENT_CERTS['certfile'],
            PASSWORD_CLIENT_KEYFILE,
        )
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         key_file=client_key,
                                         cert_file=client_cert,
                                         key_password=None)

        with pytest.raises(MaxRetryError) as e:
            https_pool.request('GET', '/certificate')

        assert 'password is required' in str(e.value)
        assert isinstance(e.value.reason, SSLError)

    def test_verified(self):
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)

            # Modern versions of Python, or systems using PyOpenSSL, don't
            # emit warnings.
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                self.assertFalse(warn.called, warn.call_args_list)
            else:
                self.assertTrue(warn.called)
                if util.HAS_SNI:
                    call = warn.call_args_list[0]
                else:
                    call = warn.call_args_list[1]
                error = call[0][1]
                self.assertEqual(error, InsecurePlatformWarning)

    def test_verified_with_context(self):
        ctx = util.ssl_.create_urllib3_context(cert_reqs=ssl.CERT_REQUIRED)
        ctx.load_verify_locations(cafile=DEFAULT_CA)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         ssl_context=ctx)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)

            # Modern versions of Python, or systems using PyOpenSSL, don't
            # emit warnings.
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                self.assertFalse(warn.called, warn.call_args_list)
            else:
                self.assertTrue(warn.called)
                if util.HAS_SNI:
                    call = warn.call_args_list[0]
                else:
                    call = warn.call_args_list[1]
                error = call[0][1]
                self.assertEqual(error, InsecurePlatformWarning)

    def test_context_combines_with_ca_certs(self):
        ctx = util.ssl_.create_urllib3_context(cert_reqs=ssl.CERT_REQUIRED)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         ca_certs=DEFAULT_CA,
                                         ssl_context=ctx)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)

            # Modern versions of Python, or systems using PyOpenSSL, don't
            # emit warnings.
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                self.assertFalse(warn.called, warn.call_args_list)
            else:
                self.assertTrue(warn.called)
                if util.HAS_SNI:
                    call = warn.call_args_list[0]
                else:
                    call = warn.call_args_list[1]
                error = call[0][1]
                self.assertEqual(error, InsecurePlatformWarning)

    @onlyPy279OrNewer
    @notSecureTransport  # SecureTransport does not support cert directories
    @notOpenSSL098  # OpenSSL 0.9.8 does not support cert directories
    def test_ca_dir_verified(self):
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_cert_dir=DEFAULT_CA_DIR)
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)

        with mock.patch('warnings.warn') as warn:
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertFalse(warn.called, warn.call_args_list)

    def test_invalid_common_name(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        try:
            https_pool.request('GET', '/')
            self.fail(""Didn't raise SSL invalid common name"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertTrue(
                ""doesn't match"" in str(e.reason) or
                ""certificate verify failed"" in str(e.reason)
            )

    def test_verified_with_bad_ca_certs(self):
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(https_pool.close)

        try:
            https_pool.request('GET', '/')
            self.fail(""Didn't raise SSL error with bad CA certs"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertIn('certificate verify failed', str(e.reason),
                          ""Expected 'certificate verify failed',""
                          ""instead got: %r"" % e.reason)

    def test_verified_without_ca_certs(self):
        # default is cert_reqs=None which is ssl.CERT_NONE
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)

        try:
            https_pool.request('GET', '/')
            self.fail(""Didn't raise SSL error with no CA certs when""
                      ""CERT_REQUIRED is set"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            # there is a different error message depending on whether or
            # not pyopenssl is injected
            self.assertTrue('No root certificates specified' in str(e.reason) or
                            'certificate verify failed' in str(e.reason) or
                            'invalid certificate chain' in str(e.reason),
                            ""Expected 'No root certificates specified',  ""
                            ""'certificate verify failed', or ""
                            ""'invalid certificate chain', ""
                            ""instead got: %r"" % e.reason)

    def test_no_ssl(self):
        pool = HTTPSConnectionPool(self.host, self.port)
        pool.ConnectionCls = None
        self.addCleanup(pool.close)
        self.assertRaises(SSLError, pool._new_conn)
        with self.assertRaises(MaxRetryError) as cm:
            pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)

    def test_unverified_ssl(self):
        """""" Test that bare HTTPSConnection can connect, make requests """"""
        pool = HTTPSConnectionPool(self.host, self.port, cert_reqs=ssl.CERT_NONE)
        self.addCleanup(pool.close)

        with mock.patch('warnings.warn') as warn:
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertTrue(warn.called)

            # Modern versions of Python, or systems using PyOpenSSL, only emit
            # the unverified warning. Older systems may also emit other
            # warnings, which we want to ignore here.
            calls = warn.call_args_list
            self.assertIn(InsecureRequestWarning, [x[0][1] for x in calls])

    def test_ssl_unverified_with_ca_certs(self):
        pool = HTTPSConnectionPool(self.host, self.port,
                                   cert_reqs='CERT_NONE',
                                   ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(pool.close)

        with mock.patch('warnings.warn') as warn:
            r = pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertTrue(warn.called)

            # Modern versions of Python, or systems using PyOpenSSL, only emit
            # the unverified warning. Older systems may also emit other
            # warnings, which we want to ignore here.
            calls = warn.call_args_list
            if sys.version_info >= (2, 7, 9) or util.IS_PYOPENSSL \
                    or util.IS_SECURETRANSPORT:
                category = calls[0][0][1]
            elif util.HAS_SNI:
                category = calls[1][0][1]
            else:
                category = calls[2][0][1]
            self.assertEqual(category, InsecureRequestWarning)

    def test_assert_hostname_false(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_hostname = False
        https_pool.request('GET', '/')

    def test_assert_specific_hostname(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_hostname = 'localhost'
        https_pool.request('GET', '/')

    def test_server_hostname(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA,
                                         server_hostname='localhost')
        self.addCleanup(https_pool.close)

        conn = https_pool._new_conn()
        conn.request('GET', '/')

        # Assert the wrapping socket is using the passed-through SNI name.
        # pyopenssl doesn't let you pull the server_hostname back off the
        # socket, so only add this assertion if the attribute is there (i.e.
        # the python ssl module).
        if hasattr(conn.sock, 'server_hostname'):
            self.assertEqual(conn.sock.server_hostname, ""localhost"")

    def test_assert_fingerprint_md5(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = 'F2:06:5A:42:10:3F:45:1C:17:FE:E6:' \
                                        '07:1E:8A:86:E5'

        https_pool.request('GET', '/')

    def test_assert_fingerprint_sha1(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'
        https_pool.request('GET', '/')

    def test_assert_fingerprint_sha256(self):
        https_pool = HTTPSConnectionPool('localhost', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = ('C5:4D:0B:83:84:89:2E:AE:B4:58:BB:12:'
                                         'F7:A6:C4:76:05:03:88:D8:57:65:51:F3:'
                                         '1E:60:B0:8B:70:18:64:E6')
        https_pool.request('GET', '/')

    def test_assert_invalid_fingerprint(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = 'AA:AA:AA:AA:AA:AAAA:AA:AAAA:AA:' \
                                        'AA:AA:AA:AA:AA:AA:AA:AA:AA'

        def _test_request(pool):
            with self.assertRaises(MaxRetryError) as cm:
                pool.request('GET', '/', retries=0)
            self.assertIsInstance(cm.exception.reason, SSLError)

        _test_request(https_pool)
        https_pool._get_conn()

        # Uneven length
        https_pool.assert_fingerprint = 'AA:A'
        _test_request(https_pool)
        https_pool._get_conn()

        # Invalid length
        https_pool.assert_fingerprint = 'AA'
        _test_request(https_pool)

    def test_verify_none_and_bad_fingerprint(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_NONE',
                                         ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = 'AA:AA:AA:AA:AA:AAAA:AA:AAAA:AA:' \
                                        'AA:AA:AA:AA:AA:AA:AA:AA:AA'
        with self.assertRaises(MaxRetryError) as cm:
            https_pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)

    def test_verify_none_and_good_fingerprint(self):
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_NONE',
                                         ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'
        https_pool.request('GET', '/')

    @notSecureTransport
    def test_good_fingerprint_and_hostname_mismatch(self):
        # This test doesn't run with SecureTransport because we don't turn off
        # hostname validation without turning off all validation, which this
        # test doesn't do (deliberately). We should revisit this if we make
        # new decisions.
        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)

        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'
        https_pool.request('GET', '/')

    @requires_network
    def test_https_timeout(self):
        timeout = Timeout(connect=0.001)
        https_pool = HTTPSConnectionPool(TARPIT_HOST, self.port,
                                         timeout=timeout, retries=False,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)

        timeout = Timeout(total=None, connect=0.001)
        https_pool = HTTPSConnectionPool(TARPIT_HOST, self.port,
                                         timeout=timeout, retries=False,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/')

        timeout = Timeout(read=0.01)
        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         timeout=timeout, retries=False,
                                         cert_reqs='CERT_REQUIRED')
        self.addCleanup(https_pool.close)
        https_pool.ca_certs = DEFAULT_CA
        https_pool.assert_fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:' \
                                        'BF:93:CF:F9:71:CC:07:7D:0A'

        timeout = Timeout(total=None)
        https_pool = HTTPSConnectionPool(self.host, self.port, timeout=timeout,
                                         cert_reqs='CERT_NONE')
        self.addCleanup(https_pool.close)
        https_pool.request('GET', '/')

    def test_tunnel(self):
        """""" test the _tunnel behavior """"""
        timeout = Timeout(total=None)
        https_pool = HTTPSConnectionPool(self.host, self.port, timeout=timeout,
                                         cert_reqs='CERT_NONE')
        self.addCleanup(https_pool.close)
        conn = https_pool._new_conn()
        self.addCleanup(conn.close)
        conn.set_tunnel(self.host, self.port)
        conn._tunnel = mock.Mock()
        https_pool._make_request(conn, 'GET', '/')
        conn._tunnel.assert_called_once_with()

    @requires_network
    def test_enhanced_timeout(self):
        def new_pool(timeout, cert_reqs='CERT_REQUIRED'):
            https_pool = HTTPSConnectionPool(TARPIT_HOST, self.port,
                                             timeout=timeout,
                                             retries=False,
                                             cert_reqs=cert_reqs)
            self.addCleanup(https_pool.close)
            return https_pool

        https_pool = new_pool(Timeout(connect=0.001))
        conn = https_pool._new_conn()
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/')
        self.assertRaises(ConnectTimeoutError, https_pool._make_request, conn,
                          'GET', '/')

        https_pool = new_pool(Timeout(connect=5))
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/',
                          timeout=Timeout(connect=0.001))

        t = Timeout(total=None)
        https_pool = new_pool(t)
        conn = https_pool._new_conn()
        self.assertRaises(ConnectTimeoutError, https_pool.request, 'GET', '/',
                          timeout=Timeout(total=None, connect=0.001))

    def test_enhanced_ssl_connection(self):
        fingerprint = '92:81:FE:85:F7:0C:26:60:EC:D6:B3:BF:93:CF:F9:71:CC:07:7D:0A'

        https_pool = HTTPSConnectionPool(self.host, self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA,
                                         assert_fingerprint=fingerprint)
        self.addCleanup(https_pool.close)

        r = https_pool.request('GET', '/')
        assert r.status == 200

    @onlyPy279OrNewer
    def test_ssl_correct_system_time(self):
        self._pool.cert_reqs = 'CERT_REQUIRED'
        self._pool.ca_certs = DEFAULT_CA

        w = self._request_without_resource_warnings('GET', '/')
        self.assertEqual([], w)

    @onlyPy279OrNewer
    def test_ssl_wrong_system_time(self):
        self._pool.cert_reqs = 'CERT_REQUIRED'
        self._pool.ca_certs = DEFAULT_CA
        with mock.patch('urllib3.connection.datetime') as mock_date:
            mock_date.date.today.return_value = datetime.date(1970, 1, 1)

            w = self._request_without_resource_warnings('GET', '/')

            self.assertEqual(len(w), 1)
            warning = w[0]

            self.assertEqual(SystemTimeWarning, warning.category)
            self.assertIn(str(RECENT_DATE), warning.message.args[0])

    def _request_without_resource_warnings(self, method, url):
        with warnings.catch_warnings(record=True) as w:
            warnings.simplefilter('always')
            self._pool.request(method, url)

        return [x for x in w if not isinstance(x.message, ResourceWarning)]

    def test_set_ssl_version_to_tls_version(self):
        if self.tls_protocol_name is None:
            pytest.skip(""Skipping base test class"")

        self._pool.ssl_version = self.certs['ssl_version']
        r = self._pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)

    def test_set_cert_default_cert_required(self):
        conn = VerifiedHTTPSConnection(self.host, self.port)
        conn.set_cert()
        self.assertEqual(conn.cert_reqs, ssl.CERT_REQUIRED)

    def test_tls_protocol_name_of_socket(self):
        if self.tls_protocol_name is None:
            pytest.skip(""Skipping base test class"")

        conn = self._pool._get_conn()
        conn.connect()

        if not hasattr(conn.sock, 'version'):
            pytest.skip('SSLSocket.version() not available')

        self.assertEqual(conn.sock.version(), self.tls_protocol_name)


@requiresTLSv1()
class TestHTTPS_TLSv1(TestHTTPS):
    tls_protocol_name = 'TLSv1'
    certs = TLSv1_CERTS


@requiresTLSv1_1()
class TestHTTPS_TLSv1_1(TestHTTPS):
    tls_protocol_name = 'TLSv1.1'
    certs = TLSv1_1_CERTS


@requiresTLSv1_2()
class TestHTTPS_TLSv1_2(TestHTTPS):
    tls_protocol_name = 'TLSv1.2'
    certs = TLSv1_2_CERTS


@requiresTLSv1_3()
class TestHTTPS_TLSv1_3(TestHTTPS):
    tls_protocol_name = 'TLSv1.3'


class TestHTTPS_NoSAN(HTTPSDummyServerTestCase):
    certs = NO_SAN_CERTS

    def test_warning_for_certs_without_a_san(self):
        """"""Ensure that a warning is raised when the cert from the server has
        no Subject Alternative Name.""""""
        with mock.patch('warnings.warn') as warn:
            https_pool = HTTPSConnectionPool(self.host, self.port,
                                             cert_reqs='CERT_REQUIRED',
                                             ca_certs=NO_SAN_CA)
            self.addCleanup(https_pool.close)
            r = https_pool.request('GET', '/')
            self.assertEqual(r.status, 200)
            self.assertTrue(warn.called)


class TestHTTPS_IPSAN(HTTPSDummyServerTestCase):
    certs = IP_SAN_CERTS

    def test_can_validate_ip_san(self):
        """"""Ensure that urllib3 can validate SANs with IP addresses in them.""""""
        try:
            import ipaddress  # noqa: F401
        except ImportError:
            pytest.skip(""Only runs on systems with an ipaddress module"")

        https_pool = HTTPSConnectionPool('127.0.0.1', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=DEFAULT_CA)
        self.addCleanup(https_pool.close)
        r = https_pool.request('GET', '/')
        self.assertEqual(r.status, 200)


class TestHTTPS_IPv6Addr(IPV6HTTPSDummyServerTestCase):
    certs = IPV6_ADDR_CERTS

    @pytest.mark.skipif(not HAS_IPV6, reason='Only runs on IPv6 systems')
    def test_strip_square_brackets_before_validating(self):
        """"""Test that the fix for #760 works.""""""
        https_pool = HTTPSConnectionPool('[::1]', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=IPV6_ADDR_CA)
        self.addCleanup(https_pool.close)
        r = https_pool.request('GET', '/')
        self.assertEqual(r.status, 200)


class TestHTTPS_IPV6SAN(IPV6HTTPSDummyServerTestCase):
    certs = IPV6_SAN_CERTS

    def test_can_validate_ipv6_san(self):
        """"""Ensure that urllib3 can validate SANs with IPv6 addresses in them.""""""
        try:
            import ipaddress  # noqa: F401
        except ImportError:
            pytest.skip(""Only runs on systems with an ipaddress module"")

        https_pool = HTTPSConnectionPool('[::1]', self.port,
                                         cert_reqs='CERT_REQUIRED',
                                         ca_certs=IPV6_SAN_CA)
        self.addCleanup(https_pool.close)
        r = https_pool.request('GET', '/')
        self.assertEqual(r.status, 200)


if __name__ == '__main__':
    unittest.main()",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR ) VAR VAR.VAR VAR (VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR) VAR VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, ) VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR = VAR( VAR.VAR.VAR, 'VAR', VAR('VAR', (), {})) VAR = VAR.VAR('VAR.VAR') VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR(VAR.VAR)) VAR = VAR.VAR() VAR[""VAR""] = VAR(VAR, ""VAR"", VAR) VAR = VAR.VAR() VAR[""VAR""] = VAR(VAR, ""VAR"", VAR) VAR = VAR.VAR() VAR[""VAR""] = VAR(VAR, ""VAR"", VAR) VAR VAR(VAR): VAR = VAR VAR VAR(VAR): VAR.VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) @VAR VAR VAR(VAR): VAR = VAR(VAR.VAR + '.', VAR.VAR, VAR=VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR, VAR = ( VAR['VAR'], VAR['VAR'], ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR('VAR', '/VAR') VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR VAR['VAR'].VAR( 'VAR VAR VAR') VAR VAR(VAR): VAR, VAR = ( VAR['VAR'], VAR['VAR'] ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR: VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR VAR VAR: VAR VAR ('VAR VAR VAR' VAR VAR(VAR) VAR 'VAR VAR VAR' VAR VAR(VAR) VAR 'VAR VAR VAR' VAR VAR(VAR) VAR  'VAR VAR VAR VAR' VAR VAR(VAR) VAR 'VAR' VAR VAR(VAR)): VAR VAR VAR VAR VAR:  VAR VAR ('VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR' VAR VAR(VAR)): VAR @VAR VAR VAR(VAR): VAR, VAR = ( VAR['VAR'], VAR, ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=""VAR"") VAR = VAR.VAR('VAR', '/VAR') VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR VAR['VAR'].VAR( 'VAR VAR VAR') @VAR VAR VAR(VAR): VAR, VAR = ( VAR['VAR'], VAR, ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/VAR') VAR 'VAR VAR VAR' VAR VAR(VAR.VAR) VAR VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200)   VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR: VAR.VAR(VAR.VAR) VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR(VAR=VAR.VAR) VAR.VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200)   VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR: VAR.VAR(VAR.VAR) VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR = VAR.VAR.VAR(VAR=VAR.VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200)   VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR.VAR(VAR.VAR, VAR.VAR) VAR: VAR.VAR(VAR.VAR) VAR VAR.VAR: VAR = VAR.VAR[0] VAR: VAR = VAR.VAR[1] VAR = VAR[0][1] VAR.VAR(VAR, VAR) @VAR @VAR  @VAR  VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR( ""VAR'VAR VAR"" VAR VAR(VAR.VAR) VAR ""VAR VAR VAR"" VAR VAR(VAR.VAR) ) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR('VAR VAR VAR', VAR(VAR.VAR), ""VAR 'VAR VAR VAR',"" ""VAR VAR: %VAR"" % VAR.VAR) VAR VAR(VAR):  VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR"" ""VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR)   VAR.VAR('VAR VAR VAR VAR' VAR VAR(VAR.VAR) VAR 'VAR VAR VAR' VAR VAR(VAR.VAR) VAR 'VAR VAR VAR' VAR VAR(VAR.VAR), ""VAR 'VAR VAR VAR VAR', "" ""'VAR VAR VAR', VAR "" ""'VAR VAR VAR', "" ""VAR VAR: %VAR"" % VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR """""" VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR.VAR) VAR.VAR(VAR.VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR)    VAR = VAR.VAR VAR.VAR(VAR, [VAR[0][1] VAR VAR VAR VAR]) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR)    VAR = VAR.VAR VAR VAR.VAR >= (2, 7, 9) VAR VAR.VAR \ VAR VAR.VAR: VAR = VAR[0][0][1] VAR VAR.VAR: VAR = VAR[1][0][1] VAR: VAR = VAR[2][0][1] VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = VAR VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR' VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR('VAR', '/')     VAR VAR(VAR.VAR, 'VAR'): VAR.VAR(VAR.VAR.VAR, ""VAR"") VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR:06:5A:42:10:3F:45:1C:17:VAR:VAR:' \ '07:1E:8A:86:VAR' VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('VAR', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = ('VAR:4D:0B:83:84:89:2E:VAR:VAR:58:VAR:12:' 'VAR:VAR:VAR:76:05:03:88:VAR:57:65:51:VAR:' '1E:60:VAR:8B:70:18:64:VAR') VAR.VAR('VAR', '/') VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:' \ 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR' VAR VAR(VAR): VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR(VAR) VAR.VAR()  VAR.VAR = 'VAR:VAR' VAR(VAR) VAR.VAR()  VAR.VAR = 'VAR' VAR(VAR) VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:' \ 'VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR:VAR' VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR.VAR('VAR', '/') @VAR VAR VAR(VAR):     VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR.VAR('VAR', '/') @VAR VAR VAR(VAR): VAR = VAR(VAR=0.001) VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR(VAR=VAR, VAR=0.001) VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR = VAR(VAR=0.01) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR.VAR = VAR VAR.VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:' \ 'VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR VAR(VAR): """""" VAR VAR VAR VAR """""" VAR = VAR(VAR=VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR = VAR.VAR() VAR.VAR(VAR, 'VAR', '/') VAR.VAR.VAR() @VAR VAR VAR(VAR): VAR VAR(VAR, VAR='VAR'): VAR = VAR(VAR, VAR.VAR, VAR=VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR VAR = VAR(VAR(VAR=0.001)) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR.VAR(VAR, VAR.VAR, VAR, 'VAR', '/') VAR = VAR(VAR(VAR=5)) VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR(VAR=0.001)) VAR = VAR(VAR=VAR) VAR = VAR(VAR) VAR = VAR.VAR() VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR(VAR=VAR, VAR=0.001)) VAR VAR(VAR): VAR = '92:81:VAR:85:VAR:0C:26:60:VAR:VAR:VAR:VAR:93:VAR:VAR:71:VAR:07:7D:0A' VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR VAR.VAR == 200 @VAR VAR VAR(VAR): VAR.VAR.VAR = 'VAR' VAR.VAR.VAR = VAR VAR = VAR.VAR('VAR', '/') VAR.VAR([], VAR) @VAR VAR VAR(VAR): VAR.VAR.VAR = 'VAR' VAR.VAR.VAR = VAR VAR VAR.VAR('VAR.VAR.VAR') VAR VAR: VAR.VAR.VAR.VAR = VAR.VAR(1970, 1, 1) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR(VAR), 1) VAR = VAR[0] VAR.VAR(VAR, VAR.VAR) VAR.VAR(VAR(VAR), VAR.VAR.VAR[0]) VAR VAR(VAR, VAR, VAR): VAR VAR.VAR(VAR=VAR) VAR VAR: VAR.VAR('VAR') VAR.VAR.VAR(VAR, VAR) VAR [VAR VAR VAR VAR VAR VAR VAR VAR(VAR.VAR, VAR)] VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR.VAR(""VAR VAR VAR VAR"") VAR.VAR.VAR = VAR.VAR['VAR'] VAR = VAR.VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR() VAR.VAR(VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR.VAR(""VAR VAR VAR VAR"") VAR = VAR.VAR.VAR() VAR.VAR() VAR VAR VAR(VAR.VAR, 'VAR'): VAR.VAR('VAR.VAR() VAR VAR') VAR.VAR(VAR.VAR.VAR(), VAR.VAR) @VAR() VAR VAR(VAR): VAR = 'VAR' VAR = VAR @VAR() VAR VAR(VAR): VAR = 'VAR.1' VAR = VAR @VAR() VAR VAR(VAR): VAR = 'VAR.2' VAR = VAR @VAR() VAR VAR(VAR): VAR = 'VAR.3' VAR VAR(VAR): VAR = VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR.VAR('VAR.VAR') VAR VAR: VAR = VAR(VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR = VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR: VAR VAR  VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR"") VAR = VAR('127.0.0.1', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR @VAR.VAR.VAR(VAR VAR, VAR='VAR VAR VAR VAR VAR') VAR VAR(VAR): """"""VAR VAR VAR VAR VAR  VAR = VAR('[::1]', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR: VAR VAR  VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR"") VAR = VAR('[::1]', VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200) VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/with_dummyserver/test_no_ssl.py,"""""""
Test connections without the builtin ssl module

Note: Import urllib3 inside the test functions to get the importblocker to work
""""""
from ..test_no_ssl import TestWithoutSSL

from dummyserver.testcase import (
        HTTPDummyServerTestCase, HTTPSDummyServerTestCase)

import urllib3


class TestHTTPWithoutSSL(HTTPDummyServerTestCase, TestWithoutSSL):
    def test_simple(self):
        pool = urllib3.HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/')
        self.assertEqual(r.status, 200, r.data)


class TestHTTPSWithoutSSL(HTTPSDummyServerTestCase, TestWithoutSSL):
    def test_simple(self):
        pool = urllib3.HTTPSConnectionPool(self.host, self.port, cert_reqs=""NONE"")
        self.addCleanup(pool.close)
        try:
            pool.request('GET', '/')
        except urllib3.exceptions.SSLError as e:
            self.assertIn('SSL module is not available', str(e))",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,""""""" VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR ..VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR) VAR VAR VAR VAR(VAR, VAR): VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR.VAR, 200, VAR.VAR) VAR VAR(VAR, VAR): VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR, VAR.VAR, VAR=""VAR"") VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/') VAR VAR.VAR.VAR VAR VAR: VAR.VAR('VAR VAR VAR VAR VAR', VAR(VAR)) ",8
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/with_dummyserver/test_poolmanager.py,"import unittest
import json

import pytest

from dummyserver.server import HAS_IPV6
from dummyserver.testcase import (HTTPDummyServerTestCase,
                                  IPv6HTTPDummyServerTestCase)
from urllib3.poolmanager import PoolManager
from urllib3.connectionpool import port_by_scheme
from urllib3.exceptions import MaxRetryError
from urllib3.util.retry import Retry


class TestPoolManager(HTTPDummyServerTestCase):

    def setUp(self):
        self.base_url = 'http://%s:%d' % (self.host, self.port)
        self.base_url_alt = 'http://%s:%d' % (self.host_alt, self.port)

    def test_redirect(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/' % self.base_url},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/' % self.base_url})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_redirect_twice(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/redirect' % self.base_url},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                       self.base_url)})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_redirect_to_relative_url(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '/redirect'},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '/redirect'})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_cross_host_redirect(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        cross_host_location = '%s/echo?a=b' % self.base_url_alt
        try:
            http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': cross_host_location},
                         timeout=1, retries=0)
            self.fail(""Request succeeded instead of raising an exception like it should."")

        except MaxRetryError:
            pass

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/echo?a=b' % self.base_url_alt},
                         timeout=1, retries=1)

        self.assertEqual(r._pool.host, self.host_alt)

    def test_too_many_redirects(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        try:
            r = http.request('GET', '%s/redirect' % self.base_url,
                             fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                           self.base_url)},
                             retries=1)
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

        try:
            r = http.request('GET', '%s/redirect' % self.base_url,
                             fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                           self.base_url)},
                             retries=Retry(total=None, redirect=1))
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

    def test_redirect_cross_host_remove_headers(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'Authorization': 'foo'})

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('Authorization', data)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'authorization': 'foo'})

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('authorization', data)
        self.assertNotIn('Authorization', data)

    def test_redirect_cross_host_no_remove_headers(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'Authorization': 'foo'},
                         retries=Retry(remove_headers_on_redirect=[]))

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertEqual(data['Authorization'], 'foo')

    def test_redirect_cross_host_set_removed_headers(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'X-API-Secret': 'foo',
                                  'Authorization': 'bar'},
                         retries=Retry(remove_headers_on_redirect=['X-API-Secret']))

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('X-API-Secret', data)
        self.assertEqual(data['Authorization'], 'bar')

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'x-api-secret': 'foo',
                                  'authorization': 'bar'},
                         retries=Retry(remove_headers_on_redirect=['X-API-Secret']))

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('x-api-secret', data)
        self.assertNotIn('X-API-Secret', data)
        self.assertEqual(data['Authorization'], 'bar')

    def test_raise_on_redirect(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/redirect?target=%s/' % (self.base_url,
                                                                       self.base_url)},
                         retries=Retry(total=None, redirect=1, raise_on_redirect=False))

        self.assertEqual(r.status, 303)

    def test_raise_on_status(self):
        http = PoolManager()
        self.addCleanup(http.clear)

        try:
            # the default is to raise
            r = http.request('GET', '%s/status' % self.base_url,
                             fields={'status': '500 Internal Server Error'},
                             retries=Retry(total=1, status_forcelist=range(500, 600)))
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

        try:
            # raise explicitly
            r = http.request('GET', '%s/status' % self.base_url,
                             fields={'status': '500 Internal Server Error'},
                             retries=Retry(total=1,
                                           status_forcelist=range(500, 600),
                                           raise_on_status=True))
            self.fail(""Failed to raise MaxRetryError exception, returned %r"" % r.status)
        except MaxRetryError:
            pass

        # don't raise
        r = http.request('GET', '%s/status' % self.base_url,
                         fields={'status': '500 Internal Server Error'},
                         retries=Retry(total=1,
                                       status_forcelist=range(500, 600),
                                       raise_on_status=False))

        self.assertEqual(r.status, 500)

    def test_missing_port(self):
        # Can a URL that lacks an explicit port like ':80' succeed, or
        # will all such URLs fail with an error?

        http = PoolManager()
        self.addCleanup(http.clear)

        # By globally adjusting `port_by_scheme` we pretend for a moment
        # that HTTP's default port is not 80, but is the port at which
        # our test server happens to be listening.
        port_by_scheme['http'] = self.port
        try:
            r = http.request('GET', 'http://%s/' % self.host, retries=0)
        finally:
            port_by_scheme['http'] = 80

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_headers(self):
        http = PoolManager(headers={'Foo': 'bar'})
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request('POST', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request_encode_url('GET', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request_encode_body('POST', '%s/headers' % self.base_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')

        r = http.request_encode_url('GET', '%s/headers' % self.base_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')

        r = http.request_encode_body('GET', '%s/headers' % self.base_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')

    def test_http_with_ssl_keywords(self):
        http = PoolManager(ca_certs='REQUIRED')
        self.addCleanup(http.clear)

        r = http.request('GET', 'http://%s:%s/' % (self.host, self.port))
        self.assertEqual(r.status, 200)

    def test_http_with_ca_cert_dir(self):
        http = PoolManager(ca_certs='REQUIRED', ca_cert_dir='/nosuchdir')
        self.addCleanup(http.clear)

        r = http.request('GET', 'http://%s:%s/' % (self.host, self.port))
        self.assertEqual(r.status, 200)


@pytest.mark.skipif(
    not HAS_IPV6,
    reason='IPv6 is not supported on this system'
)
class TestIPv6PoolManager(IPv6HTTPDummyServerTestCase):

    def setUp(self):
        self.base_url = 'http://[%s]:%d' % (self.host, self.port)

    def test_ipv6(self):
        http = PoolManager()
        self.addCleanup(http.clear)
        http.request('GET', self.base_url)


if __name__ == '__main__':
    unittest.main()",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR (VAR, VAR) VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '/VAR'}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '/VAR'}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = '%VAR/VAR?VAR=VAR' % VAR.VAR VAR: VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': VAR}, VAR=1, VAR=0) VAR.VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=VAR' % VAR.VAR}, VAR=1, VAR=1) VAR.VAR(VAR.VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR: VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}, VAR=1) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR: VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}, VAR=VAR(VAR=VAR, VAR=1)) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR', VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR', VAR) VAR.VAR('VAR', VAR) VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR': 'VAR'}, VAR=VAR(VAR=[])) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR(VAR['VAR'], 'VAR') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR-VAR-VAR': 'VAR', 'VAR': 'VAR'}, VAR=VAR(VAR=['VAR-VAR-VAR'])) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR-VAR-VAR', VAR) VAR.VAR(VAR['VAR'], 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR-VAR-VAR': 'VAR', 'VAR': 'VAR'}, VAR=VAR(VAR=['VAR-VAR-VAR'])) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR-VAR-VAR', VAR) VAR.VAR('VAR-VAR-VAR', VAR) VAR.VAR(VAR['VAR'], 'VAR') VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=%VAR/' % (VAR.VAR, VAR.VAR)}, VAR=VAR(VAR=VAR, VAR=1, VAR=VAR)) VAR.VAR(VAR.VAR, 303) VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR:  VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '500 VAR VAR VAR'}, VAR=VAR(VAR=1, VAR=VAR(500, 600))) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR VAR:  VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '500 VAR VAR VAR'}, VAR=VAR(VAR=1, VAR=VAR(500, 600), VAR=VAR)) VAR.VAR(""VAR VAR VAR VAR VAR, VAR %VAR"" % VAR.VAR) VAR VAR: VAR  VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '500 VAR VAR VAR'}, VAR=VAR(VAR=1, VAR=VAR(500, 600), VAR=VAR)) VAR.VAR(VAR.VAR, 500) VAR VAR(VAR):   VAR = VAR() VAR.VAR(VAR.VAR)    VAR['VAR'] = VAR.VAR VAR: VAR = VAR.VAR('VAR', 'VAR: VAR: VAR['VAR'] = 80 VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR(VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR VAR(VAR): VAR = VAR(VAR='VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR(VAR='VAR', VAR='/VAR') VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200) @VAR.VAR.VAR( VAR VAR, VAR='VAR VAR VAR VAR VAR VAR VAR' ) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR() VAR.VAR(VAR.VAR) VAR.VAR('VAR', VAR.VAR) VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/with_dummyserver/test_proxy_poolmanager.py,"import json
import socket
import unittest

import pytest

from dummyserver.testcase import HTTPDummyProxyTestCase, IPv6HTTPDummyProxyTestCase
from dummyserver.server import (
    DEFAULT_CA, DEFAULT_CA_BAD, get_unreachable_address)
from .. import TARPIT_HOST, requires_network

from urllib3._collections import HTTPHeaderDict
from urllib3.poolmanager import proxy_from_url, ProxyManager
from urllib3.exceptions import (
    MaxRetryError, SSLError, ProxyError, ConnectTimeoutError)
from urllib3.connectionpool import connection_from_url, VerifiedHTTPSConnection


class TestHTTPProxyManager(HTTPDummyProxyTestCase):

    def setUp(self):
        self.http_url = 'http://%s:%d' % (self.http_host, self.http_port)
        self.http_url_alt = 'http://%s:%d' % (self.http_host_alt,
                                              self.http_port)
        self.https_url = 'https://%s:%d' % (self.https_host, self.https_port)
        self.https_url_alt = 'https://%s:%d' % (self.https_host_alt,
                                                self.https_port)
        self.proxy_url = 'http://%s:%d' % (self.proxy_host, self.proxy_port)

    def test_basic_proxy(self):
        http = proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url)
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url)
        self.assertEqual(r.status, 200)

    def test_nagle_proxy(self):
        """""" Test that proxy connections do not have TCP_NODELAY turned on """"""
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)
        hc2 = http.connection_from_host(self.http_host, self.http_port)
        conn = hc2._get_conn()
        self.addCleanup(conn.close)
        hc2._make_request(conn, 'GET', '/')
        tcp_nodelay_setting = conn.sock.getsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY)
        self.assertEqual(tcp_nodelay_setting, 0,
                         (""Expected TCP_NODELAY for proxies to be set ""
                          ""to zero, instead was %s"" % tcp_nodelay_setting))

    def test_proxy_conn_fail(self):
        host, port = get_unreachable_address()
        http = proxy_from_url('http://%s:%s/' % (host, port), retries=1, timeout=0.05)
        self.addCleanup(http.clear)
        self.assertRaises(MaxRetryError, http.request, 'GET',
                          '%s/' % self.https_url)
        self.assertRaises(MaxRetryError, http.request, 'GET',
                          '%s/' % self.http_url)

        try:
            http.request('GET', '%s/' % self.http_url)
            self.fail(""Failed to raise retry error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), ProxyError)

    def test_oldapi(self):
        http = ProxyManager(connection_from_url(self.proxy_url), ca_certs=DEFAULT_CA)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url)
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url)
        self.assertEqual(r.status, 200)

    def test_proxy_verified(self):
        http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                              ca_certs=DEFAULT_CA_BAD)
        self.addCleanup(http.clear)
        https_pool = http._new_pool('https', self.https_host,
                                    self.https_port)
        try:
            https_pool.request('GET', '/', retries=0)
            self.fail(""Didn't raise SSL error with wrong CA"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertIn('certificate verify failed', str(e.reason),
                          ""Expected 'certificate verify failed',""
                          ""instead got: %r"" % e.reason)

        http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                              ca_certs=DEFAULT_CA)
        https_pool = http._new_pool('https', self.https_host,
                                    self.https_port)

        conn = https_pool._new_conn()
        self.assertEqual(conn.__class__, VerifiedHTTPSConnection)
        https_pool.request('GET', '/')  # Should succeed without exceptions.

        http = proxy_from_url(self.proxy_url, cert_reqs='REQUIRED',
                              ca_certs=DEFAULT_CA)
        https_fail_pool = http._new_pool('https', '127.0.0.1', self.https_port)

        try:
            https_fail_pool.request('GET', '/', retries=0)
            self.fail(""Didn't raise SSL invalid common name"")
        except MaxRetryError as e:
            self.assertIsInstance(e.reason, SSLError)
            self.assertIn(""doesn't match"", str(e.reason))

    def test_redirect(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/' % self.http_url},
                         redirect=False)

        self.assertEqual(r.status, 303)

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/' % self.http_url})

        self.assertEqual(r.status, 200)
        self.assertEqual(r.data, b'Dummy server!')

    def test_cross_host_redirect(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        cross_host_location = '%s/echo?a=b' % self.http_url_alt
        try:
            http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': cross_host_location},
                         timeout=1, retries=0)
            self.fail(""We don't want to follow redirects here."")

        except MaxRetryError:
            pass

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/echo?a=b' % self.http_url_alt},
                         timeout=1, retries=1)
        self.assertNotEqual(r._pool.host, self.http_host_alt)

    def test_cross_protocol_redirect(self):
        http = proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA)
        self.addCleanup(http.clear)

        cross_protocol_location = '%s/echo?a=b' % self.https_url
        try:
            http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': cross_protocol_location},
                         timeout=1, retries=0)
            self.fail(""We don't want to follow redirects here."")

        except MaxRetryError:
            pass

        r = http.request('GET', '%s/redirect' % self.http_url,
                         fields={'target': '%s/echo?a=b' % self.https_url},
                         timeout=1, retries=1)
        self.assertEqual(r._pool.host, self.https_host)

    def test_headers(self):
        http = proxy_from_url(self.proxy_url, headers={'Foo': 'bar'},
                              proxy_headers={'Hickory': 'dickory'},
                              ca_certs=DEFAULT_CA)
        self.addCleanup(http.clear)

        r = http.request_encode_url('GET', '%s/headers' % self.http_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.http_url_alt)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host_alt, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.https_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host, self.https_port))

        r = http.request_encode_body('POST', '%s/headers' % self.http_url)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.http_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_url('GET', '%s/headers' % self.https_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host, self.https_port))

        r = http.request_encode_body('GET', '%s/headers' % self.http_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertEqual(returned_headers.get('Hickory'), 'dickory')
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.http_host, self.http_port))

        r = http.request_encode_body('GET', '%s/headers' % self.https_url, headers={'Baz': 'quux'})
        returned_headers = json.loads(r.data.decode())
        self.assertIsNone(returned_headers.get('Foo'))
        self.assertEqual(returned_headers.get('Baz'), 'quux')
        self.assertIsNone(returned_headers.get('Hickory'))
        self.assertEqual(returned_headers.get('Host'),
                         '%s:%s' % (self.https_host, self.https_port))

    def test_headerdict(self):
        default_headers = HTTPHeaderDict(a='b')
        proxy_headers = HTTPHeaderDict()
        proxy_headers.add('foo', 'bar')

        http = proxy_from_url(
            self.proxy_url,
            headers=default_headers,
            proxy_headers=proxy_headers)
        self.addCleanup(http.clear)

        request_headers = HTTPHeaderDict(baz='quux')
        r = http.request('GET', '%s/headers' % self.http_url, headers=request_headers)
        returned_headers = json.loads(r.data.decode())
        self.assertEqual(returned_headers.get('Foo'), 'bar')
        self.assertEqual(returned_headers.get('Baz'), 'quux')

    def test_proxy_pooling(self):
        http = proxy_from_url(self.proxy_url, cert_reqs='NONE')
        self.addCleanup(http.clear)

        for x in range(2):
            http.urlopen('GET', self.http_url)
        self.assertEqual(len(http.pools), 1)

        for x in range(2):
            http.urlopen('GET', self.http_url_alt)
        self.assertEqual(len(http.pools), 1)

        for x in range(2):
            http.urlopen('GET', self.https_url)
        self.assertEqual(len(http.pools), 2)

        for x in range(2):
            http.urlopen('GET', self.https_url_alt)
        self.assertEqual(len(http.pools), 3)

    def test_proxy_pooling_ext(self):
        http = proxy_from_url(self.proxy_url)
        self.addCleanup(http.clear)

        hc1 = http.connection_from_url(self.http_url)
        hc2 = http.connection_from_host(self.http_host, self.http_port)
        hc3 = http.connection_from_url(self.http_url_alt)
        hc4 = http.connection_from_host(self.http_host_alt, self.http_port)
        self.assertEqual(hc1, hc2)
        self.assertEqual(hc2, hc3)
        self.assertEqual(hc3, hc4)

        sc1 = http.connection_from_url(self.https_url)
        sc2 = http.connection_from_host(self.https_host,
                                        self.https_port, scheme='https')
        sc3 = http.connection_from_url(self.https_url_alt)
        sc4 = http.connection_from_host(self.https_host_alt,
                                        self.https_port, scheme='https')
        self.assertEqual(sc1, sc2)
        self.assertNotEqual(sc2, sc3)
        self.assertEqual(sc3, sc4)

    @pytest.mark.timeout(0.5)
    @requires_network
    def test_https_proxy_timeout(self):
        https = proxy_from_url('https://{host}'.format(host=TARPIT_HOST))
        self.addCleanup(https.clear)
        try:
            https.request('GET', self.http_url, timeout=0.001)
            self.fail(""Failed to raise retry error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), ConnectTimeoutError)

    @pytest.mark.timeout(0.5)
    @requires_network
    def test_https_proxy_pool_timeout(self):
        https = proxy_from_url('https://{host}'.format(host=TARPIT_HOST),
                               timeout=0.001)
        self.addCleanup(https.clear)
        try:
            https.request('GET', self.http_url)
            self.fail(""Failed to raise retry error."")
        except MaxRetryError as e:
            self.assertEqual(type(e.reason), ConnectTimeoutError)

    def test_scheme_host_case_insensitive(self):
        """"""Assert that upper-case schemes and hosts are normalized.""""""
        http = proxy_from_url(self.proxy_url.upper(), ca_certs=DEFAULT_CA)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url.upper())
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url.upper())
        self.assertEqual(r.status, 200)


class TestIPv6HTTPProxyManager(IPv6HTTPDummyProxyTestCase):

    def setUp(self):
        self.http_url = 'http://%s:%d' % (self.http_host, self.http_port)
        self.http_url_alt = 'http://%s:%d' % (self.http_host_alt,
                                              self.http_port)
        self.https_url = 'https://%s:%d' % (self.https_host, self.https_port)
        self.https_url_alt = 'https://%s:%d' % (self.https_host_alt,
                                                self.https_port)
        self.proxy_url = 'http://[%s]:%d' % (self.proxy_host, self.proxy_port)

    def test_basic_ipv6_proxy(self):
        http = proxy_from_url(self.proxy_url, ca_certs=DEFAULT_CA)
        self.addCleanup(http.clear)

        r = http.request('GET', '%s/' % self.http_url)
        self.assertEqual(r.status, 200)

        r = http.request('GET', '%s/' % self.https_url)
        self.assertEqual(r.status, 200)


if __name__ == '__main__':
    unittest.main()",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR) VAR .. VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR) VAR VAR.VAR VAR VAR, VAR VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR) VAR.VAR(VAR, 'VAR', '/') VAR = VAR.VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR, 0, (""VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR, VAR VAR %VAR"" % VAR)) VAR VAR(VAR): VAR, VAR = VAR() VAR = VAR('VAR: VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '%VAR/' % VAR.VAR) VAR: VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): VAR = VAR(VAR(VAR.VAR), VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR='VAR', VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', VAR.VAR, VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR('VAR VAR VAR', VAR(VAR.VAR), ""VAR 'VAR VAR VAR',"" ""VAR VAR: %VAR"" % VAR.VAR) VAR = VAR(VAR.VAR, VAR='VAR', VAR=VAR) VAR = VAR.VAR('VAR', VAR.VAR, VAR.VAR) VAR = VAR.VAR() VAR.VAR(VAR.VAR, VAR) VAR.VAR('VAR', '/')  VAR = VAR(VAR.VAR, VAR='VAR', VAR=VAR) VAR = VAR.VAR('VAR', '127.0.0.1', VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(""VAR'VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR.VAR(VAR.VAR, VAR) VAR.VAR(""VAR'VAR VAR"", VAR(VAR.VAR)) VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}, VAR=VAR) VAR.VAR(VAR.VAR, 303) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/' % VAR.VAR}) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR VAR!') VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = '%VAR/VAR?VAR=VAR' % VAR.VAR VAR: VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': VAR}, VAR=1, VAR=0) VAR.VAR(""VAR VAR'VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=VAR' % VAR.VAR}, VAR=1, VAR=1) VAR.VAR(VAR.VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = '%VAR/VAR?VAR=VAR' % VAR.VAR VAR: VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': VAR}, VAR=1, VAR=0) VAR.VAR(""VAR VAR'VAR VAR VAR VAR VAR VAR."") VAR VAR: VAR VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR?VAR=VAR' % VAR.VAR}, VAR=1, VAR=1) VAR.VAR(VAR.VAR.VAR, VAR.VAR) VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR={'VAR': 'VAR'}, VAR={'VAR': 'VAR'}, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': 'VAR'}) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR')) VAR.VAR(VAR.VAR('VAR'), '%VAR:%VAR' % (VAR.VAR, VAR.VAR)) VAR VAR(VAR): VAR = VAR(VAR='VAR') VAR = VAR() VAR.VAR('VAR', 'VAR') VAR = VAR( VAR.VAR, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR(VAR='VAR') VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR=VAR) VAR = VAR.VAR(VAR.VAR.VAR()) VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR.VAR(VAR.VAR('VAR'), 'VAR') VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 1) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 1) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 2) VAR VAR VAR VAR(2): VAR.VAR('VAR', VAR.VAR) VAR.VAR(VAR(VAR.VAR), 3) VAR VAR(VAR): VAR = VAR(VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR, VAR='VAR') VAR = VAR.VAR(VAR.VAR) VAR = VAR.VAR(VAR.VAR, VAR.VAR, VAR='VAR') VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) VAR.VAR(VAR, VAR) @VAR.VAR.VAR(0.5) @VAR VAR VAR(VAR): VAR = VAR('VAR: VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', VAR.VAR, VAR=0.001) VAR.VAR(""VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) @VAR.VAR.VAR(0.5) @VAR VAR VAR(VAR): VAR = VAR('VAR: VAR=0.001) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR."") VAR VAR VAR VAR: VAR.VAR(VAR(VAR.VAR), VAR) VAR VAR(VAR): """"""VAR VAR VAR-VAR VAR VAR VAR VAR VAR."""""" VAR = VAR(VAR.VAR.VAR(), VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR.VAR()) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR.VAR()) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR.VAR = 'VAR: VAR.VAR) VAR.VAR = 'VAR: VAR VAR(VAR): VAR = VAR(VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', '%VAR/' % VAR.VAR) VAR.VAR(VAR.VAR, 200) VAR VAR == 'VAR': VAR.VAR() ",8
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/with_dummyserver/test_socketlevel.py,"# TODO: Break this module up into pieces. Maybe group by functionality tested
# rather than the socket level-ness of it.

from urllib3 import HTTPConnectionPool, HTTPSConnectionPool
from urllib3.poolmanager import proxy_from_url
from urllib3.exceptions import (
        MaxRetryError,
        ProxyError,
        ReadTimeoutError,
        SSLError,
        ProtocolError,
)
from urllib3.response import httplib
from urllib3.util.ssl_ import HAS_SNI
from urllib3.util import ssl_
from urllib3.util.timeout import Timeout
from urllib3.util.retry import Retry
from urllib3._collections import HTTPHeaderDict

from dummyserver.testcase import SocketDummyServerTestCase, consume_socket
from dummyserver.server import (
    DEFAULT_CERTS, DEFAULT_CA, COMBINED_CERT_AND_KEY,
    PASSWORD_KEYFILE, get_unreachable_address
)

from .. import onlyPy3, LogRecorder

try:
    from mimetools import Message as MimeToolMessage
except ImportError:
    class MimeToolMessage(object):
        pass
from collections import OrderedDict
from threading import Event
import select
import socket
import ssl

import pytest

from test import fails_on_travis_gce, requires_ssl_context_keyfile_password


class TestCookies(SocketDummyServerTestCase):

    def test_multi_setcookie(self):
        def multicookie_response_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(b'HTTP/1.1 200 OK\r\n'
                      b'Set-Cookie: foo=1\r\n'
                      b'Set-Cookie: bar=1\r\n'
                      b'\r\n')
            sock.close()

        self._start_server(multicookie_response_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/', retries=0)
        self.assertEqual(r.headers, {'set-cookie': 'foo=1, bar=1'})
        self.assertEqual(r.headers.getlist('set-cookie'), ['foo=1', 'bar=1'])


class TestSNI(SocketDummyServerTestCase):

    @pytest.mark.skipif(not HAS_SNI, reason='SNI-support not available')
    def test_hostname_in_first_request_packet(self):
        done_receiving = Event()
        self.buf = b''

        def socket_handler(listener):
            sock = listener.accept()[0]

            self.buf = sock.recv(65536)  # We only accept one packet
            done_receiving.set()  # let the test know it can proceed
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        try:
            pool.request('GET', '/', retries=0)
        except MaxRetryError:  # We are violating the protocol
            pass
        done_receiving.wait()
        self.assertIn(self.host.encode('ascii'), self.buf,
                      ""missing hostname in SSL handshake"")


class TestClientCerts(SocketDummyServerTestCase):
    """"""
    Tests for client certificate support.
    """"""
    def _wrap_in_ssl(self, sock):
        """"""
        Given a single socket, wraps it in TLS.
        """"""
        return ssl.wrap_socket(
            sock,
            ssl_version=ssl.PROTOCOL_SSLv23,
            cert_reqs=ssl.CERT_REQUIRED,
            ca_certs=DEFAULT_CA,
            certfile=DEFAULT_CERTS['certfile'],
            keyfile=DEFAULT_CERTS['keyfile'],
            server_side=True
        )

    def test_client_certs_two_files(self):
        """"""
        Having a client cert in a separate file to its associated key works
        properly.
        """"""
        done_receiving = Event()
        client_certs = []

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock = self._wrap_in_ssl(sock)

            client_certs.append(sock.getpeercert())

            data = b''
            while not data.endswith(b'\r\n\r\n'):
                data += sock.recv(8192)

            sock.sendall(
                b'HTTP/1.1 200 OK\r\n'
                b'Server: testsocket\r\n'
                b'Connection: close\r\n'
                b'Content-Length: 6\r\n'
                b'\r\n'
                b'Valid!'
            )

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(
            self.host,
            self.port,
            cert_file=DEFAULT_CERTS['certfile'],
            key_file=DEFAULT_CERTS['keyfile'],
            cert_reqs='REQUIRED',
            ca_certs=DEFAULT_CA,
        )
        self.addCleanup(pool.close)
        pool.request('GET', '/', retries=0)
        done_receiving.set()

        self.assertEqual(len(client_certs), 1)

    def test_client_certs_one_file(self):
        """"""
        Having a client cert and its associated private key in just one file
        works properly.
        """"""
        done_receiving = Event()
        client_certs = []

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock = self._wrap_in_ssl(sock)

            client_certs.append(sock.getpeercert())

            data = b''
            while not data.endswith(b'\r\n\r\n'):
                data += sock.recv(8192)

            sock.sendall(
                b'HTTP/1.1 200 OK\r\n'
                b'Server: testsocket\r\n'
                b'Connection: close\r\n'
                b'Content-Length: 6\r\n'
                b'\r\n'
                b'Valid!'
            )

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(
            self.host,
            self.port,
            cert_file=COMBINED_CERT_AND_KEY,
            cert_reqs='REQUIRED',
            ca_certs=DEFAULT_CA,
        )
        self.addCleanup(pool.close)
        pool.request('GET', '/', retries=0)
        done_receiving.set()

        self.assertEqual(len(client_certs), 1)

    def test_missing_client_certs_raises_error(self):
        """"""
        Having client certs not be present causes an error.
        """"""
        done_receiving = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            try:
                self._wrap_in_ssl(sock)
            except ssl.SSLError:
                pass

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(
            self.host,
            self.port,
            cert_reqs='REQUIRED',
            ca_certs=DEFAULT_CA,
        )
        self.addCleanup(pool.close)
        try:
            pool.request('GET', '/', retries=0)
        except MaxRetryError:
            done_receiving.set()
        else:
            done_receiving.set()
            self.fail(
                ""Expected server to reject connection due to missing client ""
                ""certificates""
            )

    @requires_ssl_context_keyfile_password
    def test_client_cert_with_string_password(self):
        self.run_client_cert_with_password_test(u""letmein"")

    @requires_ssl_context_keyfile_password
    def test_client_cert_with_bytes_password(self):
        self.run_client_cert_with_password_test(b""letmein"")

    def run_client_cert_with_password_test(self, password):
        """"""
        Tests client certificate password functionality
        """"""
        done_receiving = Event()
        client_certs = []

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock = self._wrap_in_ssl(sock)

            client_certs.append(sock.getpeercert())

            data = b''
            while not data.endswith(b'\r\n\r\n'):
                data += sock.recv(8192)

            sock.sendall(
                b'HTTP/1.1 200 OK\r\n'
                b'Server: testsocket\r\n'
                b'Connection: close\r\n'
                b'Content-Length: 6\r\n'
                b'\r\n'
                b'Valid!'
            )

            done_receiving.wait(5)
            sock.close()

        self._start_server(socket_handler)
        ssl_context = ssl_.SSLContext(ssl_.PROTOCOL_SSLv23)
        ssl_context.load_cert_chain(
            certfile=DEFAULT_CERTS['certfile'],
            keyfile=PASSWORD_KEYFILE,
            password=password
        )

        pool = HTTPSConnectionPool(
            self.host,
            self.port,
            ssl_context=ssl_context,
            cert_reqs='REQUIRED',
            ca_certs=DEFAULT_CA,
        )
        self.addCleanup(pool.close)
        pool.request('GET', '/', retries=0)
        done_receiving.set()

        self.assertEqual(len(client_certs), 1)

    @requires_ssl_context_keyfile_password
    def test_load_keyfile_with_invalid_password(self):
        context = ssl_.SSLContext(ssl_.PROTOCOL_SSLv23)

        # Different error is raised depending on context.
        if ssl_.IS_PYOPENSSL:
            from OpenSSL.SSL import Error
            expected_error = Error
        else:
            expected_error = ssl.SSLError

        with pytest.raises(expected_error):
            context.load_cert_chain(certfile=DEFAULT_CERTS[""certfile""],
                                    keyfile=PASSWORD_KEYFILE,
                                    password=b'letmei')


class TestSocketClosing(SocketDummyServerTestCase):

    def test_recovery_when_server_closes_connection(self):
        # Does the pool work seamlessly if an open connection in the
        # connection pool gets hung up on by the server, then reaches
        # the front of the queue again?

        done_closing = Event()

        def socket_handler(listener):
            for i in 0, 1:
                sock = listener.accept()[0]

                buf = b''
                while not buf.endswith(b'\r\n\r\n'):
                    buf = sock.recv(65536)

                body = 'Response %d' % i
                sock.send(('HTTP/1.1 200 OK\r\n'
                           'Content-Type: text/plain\r\n'
                           'Content-Length: %d\r\n'
                           '\r\n'
                           '%s' % (len(body), body)).encode('utf-8'))

                sock.close()  # simulate a server timing out, closing socket
                done_closing.set()  # let the test know it can proceed

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.request('GET', '/', retries=0)
        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'Response 0')

        done_closing.wait()  # wait until the socket in our pool gets closed

        response = pool.request('GET', '/', retries=0)
        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'Response 1')

    def test_connection_refused(self):
        # Does the pool retry if there is no listener on the port?
        host, port = get_unreachable_address()
        http = HTTPConnectionPool(host, port, maxsize=3, block=True)
        self.addCleanup(http.close)
        self.assertRaises(MaxRetryError, http.request, 'GET', '/', retries=0, release_conn=False)
        self.assertEqual(http.pool.qsize(), http.pool.maxsize)

    def test_connection_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            while not sock.recv(65536).endswith(b'\r\n\r\n'):
                pass

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        http = HTTPConnectionPool(self.host, self.port,
                                  timeout=0.01,
                                  retries=False,
                                  maxsize=3,
                                  block=True)
        self.addCleanup(http.close)

        try:
            self.assertRaises(ReadTimeoutError, http.request, 'GET', '/', release_conn=False)
        finally:
            timed_out.set()

        self.assertEqual(http.pool.qsize(), http.pool.maxsize)

    def test_read_timeout_dont_retry_method_not_in_whitelist(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            sock.recv(65536)
            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port, timeout=0.01, retries=True)
        self.addCleanup(pool.close)

        try:
            self.assertRaises(ReadTimeoutError, pool.request, 'POST', '/')
        finally:
            timed_out.set()

    def test_https_connection_read_timeout(self):
        """""" Handshake timeouts should fail with a Timeout""""""
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            while not sock.recv(65536):
                pass

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port, timeout=0.01, retries=False)
        self.addCleanup(pool.close)
        try:
            self.assertRaises(ReadTimeoutError, pool.request, 'GET', '/')
        finally:
            timed_out.set()

    def test_timeout_errors_cause_retries(self):
        def socket_handler(listener):
            sock_timeout = listener.accept()[0]

            # Wait for a second request before closing the first socket.
            sock = listener.accept()[0]
            sock_timeout.close()

            # Second request.
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            # Now respond immediately.
            body = 'Response 2'
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(body), body)).encode('utf-8'))

            sock.close()

        # In situations where the main thread throws an exception, the server
        # thread can hang on an accept() call. This ensures everything times
        # out within 1 second. This should be long enough for any socket
        # operations in the test suite to complete
        default_timeout = socket.getdefaulttimeout()
        socket.setdefaulttimeout(1)

        try:
            self._start_server(socket_handler)
            t = Timeout(connect=0.001, read=0.01)
            pool = HTTPConnectionPool(self.host, self.port, timeout=t)
            self.addCleanup(pool.close)

            response = pool.request('GET', '/', retries=1)
            self.assertEqual(response.status, 200)
            self.assertEqual(response.data, b'Response 2')
        finally:
            socket.setdefaulttimeout(default_timeout)

    def test_delayed_body_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b''
            body = 'Hi'
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n' % len(body)).encode('utf-8'))

            timed_out.wait()
            sock.send(body.encode('utf-8'))
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.urlopen('GET', '/', retries=0, preload_content=False,
                                timeout=Timeout(connect=1, read=0.01))
        try:
            self.assertRaises(ReadTimeoutError, response.read)
        finally:
            timed_out.set()

    def test_delayed_body_read_timeout_with_preload(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b''
            body = 'Hi'
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n' % len(body)).encode('utf-8'))

            timed_out.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        try:
            self.assertRaises(ReadTimeoutError, pool.urlopen,
                              'GET', '/', retries=False,
                              timeout=Timeout(connect=1, read=0.01))
        finally:
            timed_out.set()

    def test_incomplete_response(self):
        body = 'Response'
        partial_body = body[:2]

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)

            # Send partial response and close socket.
            sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: %d\r\n'
                '\r\n'
                '%s' % (len(body), partial_body)).encode('utf-8')
            )
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.request('GET', '/', retries=0, preload_content=False)
        self.assertRaises(ProtocolError, response.read)

    def test_retry_weird_http_version(self):
        """""" Retry class should handle httplib.BadStatusLine errors properly """"""

        def socket_handler(listener):
            sock = listener.accept()[0]
            # First request.
            # Pause before responding so the first request times out.
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            # send unknown http protocol
            body = ""bad http 0.5 response""
            sock.send(('HTTP/0.5 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(body), body)).encode('utf-8'))
            sock.close()

            # Second request.
            sock = listener.accept()[0]
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            # Now respond immediately.
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       'foo' % (len('foo'))).encode('utf-8'))

            sock.close()  # Close the socket.

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        retry = Retry(read=1)
        response = pool.request('GET', '/', retries=retry)
        self.assertEqual(response.status, 200)
        self.assertEqual(response.data, b'foo')

    def test_connection_cleanup_on_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            buf = b''
            body = 'Hi'
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n' % len(body)).encode('utf-8'))

            timed_out.wait()
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            poolsize = pool.pool.qsize()
            response = pool.urlopen('GET', '/', retries=0, preload_content=False,
                                    timeout=Timeout(connect=1, read=0.01))
            try:
                self.assertRaises(ReadTimeoutError, response.read)
                self.assertEqual(poolsize, pool.pool.qsize())
            finally:
                timed_out.set()

    def test_connection_cleanup_on_protocol_error_during_read(self):
        body = 'Response'
        partial_body = body[:2]

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)

            # Send partial response and close socket.
            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(body), partial_body)).encode('utf-8'))
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            poolsize = pool.pool.qsize()
            response = pool.request('GET', '/', retries=0, preload_content=False)

            self.assertRaises(ProtocolError, response.read)
            self.assertEqual(poolsize, pool.pool.qsize())

    def test_connection_closed_on_read_timeout_preload_false(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65535)

            # Send partial chunked response and then hang.
            sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Transfer-Encoding: chunked\r\n'
                '\r\n'
                '8\r\n'
                '12345678\r\n').encode('utf-8')
            )
            timed_out.wait(5)

            # Expect a new request, but keep hold of the old socket to avoid
            # leaking it. Because we don't want to hang this thread, we
            # actually use select.select to confirm that a new request is
            # coming in: this lets us time the thread out.
            rlist, _, _ = select.select([listener], [], [], 1)
            assert rlist
            new_sock = listener.accept()[0]

            # Consume request
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = new_sock.recv(65535)

            # Send complete chunked response.
            new_sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Transfer-Encoding: chunked\r\n'
                '\r\n'
                '8\r\n'
                '12345678\r\n'
                '0\r\n\r\n').encode('utf-8')
            )

            new_sock.close()
            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port) as pool:
            # First request should fail.
            response = pool.urlopen('GET', '/', retries=0,
                                    preload_content=False,
                                    timeout=Timeout(connect=1, read=0.1))
            try:
                self.assertRaises(ReadTimeoutError, response.read)
            finally:
                timed_out.set()

            # Second should succeed.
            response = pool.urlopen('GET', '/', retries=0,
                                    preload_content=False,
                                    timeout=Timeout(connect=1, read=1))
            self.assertEqual(len(response.read()), 8)

    def test_closing_response_actually_closes_connection(self):
        done_closing = Event()
        complete = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf = sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: 0\r\n'
                       '\r\n').encode('utf-8'))

            # Wait for the socket to close.
            done_closing.wait(timeout=1)

            # Look for the empty string to show that the connection got closed.
            # Don't get stuck in a timeout.
            sock.settimeout(1)
            new_data = sock.recv(65536)
            self.assertFalse(new_data)
            sock.close()
            complete.set()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        response = pool.request('GET', '/', retries=0, preload_content=False)
        self.assertEqual(response.status, 200)
        response.close()

        done_closing.set()  # wait until the socket in our pool gets closed
        successful = complete.wait(timeout=1)
        if not successful:
            self.fail(""Timed out waiting for connection close"")

    def test_release_conn_param_is_respected_after_timeout_retry(self):
        """"""For successful ```urlopen(release_conn=False)```,
        the connection isn't released, even after a retry.

        This test allows a retry: one request fails, the next request succeeds.

        This is a regression test for issue #651 [1], where the connection
        would be released if the initial request failed, even if a retry
        succeeded.

        [1] <https://github.com/shazow/urllib3/issues/651>
        """"""
        def socket_handler(listener):
            sock = listener.accept()[0]
            consume_socket(sock)

            # Close the connection, without sending any response (not even the
            # HTTP status line). This will trigger a `Timeout` on the client,
            # inside `urlopen()`.
            sock.close()

            # Expect a new request. Because we don't want to hang this thread,
            # we actually use select.select to confirm that a new request is
            # coming in: this lets us time the thread out.
            rlist, _, _ = select.select([listener], [], [], 5)
            assert rlist
            sock = listener.accept()[0]
            consume_socket(sock)

            # Send complete chunked response.
            sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Transfer-Encoding: chunked\r\n'
                '\r\n'
                '8\r\n'
                '12345678\r\n'
                '0\r\n\r\n').encode('utf-8')
            )

            sock.close()

        self._start_server(socket_handler)
        with HTTPConnectionPool(self.host, self.port, maxsize=1) as pool:
            # First request should fail, but the timeout and `retries=1` should
            # save it.
            response = pool.urlopen('GET', '/', retries=1,
                                    release_conn=False, preload_content=False,
                                    timeout=Timeout(connect=1, read=0.01))

            # The connection should still be on the response object, and none
            # should be in the pool. We opened two though.
            self.assertEqual(pool.num_connections, 2)
            self.assertEqual(pool.pool.qsize(), 0)
            self.assertIsNotNone(response.connection)

            # Consume the data. This should put the connection back.
            response.read()
            self.assertEqual(pool.pool.qsize(), 1)
            self.assertIsNone(response.connection)


class TestProxyManager(SocketDummyServerTestCase):

    def test_simple(self):
        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(buf), buf.decode('utf-8'))).encode('utf-8'))
            sock.close()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)
        proxy = proxy_from_url(base_url)
        self.addCleanup(proxy.clear)

        r = proxy.request('GET', 'http://google.com/')

        self.assertEqual(r.status, 200)
        # FIXME: The order of the headers is not predictable right now. We
        # should fix that someday (maybe when we migrate to
        # OrderedDict/MultiDict).
        self.assertEqual(sorted(r.data.split(b'\r\n')),
                         sorted([
                             b'GET http://google.com/ HTTP/1.1',
                             b'Host: google.com',
                             b'Accept-Encoding: identity',
                             b'Accept: */*',
                             b'',
                             b'',
                         ]))

    def test_headers(self):
        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(buf), buf.decode('utf-8'))).encode('utf-8'))
            sock.close()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        # Define some proxy headers.
        proxy_headers = HTTPHeaderDict({'For The Proxy': 'YEAH!'})
        proxy = proxy_from_url(base_url, proxy_headers=proxy_headers)
        self.addCleanup(proxy.clear)

        conn = proxy.connection_from_url('http://www.google.com/')

        r = conn.urlopen('GET', 'http://www.google.com/', assert_same_host=False)

        self.assertEqual(r.status, 200)
        # FIXME: The order of the headers is not predictable right now. We
        # should fix that someday (maybe when we migrate to
        # OrderedDict/MultiDict).
        self.assertIn(b'For The Proxy: YEAH!\r\n', r.data)

    def test_retries(self):
        close_event = Event()

        def echo_socket_handler(listener):
            sock = listener.accept()[0]
            # First request, which should fail
            sock.close()

            # Second request
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(('HTTP/1.1 200 OK\r\n'
                       'Content-Type: text/plain\r\n'
                       'Content-Length: %d\r\n'
                       '\r\n'
                       '%s' % (len(buf), buf.decode('utf-8'))).encode('utf-8'))
            sock.close()
            close_event.set()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        proxy = proxy_from_url(base_url)
        self.addCleanup(proxy.clear)
        conn = proxy.connection_from_url('http://www.google.com')

        r = conn.urlopen('GET', 'http://www.google.com',
                         assert_same_host=False, retries=1)
        self.assertEqual(r.status, 200)

        close_event.wait(timeout=1)
        self.assertRaises(ProxyError, conn.urlopen, 'GET',
                          'http://www.google.com',
                          assert_same_host=False, retries=False)

    def test_connect_reconn(self):
        def proxy_ssl_one(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)
            s = buf.decode('utf-8')
            if not s.startswith('CONNECT '):
                sock.send(('HTTP/1.1 405 Method not allowed\r\n'
                           'Allow: CONNECT\r\n\r\n').encode('utf-8'))
                sock.close()
                return

            if not s.startswith('CONNECT %s:443' % (self.host,)):
                sock.send(('HTTP/1.1 403 Forbidden\r\n\r\n').encode('utf-8'))
                sock.close()
                return

            sock.send(('HTTP/1.1 200 Connection Established\r\n\r\n').encode('utf-8'))
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'],
                                       ca_certs=DEFAULT_CA)

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            ssl_sock.send(('HTTP/1.1 200 OK\r\n'
                           'Content-Type: text/plain\r\n'
                           'Content-Length: 2\r\n'
                           'Connection: close\r\n'
                           '\r\n'
                           'Hi').encode('utf-8'))
            ssl_sock.close()

        def echo_socket_handler(listener):
            proxy_ssl_one(listener)
            proxy_ssl_one(listener)

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        proxy = proxy_from_url(base_url, ca_certs=DEFAULT_CA)
        self.addCleanup(proxy.clear)

        url = 'https://{0}'.format(self.host)
        conn = proxy.connection_from_url(url)
        r = conn.urlopen('GET', url, retries=0)
        self.assertEqual(r.status, 200)
        r = conn.urlopen('GET', url, retries=0)
        self.assertEqual(r.status, 200)

    def test_connect_ipv6_addr(self):
        ipv6_addr = '2001:4998:c:a06::2:4008'

        def echo_socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)
            s = buf.decode('utf-8')

            if s.startswith('CONNECT [%s]:443' % (ipv6_addr,)):
                sock.send(b'HTTP/1.1 200 Connection Established\r\n\r\n')
                ssl_sock = ssl.wrap_socket(sock,
                                           server_side=True,
                                           keyfile=DEFAULT_CERTS['keyfile'],
                                           certfile=DEFAULT_CERTS['certfile'])
                buf = b''
                while not buf.endswith(b'\r\n\r\n'):
                    buf += ssl_sock.recv(65536)

                ssl_sock.send(b'HTTP/1.1 200 OK\r\n'
                              b'Content-Type: text/plain\r\n'
                              b'Content-Length: 2\r\n'
                              b'Connection: close\r\n'
                              b'\r\n'
                              b'Hi')
                ssl_sock.close()
            else:
                sock.close()

        self._start_server(echo_socket_handler)
        base_url = 'http://%s:%d' % (self.host, self.port)

        proxy = proxy_from_url(base_url, cert_reqs='NONE')
        self.addCleanup(proxy.clear)

        url = 'https://[{0}]'.format(ipv6_addr)
        conn = proxy.connection_from_url(url)
        try:
            r = conn.urlopen('GET', url, retries=0)
            self.assertEqual(r.status, 200)
        except MaxRetryError:
            self.fail('Invalid IPv6 format in HTTP CONNECT request')


class TestSSL(SocketDummyServerTestCase):

    def test_ssl_failure_midway_through_conn(self):
        def socket_handler(listener):
            sock = listener.accept()[0]
            sock2 = sock.dup()
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'],
                                       ca_certs=DEFAULT_CA)

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            # Deliberately send from the non-SSL socket.
            sock2.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: 2\r\n'
                '\r\n'
                'Hi').encode('utf-8'))
            sock2.close()
            ssl_sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)

        with self.assertRaises(MaxRetryError) as cm:
            pool.request('GET', '/', retries=0)
        self.assertIsInstance(cm.exception.reason, SSLError)

    def test_ssl_read_timeout(self):
        timed_out = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'])

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            # Send incomplete message (note Content-Length)
            ssl_sock.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: 10\r\n'
                '\r\n'
                'Hi-').encode('utf-8'))
            timed_out.wait()

            sock.close()
            ssl_sock.close()

        self._start_server(socket_handler)
        pool = HTTPSConnectionPool(self.host, self.port, ca_certs=DEFAULT_CA)
        self.addCleanup(pool.close)

        response = pool.urlopen('GET', '/', retries=0, preload_content=False,
                                timeout=Timeout(connect=1, read=0.01))
        try:
            self.assertRaises(ReadTimeoutError, response.read)
        finally:
            timed_out.set()

    def test_ssl_failed_fingerprint_verification(self):
        def socket_handler(listener):
            for i in range(2):
                sock = listener.accept()[0]
                ssl_sock = ssl.wrap_socket(sock,
                                           server_side=True,
                                           keyfile=DEFAULT_CERTS['keyfile'],
                                           certfile=DEFAULT_CERTS['certfile'],
                                           ca_certs=DEFAULT_CA)

                ssl_sock.send(b'HTTP/1.1 200 OK\r\n'
                              b'Content-Type: text/plain\r\n'
                              b'Content-Length: 5\r\n\r\n'
                              b'Hello')

                ssl_sock.close()
                sock.close()

        self._start_server(socket_handler)
        # GitHub's fingerprint. Valid, but not matching.
        fingerprint = ('A0:C4:A7:46:00:ED:A7:2D:C0:BE:CB'
                       ':9A:8C:B6:07:CA:58:EE:74:5E')

        def request():
            pool = HTTPSConnectionPool(self.host, self.port,
                                       assert_fingerprint=fingerprint)
            try:
                response = pool.urlopen('GET', '/', preload_content=False,
                                        timeout=Timeout(connect=1, read=0.01),
                                        retries=0)
                response.read()
            finally:
                pool.close()

        with self.assertRaises(MaxRetryError) as cm:
            request()
        self.assertIsInstance(cm.exception.reason, SSLError)
        # Should not hang, see https://github.com/shazow/urllib3/issues/529
        self.assertRaises(MaxRetryError, request)

    def test_retry_ssl_error(self):
        def socket_handler(listener):
            # first request, trigger an SSLError
            sock = listener.accept()[0]
            sock2 = sock.dup()
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'])
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)

            # Deliberately send from the non-SSL socket to trigger an SSLError
            sock2.send((
                'HTTP/1.1 200 OK\r\n'
                'Content-Type: text/plain\r\n'
                'Content-Length: 4\r\n'
                '\r\n'
                'Fail').encode('utf-8'))
            sock2.close()
            ssl_sock.close()

            # retried request
            sock = listener.accept()[0]
            ssl_sock = ssl.wrap_socket(sock,
                                       server_side=True,
                                       keyfile=DEFAULT_CERTS['keyfile'],
                                       certfile=DEFAULT_CERTS['certfile'])
            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += ssl_sock.recv(65536)
            ssl_sock.send(b'HTTP/1.1 200 OK\r\n'
                          b'Content-Type: text/plain\r\n'
                          b'Content-Length: 7\r\n\r\n'
                          b'Success')
            ssl_sock.close()

        self._start_server(socket_handler)

        pool = HTTPSConnectionPool(self.host, self.port, ca_certs=DEFAULT_CA)
        self.addCleanup(pool.close)
        response = pool.urlopen('GET', '/', retries=1)
        self.assertEqual(response.data, b'Success')


class TestErrorWrapping(SocketDummyServerTestCase):

    def test_bad_statusline(self):
        self.start_response_handler(
           b'HTTP/1.1 Omg What Is This?\r\n'
           b'Content-Length: 0\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ProtocolError, pool.request, 'GET', '/')

    def test_unknown_protocol(self):
        self.start_response_handler(
           b'HTTP/1000 200 OK\r\n'
           b'Content-Length: 0\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        self.assertRaises(ProtocolError, pool.request, 'GET', '/')


class TestHeaders(SocketDummyServerTestCase):
    @onlyPy3
    def test_httplib_headers_case_insensitive(self):
        self.start_response_handler(
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 0\r\n'
           b'Content-type: text/plain\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        HEADERS = {'Content-Length': '0', 'Content-type': 'text/plain'}
        r = pool.request('GET', '/')
        self.assertEqual(HEADERS, dict(r.headers.items()))  # to preserve case sensitivity

    def test_headers_are_sent_with_the_original_case(self):
        headers = {'foo': 'bar', 'bAz': 'quux'}
        parsed_headers = {}

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            headers_list = [header for header in buf.split(b'\r\n')[1:] if header]

            for header in headers_list:
                (key, value) = header.split(b': ')
                parsed_headers[key.decode('ascii')] = value.decode('ascii')

            sock.send((
                'HTTP/1.1 204 No Content\r\n'
                'Content-Length: 0\r\n'
                '\r\n').encode('utf-8'))

            sock.close()

        self._start_server(socket_handler)
        expected_headers = {'Accept-Encoding': 'identity',
                            'Host': '{0}:{1}'.format(self.host, self.port)}
        expected_headers.update(headers)

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.request('GET', '/', headers=HTTPHeaderDict(headers))
        self.assertEqual(expected_headers, parsed_headers)

    def test_request_headers_are_sent_in_the_original_order(self):
        # NOTE: Probability this test gives a false negative is 1/(K!)
        K = 16
        # NOTE: Provide headers in non-sorted order (i.e. reversed)
        #       so that if the internal implementation tries to sort them,
        #       a change will be detected.
        expected_request_headers = [(u'X-Header-%d' % i, str(i)) for i in reversed(range(K))]

        actual_request_headers = []

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            headers_list = [header for header in buf.split(b'\r\n')[1:] if header]

            for header in headers_list:
                (key, value) = header.split(b': ')
                if not key.decode('ascii').startswith(u'X-Header-'):
                    continue
                actual_request_headers.append((key.decode('ascii'), value.decode('ascii')))

            sock.send((
                u'HTTP/1.1 204 No Content\r\n'
                u'Content-Length: 0\r\n'
                u'\r\n').encode('ascii'))

            sock.close()

        self._start_server(socket_handler)

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        pool.request('GET', '/', headers=OrderedDict(expected_request_headers))
        self.assertEqual(expected_request_headers, actual_request_headers)

    @fails_on_travis_gce
    def test_request_host_header_ignores_fqdn_dot(self):

        received_headers = []

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            for header in buf.split(b'\r\n')[1:]:
                if header:
                    received_headers.append(header)

            sock.send((
                u'HTTP/1.1 204 No Content\r\n'
                u'Content-Length: 0\r\n'
                u'\r\n').encode('ascii'))

            sock.close()

        self._start_server(socket_handler)

        pool = HTTPConnectionPool(self.host + '.', self.port, retries=False)
        self.addCleanup(pool.close)
        pool.request('GET', '/')
        self.assert_header_received(
            received_headers, 'Host', '%s:%s' % (self.host, self.port)
        )

    def test_response_headers_are_returned_in_the_original_order(self):
        # NOTE: Probability this test gives a false negative is 1/(K!)
        K = 16
        # NOTE: Provide headers in non-sorted order (i.e. reversed)
        #       so that if the internal implementation tries to sort them,
        #       a change will be detected.
        expected_response_headers = [('X-Header-%d' % i, str(i)) for i in reversed(range(K))]

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(b'HTTP/1.1 200 OK\r\n' +
                      b'\r\n'.join([
                          (k.encode('utf8') + b': ' + v.encode('utf8'))
                          for (k, v) in expected_response_headers
                      ]) +
                      b'\r\n')
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/', retries=0)
        actual_response_headers = [
            (k, v) for (k, v) in r.headers.items()
            if k.startswith('X-Header-')
        ]
        self.assertEqual(expected_response_headers, actual_response_headers)


@pytest.mark.skipif(
    issubclass(httplib.HTTPMessage, MimeToolMessage),
    reason='Header parsing errors not available'
)
class TestBrokenHeaders(SocketDummyServerTestCase):

    def _test_broken_header_parsing(self, headers, unparsed_data_check=None):
        self.start_response_handler((
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 0\r\n'
           b'Content-type: text/plain\r\n'
           ) + b'\r\n'.join(headers) + b'\r\n\r\n'
        )

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)

        with LogRecorder() as logs:
            pool.request('GET', '/')

        for record in logs:
            if 'Failed to parse headers' in record.msg and \
                    pool._absolute_url('/') == record.args[0]:
                if unparsed_data_check is None or unparsed_data_check in record.getMessage():
                    return
        self.fail('Missing log about unparsed headers')

    def test_header_without_name(self):
        self._test_broken_header_parsing([
            b': Value',
            b'Another: Header',
        ])

    def test_header_without_name_or_value(self):
        self._test_broken_header_parsing([
            b':',
            b'Another: Header',
        ])

    def test_header_without_colon_or_value(self):
        self._test_broken_header_parsing([
            b'Broken Header',
            b'Another: Header',
        ], 'Broken Header')


class TestHeaderParsingContentType(SocketDummyServerTestCase):

    def _test_okay_header_parsing(self, header):
        self.start_response_handler((
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 0\r\n'
           ) + header + b'\r\n\r\n'
        )

        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)

        with LogRecorder() as logs:
            pool.request('GET', '/')

        for record in logs:
            assert 'Failed to parse headers' not in record.msg

    def test_header_text_plain(self):
        self._test_okay_header_parsing(b'Content-type: text/plain')

    def test_header_message_rfc822(self):
        self._test_okay_header_parsing(b'Content-type: message/rfc822')


class TestHEAD(SocketDummyServerTestCase):
    def test_chunked_head_response_does_not_hang(self):
        self.start_response_handler(
           b'HTTP/1.1 200 OK\r\n'
           b'Transfer-Encoding: chunked\r\n'
           b'Content-type: text/plain\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        r = pool.request('HEAD', '/', timeout=1, preload_content=False)

        # stream will use the read_chunked method here.
        self.assertEqual([], list(r.stream()))

    def test_empty_head_response_does_not_hang(self):
        self.start_response_handler(
           b'HTTP/1.1 200 OK\r\n'
           b'Content-Length: 256\r\n'
           b'Content-type: text/plain\r\n'
           b'\r\n'
        )
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        r = pool.request('HEAD', '/', timeout=1, preload_content=False)

        # stream will use the read method here.
        self.assertEqual([], list(r.stream()))


class TestStream(SocketDummyServerTestCase):
    def test_stream_none_unchunked_response_does_not_hang(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(
                b'HTTP/1.1 200 OK\r\n'
                b'Content-Length: 12\r\n'
                b'Content-type: text/plain\r\n'
                b'\r\n'
                b'hello, world'
            )
            done_event.wait(5)
            sock.close()

        self._start_server(socket_handler)
        pool = HTTPConnectionPool(self.host, self.port, retries=False)
        self.addCleanup(pool.close)
        r = pool.request('GET', '/', timeout=1, preload_content=False)

        # Stream should read to the end.
        self.assertEqual([b'hello, world'], list(r.stream(None)))

        done_event.set()


class TestBadContentLength(SocketDummyServerTestCase):
    def test_enforce_content_length_get(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(
                b'HTTP/1.1 200 OK\r\n'
                b'Content-Length: 22\r\n'
                b'Content-type: text/plain\r\n'
                b'\r\n'
                b'hello, world'
            )
            done_event.wait(1)
            sock.close()

        self._start_server(socket_handler)
        conn = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(conn.close)

        # Test stream read when content length less than headers claim
        get_response = conn.request('GET', url='/', preload_content=False,
                                    enforce_content_length=True)
        data = get_response.stream(100)
        # Read ""good"" data before we try to read again.
        # This won't trigger till generator is exhausted.
        next(data)
        try:
            next(data)
            self.assertFail()
        except ProtocolError as e:
            self.assertIn('12 bytes read, 10 more expected', str(e))

        done_event.set()

    def test_enforce_content_length_no_body(self):
        done_event = Event()

        def socket_handler(listener):
            sock = listener.accept()[0]

            buf = b''
            while not buf.endswith(b'\r\n\r\n'):
                buf += sock.recv(65536)

            sock.send(
                b'HTTP/1.1 200 OK\r\n'
                b'Content-Length: 22\r\n'
                b'Content-type: text/plain\r\n'
                b'\r\n'
            )
            done_event.wait(1)
            sock.close()

        self._start_server(socket_handler)
        conn = HTTPConnectionPool(self.host, self.port, maxsize=1)
        self.addCleanup(conn.close)

        # Test stream on 0 length body
        head_response = conn.request('HEAD', url='/', preload_content=False,
                                     enforce_content_length=True)
        data = [chunk for chunk in head_response.stream(1)]
        self.assertEqual(len(data), 0)

        done_event.set()


class TestRetryPoolSizeDrainFail(SocketDummyServerTestCase):

    def test_pool_size_retry_drain_fail(self):
        def socket_handler(listener):
            for _ in range(2):
                sock = listener.accept()[0]
                while not sock.recv(65536).endswith(b'\r\n\r\n'):
                    pass

                # send a response with an invalid content length -- this causes
                # a ProtocolError to raise when trying to drain the connection
                sock.send(
                    b'HTTP/1.1 404 NOT FOUND\r\n'
                    b'Content-Length: 1000\r\n'
                    b'Content-Type: text/plain\r\n'
                    b'\r\n'
                )
                sock.close()

        self._start_server(socket_handler)
        retries = Retry(
            total=1,
            raise_on_status=False,
            status_forcelist=[404],
        )
        pool = HTTPConnectionPool(self.host, self.port, maxsize=10,
                                  retries=retries, block=True)
        self.addCleanup(pool.close)

        pool.urlopen('GET', '/not_found', preload_content=False)
        assert pool.num_connections == 1",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"  VAR VAR VAR VAR, VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR ) VAR .. VAR VAR, VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR(VAR): VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR=1\VAR\VAR' VAR'VAR-VAR: VAR=1\VAR\VAR' VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR, {'VAR-VAR': 'VAR=1, VAR=1'}) VAR.VAR(VAR.VAR.VAR('VAR-VAR'), ['VAR=1', 'VAR=1']) VAR VAR(VAR): @VAR.VAR.VAR(VAR VAR, VAR='VAR-VAR VAR VAR') VAR VAR(VAR): VAR = VAR() VAR.VAR = VAR'' VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR = VAR.VAR(65536)  VAR.VAR()  VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR VAR:  VAR VAR.VAR() VAR.VAR(VAR.VAR.VAR('VAR'), VAR.VAR, ""VAR VAR VAR VAR VAR"") VAR VAR(VAR): """""" VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR VAR.VAR( VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR()) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(8192) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 6\VAR\VAR' VAR'\VAR\VAR' VAR'VAR!' ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR.VAR, VAR.VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR='VAR', VAR=VAR, ) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=0) VAR.VAR() VAR.VAR(VAR(VAR), 1) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR()) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(8192) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 6\VAR\VAR' VAR'\VAR\VAR' VAR'VAR!' ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR='VAR', VAR=VAR, ) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=0) VAR.VAR() VAR.VAR(VAR(VAR), 1) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR: VAR.VAR(VAR) VAR VAR.VAR: VAR VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR.VAR, VAR.VAR, VAR='VAR', VAR=VAR, ) VAR.VAR(VAR.VAR) VAR: VAR.VAR('VAR', '/', VAR=0) VAR VAR: VAR.VAR() VAR: VAR.VAR() VAR.VAR( ""VAR VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR"" ) @VAR VAR VAR(VAR): VAR.VAR(VAR""VAR"") @VAR VAR VAR(VAR): VAR.VAR(VAR""VAR"") VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR """""" VAR = VAR() VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR) VAR.VAR(VAR.VAR()) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(8192) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'VAR-VAR: 6\VAR\VAR' VAR'\VAR\VAR' VAR'VAR!' ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR.VAR(VAR.VAR) VAR.VAR( VAR=VAR['VAR'], VAR=VAR, VAR=VAR ) VAR = VAR( VAR.VAR, VAR.VAR, VAR=VAR, VAR='VAR', VAR=VAR, ) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=0) VAR.VAR() VAR.VAR(VAR(VAR), 1) @VAR VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR)  VAR VAR.VAR: VAR VAR.VAR VAR VAR VAR = VAR VAR: VAR = VAR.VAR VAR VAR.VAR(VAR): VAR.VAR(VAR=VAR[""VAR""], VAR=VAR, VAR=VAR'VAR') VAR VAR(VAR): VAR VAR(VAR):    VAR = VAR() VAR VAR(VAR): VAR VAR VAR 0, 1: VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR = 'VAR %VAR' % VAR VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR()  VAR.VAR()  VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR 0') VAR.VAR()  VAR = VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR 1') VAR VAR(VAR):  VAR, VAR = VAR() VAR = VAR(VAR, VAR, VAR=3, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR.VAR.VAR(), VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536).VAR(VAR'\VAR\VAR\VAR\VAR'): VAR VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.01, VAR=VAR, VAR=3, VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR) VAR: VAR.VAR() VAR.VAR(VAR.VAR.VAR(), VAR.VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR.VAR(65536) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.01, VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR: VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR"""""" VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536): VAR VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=0.01, VAR=VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR.VAR()[0] VAR.VAR()  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR = 'VAR 2' VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR()     VAR = VAR.VAR() VAR.VAR(1) VAR: VAR.VAR(VAR) VAR = VAR(VAR=0.001, VAR=0.01) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR 2') VAR: VAR.VAR(VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR = 'VAR' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' % VAR(VAR)).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR.VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.01)) VAR: VAR.VAR(VAR, VAR.VAR) VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR = 'VAR' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' % VAR(VAR)).VAR('VAR-8')) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR: VAR.VAR(VAR, VAR.VAR, 'VAR', '/', VAR=VAR, VAR=VAR(VAR=1, VAR=0.01)) VAR: VAR.VAR() VAR VAR(VAR): VAR = 'VAR' VAR = VAR[:2] VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8') ) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR, VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR.VAR VAR VAR """""" VAR VAR(VAR): VAR = VAR.VAR()[0]   VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR = ""VAR VAR 0.5 VAR"" VAR.VAR(('VAR/0.5 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' 'VAR' % (VAR('VAR'))).VAR('VAR-8')) VAR.VAR()  VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR(VAR=1) VAR = VAR.VAR('VAR', '/', VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR.VAR, VAR'VAR') VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR = 'VAR' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' % VAR(VAR)).VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR() VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.01)) VAR: VAR.VAR(VAR, VAR.VAR) VAR.VAR(VAR, VAR.VAR.VAR()) VAR: VAR.VAR() VAR VAR(VAR): VAR = 'VAR' VAR = VAR[:2] VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536)  VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR)).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR() VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(VAR, VAR.VAR.VAR()) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65535)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: VAR\VAR\VAR' '\VAR\VAR' '8\VAR\VAR' '12345678\VAR\VAR').VAR('VAR-8') ) VAR.VAR(5)     VAR, VAR, VAR = VAR.VAR([VAR], [], [], 1) VAR VAR VAR = VAR.VAR()[0]  VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65535)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: VAR\VAR\VAR' '\VAR\VAR' '8\VAR\VAR' '12345678\VAR\VAR' '0\VAR\VAR\VAR\VAR').VAR('VAR-8') ) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR) VAR VAR:  VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.1)) VAR: VAR.VAR(VAR, VAR.VAR) VAR: VAR.VAR()  VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=1)) VAR.VAR(VAR(VAR.VAR()), 8) VAR VAR(VAR): VAR = VAR() VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR = VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 0\VAR\VAR' '\VAR\VAR').VAR('VAR-8'))  VAR.VAR(VAR=1)   VAR.VAR(1) VAR = VAR.VAR(65536) VAR.VAR(VAR) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR) VAR.VAR(VAR.VAR, 200) VAR.VAR() VAR.VAR()  VAR = VAR.VAR(VAR=1) VAR VAR VAR: VAR.VAR(""VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR): """"""VAR VAR ```VAR(VAR=VAR)```, VAR VAR VAR'VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR: VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR  VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR. [1] <VAR: """""" VAR VAR(VAR): VAR = VAR.VAR()[0] VAR(VAR)    VAR.VAR()    VAR, VAR, VAR = VAR.VAR([VAR], [], [], 5) VAR VAR VAR = VAR.VAR()[0] VAR(VAR)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: VAR\VAR\VAR' '\VAR\VAR' '8\VAR\VAR' '12345678\VAR\VAR' '0\VAR\VAR\VAR\VAR').VAR('VAR-8') ) VAR.VAR() VAR.VAR(VAR) VAR VAR(VAR.VAR, VAR.VAR, VAR=1) VAR VAR:   VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR, VAR=VAR, VAR=VAR(VAR=1, VAR=0.01))   VAR.VAR(VAR.VAR, 2) VAR.VAR(VAR.VAR.VAR(), 0) VAR.VAR(VAR.VAR)  VAR.VAR() VAR.VAR(VAR.VAR.VAR(), 1) VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR.VAR('VAR-8'))).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200)    VAR.VAR(VAR(VAR.VAR.VAR(VAR'\VAR\VAR')), VAR([ VAR'VAR VAR: VAR'VAR: VAR.VAR', VAR'VAR-VAR: VAR', VAR'VAR: */*', VAR'', VAR'', ])) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR.VAR('VAR-8'))).VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = 'VAR:  VAR = VAR({'VAR VAR VAR': 'VAR!'}) VAR = VAR(VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR: VAR = VAR.VAR('VAR', 'VAR: VAR.VAR(VAR.VAR, 200)    VAR.VAR(VAR'VAR VAR VAR: VAR!\VAR\VAR', VAR.VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0]  VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: %VAR\VAR\VAR' '\VAR\VAR' '%VAR' % (VAR(VAR), VAR.VAR('VAR-8'))).VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR: VAR = VAR.VAR('VAR', 'VAR: VAR=VAR, VAR=1) VAR.VAR(VAR.VAR, 200) VAR.VAR(VAR=1) VAR.VAR(VAR, VAR.VAR, 'VAR', 'VAR: VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = VAR.VAR('VAR-8') VAR VAR VAR.VAR('VAR '): VAR.VAR(('VAR/1.1 405 VAR VAR VAR\VAR\VAR' 'VAR: VAR\VAR\VAR\VAR\VAR').VAR('VAR-8')) VAR.VAR() VAR VAR VAR VAR.VAR('VAR %VAR:443' % (VAR.VAR,)): VAR.VAR(('VAR/1.1 403 VAR\VAR\VAR\VAR\VAR').VAR('VAR-8')) VAR.VAR() VAR VAR.VAR(('VAR/1.1 200 VAR VAR\VAR\VAR\VAR\VAR').VAR('VAR-8')) VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(('VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 2\VAR\VAR' 'VAR: VAR\VAR\VAR' '\VAR\VAR' 'VAR').VAR('VAR-8')) VAR.VAR() VAR VAR(VAR): VAR(VAR) VAR(VAR) VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = 'VAR: VAR = VAR.VAR(VAR) VAR = VAR.VAR('VAR', VAR, VAR=0) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR('VAR', VAR, VAR=0) VAR.VAR(VAR.VAR, 200) VAR VAR(VAR): VAR = '2001:4998:VAR:VAR::2:4008' VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = VAR.VAR('VAR-8') VAR VAR.VAR('VAR [%VAR]:443' % (VAR,)): VAR.VAR(VAR'VAR/1.1 200 VAR VAR\VAR\VAR\VAR\VAR') VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR']) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 2\VAR\VAR' VAR'VAR: VAR\VAR\VAR' VAR'\VAR\VAR' VAR'VAR') VAR.VAR() VAR: VAR.VAR() VAR.VAR(VAR) VAR = 'VAR: VAR = VAR(VAR, VAR='VAR') VAR.VAR(VAR.VAR) VAR = 'VAR: VAR = VAR.VAR(VAR) VAR: VAR = VAR.VAR('VAR', VAR, VAR=0) VAR.VAR(VAR.VAR, 200) VAR VAR: VAR.VAR('VAR VAR VAR VAR VAR VAR VAR') VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR() VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 2\VAR\VAR' '\VAR\VAR' 'VAR').VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR('VAR', '/', VAR=0) VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR']) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 10\VAR\VAR' '\VAR\VAR' 'VAR-').VAR('VAR-8')) VAR.VAR() VAR.VAR() VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0, VAR=VAR, VAR=VAR(VAR=1, VAR=0.01)) VAR: VAR.VAR(VAR, VAR.VAR) VAR: VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR'], VAR=VAR) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 5\VAR\VAR\VAR\VAR' VAR'VAR') VAR.VAR() VAR.VAR() VAR.VAR(VAR)  VAR = ('VAR:VAR:VAR:46:00:VAR:VAR:2D:VAR:VAR:VAR' ':9A:8C:VAR:07:VAR:58:VAR:74:5E') VAR VAR(): VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR: VAR = VAR.VAR('VAR', '/', VAR=VAR, VAR=VAR(VAR=1, VAR=0.01), VAR=0) VAR.VAR() VAR: VAR.VAR() VAR VAR.VAR(VAR) VAR VAR: VAR() VAR.VAR(VAR.VAR.VAR, VAR)  VAR.VAR(VAR, VAR) VAR VAR(VAR): VAR VAR(VAR):  VAR = VAR.VAR()[0] VAR = VAR.VAR() VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR']) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536)  VAR.VAR(( 'VAR/1.1 200 VAR\VAR\VAR' 'VAR-VAR: VAR/VAR\VAR\VAR' 'VAR-VAR: 4\VAR\VAR' '\VAR\VAR' 'VAR').VAR('VAR-8')) VAR.VAR() VAR.VAR()  VAR = VAR.VAR()[0] VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR['VAR'], VAR=VAR['VAR']) VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'VAR-VAR: 7\VAR\VAR\VAR\VAR' VAR'VAR') VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1) VAR.VAR(VAR.VAR, VAR'VAR') VAR VAR(VAR): VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 VAR VAR VAR VAR?\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR VAR(VAR): VAR.VAR( VAR'VAR/1000 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR(VAR, VAR.VAR, 'VAR', '/') VAR VAR(VAR): @VAR VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = {'VAR-VAR': '0', 'VAR-VAR': 'VAR/VAR'} VAR = VAR.VAR('VAR', '/') VAR.VAR(VAR, VAR(VAR.VAR.VAR()))  VAR VAR(VAR): VAR = {'VAR': 'VAR', 'VAR': 'VAR'} VAR = {} VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = [VAR VAR VAR VAR VAR.VAR(VAR'\VAR\VAR')[1:] VAR VAR] VAR VAR VAR VAR: (VAR, VAR) = VAR.VAR(VAR': ') VAR[VAR.VAR('VAR')] = VAR.VAR('VAR') VAR.VAR(( 'VAR/1.1 204 VAR VAR\VAR\VAR' 'VAR-VAR: 0\VAR\VAR' '\VAR\VAR').VAR('VAR-8')) VAR.VAR() VAR.VAR(VAR) VAR = {'VAR-VAR': 'VAR', 'VAR': '{0}:{1}'.VAR(VAR.VAR, VAR.VAR)} VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=VAR(VAR)) VAR.VAR(VAR, VAR) VAR VAR(VAR):  VAR = 16    VAR = [(VAR'VAR-VAR-%VAR' % VAR, VAR(VAR)) VAR VAR VAR VAR(VAR(VAR))] VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR = [VAR VAR VAR VAR VAR.VAR(VAR'\VAR\VAR')[1:] VAR VAR] VAR VAR VAR VAR: (VAR, VAR) = VAR.VAR(VAR': ') VAR VAR VAR.VAR('VAR').VAR(VAR'VAR-VAR-'): VAR VAR.VAR((VAR.VAR('VAR'), VAR.VAR('VAR'))) VAR.VAR(( VAR'VAR/1.1 204 VAR VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR').VAR('VAR')) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/', VAR=VAR(VAR)) VAR.VAR(VAR, VAR) @VAR VAR VAR(VAR): VAR = [] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR VAR VAR VAR.VAR(VAR'\VAR\VAR')[1:]: VAR VAR: VAR.VAR(VAR) VAR.VAR(( VAR'VAR/1.1 204 VAR VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'\VAR\VAR').VAR('VAR')) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR + '.', VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/') VAR.VAR( VAR, 'VAR', '%VAR:%VAR' % (VAR.VAR, VAR.VAR) ) VAR VAR(VAR):  VAR = 16    VAR = [('VAR-VAR-%VAR' % VAR, VAR(VAR)) VAR VAR VAR VAR(VAR(VAR))] VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR(VAR'VAR/1.1 200 VAR\VAR\VAR' + VAR'\VAR\VAR'.VAR([ (VAR.VAR('VAR') + VAR': ' + VAR.VAR('VAR')) VAR (VAR, VAR) VAR VAR ]) + VAR'\VAR\VAR') VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=0) VAR = [ (VAR, VAR) VAR (VAR, VAR) VAR VAR.VAR.VAR() VAR VAR.VAR('VAR-VAR-') ] VAR.VAR(VAR, VAR) @VAR.VAR.VAR( VAR(VAR.VAR, VAR), VAR='VAR VAR VAR VAR VAR' ) VAR VAR(VAR): VAR VAR(VAR, VAR, VAR=VAR): VAR.VAR(( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' ) + VAR'\VAR\VAR'.VAR(VAR) + VAR'\VAR\VAR\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR() VAR VAR: VAR.VAR('VAR', '/') VAR VAR VAR VAR: VAR 'VAR VAR VAR VAR' VAR VAR.VAR VAR \ VAR.VAR('/') == VAR.VAR[0]: VAR VAR VAR VAR VAR VAR VAR VAR.VAR(): VAR VAR.VAR('VAR VAR VAR VAR VAR') VAR VAR(VAR): VAR.VAR([ VAR': VAR', VAR'VAR: VAR', ]) VAR VAR(VAR): VAR.VAR([ VAR':', VAR'VAR: VAR', ]) VAR VAR(VAR): VAR.VAR([ VAR'VAR VAR', VAR'VAR: VAR', ], 'VAR VAR') VAR VAR(VAR): VAR VAR(VAR, VAR): VAR.VAR(( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 0\VAR\VAR' ) + VAR + VAR'\VAR\VAR\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR VAR() VAR VAR: VAR.VAR('VAR', '/') VAR VAR VAR VAR: VAR 'VAR VAR VAR VAR' VAR VAR VAR.VAR VAR VAR(VAR): VAR.VAR(VAR'VAR-VAR: VAR/VAR') VAR VAR(VAR): VAR.VAR(VAR'VAR-VAR: VAR/VAR') VAR VAR(VAR): VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: VAR\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR)  VAR.VAR([], VAR(VAR.VAR())) VAR VAR(VAR): VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 256\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR)  VAR.VAR([], VAR(VAR.VAR())) VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 12\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' VAR'VAR, VAR' ) VAR.VAR(5) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR = VAR.VAR('VAR', '/', VAR=1, VAR=VAR)  VAR.VAR([VAR'VAR, VAR'], VAR(VAR.VAR(VAR))) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 22\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' VAR'VAR, VAR' ) VAR.VAR(1) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR)  VAR = VAR.VAR('VAR', VAR='/', VAR=VAR, VAR=VAR) VAR = VAR.VAR(100)   VAR(VAR) VAR: VAR(VAR) VAR.VAR() VAR VAR VAR VAR: VAR.VAR('12 VAR VAR, 10 VAR VAR', VAR(VAR)) VAR.VAR() VAR VAR(VAR): VAR = VAR() VAR VAR(VAR): VAR = VAR.VAR()[0] VAR = VAR'' VAR VAR VAR.VAR(VAR'\VAR\VAR\VAR\VAR'): VAR += VAR.VAR(65536) VAR.VAR( VAR'VAR/1.1 200 VAR\VAR\VAR' VAR'VAR-VAR: 22\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR.VAR(1) VAR.VAR() VAR.VAR(VAR) VAR = VAR(VAR.VAR, VAR.VAR, VAR=1) VAR.VAR(VAR.VAR)  VAR = VAR.VAR('VAR', VAR='/', VAR=VAR, VAR=VAR) VAR = [VAR VAR VAR VAR VAR.VAR(1)] VAR.VAR(VAR(VAR), 0) VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR VAR(VAR): VAR VAR VAR VAR(2): VAR = VAR.VAR()[0] VAR VAR VAR.VAR(65536).VAR(VAR'\VAR\VAR\VAR\VAR'): VAR   VAR.VAR( VAR'VAR/1.1 404 VAR VAR\VAR\VAR' VAR'VAR-VAR: 1000\VAR\VAR' VAR'VAR-VAR: VAR/VAR\VAR\VAR' VAR'\VAR\VAR' ) VAR.VAR() VAR.VAR(VAR) VAR = VAR( VAR=1, VAR=VAR, VAR=[404], ) VAR = VAR(VAR.VAR, VAR.VAR, VAR=10, VAR=VAR, VAR=VAR) VAR.VAR(VAR.VAR) VAR.VAR('VAR', '/VAR', VAR=VAR) VAR VAR.VAR == 1 ",8
urllib3_adb358f8e06865406d1f05e581a16cbea2136fbc,test/with_dummyserver/test_poolmanager.py,"        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'authorization': 'foo'})

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('authorization', data)
        self.assertNotIn('Authorization', data)

        r = http.request('GET', '%s/redirect' % self.base_url,
                         fields={'target': '%s/headers' % self.base_url_alt},
                         headers={'x-api-secret': 'foo',
                                  'authorization': 'bar'},
                         retries=Retry(remove_headers_on_redirect=['X-API-Secret']))

        self.assertEqual(r.status, 200)

        data = json.loads(r.data.decode('utf-8'))

        self.assertNotIn('x-api-secret', data)
        self.assertNotIn('X-API-Secret', data)
        self.assertEqual(data['Authorization'], 'bar')
",,adb358f8e06865406d1f05e581a16cbea2136fbc,CVE-2018-25091,adb358f8e06865406d1f05e581a16cbea2136fbc,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR': 'VAR'}) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR', VAR) VAR.VAR('VAR', VAR) VAR = VAR.VAR('VAR', '%VAR/VAR' % VAR.VAR, VAR={'VAR': '%VAR/VAR' % VAR.VAR}, VAR={'VAR-VAR-VAR': 'VAR', 'VAR': 'VAR'}, VAR=VAR(VAR=['VAR-VAR-VAR'])) VAR.VAR(VAR.VAR, 200) VAR = VAR.VAR(VAR.VAR.VAR('VAR-8')) VAR.VAR('VAR-VAR-VAR', VAR) VAR.VAR('VAR-VAR-VAR', VAR) VAR.VAR(VAR['VAR'], 'VAR') ",8
vim_0ff01835a40f549c5c4a550502f62a2ac9ac447c,src/testdir/test_ins_complete.vim,"  call TermWait(buf, 200)
func s:Tagfunc(t,f,o)
  bwipe!
  return []
endfunc

"" This was using freed memory, since 'complete' was in a wiped out buffer.
"" Also using a window that was closed.
func Test_tagfunc_wipes_out_buffer()
  new
  set complete=.,t,w,b,u,i
  se tagfunc=s:Tagfunc
  sil norm i

  bwipe!
endfunc

","  call TermWait(buf, 50)
  call TermWait(buf, 100)",0ff01835a40f549c5c4a550502f62a2ac9ac447c,CVE-2022-3297,0ff01835a40f549c5c4a550502f62a2ac9ac447c,https://github.com/vim/vim,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR(VAR, 200) VAR VAR:VAR(VAR,VAR,VAR) VAR! VAR [] VAR "" VAR VAR VAR VAR VAR, VAR 'VAR' VAR VAR VAR VAR VAR VAR. "" VAR VAR VAR VAR VAR VAR VAR. VAR VAR() VAR VAR VAR=.,VAR,VAR,VAR,VAR,VAR VAR VAR=VAR:VAR VAR VAR VAR VAR! VAR VAR VAR(VAR, 50) VAR VAR(VAR, 100)",8

commit,file,added_code,deleted_code,hash_clean,cve_id,hash,repo_url,rel_type,score,extraction_status,text_norm,cluster_kmeans
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/workspace.js,"const slugify = require(""slugify"");
const { Document } = require(""./documents"");
const { checkForMigrations } = require(""../utils/database"");
const { WorkspaceUser } = require(""./workspaceUsers"");

const Workspace = {
  tablename: ""workspaces"",
  writable: [
    // Used for generic updates so we can validate keys in request body
    ""name"",
    ""slug"",
    ""vectorTag"",
    ""openAiTemp"",
    ""openAiHistory"",
    ""lastUpdatedAt"",
    ""openAiPrompt"",
  ],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  vectorTag TEXT DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  openAiTemp REAL DEFAULT NULL,
  openAiHistory INTEGER DEFAULT 20,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
  openAiPrompt TEXT DEFAULT NULL
  `,
  migrateTable: async function () {
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for Workspace migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [
      {
        colName: ""openAiTemp"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN openAiTemp REAL DEFAULT NULL`,
        doif: false,
      },
      {
        colName: ""openAiPrompt"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN openAiPrompt TEXT DEFAULT NULL`,
        doif: false,
      },
      {
        colName: ""id"",
        execCmd: `CREATE TRIGGER IF NOT EXISTS Trg_LastUpdated AFTER UPDATE ON ${this.tablename}
                                 FOR EACH ROW
                                 BEGIN
                                  UPDATE ${this.tablename} SET lastUpdatedAt = CURRENT_TIMESTAMP WHERE id = old.id;
                                 END`,
        doif: true,
      },
      {
        colName: ""openAiHistory"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN openAiHistory INTEGER DEFAULT 20`,
        doif: false,
      },
    ];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  new: async function (name = null, creatorId = null) {
    if (!name) return { result: null, message: ""name cannot be null"" };
    var slug = slugify(name, { lower: true });

    const existingBySlug = await this.get(`slug = '${slug}'`);
    if (existingBySlug !== null) {
      const slugSeed = Math.floor(10000000 + Math.random() * 90000000);
      slug = slugify(`${name}-${slugSeed}`, { lower: true });
    }

    const db = await this.db();
    const { id, success, message } = await db
      .run(`INSERT INTO ${this.tablename} (name, slug) VALUES (?, ?)`, [
        name,
        slug,
      ])
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      return { workspace: null, message };
    }

    const workspace = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id}`
    );
    db.close();

    // If created with a user then we need to create the relationship as well.
    // If creating with an admin User it wont change anything because admins can
    // view all workspaces anyway.
    if (!!creatorId) await WorkspaceUser.create(creatorId, workspace.id);
    return { workspace, message: null };
  },
  update: async function (id = null, data = {}) {
    if (!id) throw new Error(""No workspace id provided for update"");

    const validKeys = Object.keys(data).filter((key) =>
      this.writable.includes(key)
    );
    const values = Object.values(data);
    if (validKeys.length === 0 || validKeys.length !== values.length)
      return { workspace: { id }, message: ""No valid fields to update!"" };

    const template = `UPDATE ${this.tablename} SET ${validKeys.map((key) => {
      return `${key}=?`;
    })} WHERE id = ?`;
    const db = await this.db();
    const { success, message } = await db
      .run(template, [...values, id])
      .then(() => {
        return { success: true, message: null };
      })
      .catch((error) => {
        return { success: false, message: error.message };
      });

    db.close();
    if (!success) {
      return { workspace: null, message };
    }

    const updatedWorkspace = await this.get(`id = ${id}`);
    return { workspace: updatedWorkspace, message: null };
  },
  getWithUser: async function (user = null, clause = """") {
    if (user.role === ""admin"") return this.get(clause);

    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} as workspace
      LEFT JOIN workspace_users as ws_users
      ON ws_users.workspace_id = workspace.id
      WHERE ws_users.user_id = ${user?.id} AND ${clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    const workspace = { ...result, id: result.workspace_id };
    const documents = await Document.forWorkspace(workspace.id);
    return { ...workspace, documents };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    const documents = await Document.forWorkspace(result.id);
    return { ...result, documents };
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null, orderBy = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      } ${!!orderBy ? orderBy : """"}`
    );
    db.close();

    return results;
  },
  whereWithUser: async function (
    user,
    clause = null,
    limit = null,
    orderBy = null
  ) {
    if (user.role === ""admin"") return await this.where(clause, limit);
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} as workspace
      LEFT JOIN workspace_users as ws_users
      ON ws_users.workspace_id = workspace.id
      WHERE ws_users.user_id = ${user.id} ${clause ? `AND ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      } ${!!orderBy ? orderBy : """"}`
    );
    db.close();
    const workspaces = results.map((ws) => {
      return { ...ws, id: ws.workspace_id };
    });

    return workspaces;
  },
  whereWithUsers: async function (clause = """", limit = null, orderBy = null) {
    const workspaces = await this.where(clause, limit, orderBy);
    for (const workspace of workspaces) {
      const userIds = (
        await WorkspaceUser.where(`workspace_id = ${workspace.id}`)
      ).map((rel) => rel.user_id);
      workspace.userIds = userIds;
    }
    return workspaces;
  },
  updateUsers: async function (workspaceId, userIds = []) {
    await WorkspaceUser.delete(`workspace_id = ${workspaceId}`);
    await WorkspaceUser.createManyUsers(userIds, workspaceId);
    return { success: true, error: null };
  },
};

module.exports = { Workspace };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = VAR(""VAR""); VAR { VAR } = VAR(""./VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""./VAR""); VAR VAR = { VAR: ""VAR"", VAR: [  ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR 20, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR [ { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR`, VAR: VAR, }, { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR`, VAR: VAR, }, { VAR: ""VAR"", VAR: `VAR VAR VAR VAR VAR VAR VAR VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR ${VAR.VAR} VAR VAR = VAR VAR VAR = VAR.VAR; VAR`, VAR: VAR, }, { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR 20`, VAR: VAR, }, ]; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR"" }; VAR VAR = VAR(VAR, { VAR: VAR }); VAR VAR = VAR VAR.VAR(`VAR = '${VAR}'`); VAR (VAR !== VAR) { VAR VAR = VAR.VAR(10000000 + VAR.VAR() * 90000000); VAR = VAR(`${VAR}-${VAR}`, { VAR: VAR }); } VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?, ?)`, [ VAR, VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR { VAR: VAR, VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR}` ); VAR.VAR();    VAR (!!VAR) VAR VAR.VAR(VAR, VAR.VAR); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR, VAR = {}) { VAR (!VAR) VAR VAR VAR(""VAR VAR VAR VAR VAR VAR""); VAR VAR = VAR.VAR(VAR).VAR((VAR) => VAR.VAR.VAR(VAR) ); VAR VAR = VAR.VAR(VAR); VAR (VAR.VAR === 0 || VAR.VAR !== VAR.VAR) VAR { VAR: { VAR }, VAR: ""VAR VAR VAR VAR VAR!"" }; VAR VAR = `VAR ${VAR.VAR} VAR ${VAR.VAR((VAR) => { VAR `${VAR}=?`; })} VAR VAR = ?`; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(VAR, [...VAR, VAR]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR { VAR: VAR, VAR }; } VAR VAR = VAR VAR.VAR(`VAR = ${VAR}`); VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR, VAR = """") { VAR (VAR.VAR === ""VAR"") VAR VAR.VAR(VAR); VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR = VAR.VAR VAR VAR.VAR = ${VAR?.VAR} VAR ${VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR = { ...VAR, VAR: VAR.VAR }; VAR VAR = VAR VAR.VAR(VAR.VAR); VAR { ...VAR, VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR = VAR VAR.VAR(VAR.VAR); VAR { ...VAR, VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" } ${!!VAR ? VAR : """"}` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR ( VAR, VAR = VAR, VAR = VAR, VAR = VAR ) { VAR (VAR.VAR === ""VAR"") VAR VAR VAR.VAR(VAR, VAR); VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR = VAR.VAR VAR VAR.VAR = ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" } ${!!VAR ? VAR : """"}` ); VAR.VAR(); VAR VAR = VAR.VAR((VAR) => { VAR { ...VAR, VAR: VAR.VAR }; }); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(VAR, VAR, VAR); VAR (VAR VAR VAR VAR) { VAR VAR = ( VAR VAR.VAR(`VAR = ${VAR.VAR}`) ).VAR((VAR) => VAR.VAR); VAR.VAR = VAR; } VAR VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR VAR.VAR(`VAR = ${VAR}`); VAR VAR.VAR(VAR, VAR); VAR { VAR: VAR, VAR: VAR }; }, }; VAR.VAR = { VAR }; ",7
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/workspace.js,"const slugify = require(""slugify"");
const { Document } = require(""./documents"");
const { checkForMigrations } = require(""../utils/database"");
const { WorkspaceUser } = require(""./workspaceUsers"");
const { escape } = require(""sqlstring-sqlite"");

const Workspace = {
  tablename: ""workspaces"",
  writable: [
    // Used for generic updates so we can validate keys in request body
    ""name"",
    ""slug"",
    ""vectorTag"",
    ""openAiTemp"",
    ""openAiHistory"",
    ""lastUpdatedAt"",
    ""openAiPrompt"",
  ],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  vectorTag TEXT DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  openAiTemp REAL DEFAULT NULL,
  openAiHistory INTEGER DEFAULT 20,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
  openAiPrompt TEXT DEFAULT NULL
  `,
  migrateTable: async function () {
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for Workspace migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [
      {
        colName: ""openAiTemp"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN openAiTemp REAL DEFAULT NULL`,
        doif: false,
      },
      {
        colName: ""openAiPrompt"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN openAiPrompt TEXT DEFAULT NULL`,
        doif: false,
      },
      {
        colName: ""id"",
        execCmd: `CREATE TRIGGER IF NOT EXISTS Trg_LastUpdated AFTER UPDATE ON ${this.tablename}
                                 FOR EACH ROW
                                 BEGIN
                                  UPDATE ${this.tablename} SET lastUpdatedAt = CURRENT_TIMESTAMP WHERE id = old.id;
                                 END`,
        doif: true,
      },
      {
        colName: ""openAiHistory"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN openAiHistory INTEGER DEFAULT 20`,
        doif: false,
      },
    ];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  new: async function (name = null, creatorId = null) {
    if (!name) return { result: null, message: ""name cannot be null"" };
    var slug = slugify(name, { lower: true });

    const existingBySlug = await this.get(`slug = ${escape(slug)}`);
    if (existingBySlug !== null) {
      const slugSeed = Math.floor(10000000 + Math.random() * 90000000);
      slug = slugify(`${name}-${slugSeed}`, { lower: true });
    }

    const db = await this.db();
    const { id, success, message } = await db
      .run(`INSERT INTO ${this.tablename} (name, slug) VALUES (?, ?)`, [
        name,
        slug,
      ])
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      return { workspace: null, message };
    }

    const workspace = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id}`
    );
    db.close();

    // If created with a user then we need to create the relationship as well.
    // If creating with an admin User it wont change anything because admins can
    // view all workspaces anyway.
    if (!!creatorId) await WorkspaceUser.create(creatorId, workspace.id);
    return { workspace, message: null };
  },
  update: async function (id = null, data = {}) {
    if (!id) throw new Error(""No workspace id provided for update"");

    const validKeys = Object.keys(data).filter((key) =>
      this.writable.includes(key)
    );
    const values = Object.values(data);
    if (validKeys.length === 0 || validKeys.length !== values.length)
      return { workspace: { id }, message: ""No valid fields to update!"" };

    const template = `UPDATE ${this.tablename} SET ${validKeys.map((key) => {
      return `${key}=?`;
    })} WHERE id = ?`;
    const db = await this.db();
    const { success, message } = await db
      .run(template, [...values, id])
      .then(() => {
        return { success: true, message: null };
      })
      .catch((error) => {
        return { success: false, message: error.message };
      });

    db.close();
    if (!success) {
      return { workspace: null, message };
    }

    const updatedWorkspace = await this.get(`id = ${id}`);
    return { workspace: updatedWorkspace, message: null };
  },
  getWithUser: async function (user = null, clause = """") {
    if (user.role === ""admin"") return this.get(clause);

    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} as workspace
      LEFT JOIN workspace_users as ws_users
      ON ws_users.workspace_id = workspace.id
      WHERE ws_users.user_id = ${user?.id} AND ${clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    const workspace = { ...result, id: result.workspace_id };
    const documents = await Document.forWorkspace(workspace.id);
    return { ...workspace, documents };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    const documents = await Document.forWorkspace(result.id);
    return { ...result, documents };
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null, orderBy = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      } ${!!orderBy ? orderBy : """"}`
    );
    db.close();

    return results;
  },
  whereWithUser: async function (
    user,
    clause = null,
    limit = null,
    orderBy = null
  ) {
    if (user.role === ""admin"") return await this.where(clause, limit);
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} as workspace
      LEFT JOIN workspace_users as ws_users
      ON ws_users.workspace_id = workspace.id
      WHERE ws_users.user_id = ${user.id} ${clause ? `AND ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      } ${!!orderBy ? orderBy : """"}`
    );
    db.close();
    const workspaces = results.map((ws) => {
      return { ...ws, id: ws.workspace_id };
    });

    return workspaces;
  },
  whereWithUsers: async function (clause = """", limit = null, orderBy = null) {
    const workspaces = await this.where(clause, limit, orderBy);
    for (const workspace of workspaces) {
      const userIds = (
        await WorkspaceUser.where(`workspace_id = ${workspace.id}`)
      ).map((rel) => rel.user_id);
      workspace.userIds = userIds;
    }
    return workspaces;
  },
  updateUsers: async function (workspaceId, userIds = []) {
    await WorkspaceUser.delete(`workspace_id = ${workspaceId}`);
    await WorkspaceUser.createManyUsers(userIds, workspaceId);
    return { success: true, error: null };
  },
};

module.exports = { Workspace };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = VAR(""VAR""); VAR { VAR } = VAR(""./VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""./VAR""); VAR { VAR } = VAR(""VAR-VAR""); VAR VAR = { VAR: ""VAR"", VAR: [  ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR 20, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR [ { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR`, VAR: VAR, }, { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR`, VAR: VAR, }, { VAR: ""VAR"", VAR: `VAR VAR VAR VAR VAR VAR VAR VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR ${VAR.VAR} VAR VAR = VAR VAR VAR = VAR.VAR; VAR`, VAR: VAR, }, { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR 20`, VAR: VAR, }, ]; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR"" }; VAR VAR = VAR(VAR, { VAR: VAR }); VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (VAR !== VAR) { VAR VAR = VAR.VAR(10000000 + VAR.VAR() * 90000000); VAR = VAR(`${VAR}-${VAR}`, { VAR: VAR }); } VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?, ?)`, [ VAR, VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR { VAR: VAR, VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR}` ); VAR.VAR();    VAR (!!VAR) VAR VAR.VAR(VAR, VAR.VAR); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR, VAR = {}) { VAR (!VAR) VAR VAR VAR(""VAR VAR VAR VAR VAR VAR""); VAR VAR = VAR.VAR(VAR).VAR((VAR) => VAR.VAR.VAR(VAR) ); VAR VAR = VAR.VAR(VAR); VAR (VAR.VAR === 0 || VAR.VAR !== VAR.VAR) VAR { VAR: { VAR }, VAR: ""VAR VAR VAR VAR VAR!"" }; VAR VAR = `VAR ${VAR.VAR} VAR ${VAR.VAR((VAR) => { VAR `${VAR}=?`; })} VAR VAR = ?`; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(VAR, [...VAR, VAR]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR { VAR: VAR, VAR }; } VAR VAR = VAR VAR.VAR(`VAR = ${VAR}`); VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR, VAR = """") { VAR (VAR.VAR === ""VAR"") VAR VAR.VAR(VAR); VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR = VAR.VAR VAR VAR.VAR = ${VAR?.VAR} VAR ${VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR = { ...VAR, VAR: VAR.VAR }; VAR VAR = VAR VAR.VAR(VAR.VAR); VAR { ...VAR, VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR = VAR VAR.VAR(VAR.VAR); VAR { ...VAR, VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" } ${!!VAR ? VAR : """"}` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR ( VAR, VAR = VAR, VAR = VAR, VAR = VAR ) { VAR (VAR.VAR === ""VAR"") VAR VAR VAR.VAR(VAR, VAR); VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR = VAR.VAR VAR VAR.VAR = ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" } ${!!VAR ? VAR : """"}` ); VAR.VAR(); VAR VAR = VAR.VAR((VAR) => { VAR { ...VAR, VAR: VAR.VAR }; }); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(VAR, VAR, VAR); VAR (VAR VAR VAR VAR) { VAR VAR = ( VAR VAR.VAR(`VAR = ${VAR.VAR}`) ).VAR((VAR) => VAR.VAR); VAR.VAR = VAR; } VAR VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR VAR.VAR(`VAR = ${VAR}`); VAR VAR.VAR(VAR, VAR); VAR { VAR: VAR, VAR: VAR }; }, }; VAR.VAR = { VAR }; ",7
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/workspace.js,"const slugify = require(""slugify"");
const { Document } = require(""./documents"");
const { checkForMigrations } = require(""../utils/database"");
const { WorkspaceUser } = require(""./workspaceUsers"");
const { escape } = require(""sqlstring-sqlite"");

const Workspace = {
  tablename: ""workspaces"",
  writable: [
    // Used for generic updates so we can validate keys in request body
    ""name"",
    ""slug"",
    ""vectorTag"",
    ""openAiTemp"",
    ""openAiHistory"",
    ""lastUpdatedAt"",
    ""openAiPrompt"",
  ],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  name TEXT NOT NULL,
  slug TEXT NOT NULL UNIQUE,
  vectorTag TEXT DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  openAiTemp REAL DEFAULT NULL,
  openAiHistory INTEGER DEFAULT 20,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP,
  openAiPrompt TEXT DEFAULT NULL
  `,
  migrateTable: async function () {
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for Workspace migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [
      {
        colName: ""openAiTemp"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN openAiTemp REAL DEFAULT NULL`,
        doif: false,
      },
      {
        colName: ""openAiPrompt"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN openAiPrompt TEXT DEFAULT NULL`,
        doif: false,
      },
      {
        colName: ""id"",
        execCmd: `CREATE TRIGGER IF NOT EXISTS Trg_LastUpdated AFTER UPDATE ON ${this.tablename}
                                 FOR EACH ROW
                                 BEGIN
                                  UPDATE ${this.tablename} SET lastUpdatedAt = CURRENT_TIMESTAMP WHERE id = old.id;
                                 END`,
        doif: true,
      },
      {
        colName: ""openAiHistory"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN openAiHistory INTEGER DEFAULT 20`,
        doif: false,
      },
    ];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  new: async function (name = null, creatorId = null) {
    if (!name) return { result: null, message: ""name cannot be null"" };
    var slug = slugify(name, { lower: true });

    const existingBySlug = await this.get(`slug = ${escape(slug)}`);
    if (existingBySlug !== null) {
      const slugSeed = Math.floor(10000000 + Math.random() * 90000000);
      slug = slugify(`${name}-${slugSeed}`, { lower: true });
    }

    const db = await this.db();
    const { id, success, message } = await db
      .run(`INSERT INTO ${this.tablename} (name, slug) VALUES (?, ?)`, [
        name,
        slug,
      ])
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      return { workspace: null, message };
    }

    const workspace = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id}`
    );
    db.close();

    // If created with a user then we need to create the relationship as well.
    // If creating with an admin User it wont change anything because admins can
    // view all workspaces anyway.
    if (!!creatorId) await WorkspaceUser.create(creatorId, workspace.id);
    return { workspace, message: null };
  },
  update: async function (id = null, data = {}) {
    if (!id) throw new Error(""No workspace id provided for update"");

    const validKeys = Object.keys(data).filter((key) =>
      this.writable.includes(key)
    );
    const values = Object.values(data);
    if (validKeys.length === 0 || validKeys.length !== values.length)
      return { workspace: { id }, message: ""No valid fields to update!"" };

    const template = `UPDATE ${this.tablename} SET ${validKeys.map((key) => {
      return `${key}=?`;
    })} WHERE id = ?`;
    const db = await this.db();
    const { success, message } = await db
      .run(template, [...values, id])
      .then(() => {
        return { success: true, message: null };
      })
      .catch((error) => {
        return { success: false, message: error.message };
      });

    db.close();
    if (!success) {
      return { workspace: null, message };
    }

    const updatedWorkspace = await this.get(`id = ${id}`);
    return { workspace: updatedWorkspace, message: null };
  },
  getWithUser: async function (user = null, clause = """") {
    if (user.role === ""admin"") return this.get(clause);

    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} as workspace
      LEFT JOIN workspace_users as ws_users
      ON ws_users.workspace_id = workspace.id
      WHERE ws_users.user_id = ${user?.id} AND ${clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    const workspace = { ...result, id: result.workspace_id };
    const documents = await Document.forWorkspace(workspace.id);
    return { ...workspace, documents };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    const documents = await Document.forWorkspace(result.id);
    return { ...result, documents };
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null, orderBy = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      } ${!!orderBy ? orderBy : """"}`
    );
    db.close();

    return results;
  },
  whereWithUser: async function (
    user,
    clause = null,
    limit = null,
    orderBy = null
  ) {
    if (user.role === ""admin"") return await this.where(clause, limit);
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} as workspace
      LEFT JOIN workspace_users as ws_users
      ON ws_users.workspace_id = workspace.id
      WHERE ws_users.user_id = ${user.id} ${clause ? `AND ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      } ${!!orderBy ? orderBy : """"}`
    );
    db.close();
    const workspaces = results.map((ws) => {
      return { ...ws, id: ws.workspace_id };
    });

    return workspaces;
  },
  whereWithUsers: async function (clause = """", limit = null, orderBy = null) {
    const workspaces = await this.where(clause, limit, orderBy);
    for (const workspace of workspaces) {
      const userIds = (
        await WorkspaceUser.where(`workspace_id = ${workspace.id}`)
      ).map((rel) => rel.user_id);
      workspace.userIds = userIds;
    }
    return workspaces;
  },
  updateUsers: async function (workspaceId, userIds = []) {
    await WorkspaceUser.delete(`workspace_id = ${workspaceId}`);
    await WorkspaceUser.createManyUsers(userIds, workspaceId);
    return { success: true, error: null };
  },
};

module.exports = { Workspace };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = VAR(""VAR""); VAR { VAR } = VAR(""./VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""./VAR""); VAR { VAR } = VAR(""VAR-VAR""); VAR VAR = { VAR: ""VAR"", VAR: [  ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR 20, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR [ { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR`, VAR: VAR, }, { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR`, VAR: VAR, }, { VAR: ""VAR"", VAR: `VAR VAR VAR VAR VAR VAR VAR VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR ${VAR.VAR} VAR VAR = VAR VAR VAR = VAR.VAR; VAR`, VAR: VAR, }, { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR 20`, VAR: VAR, }, ]; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR"" }; VAR VAR = VAR(VAR, { VAR: VAR }); VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (VAR !== VAR) { VAR VAR = VAR.VAR(10000000 + VAR.VAR() * 90000000); VAR = VAR(`${VAR}-${VAR}`, { VAR: VAR }); } VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?, ?)`, [ VAR, VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR { VAR: VAR, VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR}` ); VAR.VAR();    VAR (!!VAR) VAR VAR.VAR(VAR, VAR.VAR); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR, VAR = {}) { VAR (!VAR) VAR VAR VAR(""VAR VAR VAR VAR VAR VAR""); VAR VAR = VAR.VAR(VAR).VAR((VAR) => VAR.VAR.VAR(VAR) ); VAR VAR = VAR.VAR(VAR); VAR (VAR.VAR === 0 || VAR.VAR !== VAR.VAR) VAR { VAR: { VAR }, VAR: ""VAR VAR VAR VAR VAR!"" }; VAR VAR = `VAR ${VAR.VAR} VAR ${VAR.VAR((VAR) => { VAR `${VAR}=?`; })} VAR VAR = ?`; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(VAR, [...VAR, VAR]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR { VAR: VAR, VAR }; } VAR VAR = VAR VAR.VAR(`VAR = ${VAR}`); VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR, VAR = """") { VAR (VAR.VAR === ""VAR"") VAR VAR.VAR(VAR); VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR = VAR.VAR VAR VAR.VAR = ${VAR?.VAR} VAR ${VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR = { ...VAR, VAR: VAR.VAR }; VAR VAR = VAR VAR.VAR(VAR.VAR); VAR { ...VAR, VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR = VAR VAR.VAR(VAR.VAR); VAR { ...VAR, VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" } ${!!VAR ? VAR : """"}` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR ( VAR, VAR = VAR, VAR = VAR, VAR = VAR ) { VAR (VAR.VAR === ""VAR"") VAR VAR VAR.VAR(VAR, VAR); VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR = VAR.VAR VAR VAR.VAR = ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" } ${!!VAR ? VAR : """"}` ); VAR.VAR(); VAR VAR = VAR.VAR((VAR) => { VAR { ...VAR, VAR: VAR.VAR }; }); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(VAR, VAR, VAR); VAR (VAR VAR VAR VAR) { VAR VAR = ( VAR VAR.VAR(`VAR = ${VAR.VAR}`) ).VAR((VAR) => VAR.VAR); VAR.VAR = VAR; } VAR VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR VAR.VAR(`VAR = ${VAR}`); VAR VAR.VAR(VAR, VAR); VAR { VAR: VAR, VAR: VAR }; }, }; VAR.VAR = { VAR }; ",7
discourse_1d0faedfbc3a8b77b971dc70d25e30791dbb6e0b,plugins/poll/spec/dpost_migrate/migrate_polls_data_spec.rb,,"# frozen_string_literal: true

require 'rails_helper'
require_relative '../../../db/migrate/20180820080623_migrate_polls_data'

RSpec.describe MigratePollsData do
  let!(:user) { Fabricate(:user, id: 1) }
  let!(:user2) { Fabricate(:user, id: 2) }
  let!(:user3) { Fabricate(:user, id: 3) }
  let!(:user4) { Fabricate(:user, id: 4) }
  let!(:user5) { Fabricate(:user, id: 5) }
  let(:post) { Fabricate(:post, user: user) }

  describe 'for a number poll' do
    before do
      post.custom_fields = {
        ""polls"" => {
          ""poll"" => {
            ""options"" => [
              { ""id"" => ""4d8a15e3cc35750f016ce15a43937620"", ""html"" => ""1"", ""votes"" => 0 },
              { ""id"" => ""aa2393b424f2f395abb63bf785760a3b"", ""html"" => ""4"", ""votes"" => 0 },
              { ""id"" => ""9ab1070dec27185440cdabb4948a5e9a"", ""html"" => ""7"", ""votes"" => 1 },
              { ""id"" => ""46c01f638a50d86e020f47469733b8be"", ""html"" => ""10"", ""votes"" => 0 },
              { ""id"" => ""b4f15431e07443c372d521e4ed131abe"", ""html"" => ""13"", ""votes"" => 0 },
              { ""id"" => ""4e885ead68ff4456f102843df9fbbd7f"", ""html"" => ""16"", ""votes"" => 0 },
              { ""id"" => ""eb8661f072794ea57baa7827cd8ffc88"", ""html"" => ""19"", ""votes"" => 0 }
            ],
            ""voters"" => 1,
            ""name"" => ""poll"",
            ""status"" => ""open"",
            ""type"" => ""number"",
            ""min"" => ""1"",
            ""max"" => ""20"",
            ""step"" => ""3""
          },
        },
        ""polls-votes"" => {
          ""1"" => {
            ""poll"" => [
              ""9ab1070dec27185440cdabb4948a5e9a""
            ]
          }
        }
      }

      post.save_custom_fields
    end

    it ""should migrate the data correctly"" do
      expect do
        silence_stdout { MigratePollsData.new.up }
      end.to \
        change { Poll.count }.by(1) &
        change { PollOption.count }.by(7) &
        change { PollVote.count }.by(1)

      poll = Poll.find_by(name: ""poll"", post: post)

      expect(poll.close_at).to eq(nil)

      expect(poll.number?).to eq(true)
      expect(poll.open?).to eq(true)
      expect(poll.always?).to eq(true)
      expect(poll.secret?).to eq(true)

      expect(poll.min).to eq(1)
      expect(poll.max).to eq(20)
      expect(poll.step).to eq(3)

      expect(PollOption.all.pluck(:digest, :html)).to eq([
        [""4d8a15e3cc35750f016ce15a43937620"", ""1""],
        [""aa2393b424f2f395abb63bf785760a3b"", ""4""],
        [""9ab1070dec27185440cdabb4948a5e9a"", ""7""],
        [""46c01f638a50d86e020f47469733b8be"", ""10""],
        [""b4f15431e07443c372d521e4ed131abe"", ""13""],
        [""4e885ead68ff4456f102843df9fbbd7f"", ""16""],
        [""eb8661f072794ea57baa7827cd8ffc88"", ""19""]
      ])

      poll_vote = PollVote.first

      expect(poll_vote.poll).to eq(poll)
      expect(poll_vote.poll_option.html).to eq(""7"")
      expect(poll_vote.user).to eq(user)
    end
  end

  describe 'for a multiple poll' do
    before do
      post.custom_fields = {
        ""polls-votes"" => {
          ""1"" => {
            ""testing"" => [
              ""b2c3e3668a886d09e97e38b8adde7d45"",
              ""b2c3e3668a886d09e97e38b8adde7d45"",
              ""28df49fa9e9c09d3a1eb8cfbcdcda7790""
            ]
          },
          ""2"" => {
            ""testing"" => [
              ""b2c3e3668a886d09e97e38b8adde7d45"",
              ""d01af008ec373e948c0ab3ad61009f35"",
            ]
          },
        },
        ""polls"" => {
          ""poll"" => {
            ""options"" => [
              {
                ""id"" => ""b2c3e3668a886d09e97e38b8adde7d45"",
                ""html"" => ""Choice 1"",
                ""votes"" => 2,
                ""voter_ids"" => [user.id, user2.id]
              },
              {
                ""id"" => ""28df49fa9e9c09d3a1eb8cfbcdcda7790"",
                ""html"" => ""Choice 2"",
                ""votes"" => 1,
                ""voter_ids"" => [user.id]
              },
              {
                ""id"" => ""d01af008ec373e948c0ab3ad61009f35"",
                ""html"" => ""Choice 3"",
                ""votes"" => 1,
                ""voter_ids"" => [user2.id]
              },
            ],
            ""voters"" => 4,
            ""name"" => ""testing"",
            ""status"" => ""closed"",
            ""type"" => ""multiple"",
            ""public"" => ""true"",
            ""min"" => 1,
            ""max"" => 2
          }
        }
      }

      post.save_custom_fields
    end

    it 'should migrate the data correctly' do
      expect do
        silence_stdout { MigratePollsData.new.up }
      end.to \
        change { Poll.count }.by(1) &
        change { PollOption.count }.by(3) &
        change { PollVote.count }.by(4)

      poll = Poll.last

      expect(poll.post_id).to eq(post.id)
      expect(poll.name).to eq(""testing"")
      expect(poll.close_at).to eq(nil)

      expect(poll.multiple?).to eq(true)
      expect(poll.closed?).to eq(true)
      expect(poll.always?).to eq(true)
      expect(poll.everyone?).to eq(true)

      expect(poll.min).to eq(1)
      expect(poll.max).to eq(2)
      expect(poll.step).to eq(nil)

      poll_options = PollOption.all

      poll_option_1 = poll_options[0]
      expect(poll_option_1.poll_id).to eq(poll.id)
      expect(poll_option_1.digest).to eq(""b2c3e3668a886d09e97e38b8adde7d45"")
      expect(poll_option_1.html).to eq(""Choice 1"")

      poll_option_2 = poll_options[1]
      expect(poll_option_2.poll_id).to eq(poll.id)
      expect(poll_option_2.digest).to eq(""28df49fa9e9c09d3a1eb8cfbcdcda7790"")
      expect(poll_option_2.html).to eq(""Choice 2"")

      poll_option_3 = poll_options[2]
      expect(poll_option_3.poll_id).to eq(poll.id)
      expect(poll_option_3.digest).to eq(""d01af008ec373e948c0ab3ad61009f35"")
      expect(poll_option_3.html).to eq(""Choice 3"")

      expect(PollVote.all.pluck(:poll_id).uniq).to eq([poll.id])

      {
        user => [poll_option_1, poll_option_2],
        user2 => [poll_option_1, poll_option_3]
      }.each do |user, options|
        options.each do |option|
          expect(PollVote.exists?(poll_option_id: option.id, user_id: user.id))
            .to eq(true)
        end
      end
    end
  end

  describe 'for a regular poll' do
    before do
      post.custom_fields = {
        ""polls"" => {
          ""testing"" => {
            ""options"" => [
              {
                ""id"" => ""e94c09aae2aa071610212a5c5042111b"",
                ""html"" => ""Yes"",
                ""votes"" => 0,
                ""anonymous_votes"" => 1,
                ""voter_ids"" => []
              },
              {
                ""id"" => ""802c50392a68e426d4b26d81ddc5ab33"",
                ""html"" => ""No"",
                ""votes"" => 0,
                ""anonymous_votes"" => 2,
                ""voter_ids"" => []
              }
            ],
            ""voters"" => 0,
            ""anonymous_voters"" => 3,
            ""name"" => ""testing"",
            ""status"" => ""open"",
            ""type"" => ""regular""
          },
          ""poll"" => {
            ""options"" => [
              {
                ""id"" => ""edeee5dae4802ab24185d41039efb545"",
                ""html"" => ""Yes"",
                ""votes"" => 2,
                ""voter_ids"" => [1, 2]
              },
              {
                ""id"" => ""38d8e35c8fc80590f836f22189064835"",
                ""html"" =>
                ""No"",
                ""votes"" => 3,
                ""voter_ids"" => [3, 4, 5]
              }
            ],
            ""voters"" => 5,
            ""name"" => ""poll"",
            ""status"" => ""open"",
            ""type"" => ""regular"",
            ""public"" => ""true"",
            ""close"" => ""2018-10-08T00:00:00.000Z""
          },
        },
        ""polls-votes"" => {
          ""1"" => { ""poll"" => [""edeee5dae4802ab24185d41039efb545""] },
          ""2"" => { ""poll"" => [""edeee5dae4802ab24185d41039efb545""] },
          ""3"" => { ""poll"" => [""38d8e35c8fc80590f836f22189064835""] },
          ""4"" => { ""poll"" => [""38d8e35c8fc80590f836f22189064835""] },
          ""5"" => { ""poll"" => [""38d8e35c8fc80590f836f22189064835""] }
        }
      }

      post.save_custom_fields
    end

    it 'should migrate the data correctly' do
      expect do
        silence_stdout { MigratePollsData.new.up }
      end.to \
        change { Poll.count }.by(2) &
        change { PollOption.count }.by(4) &
        change { PollVote.count }.by(5)

      poll = Poll.find_by(name: ""poll"")

      expect(poll.post_id).to eq(post.id)
      expect(poll.close_at).to eq_time(Time.parse(""2018-10-08T00:00:00.000Z""))

      expect(poll.regular?).to eq(true)
      expect(poll.open?).to eq(true)
      expect(poll.always?).to eq(true)
      expect(poll.everyone?).to eq(true)

      expect(poll.min).to eq(nil)
      expect(poll.max).to eq(nil)
      expect(poll.step).to eq(nil)

      poll_options = PollOption.where(poll_id: poll.id).to_a
      expect(poll_options.size).to eq(2)

      option_1 = poll_options.first
      expect(option_1.digest).to eq(""edeee5dae4802ab24185d41039efb545"")
      expect(option_1.html).to eq(""Yes"")

      option_2 = poll_options.last
      expect(option_2.digest).to eq(""38d8e35c8fc80590f836f22189064835"")
      expect(option_2.html).to eq(""No"")

      expect(PollVote.pluck(:poll_id).uniq).to eq([poll.id])

      [user, user2].each do |user|
        expect(PollVote.exists?(poll_option_id: option_1.id, user_id: user.id))
          .to eq(true)
      end

      [user3, user4, user5].each do |user|
        expect(PollVote.exists?(poll_option_id: option_2.id, user_id: user.id))
          .to eq(true)
      end

      poll = Poll.find_by(name: ""testing"")

      expect(poll.post_id).to eq(post.id)
      expect(poll.close_at).to eq(nil)
      expect(poll.anonymous_voters).to eq(3)

      expect(poll.regular?).to eq(true)
      expect(poll.open?).to eq(true)
      expect(poll.always?).to eq(true)
      expect(poll.secret?).to eq(true)

      expect(poll.min).to eq(nil)
      expect(poll.max).to eq(nil)
      expect(poll.step).to eq(nil)

      poll_options = PollOption.where(poll: poll).to_a
      expect(poll_options.size).to eq(2)

      option_1 = poll_options.first
      expect(option_1.digest).to eq(""e94c09aae2aa071610212a5c5042111b"")
      expect(option_1.html).to eq(""Yes"")
      expect(option_1.anonymous_votes).to eq(1)

      option_2 = poll_options.last
      expect(option_2.digest).to eq(""802c50392a68e426d4b26d81ddc5ab33"")
      expect(option_2.html).to eq(""No"")
      expect(option_2.anonymous_votes).to eq(2)
    end
  end
end",1d0faedfbc3a8b77b971dc70d25e30791dbb6e0b,CVE-2021-43793,1d0faedfbc3a8b77b971dc70d25e30791dbb6e0b,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"  VAR 'VAR' VAR '../../../VAR/VAR/20180820080623_migrate_polls_data' VAR.VAR VAR VAR VAR!(:VAR) { VAR(:VAR, VAR: 1) } VAR!(:VAR) { VAR(:VAR, VAR: 2) } VAR!(:VAR) { VAR(:VAR, VAR: 3) } VAR!(:VAR) { VAR(:VAR, VAR: 4) } VAR!(:VAR) { VAR(:VAR, VAR: 5) } VAR(:VAR) { VAR(:VAR, VAR: VAR) } VAR 'VAR VAR VAR VAR' VAR VAR VAR VAR.VAR = { ""VAR"" => { ""VAR"" => { ""VAR"" => [ { ""VAR"" => ""4d8a15e3cc35750f016ce15a43937620"", ""VAR"" => ""1"", ""VAR"" => 0 }, { ""VAR"" => ""VAR"", ""VAR"" => ""4"", ""VAR"" => 0 }, { ""VAR"" => ""9ab1070dec27185440cdabb4948a5e9a"", ""VAR"" => ""7"", ""VAR"" => 1 }, { ""VAR"" => ""46c01f638a50d86e020f47469733b8be"", ""VAR"" => ""10"", ""VAR"" => 0 }, { ""VAR"" => ""VAR"", ""VAR"" => ""13"", ""VAR"" => 0 }, { ""VAR"" => ""4e885ead68ff4456f102843df9fbbd7f"", ""VAR"" => ""16"", ""VAR"" => 0 }, { ""VAR"" => ""VAR"", ""VAR"" => ""19"", ""VAR"" => 0 } ], ""VAR"" => 1, ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => ""1"", ""VAR"" => ""20"", ""VAR"" => ""3"" }, }, ""VAR-VAR"" => { ""1"" => { ""VAR"" => [ ""9ab1070dec27185440cdabb4948a5e9a"" ] } } } VAR.VAR VAR VAR ""VAR VAR VAR VAR VAR"" VAR VAR VAR VAR { VAR.VAR.VAR } VAR.VAR \ VAR { VAR.VAR }.VAR(1) & VAR { VAR.VAR }.VAR(7) & VAR { VAR.VAR }.VAR(1) VAR = VAR.VAR(VAR: ""VAR"", VAR: VAR) VAR(VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR).VAR VAR(1) VAR(VAR.VAR).VAR VAR(20) VAR(VAR.VAR).VAR VAR(3) VAR(VAR.VAR.VAR(:VAR, :VAR)).VAR VAR([ [""4d8a15e3cc35750f016ce15a43937620"", ""1""], [""VAR"", ""4""], [""9ab1070dec27185440cdabb4948a5e9a"", ""7""], [""46c01f638a50d86e020f47469733b8be"", ""10""], [""VAR"", ""13""], [""4e885ead68ff4456f102843df9fbbd7f"", ""16""], [""VAR"", ""19""] ]) VAR = VAR.VAR VAR(VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR.VAR).VAR VAR(""7"") VAR(VAR.VAR).VAR VAR(VAR) VAR VAR VAR 'VAR VAR VAR VAR' VAR VAR VAR VAR.VAR = { ""VAR-VAR"" => { ""1"" => { ""VAR"" => [ ""VAR"", ""VAR"", ""28df49fa9e9c09d3a1eb8cfbcdcda7790"" ] }, ""2"" => { ""VAR"" => [ ""VAR"", ""VAR"", ] }, }, ""VAR"" => { ""VAR"" => { ""VAR"" => [ { ""VAR"" => ""VAR"", ""VAR"" => ""VAR 1"", ""VAR"" => 2, ""VAR"" => [VAR.VAR, VAR.VAR] }, { ""VAR"" => ""28df49fa9e9c09d3a1eb8cfbcdcda7790"", ""VAR"" => ""VAR 2"", ""VAR"" => 1, ""VAR"" => [VAR.VAR] }, { ""VAR"" => ""VAR"", ""VAR"" => ""VAR 3"", ""VAR"" => 1, ""VAR"" => [VAR.VAR] }, ], ""VAR"" => 4, ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => 1, ""VAR"" => 2 } } } VAR.VAR VAR VAR 'VAR VAR VAR VAR VAR' VAR VAR VAR VAR { VAR.VAR.VAR } VAR.VAR \ VAR { VAR.VAR }.VAR(1) & VAR { VAR.VAR }.VAR(3) & VAR { VAR.VAR }.VAR(4) VAR = VAR.VAR VAR(VAR.VAR).VAR VAR(VAR.VAR) VAR(VAR.VAR).VAR VAR(""VAR"") VAR(VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR).VAR VAR(1) VAR(VAR.VAR).VAR VAR(2) VAR(VAR.VAR).VAR VAR(VAR) VAR = VAR.VAR VAR = VAR[0] VAR(VAR.VAR).VAR VAR(VAR.VAR) VAR(VAR.VAR).VAR VAR(""VAR"") VAR(VAR.VAR).VAR VAR(""VAR 1"") VAR = VAR[1] VAR(VAR.VAR).VAR VAR(VAR.VAR) VAR(VAR.VAR).VAR VAR(""28df49fa9e9c09d3a1eb8cfbcdcda7790"") VAR(VAR.VAR).VAR VAR(""VAR 2"") VAR = VAR[2] VAR(VAR.VAR).VAR VAR(VAR.VAR) VAR(VAR.VAR).VAR VAR(""VAR"") VAR(VAR.VAR).VAR VAR(""VAR 3"") VAR(VAR.VAR.VAR(:VAR).VAR).VAR VAR([VAR.VAR]) { VAR => [VAR, VAR], VAR => [VAR, VAR] }.VAR VAR |VAR, VAR| VAR.VAR VAR |VAR| VAR(VAR.VAR?(VAR: VAR.VAR, VAR: VAR.VAR)) .VAR VAR(VAR) VAR VAR VAR VAR VAR 'VAR VAR VAR VAR' VAR VAR VAR VAR.VAR = { ""VAR"" => { ""VAR"" => { ""VAR"" => [ { ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => 0, ""VAR"" => 1, ""VAR"" => [] }, { ""VAR"" => ""802c50392a68e426d4b26d81ddc5ab33"", ""VAR"" => ""VAR"", ""VAR"" => 0, ""VAR"" => 2, ""VAR"" => [] } ], ""VAR"" => 0, ""VAR"" => 3, ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => ""VAR"" }, ""VAR"" => { ""VAR"" => [ { ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => 2, ""VAR"" => [1, 2] }, { ""VAR"" => ""38d8e35c8fc80590f836f22189064835"", ""VAR"" => ""VAR"", ""VAR"" => 3, ""VAR"" => [3, 4, 5] } ], ""VAR"" => 5, ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => ""VAR"", ""VAR"" => ""2018-10-08T00:00:00.000Z"" }, }, ""VAR-VAR"" => { ""1"" => { ""VAR"" => [""VAR""] }, ""2"" => { ""VAR"" => [""VAR""] }, ""3"" => { ""VAR"" => [""38d8e35c8fc80590f836f22189064835""] }, ""4"" => { ""VAR"" => [""38d8e35c8fc80590f836f22189064835""] }, ""5"" => { ""VAR"" => [""38d8e35c8fc80590f836f22189064835""] } } } VAR.VAR VAR VAR 'VAR VAR VAR VAR VAR' VAR VAR VAR VAR { VAR.VAR.VAR } VAR.VAR \ VAR { VAR.VAR }.VAR(2) & VAR { VAR.VAR }.VAR(4) & VAR { VAR.VAR }.VAR(5) VAR = VAR.VAR(VAR: ""VAR"") VAR(VAR.VAR).VAR VAR(VAR.VAR) VAR(VAR.VAR).VAR VAR(VAR.VAR(""2018-10-08T00:00:00.000Z"")) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR).VAR VAR(VAR) VAR = VAR.VAR(VAR: VAR.VAR).VAR VAR(VAR.VAR).VAR VAR(2) VAR = VAR.VAR VAR(VAR.VAR).VAR VAR(""VAR"") VAR(VAR.VAR).VAR VAR(""VAR"") VAR = VAR.VAR VAR(VAR.VAR).VAR VAR(""38d8e35c8fc80590f836f22189064835"") VAR(VAR.VAR).VAR VAR(""VAR"") VAR(VAR.VAR(:VAR).VAR).VAR VAR([VAR.VAR]) [VAR, VAR].VAR VAR |VAR| VAR(VAR.VAR?(VAR: VAR.VAR, VAR: VAR.VAR)) .VAR VAR(VAR) VAR [VAR, VAR, VAR].VAR VAR |VAR| VAR(VAR.VAR?(VAR: VAR.VAR, VAR: VAR.VAR)) .VAR VAR(VAR) VAR VAR = VAR.VAR(VAR: ""VAR"") VAR(VAR.VAR).VAR VAR(VAR.VAR) VAR(VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR).VAR VAR(3) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR?).VAR VAR(VAR) VAR(VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR).VAR VAR(VAR) VAR(VAR.VAR).VAR VAR(VAR) VAR = VAR.VAR(VAR: VAR).VAR VAR(VAR.VAR).VAR VAR(2) VAR = VAR.VAR VAR(VAR.VAR).VAR VAR(""VAR"") VAR(VAR.VAR).VAR VAR(""VAR"") VAR(VAR.VAR).VAR VAR(1) VAR = VAR.VAR VAR(VAR.VAR).VAR VAR(""802c50392a68e426d4b26d81ddc5ab33"") VAR(VAR.VAR).VAR VAR(""VAR"") VAR(VAR.VAR).VAR VAR(2) VAR VAR VAR",7
discourse_3c5fb871c0f54af47679ae71ad449666b01d8216,libookmark_query.rb,"
  def unread_notifications(limit: 20)
    reminder_notifications =
      Notification
        .for_user_menu(@user.id, limit: [limit, 100].min)
        .unread
        .where(notification_type: Notification.types[:bookmark_reminder])

    # We preload associations like we do above for the list to avoid
    # N1s in the can_see? guardian calls for each bookmark.
    bookmarks =
      Bookmark.where(
        id: reminder_notifications.map { |n| n.data_hash[:bookmark_id] }.compact,
        user: @user,
      )
    BookmarkQuery.preload(bookmarks, self)

    reminder_notifications.select do |n|
      bookmark = bookmarks.find { |bm| bm.id == n.data_hash[:bookmark_id] }
      next if bookmark.blank?
      bookmarkable = Bookmark.registered_bookmarkable_from_type(bookmark.bookmarkable_type)
      bookmarkable.can_see?(@guardian, bookmark)
    end
  end",,3c5fb871c0f54af47679ae71ad449666b01d8216,CVE-2023-45816,3c5fb871c0f54af47679ae71ad449666b01d8216,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR(VAR: 20) VAR = VAR .VAR(@VAR.VAR, VAR: [VAR, 100].VAR) .VAR .VAR(VAR: VAR.VAR[:VAR])   VAR = VAR.VAR( VAR: VAR.VAR { |VAR| VAR.VAR[:VAR] }.VAR, VAR: @VAR, ) VAR.VAR(VAR, VAR) VAR.VAR VAR |VAR| VAR = VAR.VAR { |VAR| VAR.VAR == VAR.VAR[:VAR] } VAR VAR VAR.VAR? VAR = VAR.VAR(VAR.VAR) VAR.VAR?(@VAR, VAR) VAR VAR ",7
discourse_bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,app/controllers/users_controller.rb,"  SEARCH_USERS_LIMIT = 50


    if limit = fetch_limit_from_params(default: nil, max: SEARCH_USERS_LIMIT)
      options[:limit] = limit

  BOOKMARKS_LIMIT = 20

        bookmark_list =
          UserBookmarkList.new(
            user: user,
            guardian: guardian,
            search_term: params[:q],
            page: params[:page],
            per_page: fetch_limit_from_params(default: nil, max: BOOKMARKS_LIMIT),
          )

          per_page: USER_MENU_LIST_LIMIT - reminder_notifications.size,
","    if params[:limit].present?
      options[:limit] = params[:limit].to_i
      raise Discourse::InvalidParameters.new(:limit) if options[:limit] <= 0
        bookmark_list = UserBookmarkList.new(user: user, guardian: guardian, params: params)
          params: {
            per_page: USER_MENU_LIST_LIMIT - reminder_notifications.size,
          },",bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,CVE-2023-38684,bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR = 50 VAR VAR = VAR(VAR: VAR, VAR: VAR) VAR[:VAR] = VAR VAR = 20 VAR = VAR.VAR( VAR: VAR, VAR: VAR, VAR: VAR[:VAR], VAR: VAR[:VAR], VAR: VAR(VAR: VAR, VAR: VAR), ) VAR: VAR - VAR.VAR, VAR VAR[:VAR].VAR? VAR[:VAR] = VAR[:VAR].VAR VAR VAR::VAR.VAR(:VAR) VAR VAR[:VAR] <= 0 VAR = VAR.VAR(VAR: VAR, VAR: VAR, VAR: VAR) VAR: { VAR: VAR - VAR.VAR, },",7
discourse_bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,libookmark_query.rb,"  def initialize(user:, guardian: nil, search_term: nil, page: nil, per_page: nil)
    @search_term = search_term
    @page = page ? page.to_i : 0
    @per_page = per_page ? per_page.to_i : 20
    ts_query = @search_term.present? ? Search.ts_query(term: @search_term) : nil
    search_term_wildcard = @search_term.present? ? ""%#{@search_term}%"" : nil
          if @search_term.present?
    results = results.offset(@page * @per_page) if @page.positive?
    results = results.limit(@per_page).to_a
","  def initialize(user:, guardian: nil, params: {})
    @params = params
    @page = @params[:page].to_i
    @limit = @params[:limit].present? ? @params[:limit].to_i : @params[:per_page]
    search_term = @params[:q]
    ts_query = search_term.present? ? Search.ts_query(term: search_term) : nil
    search_term_wildcard = search_term.present? ? ""%#{search_term}%"" : nil
          if search_term.present?
    results = results.offset(@page * @params[:per_page]) if @page.positive?
    results = results.limit(@limit).to_a",bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,CVE-2023-38684,bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR(VAR:, VAR: VAR, VAR: VAR, VAR: VAR, VAR: VAR) @VAR = VAR @VAR = VAR ? VAR.VAR : 0 @VAR = VAR ? VAR.VAR : 20 VAR = @VAR.VAR? ? VAR.VAR(VAR: @VAR) : VAR VAR = @VAR.VAR? ? ""% VAR @VAR.VAR? VAR = VAR.VAR(@VAR * @VAR) VAR @VAR.VAR? VAR = VAR.VAR(@VAR).VAR VAR VAR(VAR:, VAR: VAR, VAR: {}) @VAR = VAR @VAR = @VAR[:VAR].VAR @VAR = @VAR[:VAR].VAR? ? @VAR[:VAR].VAR : @VAR[:VAR] VAR = @VAR[:VAR] VAR = VAR.VAR? ? VAR.VAR(VAR: VAR) : VAR VAR = VAR.VAR? ? ""% VAR VAR.VAR? VAR = VAR.VAR(@VAR * @VAR[:VAR]) VAR @VAR.VAR? VAR = VAR.VAR(@VAR).VAR",7
discourse_d78357917c6a917a8a27af68756228e89c69321c,spec/lionebox/engine/github_issue_onebox_spec.rb,"# frozen_string_literal: true

RSpec.describe Onebox::Engine::GithubIssueOnebox do
  before do
    @link = ""https://github.com/discourse/discourse/issues/1""

    stub_request(:get, ""https://api.github.com/repos/discourse/discourse/issues/1"").to_return(
      status: 200,
      body: onebox_response(""github_issue_onebox""),
    )
  end

  include_context ""with engines""
  it_behaves_like ""an engine""

  describe ""#to_html"" do
    it ""sanitizes the input and transform the emoji into an img tag"" do
      sanitized_label =
        'Test <img src=""/images/emoji/twitter/+1.png?v=12"" title=""+1"" class=""emoji"" alt=""+1"" loading=""lazy"" width=""20"" height=""20""> &lt;style&gt;body {display: none}&lt;/style&gt;'

      expect(html).to include(sanitized_label)
    end
  end
end",,d78357917c6a917a8a27af68756228e89c69321c,CVE-2023-47119,d78357917c6a917a8a27af68756228e89c69321c,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED," VAR.VAR VAR::VAR::VAR VAR VAR VAR @VAR = ""VAR: VAR(:VAR, ""VAR: VAR: 200, VAR: VAR(""VAR""), ) VAR VAR ""VAR VAR"" VAR ""VAR VAR"" VAR "" VAR ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR = 'VAR <VAR VAR=""/VAR/VAR/VAR/+1.VAR?VAR=12"" VAR=""+1"" VAR=""VAR"" VAR=""+1"" VAR=""VAR"" VAR=""20"" VAR=""20""> &VAR;VAR&VAR;VAR {VAR: VAR}&VAR;/VAR&VAR;' VAR(VAR).VAR VAR(VAR) VAR VAR VAR ",7
django_cca0d98118cccf9ae0c6dcf2d6c57fc50469fbf0,docs/releases/2.2.20.txt,"===========================
Django 2.2.20 release notes
===========================

*April 6, 2021*

Django 2.2.20 fixes a security issue with severity ""low"" in 2.2.19.

CVE-2021-28658: Potential directory-traversal via uploaded files
================================================================

``MultiPartParser`` allowed directory-traversal via uploaded files with
suitably crafted file names.

Built-in upload handlers were not affected by this vulnerability.",,cca0d98118cccf9ae0c6dcf2d6c57fc50469fbf0,CVE-2021-28658,cca0d98118cccf9ae0c6dcf2d6c57fc50469fbf0,https://github.com/django/django,GHSD_REGISTRY,88,COMPLETED,"=========================== VAR 2.2.20 VAR VAR =========================== *VAR 6, 2021* VAR 2.2.20 VAR VAR VAR VAR VAR VAR ""VAR"" VAR 2.2.19. VAR-2021-28658: VAR VAR-VAR VAR VAR VAR ================================================================ ``VAR`` VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR. ",7
django_d4d800ca1addc4141e03c5440a849bb64d1582cd,docs/releases/2.2.20.txt,"===========================
Django 2.2.20 release notes
===========================

*April 6, 2021*

Django 2.2.20 fixes a security issue with severity ""low"" in 2.2.19.

CVE-2021-28658: Potential directory-traversal via uploaded files
================================================================

``MultiPartParser`` allowed directory-traversal via uploaded files with
suitably crafted file names.

Built-in upload handlers were not affected by this vulnerability.",,d4d800ca1addc4141e03c5440a849bb64d1582cd,CVE-2021-28658,d4d800ca1addc4141e03c5440a849bb64d1582cd,https://github.com/django/django,GHSD_REGISTRY,152,COMPLETED,"=========================== VAR 2.2.20 VAR VAR =========================== *VAR 6, 2021* VAR 2.2.20 VAR VAR VAR VAR VAR VAR ""VAR"" VAR 2.2.19. VAR-2021-28658: VAR VAR-VAR VAR VAR VAR ================================================================ ``VAR`` VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR. ",7
django_e7fba62248f604c76da4f23dcf1db4a57b0808ea,docs/releases/2.2.20.txt,"===========================
Django 2.2.20 release notes
===========================

*April 6, 2021*

Django 2.2.20 fixes a security issue with severity ""low"" in 2.2.19.

CVE-2021-28658: Potential directory-traversal via uploaded files
================================================================

``MultiPartParser`` allowed directory-traversal via uploaded files with
suitably crafted file names.

Built-in upload handlers were not affected by this vulnerability.",,e7fba62248f604c76da4f23dcf1db4a57b0808ea,CVE-2021-28658,e7fba62248f604c76da4f23dcf1db4a57b0808ea,https://github.com/django/django,GHSD_REGISTRY,88,COMPLETED,"=========================== VAR 2.2.20 VAR VAR =========================== *VAR 6, 2021* VAR 2.2.20 VAR VAR VAR VAR VAR VAR ""VAR"" VAR 2.2.19. VAR-2021-28658: VAR VAR-VAR VAR VAR VAR ================================================================ ``VAR`` VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR. ",7
FreeRDP_d39a7ba5c38e3ba3b99b1558dc2ab0970cbfb0c5,libfreerdp/core/gateway/rts.c,"#include <assert.h>
#include ""rts_signature.h""
static const char* rts_pdu_ptype_to_string(UINT32 ptype)
{
	switch (ptype)
	{
		case PTYPE_REQUEST:
			return ""PTYPE_REQUEST"";
		case PTYPE_PING:
			return ""PTYPE_PING"";
		case PTYPE_RESPONSE:
			return ""PTYPE_RESPONSE"";
		case PTYPE_FAULT:
			return ""PTYPE_FAULT"";
		case PTYPE_WORKING:
			return ""PTYPE_WORKING"";
		case PTYPE_NOCALL:
			return ""PTYPE_NOCALL"";
		case PTYPE_REJECT:
			return ""PTYPE_REJECT"";
		case PTYPE_ACK:
			return ""PTYPE_ACK"";
		case PTYPE_CL_CANCEL:
			return ""PTYPE_CL_CANCEL"";
		case PTYPE_FACK:
			return ""PTYPE_FACK"";
		case PTYPE_CANCEL_ACK:
			return ""PTYPE_CANCEL_ACK"";
		case PTYPE_BIND:
			return ""PTYPE_BIND"";
		case PTYPE_BIND_ACK:
			return ""PTYPE_BIND_ACK"";
		case PTYPE_BIND_NAK:
			return ""PTYPE_BIND_NAK"";
		case PTYPE_ALTER_CONTEXT:
			return ""PTYPE_ALTER_CONTEXT"";
		case PTYPE_ALTER_CONTEXT_RESP:
			return ""PTYPE_ALTER_CONTEXT_RESP"";
		case PTYPE_RPC_AUTH_3:
			return ""PTYPE_RPC_AUTH_3"";
		case PTYPE_SHUTDOWN:
			return ""PTYPE_SHUTDOWN"";
		case PTYPE_CO_CANCEL:
			return ""PTYPE_CO_CANCEL"";
		case PTYPE_ORPHANED:
			return ""PTYPE_ORPHANED"";
		case PTYPE_RTS:
			return ""PTYPE_RTS"";
		default:
			return ""UNKNOWN"";
	}
}
	rpcconn_rts_hdr_t header = { 0 };
	header.header.rpc_vers = 5;
	header.header.rpc_vers_minor = 0;
	header.header.ptype = PTYPE_RTS;
	header.header.packed_drep[0] = 0x10;
	header.header.packed_drep[1] = 0x00;
	header.header.packed_drep[2] = 0x00;
	header.header.packed_drep[3] = 0x00;
	header.header.pfc_flags = PFC_FIRST_FRAG | PFC_LAST_FRAG;
	header.header.auth_length = 0;
	header.header.call_id = 0;

	return header;
}

static BOOL rts_align_stream(wStream* s, size_t alignment)
{
	size_t pos, pad;

	assert(s);
	assert(alignment > 0);

	pos = Stream_GetPosition(s);
	pad = rpc_offset_align(&pos, alignment);
	return Stream_SafeSeek(s, pad);
}

static char* sdup(const void* src, size_t length)
{
	char* dst;
	assert(src || (length == 0));
	if (length == 0)
		return NULL;

	dst = calloc(length + 1, sizeof(char));
	if (!dst)
		return NULL;
	memcpy(dst, src, length);
	return dst;
}

static BOOL rts_write_common_pdu_header(wStream* s, const rpcconn_common_hdr_t* header)
{
	assert(s);
	assert(header);
	if (!Stream_EnsureRemainingCapacity(s, sizeof(rpcconn_common_hdr_t)))
		return FALSE;

	Stream_Write_UINT8(s, header->rpc_vers);
	Stream_Write_UINT8(s, header->rpc_vers_minor);
	Stream_Write_UINT8(s, header->ptype);
	Stream_Write_UINT8(s, header->pfc_flags);
	Stream_Write(s, header->packed_drep, ARRAYSIZE(header->packed_drep));
	Stream_Write_UINT16(s, header->frag_length);
	Stream_Write_UINT16(s, header->auth_length);
	Stream_Write_UINT32(s, header->call_id);
	return TRUE;
}

BOOL rts_read_common_pdu_header(wStream* s, rpcconn_common_hdr_t* header)
{
	size_t left;
	assert(s);
	assert(header);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_common_hdr_t))
		return FALSE;

	Stream_Read_UINT8(s, header->rpc_vers);
	Stream_Read_UINT8(s, header->rpc_vers_minor);
	Stream_Read_UINT8(s, header->ptype);
	Stream_Read_UINT8(s, header->pfc_flags);
	Stream_Read(s, header->packed_drep, ARRAYSIZE(header->packed_drep));
	Stream_Read_UINT16(s, header->frag_length);
	Stream_Read_UINT16(s, header->auth_length);
	Stream_Read_UINT32(s, header->call_id);

	if (header->frag_length < sizeof(rpcconn_common_hdr_t))
		return FALSE;

	left = Stream_GetRemainingLength(s);
	if (left < header->frag_length - sizeof(rpcconn_common_hdr_t))
		return FALSE;

	return TRUE;
}

static BOOL rts_read_auth_verifier_no_checks(wStream* s, auth_verifier_co_t* auth,
                                             const rpcconn_common_hdr_t* header, size_t* startPos)
{
	assert(s);
	assert(auth);
	assert(header);

	assert(header->frag_length > header->auth_length);

	if (startPos)
		*startPos = Stream_GetPosition(s);

	/* Read the auth verifier and check padding matches frag_length */
	{
		const size_t expected = header->frag_length - header->auth_length - 8;

		Stream_SetPosition(s, expected);
		if (Stream_GetRemainingLength(s) < sizeof(auth_verifier_co_t))
			return FALSE;

		Stream_Read_UINT8(s, auth->auth_type);
		Stream_Read_UINT8(s, auth->auth_level);
		Stream_Read_UINT8(s, auth->auth_pad_length);
		Stream_Read_UINT8(s, auth->auth_reserved);
		Stream_Read_UINT32(s, auth->auth_context_id);
	}

	if (header->auth_length != 0)
	{
		const void* ptr = Stream_Pointer(s);
		if (!Stream_SafeSeek(s, header->auth_length))
			return FALSE;
		auth->auth_value = (BYTE*)sdup(ptr, header->auth_length);
		if (auth->auth_value == NULL)
			return FALSE;
	}

	return TRUE;
}

static BOOL rts_read_auth_verifier(wStream* s, auth_verifier_co_t* auth,
                                   const rpcconn_common_hdr_t* header)
{
	size_t pos;
	assert(s);
	assert(auth);
	assert(header);

	if (!rts_read_auth_verifier_no_checks(s, auth, header, &pos))
		return FALSE;

	{
		const size_t expected = header->frag_length - header->auth_length - 8;
		assert(pos + auth->auth_pad_length == expected);
	}

	return TRUE;
}

static BOOL rts_read_auth_verifier_with_stub(wStream* s, auth_verifier_co_t* auth,
                                             rpcconn_common_hdr_t* header)
{
	size_t pos;
	size_t alloc_hint = 0;
	BYTE** ptr = NULL;

	if (!rts_read_auth_verifier_no_checks(s, auth, header, &pos))
		return FALSE;

	switch (header->ptype)
	{
		case PTYPE_FAULT:
		{
			rpcconn_fault_hdr_t* hdr = (rpcconn_fault_hdr_t*)header;
			alloc_hint = hdr->alloc_hint;
			ptr = &hdr->stub_data;
		}
		break;
		case PTYPE_RESPONSE:
		{
			rpcconn_response_hdr_t* hdr = (rpcconn_response_hdr_t*)header;
			alloc_hint = hdr->alloc_hint;
			ptr = &hdr->stub_data;
		}
		break;
		case PTYPE_REQUEST:
		{
			rpcconn_request_hdr_t* hdr = (rpcconn_request_hdr_t*)header;
			alloc_hint = hdr->alloc_hint;
			ptr = &hdr->stub_data;
		}
		break;
		default:
			return FALSE;
	}

	if (alloc_hint > 0)
	{
		const size_t size =
		    header->frag_length - header->auth_length - 8 - auth->auth_pad_length - pos;
		const void* src = Stream_Buffer(s) + pos;

		*ptr = (BYTE*)sdup(src, size);
		if (!*ptr)
			return FALSE;
	}

	return TRUE;
}

static void rts_free_auth_verifier(auth_verifier_co_t* auth)
{
	if (!auth)
		return;
	free(auth->auth_value);
}

static BOOL rts_write_auth_verifier(wStream* s, const auth_verifier_co_t* auth,
                                    const rpcconn_common_hdr_t* header)
{
	size_t pos;
	UINT8 auth_pad_length = 0;

	assert(s);
	assert(auth);
	assert(header);

	/* Align start to a multiple of 4 */
	pos = Stream_GetPosition(s);
	if ((pos % 4) != 0)
	{
		auth_pad_length = 4 - (pos % 4);
		if (!Stream_EnsureRemainingCapacity(s, auth_pad_length))
			return FALSE;
		Stream_Zero(s, auth_pad_length);
	}

	assert(header->frag_length + 8ull > header->auth_length);
	{
		size_t pos = Stream_GetPosition(s);
		size_t expected = header->frag_length - header->auth_length - 8;

		assert(pos == expected);
	}

	if (!Stream_EnsureRemainingCapacity(s, sizeof(auth_verifier_co_t)))
		return FALSE;

	Stream_Write_UINT8(s, auth->auth_type);
	Stream_Write_UINT8(s, auth->auth_level);
	Stream_Write_UINT8(s, auth_pad_length);
	Stream_Write_UINT8(s, 0); /* auth->auth_reserved */
	Stream_Write_UINT32(s, auth->auth_context_id);

	if (!Stream_EnsureRemainingCapacity(s, header->auth_length))
		return FALSE;
	Stream_Write(s, auth->auth_value, header->auth_length);
	return TRUE;
}

static BOOL rts_read_version(wStream* s, p_rt_version_t* version)
{
	assert(s);
	assert(version);

	if (Stream_GetRemainingLength(s) < 2 * sizeof(UINT8))
		return FALSE;
	Stream_Read_UINT8(s, version->major);
	Stream_Read_UINT8(s, version->minor);
	return TRUE;
}

void rts_free_supported_versions(p_rt_versions_supported_t* versions)
{
	if (!versions)
		return;
	free(versions->p_protocols);
	versions->p_protocols = NULL;
}

static BOOL rts_read_supported_versions(wStream* s, p_rt_versions_supported_t* versions)
{
	BYTE x;

	assert(s);
	assert(versions);

	if (Stream_GetRemainingLength(s) < sizeof(UINT8))
		return FALSE;

	Stream_Read_UINT8(s, versions->n_protocols); /* count */

	if (versions->n_protocols > 0)
	{
		versions->p_protocols = calloc(versions->n_protocols, sizeof(p_rt_version_t));
		if (!versions->p_protocols)
			return FALSE;
	}
	for (x = 0; x < versions->n_protocols; x++)
	{
		p_rt_version_t* version = &versions->p_protocols[x];
		if (!rts_read_version(s, version)) /* size_is(n_protocols) */
		{
			rts_free_supported_versions(versions);
			return FALSE;
		}
	}

	return TRUE;
}

static BOOL rts_read_port_any(wStream* s, port_any_t* port)
{
	const void* ptr;

	assert(s);
	assert(port);

	if (Stream_GetRemainingLength(s) < sizeof(UINT16))
		return FALSE;

	Stream_Read_UINT16(s, port->length);
	if (port->length == 0)
		return TRUE;

	ptr = Stream_Pointer(s);
	if (!Stream_SafeSeek(s, port->length))
		return FALSE;
	port->port_spec = sdup(ptr, port->length);
	return port->port_spec != NULL;
}

static void rts_free_port_any(port_any_t* port)
{
	if (!port)
		return;
	free(port->port_spec);
}

static BOOL rts_read_uuid(wStream* s, p_uuid_t* uuid)
{
	assert(s);
	assert(uuid);

	if (Stream_GetRemainingLength(s) < sizeof(p_uuid_t))
		return FALSE;

	Stream_Read_UINT32(s, uuid->time_low);
	Stream_Read_UINT16(s, uuid->time_mid);
	Stream_Read_UINT16(s, uuid->time_hi_and_version);
	Stream_Read_UINT8(s, uuid->clock_seq_hi_and_reserved);
	Stream_Read_UINT8(s, uuid->clock_seq_low);
	Stream_Read(s, uuid->node, ARRAYSIZE(uuid->node));
	return TRUE;
}

static BOOL rts_write_uuid(wStream* s, const p_uuid_t* uuid)
{
	assert(s);
	assert(uuid);

	if (!Stream_EnsureRemainingCapacity(s, sizeof(p_uuid_t)))
		return FALSE;

	Stream_Write_UINT32(s, uuid->time_low);
	Stream_Write_UINT16(s, uuid->time_mid);
	Stream_Write_UINT16(s, uuid->time_hi_and_version);
	Stream_Write_UINT8(s, uuid->clock_seq_hi_and_reserved);
	Stream_Write_UINT8(s, uuid->clock_seq_low);
	Stream_Write(s, uuid->node, ARRAYSIZE(uuid->node));
	return TRUE;
}

static p_syntax_id_t* rts_syntax_id_new(size_t count)
{
	return calloc(count, sizeof(p_syntax_id_t));
}

static void rts_syntax_id_free(p_syntax_id_t* ptr)
{
	free(ptr);
}

static BOOL rts_read_syntax_id(wStream* s, p_syntax_id_t* syntax_id)
{
	assert(s);
	assert(syntax_id);

	if (!rts_read_uuid(s, &syntax_id->if_uuid))
		return FALSE;

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;

	Stream_Read_UINT32(s, syntax_id->if_version);
	return TRUE;
}

static BOOL rts_write_syntax_id(wStream* s, const p_syntax_id_t* syntax_id)
{
	assert(s);
	assert(syntax_id);

	if (!rts_write_uuid(s, &syntax_id->if_uuid))
		return FALSE;

	if (!Stream_EnsureRemainingCapacity(s, 4))
		return FALSE;

	Stream_Write_UINT32(s, syntax_id->if_version);
	return TRUE;
}

p_cont_elem_t* rts_context_elem_new(size_t count)
{
	p_cont_elem_t* ctx = calloc(count, sizeof(p_cont_elem_t));
	return ctx;
}

void rts_context_elem_free(p_cont_elem_t* ptr)
{
	if (!ptr)
		return;
	rts_syntax_id_free(ptr->transfer_syntaxes);
	free(ptr);
}

static BOOL rts_read_context_elem(wStream* s, p_cont_elem_t* element)
{
	BYTE x;
	assert(s);
	assert(element);

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;

	Stream_Read_UINT16(s, element->p_cont_id);
	Stream_Read_UINT8(s, element->n_transfer_syn); /* number of items */
	Stream_Read_UINT8(s, element->reserved);       /* alignment pad, m.b.z. */

	if (!rts_read_syntax_id(s, &element->abstract_syntax)) /* transfer syntax list */
		return FALSE;

	if (element->n_transfer_syn > 0)
	{
		element->transfer_syntaxes = rts_syntax_id_new(element->n_transfer_syn);
		if (!element->transfer_syntaxes)
			return FALSE;
		for (x = 0; x < element->n_transfer_syn; x++)
		{
			p_syntax_id_t* syn = &element->transfer_syntaxes[x];
			if (!rts_read_syntax_id(s, syn)) /* size_is(n_transfer_syn) */
				return FALSE;
		}
	}

	return TRUE;
}

static BOOL rts_write_context_elem(wStream* s, const p_cont_elem_t* element)
{
	BYTE x;
	assert(s);
	assert(element);

	if (!Stream_EnsureRemainingCapacity(s, 4))
		return FALSE;
	Stream_Write_UINT16(s, element->p_cont_id);
	Stream_Write_UINT8(s, element->n_transfer_syn);         /* number of items */
	Stream_Write_UINT8(s, element->reserved);               /* alignment pad, m.b.z. */
	if (!rts_write_syntax_id(s, &element->abstract_syntax)) /* transfer syntax list */
		return FALSE;

	for (x = 0; x < element->n_transfer_syn; x++)
	{
		const p_syntax_id_t* syn = &element->transfer_syntaxes[x];
		if (!rts_write_syntax_id(s, syn)) /* size_is(n_transfer_syn) */
			return FALSE;
	}

	return TRUE;
}

static BOOL rts_read_context_list(wStream* s, p_cont_list_t* list)
{
	BYTE x;

	assert(s);
	assert(list);

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;
	Stream_Read_UINT8(s, list->n_context_elem); /* number of items */
	Stream_Read_UINT8(s, list->reserved);       /* alignment pad, m.b.z. */
	Stream_Read_UINT16(s, list->reserved2);     /* alignment pad, m.b.z. */

	if (list->n_context_elem > 0)
	{
		list->p_cont_elem = rts_context_elem_new(list->n_context_elem);
		if (!list->p_cont_elem)
			return FALSE;
		for (x = 0; x < list->n_context_elem; x++)
		{
			p_cont_elem_t* element = &list->p_cont_elem[x];
			if (!rts_read_context_elem(s, element))
				return FALSE;
		}
	}
	return TRUE;
}

static void rts_free_context_list(p_cont_list_t* list)
{
	if (!list)
		return;
	rts_context_elem_free(list->p_cont_elem);
}

static BOOL rts_write_context_list(wStream* s, const p_cont_list_t* list)
{
	BYTE x;

	assert(s);
	assert(list);

	if (!Stream_EnsureRemainingCapacity(s, 4))
		return FALSE;
	Stream_Write_UINT8(s, list->n_context_elem); /* number of items */
	Stream_Write_UINT8(s, 0);                    /* alignment pad, m.b.z. */
	Stream_Write_UINT16(s, 0);                   /* alignment pad, m.b.z. */

	for (x = 0; x < list->n_context_elem; x++)
	{
		const p_cont_elem_t* element = &list->p_cont_elem[x];
		if (!rts_write_context_elem(s, element))
			return FALSE;
	}
	return TRUE;
}

static p_result_t* rts_result_new(size_t count)
{
	return calloc(count, sizeof(p_result_t));
}

static void rts_result_free(p_result_t* results)
{
	if (!results)
		return;
	free(results);
}

static BOOL rts_read_result(wStream* s, p_result_t* result)
{
	assert(s);
	assert(result);

	if (Stream_GetRemainingLength(s) < 2)
		return FALSE;
	Stream_Read_UINT16(s, result->result);
	Stream_Read_UINT16(s, result->reason);

	return rts_read_syntax_id(s, &result->transfer_syntax);
}

static void rts_free_result(p_result_t* result)
{
	if (!result)
		return;
}

static BOOL rts_read_result_list(wStream* s, p_result_list_t* list)
{
	BYTE x;

	assert(s);
	assert(list);

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;
	Stream_Read_UINT8(s, list->n_results);  /* count */
	Stream_Read_UINT8(s, list->reserved);   /* alignment pad, m.b.z. */
	Stream_Read_UINT16(s, list->reserved2); /* alignment pad, m.b.z. */

	if (list->n_results > 0)
	{
		list->p_results = rts_result_new(list->n_results);
		if (!list->p_results)
			return FALSE;

		for (x = 0; x < list->n_results; x++)
		{
			p_result_t* result = &list->p_results[x]; /* size_is(n_results) */
			if (!rts_read_result(s, result))
				return FALSE;
		}
	}

	return TRUE;
}

static void rts_free_result_list(p_result_list_t* list)
{
	BYTE x;

	if (!list)
		return;
	for (x = 0; x < list->n_results; x++)
	{
		p_result_t* result = &list->p_results[x];
		rts_free_result(result);
	}
	rts_result_free(list->p_results);
}

static void rts_free_pdu_alter_context(rpcconn_alter_context_hdr_t* ctx)
{
	if (!ctx)
		return;

	rts_free_context_list(&ctx->p_context_elem);
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_alter_context(wStream* s, rpcconn_alter_context_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_alter_context_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;

	Stream_Read_UINT16(s, ctx->max_xmit_frag);
	Stream_Read_UINT16(s, ctx->max_recv_frag);
	Stream_Read_UINT32(s, ctx->assoc_group_id);

	if (!rts_read_context_list(s, &ctx->p_context_elem))
		return FALSE;

	if (!rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header))
		return FALSE;

	return TRUE;
}

static BOOL rts_read_pdu_alter_context_response(wStream* s,
                                                rpcconn_alter_context_response_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_alter_context_response_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT16(s, ctx->max_xmit_frag);
	Stream_Read_UINT16(s, ctx->max_recv_frag);
	Stream_Read_UINT32(s, ctx->assoc_group_id);

	if (!rts_read_port_any(s, &ctx->sec_addr))
		return FALSE;

	if (!rts_align_stream(s, 4))
		return FALSE;

	if (!rts_read_result_list(s, &ctx->p_result_list))
		return FALSE;

	if (!rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header))
		return FALSE;

	return TRUE;
}

static void rts_free_pdu_alter_context_response(rpcconn_alter_context_response_hdr_t* ctx)
{
	if (!ctx)
		return;

	rts_free_port_any(&ctx->sec_addr);
	rts_free_result_list(&ctx->p_result_list);
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_bind(wStream* s, rpcconn_bind_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_bind_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT16(s, ctx->max_xmit_frag);
	Stream_Read_UINT16(s, ctx->max_recv_frag);
	Stream_Read_UINT32(s, ctx->assoc_group_id);

	if (!rts_read_context_list(s, &ctx->p_context_elem))
		return FALSE;

	if (!rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header))
		return FALSE;

	return TRUE;
}

static void rts_free_pdu_bind(rpcconn_bind_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_context_list(&ctx->p_context_elem);
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_bind_ack(wStream* s, rpcconn_bind_ack_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_bind_ack_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT16(s, ctx->max_xmit_frag);
	Stream_Read_UINT16(s, ctx->max_recv_frag);
	Stream_Read_UINT32(s, ctx->assoc_group_id);

	if (!rts_read_port_any(s, &ctx->sec_addr))
		return FALSE;

	if (!rts_align_stream(s, 4))
		return FALSE;

	if (!rts_read_result_list(s, &ctx->p_result_list))
		return FALSE;

	return rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_bind_ack(rpcconn_bind_ack_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_port_any(&ctx->sec_addr);
	rts_free_result_list(&ctx->p_result_list);
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_bind_nak(wStream* s, rpcconn_bind_nak_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_bind_nak_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT16(s, ctx->provider_reject_reason);
	return rts_read_supported_versions(s, &ctx->versions);
}

static void rts_free_pdu_bind_nak(rpcconn_bind_nak_hdr_t* ctx)
{
	if (!ctx)
		return;

	rts_free_supported_versions(&ctx->versions);
}

static BOOL rts_read_pdu_auth3(wStream* s, rpcconn_rpc_auth_3_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_rpc_auth_3_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT16(s, ctx->max_xmit_frag);
	Stream_Read_UINT16(s, ctx->max_recv_frag);

	return rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_auth3(rpcconn_rpc_auth_3_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_fault(wStream* s, rpcconn_fault_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_fault_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT32(s, ctx->alloc_hint);
	Stream_Read_UINT16(s, ctx->p_cont_id);
	Stream_Read_UINT8(s, ctx->cancel_count);
	Stream_Read_UINT8(s, ctx->reserved);
	Stream_Read_UINT32(s, ctx->status);

	return rts_read_auth_verifier_with_stub(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_fault(rpcconn_fault_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_cancel_ack(wStream* s, rpcconn_cancel_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_cancel_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	return rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_cancel_ack(rpcconn_cancel_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_orphaned(wStream* s, rpcconn_orphaned_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_orphaned_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	return rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_orphaned(rpcconn_orphaned_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_request(wStream* s, rpcconn_request_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_request_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT32(s, ctx->alloc_hint);
	Stream_Read_UINT16(s, ctx->p_cont_id);
	Stream_Read_UINT16(s, ctx->opnum);
	if (!rts_read_uuid(s, &ctx->object))
		return FALSE;

	return rts_read_auth_verifier_with_stub(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_request(rpcconn_request_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_response(wStream* s, rpcconn_response_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_response_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT32(s, ctx->alloc_hint);
	Stream_Read_UINT16(s, ctx->p_cont_id);
	Stream_Read_UINT8(s, ctx->cancel_count);
	Stream_Read_UINT8(s, ctx->reserved);

	if (!rts_align_stream(s, 8))
		return FALSE;

	return rts_read_auth_verifier_with_stub(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_response(rpcconn_response_hdr_t* ctx)
{
	if (!ctx)
		return;
	free(ctx->stub_data);
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_rts(wStream* s, rpcconn_rts_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_rts_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;

	Stream_Read_UINT16(s, ctx->Flags);
	Stream_Read_UINT16(s, ctx->NumberOfCommands);
	return TRUE;
}

static void rts_free_pdu_rts(rpcconn_rts_hdr_t* ctx)
{
	WINPR_UNUSED(ctx);
}

void rts_free_pdu_header(rpcconn_hdr_t* header, BOOL allocated)
{
	if (!header)
		return;

	switch (header->common.ptype)
	{
		case PTYPE_ALTER_CONTEXT:
			rts_free_pdu_alter_context(&header->alter_context);
			break;
		case PTYPE_ALTER_CONTEXT_RESP:
			rts_free_pdu_alter_context_response(&header->alter_context_response);
			break;
		case PTYPE_BIND:
			rts_free_pdu_bind(&header->bind);
			break;
		case PTYPE_BIND_ACK:
			rts_free_pdu_bind_ack(&header->bind_ack);
			break;
		case PTYPE_BIND_NAK:
			rts_free_pdu_bind_nak(&header->bind_nak);
			break;
		case PTYPE_RPC_AUTH_3:
			rts_free_pdu_auth3(&header->rpc_auth_3);
			break;
		case PTYPE_CANCEL_ACK:
			rts_free_pdu_cancel_ack(&header->cancel);
			break;
		case PTYPE_FAULT:
			rts_free_pdu_fault(&header->fault);
			break;
		case PTYPE_ORPHANED:
			rts_free_pdu_orphaned(&header->orphaned);
			break;
		case PTYPE_REQUEST:
			rts_free_pdu_request(&header->request);
			break;
		case PTYPE_RESPONSE:
			rts_free_pdu_response(&header->response);
			break;
		case PTYPE_RTS:
			rts_free_pdu_rts(&header->rts);
			break;
			/* No extra fields */
		case PTYPE_SHUTDOWN:
			break;

		/* not handled */
		case PTYPE_PING:
		case PTYPE_WORKING:
		case PTYPE_NOCALL:
		case PTYPE_REJECT:
		case PTYPE_ACK:
		case PTYPE_CL_CANCEL:
		case PTYPE_FACK:
		case PTYPE_CO_CANCEL:
		default:
			break;
	}

	if (allocated)
		free(header);
}

BOOL rts_read_pdu_header(wStream* s, rpcconn_hdr_t* header)
{
	BOOL rc = FALSE;
	assert(s);
	assert(header);

	if (!rts_read_common_pdu_header(s, &header->common))
		return FALSE;

	WLog_DBG(TAG, ""Reading PDU type %s"", rts_pdu_ptype_to_string(header->common.ptype));
	fflush(stdout);
	switch (header->common.ptype)
	{
		case PTYPE_ALTER_CONTEXT:
			rc = rts_read_pdu_alter_context(s, &header->alter_context);
			break;
		case PTYPE_ALTER_CONTEXT_RESP:
			rc = rts_read_pdu_alter_context_response(s, &header->alter_context_response);
			break;
		case PTYPE_BIND:
			rc = rts_read_pdu_bind(s, &header->bind);
			break;
		case PTYPE_BIND_ACK:
			rc = rts_read_pdu_bind_ack(s, &header->bind_ack);
			break;
		case PTYPE_BIND_NAK:
			rc = rts_read_pdu_bind_nak(s, &header->bind_nak);
			break;
		case PTYPE_RPC_AUTH_3:
			rc = rts_read_pdu_auth3(s, &header->rpc_auth_3);
			break;
		case PTYPE_CANCEL_ACK:
			rc = rts_read_pdu_cancel_ack(s, &header->cancel);
			break;
		case PTYPE_FAULT:
			rc = rts_read_pdu_fault(s, &header->fault);
			break;
		case PTYPE_ORPHANED:
			rc = rts_read_pdu_orphaned(s, &header->orphaned);
			break;
		case PTYPE_REQUEST:
			rc = rts_read_pdu_request(s, &header->request);
			break;
		case PTYPE_RESPONSE:
			rc = rts_read_pdu_response(s, &header->response);
			break;
		case PTYPE_RTS:
			rc = rts_read_pdu_rts(s, &header->rts);
			break;
		case PTYPE_SHUTDOWN:
			rc = TRUE; /* No extra fields */
			break;

		/* not handled */
		case PTYPE_PING:
		case PTYPE_WORKING:
		case PTYPE_NOCALL:
		case PTYPE_REJECT:
		case PTYPE_ACK:
		case PTYPE_CL_CANCEL:
		case PTYPE_FACK:
		case PTYPE_CO_CANCEL:
		default:
			break;
	}

	return rc;
}

static BOOL rts_write_pdu_header(wStream* s, const rpcconn_rts_hdr_t* header)
{
	assert(s);
	assert(header);
	if (!Stream_EnsureRemainingCapacity(s, sizeof(rpcconn_rts_hdr_t)))
		return FALSE;
	if (!rts_write_common_pdu_header(s, &header->header))
		return FALSE;

	Stream_Write_UINT16(s, header->Flags);
	Stream_Write_UINT16(s, header->NumberOfCommands);
	return TRUE;
static int rts_receive_window_size_command_read(rdpRpc* rpc, wStream* buffer,
	UINT32 val;

	assert(rpc);
	assert(buffer);

	if (Stream_GetRemainingLength(buffer) < 4)
		return -1;
	Stream_Read_UINT32(buffer, val);
		*ReceiveWindowSize = val; /* ReceiveWindowSize (4 bytes) */
static BOOL rts_receive_window_size_command_write(wStream* s, UINT32 ReceiveWindowSize)
	assert(s);

	if (!Stream_EnsureRemainingCapacity(s, 2 * sizeof(UINT32)))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_RECEIVE_WINDOW_SIZE); /* CommandType (4 bytes) */
	Stream_Write_UINT32(s, ReceiveWindowSize);           /* ReceiveWindowSize (4 bytes) */

	return TRUE;
static int rts_flow_control_ack_command_read(rdpRpc* rpc, wStream* buffer, UINT32* BytesReceived,
                                             UINT32* AvailableWindow, BYTE* ChannelCookie)
	UINT32 val;
	assert(rpc);
	assert(buffer);

	if (Stream_GetRemainingLength(buffer) < 24)
		return -1;

	Stream_Read_UINT32(buffer, val);
		*BytesReceived = val; /* BytesReceived (4 bytes) */
	Stream_Read_UINT32(buffer, val);
		*AvailableWindow = val; /* AvailableWindow (4 bytes) */
		Stream_Read(buffer, ChannelCookie, 16); /* ChannelCookie (16 bytes) */
	else
		Stream_Seek(buffer, 16);
static BOOL rts_flow_control_ack_command_write(wStream* s, UINT32 BytesReceived,
                                               UINT32 AvailableWindow, BYTE* ChannelCookie)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 28))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_FLOW_CONTROL_ACK); /* CommandType (4 bytes) */
	Stream_Write_UINT32(s, BytesReceived);            /* BytesReceived (4 bytes) */
	Stream_Write_UINT32(s, AvailableWindow);          /* AvailableWindow (4 bytes) */
	Stream_Write(s, ChannelCookie, 16);               /* ChannelCookie (16 bytes) */
	return TRUE;
static BOOL rts_connection_timeout_command_read(rdpRpc* rpc, wStream* buffer,
                                                UINT32* ConnectionTimeout)
	UINT32 val;
	assert(rpc);
	assert(buffer);
	if (Stream_GetRemainingLength(buffer) < 4)
		return FALSE;
	Stream_Read_UINT32(buffer, val);
	if (ConnectionTimeout)
		*ConnectionTimeout = val; /* ConnectionTimeout (4 bytes) */

	return TRUE;
static BOOL rts_cookie_command_write(wStream* s, const BYTE* Cookie)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 20))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_COOKIE); /* CommandType (4 bytes) */
	Stream_Write(s, Cookie, 16);            /* Cookie (16 bytes) */

	return TRUE;
static BOOL rts_channel_lifetime_command_write(wStream* s, UINT32 ChannelLifetime)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 8))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_CHANNEL_LIFETIME); /* CommandType (4 bytes) */
	Stream_Write_UINT32(s, ChannelLifetime);          /* ChannelLifetime (4 bytes) */
	return TRUE;
static BOOL rts_client_keepalive_command_write(wStream* s, UINT32 ClientKeepalive)
	assert(s);

	if (!Stream_EnsureRemainingCapacity(s, 8))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_CLIENT_KEEPALIVE); /* CommandType (4 bytes) */
	Stream_Write_UINT32(s, ClientKeepalive);          /* ClientKeepalive (4 bytes) */
	return TRUE;
static BOOL rts_version_command_read(rdpRpc* rpc, wStream* buffer)
	assert(rpc);
	assert(buffer);
	if (!Stream_SafeSeek(buffer, 4))
		return FALSE;
	/* Version (4 bytes) */
	return TRUE;
static BOOL rts_version_command_write(wStream* buffer)
	assert(buffer);
	if (Stream_GetRemainingCapacity(buffer) < 8)
		return FALSE;
	Stream_Write_UINT32(buffer, RTS_CMD_VERSION); /* CommandType (4 bytes) */
	Stream_Write_UINT32(buffer, 1);               /* Version (4 bytes) */
	return TRUE;
static BOOL rts_empty_command_write(wStream* s)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 8))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_EMPTY); /* CommandType (4 bytes) */
	return TRUE;
static BOOL rts_padding_command_read(wStream* s, size_t* length)
	UINT32 ConformanceCount;
	assert(s);
	assert(length);
	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;
	Stream_Read_UINT32(s, ConformanceCount); /* ConformanceCount (4 bytes) */
	*length = ConformanceCount + 4;
	return TRUE;
static BOOL rts_client_address_command_read(wStream* s, size_t* length)

	assert(s);
	assert(length);

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;
	Stream_Read_UINT32(s, AddressType); /* AddressType (4 bytes) */
		*length = 4 + 4 + 12;
		*length = 4 + 16 + 12;
	return TRUE;
static BOOL rts_association_group_id_command_write(wStream* s, const BYTE* AssociationGroupId)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 20))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_ASSOCIATION_GROUP_ID); /* CommandType (4 bytes) */
	Stream_Write(s, AssociationGroupId, 16);              /* AssociationGroupId (16 bytes) */
	return TRUE;
static int rts_destination_command_read(rdpRpc* rpc, wStream* buffer, UINT32* Destination)
	UINT32 val;
	assert(rpc);
	assert(buffer);
	if (Stream_GetRemainingLength(buffer) < 4)
		return -1;
	Stream_Read_UINT32(buffer, val);
		*Destination = val; /* Destination (4 bytes) */
static BOOL rts_destination_command_write(wStream* s, UINT32 Destination)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 8))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_DESTINATION); /* CommandType (4 bytes) */
	Stream_Write_UINT32(s, Destination);         /* Destination (4 bytes) */
	return TRUE;
	assert(cookie);
static BOOL rts_send_buffer(RpcChannel* channel, wStream* s, size_t frag_length)
{
	BOOL status = FALSE;
	SSIZE_T rc;

	assert(channel);
	assert(s);

	Stream_SealLength(s);
	if (Stream_Length(s) < sizeof(rpcconn_common_hdr_t))
		goto fail;
	if (Stream_Length(s) != frag_length)
		goto fail;

	rc = rpc_channel_write(channel, Stream_Buffer(s), Stream_Length(s));
	if (rc < 0)
		goto fail;
	if ((size_t)rc != Stream_Length(s))
		goto fail;
	status = TRUE;
fail:
	return status;
}

BOOL rts_send_CONN_A1_pdu(rdpRpc* rpc)
	BOOL status = FALSE;
	wStream* buffer;
	RpcVirtualConnection* connection;
	RpcOutChannel* outChannel;

	assert(rpc);

	connection = rpc->VirtualConnection;
	assert(connection);

	outChannel = connection->DefaultOutChannel;
	assert(outChannel);


	buffer = Stream_New(NULL, header.header.frag_length);
	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	status = rts_version_command_write(buffer); /* Version (8 bytes) */
	if (!status)
		goto fail;
	status = rts_cookie_command_write(
	    buffer, VirtualConnectionCookie); /* VirtualConnectionCookie (20 bytes) */
	if (!status)
		goto fail;
	status = rts_cookie_command_write(buffer, OUTChannelCookie); /* OUTChannelCookie (20 bytes) */
	if (!status)
		goto fail;
	status = rts_receive_window_size_command_write(
	    buffer, ReceiveWindowSize); /* ReceiveWindowSize (8 bytes) */
	if (!status)
		goto fail;
	status = rts_send_buffer(&outChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return status;
BOOL rts_recv_CONN_A3_pdu(rdpRpc* rpc, wStream* buffer)
	BOOL rc;

	if (!Stream_SafeSeek(buffer, 24))
		return FALSE;

	rc = rts_connection_timeout_command_read(rpc, buffer, &ConnectionTimeout);
	if (!rc)
		return rc;


	assert(rpc);
	assert(rpc->VirtualConnection);
	assert(rpc->VirtualConnection->DefaultInChannel);

	return TRUE;
BOOL rts_send_CONN_B1_pdu(rdpRpc* rpc)
	BOOL status = FALSE;
	wStream* buffer;
	RpcVirtualConnection* connection;
	RpcInChannel* inChannel;

	assert(rpc);

	connection = rpc->VirtualConnection;
	assert(connection);

	inChannel = connection->DefaultInChannel;
	assert(inChannel);


	buffer = Stream_New(NULL, header.header.frag_length);
		goto fail;
	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	if (!rts_version_command_write(buffer)) /* Version (8 bytes) */
		goto fail;
	if (!rts_cookie_command_write(buffer,
	                              VirtualConnectionCookie)) /* VirtualConnectionCookie (20 bytes) */
		goto fail;
	if (!rts_cookie_command_write(buffer, INChannelCookie)) /* INChannelCookie (20 bytes) */
		goto fail;
	if (!rts_channel_lifetime_command_write(buffer,
	                                        rpc->ChannelLifetime)) /* ChannelLifetime (8 bytes) */
		goto fail;
	if (!rts_client_keepalive_command_write(buffer,
	                                        rpc->KeepAliveInterval)) /* ClientKeepalive (8 bytes) */
		goto fail;
	if (!rts_association_group_id_command_write(
	        buffer, AssociationGroupId)) /* AssociationGroupId (20 bytes) */
		goto fail;
	status = rts_send_buffer(&inChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return status;
BOOL rts_recv_CONN_C2_pdu(rdpRpc* rpc, wStream* buffer)
	BOOL rc;

	assert(rpc);
	assert(buffer);

	if (!Stream_SafeSeek(buffer, 24))
		return FALSE;

	rc = rts_version_command_read(rpc, buffer);
	if (rc < 0)
		return rc;
	rc = rts_receive_window_size_command_read(rpc, buffer, &ReceiveWindowSize);
	if (rc < 0)
		return rc;
	rc = rts_connection_timeout_command_read(rpc, buffer, &ConnectionTimeout);
	if (rc < 0)
		return rc;

	assert(rpc);
	assert(rpc->VirtualConnection);
	assert(rpc->VirtualConnection->DefaultInChannel);

	return TRUE;
BOOL rts_send_flow_control_ack_pdu(rdpRpc* rpc)
	BOOL status = FALSE;
	wStream* buffer;
	UINT32 BytesReceived;
	UINT32 AvailableWindow;
	BYTE* ChannelCookie;
	RpcVirtualConnection* connection;
	RpcInChannel* inChannel;
	RpcOutChannel* outChannel;
	assert(rpc);
	connection = rpc->VirtualConnection;
	assert(connection);
	inChannel = connection->DefaultInChannel;
	assert(inChannel);
	outChannel = connection->DefaultOutChannel;
	assert(outChannel);


	buffer = Stream_New(NULL, header.header.frag_length);
		goto fail;

	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	if (!rts_destination_command_write(buffer, FDOutProxy)) /* Destination Command (8 bytes) */
		goto fail;
	if (!rts_flow_control_ack_command_write(buffer, BytesReceived, AvailableWindow, ChannelCookie))
		goto fail;

	status = rts_send_buffer(&inChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return status;
static int rts_recv_flow_control_ack_pdu(rdpRpc* rpc, wStream* buffer)
	int rc;
	BYTE ChannelCookie[16] = { 0 };

	rc = rts_flow_control_ack_command_read(rpc, buffer, &BytesReceived, &AvailableWindow,
	                                       (BYTE*)&ChannelCookie);
	if (rc < 0)
		return rc;

	assert(rpc->VirtualConnection);
	assert(rpc->VirtualConnection->DefaultInChannel);

static int rts_recv_flow_control_ack_with_destination_pdu(rdpRpc* rpc, wStream* buffer)
	int rc;
	BYTE ChannelCookie[16] = { 0 };

	rc = rts_destination_command_read(rpc, buffer, &Destination);
	if (rc < 0)
		return rc;

	rc = rts_flow_control_ack_command_read(rpc, buffer, &BytesReceived, &AvailableWindow,
	                                       ChannelCookie);
	if (rc < 0)
		return rc;


	assert(rpc->VirtualConnection);
	assert(rpc->VirtualConnection->DefaultInChannel);
	BOOL status = FALSE;
	wStream* buffer;
	RpcInChannel* inChannel;

	assert(rpc);
	assert(rpc->VirtualConnection);

	inChannel = rpc->VirtualConnection->DefaultInChannel;
	assert(inChannel);

	buffer = Stream_New(NULL, header.header.frag_length);
		goto fail;

	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	status = rts_send_buffer(&inChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return (status) ? 1 : -1;
BOOL rts_command_length(UINT32 CommandType, wStream* s, size_t* length)
	size_t padding = 0;
	size_t CommandLength = 0;

	assert(s);
			if (!rts_padding_command_read(s, &padding))
				return FALSE;
			if (!rts_client_address_command_read(s, &CommandLength))
				return FALSE;
			return FALSE;
	CommandLength += padding;
	if (Stream_GetRemainingLength(s) < CommandLength)
		return FALSE;

	if (length)
		*length = CommandLength;
	return TRUE;
	BOOL status = FALSE;
	wStream* buffer;
	RpcInChannel* inChannel;
	RpcOutChannel* nextOutChannel;

	assert(rpc);
	assert(rpc->VirtualConnection);

	inChannel = rpc->VirtualConnection->DefaultInChannel;
	assert(inChannel);

	nextOutChannel = rpc->VirtualConnection->NonDefaultOutChannel;
	assert(nextOutChannel);


	buffer = Stream_New(NULL, header.header.frag_length);
	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	if (!rts_destination_command_write(buffer, FDServer)) /* Destination (8 bytes)*/
		goto fail;
	if (!rts_cookie_command_write(buffer,
	                              SuccessorChannelCookie)) /* SuccessorChannelCookie (20 bytes) */
		goto fail;
	if (!rts_version_command_write(buffer)) /* Version (8 bytes) */
		goto fail;
	status = rts_send_buffer(&inChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return (status) ? 1 : -1;
	BOOL status = FALSE;
	wStream* buffer;
	RpcOutChannel* nextOutChannel;

	assert(rpc);
	assert(rpc->VirtualConnection);

	nextOutChannel = rpc->VirtualConnection->NonDefaultOutChannel;
	assert(nextOutChannel);

	buffer = Stream_New(NULL, header.header.frag_length);
	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;

	if (!rts_empty_command_write(buffer)) /* Empty command (4 bytes) */
		goto fail;
	status = rts_send_buffer(&nextOutChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return (status) ? 1 : -1;
BOOL rts_send_OUT_R1_A3_pdu(rdpRpc* rpc)
	BOOL status = FALSE;
	wStream* buffer;
	RpcVirtualConnection* connection;
	RpcOutChannel* outChannel;
	RpcOutChannel* nextOutChannel;

	assert(rpc);

	connection = rpc->VirtualConnection;
	assert(connection);

	outChannel = connection->DefaultOutChannel;
	assert(outChannel);

	nextOutChannel = connection->NonDefaultOutChannel;
	assert(nextOutChannel);


	buffer = Stream_New(NULL, header.header.frag_length);
	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	if (!rts_version_command_write(buffer)) /* Version (8 bytes) */
		goto fail;
	if (!rts_cookie_command_write(buffer,
	                              VirtualConnectionCookie)) /* VirtualConnectionCookie (20 bytes) */
		goto fail;
	if (!rts_cookie_command_write(
	        buffer, PredecessorChannelCookie)) /* PredecessorChannelCookie (20 bytes) */
		goto fail;
	if (!rts_cookie_command_write(buffer,
	                              SuccessorChannelCookie)) /* SuccessorChannelCookie (20 bytes) */
		goto fail;
	if (!rts_receive_window_size_command_write(buffer,
	                                           ReceiveWindowSize)) /* ReceiveWindowSize (8 bytes) */
		goto fail;

	status = rts_send_buffer(&nextOutChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return status;
static int rts_recv_OUT_R1_A2_pdu(rdpRpc* rpc, wStream* buffer)
	RpcVirtualConnection* connection;
	assert(rpc);
	assert(buffer);

	connection = rpc->VirtualConnection;
	assert(connection);

	status = rts_destination_command_read(rpc, buffer, &Destination);
	if (status < 0)
		return status;
static int rts_recv_OUT_R2_A6_pdu(rdpRpc* rpc, wStream* buffer)
	RpcVirtualConnection* connection;

	assert(rpc);
	assert(buffer);

	connection = rpc->VirtualConnection;
	assert(connection);

static int rts_recv_OUT_R2_B3_pdu(rdpRpc* rpc, wStream* buffer)
	RpcVirtualConnection* connection;

	assert(rpc);
	assert(buffer);

	connection = rpc->VirtualConnection;
	assert(connection);

BOOL rts_recv_out_of_sequence_pdu(rdpRpc* rpc, wStream* buffer, const rpcconn_hdr_t* header)
	BOOL status = FALSE;
	size_t length, total;
	RtsPduSignature signature = { 0 };
	assert(rpc);
	assert(buffer);
	assert(header);

	total = Stream_Length(buffer);
	length = header->common.frag_length;
	if (total < length)
		return FALSE;
		return FALSE;
	if (!rts_extract_pdu_signature(&signature, buffer, header))
		return FALSE;
	if (rts_match_pdu_signature(&RTS_PDU_FLOW_CONTROL_ACK_SIGNATURE, buffer, header))
		status = rts_recv_flow_control_ack_pdu(rpc, buffer);
	else if (rts_match_pdu_signature(&RTS_PDU_FLOW_CONTROL_ACK_WITH_DESTINATION_SIGNATURE, buffer,
	                                 header))
		status = rts_recv_flow_control_ack_with_destination_pdu(rpc, buffer);
	else if (rts_match_pdu_signature(&RTS_PDU_PING_SIGNATURE, buffer, header))
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R1_A2_SIGNATURE, buffer, header))
				status = rts_recv_OUT_R1_A2_pdu(rpc, buffer);
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R2_A6_SIGNATURE, buffer, header))
				status = rts_recv_OUT_R2_A6_pdu(rpc, buffer);
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R2_B3_SIGNATURE, buffer, header))
				status = rts_recv_OUT_R2_B3_pdu(rpc, buffer);
	if (!status)

BOOL rts_write_pdu_auth3(wStream* s, const rpcconn_rpc_auth_3_hdr_t* auth)
{
	assert(s);
	assert(auth);

	if (!rts_write_common_pdu_header(s, &auth->header))
		return FALSE;

	if (!Stream_EnsureRemainingCapacity(s, 2 * sizeof(UINT16)))
		return FALSE;

	Stream_Write_UINT16(s, auth->max_xmit_frag);
	Stream_Write_UINT16(s, auth->max_recv_frag);

	return rts_write_auth_verifier(s, &auth->auth_verifier, &auth->header);
}

BOOL rts_write_pdu_bind(wStream* s, const rpcconn_bind_hdr_t* bind)
{

	assert(s);
	assert(bind);

	if (!rts_write_common_pdu_header(s, &bind->header))
		return FALSE;

	if (!Stream_EnsureRemainingCapacity(s, 8))
		return FALSE;

	Stream_Write_UINT16(s, bind->max_xmit_frag);
	Stream_Write_UINT16(s, bind->max_recv_frag);
	Stream_Write_UINT32(s, bind->assoc_group_id);

	if (!rts_write_context_list(s, &bind->p_context_elem))
		return FALSE;

	return rts_write_auth_verifier(s, &bind->auth_verifier, &bind->header);
}","	rpcconn_rts_hdr_t header = { 0 };
	header.header.rpc_vers = 5;
	header.header.rpc_vers_minor = 0;
	header.header.ptype = PTYPE_RTS;
	header.header.packed_drep[0] = 0x10;
	header.header.packed_drep[1] = 0x00;
	header.header.packed_drep[2] = 0x00;
	header.header.packed_drep[3] = 0x00;
	header.header.pfc_flags = PFC_FIRST_FRAG | PFC_LAST_FRAG;
	header.header.auth_length = 0;
	header.header.call_id = 0;
	return header;
static int rts_receive_window_size_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length,
		*ReceiveWindowSize = *((UINT32*)&buffer[0]); /* ReceiveWindowSize (4 bytes) */
static int rts_receive_window_size_command_write(BYTE* buffer, UINT32 ReceiveWindowSize)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_RECEIVE_WINDOW_SIZE; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = ReceiveWindowSize;           /* ReceiveWindowSize (4 bytes) */
	}
	return 8;
static int rts_flow_control_ack_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length,
                                             UINT32* BytesReceived, UINT32* AvailableWindow,
                                             BYTE* ChannelCookie)
		*BytesReceived = *((UINT32*)&buffer[0]); /* BytesReceived (4 bytes) */
		*AvailableWindow = *((UINT32*)&buffer[4]); /* AvailableWindow (4 bytes) */
		CopyMemory(ChannelCookie, &buffer[8], 16); /* ChannelCookie (16 bytes) */

static int rts_flow_control_ack_command_write(BYTE* buffer, UINT32 BytesReceived,
                                              UINT32 AvailableWindow, BYTE* ChannelCookie)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_FLOW_CONTROL_ACK; /* CommandType (4 bytes) */
		/* Ack (24 bytes) */
		*((UINT32*)&buffer[4]) = BytesReceived;     /* BytesReceived (4 bytes) */
		*((UINT32*)&buffer[8]) = AvailableWindow;   /* AvailableWindow (4 bytes) */
		CopyMemory(&buffer[12], ChannelCookie, 16); /* ChannelCookie (16 bytes) */
	}
	return 28;
}
static int rts_connection_timeout_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length,
                                               UINT32* ConnectionTimeout)
{
	if (ConnectionTimeout)
		*ConnectionTimeout = *((UINT32*)&buffer[0]); /* ConnectionTimeout (4 bytes) */
	return 4;
static int rts_connection_timeout_command_write(BYTE* buffer, UINT32 ConnectionTimeout)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_CONNECTION_TIMEOUT; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = ConnectionTimeout;          /* ConnectionTimeout (4 bytes) */
	}
	return 8;
}
static int rts_cookie_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* Cookie (16 bytes) */
	return 16;
static int rts_cookie_command_write(BYTE* buffer, BYTE* Cookie)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_COOKIE; /* CommandType (4 bytes) */
		CopyMemory(&buffer[4], Cookie, 16);      /* Cookie (16 bytes) */
	}
	return 20;
}
static int rts_channel_lifetime_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* ChannelLifetime (4 bytes) */
	return 4;
static int rts_channel_lifetime_command_write(BYTE* buffer, UINT32 ChannelLifetime)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_CHANNEL_LIFETIME; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = ChannelLifetime;          /* ChannelLifetime (4 bytes) */
	}
	return 8;
}
static int rts_client_keepalive_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* ClientKeepalive (4 bytes) */
	return 4;
static int rts_client_keepalive_command_write(BYTE* buffer, UINT32 ClientKeepalive)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_CLIENT_KEEPALIVE; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = ClientKeepalive;          /* ClientKeepalive (4 bytes) */
	}
	return 8;
}
static int rts_version_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* Version (4 bytes) */
	return 4;
static int rts_version_command_write(BYTE* buffer)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_VERSION; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = 1;               /* Version (4 bytes) */
	}
	return 8;
}
static int rts_empty_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	return 0;
static int rts_empty_command_write(BYTE* buffer)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_EMPTY; /* CommandType (4 bytes) */
	}

	return 4;
}
static SSIZE_T rts_padding_command_read(const BYTE* buffer, size_t length)
{
	UINT32 ConformanceCount;
	ConformanceCount = *((UINT32*)&buffer[0]); /* ConformanceCount (4 bytes) */
	/* Padding (variable) */
	return ConformanceCount + 4;
}
static int rts_padding_command_write(BYTE* buffer, UINT32 ConformanceCount)
{
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_PADDING;  /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = ConformanceCount; /* ConformanceCount (4 bytes) */
		ZeroMemory(&buffer[8], ConformanceCount);  /* Padding (variable) */
	}
	return 8 + ConformanceCount;
static int rts_negative_ance_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	return 0;
}
static int rts_negative_ance_command_write(BYTE* buffer)
{
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_NEGATIVE_ANCE; /* CommandType (4 bytes) */
	}
	return 4;
}
static int rts_ance_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	return 0;
static int rts_ance_command_write(BYTE* buffer)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_ANCE; /* CommandType (4 bytes) */
	}

	return 4;
static SSIZE_T rts_client_address_command_read(const BYTE* buffer, size_t length)
	AddressType = *((UINT32*)&buffer[0]); /* AddressType (4 bytes) */
		return 4 + 4 + 12;
		return 4 + 16 + 12;
static int rts_client_address_command_write(BYTE* buffer, UINT32 AddressType, BYTE* ClientAddress)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_CLIENT_ADDRESS; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = AddressType;            /* AddressType (4 bytes) */
	}
	if (AddressType == 0)
	{
		if (buffer)
		{
			CopyMemory(&buffer[8], ClientAddress, 4); /* ClientAddress (4 bytes) */
			ZeroMemory(&buffer[12], 12);              /* padding (12 bytes) */
		}

		return 24;
	}
	else
	{
		if (buffer)
		{
			CopyMemory(&buffer[8], ClientAddress, 16); /* ClientAddress (16 bytes) */
			ZeroMemory(&buffer[24], 12);               /* padding (12 bytes) */
		}
		return 36;
	}
}
static int rts_association_group_id_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* AssociationGroupId (16 bytes) */
	return 16;
static int rts_association_group_id_command_write(BYTE* buffer, BYTE* AssociationGroupId)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_ASSOCIATION_GROUP_ID; /* CommandType (4 bytes) */
		CopyMemory(&buffer[4], AssociationGroupId, 16);        /* AssociationGroupId (16 bytes) */
	}

	return 20;
}
static int rts_destination_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length,
                                        UINT32* Destination)
{
		*Destination = *((UINT32*)&buffer[0]); /* Destination (4 bytes) */
static int rts_destination_command_write(BYTE* buffer, UINT32 Destination)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_DESTINATION; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = Destination;         /* Destination (4 bytes) */
	}

	return 8;
}
static int rts_ping_traffic_sent_notify_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* PingTrafficSent (4 bytes) */
	return 4;
}
static int rts_ping_traffic_sent_notify_command_write(BYTE* buffer, UINT32 PingTrafficSent)
{
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_PING_TRAFFIC_SENT_NOTIFY; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = PingTrafficSent;                  /* PingTrafficSent (4 bytes) */
	}
	return 8;
int rts_send_CONN_A1_pdu(rdpRpc* rpc)
	int status;
	BYTE* buffer;
	RpcVirtualConnection* connection = rpc->VirtualConnection;
	RpcOutChannel* outChannel = connection->DefaultOutChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	rts_version_command_write(&buffer[20]);   /* Version (8 bytes) */
	rts_cookie_command_write(&buffer[28],
	                         VirtualConnectionCookie); /* VirtualConnectionCookie (20 bytes) */
	rts_cookie_command_write(&buffer[48], OUTChannelCookie); /* OUTChannelCookie (20 bytes) */
	rts_receive_window_size_command_write(&buffer[68],
	                                      ReceiveWindowSize); /* ReceiveWindowSize (8 bytes) */
	status = rpc_channel_write(&outChannel->common, buffer, header.header.frag_length);
	free(buffer);
	return (status > 0) ? 1 : -1;
int rts_recv_CONN_A3_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	rts_connection_timeout_command_read(rpc, &buffer[24], length - 24, &ConnectionTimeout);
	return 1;
int rts_send_CONN_B1_pdu(rdpRpc* rpc)
	int status;
	BYTE* buffer;
	UINT32 length;
	RpcVirtualConnection* connection = rpc->VirtualConnection;
	RpcInChannel* inChannel = connection->DefaultInChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
		return -1;

	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	rts_version_command_write(&buffer[20]);   /* Version (8 bytes) */
	rts_cookie_command_write(&buffer[28],
	                         VirtualConnectionCookie);      /* VirtualConnectionCookie (20 bytes) */
	rts_cookie_command_write(&buffer[48], INChannelCookie); /* INChannelCookie (20 bytes) */
	rts_channel_lifetime_command_write(&buffer[68],
	                                   rpc->ChannelLifetime); /* ChannelLifetime (8 bytes) */
	rts_client_keepalive_command_write(&buffer[76],
	                                   rpc->KeepAliveInterval); /* ClientKeepalive (8 bytes) */
	rts_association_group_id_command_write(&buffer[84],
	                                       AssociationGroupId); /* AssociationGroupId (20 bytes) */
	length = header.header.frag_length;
	status = rpc_channel_write(&inChannel->common, buffer, length);
	free(buffer);
	return (status > 0) ? 1 : -1;
int rts_recv_CONN_C2_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	UINT32 offset;
	offset = 24;
	offset += rts_version_command_read(rpc, &buffer[offset], length - offset) + 4;
	offset += rts_receive_window_size_command_read(rpc, &buffer[offset], length - offset,
	                                               &ReceiveWindowSize) +
	          4;
	offset += rts_connection_timeout_command_read(rpc, &buffer[offset], length - offset,
	                                              &ConnectionTimeout) +
	          4;
	return 1;
static int rts_send_keep_alive_pdu(rdpRpc* rpc)
	int status;
	BYTE* buffer;
	UINT32 length;
	RpcInChannel* inChannel = rpc->VirtualConnection->DefaultInChannel;
	header.header.frag_length = 28;
	header.Flags = RTS_FLAG_OTHER_CMD;
	header.NumberOfCommands = 1;
	WLog_DBG(TAG, ""Sending Keep-Alive RTS PDU"");
	buffer = (BYTE*)malloc(header.header.frag_length);
	if (!buffer)
		return -1;
	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	rts_client_keepalive_command_write(
	    &buffer[20], rpc->CurrentKeepAliveInterval); /* ClientKeepAlive (8 bytes) */
	length = header.header.frag_length;
	status = rpc_channel_write(&inChannel->common, buffer, length);
	free(buffer);
	return (status > 0) ? 1 : -1;
}
int rts_send_flow_control_ack_pdu(rdpRpc* rpc)
{
	int status;
	BYTE* buffer;
	UINT32 length;
	rpcconn_rts_hdr_t header = rts_pdu_header_init();
	UINT32 BytesReceived;
	UINT32 AvailableWindow;
	BYTE* ChannelCookie;
	RpcVirtualConnection* connection = rpc->VirtualConnection;
	RpcInChannel* inChannel = connection->DefaultInChannel;
	RpcOutChannel* outChannel = connection->DefaultOutChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
		return -1;
	CopyMemory(buffer, ((BYTE*)&header), 20);               /* RTS Header (20 bytes) */
	rts_destination_command_write(&buffer[20], FDOutProxy); /* Destination Command (8 bytes) */
	rts_flow_control_ack_command_write(&buffer[28], BytesReceived, AvailableWindow, ChannelCookie);
	length = header.header.frag_length;
	status = rpc_channel_write(&inChannel->common, buffer, length);
	free(buffer);
	return (status > 0) ? 1 : -1;
static int rts_recv_flow_control_ack_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	UINT32 offset;
	BYTE ChannelCookie[16];
	offset = 24;
	offset +=
	    rts_flow_control_ack_command_read(rpc, &buffer[offset], length - offset, &BytesReceived,
	                                      &AvailableWindow, (BYTE*)&ChannelCookie) +
	    4;
static int rts_recv_flow_control_ack_with_destination_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	UINT32 offset;
	BYTE ChannelCookie[16];
	offset = 24;
	offset += rts_destination_command_read(rpc, &buffer[offset], length - offset, &Destination) + 4;
	offset +=
	    rts_flow_control_ack_command_read(rpc, &buffer[offset], length - offset, &BytesReceived,
	                                      &AvailableWindow, (BYTE*)&ChannelCookie) +
	    4;
	int status;
	BYTE* buffer;
	UINT32 length;
	RpcInChannel* inChannel = rpc->VirtualConnection->DefaultInChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
		return -1;

	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	length = header.header.frag_length;
	status = rpc_channel_write(&inChannel->common, buffer, length);
	free(buffer);
	return (status > 0) ? 1 : -1;
SSIZE_T rts_command_length(UINT32 CommandType, const BYTE* buffer, size_t length)
	int CommandLength = 0;
			CommandLength = rts_padding_command_read(buffer, length);
			CommandLength = rts_client_address_command_read(buffer, length);
			return -1;
	return CommandLength;
	int status;
	BYTE* buffer;
	RpcInChannel* inChannel = rpc->VirtualConnection->DefaultInChannel;
	RpcOutChannel* nextOutChannel = rpc->VirtualConnection->NonDefaultOutChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
	CopyMemory(buffer, ((BYTE*)&header), 20);             /* RTS Header (20 bytes) */
	rts_destination_command_write(&buffer[20], FDServer); /* Destination (8 bytes)*/
	rts_cookie_command_write(&buffer[28],
	                         SuccessorChannelCookie); /* SuccessorChannelCookie (20 bytes) */
	rts_version_command_write(&buffer[48]);           /* Version (8 bytes) */
	status = rpc_channel_write(&inChannel->common, buffer, header.header.frag_length);
	free(buffer);
	return (status > 0) ? 1 : -1;
	int status;
	BYTE* buffer;
	RpcOutChannel* nextOutChannel = rpc->VirtualConnection->NonDefaultOutChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	rts_empty_command_write(&buffer[20]);     /* Empty command (4 bytes) */
	status = rpc_channel_write(&nextOutChannel->common, buffer, header.header.frag_length);
	free(buffer);
	return (status > 0) ? 1 : -1;
int rts_send_OUT_R1_A3_pdu(rdpRpc* rpc)
	int status;
	BYTE* buffer;
	RpcVirtualConnection* connection = rpc->VirtualConnection;
	RpcOutChannel* outChannel = connection->DefaultOutChannel;
	RpcOutChannel* nextOutChannel = connection->NonDefaultOutChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	rts_version_command_write(&buffer[20]);   /* Version (8 bytes) */
	rts_cookie_command_write(&buffer[28],
	                         VirtualConnectionCookie); /* VirtualConnectionCookie (20 bytes) */
	rts_cookie_command_write(&buffer[48],
	                         PredecessorChannelCookie); /* PredecessorChannelCookie (20 bytes) */
	rts_cookie_command_write(&buffer[68],
	                         SuccessorChannelCookie); /* SuccessorChannelCookie (20 bytes) */
	rts_receive_window_size_command_write(&buffer[88],
	                                      ReceiveWindowSize); /* ReceiveWindowSize (8 bytes) */
	status = rpc_channel_write(&nextOutChannel->common, buffer, header.header.frag_length);
	free(buffer);
	return (status > 0) ? 1 : -1;
static int rts_recv_OUT_R1_A2_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	UINT32 offset;
	RpcVirtualConnection* connection = rpc->VirtualConnection;
	offset = 24;
	if (length < offset)
		return -1;
	rts_destination_command_read(rpc, &buffer[offset], length - offset, &Destination);
static int rts_recv_OUT_R2_A6_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	RpcVirtualConnection* connection = rpc->VirtualConnection;
static int rts_recv_OUT_R2_B3_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	RpcVirtualConnection* connection = rpc->VirtualConnection;
int rts_recv_out_of_sequence_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	int status = -1;
	rpcconn_rts_hdr_t* rts;
	RtsPduSignature signature;
	if (!rpc || !buffer)
		return -1;
		return -1;

	rts = (rpcconn_rts_hdr_t*)buffer;
	if (!rts_extract_pdu_signature(&signature, rts))
		return -1;
	if (rts_match_pdu_signature(&RTS_PDU_FLOW_CONTROL_ACK_SIGNATURE, rts))
		status = rts_recv_flow_control_ack_pdu(rpc, buffer, length);
	else if (rts_match_pdu_signature(&RTS_PDU_FLOW_CONTROL_ACK_WITH_DESTINATION_SIGNATURE, rts))
		status = rts_recv_flow_control_ack_with_destination_pdu(rpc, buffer, length);
	else if (rts_match_pdu_signature(&RTS_PDU_PING_SIGNATURE, rts))
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R1_A2_SIGNATURE, rts))
				status = rts_recv_OUT_R1_A2_pdu(rpc, buffer, length);
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R2_A6_SIGNATURE, rts))
				status = rts_recv_OUT_R2_A6_pdu(rpc, buffer, length);
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R2_B3_SIGNATURE, rts))
				status = rts_recv_OUT_R2_B3_pdu(rpc, buffer, length);
	if (status < 0)",d39a7ba5c38e3ba3b99b1558dc2ab0970cbfb0c5,CVE-2021-41159,d39a7ba5c38e3ba3b99b1558dc2ab0970cbfb0c5,https://github.com/FreeRDP/FreeRDP,NVD_GIT_REPOBASED,98,COMPLETED,"  VAR VAR VAR* VAR(VAR VAR) { VAR (VAR) { VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR: VAR ""VAR""; } } VAR VAR = { 0 }; VAR.VAR.VAR = 5; VAR.VAR.VAR = 0; VAR.VAR.VAR = VAR; VAR.VAR.VAR[0] = 0x10; VAR.VAR.VAR[1] = 0x00; VAR.VAR.VAR[2] = 0x00; VAR.VAR.VAR[3] = 0x00; VAR.VAR.VAR = VAR | VAR; VAR.VAR.VAR = 0; VAR.VAR.VAR = 0; VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR) { VAR VAR, VAR; VAR(VAR); VAR(VAR > 0); VAR = VAR(VAR); VAR = VAR(&VAR, VAR); VAR VAR(VAR, VAR); } VAR VAR* VAR(VAR VAR* VAR, VAR VAR) { VAR* VAR; VAR(VAR || (VAR == 0)); VAR (VAR == 0) VAR VAR; VAR = VAR(VAR + 1, VAR(VAR)); VAR (!VAR) VAR VAR; VAR(VAR, VAR, VAR); VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, VAR(VAR))) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR, VAR(VAR->VAR)); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR; } VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR, VAR(VAR->VAR)); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (VAR->VAR < VAR(VAR)) VAR VAR; VAR = VAR(VAR); VAR (VAR < VAR->VAR - VAR(VAR)) VAR VAR; VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR->VAR > VAR->VAR); VAR (VAR) *VAR = VAR(VAR);  { VAR VAR VAR = VAR->VAR - VAR->VAR - 8; VAR(VAR, VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); } VAR (VAR->VAR != 0) { VAR VAR* VAR = VAR(VAR); VAR (!VAR(VAR, VAR->VAR)) VAR VAR; VAR->VAR = (VAR*)VAR(VAR, VAR->VAR); VAR (VAR->VAR == VAR) VAR VAR; } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR(VAR); VAR (!VAR(VAR, VAR, VAR, &VAR)) VAR VAR; { VAR VAR VAR = VAR->VAR - VAR->VAR - 8; VAR(VAR + VAR->VAR == VAR); } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR* VAR) { VAR VAR; VAR VAR = 0; VAR** VAR = VAR; VAR (!VAR(VAR, VAR, VAR, &VAR)) VAR VAR; VAR (VAR->VAR) { VAR VAR: { VAR* VAR = (VAR*)VAR; VAR = VAR->VAR; VAR = &VAR->VAR; } VAR; VAR VAR: { VAR* VAR = (VAR*)VAR; VAR = VAR->VAR; VAR = &VAR->VAR; } VAR; VAR VAR: { VAR* VAR = (VAR*)VAR; VAR = VAR->VAR; VAR = &VAR->VAR; } VAR; VAR: VAR VAR; } VAR (VAR > 0) { VAR VAR VAR = VAR->VAR - VAR->VAR - 8 - VAR->VAR - VAR; VAR VAR* VAR = VAR(VAR) + VAR; *VAR = (VAR*)VAR(VAR, VAR); VAR (!*VAR) VAR VAR; } VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR VAR* VAR, VAR VAR* VAR) { VAR VAR; VAR VAR = 0; VAR(VAR); VAR(VAR); VAR(VAR);  VAR = VAR(VAR); VAR ((VAR % 4) != 0) { VAR = 4 - (VAR % 4); VAR (!VAR(VAR, VAR)) VAR VAR; VAR(VAR, VAR); } VAR(VAR->VAR + 8ull > VAR->VAR); { VAR VAR = VAR(VAR); VAR VAR = VAR->VAR - VAR->VAR - 8; VAR(VAR == VAR); } VAR (!VAR(VAR, VAR(VAR))) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR); VAR(VAR, 0);  VAR(VAR, VAR->VAR); VAR (!VAR(VAR, VAR->VAR)) VAR VAR; VAR(VAR, VAR->VAR, VAR->VAR); VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 2 * VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR; } VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); VAR->VAR = VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR);  VAR (VAR->VAR > 0) { VAR->VAR = VAR(VAR->VAR, VAR(VAR)); VAR (!VAR->VAR) VAR VAR; } VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR* VAR = &VAR->VAR[VAR]; VAR (!VAR(VAR, VAR))  { VAR(VAR); VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR* VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR (VAR->VAR == 0) VAR VAR; VAR = VAR(VAR); VAR (!VAR(VAR, VAR->VAR)) VAR VAR; VAR->VAR = VAR(VAR, VAR->VAR); VAR VAR->VAR != VAR; } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR, VAR(VAR->VAR)); VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, VAR(VAR))) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR, VAR(VAR->VAR)); VAR VAR; } VAR VAR* VAR(VAR VAR) { VAR VAR(VAR, VAR(VAR)); } VAR VAR VAR(VAR* VAR) { VAR(VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR->VAR); VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, 4)) VAR VAR; VAR(VAR, VAR->VAR); VAR VAR; } VAR* VAR(VAR VAR) { VAR* VAR = VAR(VAR, VAR(VAR)); VAR VAR; } VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); VAR(VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR (!VAR(VAR, &VAR->VAR))  VAR VAR; VAR (VAR->VAR > 0) { VAR->VAR = VAR(VAR->VAR); VAR (!VAR->VAR) VAR VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR* VAR = &VAR->VAR[VAR]; VAR (!VAR(VAR, VAR))  VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (!VAR(VAR, 4)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR (!VAR(VAR, &VAR->VAR))  VAR VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR VAR* VAR = &VAR->VAR[VAR]; VAR (!VAR(VAR, VAR))  VAR VAR; } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR (VAR->VAR > 0) { VAR->VAR = VAR(VAR->VAR); VAR (!VAR->VAR) VAR VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR* VAR = &VAR->VAR[VAR]; VAR (!VAR(VAR, VAR)) VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (!VAR(VAR, 4)) VAR VAR; VAR(VAR, VAR->VAR);  VAR(VAR, 0);  VAR(VAR, 0);  VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR VAR* VAR = &VAR->VAR[VAR]; VAR (!VAR(VAR, VAR)) VAR VAR; } VAR VAR; } VAR VAR* VAR(VAR VAR) { VAR VAR(VAR, VAR(VAR)); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 2) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR(VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR (VAR->VAR > 0) { VAR->VAR = VAR(VAR->VAR); VAR (!VAR->VAR) VAR VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR* VAR = &VAR->VAR[VAR];  VAR (!VAR(VAR, VAR)) VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR VAR; VAR (!VAR) VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR* VAR = &VAR->VAR[VAR]; VAR(VAR); } VAR(VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, &VAR->VAR, &VAR->VAR)) VAR VAR; VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, 4)) VAR VAR; VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, &VAR->VAR, &VAR->VAR)) VAR VAR; VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, &VAR->VAR, &VAR->VAR)) VAR VAR; VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, 4)) VAR VAR; VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR VAR(VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, 8)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR(VAR); } VAR VAR(VAR* VAR, VAR VAR) { VAR (!VAR) VAR; VAR (VAR->VAR.VAR) { VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR;  VAR VAR: VAR;  VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR: VAR; } VAR (VAR) VAR(VAR); } VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR = VAR; VAR(VAR); VAR(VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR(VAR, ""VAR VAR VAR %VAR"", VAR(VAR->VAR.VAR)); VAR(VAR); VAR (VAR->VAR.VAR) { VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR;  VAR;  VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR: VAR; } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, VAR(VAR))) VAR VAR; VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR -1; VAR(VAR, VAR); *VAR = VAR;  VAR VAR VAR(VAR* VAR, VAR VAR) VAR(VAR); VAR (!VAR(VAR, 2 * VAR(VAR))) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR* VAR, VAR* VAR, VAR* VAR) VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 24) VAR -1; VAR(VAR, VAR); *VAR = VAR;  VAR(VAR, VAR); *VAR = VAR;  VAR(VAR, VAR, 16);  VAR VAR(VAR, 16); VAR VAR VAR(VAR* VAR, VAR VAR, VAR VAR, VAR* VAR) VAR(VAR); VAR (!VAR(VAR, 28)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR);  VAR(VAR, VAR);  VAR(VAR, VAR, 16);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR* VAR) VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR); VAR (VAR) *VAR = VAR;  VAR VAR; VAR VAR VAR(VAR* VAR, VAR VAR* VAR) VAR(VAR); VAR (!VAR(VAR, 20)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR, 16);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR VAR) VAR(VAR); VAR (!VAR(VAR, 8)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR VAR) VAR(VAR); VAR (!VAR(VAR, 8)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR(VAR); VAR(VAR); VAR (!VAR(VAR, 4)) VAR VAR;  VAR VAR; VAR VAR VAR(VAR* VAR) VAR(VAR); VAR (VAR(VAR) < 8) VAR VAR; VAR(VAR, VAR);  VAR(VAR, 1);  VAR VAR; VAR VAR VAR(VAR* VAR) VAR(VAR); VAR (!VAR(VAR, 8)) VAR VAR; VAR(VAR, VAR);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR);  *VAR = VAR + 4; VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR);  *VAR = 4 + 4 + 12; *VAR = 4 + 16 + 12; VAR VAR; VAR VAR VAR(VAR* VAR, VAR VAR* VAR) VAR(VAR); VAR (!VAR(VAR, 20)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR, 16);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR* VAR) VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR -1; VAR(VAR, VAR); *VAR = VAR;  VAR VAR VAR(VAR* VAR, VAR VAR) VAR(VAR); VAR (!VAR(VAR, 8)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR);  VAR VAR; VAR(VAR); VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) { VAR VAR = VAR; VAR VAR; VAR(VAR); VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR (VAR(VAR) != VAR) VAR VAR; VAR = VAR(VAR, VAR(VAR), VAR(VAR)); VAR (VAR < 0) VAR VAR; VAR ((VAR)VAR != VAR(VAR)) VAR VAR; VAR = VAR; VAR: VAR VAR; } VAR VAR(VAR* VAR) VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR (!VAR(VAR, &VAR))  VAR VAR; VAR = VAR(VAR);  VAR (!VAR) VAR VAR; VAR = VAR( VAR, VAR);  VAR (!VAR) VAR VAR; VAR = VAR(VAR, VAR);  VAR (!VAR) VAR VAR; VAR = VAR( VAR, VAR);  VAR (!VAR) VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR VAR; VAR VAR(VAR* VAR, VAR* VAR) VAR VAR; VAR (!VAR(VAR, 24)) VAR VAR; VAR = VAR(VAR, VAR, &VAR); VAR (!VAR) VAR VAR; VAR(VAR); VAR(VAR->VAR); VAR(VAR->VAR->VAR); VAR VAR; VAR VAR(VAR* VAR) VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR VAR; VAR (!VAR(VAR, &VAR))  VAR VAR; VAR (!VAR(VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR->VAR))  VAR VAR; VAR (!VAR(VAR, VAR->VAR))  VAR VAR; VAR (!VAR( VAR, VAR))  VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR VAR; VAR VAR(VAR* VAR, VAR* VAR) VAR VAR; VAR(VAR); VAR(VAR); VAR (!VAR(VAR, 24)) VAR VAR; VAR = VAR(VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR, VAR, &VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR, VAR, &VAR); VAR (VAR < 0) VAR VAR; VAR(VAR); VAR(VAR->VAR); VAR(VAR->VAR->VAR); VAR VAR; VAR VAR(VAR* VAR) VAR VAR = VAR; VAR* VAR; VAR VAR; VAR VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR VAR; VAR (!VAR(VAR, &VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR, VAR, VAR)) VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR VAR; VAR VAR[16] = { 0 }; VAR = VAR(VAR, VAR, &VAR, &VAR, (VAR*)&VAR); VAR (VAR < 0) VAR VAR; VAR(VAR->VAR); VAR(VAR->VAR->VAR); VAR VAR VAR(VAR* VAR, VAR* VAR) VAR VAR; VAR VAR[16] = { 0 }; VAR = VAR(VAR, VAR, &VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR, VAR, &VAR, &VAR, VAR); VAR (VAR < 0) VAR VAR; VAR(VAR->VAR); VAR(VAR->VAR->VAR); VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR(VAR->VAR); VAR = VAR->VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR VAR; VAR (!VAR(VAR, &VAR))  VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR (VAR) ? 1 : -1; VAR VAR(VAR VAR, VAR* VAR, VAR* VAR) VAR VAR = 0; VAR VAR = 0; VAR(VAR); VAR (!VAR(VAR, &VAR)) VAR VAR; VAR (!VAR(VAR, &VAR)) VAR VAR; VAR VAR; VAR += VAR; VAR (VAR(VAR) < VAR) VAR VAR; VAR (VAR) *VAR = VAR; VAR VAR; VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR(VAR->VAR); VAR = VAR->VAR->VAR; VAR(VAR); VAR = VAR->VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR (!VAR(VAR, &VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR))  VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR (VAR) ? 1 : -1; VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR(VAR->VAR); VAR = VAR->VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR (!VAR(VAR, &VAR))  VAR VAR; VAR (!VAR(VAR))  VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR (VAR) ? 1 : -1; VAR VAR(VAR* VAR) VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR (!VAR(VAR, &VAR))  VAR VAR; VAR (!VAR(VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR( VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR* VAR; VAR(VAR); VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR, &VAR); VAR (VAR < 0) VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR* VAR; VAR(VAR); VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR VAR VAR(VAR* VAR, VAR* VAR) VAR* VAR; VAR(VAR); VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR VAR(VAR* VAR, VAR* VAR, VAR VAR* VAR) VAR VAR = VAR; VAR VAR, VAR; VAR VAR = { 0 }; VAR(VAR); VAR(VAR); VAR(VAR); VAR = VAR(VAR); VAR = VAR->VAR.VAR; VAR (VAR < VAR) VAR VAR; VAR VAR; VAR (!VAR(&VAR, VAR, VAR)) VAR VAR; VAR (VAR(&VAR, VAR, VAR)) VAR = VAR(VAR, VAR); VAR VAR (VAR(&VAR, VAR, VAR)) VAR = VAR(VAR, VAR); VAR VAR (VAR(&VAR, VAR, VAR)) VAR (VAR(&VAR, VAR, VAR)) VAR = VAR(VAR, VAR); VAR (VAR(&VAR, VAR, VAR)) VAR = VAR(VAR, VAR); VAR (VAR(&VAR, VAR, VAR)) VAR = VAR(VAR, VAR); VAR (!VAR) VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, 2 * VAR(VAR))) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, 8)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR = { 0 }; VAR.VAR.VAR = 5; VAR.VAR.VAR = 0; VAR.VAR.VAR = VAR; VAR.VAR.VAR[0] = 0x10; VAR.VAR.VAR[1] = 0x00; VAR.VAR.VAR[2] = 0x00; VAR.VAR.VAR[3] = 0x00; VAR.VAR.VAR = VAR | VAR; VAR.VAR.VAR = 0; VAR.VAR.VAR = 0; VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR, *VAR = *((VAR*)&VAR[0]);  VAR VAR VAR(VAR* VAR, VAR VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR, VAR* VAR, VAR* VAR, VAR* VAR) *VAR = *((VAR*)&VAR[0]);  *VAR = *((VAR*)&VAR[4]);  VAR(VAR, &VAR[8], 16);  VAR VAR VAR(VAR* VAR, VAR VAR, VAR VAR, VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;   *((VAR*)&VAR[4]) = VAR;  *((VAR*)&VAR[8]) = VAR;  VAR(&VAR[12], VAR, 16);  } VAR 28; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR, VAR* VAR) { VAR (VAR) *VAR = *((VAR*)&VAR[0]);  VAR 4; VAR VAR VAR(VAR* VAR, VAR VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 16; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  VAR(&VAR[4], VAR, 16);  } VAR 20; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 4; VAR VAR VAR(VAR* VAR, VAR VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 4; VAR VAR VAR(VAR* VAR, VAR VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 4; VAR VAR VAR(VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = 1;  } VAR 8; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) { VAR 0; VAR VAR VAR(VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  } VAR 4; } VAR VAR VAR(VAR VAR* VAR, VAR VAR) { VAR VAR; VAR = *((VAR*)&VAR[0]);   VAR VAR + 4; } VAR VAR VAR(VAR* VAR, VAR VAR) { VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  VAR(&VAR[8], VAR);  } VAR 8 + VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR 0; } VAR VAR VAR(VAR* VAR) { VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  } VAR 4; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) { VAR 0; VAR VAR VAR(VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  } VAR 4; VAR VAR VAR(VAR VAR* VAR, VAR VAR) VAR = *((VAR*)&VAR[0]);  VAR 4 + 4 + 12; VAR 4 + 16 + 12; VAR VAR VAR(VAR* VAR, VAR VAR, VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR (VAR == 0) { VAR (VAR) { VAR(&VAR[8], VAR, 4);  VAR(&VAR[12], 12);  } VAR 24; } VAR { VAR (VAR) { VAR(&VAR[8], VAR, 16);  VAR(&VAR[24], 12);  } VAR 36; } } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 16; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  VAR(&VAR[4], VAR, 16);  } VAR 20; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR, VAR* VAR) { *VAR = *((VAR*)&VAR[0]);  VAR VAR VAR(VAR* VAR, VAR VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 4; } VAR VAR VAR(VAR* VAR, VAR VAR) { VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; VAR VAR(VAR* VAR) VAR VAR; VAR* VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20]);  VAR(&VAR[28], VAR);  VAR(&VAR[48], VAR);  VAR(&VAR[68], VAR);  VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR(VAR, &VAR[24], VAR - 24, &VAR); VAR 1; VAR VAR(VAR* VAR) VAR VAR; VAR* VAR; VAR VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR -1; VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20]);  VAR(&VAR[28], VAR);  VAR(&VAR[48], VAR);  VAR(&VAR[68], VAR->VAR);  VAR(&VAR[76], VAR->VAR);  VAR(&VAR[84], VAR);  VAR = VAR.VAR.VAR; VAR = VAR(&VAR->VAR, VAR, VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR VAR; VAR = 24; VAR += VAR(VAR, &VAR[VAR], VAR - VAR) + 4; VAR += VAR(VAR, &VAR[VAR], VAR - VAR, &VAR) + 4; VAR += VAR(VAR, &VAR[VAR], VAR - VAR, &VAR) + 4; VAR 1; VAR VAR VAR(VAR* VAR) VAR VAR; VAR* VAR; VAR VAR; VAR* VAR = VAR->VAR->VAR; VAR.VAR.VAR = 28; VAR.VAR = VAR; VAR.VAR = 1; VAR(VAR, ""VAR VAR-VAR VAR VAR""); VAR = (VAR*)VAR(VAR.VAR.VAR); VAR (!VAR) VAR -1; VAR(VAR, ((VAR*)&VAR), 20);  VAR( &VAR[20], VAR->VAR);  VAR = VAR.VAR.VAR; VAR = VAR(&VAR->VAR, VAR, VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; } VAR VAR(VAR* VAR) { VAR VAR; VAR* VAR; VAR VAR; VAR VAR = VAR(); VAR VAR; VAR VAR; VAR* VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR -1; VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20], VAR);  VAR(&VAR[28], VAR, VAR, VAR); VAR = VAR.VAR.VAR; VAR = VAR(&VAR->VAR, VAR, VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR VAR; VAR VAR[16]; VAR = 24; VAR += VAR(VAR, &VAR[VAR], VAR - VAR, &VAR, &VAR, (VAR*)&VAR) + 4; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR VAR; VAR VAR[16]; VAR = 24; VAR += VAR(VAR, &VAR[VAR], VAR - VAR, &VAR) + 4; VAR += VAR(VAR, &VAR[VAR], VAR - VAR, &VAR, &VAR, (VAR*)&VAR) + 4; VAR VAR; VAR* VAR; VAR VAR; VAR* VAR = VAR->VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR -1; VAR(VAR, ((VAR*)&VAR), 20);  VAR = VAR.VAR.VAR; VAR = VAR(&VAR->VAR, VAR, VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR(VAR VAR, VAR VAR* VAR, VAR VAR) VAR VAR = 0; VAR = VAR(VAR, VAR); VAR = VAR(VAR, VAR); VAR -1; VAR VAR; VAR VAR; VAR* VAR; VAR* VAR = VAR->VAR->VAR; VAR* VAR = VAR->VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20], VAR);  VAR(&VAR[28], VAR);  VAR(&VAR[48]);  VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR; VAR* VAR; VAR* VAR = VAR->VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20]);  VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR(VAR* VAR) VAR VAR; VAR* VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20]);  VAR(&VAR[28], VAR);  VAR(&VAR[48], VAR);  VAR(&VAR[68], VAR);  VAR(&VAR[88], VAR);  VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR VAR; VAR* VAR = VAR->VAR; VAR = 24; VAR (VAR < VAR) VAR -1; VAR(VAR, &VAR[VAR], VAR - VAR, &VAR); VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR* VAR = VAR->VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR* VAR = VAR->VAR; VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR VAR = -1; VAR* VAR; VAR VAR; VAR (!VAR || !VAR) VAR -1; VAR -1; VAR = (VAR*)VAR; VAR (!VAR(&VAR, VAR)) VAR -1; VAR (VAR(&VAR, VAR)) VAR = VAR(VAR, VAR, VAR); VAR VAR (VAR(&VAR, VAR)) VAR = VAR(VAR, VAR, VAR); VAR VAR (VAR(&VAR, VAR)) VAR (VAR(&VAR, VAR)) VAR = VAR(VAR, VAR, VAR); VAR (VAR(&VAR, VAR)) VAR = VAR(VAR, VAR, VAR); VAR (VAR(&VAR, VAR)) VAR = VAR(VAR, VAR, VAR); VAR (VAR < 0)",7
FreeRDP_d39a7ba5c38e3ba3b99b1558dc2ab0970cbfb0c5,libfreerdp/core/gateway/rts.c,"#include <assert.h>
#include ""rts_signature.h""
static const char* rts_pdu_ptype_to_string(UINT32 ptype)
{
	switch (ptype)
	{
		case PTYPE_REQUEST:
			return ""PTYPE_REQUEST"";
		case PTYPE_PING:
			return ""PTYPE_PING"";
		case PTYPE_RESPONSE:
			return ""PTYPE_RESPONSE"";
		case PTYPE_FAULT:
			return ""PTYPE_FAULT"";
		case PTYPE_WORKING:
			return ""PTYPE_WORKING"";
		case PTYPE_NOCALL:
			return ""PTYPE_NOCALL"";
		case PTYPE_REJECT:
			return ""PTYPE_REJECT"";
		case PTYPE_ACK:
			return ""PTYPE_ACK"";
		case PTYPE_CL_CANCEL:
			return ""PTYPE_CL_CANCEL"";
		case PTYPE_FACK:
			return ""PTYPE_FACK"";
		case PTYPE_CANCEL_ACK:
			return ""PTYPE_CANCEL_ACK"";
		case PTYPE_BIND:
			return ""PTYPE_BIND"";
		case PTYPE_BIND_ACK:
			return ""PTYPE_BIND_ACK"";
		case PTYPE_BIND_NAK:
			return ""PTYPE_BIND_NAK"";
		case PTYPE_ALTER_CONTEXT:
			return ""PTYPE_ALTER_CONTEXT"";
		case PTYPE_ALTER_CONTEXT_RESP:
			return ""PTYPE_ALTER_CONTEXT_RESP"";
		case PTYPE_RPC_AUTH_3:
			return ""PTYPE_RPC_AUTH_3"";
		case PTYPE_SHUTDOWN:
			return ""PTYPE_SHUTDOWN"";
		case PTYPE_CO_CANCEL:
			return ""PTYPE_CO_CANCEL"";
		case PTYPE_ORPHANED:
			return ""PTYPE_ORPHANED"";
		case PTYPE_RTS:
			return ""PTYPE_RTS"";
		default:
			return ""UNKNOWN"";
	}
}
	rpcconn_rts_hdr_t header = { 0 };
	header.header.rpc_vers = 5;
	header.header.rpc_vers_minor = 0;
	header.header.ptype = PTYPE_RTS;
	header.header.packed_drep[0] = 0x10;
	header.header.packed_drep[1] = 0x00;
	header.header.packed_drep[2] = 0x00;
	header.header.packed_drep[3] = 0x00;
	header.header.pfc_flags = PFC_FIRST_FRAG | PFC_LAST_FRAG;
	header.header.auth_length = 0;
	header.header.call_id = 0;

	return header;
}

static BOOL rts_align_stream(wStream* s, size_t alignment)
{
	size_t pos, pad;

	assert(s);
	assert(alignment > 0);

	pos = Stream_GetPosition(s);
	pad = rpc_offset_align(&pos, alignment);
	return Stream_SafeSeek(s, pad);
}

static char* sdup(const void* src, size_t length)
{
	char* dst;
	assert(src || (length == 0));
	if (length == 0)
		return NULL;

	dst = calloc(length + 1, sizeof(char));
	if (!dst)
		return NULL;
	memcpy(dst, src, length);
	return dst;
}

static BOOL rts_write_common_pdu_header(wStream* s, const rpcconn_common_hdr_t* header)
{
	assert(s);
	assert(header);
	if (!Stream_EnsureRemainingCapacity(s, sizeof(rpcconn_common_hdr_t)))
		return FALSE;

	Stream_Write_UINT8(s, header->rpc_vers);
	Stream_Write_UINT8(s, header->rpc_vers_minor);
	Stream_Write_UINT8(s, header->ptype);
	Stream_Write_UINT8(s, header->pfc_flags);
	Stream_Write(s, header->packed_drep, ARRAYSIZE(header->packed_drep));
	Stream_Write_UINT16(s, header->frag_length);
	Stream_Write_UINT16(s, header->auth_length);
	Stream_Write_UINT32(s, header->call_id);
	return TRUE;
}

BOOL rts_read_common_pdu_header(wStream* s, rpcconn_common_hdr_t* header)
{
	size_t left;
	assert(s);
	assert(header);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_common_hdr_t))
		return FALSE;

	Stream_Read_UINT8(s, header->rpc_vers);
	Stream_Read_UINT8(s, header->rpc_vers_minor);
	Stream_Read_UINT8(s, header->ptype);
	Stream_Read_UINT8(s, header->pfc_flags);
	Stream_Read(s, header->packed_drep, ARRAYSIZE(header->packed_drep));
	Stream_Read_UINT16(s, header->frag_length);
	Stream_Read_UINT16(s, header->auth_length);
	Stream_Read_UINT32(s, header->call_id);

	if (header->frag_length < sizeof(rpcconn_common_hdr_t))
		return FALSE;

	left = Stream_GetRemainingLength(s);
	if (left < header->frag_length - sizeof(rpcconn_common_hdr_t))
		return FALSE;

	return TRUE;
}

static BOOL rts_read_auth_verifier_no_checks(wStream* s, auth_verifier_co_t* auth,
                                             const rpcconn_common_hdr_t* header, size_t* startPos)
{
	assert(s);
	assert(auth);
	assert(header);

	assert(header->frag_length > header->auth_length);

	if (startPos)
		*startPos = Stream_GetPosition(s);

	/* Read the auth verifier and check padding matches frag_length */
	{
		const size_t expected = header->frag_length - header->auth_length - 8;

		Stream_SetPosition(s, expected);
		if (Stream_GetRemainingLength(s) < sizeof(auth_verifier_co_t))
			return FALSE;

		Stream_Read_UINT8(s, auth->auth_type);
		Stream_Read_UINT8(s, auth->auth_level);
		Stream_Read_UINT8(s, auth->auth_pad_length);
		Stream_Read_UINT8(s, auth->auth_reserved);
		Stream_Read_UINT32(s, auth->auth_context_id);
	}

	if (header->auth_length != 0)
	{
		const void* ptr = Stream_Pointer(s);
		if (!Stream_SafeSeek(s, header->auth_length))
			return FALSE;
		auth->auth_value = (BYTE*)sdup(ptr, header->auth_length);
		if (auth->auth_value == NULL)
			return FALSE;
	}

	return TRUE;
}

static BOOL rts_read_auth_verifier(wStream* s, auth_verifier_co_t* auth,
                                   const rpcconn_common_hdr_t* header)
{
	size_t pos;
	assert(s);
	assert(auth);
	assert(header);

	if (!rts_read_auth_verifier_no_checks(s, auth, header, &pos))
		return FALSE;

	{
		const size_t expected = header->frag_length - header->auth_length - 8;
		assert(pos + auth->auth_pad_length == expected);
	}

	return TRUE;
}

static BOOL rts_read_auth_verifier_with_stub(wStream* s, auth_verifier_co_t* auth,
                                             rpcconn_common_hdr_t* header)
{
	size_t pos;
	size_t alloc_hint = 0;
	BYTE** ptr = NULL;

	if (!rts_read_auth_verifier_no_checks(s, auth, header, &pos))
		return FALSE;

	switch (header->ptype)
	{
		case PTYPE_FAULT:
		{
			rpcconn_fault_hdr_t* hdr = (rpcconn_fault_hdr_t*)header;
			alloc_hint = hdr->alloc_hint;
			ptr = &hdr->stub_data;
		}
		break;
		case PTYPE_RESPONSE:
		{
			rpcconn_response_hdr_t* hdr = (rpcconn_response_hdr_t*)header;
			alloc_hint = hdr->alloc_hint;
			ptr = &hdr->stub_data;
		}
		break;
		case PTYPE_REQUEST:
		{
			rpcconn_request_hdr_t* hdr = (rpcconn_request_hdr_t*)header;
			alloc_hint = hdr->alloc_hint;
			ptr = &hdr->stub_data;
		}
		break;
		default:
			return FALSE;
	}

	if (alloc_hint > 0)
	{
		const size_t size =
		    header->frag_length - header->auth_length - 8 - auth->auth_pad_length - pos;
		const void* src = Stream_Buffer(s) + pos;

		*ptr = (BYTE*)sdup(src, size);
		if (!*ptr)
			return FALSE;
	}

	return TRUE;
}

static void rts_free_auth_verifier(auth_verifier_co_t* auth)
{
	if (!auth)
		return;
	free(auth->auth_value);
}

static BOOL rts_write_auth_verifier(wStream* s, const auth_verifier_co_t* auth,
                                    const rpcconn_common_hdr_t* header)
{
	size_t pos;
	UINT8 auth_pad_length = 0;

	assert(s);
	assert(auth);
	assert(header);

	/* Align start to a multiple of 4 */
	pos = Stream_GetPosition(s);
	if ((pos % 4) != 0)
	{
		auth_pad_length = 4 - (pos % 4);
		if (!Stream_EnsureRemainingCapacity(s, auth_pad_length))
			return FALSE;
		Stream_Zero(s, auth_pad_length);
	}

	assert(header->frag_length + 8ull > header->auth_length);
	{
		size_t pos = Stream_GetPosition(s);
		size_t expected = header->frag_length - header->auth_length - 8;

		assert(pos == expected);
	}

	if (!Stream_EnsureRemainingCapacity(s, sizeof(auth_verifier_co_t)))
		return FALSE;

	Stream_Write_UINT8(s, auth->auth_type);
	Stream_Write_UINT8(s, auth->auth_level);
	Stream_Write_UINT8(s, auth_pad_length);
	Stream_Write_UINT8(s, 0); /* auth->auth_reserved */
	Stream_Write_UINT32(s, auth->auth_context_id);

	if (!Stream_EnsureRemainingCapacity(s, header->auth_length))
		return FALSE;
	Stream_Write(s, auth->auth_value, header->auth_length);
	return TRUE;
}

static BOOL rts_read_version(wStream* s, p_rt_version_t* version)
{
	assert(s);
	assert(version);

	if (Stream_GetRemainingLength(s) < 2 * sizeof(UINT8))
		return FALSE;
	Stream_Read_UINT8(s, version->major);
	Stream_Read_UINT8(s, version->minor);
	return TRUE;
}

void rts_free_supported_versions(p_rt_versions_supported_t* versions)
{
	if (!versions)
		return;
	free(versions->p_protocols);
	versions->p_protocols = NULL;
}

static BOOL rts_read_supported_versions(wStream* s, p_rt_versions_supported_t* versions)
{
	BYTE x;

	assert(s);
	assert(versions);

	if (Stream_GetRemainingLength(s) < sizeof(UINT8))
		return FALSE;

	Stream_Read_UINT8(s, versions->n_protocols); /* count */

	if (versions->n_protocols > 0)
	{
		versions->p_protocols = calloc(versions->n_protocols, sizeof(p_rt_version_t));
		if (!versions->p_protocols)
			return FALSE;
	}
	for (x = 0; x < versions->n_protocols; x++)
	{
		p_rt_version_t* version = &versions->p_protocols[x];
		if (!rts_read_version(s, version)) /* size_is(n_protocols) */
		{
			rts_free_supported_versions(versions);
			return FALSE;
		}
	}

	return TRUE;
}

static BOOL rts_read_port_any(wStream* s, port_any_t* port)
{
	const void* ptr;

	assert(s);
	assert(port);

	if (Stream_GetRemainingLength(s) < sizeof(UINT16))
		return FALSE;

	Stream_Read_UINT16(s, port->length);
	if (port->length == 0)
		return TRUE;

	ptr = Stream_Pointer(s);
	if (!Stream_SafeSeek(s, port->length))
		return FALSE;
	port->port_spec = sdup(ptr, port->length);
	return port->port_spec != NULL;
}

static void rts_free_port_any(port_any_t* port)
{
	if (!port)
		return;
	free(port->port_spec);
}

static BOOL rts_read_uuid(wStream* s, p_uuid_t* uuid)
{
	assert(s);
	assert(uuid);

	if (Stream_GetRemainingLength(s) < sizeof(p_uuid_t))
		return FALSE;

	Stream_Read_UINT32(s, uuid->time_low);
	Stream_Read_UINT16(s, uuid->time_mid);
	Stream_Read_UINT16(s, uuid->time_hi_and_version);
	Stream_Read_UINT8(s, uuid->clock_seq_hi_and_reserved);
	Stream_Read_UINT8(s, uuid->clock_seq_low);
	Stream_Read(s, uuid->node, ARRAYSIZE(uuid->node));
	return TRUE;
}

static BOOL rts_write_uuid(wStream* s, const p_uuid_t* uuid)
{
	assert(s);
	assert(uuid);

	if (!Stream_EnsureRemainingCapacity(s, sizeof(p_uuid_t)))
		return FALSE;

	Stream_Write_UINT32(s, uuid->time_low);
	Stream_Write_UINT16(s, uuid->time_mid);
	Stream_Write_UINT16(s, uuid->time_hi_and_version);
	Stream_Write_UINT8(s, uuid->clock_seq_hi_and_reserved);
	Stream_Write_UINT8(s, uuid->clock_seq_low);
	Stream_Write(s, uuid->node, ARRAYSIZE(uuid->node));
	return TRUE;
}

static p_syntax_id_t* rts_syntax_id_new(size_t count)
{
	return calloc(count, sizeof(p_syntax_id_t));
}

static void rts_syntax_id_free(p_syntax_id_t* ptr)
{
	free(ptr);
}

static BOOL rts_read_syntax_id(wStream* s, p_syntax_id_t* syntax_id)
{
	assert(s);
	assert(syntax_id);

	if (!rts_read_uuid(s, &syntax_id->if_uuid))
		return FALSE;

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;

	Stream_Read_UINT32(s, syntax_id->if_version);
	return TRUE;
}

static BOOL rts_write_syntax_id(wStream* s, const p_syntax_id_t* syntax_id)
{
	assert(s);
	assert(syntax_id);

	if (!rts_write_uuid(s, &syntax_id->if_uuid))
		return FALSE;

	if (!Stream_EnsureRemainingCapacity(s, 4))
		return FALSE;

	Stream_Write_UINT32(s, syntax_id->if_version);
	return TRUE;
}

p_cont_elem_t* rts_context_elem_new(size_t count)
{
	p_cont_elem_t* ctx = calloc(count, sizeof(p_cont_elem_t));
	return ctx;
}

void rts_context_elem_free(p_cont_elem_t* ptr)
{
	if (!ptr)
		return;
	rts_syntax_id_free(ptr->transfer_syntaxes);
	free(ptr);
}

static BOOL rts_read_context_elem(wStream* s, p_cont_elem_t* element)
{
	BYTE x;
	assert(s);
	assert(element);

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;

	Stream_Read_UINT16(s, element->p_cont_id);
	Stream_Read_UINT8(s, element->n_transfer_syn); /* number of items */
	Stream_Read_UINT8(s, element->reserved);       /* alignment pad, m.b.z. */

	if (!rts_read_syntax_id(s, &element->abstract_syntax)) /* transfer syntax list */
		return FALSE;

	if (element->n_transfer_syn > 0)
	{
		element->transfer_syntaxes = rts_syntax_id_new(element->n_transfer_syn);
		if (!element->transfer_syntaxes)
			return FALSE;
		for (x = 0; x < element->n_transfer_syn; x++)
		{
			p_syntax_id_t* syn = &element->transfer_syntaxes[x];
			if (!rts_read_syntax_id(s, syn)) /* size_is(n_transfer_syn) */
				return FALSE;
		}
	}

	return TRUE;
}

static BOOL rts_write_context_elem(wStream* s, const p_cont_elem_t* element)
{
	BYTE x;
	assert(s);
	assert(element);

	if (!Stream_EnsureRemainingCapacity(s, 4))
		return FALSE;
	Stream_Write_UINT16(s, element->p_cont_id);
	Stream_Write_UINT8(s, element->n_transfer_syn);         /* number of items */
	Stream_Write_UINT8(s, element->reserved);               /* alignment pad, m.b.z. */
	if (!rts_write_syntax_id(s, &element->abstract_syntax)) /* transfer syntax list */
		return FALSE;

	for (x = 0; x < element->n_transfer_syn; x++)
	{
		const p_syntax_id_t* syn = &element->transfer_syntaxes[x];
		if (!rts_write_syntax_id(s, syn)) /* size_is(n_transfer_syn) */
			return FALSE;
	}

	return TRUE;
}

static BOOL rts_read_context_list(wStream* s, p_cont_list_t* list)
{
	BYTE x;

	assert(s);
	assert(list);

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;
	Stream_Read_UINT8(s, list->n_context_elem); /* number of items */
	Stream_Read_UINT8(s, list->reserved);       /* alignment pad, m.b.z. */
	Stream_Read_UINT16(s, list->reserved2);     /* alignment pad, m.b.z. */

	if (list->n_context_elem > 0)
	{
		list->p_cont_elem = rts_context_elem_new(list->n_context_elem);
		if (!list->p_cont_elem)
			return FALSE;
		for (x = 0; x < list->n_context_elem; x++)
		{
			p_cont_elem_t* element = &list->p_cont_elem[x];
			if (!rts_read_context_elem(s, element))
				return FALSE;
		}
	}
	return TRUE;
}

static void rts_free_context_list(p_cont_list_t* list)
{
	if (!list)
		return;
	rts_context_elem_free(list->p_cont_elem);
}

static BOOL rts_write_context_list(wStream* s, const p_cont_list_t* list)
{
	BYTE x;

	assert(s);
	assert(list);

	if (!Stream_EnsureRemainingCapacity(s, 4))
		return FALSE;
	Stream_Write_UINT8(s, list->n_context_elem); /* number of items */
	Stream_Write_UINT8(s, 0);                    /* alignment pad, m.b.z. */
	Stream_Write_UINT16(s, 0);                   /* alignment pad, m.b.z. */

	for (x = 0; x < list->n_context_elem; x++)
	{
		const p_cont_elem_t* element = &list->p_cont_elem[x];
		if (!rts_write_context_elem(s, element))
			return FALSE;
	}
	return TRUE;
}

static p_result_t* rts_result_new(size_t count)
{
	return calloc(count, sizeof(p_result_t));
}

static void rts_result_free(p_result_t* results)
{
	if (!results)
		return;
	free(results);
}

static BOOL rts_read_result(wStream* s, p_result_t* result)
{
	assert(s);
	assert(result);

	if (Stream_GetRemainingLength(s) < 2)
		return FALSE;
	Stream_Read_UINT16(s, result->result);
	Stream_Read_UINT16(s, result->reason);

	return rts_read_syntax_id(s, &result->transfer_syntax);
}

static void rts_free_result(p_result_t* result)
{
	if (!result)
		return;
}

static BOOL rts_read_result_list(wStream* s, p_result_list_t* list)
{
	BYTE x;

	assert(s);
	assert(list);

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;
	Stream_Read_UINT8(s, list->n_results);  /* count */
	Stream_Read_UINT8(s, list->reserved);   /* alignment pad, m.b.z. */
	Stream_Read_UINT16(s, list->reserved2); /* alignment pad, m.b.z. */

	if (list->n_results > 0)
	{
		list->p_results = rts_result_new(list->n_results);
		if (!list->p_results)
			return FALSE;

		for (x = 0; x < list->n_results; x++)
		{
			p_result_t* result = &list->p_results[x]; /* size_is(n_results) */
			if (!rts_read_result(s, result))
				return FALSE;
		}
	}

	return TRUE;
}

static void rts_free_result_list(p_result_list_t* list)
{
	BYTE x;

	if (!list)
		return;
	for (x = 0; x < list->n_results; x++)
	{
		p_result_t* result = &list->p_results[x];
		rts_free_result(result);
	}
	rts_result_free(list->p_results);
}

static void rts_free_pdu_alter_context(rpcconn_alter_context_hdr_t* ctx)
{
	if (!ctx)
		return;

	rts_free_context_list(&ctx->p_context_elem);
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_alter_context(wStream* s, rpcconn_alter_context_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_alter_context_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;

	Stream_Read_UINT16(s, ctx->max_xmit_frag);
	Stream_Read_UINT16(s, ctx->max_recv_frag);
	Stream_Read_UINT32(s, ctx->assoc_group_id);

	if (!rts_read_context_list(s, &ctx->p_context_elem))
		return FALSE;

	if (!rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header))
		return FALSE;

	return TRUE;
}

static BOOL rts_read_pdu_alter_context_response(wStream* s,
                                                rpcconn_alter_context_response_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_alter_context_response_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT16(s, ctx->max_xmit_frag);
	Stream_Read_UINT16(s, ctx->max_recv_frag);
	Stream_Read_UINT32(s, ctx->assoc_group_id);

	if (!rts_read_port_any(s, &ctx->sec_addr))
		return FALSE;

	if (!rts_align_stream(s, 4))
		return FALSE;

	if (!rts_read_result_list(s, &ctx->p_result_list))
		return FALSE;

	if (!rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header))
		return FALSE;

	return TRUE;
}

static void rts_free_pdu_alter_context_response(rpcconn_alter_context_response_hdr_t* ctx)
{
	if (!ctx)
		return;

	rts_free_port_any(&ctx->sec_addr);
	rts_free_result_list(&ctx->p_result_list);
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_bind(wStream* s, rpcconn_bind_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_bind_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT16(s, ctx->max_xmit_frag);
	Stream_Read_UINT16(s, ctx->max_recv_frag);
	Stream_Read_UINT32(s, ctx->assoc_group_id);

	if (!rts_read_context_list(s, &ctx->p_context_elem))
		return FALSE;

	if (!rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header))
		return FALSE;

	return TRUE;
}

static void rts_free_pdu_bind(rpcconn_bind_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_context_list(&ctx->p_context_elem);
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_bind_ack(wStream* s, rpcconn_bind_ack_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_bind_ack_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT16(s, ctx->max_xmit_frag);
	Stream_Read_UINT16(s, ctx->max_recv_frag);
	Stream_Read_UINT32(s, ctx->assoc_group_id);

	if (!rts_read_port_any(s, &ctx->sec_addr))
		return FALSE;

	if (!rts_align_stream(s, 4))
		return FALSE;

	if (!rts_read_result_list(s, &ctx->p_result_list))
		return FALSE;

	return rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_bind_ack(rpcconn_bind_ack_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_port_any(&ctx->sec_addr);
	rts_free_result_list(&ctx->p_result_list);
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_bind_nak(wStream* s, rpcconn_bind_nak_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_bind_nak_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT16(s, ctx->provider_reject_reason);
	return rts_read_supported_versions(s, &ctx->versions);
}

static void rts_free_pdu_bind_nak(rpcconn_bind_nak_hdr_t* ctx)
{
	if (!ctx)
		return;

	rts_free_supported_versions(&ctx->versions);
}

static BOOL rts_read_pdu_auth3(wStream* s, rpcconn_rpc_auth_3_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_rpc_auth_3_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT16(s, ctx->max_xmit_frag);
	Stream_Read_UINT16(s, ctx->max_recv_frag);

	return rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_auth3(rpcconn_rpc_auth_3_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_fault(wStream* s, rpcconn_fault_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_fault_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT32(s, ctx->alloc_hint);
	Stream_Read_UINT16(s, ctx->p_cont_id);
	Stream_Read_UINT8(s, ctx->cancel_count);
	Stream_Read_UINT8(s, ctx->reserved);
	Stream_Read_UINT32(s, ctx->status);

	return rts_read_auth_verifier_with_stub(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_fault(rpcconn_fault_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_cancel_ack(wStream* s, rpcconn_cancel_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_cancel_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	return rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_cancel_ack(rpcconn_cancel_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_orphaned(wStream* s, rpcconn_orphaned_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_orphaned_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	return rts_read_auth_verifier(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_orphaned(rpcconn_orphaned_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_request(wStream* s, rpcconn_request_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_request_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT32(s, ctx->alloc_hint);
	Stream_Read_UINT16(s, ctx->p_cont_id);
	Stream_Read_UINT16(s, ctx->opnum);
	if (!rts_read_uuid(s, &ctx->object))
		return FALSE;

	return rts_read_auth_verifier_with_stub(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_request(rpcconn_request_hdr_t* ctx)
{
	if (!ctx)
		return;
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_response(wStream* s, rpcconn_response_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) <
	    sizeof(rpcconn_response_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;
	Stream_Read_UINT32(s, ctx->alloc_hint);
	Stream_Read_UINT16(s, ctx->p_cont_id);
	Stream_Read_UINT8(s, ctx->cancel_count);
	Stream_Read_UINT8(s, ctx->reserved);

	if (!rts_align_stream(s, 8))
		return FALSE;

	return rts_read_auth_verifier_with_stub(s, &ctx->auth_verifier, &ctx->header);
}

static void rts_free_pdu_response(rpcconn_response_hdr_t* ctx)
{
	if (!ctx)
		return;
	free(ctx->stub_data);
	rts_free_auth_verifier(&ctx->auth_verifier);
}

static BOOL rts_read_pdu_rts(wStream* s, rpcconn_rts_hdr_t* ctx)
{
	assert(s);
	assert(ctx);

	if (Stream_GetRemainingLength(s) < sizeof(rpcconn_rts_hdr_t) - sizeof(rpcconn_common_hdr_t))
		return FALSE;

	Stream_Read_UINT16(s, ctx->Flags);
	Stream_Read_UINT16(s, ctx->NumberOfCommands);
	return TRUE;
}

static void rts_free_pdu_rts(rpcconn_rts_hdr_t* ctx)
{
	WINPR_UNUSED(ctx);
}

void rts_free_pdu_header(rpcconn_hdr_t* header, BOOL allocated)
{
	if (!header)
		return;

	switch (header->common.ptype)
	{
		case PTYPE_ALTER_CONTEXT:
			rts_free_pdu_alter_context(&header->alter_context);
			break;
		case PTYPE_ALTER_CONTEXT_RESP:
			rts_free_pdu_alter_context_response(&header->alter_context_response);
			break;
		case PTYPE_BIND:
			rts_free_pdu_bind(&header->bind);
			break;
		case PTYPE_BIND_ACK:
			rts_free_pdu_bind_ack(&header->bind_ack);
			break;
		case PTYPE_BIND_NAK:
			rts_free_pdu_bind_nak(&header->bind_nak);
			break;
		case PTYPE_RPC_AUTH_3:
			rts_free_pdu_auth3(&header->rpc_auth_3);
			break;
		case PTYPE_CANCEL_ACK:
			rts_free_pdu_cancel_ack(&header->cancel);
			break;
		case PTYPE_FAULT:
			rts_free_pdu_fault(&header->fault);
			break;
		case PTYPE_ORPHANED:
			rts_free_pdu_orphaned(&header->orphaned);
			break;
		case PTYPE_REQUEST:
			rts_free_pdu_request(&header->request);
			break;
		case PTYPE_RESPONSE:
			rts_free_pdu_response(&header->response);
			break;
		case PTYPE_RTS:
			rts_free_pdu_rts(&header->rts);
			break;
			/* No extra fields */
		case PTYPE_SHUTDOWN:
			break;

		/* not handled */
		case PTYPE_PING:
		case PTYPE_WORKING:
		case PTYPE_NOCALL:
		case PTYPE_REJECT:
		case PTYPE_ACK:
		case PTYPE_CL_CANCEL:
		case PTYPE_FACK:
		case PTYPE_CO_CANCEL:
		default:
			break;
	}

	if (allocated)
		free(header);
}

BOOL rts_read_pdu_header(wStream* s, rpcconn_hdr_t* header)
{
	BOOL rc = FALSE;
	assert(s);
	assert(header);

	if (!rts_read_common_pdu_header(s, &header->common))
		return FALSE;

	WLog_DBG(TAG, ""Reading PDU type %s"", rts_pdu_ptype_to_string(header->common.ptype));
	fflush(stdout);
	switch (header->common.ptype)
	{
		case PTYPE_ALTER_CONTEXT:
			rc = rts_read_pdu_alter_context(s, &header->alter_context);
			break;
		case PTYPE_ALTER_CONTEXT_RESP:
			rc = rts_read_pdu_alter_context_response(s, &header->alter_context_response);
			break;
		case PTYPE_BIND:
			rc = rts_read_pdu_bind(s, &header->bind);
			break;
		case PTYPE_BIND_ACK:
			rc = rts_read_pdu_bind_ack(s, &header->bind_ack);
			break;
		case PTYPE_BIND_NAK:
			rc = rts_read_pdu_bind_nak(s, &header->bind_nak);
			break;
		case PTYPE_RPC_AUTH_3:
			rc = rts_read_pdu_auth3(s, &header->rpc_auth_3);
			break;
		case PTYPE_CANCEL_ACK:
			rc = rts_read_pdu_cancel_ack(s, &header->cancel);
			break;
		case PTYPE_FAULT:
			rc = rts_read_pdu_fault(s, &header->fault);
			break;
		case PTYPE_ORPHANED:
			rc = rts_read_pdu_orphaned(s, &header->orphaned);
			break;
		case PTYPE_REQUEST:
			rc = rts_read_pdu_request(s, &header->request);
			break;
		case PTYPE_RESPONSE:
			rc = rts_read_pdu_response(s, &header->response);
			break;
		case PTYPE_RTS:
			rc = rts_read_pdu_rts(s, &header->rts);
			break;
		case PTYPE_SHUTDOWN:
			rc = TRUE; /* No extra fields */
			break;

		/* not handled */
		case PTYPE_PING:
		case PTYPE_WORKING:
		case PTYPE_NOCALL:
		case PTYPE_REJECT:
		case PTYPE_ACK:
		case PTYPE_CL_CANCEL:
		case PTYPE_FACK:
		case PTYPE_CO_CANCEL:
		default:
			break;
	}

	return rc;
}

static BOOL rts_write_pdu_header(wStream* s, const rpcconn_rts_hdr_t* header)
{
	assert(s);
	assert(header);
	if (!Stream_EnsureRemainingCapacity(s, sizeof(rpcconn_rts_hdr_t)))
		return FALSE;
	if (!rts_write_common_pdu_header(s, &header->header))
		return FALSE;

	Stream_Write_UINT16(s, header->Flags);
	Stream_Write_UINT16(s, header->NumberOfCommands);
	return TRUE;
static int rts_receive_window_size_command_read(rdpRpc* rpc, wStream* buffer,
	UINT32 val;

	assert(rpc);
	assert(buffer);

	if (Stream_GetRemainingLength(buffer) < 4)
		return -1;
	Stream_Read_UINT32(buffer, val);
		*ReceiveWindowSize = val; /* ReceiveWindowSize (4 bytes) */
static BOOL rts_receive_window_size_command_write(wStream* s, UINT32 ReceiveWindowSize)
	assert(s);

	if (!Stream_EnsureRemainingCapacity(s, 2 * sizeof(UINT32)))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_RECEIVE_WINDOW_SIZE); /* CommandType (4 bytes) */
	Stream_Write_UINT32(s, ReceiveWindowSize);           /* ReceiveWindowSize (4 bytes) */

	return TRUE;
static int rts_flow_control_ack_command_read(rdpRpc* rpc, wStream* buffer, UINT32* BytesReceived,
                                             UINT32* AvailableWindow, BYTE* ChannelCookie)
	UINT32 val;
	assert(rpc);
	assert(buffer);

	if (Stream_GetRemainingLength(buffer) < 24)
		return -1;

	Stream_Read_UINT32(buffer, val);
		*BytesReceived = val; /* BytesReceived (4 bytes) */
	Stream_Read_UINT32(buffer, val);
		*AvailableWindow = val; /* AvailableWindow (4 bytes) */
		Stream_Read(buffer, ChannelCookie, 16); /* ChannelCookie (16 bytes) */
	else
		Stream_Seek(buffer, 16);
static BOOL rts_flow_control_ack_command_write(wStream* s, UINT32 BytesReceived,
                                               UINT32 AvailableWindow, BYTE* ChannelCookie)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 28))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_FLOW_CONTROL_ACK); /* CommandType (4 bytes) */
	Stream_Write_UINT32(s, BytesReceived);            /* BytesReceived (4 bytes) */
	Stream_Write_UINT32(s, AvailableWindow);          /* AvailableWindow (4 bytes) */
	Stream_Write(s, ChannelCookie, 16);               /* ChannelCookie (16 bytes) */
	return TRUE;
static BOOL rts_connection_timeout_command_read(rdpRpc* rpc, wStream* buffer,
                                                UINT32* ConnectionTimeout)
	UINT32 val;
	assert(rpc);
	assert(buffer);
	if (Stream_GetRemainingLength(buffer) < 4)
		return FALSE;
	Stream_Read_UINT32(buffer, val);
	if (ConnectionTimeout)
		*ConnectionTimeout = val; /* ConnectionTimeout (4 bytes) */

	return TRUE;
static BOOL rts_cookie_command_write(wStream* s, const BYTE* Cookie)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 20))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_COOKIE); /* CommandType (4 bytes) */
	Stream_Write(s, Cookie, 16);            /* Cookie (16 bytes) */

	return TRUE;
static BOOL rts_channel_lifetime_command_write(wStream* s, UINT32 ChannelLifetime)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 8))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_CHANNEL_LIFETIME); /* CommandType (4 bytes) */
	Stream_Write_UINT32(s, ChannelLifetime);          /* ChannelLifetime (4 bytes) */
	return TRUE;
static BOOL rts_client_keepalive_command_write(wStream* s, UINT32 ClientKeepalive)
	assert(s);

	if (!Stream_EnsureRemainingCapacity(s, 8))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_CLIENT_KEEPALIVE); /* CommandType (4 bytes) */
	Stream_Write_UINT32(s, ClientKeepalive);          /* ClientKeepalive (4 bytes) */
	return TRUE;
static BOOL rts_version_command_read(rdpRpc* rpc, wStream* buffer)
	assert(rpc);
	assert(buffer);
	if (!Stream_SafeSeek(buffer, 4))
		return FALSE;
	/* Version (4 bytes) */
	return TRUE;
static BOOL rts_version_command_write(wStream* buffer)
	assert(buffer);
	if (Stream_GetRemainingCapacity(buffer) < 8)
		return FALSE;
	Stream_Write_UINT32(buffer, RTS_CMD_VERSION); /* CommandType (4 bytes) */
	Stream_Write_UINT32(buffer, 1);               /* Version (4 bytes) */
	return TRUE;
static BOOL rts_empty_command_write(wStream* s)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 8))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_EMPTY); /* CommandType (4 bytes) */
	return TRUE;
static BOOL rts_padding_command_read(wStream* s, size_t* length)
	UINT32 ConformanceCount;
	assert(s);
	assert(length);
	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;
	Stream_Read_UINT32(s, ConformanceCount); /* ConformanceCount (4 bytes) */
	*length = ConformanceCount + 4;
	return TRUE;
static BOOL rts_client_address_command_read(wStream* s, size_t* length)

	assert(s);
	assert(length);

	if (Stream_GetRemainingLength(s) < 4)
		return FALSE;
	Stream_Read_UINT32(s, AddressType); /* AddressType (4 bytes) */
		*length = 4 + 4 + 12;
		*length = 4 + 16 + 12;
	return TRUE;
static BOOL rts_association_group_id_command_write(wStream* s, const BYTE* AssociationGroupId)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 20))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_ASSOCIATION_GROUP_ID); /* CommandType (4 bytes) */
	Stream_Write(s, AssociationGroupId, 16);              /* AssociationGroupId (16 bytes) */
	return TRUE;
static int rts_destination_command_read(rdpRpc* rpc, wStream* buffer, UINT32* Destination)
	UINT32 val;
	assert(rpc);
	assert(buffer);
	if (Stream_GetRemainingLength(buffer) < 4)
		return -1;
	Stream_Read_UINT32(buffer, val);
		*Destination = val; /* Destination (4 bytes) */
static BOOL rts_destination_command_write(wStream* s, UINT32 Destination)
	assert(s);
	if (!Stream_EnsureRemainingCapacity(s, 8))
		return FALSE;
	Stream_Write_UINT32(s, RTS_CMD_DESTINATION); /* CommandType (4 bytes) */
	Stream_Write_UINT32(s, Destination);         /* Destination (4 bytes) */
	return TRUE;
	assert(cookie);
static BOOL rts_send_buffer(RpcChannel* channel, wStream* s, size_t frag_length)
{
	BOOL status = FALSE;
	SSIZE_T rc;

	assert(channel);
	assert(s);

	Stream_SealLength(s);
	if (Stream_Length(s) < sizeof(rpcconn_common_hdr_t))
		goto fail;
	if (Stream_Length(s) != frag_length)
		goto fail;

	rc = rpc_channel_write(channel, Stream_Buffer(s), Stream_Length(s));
	if (rc < 0)
		goto fail;
	if ((size_t)rc != Stream_Length(s))
		goto fail;
	status = TRUE;
fail:
	return status;
}

BOOL rts_send_CONN_A1_pdu(rdpRpc* rpc)
	BOOL status = FALSE;
	wStream* buffer;
	RpcVirtualConnection* connection;
	RpcOutChannel* outChannel;

	assert(rpc);

	connection = rpc->VirtualConnection;
	assert(connection);

	outChannel = connection->DefaultOutChannel;
	assert(outChannel);


	buffer = Stream_New(NULL, header.header.frag_length);
	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	status = rts_version_command_write(buffer); /* Version (8 bytes) */
	if (!status)
		goto fail;
	status = rts_cookie_command_write(
	    buffer, VirtualConnectionCookie); /* VirtualConnectionCookie (20 bytes) */
	if (!status)
		goto fail;
	status = rts_cookie_command_write(buffer, OUTChannelCookie); /* OUTChannelCookie (20 bytes) */
	if (!status)
		goto fail;
	status = rts_receive_window_size_command_write(
	    buffer, ReceiveWindowSize); /* ReceiveWindowSize (8 bytes) */
	if (!status)
		goto fail;
	status = rts_send_buffer(&outChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return status;
BOOL rts_recv_CONN_A3_pdu(rdpRpc* rpc, wStream* buffer)
	BOOL rc;

	if (!Stream_SafeSeek(buffer, 24))
		return FALSE;

	rc = rts_connection_timeout_command_read(rpc, buffer, &ConnectionTimeout);
	if (!rc)
		return rc;


	assert(rpc);
	assert(rpc->VirtualConnection);
	assert(rpc->VirtualConnection->DefaultInChannel);

	return TRUE;
BOOL rts_send_CONN_B1_pdu(rdpRpc* rpc)
	BOOL status = FALSE;
	wStream* buffer;
	RpcVirtualConnection* connection;
	RpcInChannel* inChannel;

	assert(rpc);

	connection = rpc->VirtualConnection;
	assert(connection);

	inChannel = connection->DefaultInChannel;
	assert(inChannel);


	buffer = Stream_New(NULL, header.header.frag_length);
		goto fail;
	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	if (!rts_version_command_write(buffer)) /* Version (8 bytes) */
		goto fail;
	if (!rts_cookie_command_write(buffer,
	                              VirtualConnectionCookie)) /* VirtualConnectionCookie (20 bytes) */
		goto fail;
	if (!rts_cookie_command_write(buffer, INChannelCookie)) /* INChannelCookie (20 bytes) */
		goto fail;
	if (!rts_channel_lifetime_command_write(buffer,
	                                        rpc->ChannelLifetime)) /* ChannelLifetime (8 bytes) */
		goto fail;
	if (!rts_client_keepalive_command_write(buffer,
	                                        rpc->KeepAliveInterval)) /* ClientKeepalive (8 bytes) */
		goto fail;
	if (!rts_association_group_id_command_write(
	        buffer, AssociationGroupId)) /* AssociationGroupId (20 bytes) */
		goto fail;
	status = rts_send_buffer(&inChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return status;
BOOL rts_recv_CONN_C2_pdu(rdpRpc* rpc, wStream* buffer)
	BOOL rc;

	assert(rpc);
	assert(buffer);

	if (!Stream_SafeSeek(buffer, 24))
		return FALSE;

	rc = rts_version_command_read(rpc, buffer);
	if (rc < 0)
		return rc;
	rc = rts_receive_window_size_command_read(rpc, buffer, &ReceiveWindowSize);
	if (rc < 0)
		return rc;
	rc = rts_connection_timeout_command_read(rpc, buffer, &ConnectionTimeout);
	if (rc < 0)
		return rc;

	assert(rpc);
	assert(rpc->VirtualConnection);
	assert(rpc->VirtualConnection->DefaultInChannel);

	return TRUE;
BOOL rts_send_flow_control_ack_pdu(rdpRpc* rpc)
	BOOL status = FALSE;
	wStream* buffer;
	UINT32 BytesReceived;
	UINT32 AvailableWindow;
	BYTE* ChannelCookie;
	RpcVirtualConnection* connection;
	RpcInChannel* inChannel;
	RpcOutChannel* outChannel;
	assert(rpc);
	connection = rpc->VirtualConnection;
	assert(connection);
	inChannel = connection->DefaultInChannel;
	assert(inChannel);
	outChannel = connection->DefaultOutChannel;
	assert(outChannel);


	buffer = Stream_New(NULL, header.header.frag_length);
		goto fail;

	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	if (!rts_destination_command_write(buffer, FDOutProxy)) /* Destination Command (8 bytes) */
		goto fail;
	if (!rts_flow_control_ack_command_write(buffer, BytesReceived, AvailableWindow, ChannelCookie))
		goto fail;

	status = rts_send_buffer(&inChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return status;
static int rts_recv_flow_control_ack_pdu(rdpRpc* rpc, wStream* buffer)
	int rc;
	BYTE ChannelCookie[16] = { 0 };

	rc = rts_flow_control_ack_command_read(rpc, buffer, &BytesReceived, &AvailableWindow,
	                                       (BYTE*)&ChannelCookie);
	if (rc < 0)
		return rc;

	assert(rpc->VirtualConnection);
	assert(rpc->VirtualConnection->DefaultInChannel);

static int rts_recv_flow_control_ack_with_destination_pdu(rdpRpc* rpc, wStream* buffer)
	int rc;
	BYTE ChannelCookie[16] = { 0 };

	rc = rts_destination_command_read(rpc, buffer, &Destination);
	if (rc < 0)
		return rc;

	rc = rts_flow_control_ack_command_read(rpc, buffer, &BytesReceived, &AvailableWindow,
	                                       ChannelCookie);
	if (rc < 0)
		return rc;


	assert(rpc->VirtualConnection);
	assert(rpc->VirtualConnection->DefaultInChannel);
	BOOL status = FALSE;
	wStream* buffer;
	RpcInChannel* inChannel;

	assert(rpc);
	assert(rpc->VirtualConnection);

	inChannel = rpc->VirtualConnection->DefaultInChannel;
	assert(inChannel);

	buffer = Stream_New(NULL, header.header.frag_length);
		goto fail;

	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	status = rts_send_buffer(&inChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return (status) ? 1 : -1;
BOOL rts_command_length(UINT32 CommandType, wStream* s, size_t* length)
	size_t padding = 0;
	size_t CommandLength = 0;

	assert(s);
			if (!rts_padding_command_read(s, &padding))
				return FALSE;
			if (!rts_client_address_command_read(s, &CommandLength))
				return FALSE;
			return FALSE;
	CommandLength += padding;
	if (Stream_GetRemainingLength(s) < CommandLength)
		return FALSE;

	if (length)
		*length = CommandLength;
	return TRUE;
	BOOL status = FALSE;
	wStream* buffer;
	RpcInChannel* inChannel;
	RpcOutChannel* nextOutChannel;

	assert(rpc);
	assert(rpc->VirtualConnection);

	inChannel = rpc->VirtualConnection->DefaultInChannel;
	assert(inChannel);

	nextOutChannel = rpc->VirtualConnection->NonDefaultOutChannel;
	assert(nextOutChannel);


	buffer = Stream_New(NULL, header.header.frag_length);
	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	if (!rts_destination_command_write(buffer, FDServer)) /* Destination (8 bytes)*/
		goto fail;
	if (!rts_cookie_command_write(buffer,
	                              SuccessorChannelCookie)) /* SuccessorChannelCookie (20 bytes) */
		goto fail;
	if (!rts_version_command_write(buffer)) /* Version (8 bytes) */
		goto fail;
	status = rts_send_buffer(&inChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return (status) ? 1 : -1;
	BOOL status = FALSE;
	wStream* buffer;
	RpcOutChannel* nextOutChannel;

	assert(rpc);
	assert(rpc->VirtualConnection);

	nextOutChannel = rpc->VirtualConnection->NonDefaultOutChannel;
	assert(nextOutChannel);

	buffer = Stream_New(NULL, header.header.frag_length);
	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;

	if (!rts_empty_command_write(buffer)) /* Empty command (4 bytes) */
		goto fail;
	status = rts_send_buffer(&nextOutChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return (status) ? 1 : -1;
BOOL rts_send_OUT_R1_A3_pdu(rdpRpc* rpc)
	BOOL status = FALSE;
	wStream* buffer;
	RpcVirtualConnection* connection;
	RpcOutChannel* outChannel;
	RpcOutChannel* nextOutChannel;

	assert(rpc);

	connection = rpc->VirtualConnection;
	assert(connection);

	outChannel = connection->DefaultOutChannel;
	assert(outChannel);

	nextOutChannel = connection->NonDefaultOutChannel;
	assert(nextOutChannel);


	buffer = Stream_New(NULL, header.header.frag_length);
	if (!rts_write_pdu_header(buffer, &header)) /* RTS Header (20 bytes) */
		goto fail;
	if (!rts_version_command_write(buffer)) /* Version (8 bytes) */
		goto fail;
	if (!rts_cookie_command_write(buffer,
	                              VirtualConnectionCookie)) /* VirtualConnectionCookie (20 bytes) */
		goto fail;
	if (!rts_cookie_command_write(
	        buffer, PredecessorChannelCookie)) /* PredecessorChannelCookie (20 bytes) */
		goto fail;
	if (!rts_cookie_command_write(buffer,
	                              SuccessorChannelCookie)) /* SuccessorChannelCookie (20 bytes) */
		goto fail;
	if (!rts_receive_window_size_command_write(buffer,
	                                           ReceiveWindowSize)) /* ReceiveWindowSize (8 bytes) */
		goto fail;

	status = rts_send_buffer(&nextOutChannel->common, buffer, header.header.frag_length);
fail:
	Stream_Free(buffer, TRUE);
	return status;
static int rts_recv_OUT_R1_A2_pdu(rdpRpc* rpc, wStream* buffer)
	RpcVirtualConnection* connection;
	assert(rpc);
	assert(buffer);

	connection = rpc->VirtualConnection;
	assert(connection);

	status = rts_destination_command_read(rpc, buffer, &Destination);
	if (status < 0)
		return status;
static int rts_recv_OUT_R2_A6_pdu(rdpRpc* rpc, wStream* buffer)
	RpcVirtualConnection* connection;

	assert(rpc);
	assert(buffer);

	connection = rpc->VirtualConnection;
	assert(connection);

static int rts_recv_OUT_R2_B3_pdu(rdpRpc* rpc, wStream* buffer)
	RpcVirtualConnection* connection;

	assert(rpc);
	assert(buffer);

	connection = rpc->VirtualConnection;
	assert(connection);

BOOL rts_recv_out_of_sequence_pdu(rdpRpc* rpc, wStream* buffer, const rpcconn_hdr_t* header)
	BOOL status = FALSE;
	size_t length, total;
	RtsPduSignature signature = { 0 };
	assert(rpc);
	assert(buffer);
	assert(header);

	total = Stream_Length(buffer);
	length = header->common.frag_length;
	if (total < length)
		return FALSE;
		return FALSE;
	if (!rts_extract_pdu_signature(&signature, buffer, header))
		return FALSE;
	if (rts_match_pdu_signature(&RTS_PDU_FLOW_CONTROL_ACK_SIGNATURE, buffer, header))
		status = rts_recv_flow_control_ack_pdu(rpc, buffer);
	else if (rts_match_pdu_signature(&RTS_PDU_FLOW_CONTROL_ACK_WITH_DESTINATION_SIGNATURE, buffer,
	                                 header))
		status = rts_recv_flow_control_ack_with_destination_pdu(rpc, buffer);
	else if (rts_match_pdu_signature(&RTS_PDU_PING_SIGNATURE, buffer, header))
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R1_A2_SIGNATURE, buffer, header))
				status = rts_recv_OUT_R1_A2_pdu(rpc, buffer);
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R2_A6_SIGNATURE, buffer, header))
				status = rts_recv_OUT_R2_A6_pdu(rpc, buffer);
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R2_B3_SIGNATURE, buffer, header))
				status = rts_recv_OUT_R2_B3_pdu(rpc, buffer);
	if (!status)

BOOL rts_write_pdu_auth3(wStream* s, const rpcconn_rpc_auth_3_hdr_t* auth)
{
	assert(s);
	assert(auth);

	if (!rts_write_common_pdu_header(s, &auth->header))
		return FALSE;

	if (!Stream_EnsureRemainingCapacity(s, 2 * sizeof(UINT16)))
		return FALSE;

	Stream_Write_UINT16(s, auth->max_xmit_frag);
	Stream_Write_UINT16(s, auth->max_recv_frag);

	return rts_write_auth_verifier(s, &auth->auth_verifier, &auth->header);
}

BOOL rts_write_pdu_bind(wStream* s, const rpcconn_bind_hdr_t* bind)
{

	assert(s);
	assert(bind);

	if (!rts_write_common_pdu_header(s, &bind->header))
		return FALSE;

	if (!Stream_EnsureRemainingCapacity(s, 8))
		return FALSE;

	Stream_Write_UINT16(s, bind->max_xmit_frag);
	Stream_Write_UINT16(s, bind->max_recv_frag);
	Stream_Write_UINT32(s, bind->assoc_group_id);

	if (!rts_write_context_list(s, &bind->p_context_elem))
		return FALSE;

	return rts_write_auth_verifier(s, &bind->auth_verifier, &bind->header);
}","	rpcconn_rts_hdr_t header = { 0 };
	header.header.rpc_vers = 5;
	header.header.rpc_vers_minor = 0;
	header.header.ptype = PTYPE_RTS;
	header.header.packed_drep[0] = 0x10;
	header.header.packed_drep[1] = 0x00;
	header.header.packed_drep[2] = 0x00;
	header.header.packed_drep[3] = 0x00;
	header.header.pfc_flags = PFC_FIRST_FRAG | PFC_LAST_FRAG;
	header.header.auth_length = 0;
	header.header.call_id = 0;
	return header;
static int rts_receive_window_size_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length,
		*ReceiveWindowSize = *((UINT32*)&buffer[0]); /* ReceiveWindowSize (4 bytes) */
static int rts_receive_window_size_command_write(BYTE* buffer, UINT32 ReceiveWindowSize)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_RECEIVE_WINDOW_SIZE; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = ReceiveWindowSize;           /* ReceiveWindowSize (4 bytes) */
	}
	return 8;
static int rts_flow_control_ack_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length,
                                             UINT32* BytesReceived, UINT32* AvailableWindow,
                                             BYTE* ChannelCookie)
		*BytesReceived = *((UINT32*)&buffer[0]); /* BytesReceived (4 bytes) */
		*AvailableWindow = *((UINT32*)&buffer[4]); /* AvailableWindow (4 bytes) */
		CopyMemory(ChannelCookie, &buffer[8], 16); /* ChannelCookie (16 bytes) */

static int rts_flow_control_ack_command_write(BYTE* buffer, UINT32 BytesReceived,
                                              UINT32 AvailableWindow, BYTE* ChannelCookie)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_FLOW_CONTROL_ACK; /* CommandType (4 bytes) */
		/* Ack (24 bytes) */
		*((UINT32*)&buffer[4]) = BytesReceived;     /* BytesReceived (4 bytes) */
		*((UINT32*)&buffer[8]) = AvailableWindow;   /* AvailableWindow (4 bytes) */
		CopyMemory(&buffer[12], ChannelCookie, 16); /* ChannelCookie (16 bytes) */
	}
	return 28;
}
static int rts_connection_timeout_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length,
                                               UINT32* ConnectionTimeout)
{
	if (ConnectionTimeout)
		*ConnectionTimeout = *((UINT32*)&buffer[0]); /* ConnectionTimeout (4 bytes) */
	return 4;
static int rts_connection_timeout_command_write(BYTE* buffer, UINT32 ConnectionTimeout)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_CONNECTION_TIMEOUT; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = ConnectionTimeout;          /* ConnectionTimeout (4 bytes) */
	}
	return 8;
}
static int rts_cookie_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* Cookie (16 bytes) */
	return 16;
static int rts_cookie_command_write(BYTE* buffer, BYTE* Cookie)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_COOKIE; /* CommandType (4 bytes) */
		CopyMemory(&buffer[4], Cookie, 16);      /* Cookie (16 bytes) */
	}
	return 20;
}
static int rts_channel_lifetime_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* ChannelLifetime (4 bytes) */
	return 4;
static int rts_channel_lifetime_command_write(BYTE* buffer, UINT32 ChannelLifetime)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_CHANNEL_LIFETIME; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = ChannelLifetime;          /* ChannelLifetime (4 bytes) */
	}
	return 8;
}
static int rts_client_keepalive_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* ClientKeepalive (4 bytes) */
	return 4;
static int rts_client_keepalive_command_write(BYTE* buffer, UINT32 ClientKeepalive)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_CLIENT_KEEPALIVE; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = ClientKeepalive;          /* ClientKeepalive (4 bytes) */
	}
	return 8;
}
static int rts_version_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* Version (4 bytes) */
	return 4;
static int rts_version_command_write(BYTE* buffer)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_VERSION; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = 1;               /* Version (4 bytes) */
	}
	return 8;
}
static int rts_empty_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	return 0;
static int rts_empty_command_write(BYTE* buffer)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_EMPTY; /* CommandType (4 bytes) */
	}

	return 4;
}
static SSIZE_T rts_padding_command_read(const BYTE* buffer, size_t length)
{
	UINT32 ConformanceCount;
	ConformanceCount = *((UINT32*)&buffer[0]); /* ConformanceCount (4 bytes) */
	/* Padding (variable) */
	return ConformanceCount + 4;
}
static int rts_padding_command_write(BYTE* buffer, UINT32 ConformanceCount)
{
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_PADDING;  /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = ConformanceCount; /* ConformanceCount (4 bytes) */
		ZeroMemory(&buffer[8], ConformanceCount);  /* Padding (variable) */
	}
	return 8 + ConformanceCount;
static int rts_negative_ance_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	return 0;
}
static int rts_negative_ance_command_write(BYTE* buffer)
{
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_NEGATIVE_ANCE; /* CommandType (4 bytes) */
	}
	return 4;
}
static int rts_ance_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	return 0;
static int rts_ance_command_write(BYTE* buffer)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_ANCE; /* CommandType (4 bytes) */
	}

	return 4;
static SSIZE_T rts_client_address_command_read(const BYTE* buffer, size_t length)
	AddressType = *((UINT32*)&buffer[0]); /* AddressType (4 bytes) */
		return 4 + 4 + 12;
		return 4 + 16 + 12;
static int rts_client_address_command_write(BYTE* buffer, UINT32 AddressType, BYTE* ClientAddress)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_CLIENT_ADDRESS; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = AddressType;            /* AddressType (4 bytes) */
	}
	if (AddressType == 0)
	{
		if (buffer)
		{
			CopyMemory(&buffer[8], ClientAddress, 4); /* ClientAddress (4 bytes) */
			ZeroMemory(&buffer[12], 12);              /* padding (12 bytes) */
		}

		return 24;
	}
	else
	{
		if (buffer)
		{
			CopyMemory(&buffer[8], ClientAddress, 16); /* ClientAddress (16 bytes) */
			ZeroMemory(&buffer[24], 12);               /* padding (12 bytes) */
		}
		return 36;
	}
}
static int rts_association_group_id_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* AssociationGroupId (16 bytes) */
	return 16;
static int rts_association_group_id_command_write(BYTE* buffer, BYTE* AssociationGroupId)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_ASSOCIATION_GROUP_ID; /* CommandType (4 bytes) */
		CopyMemory(&buffer[4], AssociationGroupId, 16);        /* AssociationGroupId (16 bytes) */
	}

	return 20;
}
static int rts_destination_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length,
                                        UINT32* Destination)
{
		*Destination = *((UINT32*)&buffer[0]); /* Destination (4 bytes) */
static int rts_destination_command_write(BYTE* buffer, UINT32 Destination)
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_DESTINATION; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = Destination;         /* Destination (4 bytes) */
	}

	return 8;
}
static int rts_ping_traffic_sent_notify_command_read(rdpRpc* rpc, BYTE* buffer, UINT32 length)
{
	/* PingTrafficSent (4 bytes) */
	return 4;
}
static int rts_ping_traffic_sent_notify_command_write(BYTE* buffer, UINT32 PingTrafficSent)
{
	if (buffer)
	{
		*((UINT32*)&buffer[0]) = RTS_CMD_PING_TRAFFIC_SENT_NOTIFY; /* CommandType (4 bytes) */
		*((UINT32*)&buffer[4]) = PingTrafficSent;                  /* PingTrafficSent (4 bytes) */
	}
	return 8;
int rts_send_CONN_A1_pdu(rdpRpc* rpc)
	int status;
	BYTE* buffer;
	RpcVirtualConnection* connection = rpc->VirtualConnection;
	RpcOutChannel* outChannel = connection->DefaultOutChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	rts_version_command_write(&buffer[20]);   /* Version (8 bytes) */
	rts_cookie_command_write(&buffer[28],
	                         VirtualConnectionCookie); /* VirtualConnectionCookie (20 bytes) */
	rts_cookie_command_write(&buffer[48], OUTChannelCookie); /* OUTChannelCookie (20 bytes) */
	rts_receive_window_size_command_write(&buffer[68],
	                                      ReceiveWindowSize); /* ReceiveWindowSize (8 bytes) */
	status = rpc_channel_write(&outChannel->common, buffer, header.header.frag_length);
	free(buffer);
	return (status > 0) ? 1 : -1;
int rts_recv_CONN_A3_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	rts_connection_timeout_command_read(rpc, &buffer[24], length - 24, &ConnectionTimeout);
	return 1;
int rts_send_CONN_B1_pdu(rdpRpc* rpc)
	int status;
	BYTE* buffer;
	UINT32 length;
	RpcVirtualConnection* connection = rpc->VirtualConnection;
	RpcInChannel* inChannel = connection->DefaultInChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
		return -1;

	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	rts_version_command_write(&buffer[20]);   /* Version (8 bytes) */
	rts_cookie_command_write(&buffer[28],
	                         VirtualConnectionCookie);      /* VirtualConnectionCookie (20 bytes) */
	rts_cookie_command_write(&buffer[48], INChannelCookie); /* INChannelCookie (20 bytes) */
	rts_channel_lifetime_command_write(&buffer[68],
	                                   rpc->ChannelLifetime); /* ChannelLifetime (8 bytes) */
	rts_client_keepalive_command_write(&buffer[76],
	                                   rpc->KeepAliveInterval); /* ClientKeepalive (8 bytes) */
	rts_association_group_id_command_write(&buffer[84],
	                                       AssociationGroupId); /* AssociationGroupId (20 bytes) */
	length = header.header.frag_length;
	status = rpc_channel_write(&inChannel->common, buffer, length);
	free(buffer);
	return (status > 0) ? 1 : -1;
int rts_recv_CONN_C2_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	UINT32 offset;
	offset = 24;
	offset += rts_version_command_read(rpc, &buffer[offset], length - offset) + 4;
	offset += rts_receive_window_size_command_read(rpc, &buffer[offset], length - offset,
	                                               &ReceiveWindowSize) +
	          4;
	offset += rts_connection_timeout_command_read(rpc, &buffer[offset], length - offset,
	                                              &ConnectionTimeout) +
	          4;
	return 1;
static int rts_send_keep_alive_pdu(rdpRpc* rpc)
	int status;
	BYTE* buffer;
	UINT32 length;
	RpcInChannel* inChannel = rpc->VirtualConnection->DefaultInChannel;
	header.header.frag_length = 28;
	header.Flags = RTS_FLAG_OTHER_CMD;
	header.NumberOfCommands = 1;
	WLog_DBG(TAG, ""Sending Keep-Alive RTS PDU"");
	buffer = (BYTE*)malloc(header.header.frag_length);
	if (!buffer)
		return -1;
	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	rts_client_keepalive_command_write(
	    &buffer[20], rpc->CurrentKeepAliveInterval); /* ClientKeepAlive (8 bytes) */
	length = header.header.frag_length;
	status = rpc_channel_write(&inChannel->common, buffer, length);
	free(buffer);
	return (status > 0) ? 1 : -1;
}
int rts_send_flow_control_ack_pdu(rdpRpc* rpc)
{
	int status;
	BYTE* buffer;
	UINT32 length;
	rpcconn_rts_hdr_t header = rts_pdu_header_init();
	UINT32 BytesReceived;
	UINT32 AvailableWindow;
	BYTE* ChannelCookie;
	RpcVirtualConnection* connection = rpc->VirtualConnection;
	RpcInChannel* inChannel = connection->DefaultInChannel;
	RpcOutChannel* outChannel = connection->DefaultOutChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
		return -1;
	CopyMemory(buffer, ((BYTE*)&header), 20);               /* RTS Header (20 bytes) */
	rts_destination_command_write(&buffer[20], FDOutProxy); /* Destination Command (8 bytes) */
	rts_flow_control_ack_command_write(&buffer[28], BytesReceived, AvailableWindow, ChannelCookie);
	length = header.header.frag_length;
	status = rpc_channel_write(&inChannel->common, buffer, length);
	free(buffer);
	return (status > 0) ? 1 : -1;
static int rts_recv_flow_control_ack_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	UINT32 offset;
	BYTE ChannelCookie[16];
	offset = 24;
	offset +=
	    rts_flow_control_ack_command_read(rpc, &buffer[offset], length - offset, &BytesReceived,
	                                      &AvailableWindow, (BYTE*)&ChannelCookie) +
	    4;
static int rts_recv_flow_control_ack_with_destination_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	UINT32 offset;
	BYTE ChannelCookie[16];
	offset = 24;
	offset += rts_destination_command_read(rpc, &buffer[offset], length - offset, &Destination) + 4;
	offset +=
	    rts_flow_control_ack_command_read(rpc, &buffer[offset], length - offset, &BytesReceived,
	                                      &AvailableWindow, (BYTE*)&ChannelCookie) +
	    4;
	int status;
	BYTE* buffer;
	UINT32 length;
	RpcInChannel* inChannel = rpc->VirtualConnection->DefaultInChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
		return -1;

	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	length = header.header.frag_length;
	status = rpc_channel_write(&inChannel->common, buffer, length);
	free(buffer);
	return (status > 0) ? 1 : -1;
SSIZE_T rts_command_length(UINT32 CommandType, const BYTE* buffer, size_t length)
	int CommandLength = 0;
			CommandLength = rts_padding_command_read(buffer, length);
			CommandLength = rts_client_address_command_read(buffer, length);
			return -1;
	return CommandLength;
	int status;
	BYTE* buffer;
	RpcInChannel* inChannel = rpc->VirtualConnection->DefaultInChannel;
	RpcOutChannel* nextOutChannel = rpc->VirtualConnection->NonDefaultOutChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
	CopyMemory(buffer, ((BYTE*)&header), 20);             /* RTS Header (20 bytes) */
	rts_destination_command_write(&buffer[20], FDServer); /* Destination (8 bytes)*/
	rts_cookie_command_write(&buffer[28],
	                         SuccessorChannelCookie); /* SuccessorChannelCookie (20 bytes) */
	rts_version_command_write(&buffer[48]);           /* Version (8 bytes) */
	status = rpc_channel_write(&inChannel->common, buffer, header.header.frag_length);
	free(buffer);
	return (status > 0) ? 1 : -1;
	int status;
	BYTE* buffer;
	RpcOutChannel* nextOutChannel = rpc->VirtualConnection->NonDefaultOutChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	rts_empty_command_write(&buffer[20]);     /* Empty command (4 bytes) */
	status = rpc_channel_write(&nextOutChannel->common, buffer, header.header.frag_length);
	free(buffer);
	return (status > 0) ? 1 : -1;
int rts_send_OUT_R1_A3_pdu(rdpRpc* rpc)
	int status;
	BYTE* buffer;
	RpcVirtualConnection* connection = rpc->VirtualConnection;
	RpcOutChannel* outChannel = connection->DefaultOutChannel;
	RpcOutChannel* nextOutChannel = connection->NonDefaultOutChannel;
	buffer = (BYTE*)malloc(header.header.frag_length);
	CopyMemory(buffer, ((BYTE*)&header), 20); /* RTS Header (20 bytes) */
	rts_version_command_write(&buffer[20]);   /* Version (8 bytes) */
	rts_cookie_command_write(&buffer[28],
	                         VirtualConnectionCookie); /* VirtualConnectionCookie (20 bytes) */
	rts_cookie_command_write(&buffer[48],
	                         PredecessorChannelCookie); /* PredecessorChannelCookie (20 bytes) */
	rts_cookie_command_write(&buffer[68],
	                         SuccessorChannelCookie); /* SuccessorChannelCookie (20 bytes) */
	rts_receive_window_size_command_write(&buffer[88],
	                                      ReceiveWindowSize); /* ReceiveWindowSize (8 bytes) */
	status = rpc_channel_write(&nextOutChannel->common, buffer, header.header.frag_length);
	free(buffer);
	return (status > 0) ? 1 : -1;
static int rts_recv_OUT_R1_A2_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	UINT32 offset;
	RpcVirtualConnection* connection = rpc->VirtualConnection;
	offset = 24;
	if (length < offset)
		return -1;
	rts_destination_command_read(rpc, &buffer[offset], length - offset, &Destination);
static int rts_recv_OUT_R2_A6_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	RpcVirtualConnection* connection = rpc->VirtualConnection;
static int rts_recv_OUT_R2_B3_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	RpcVirtualConnection* connection = rpc->VirtualConnection;
int rts_recv_out_of_sequence_pdu(rdpRpc* rpc, BYTE* buffer, UINT32 length)
	int status = -1;
	rpcconn_rts_hdr_t* rts;
	RtsPduSignature signature;
	if (!rpc || !buffer)
		return -1;
		return -1;

	rts = (rpcconn_rts_hdr_t*)buffer;
	if (!rts_extract_pdu_signature(&signature, rts))
		return -1;
	if (rts_match_pdu_signature(&RTS_PDU_FLOW_CONTROL_ACK_SIGNATURE, rts))
		status = rts_recv_flow_control_ack_pdu(rpc, buffer, length);
	else if (rts_match_pdu_signature(&RTS_PDU_FLOW_CONTROL_ACK_WITH_DESTINATION_SIGNATURE, rts))
		status = rts_recv_flow_control_ack_with_destination_pdu(rpc, buffer, length);
	else if (rts_match_pdu_signature(&RTS_PDU_PING_SIGNATURE, rts))
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R1_A2_SIGNATURE, rts))
				status = rts_recv_OUT_R1_A2_pdu(rpc, buffer, length);
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R2_A6_SIGNATURE, rts))
				status = rts_recv_OUT_R2_A6_pdu(rpc, buffer, length);
			if (rts_match_pdu_signature(&RTS_PDU_OUT_R2_B3_SIGNATURE, rts))
				status = rts_recv_OUT_R2_B3_pdu(rpc, buffer, length);
	if (status < 0)",d39a7ba5c38e3ba3b99b1558dc2ab0970cbfb0c5,CVE-2021-41160,d39a7ba5c38e3ba3b99b1558dc2ab0970cbfb0c5,https://github.com/FreeRDP/FreeRDP,NVD_GIT_REPOBASED,66,COMPLETED,"  VAR VAR VAR* VAR(VAR VAR) { VAR (VAR) { VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR VAR: VAR ""VAR""; VAR: VAR ""VAR""; } } VAR VAR = { 0 }; VAR.VAR.VAR = 5; VAR.VAR.VAR = 0; VAR.VAR.VAR = VAR; VAR.VAR.VAR[0] = 0x10; VAR.VAR.VAR[1] = 0x00; VAR.VAR.VAR[2] = 0x00; VAR.VAR.VAR[3] = 0x00; VAR.VAR.VAR = VAR | VAR; VAR.VAR.VAR = 0; VAR.VAR.VAR = 0; VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR) { VAR VAR, VAR; VAR(VAR); VAR(VAR > 0); VAR = VAR(VAR); VAR = VAR(&VAR, VAR); VAR VAR(VAR, VAR); } VAR VAR* VAR(VAR VAR* VAR, VAR VAR) { VAR* VAR; VAR(VAR || (VAR == 0)); VAR (VAR == 0) VAR VAR; VAR = VAR(VAR + 1, VAR(VAR)); VAR (!VAR) VAR VAR; VAR(VAR, VAR, VAR); VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, VAR(VAR))) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR, VAR(VAR->VAR)); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR; } VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR, VAR(VAR->VAR)); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (VAR->VAR < VAR(VAR)) VAR VAR; VAR = VAR(VAR); VAR (VAR < VAR->VAR - VAR(VAR)) VAR VAR; VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR->VAR > VAR->VAR); VAR (VAR) *VAR = VAR(VAR);  { VAR VAR VAR = VAR->VAR - VAR->VAR - 8; VAR(VAR, VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); } VAR (VAR->VAR != 0) { VAR VAR* VAR = VAR(VAR); VAR (!VAR(VAR, VAR->VAR)) VAR VAR; VAR->VAR = (VAR*)VAR(VAR, VAR->VAR); VAR (VAR->VAR == VAR) VAR VAR; } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR(VAR); VAR (!VAR(VAR, VAR, VAR, &VAR)) VAR VAR; { VAR VAR VAR = VAR->VAR - VAR->VAR - 8; VAR(VAR + VAR->VAR == VAR); } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR* VAR) { VAR VAR; VAR VAR = 0; VAR** VAR = VAR; VAR (!VAR(VAR, VAR, VAR, &VAR)) VAR VAR; VAR (VAR->VAR) { VAR VAR: { VAR* VAR = (VAR*)VAR; VAR = VAR->VAR; VAR = &VAR->VAR; } VAR; VAR VAR: { VAR* VAR = (VAR*)VAR; VAR = VAR->VAR; VAR = &VAR->VAR; } VAR; VAR VAR: { VAR* VAR = (VAR*)VAR; VAR = VAR->VAR; VAR = &VAR->VAR; } VAR; VAR: VAR VAR; } VAR (VAR > 0) { VAR VAR VAR = VAR->VAR - VAR->VAR - 8 - VAR->VAR - VAR; VAR VAR* VAR = VAR(VAR) + VAR; *VAR = (VAR*)VAR(VAR, VAR); VAR (!*VAR) VAR VAR; } VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR VAR* VAR, VAR VAR* VAR) { VAR VAR; VAR VAR = 0; VAR(VAR); VAR(VAR); VAR(VAR);  VAR = VAR(VAR); VAR ((VAR % 4) != 0) { VAR = 4 - (VAR % 4); VAR (!VAR(VAR, VAR)) VAR VAR; VAR(VAR, VAR); } VAR(VAR->VAR + 8ull > VAR->VAR); { VAR VAR = VAR(VAR); VAR VAR = VAR->VAR - VAR->VAR - 8; VAR(VAR == VAR); } VAR (!VAR(VAR, VAR(VAR))) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR); VAR(VAR, 0);  VAR(VAR, VAR->VAR); VAR (!VAR(VAR, VAR->VAR)) VAR VAR; VAR(VAR, VAR->VAR, VAR->VAR); VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 2 * VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR; } VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); VAR->VAR = VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR);  VAR (VAR->VAR > 0) { VAR->VAR = VAR(VAR->VAR, VAR(VAR)); VAR (!VAR->VAR) VAR VAR; } VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR* VAR = &VAR->VAR[VAR]; VAR (!VAR(VAR, VAR))  { VAR(VAR); VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR* VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR (VAR->VAR == 0) VAR VAR; VAR = VAR(VAR); VAR (!VAR(VAR, VAR->VAR)) VAR VAR; VAR->VAR = VAR(VAR, VAR->VAR); VAR VAR->VAR != VAR; } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR, VAR(VAR->VAR)); VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, VAR(VAR))) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR, VAR(VAR->VAR)); VAR VAR; } VAR VAR* VAR(VAR VAR) { VAR VAR(VAR, VAR(VAR)); } VAR VAR VAR(VAR* VAR) { VAR(VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR->VAR); VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, 4)) VAR VAR; VAR(VAR, VAR->VAR); VAR VAR; } VAR* VAR(VAR VAR) { VAR* VAR = VAR(VAR, VAR(VAR)); VAR VAR; } VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); VAR(VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR (!VAR(VAR, &VAR->VAR))  VAR VAR; VAR (VAR->VAR > 0) { VAR->VAR = VAR(VAR->VAR); VAR (!VAR->VAR) VAR VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR* VAR = &VAR->VAR[VAR]; VAR (!VAR(VAR, VAR))  VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (!VAR(VAR, 4)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR (!VAR(VAR, &VAR->VAR))  VAR VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR VAR* VAR = &VAR->VAR[VAR]; VAR (!VAR(VAR, VAR))  VAR VAR; } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR (VAR->VAR > 0) { VAR->VAR = VAR(VAR->VAR); VAR (!VAR->VAR) VAR VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR* VAR = &VAR->VAR[VAR]; VAR (!VAR(VAR, VAR)) VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (!VAR(VAR, 4)) VAR VAR; VAR(VAR, VAR->VAR);  VAR(VAR, 0);  VAR(VAR, 0);  VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR VAR* VAR = &VAR->VAR[VAR]; VAR (!VAR(VAR, VAR)) VAR VAR; } VAR VAR; } VAR VAR* VAR(VAR VAR) { VAR VAR(VAR, VAR(VAR)); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 2) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR(VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR(VAR, VAR->VAR);  VAR (VAR->VAR > 0) { VAR->VAR = VAR(VAR->VAR); VAR (!VAR->VAR) VAR VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR* VAR = &VAR->VAR[VAR];  VAR (!VAR(VAR, VAR)) VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR VAR; VAR (!VAR) VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR* VAR = &VAR->VAR[VAR]; VAR(VAR); } VAR(VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, &VAR->VAR, &VAR->VAR)) VAR VAR; VAR VAR; } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, 4)) VAR VAR; VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, &VAR->VAR, &VAR->VAR)) VAR VAR; VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, &VAR->VAR, &VAR->VAR)) VAR VAR; VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, 4)) VAR VAR; VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR VAR(VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, 8)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR* VAR) { VAR (!VAR) VAR; VAR(VAR->VAR); VAR(&VAR->VAR); } VAR VAR VAR(VAR* VAR, VAR* VAR) { VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR) - VAR(VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR; } VAR VAR VAR(VAR* VAR) { VAR(VAR); } VAR VAR(VAR* VAR, VAR VAR) { VAR (!VAR) VAR; VAR (VAR->VAR.VAR) { VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR; VAR VAR: VAR(&VAR->VAR); VAR;  VAR VAR: VAR;  VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR: VAR; } VAR (VAR) VAR(VAR); } VAR VAR(VAR* VAR, VAR* VAR) { VAR VAR = VAR; VAR(VAR); VAR(VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR(VAR, ""VAR VAR VAR %VAR"", VAR(VAR->VAR.VAR)); VAR(VAR); VAR (VAR->VAR.VAR) { VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR(VAR, &VAR->VAR); VAR; VAR VAR: VAR = VAR;  VAR;  VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR: VAR; } VAR VAR; } VAR VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, VAR(VAR))) VAR VAR; VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR -1; VAR(VAR, VAR); *VAR = VAR;  VAR VAR VAR(VAR* VAR, VAR VAR) VAR(VAR); VAR (!VAR(VAR, 2 * VAR(VAR))) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR* VAR, VAR* VAR, VAR* VAR) VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 24) VAR -1; VAR(VAR, VAR); *VAR = VAR;  VAR(VAR, VAR); *VAR = VAR;  VAR(VAR, VAR, 16);  VAR VAR(VAR, 16); VAR VAR VAR(VAR* VAR, VAR VAR, VAR VAR, VAR* VAR) VAR(VAR); VAR (!VAR(VAR, 28)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR);  VAR(VAR, VAR);  VAR(VAR, VAR, 16);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR* VAR) VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR); VAR (VAR) *VAR = VAR;  VAR VAR; VAR VAR VAR(VAR* VAR, VAR VAR* VAR) VAR(VAR); VAR (!VAR(VAR, 20)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR, 16);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR VAR) VAR(VAR); VAR (!VAR(VAR, 8)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR VAR) VAR(VAR); VAR (!VAR(VAR, 8)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR(VAR); VAR(VAR); VAR (!VAR(VAR, 4)) VAR VAR;  VAR VAR; VAR VAR VAR(VAR* VAR) VAR(VAR); VAR (VAR(VAR) < 8) VAR VAR; VAR(VAR, VAR);  VAR(VAR, 1);  VAR VAR; VAR VAR VAR(VAR* VAR) VAR(VAR); VAR (!VAR(VAR, 8)) VAR VAR; VAR(VAR, VAR);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR);  *VAR = VAR + 4; VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR VAR; VAR(VAR, VAR);  *VAR = 4 + 4 + 12; *VAR = 4 + 16 + 12; VAR VAR; VAR VAR VAR(VAR* VAR, VAR VAR* VAR) VAR(VAR); VAR (!VAR(VAR, 20)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR, 16);  VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR* VAR) VAR VAR; VAR(VAR); VAR(VAR); VAR (VAR(VAR) < 4) VAR -1; VAR(VAR, VAR); *VAR = VAR;  VAR VAR VAR(VAR* VAR, VAR VAR) VAR(VAR); VAR (!VAR(VAR, 8)) VAR VAR; VAR(VAR, VAR);  VAR(VAR, VAR);  VAR VAR; VAR(VAR); VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) { VAR VAR = VAR; VAR VAR; VAR(VAR); VAR(VAR); VAR(VAR); VAR (VAR(VAR) < VAR(VAR)) VAR VAR; VAR (VAR(VAR) != VAR) VAR VAR; VAR = VAR(VAR, VAR(VAR), VAR(VAR)); VAR (VAR < 0) VAR VAR; VAR ((VAR)VAR != VAR(VAR)) VAR VAR; VAR = VAR; VAR: VAR VAR; } VAR VAR(VAR* VAR) VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR (!VAR(VAR, &VAR))  VAR VAR; VAR = VAR(VAR);  VAR (!VAR) VAR VAR; VAR = VAR( VAR, VAR);  VAR (!VAR) VAR VAR; VAR = VAR(VAR, VAR);  VAR (!VAR) VAR VAR; VAR = VAR( VAR, VAR);  VAR (!VAR) VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR VAR; VAR VAR(VAR* VAR, VAR* VAR) VAR VAR; VAR (!VAR(VAR, 24)) VAR VAR; VAR = VAR(VAR, VAR, &VAR); VAR (!VAR) VAR VAR; VAR(VAR); VAR(VAR->VAR); VAR(VAR->VAR->VAR); VAR VAR; VAR VAR(VAR* VAR) VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR VAR; VAR (!VAR(VAR, &VAR))  VAR VAR; VAR (!VAR(VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR->VAR))  VAR VAR; VAR (!VAR(VAR, VAR->VAR))  VAR VAR; VAR (!VAR( VAR, VAR))  VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR VAR; VAR VAR(VAR* VAR, VAR* VAR) VAR VAR; VAR(VAR); VAR(VAR); VAR (!VAR(VAR, 24)) VAR VAR; VAR = VAR(VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR, VAR, &VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR, VAR, &VAR); VAR (VAR < 0) VAR VAR; VAR(VAR); VAR(VAR->VAR); VAR(VAR->VAR->VAR); VAR VAR; VAR VAR(VAR* VAR) VAR VAR = VAR; VAR* VAR; VAR VAR; VAR VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR VAR; VAR (!VAR(VAR, &VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR, VAR, VAR)) VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR VAR; VAR VAR[16] = { 0 }; VAR = VAR(VAR, VAR, &VAR, &VAR, (VAR*)&VAR); VAR (VAR < 0) VAR VAR; VAR(VAR->VAR); VAR(VAR->VAR->VAR); VAR VAR VAR(VAR* VAR, VAR* VAR) VAR VAR; VAR VAR[16] = { 0 }; VAR = VAR(VAR, VAR, &VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR, VAR, &VAR, &VAR, VAR); VAR (VAR < 0) VAR VAR; VAR(VAR->VAR); VAR(VAR->VAR->VAR); VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR(VAR->VAR); VAR = VAR->VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR VAR; VAR (!VAR(VAR, &VAR))  VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR (VAR) ? 1 : -1; VAR VAR(VAR VAR, VAR* VAR, VAR* VAR) VAR VAR = 0; VAR VAR = 0; VAR(VAR); VAR (!VAR(VAR, &VAR)) VAR VAR; VAR (!VAR(VAR, &VAR)) VAR VAR; VAR VAR; VAR += VAR; VAR (VAR(VAR) < VAR) VAR VAR; VAR (VAR) *VAR = VAR; VAR VAR; VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR(VAR->VAR); VAR = VAR->VAR->VAR; VAR(VAR); VAR = VAR->VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR (!VAR(VAR, &VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR))  VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR (VAR) ? 1 : -1; VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR(VAR->VAR); VAR = VAR->VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR (!VAR(VAR, &VAR))  VAR VAR; VAR (!VAR(VAR))  VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR (VAR) ? 1 : -1; VAR VAR(VAR* VAR) VAR VAR = VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR* VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR.VAR.VAR); VAR (!VAR(VAR, &VAR))  VAR VAR; VAR (!VAR(VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR( VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR (!VAR(VAR, VAR))  VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR: VAR(VAR, VAR); VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR* VAR; VAR(VAR); VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR = VAR(VAR, VAR, &VAR); VAR (VAR < 0) VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR* VAR; VAR(VAR); VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR VAR VAR(VAR* VAR, VAR* VAR) VAR* VAR; VAR(VAR); VAR(VAR); VAR = VAR->VAR; VAR(VAR); VAR VAR(VAR* VAR, VAR* VAR, VAR VAR* VAR) VAR VAR = VAR; VAR VAR, VAR; VAR VAR = { 0 }; VAR(VAR); VAR(VAR); VAR(VAR); VAR = VAR(VAR); VAR = VAR->VAR.VAR; VAR (VAR < VAR) VAR VAR; VAR VAR; VAR (!VAR(&VAR, VAR, VAR)) VAR VAR; VAR (VAR(&VAR, VAR, VAR)) VAR = VAR(VAR, VAR); VAR VAR (VAR(&VAR, VAR, VAR)) VAR = VAR(VAR, VAR); VAR VAR (VAR(&VAR, VAR, VAR)) VAR (VAR(&VAR, VAR, VAR)) VAR = VAR(VAR, VAR); VAR (VAR(&VAR, VAR, VAR)) VAR = VAR(VAR, VAR); VAR (VAR(&VAR, VAR, VAR)) VAR = VAR(VAR, VAR); VAR (!VAR) VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, 2 * VAR(VAR))) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR(VAR* VAR, VAR VAR* VAR) { VAR(VAR); VAR(VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR (!VAR(VAR, 8)) VAR VAR; VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR); VAR (!VAR(VAR, &VAR->VAR)) VAR VAR; VAR VAR(VAR, &VAR->VAR, &VAR->VAR); } VAR VAR = { 0 }; VAR.VAR.VAR = 5; VAR.VAR.VAR = 0; VAR.VAR.VAR = VAR; VAR.VAR.VAR[0] = 0x10; VAR.VAR.VAR[1] = 0x00; VAR.VAR.VAR[2] = 0x00; VAR.VAR.VAR[3] = 0x00; VAR.VAR.VAR = VAR | VAR; VAR.VAR.VAR = 0; VAR.VAR.VAR = 0; VAR VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR, *VAR = *((VAR*)&VAR[0]);  VAR VAR VAR(VAR* VAR, VAR VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR, VAR* VAR, VAR* VAR, VAR* VAR) *VAR = *((VAR*)&VAR[0]);  *VAR = *((VAR*)&VAR[4]);  VAR(VAR, &VAR[8], 16);  VAR VAR VAR(VAR* VAR, VAR VAR, VAR VAR, VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;   *((VAR*)&VAR[4]) = VAR;  *((VAR*)&VAR[8]) = VAR;  VAR(&VAR[12], VAR, 16);  } VAR 28; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR, VAR* VAR) { VAR (VAR) *VAR = *((VAR*)&VAR[0]);  VAR 4; VAR VAR VAR(VAR* VAR, VAR VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 16; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  VAR(&VAR[4], VAR, 16);  } VAR 20; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 4; VAR VAR VAR(VAR* VAR, VAR VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 4; VAR VAR VAR(VAR* VAR, VAR VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 4; VAR VAR VAR(VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = 1;  } VAR 8; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) { VAR 0; VAR VAR VAR(VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  } VAR 4; } VAR VAR VAR(VAR VAR* VAR, VAR VAR) { VAR VAR; VAR = *((VAR*)&VAR[0]);   VAR VAR + 4; } VAR VAR VAR(VAR* VAR, VAR VAR) { VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  VAR(&VAR[8], VAR);  } VAR 8 + VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR 0; } VAR VAR VAR(VAR* VAR) { VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  } VAR 4; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) { VAR 0; VAR VAR VAR(VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  } VAR 4; VAR VAR VAR(VAR VAR* VAR, VAR VAR) VAR = *((VAR*)&VAR[0]);  VAR 4 + 4 + 12; VAR 4 + 16 + 12; VAR VAR VAR(VAR* VAR, VAR VAR, VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR (VAR == 0) { VAR (VAR) { VAR(&VAR[8], VAR, 4);  VAR(&VAR[12], 12);  } VAR 24; } VAR { VAR (VAR) { VAR(&VAR[8], VAR, 16);  VAR(&VAR[24], 12);  } VAR 36; } } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 16; VAR VAR VAR(VAR* VAR, VAR* VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  VAR(&VAR[4], VAR, 16);  } VAR 20; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR, VAR* VAR) { *VAR = *((VAR*)&VAR[0]);  VAR VAR VAR(VAR* VAR, VAR VAR) VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; } VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) {  VAR 4; } VAR VAR VAR(VAR* VAR, VAR VAR) { VAR (VAR) { *((VAR*)&VAR[0]) = VAR;  *((VAR*)&VAR[4]) = VAR;  } VAR 8; VAR VAR(VAR* VAR) VAR VAR; VAR* VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20]);  VAR(&VAR[28], VAR);  VAR(&VAR[48], VAR);  VAR(&VAR[68], VAR);  VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR(VAR, &VAR[24], VAR - 24, &VAR); VAR 1; VAR VAR(VAR* VAR) VAR VAR; VAR* VAR; VAR VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR -1; VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20]);  VAR(&VAR[28], VAR);  VAR(&VAR[48], VAR);  VAR(&VAR[68], VAR->VAR);  VAR(&VAR[76], VAR->VAR);  VAR(&VAR[84], VAR);  VAR = VAR.VAR.VAR; VAR = VAR(&VAR->VAR, VAR, VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR VAR; VAR = 24; VAR += VAR(VAR, &VAR[VAR], VAR - VAR) + 4; VAR += VAR(VAR, &VAR[VAR], VAR - VAR, &VAR) + 4; VAR += VAR(VAR, &VAR[VAR], VAR - VAR, &VAR) + 4; VAR 1; VAR VAR VAR(VAR* VAR) VAR VAR; VAR* VAR; VAR VAR; VAR* VAR = VAR->VAR->VAR; VAR.VAR.VAR = 28; VAR.VAR = VAR; VAR.VAR = 1; VAR(VAR, ""VAR VAR-VAR VAR VAR""); VAR = (VAR*)VAR(VAR.VAR.VAR); VAR (!VAR) VAR -1; VAR(VAR, ((VAR*)&VAR), 20);  VAR( &VAR[20], VAR->VAR);  VAR = VAR.VAR.VAR; VAR = VAR(&VAR->VAR, VAR, VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; } VAR VAR(VAR* VAR) { VAR VAR; VAR* VAR; VAR VAR; VAR VAR = VAR(); VAR VAR; VAR VAR; VAR* VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR -1; VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20], VAR);  VAR(&VAR[28], VAR, VAR, VAR); VAR = VAR.VAR.VAR; VAR = VAR(&VAR->VAR, VAR, VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR VAR; VAR VAR[16]; VAR = 24; VAR += VAR(VAR, &VAR[VAR], VAR - VAR, &VAR, &VAR, (VAR*)&VAR) + 4; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR VAR; VAR VAR[16]; VAR = 24; VAR += VAR(VAR, &VAR[VAR], VAR - VAR, &VAR) + 4; VAR += VAR(VAR, &VAR[VAR], VAR - VAR, &VAR, &VAR, (VAR*)&VAR) + 4; VAR VAR; VAR* VAR; VAR VAR; VAR* VAR = VAR->VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR -1; VAR(VAR, ((VAR*)&VAR), 20);  VAR = VAR.VAR.VAR; VAR = VAR(&VAR->VAR, VAR, VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR(VAR VAR, VAR VAR* VAR, VAR VAR) VAR VAR = 0; VAR = VAR(VAR, VAR); VAR = VAR(VAR, VAR); VAR -1; VAR VAR; VAR VAR; VAR* VAR; VAR* VAR = VAR->VAR->VAR; VAR* VAR = VAR->VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20], VAR);  VAR(&VAR[28], VAR);  VAR(&VAR[48]);  VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR; VAR* VAR; VAR* VAR = VAR->VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20]);  VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR(VAR* VAR) VAR VAR; VAR* VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR* VAR = VAR->VAR; VAR = (VAR*)VAR(VAR.VAR.VAR); VAR(VAR, ((VAR*)&VAR), 20);  VAR(&VAR[20]);  VAR(&VAR[28], VAR);  VAR(&VAR[48], VAR);  VAR(&VAR[68], VAR);  VAR(&VAR[88], VAR);  VAR = VAR(&VAR->VAR, VAR, VAR.VAR.VAR); VAR(VAR); VAR (VAR > 0) ? 1 : -1; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR VAR; VAR* VAR = VAR->VAR; VAR = 24; VAR (VAR < VAR) VAR -1; VAR(VAR, &VAR[VAR], VAR - VAR, &VAR); VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR* VAR = VAR->VAR; VAR VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR* VAR = VAR->VAR; VAR VAR(VAR* VAR, VAR* VAR, VAR VAR) VAR VAR = -1; VAR* VAR; VAR VAR; VAR (!VAR || !VAR) VAR -1; VAR -1; VAR = (VAR*)VAR; VAR (!VAR(&VAR, VAR)) VAR -1; VAR (VAR(&VAR, VAR)) VAR = VAR(VAR, VAR, VAR); VAR VAR (VAR(&VAR, VAR)) VAR = VAR(VAR, VAR, VAR); VAR VAR (VAR(&VAR, VAR)) VAR (VAR(&VAR, VAR)) VAR = VAR(VAR, VAR, VAR); VAR (VAR(&VAR, VAR)) VAR = VAR(VAR, VAR, VAR); VAR (VAR(&VAR, VAR)) VAR = VAR(VAR, VAR, VAR); VAR (VAR < 0)",7
go_0d719823af1343f9921ee0293596f09e36ced0e4,doc/godebug.md,"
Go 1.21 made it an error for html/template actions to appear inside of an ECMAScript 6
template literal, controlled by the
[`jstmpllitinterp` setting](/pkg/html/template#hdr-Security_Model).
This behavior was backported to Go 1.19.8+ and Go 1.20.3+.

Go 1.21 introduced a limit on the maximum number of MIME headers and multipart
forms, controlled by the
[`multipartmaxheaders` and `multipartmaxparts` settings](/pkg/mime/multipart#hdr-Limits)
respectively.
This behavior was backported to Go 1.19.8+ and Go 1.20.3+.

There is no plan to remove any of these settings.",There is no plan to remove this setting.,0d719823af1343f9921ee0293596f09e36ced0e4,CVE-2023-24538,0d719823af1343f9921ee0293596f09e36ced0e4,https://github.com/golang/go,CPE_GIT_REPOBASED,70,COMPLETED,"VAR 1.21 VAR VAR VAR VAR VAR VAR/VAR VAR VAR VAR VAR VAR VAR VAR 6 VAR VAR, VAR VAR VAR [`VAR` VAR](/VAR/VAR/VAR VAR VAR VAR VAR VAR VAR 1.19.8+ VAR VAR 1.20.3+. VAR 1.21 VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR [`VAR` VAR `VAR` VAR](/VAR/VAR/VAR VAR. VAR VAR VAR VAR VAR VAR 1.19.8+ VAR VAR 1.20.3+. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR.",7
go_6446af942e2e2b161c4ec1b60d9703a2b55dc4dd,src/net/http/internal/chunked_test.go,"
func TestChunkReaderTooMuchOverhead(t *testing.T) {
	// If the sender is sending 100x as many chunk header bytes as chunk data,
	// we should reject the stream at some point.
	chunk := []byte(""1;"")
	for i := 0; i < 100; i++ {
		chunk = append(chunk, 'a') // chunk extension
	}
	chunk = append(chunk, ""\r\nX\r\n""...)
	const bodylen = 1 << 20
	r := NewChunkedReader(&funcReader{f: func(i int) ([]byte, error) {
		if i < bodylen {
			return chunk, nil
		}
		return []byte(""0\r\n""), nil
	}})
	_, err := io.ReadAll(r)
	if err == nil {
		t.Fatalf(""successfully read body with excessive overhead; want error"")
	}
}

func TestChunkReaderByteAtATime(t *testing.T) {
	// Sending one byte per chunk should not trip the excess-overhead detection.
	const bodylen = 1 << 20
	r := NewChunkedReader(&funcReader{f: func(i int) ([]byte, error) {
		if i < bodylen {
			return []byte(""1\r\nX\r\n""), nil
		}
		return []byte(""0\r\n""), nil
	}})
	got, err := io.ReadAll(r)
	if err != nil {
		t.Errorf(""unexpected error: %v"", err)
	}
	if len(got) != bodylen {
		t.Errorf(""read %v bytes, want %v"", len(got), bodylen)
	}
}

type funcReader struct {
	f   func(iteration int) ([]byte, error)
	i   int
	b   []byte
	err error
}

func (r *funcReader) Read(p []byte) (n int, err error) {
	if len(r.b) == 0 && r.err == nil {
		r.b, r.err = r.f(r.i)
		r.i++
	}
	n = copy(p, r.b)
	r.b = r.b[n:]
	if len(r.b) > 0 {
		return n, nil
	}
	return n, r.err
}",,6446af942e2e2b161c4ec1b60d9703a2b55dc4dd,CVE-2023-39326,6446af942e2e2b161c4ec1b60d9703a2b55dc4dd,https://github.com/golang/go,CPE_GIT_REPOBASED,150,COMPLETED,"VAR VAR(VAR *VAR.VAR) {   VAR := []VAR(""1;"") VAR VAR := 0; VAR < 100; VAR++ { VAR = VAR(VAR, 'VAR')  } VAR = VAR(VAR, ""\VAR\VAR\VAR\VAR""...) VAR VAR = 1 << 20 VAR := VAR(&VAR{VAR: VAR(VAR VAR) ([]VAR, VAR) { VAR VAR < VAR { VAR VAR, VAR } VAR []VAR(""0\VAR\VAR""), VAR }}) VAR, VAR := VAR.VAR(VAR) VAR VAR == VAR { VAR.VAR(""VAR VAR VAR VAR VAR VAR; VAR VAR"") } } VAR VAR(VAR *VAR.VAR) {  VAR VAR = 1 << 20 VAR := VAR(&VAR{VAR: VAR(VAR VAR) ([]VAR, VAR) { VAR VAR < VAR { VAR []VAR(""1\VAR\VAR\VAR\VAR""), VAR } VAR []VAR(""0\VAR\VAR""), VAR }}) VAR, VAR := VAR.VAR(VAR) VAR VAR != VAR { VAR.VAR(""VAR VAR: %VAR"", VAR) } VAR VAR(VAR) != VAR { VAR.VAR(""VAR %VAR VAR, VAR %VAR"", VAR(VAR), VAR) } } VAR VAR VAR { VAR VAR(VAR VAR) ([]VAR, VAR) VAR VAR VAR []VAR VAR VAR } VAR (VAR *VAR) VAR(VAR []VAR) (VAR VAR, VAR VAR) { VAR VAR(VAR.VAR) == 0 && VAR.VAR == VAR { VAR.VAR, VAR.VAR = VAR.VAR(VAR.VAR) VAR.VAR++ } VAR = VAR(VAR, VAR.VAR) VAR.VAR = VAR.VAR[VAR:] VAR VAR(VAR.VAR) > 0 { VAR VAR, VAR } VAR VAR, VAR.VAR } ",7
go_ea6b5a64dd5bf68b33286436ffbe06f68a1fdbfd,src/mime/multipart/formdata_test.go,"
func BenchmarkReadForm(b *testing.B) {
	for _, test := range []struct {
		name string
		form func(fw *Writer, count int)
	}{{
		name: ""fields"",
		form: func(fw *Writer, count int) {
			for i := 0; i < count; i++ {
				w, _ := fw.CreateFormField(fmt.Sprintf(""field%v"", i))
				fmt.Fprintf(w, ""value %v"", i)
			}
		},
	}, {
		name: ""files"",
		form: func(fw *Writer, count int) {
			for i := 0; i < count; i++ {
				w, _ := fw.CreateFormFile(fmt.Sprintf(""field%v"", i), fmt.Sprintf(""file%v"", i))
				fmt.Fprintf(w, ""value %v"", i)
			}
		},
	}} {
		b.Run(test.name, func(b *testing.B) {
			for _, maxMemory := range []int64{
				0,
				1 << 20,
			} {
				var buf bytes.Buffer
				fw := NewWriter(&buf)
				test.form(fw, 10)
				if err := fw.Close(); err != nil {
					b.Fatal(err)
				}
				b.Run(fmt.Sprintf(""maxMemory=%v"", maxMemory), func(b *testing.B) {
					b.ReportAllocs()
					for i := 0; i < b.N; i++ {
						fr := NewReader(bytes.NewReader(buf.Bytes()), fw.Boundary())
						form, err := fr.ReadForm(maxMemory)
						if err != nil {
							b.Fatal(err)
						}
						form.RemoveAll()
					}

				})
			}
		})
	}
}",,ea6b5a64dd5bf68b33286436ffbe06f68a1fdbfd,CVE-2023-24536,ea6b5a64dd5bf68b33286436ffbe06f68a1fdbfd,https://github.com/golang/go,CPE_GIT_REPOBASED,226,COMPLETED,"VAR VAR(VAR *VAR.VAR) { VAR VAR, VAR := VAR []VAR { VAR VAR VAR VAR(VAR *VAR, VAR VAR) }{{ VAR: ""VAR"", VAR: VAR(VAR *VAR, VAR VAR) { VAR VAR := 0; VAR < VAR; VAR++ { VAR, VAR := VAR.VAR(VAR.VAR(""VAR%VAR"", VAR)) VAR.VAR(VAR, ""VAR %VAR"", VAR) } }, }, { VAR: ""VAR"", VAR: VAR(VAR *VAR, VAR VAR) { VAR VAR := 0; VAR < VAR; VAR++ { VAR, VAR := VAR.VAR(VAR.VAR(""VAR%VAR"", VAR), VAR.VAR(""VAR%VAR"", VAR)) VAR.VAR(VAR, ""VAR %VAR"", VAR) } }, }} { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR VAR, VAR := VAR []VAR{ 0, 1 << 20, } { VAR VAR VAR.VAR VAR := VAR(&VAR) VAR.VAR(VAR, 10) VAR VAR := VAR.VAR(); VAR != VAR { VAR.VAR(VAR) } VAR.VAR(VAR.VAR(""VAR=%VAR"", VAR), VAR(VAR *VAR.VAR) { VAR.VAR() VAR VAR := 0; VAR < VAR.VAR; VAR++ { VAR := VAR(VAR.VAR(VAR.VAR()), VAR.VAR()) VAR, VAR := VAR.VAR(VAR) VAR VAR != VAR { VAR.VAR(VAR) } VAR.VAR() } }) } }) } } ",7
go_ef41a4e2face45e580c5836eaebd51629fc23f15,src/mime/multipart/formdata_test.go,"
func BenchmarkReadForm(b *testing.B) {
	for _, test := range []struct {
		name string
		form func(fw *Writer, count int)
	}{{
		name: ""fields"",
		form: func(fw *Writer, count int) {
			for i := 0; i < count; i++ {
				w, _ := fw.CreateFormField(fmt.Sprintf(""field%v"", i))
				fmt.Fprintf(w, ""value %v"", i)
			}
		},
	}, {
		name: ""files"",
		form: func(fw *Writer, count int) {
			for i := 0; i < count; i++ {
				w, _ := fw.CreateFormFile(fmt.Sprintf(""field%v"", i), fmt.Sprintf(""file%v"", i))
				fmt.Fprintf(w, ""value %v"", i)
			}
		},
	}} {
		b.Run(test.name, func(b *testing.B) {
			for _, maxMemory := range []int64{
				0,
				1 << 20,
			} {
				var buf bytes.Buffer
				fw := NewWriter(&buf)
				test.form(fw, 10)
				if err := fw.Close(); err != nil {
					b.Fatal(err)
				}
				b.Run(fmt.Sprintf(""maxMemory=%v"", maxMemory), func(b *testing.B) {
					b.ReportAllocs()
					for i := 0; i < b.N; i++ {
						fr := NewReader(bytes.NewReader(buf.Bytes()), fw.Boundary())
						form, err := fr.ReadForm(maxMemory)
						if err != nil {
							b.Fatal(err)
						}
						form.RemoveAll()
					}

				})
			}
		})
	}
}",,ef41a4e2face45e580c5836eaebd51629fc23f15,CVE-2023-24536,ef41a4e2face45e580c5836eaebd51629fc23f15,https://github.com/golang/go,CPE_GIT_REPOBASED,162,COMPLETED,"VAR VAR(VAR *VAR.VAR) { VAR VAR, VAR := VAR []VAR { VAR VAR VAR VAR(VAR *VAR, VAR VAR) }{{ VAR: ""VAR"", VAR: VAR(VAR *VAR, VAR VAR) { VAR VAR := 0; VAR < VAR; VAR++ { VAR, VAR := VAR.VAR(VAR.VAR(""VAR%VAR"", VAR)) VAR.VAR(VAR, ""VAR %VAR"", VAR) } }, }, { VAR: ""VAR"", VAR: VAR(VAR *VAR, VAR VAR) { VAR VAR := 0; VAR < VAR; VAR++ { VAR, VAR := VAR.VAR(VAR.VAR(""VAR%VAR"", VAR), VAR.VAR(""VAR%VAR"", VAR)) VAR.VAR(VAR, ""VAR %VAR"", VAR) } }, }} { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR VAR, VAR := VAR []VAR{ 0, 1 << 20, } { VAR VAR VAR.VAR VAR := VAR(&VAR) VAR.VAR(VAR, 10) VAR VAR := VAR.VAR(); VAR != VAR { VAR.VAR(VAR) } VAR.VAR(VAR.VAR(""VAR=%VAR"", VAR), VAR(VAR *VAR.VAR) { VAR.VAR() VAR VAR := 0; VAR < VAR.VAR; VAR++ { VAR := VAR(VAR.VAR(VAR.VAR()), VAR.VAR()) VAR, VAR := VAR.VAR(VAR) VAR VAR != VAR { VAR.VAR(VAR) } VAR.VAR() } }) } }) } } ",7
gpac_289ffce3e0d224d314f5f92a744d5fe35999f20b,applications/mp4box/filedump.c,"		if (!av1c) {
			fprintf(stderr, ""\tCorrupted av1 config\n"");
		} else {
			fprintf(stderr, ""\tversion=%u, profile=%u, level_idx0=%u, tier=%u\n"", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);
			fprintf(stderr, ""\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\n"", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);
			fprintf(stderr, ""\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\n"", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);
			if (av1c->initial_presentation_delay_present)
				fprintf(stderr, ""\tInitial presentation delay %u\n"", (u32) av1c->initial_presentation_delay_minus_one+1);
			count = gf_list_count(av1c->obu_array);
			for (i=0; i<count; i++) {
				u8 hash[20];
				GF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);
				gf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);
				fprintf(stderr, ""\tOBU#%d %s hash: "", i+1, gf_av1_get_obu_name(obu->obu_type) );
				for (j=0; j<20; j++) fprintf(stderr, ""%02X"", hash[j]);
				fprintf(stderr, ""\n"");
			}
			gf_odf_av1_cfg_del(av1c);","		fprintf(stderr, ""\tversion=%u, profile=%u, level_idx0=%u, tier=%u\n"", (u32)av1c->version, (u32)av1c->seq_profile, (u32)av1c->seq_level_idx_0, (u32)av1c->seq_tier_0);
		fprintf(stderr, ""\thigh_bitdepth=%u, twelve_bit=%u, monochrome=%u\n"", (u32)av1c->high_bitdepth, (u32)av1c->twelve_bit, (u32)av1c->monochrome);
		fprintf(stderr, ""\tchroma: subsampling_x=%u, subsampling_y=%u, sample_position=%u\n"", (u32)av1c->chroma_subsampling_x, (u32)av1c->chroma_subsampling_y, (u32)av1c->chroma_sample_position);
		if (av1c->initial_presentation_delay_present)
			fprintf(stderr, ""\tInitial presentation delay %u\n"", (u32) av1c->initial_presentation_delay_minus_one+1);
		count = gf_list_count(av1c->obu_array);
		for (i=0; i<count; i++) {
			u8 hash[20];
			GF_AV1_OBUArrayEntry *obu = gf_list_get(av1c->obu_array, i);
			gf_sha1_csum((u8*)obu->obu, (u32)obu->obu_length, hash);
			fprintf(stderr, ""\tOBU#%d %s hash: "", i+1, gf_av1_get_obu_name(obu->obu_type) );
			for (j=0; j<20; j++) fprintf(stderr, ""%02X"", hash[j]);
			fprintf(stderr, ""\n"");
		gf_odf_av1_cfg_del(av1c);",289ffce3e0d224d314f5f92a744d5fe35999f20b,CVE-2021-32138,289ffce3e0d224d314f5f92a744d5fe35999f20b,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR (!VAR) { VAR(VAR, ""\VAR VAR VAR\VAR""); } VAR { VAR(VAR, ""\VAR=%VAR, VAR=%VAR, VAR=%VAR, VAR=%VAR\VAR"", (VAR)VAR->VAR, (VAR)VAR->VAR, (VAR)VAR->VAR, (VAR)VAR->VAR); VAR(VAR, ""\VAR=%VAR, VAR=%VAR, VAR=%VAR\VAR"", (VAR)VAR->VAR, (VAR)VAR->VAR, (VAR)VAR->VAR); VAR(VAR, ""\VAR: VAR=%VAR, VAR=%VAR, VAR=%VAR\VAR"", (VAR)VAR->VAR, (VAR)VAR->VAR, (VAR)VAR->VAR); VAR (VAR->VAR) VAR(VAR, ""\VAR VAR VAR %VAR\VAR"", (VAR) VAR->VAR+1); VAR = VAR(VAR->VAR); VAR (VAR=0; VAR<VAR; VAR++) { VAR VAR[20]; VAR *VAR = VAR(VAR->VAR, VAR); VAR((VAR*)VAR->VAR, (VAR)VAR->VAR, VAR); VAR(VAR, ""\VAR VAR (VAR=0; VAR<20; VAR++) VAR(VAR, ""%02X"", VAR[VAR]); VAR(VAR, ""\VAR""); } VAR(VAR); VAR(VAR, ""\VAR=%VAR, VAR=%VAR, VAR=%VAR, VAR=%VAR\VAR"", (VAR)VAR->VAR, (VAR)VAR->VAR, (VAR)VAR->VAR, (VAR)VAR->VAR); VAR(VAR, ""\VAR=%VAR, VAR=%VAR, VAR=%VAR\VAR"", (VAR)VAR->VAR, (VAR)VAR->VAR, (VAR)VAR->VAR); VAR(VAR, ""\VAR: VAR=%VAR, VAR=%VAR, VAR=%VAR\VAR"", (VAR)VAR->VAR, (VAR)VAR->VAR, (VAR)VAR->VAR); VAR (VAR->VAR) VAR(VAR, ""\VAR VAR VAR %VAR\VAR"", (VAR) VAR->VAR+1); VAR = VAR(VAR->VAR); VAR (VAR=0; VAR<VAR; VAR++) { VAR VAR[20]; VAR *VAR = VAR(VAR->VAR, VAR); VAR((VAR*)VAR->VAR, (VAR)VAR->VAR, VAR); VAR(VAR, ""\VAR VAR (VAR=0; VAR<20; VAR++) VAR(VAR, ""%02X"", VAR[VAR]); VAR(VAR, ""\VAR""); VAR(VAR);",7
gpac_da37ec8582266983d0ec4b7550ec907401ec441e,src/filter_core/filter_session.c,"	u32 flen = 20 + (u32) strlen(file_name);

	char *apath = gf_malloc(sizeof(char) * (len+flen) );
	if (!apath) return GF_FALSE;
	strcpy(apath, path);

	strcat(apath, file_name);
	if (gf_file_exists(apath)) {
		gf_free(apath);
	}
		strcat(apath, "".js"");
		if (gf_file_exists(apath)) {
			gf_free(apath);
		}
	apath[len] = 0;
	strcat(apath, file_name);
	strcat(apath, ""/init.js"");
	if (gf_file_exists(apath)) {
		gf_free(apath);
	}
	gf_free(apath);","	strcat(path, file_name);
	if (gf_file_exists(path))
		strcat(path, "".js"");
		if (gf_file_exists(path))
	path[len] = 0;
	strcat(path, file_name);
	strcat(path, ""/init.js"");
	if (gf_file_exists(path))
",da37ec8582266983d0ec4b7550ec907401ec441e,CVE-2021-40942,da37ec8582266983d0ec4b7550ec907401ec441e,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,118,COMPLETED,"VAR VAR = 20 + (VAR) VAR(VAR); VAR *VAR = VAR(VAR(VAR) * (VAR+VAR) ); VAR (!VAR) VAR VAR; VAR(VAR, VAR); VAR(VAR, VAR); VAR (VAR(VAR)) { VAR(VAR); } VAR(VAR, "".VAR""); VAR (VAR(VAR)) { VAR(VAR); } VAR[VAR] = 0; VAR(VAR, VAR); VAR(VAR, ""/VAR.VAR""); VAR (VAR(VAR)) { VAR(VAR); } VAR(VAR); VAR(VAR, VAR); VAR (VAR(VAR)) VAR(VAR, "".VAR""); VAR (VAR(VAR)) VAR[VAR] = 0; VAR(VAR, VAR); VAR(VAR, ""/VAR.VAR""); VAR (VAR(VAR))",7
libarchive_1e18cbb71515a22b2a6f1eb4aaadea461929b834,libarchive/test/test_read_format_mtree.c,"	assertEqualIntA(a, ARCHIVE_OK, archive_read_next_header(a, &ae));
	assertEqualString(archive_entry_pathname(ae), ""dir2/dir3b/filename\\with_esc\b\t\fapes"");
	assertEqualInt(archive_entry_filetype(ae), AE_IFREG);
	assertEqualInt(archive_entry_is_encrypted(ae), 0);
	assertEqualIntA(a, archive_read_has_encrypted_entries(a), ARCHIVE_READ_FORMAT_ENCRYPTION_UNSUPPORTED);

	assertEqualInt(20, archive_file_count(a));","	assertEqualInt(19, archive_file_count(a));",1e18cbb71515a22b2a6f1eb4aaadea461929b834,CVE-2015-8925,1e18cbb71515a22b2a6f1eb4aaadea461929b834,https://github.com/libarchive/libarchive,NVD_GIT_REPOBASED,80,COMPLETED,"VAR(VAR, VAR, VAR(VAR, &VAR)); VAR(VAR(VAR), ""VAR/VAR/VAR\\VAR\VAR\VAR\VAR""); VAR(VAR(VAR), VAR); VAR(VAR(VAR), 0); VAR(VAR, VAR(VAR), VAR); VAR(20, VAR(VAR)); VAR(19, VAR(VAR));",7
linux_50b5d6ad63821cea324a5a7a19854d4de1a0a819,net/sctp/input.c,"	if (sock_owned_by_user(sk)) {
		if (timer_pending(&t->proto_unreach_timer))
			return;
		else {
			if (!mod_timer(&t->proto_unreach_timer,
						jiffies + (HZ/20)))
				sctp_association_hold(asoc);
		}

	} else {
		if (timer_pending(&t->proto_unreach_timer) &&
		    del_timer(&t->proto_unreach_timer))
			sctp_association_put(asoc);
		sctp_do_sm(SCTP_EVENT_T_OTHER,
			   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),
			   asoc->state, asoc->ep, asoc, t,
			   GFP_ATOMIC);
	}","	sctp_do_sm(SCTP_EVENT_T_OTHER,
		   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),
		   asoc->state, asoc->ep, asoc, t,
		   GFP_ATOMIC);",50b5d6ad63821cea324a5a7a19854d4de1a0a819,CVE-2010-4526,50b5d6ad63821cea324a5a7a19854d4de1a0a819,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,98,COMPLETED,"VAR (VAR(VAR)) { VAR (VAR(&VAR->VAR)) VAR; VAR { VAR (!VAR(&VAR->VAR, VAR + (VAR/20))) VAR(VAR); } } VAR { VAR (VAR(&VAR->VAR) && VAR(&VAR->VAR)) VAR(VAR); VAR(VAR, VAR(VAR), VAR->VAR, VAR->VAR, VAR, VAR, VAR); } VAR(VAR, VAR(VAR), VAR->VAR, VAR->VAR, VAR, VAR, VAR);",7
linux_50b5d6ad63821cea324a5a7a19854d4de1a0a819,net/sctp/sm_sideeffect.c,"/* Handle the timeout of the ICMP protocol unreachable timer.  Trigger
 * the correct state machine transition that will close the association.
 */
void sctp_generate_proto_unreach_event(unsigned long data)
{
	struct sctp_transport *transport = (struct sctp_transport *) data;
	struct sctp_association *asoc = transport->asoc;

	sctp_bh_lock_sock(asoc->base.sk);
	if (sock_owned_by_user(asoc->base.sk)) {
		SCTP_DEBUG_PRINTK(""%s:Sock is busy.\n"", __func__);

		/* Try again later.  */
		if (!mod_timer(&transport->proto_unreach_timer,
				jiffies + (HZ/20)))
			sctp_association_hold(asoc);
		goto out_unlock;
	}

	/* Is this structure just waiting around for us to actually
	 * get destroyed?
	 */
	if (asoc->base.dead)
		goto out_unlock;

	sctp_do_sm(SCTP_EVENT_T_OTHER,
		   SCTP_ST_OTHER(SCTP_EVENT_ICMP_PROTO_UNREACH),
		   asoc->state, asoc->ep, asoc, transport, GFP_ATOMIC);

out_unlock:
	sctp_bh_unlock_sock(asoc->base.sk);
	sctp_association_put(asoc);
}

",,50b5d6ad63821cea324a5a7a19854d4de1a0a819,CVE-2010-4526,50b5d6ad63821cea324a5a7a19854d4de1a0a819,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,98,COMPLETED,"/* VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR(VAR VAR VAR) { VAR VAR *VAR = (VAR VAR *) VAR; VAR VAR *VAR = VAR->VAR; VAR(VAR->VAR.VAR); VAR (VAR(VAR->VAR.VAR)) { VAR(""%VAR:VAR VAR VAR.\VAR"", VAR);  VAR (!VAR(&VAR->VAR, VAR + (VAR/20))) VAR(VAR); VAR VAR; } /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR? */ VAR (VAR->VAR.VAR) VAR VAR; VAR(VAR, VAR(VAR), VAR->VAR, VAR->VAR, VAR, VAR, VAR); VAR: VAR(VAR->VAR.VAR); VAR(VAR); } ",7
linux_5f2f97656ada8d811d3c1bef503ced266fcd53a0,net/rxrpc/key.c,"	unsigned int toklen = *_toklen, n_parts, loop, tmp, paddedlen;
		paddedlen = (tmp + 3) & ~3;
		if (paddedlen > toklen)
		toklen -= paddedlen;
		xdr += paddedlen >> 2;
	paddedlen = (tmp + 3) & ~3;
	if (paddedlen > toklen)
	toklen -= paddedlen;
	xdr += paddedlen >> 2;
	unsigned int toklen = *_toklen, len, paddedlen;
	paddedlen = (len + 3) & ~3;
	if (paddedlen > toklen)
		return -EINVAL;
		toklen -= paddedlen;
		xdr += paddedlen >> 2;
	unsigned int toklen = *_toklen, len, paddedlen;
	paddedlen = (len + 3) & ~3;
	if (paddedlen > toklen)
		return -EINVAL;
		toklen -= paddedlen;
		xdr += paddedlen >> 2;
	unsigned int len, paddedlen, loop, ntoken, toklen, sec_ix;
	paddedlen = (len + 3) & ~3;
	if (paddedlen > datalen)
	for (; loop < paddedlen; loop++)
		if (cp[loop])
			goto not_xdr;
	       len, paddedlen, len, len, (const char *) xdr);
	datalen -= paddedlen;
	xdr += paddedlen >> 2;
		paddedlen = (toklen + 3) & ~3;
		if (toklen < 20 || toklen > datalen || paddedlen > datalen)
		datalen -= paddedlen;
		xdr += paddedlen >> 2;","	unsigned int toklen = *_toklen, n_parts, loop, tmp;
		if (tmp > toklen)
		tmp = (tmp + 3) & ~3;
		toklen -= tmp;
		xdr += tmp >> 2;
	if (tmp > toklen)
	tmp = (tmp + 3) & ~3;
	toklen -= tmp;
	xdr += tmp >> 2;
	unsigned int toklen = *_toklen, len;
		len = (len + 3) & ~3;
		toklen -= len;
		xdr += len >> 2;
	unsigned int toklen = *_toklen, len;
		len = (len + 3) & ~3;
		toklen -= len;
		xdr += len >> 2;
	unsigned int len, tmp, loop, ntoken, toklen, sec_ix;
	tmp = (len + 3) & ~3;
	if (tmp > datalen)
	if (len < tmp)
		for (; loop < tmp; loop++)
			if (cp[loop])
				goto not_xdr;
	       len, tmp, len, len, (const char *) xdr);
	datalen -= tmp;
	xdr += tmp >> 2;
		if (toklen < 20 || toklen > datalen)
		datalen -= (toklen + 3) & ~3;
		xdr += (toklen + 3) >> 2;",5f2f97656ada8d811d3c1bef503ced266fcd53a0,CVE-2017-7482,5f2f97656ada8d811d3c1bef503ced266fcd53a0,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,152,COMPLETED,"VAR VAR VAR = *VAR, VAR, VAR, VAR, VAR; VAR = (VAR + 3) & ~3; VAR (VAR > VAR) VAR -= VAR; VAR += VAR >> 2; VAR = (VAR + 3) & ~3; VAR (VAR > VAR) VAR -= VAR; VAR += VAR >> 2; VAR VAR VAR = *VAR, VAR, VAR; VAR = (VAR + 3) & ~3; VAR (VAR > VAR) VAR -VAR; VAR -= VAR; VAR += VAR >> 2; VAR VAR VAR = *VAR, VAR, VAR; VAR = (VAR + 3) & ~3; VAR (VAR > VAR) VAR -VAR; VAR -= VAR; VAR += VAR >> 2; VAR VAR VAR, VAR, VAR, VAR, VAR, VAR; VAR = (VAR + 3) & ~3; VAR (VAR > VAR) VAR (; VAR < VAR; VAR++) VAR (VAR[VAR]) VAR VAR; VAR, VAR, VAR, VAR, (VAR VAR *) VAR); VAR -= VAR; VAR += VAR >> 2; VAR = (VAR + 3) & ~3; VAR (VAR < 20 || VAR > VAR || VAR > VAR) VAR -= VAR; VAR += VAR >> 2; VAR VAR VAR = *VAR, VAR, VAR, VAR; VAR (VAR > VAR) VAR = (VAR + 3) & ~3; VAR -= VAR; VAR += VAR >> 2; VAR (VAR > VAR) VAR = (VAR + 3) & ~3; VAR -= VAR; VAR += VAR >> 2; VAR VAR VAR = *VAR, VAR; VAR = (VAR + 3) & ~3; VAR -= VAR; VAR += VAR >> 2; VAR VAR VAR = *VAR, VAR; VAR = (VAR + 3) & ~3; VAR -= VAR; VAR += VAR >> 2; VAR VAR VAR, VAR, VAR, VAR, VAR, VAR; VAR = (VAR + 3) & ~3; VAR (VAR > VAR) VAR (VAR < VAR) VAR (; VAR < VAR; VAR++) VAR (VAR[VAR]) VAR VAR; VAR, VAR, VAR, VAR, (VAR VAR *) VAR); VAR -= VAR; VAR += VAR >> 2; VAR (VAR < 20 || VAR > VAR) VAR -= (VAR + 3) & ~3; VAR += (VAR + 3) >> 2;",7
linux_67de956ff5dc1d4f321e16cfbd63f5be3b691b43,net/nfc/nci/ntf.c,"	nfca_poll->nfcid1_len = min_t(__u8, *data++, NFC_NFCID1_MAXSIZE);
	nfcb_poll->sensb_res_len = min_t(__u8, *data++, NFC_SENSB_RES_MAXSIZE);
	nfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);
		nfca_poll->rats_res_len = min_t(__u8, *data++, 20);
		nfcb_poll->attrib_res_len = min_t(__u8, *data++, 50);","	nfca_poll->nfcid1_len = *data++;
	nfcb_poll->sensb_res_len = *data++;
	nfcf_poll->sensf_res_len = *data++;
		nfca_poll->rats_res_len = *data++;
		nfcb_poll->attrib_res_len = *data++;",67de956ff5dc1d4f321e16cfbd63f5be3b691b43,CVE-2012-3364,67de956ff5dc1d4f321e16cfbd63f5be3b691b43,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR->VAR = VAR(VAR, *VAR++, VAR); VAR->VAR = VAR(VAR, *VAR++, VAR); VAR->VAR = VAR(VAR, *VAR++, VAR); VAR->VAR = VAR(VAR, *VAR++, 20); VAR->VAR = VAR(VAR, *VAR++, 50); VAR->VAR = *VAR++; VAR->VAR = *VAR++; VAR->VAR = *VAR++; VAR->VAR = *VAR++; VAR->VAR = *VAR++;",7
linux_7d63fb3af87aa67aa7d24466e792f9d7c57d8e79,kernel/dma/swiotlb.c,"#define pr_fmt(fmt) ""software IO TLB: "" fmt

		pr_warn(""No low mem\n"");
	pr_info(""mapped [mem %#010llx-%#010llx] (%luMB)\n"",
	       bytes >> 20);
	pr_warn(""Cannot allocate buffer"");
		pr_warn(""only able to allocate %ld MB\n"",
			(PAGE_SIZE << order) >> 20);","	unsigned char *vstart, *vend;
		pr_warn(""software IO TLB: No low mem\n"");
	vstart = phys_to_virt(io_tlb_start);
	vend = phys_to_virt(io_tlb_end);

	printk(KERN_INFO ""software IO TLB [mem %#010llx-%#010llx] (%luMB) mapped at [%p-%p]\n"",
	       bytes >> 20, vstart, vend - 1);
	pr_warn(""Cannot allocate SWIOTLB buffer"");
		printk(KERN_WARNING ""Warning: only able to allocate %ld MB ""
		       ""for software IO TLB\n"", (PAGE_SIZE << order) >> 20);",7d63fb3af87aa67aa7d24466e792f9d7c57d8e79,CVE-2018-5953,7d63fb3af87aa67aa7d24466e792f9d7c57d8e79,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED," VAR(""VAR VAR VAR\VAR""); VAR(""VAR [VAR % VAR >> 20); VAR(""VAR VAR VAR""); VAR(""VAR VAR VAR VAR %VAR VAR\VAR"", (VAR << VAR) >> 20); VAR VAR *VAR, *VAR; VAR(""VAR VAR VAR: VAR VAR VAR\VAR""); VAR = VAR(VAR); VAR = VAR(VAR); VAR(VAR ""VAR VAR VAR [VAR % VAR >> 20, VAR, VAR - 1); VAR(""VAR VAR VAR VAR""); VAR(VAR ""VAR: VAR VAR VAR VAR %VAR VAR "" ""VAR VAR VAR VAR\VAR"", (VAR << VAR) >> 20);",7
linux_9f260e0efa4766e56d0ac14f1aeea6ee5eb8fe83,net/can/bcm.c,"	char procname [32]; /* inode number in decimal with \0 */
		sprintf(bo->procname, ""%lu"", sock_i_ino(sk));","	char procname [20]; /* pointer printed in ASCII with \0 */
		sprintf(bo->procname, ""%p"", sock);",9f260e0efa4766e56d0ac14f1aeea6ee5eb8fe83,CVE-2010-4565,9f260e0efa4766e56d0ac14f1aeea6ee5eb8fe83,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,140,COMPLETED,"VAR VAR [32];  VAR(VAR->VAR, ""%VAR"", VAR(VAR)); VAR VAR [20];  VAR(VAR->VAR, ""%VAR"", VAR);",7
linux_be20250c13f88375345ad99950190685eda51eb8,net/rose/rose_subr.c,"					if (pt[6] & AX25_HBIT) {
						if (facilities->dest_ndigis >= ROSE_MAX_DIGIS)
							return -1;
					} else {
						if (facilities->source_ndigis >= ROSE_MAX_DIGIS)
							return -1;
					}

			/* Prevent overflows*/
			if (l < 10 || l > 20)
				return -1;

				if (len < 0)
					return 0;
				if (len < 0)
					return 0;","					if (pt[6] & AX25_HBIT)
					else",be20250c13f88375345ad99950190685eda51eb8,CVE-2011-4913,be20250c13f88375345ad99950190685eda51eb8,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR (VAR[6] & VAR) { VAR (VAR->VAR >= VAR) VAR -1; } VAR { VAR (VAR->VAR >= VAR) VAR -1; }  VAR (VAR < 10 || VAR > 20) VAR -1; VAR (VAR < 0) VAR 0; VAR (VAR < 0) VAR 0; VAR (VAR[6] & VAR) VAR,7
linux_be20250c13f88375345ad99950190685eda51eb8,net/rose/rose_subr.c,"					if (pt[6] & AX25_HBIT) {
						if (facilities->dest_ndigis >= ROSE_MAX_DIGIS)
							return -1;
					} else {
						if (facilities->source_ndigis >= ROSE_MAX_DIGIS)
							return -1;
					}

			/* Prevent overflows*/
			if (l < 10 || l > 20)
				return -1;

				if (len < 0)
					return 0;
				if (len < 0)
					return 0;","					if (pt[6] & AX25_HBIT)
					else",be20250c13f88375345ad99950190685eda51eb8,CVE-2011-1493,be20250c13f88375345ad99950190685eda51eb8,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR (VAR[6] & VAR) { VAR (VAR->VAR >= VAR) VAR -1; } VAR { VAR (VAR->VAR >= VAR) VAR -1; }  VAR (VAR < 10 || VAR > 20) VAR -1; VAR (VAR < 0) VAR 0; VAR (VAR < 0) VAR 0; VAR (VAR[6] & VAR) VAR,7
linux_bfeffd155283772bbe78c6a05dec7c0128ee500c,Makefile,"VERSION = 5
PATCHLEVEL = 0
EXTRAVERSION = -rc1","VERSION = 4
PATCHLEVEL = 20
EXTRAVERSION =",bfeffd155283772bbe78c6a05dec7c0128ee500c,CVE-2019-15927,bfeffd155283772bbe78c6a05dec7c0128ee500c,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,68,COMPLETED,VAR = 5 VAR = 0 VAR = -VAR VAR = 4 VAR = 20 VAR =,7
linux_f1e255d60ae66a9f672ff9a207ee6cd8e33d2679,drivers/usmisc/yurex.c,"	int len = 0;
		mutex_unlock(&dev->io_mutex);
		return -ENODEV;
	len = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu);

	return simple_read_from_buffer(buffer, count, ppos, in_buffer, len);","	int retval = 0;
	int bytes_read = 0;
		retval = -ENODEV;
		goto exit;
	bytes_read = snprintf(in_buffer, 20, ""%lld\n"", dev->bbu);

	if (*ppos < bytes_read) {
		if (copy_to_user(buffer, in_buffer + *ppos, bytes_read - *ppos))
			retval = -EFAULT;
		else {
			retval = bytes_read - *ppos;
			*ppos += bytes_read;
		}
	}

exit:
	return retval;",f1e255d60ae66a9f672ff9a207ee6cd8e33d2679,CVE-2018-16276,f1e255d60ae66a9f672ff9a207ee6cd8e33d2679,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = 0; VAR(&VAR->VAR); VAR -VAR; VAR = VAR(VAR, 20, ""%VAR\VAR"", VAR->VAR); VAR VAR(VAR, VAR, VAR, VAR, VAR); VAR VAR = 0; VAR VAR = 0; VAR = -VAR; VAR VAR; VAR = VAR(VAR, 20, ""%VAR\VAR"", VAR->VAR); VAR (*VAR < VAR) { VAR (VAR(VAR, VAR + *VAR, VAR - *VAR)) VAR = -VAR; VAR { VAR = VAR - *VAR; *VAR += VAR; } } VAR: VAR VAR;",7
moodle_ea106d2a1dbc633a22f12a119763b2af5f33542b,admin/tool/monitor/tests/subscription_test.php,"<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.
defined('MOODLE_INTERNAL') || exit();

/**
 * Unit tests for the subscription class.
 * @since 3.2.0
 *
 * @package    tool_monitor
 * @category   test
 * @copyright  2016 Jake Dallimore <jrhdallimore@gmail.com>
 * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */
class tool_monitor_subscription_testcase extends advanced_testcase {

    /**
     * @var \tool_monitor\subscription $subscription object.
     */
    private $subscription;

    /**
     * Test set up.
     */
    public function setUp() {
        $this->resetAfterTest(true);

        // Create the mock subscription.
        $sub = new stdClass();
        $sub->id = 100;
        $sub->name = 'My test rule';
        $sub->courseid = 20;
        $this->subscription = $this->getMock('\tool_monitor\subscription',null, array($sub));
    }

    /**
     * Test for the magic __isset method.
     */
    public function test_magic_isset() {
        $this->assertEquals(true, isset($this->subscription->name));
        $this->assertEquals(true, isset($this->subscription->courseid));
        $this->assertEquals(false, isset($this->subscription->ruleid));
    }

    /**
     * Test for the magic __get method.
     */
    public function test_magic_get() {
        $this->assertEquals(20, $this->subscription->courseid);
        $this->setExpectedException('coding_exception');
        $this->subscription->ruleid;
    }
}",,ea106d2a1dbc633a22f12a119763b2af5f33542b,CVE-2016-5014,ea106d2a1dbc633a22f12a119763b2af5f33542b,https://github.com/moodle/moodle,GHSD_DIRECT_COMMIT,1337,COMPLETED,"<?VAR               VAR('VAR') || VAR(); /** * VAR VAR VAR VAR VAR VAR. * @VAR 3.2.0 * * @VAR VAR * @VAR VAR * @VAR 2016 VAR VAR <VAR@VAR.VAR> * @VAR VAR: */ VAR VAR VAR VAR { /** * @VAR \VAR\VAR $VAR VAR. */ VAR $VAR; /** * VAR VAR VAR. */ VAR VAR VAR() { $VAR->VAR(VAR);  $VAR = VAR VAR(); $VAR->VAR = 100; $VAR->VAR = 'VAR VAR VAR'; $VAR->VAR = 20; $VAR->VAR = $VAR->VAR('\VAR\VAR',VAR, VAR($VAR)); } /** * VAR VAR VAR VAR VAR VAR. */ VAR VAR VAR() { $VAR->VAR(VAR, VAR($VAR->VAR->VAR)); $VAR->VAR(VAR, VAR($VAR->VAR->VAR)); $VAR->VAR(VAR, VAR($VAR->VAR->VAR)); } /** * VAR VAR VAR VAR VAR VAR. */ VAR VAR VAR() { $VAR->VAR(20, $VAR->VAR->VAR); $VAR->VAR('VAR'); $VAR->VAR->VAR; } } ",7
roundcubemail_a71bf2e8d4a64ff2c83fdabc1e8cb0c045a41ef4,tests/Framework/Washtml.php,"     * Test cases for SVG tests
    function data_wash_svg_tests()
        $svg1 = ""<svg id='x' width='100' height='100'><a xlink:href='javascript:alert(1)'><rect x='0' y='0' width='100' height='100' /></a></svg>"";

        return [
            [
                '<head xmlns=""&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;""><svg></svg></head>',
                '<!-- html ignored --><!-- head ignored --><svg xmlns=""http://www.w3.org/1999/xhtml""></svg>'
            ],
            [
                '<head xmlns=""&quot; onload=&quot;alert(document.domain)"">Hello victim!<svg></svg></head>',
                '<!-- html ignored --><!-- head ignored -->Hello victim!<svg xmlns=""http://www.w3.org/1999/xhtml""></svg>'
            ],
            [
                '<p>Hello victim!<svg xmlns=""&quot; onload=&quot;alert(document.domain)""></svg></p>',
                '<p>Hello victim!<svg /></p>'
            ],
            [
                '<html><p>Hello victim!<svg xmlns=""&quot; onload=&quot;alert(document.domain)""></svg></p>',
                '<!-- html ignored --><!-- body ignored --><p>Hello victim!<svg xmlns=""http://www.w3.org/1999/xhtml""></svg></p>'
            ],
            [
                '<svg xmlns=""&quot; onload=&quot;alert(document.domain)"" />',
                '<svg xmlns=""&quot; onload=&quot;alert(document.domain)"" />'
            ],
            [
                '<html><svg xmlns=""&quot; onload=&quot;alert(document.domain)"" />',
                '<!-- html ignored --><!-- body ignored --><svg xmlns=""http://www.w3.org/1999/xhtml""></svg>'
            ],
            [
                '<svg><a xlink:href=""javascript:alert(1)""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<svg><a x-washed=""xlink:href""><text x=""20"" y=""20"">XSS</text></a></svg>'
            ],
            [
                '<html><svg><a xlink:href=""javascript:alert(1)""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<!-- html ignored --><!-- body ignored --><svg xmlns=""http://www.w3.org/1999/xhtml""><a x-washed=""xlink:href""><text x=""20"" y=""20"">XSS</text></a></svg>'
            ],
            [
                '<svg><animate xlink:href=""#xss"" attributeName=""href"" values=""javascript:alert(1)"" />'
                    . '<a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<svg><!-- animate blocked --><a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
            ],
            [
                '<html><svg><animate xlink:href=""#xss"" attributeName=""href"" values=""javascript:alert(1)"" />'
                    . '<a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<!-- html ignored --><!-- body ignored --><svg xmlns=""http://www.w3.org/1999/xhtml"">'
                    . '<!-- animate blocked --><a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
            ],
            [
                '<svg><animate xlink:href=""#xss"" attributeName=""href"" from=""javascript:alert(1)"" to=""1"" />'
                    . '<a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<svg><!-- animate blocked --><a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
            ],
            [
                '<svg><set xlink:href=""#xss"" attributeName=""href"" from=""?"" to=""javascript:alert(1)"" />'
                    . '<a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<svg><!-- set blocked --><a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
            ],
            [
                '<svg><animate xlink:href=""#xss"" attributename=""href"" dur=""5s"" repeatCount=""indefinite"" keytimes=""0;0;1"" values=""https://portswigger.net?;javascript:alert(1);0"" />'
                    . '<a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<svg><!-- animate blocked --><a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
            ],
            [
                ""<svg><use href=\""data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' ""
                    . ""xmlns:xlink='http://www.w3.org/1999/xlink' width='100' height='100'&gt;&lt;a xlink:href='javascript:alert(1)'&gt;""
                    . ""&lt;rect x='0' y='0' width='100' height='100' /&gt;&lt;/a&gt;&lt;/svg&gt;\""></use></svg>"",
                ""<svg><use href=\""data:image/svg+xml;base64,PHN2ZyB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53""
                    . ""My5vcmcvMTk5OS94bGluayIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBpZD0ie""
                    . ""CIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjxhIHgtd2FzaGVkPSJ4bGluazpocmVmIj48cmVjdC""
                    . ""B4PSIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgLz48L2E+PC9zdmc+\"" /></svg>""
            ],
            [
                ""<svg><use href=\""data:image/svg+xml;base64,"" . base64_encode($svg1) . ""\""></use></svg>"",
                ""<svg><use href=\""data:image/svg+xml;base64,PHN2ZyBpZD0ieCIgd2lkdGg9IjEwMCIgaGVpZ2h""
                    . ""0PSIxMDAiPjxhIHgtd2FzaGVkPSJ4bGluazpocmVmIj48cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0""
                    . ""iMTAwIiBoZWlnaHQ9IjEwMCIgLz48L2E+PC9zdmc+\"" /></svg>""
            ],
            [
                '<svg><script href=""data:text/javascript,alert(1)"" /><text x=""20"" y=""20"">XSS</text></svg>',
                '<svg><!-- script not allowed --><text x=""20"" y=""20"">XSS</text></svg>'
            ],
        ];
    }
    /**
     * Test SVG cleanup
     *
     * @dataProvider data_wash_svg_tests
     */
    function test_wash_svg_tests($input, $expected)
    {
        $washed = $washer->wash($input);
        $this->assertSame($expected, $washed, ""SVG content"");
    }
    /**
     * Test cases for various XSS issues
     */
    function data_wash_xss_tests()
    {
        return [
            [
                '<html><base href=""javascript:/a/-alert(1)///////""><a href=""../lol/safari.html"">test</a>',
                '<!-- html ignored --><body><!-- base ignored --><a x-washed=""href"">test</a></body>'
            ],
            [
                '<html><math><x href=""javascript:alert(1)"">blah</x>',
                '<!-- html ignored --><body><math><!-- x ignored -->blah</math></body>'
            ],
            [
                '<html><a href=""j&#x61vascript:alert(1)"">XSS</a>',
                '<!-- html ignored --><body><a x-washed=""href"">XSS</a></body>'
            ],
            [
                '<html><a href=""&#x6a avascript:alert(1)"">XSS</a>',
                '<!-- html ignored --><body><a x-washed=""href"">XSS</a></body>'
            ],
            [
                '<html><a href=""&#x6a avascript:alert(1)"">XSS</a>',
                '<!-- html ignored --><body><a x-washed=""href"">XSS</a></body>'
            ],
            [
                '<html><body background=""javascript:alert(1)"">',
                '<!-- html ignored --><body x-washed=""background""></body>'
            ],
            [
                '<html><math href=""javascript:alert(location);""><mi>clickme</mi></math>',
                '<!-- html ignored --><body><math x-washed=""href""><mi>clickme</mi></math></body>',
            ],
            [
                '<html><math><mstyle href=""javascript:alert(location);""><mi>clickme</mi></mstyle></math>',
                '<!-- html ignored --><body><math><mstyle x-washed=""href""><mi>clickme</mi></mstyle></math></body>',
            ],
            [
                '<html><math><msubsup href=""javascript:alert(location);""><mi>clickme</mi></msubsup></math>',
                '<!-- html ignored --><body><math><msubsup x-washed=""href""><mi>clickme</mi></msubsup></math></body>',
            ],
            [
                '<html><math><ms HREF=""javascript:alert(location);"">clickme</ms></math>',
                '<!-- html ignored --><body><math><ms x-washed=""href"">clickme</ms></math></body>',
            ],
        ];
    }
    /**
     * Test various XSS issues
     *
     * @dataProvider data_wash_xss_tests
     */
    function test_wash_xss_tests($input, $expected)
    {
        $washer = new rcube_washtml(['allow_remote' => true, 'html_elements' => ['body']]);
        $washed = $washer->wash($input);
        $this->assertSame($expected, $washed, ""XSS issues"");","     * Test SVG cleanup
    function test_wash_svg2()
        $svg = '<head xmlns=""&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;""><svg></svg></head>';
        $exp = '<!-- html ignored --><!-- head ignored --><svg xmlns=""http://www.w3.org/1999/xhtml""></svg>';

        $washer = new rcube_washtml;
        $washed = $washer->wash($svg);

        $this->assertSame($washed, $exp, ""SVG content"");

        $svg = '<head xmlns=""&quot; onload=&quot;alert(document.domain)"">Hello victim!<svg></svg></head>';
        $exp = '<!-- html ignored --><!-- head ignored -->Hello victim!<svg xmlns=""http://www.w3.org/1999/xhtml""></svg>';

        $washer = new rcube_washtml;
        $washed = $washer->wash($svg);

        $this->assertSame($washed, $exp, ""SVG content"");

        $svg = '<p>Hello victim!<svg xmlns=""&quot; onload=&quot;alert(document.domain)""></svg></p>';
        $exp = '<p>Hello victim!<svg /></p>';
        $washed = $washer->wash($svg);
        $this->assertSame($washed, $exp, ""SVG content"");
        $svg = '<svg xmlns=""&quot; onload=&quot;alert(document.domain)"" />';
        $exp = '<svg xmlns=""&quot; onload=&quot;alert(document.domain)"" />';
        $washer = new rcube_washtml;
        $washed = $washer->wash($svg);
        $this->assertSame($washed, $exp, ""SVG content"");",a71bf2e8d4a64ff2c83fdabc1e8cb0c045a41ef4,CVE-2020-16145,a71bf2e8d4a64ff2c83fdabc1e8cb0c045a41ef4,https://github.com/roundcube/roundcubemail,NVD_DIRECT_COMMIT,1337,COMPLETED,"* VAR VAR VAR VAR VAR VAR VAR() $VAR = ""<VAR VAR='VAR' VAR='100' VAR='100'><VAR VAR:VAR='VAR:VAR(1)'><VAR VAR='0' VAR='0' VAR='100' VAR='100' /></VAR></VAR>""; VAR [ [ '<VAR VAR=""&VAR;&VAR;&VAR;VAR&VAR;VAR(VAR.VAR)&VAR;/VAR&VAR;""><VAR></VAR></VAR>', '<!-- VAR VAR --><!-- VAR VAR --><VAR VAR=""VAR: ], [ '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"">VAR VAR!<VAR></VAR></VAR>', '<!-- VAR VAR --><!-- VAR VAR -->VAR VAR!<VAR VAR=""VAR: ], [ '<VAR>VAR VAR!<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)""></VAR></VAR>', '<VAR>VAR VAR!<VAR /></VAR>' ], [ '<VAR><VAR>VAR VAR!<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)""></VAR></VAR>', '<!-- VAR VAR --><!-- VAR VAR --><VAR>VAR VAR!<VAR VAR=""VAR: ], [ '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"" />', '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"" />' ], [ '<VAR><VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"" />', '<!-- VAR VAR --><!-- VAR VAR --><VAR VAR=""VAR: ], [ '<VAR><VAR VAR:VAR=""VAR:VAR(1)""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<VAR><VAR VAR-VAR=""VAR:VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>' ], [ '<VAR><VAR><VAR VAR:VAR=""VAR:VAR(1)""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<!-- VAR VAR --><!-- VAR VAR --><VAR VAR=""VAR: ], [ '<VAR><VAR VAR:VAR="" . '<VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<VAR><!-- VAR VAR --><VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', ], [ '<VAR><VAR><VAR VAR:VAR="" . '<VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<!-- VAR VAR --><!-- VAR VAR --><VAR VAR=""VAR: . '<!-- VAR VAR --><VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', ], [ '<VAR><VAR VAR:VAR="" . '<VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<VAR><!-- VAR VAR --><VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', ], [ '<VAR><VAR VAR:VAR="" . '<VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<VAR><!-- VAR VAR --><VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', ], [ '<VAR><VAR VAR:VAR="" . '<VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<VAR><!-- VAR VAR --><VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', ], [ ""<VAR><VAR VAR=\""VAR:VAR/VAR+VAR,&VAR;VAR VAR='VAR' VAR='VAR: . ""VAR:VAR='VAR: . ""&VAR;VAR VAR='0' VAR='0' VAR='100' VAR='100' /&VAR;&VAR;/VAR&VAR;&VAR;/VAR&VAR;\""></VAR></VAR>"", ""<VAR><VAR VAR=\""VAR:VAR/VAR+VAR;VAR,VAR"" . ""VAR"" . ""VAR"" . ""VAR+VAR+\"" /></VAR>"" ], [ ""<VAR><VAR VAR=\""VAR:VAR/VAR+VAR;VAR,"" . VAR($VAR) . ""\""></VAR></VAR>"", ""<VAR><VAR VAR=\""VAR:VAR/VAR+VAR;VAR,VAR"" . ""0PSIxMDAiPjxhIHgtd2FzaGVkPSJ4bGluazpocmVmIj48cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0"" . ""VAR+VAR+\"" /></VAR>"" ], [ '<VAR><VAR VAR=""VAR:VAR/VAR,VAR(1)"" /><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR>', '<VAR><!-- VAR VAR VAR --><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR>' ], ]; } /** * VAR VAR VAR * * @VAR VAR */ VAR VAR($VAR, $VAR) { $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR""); } /** * VAR VAR VAR VAR VAR VAR */ VAR VAR() { VAR [ [ '<VAR><VAR VAR=""VAR:/VAR/-VAR(1) '<!-- VAR VAR --><VAR><!-- VAR VAR --><VAR VAR-VAR=""VAR"">VAR</VAR></VAR>' ], [ '<VAR><VAR><VAR VAR=""VAR:VAR(1)"">VAR</VAR>', '<!-- VAR VAR --><VAR><VAR><!-- VAR VAR -->VAR</VAR></VAR>' ], [ '<VAR><VAR VAR=""VAR& '<!-- VAR VAR --><VAR><VAR VAR-VAR=""VAR"">VAR</VAR></VAR>' ], [ '<VAR><VAR VAR=""& '<!-- VAR VAR --><VAR><VAR VAR-VAR=""VAR"">VAR</VAR></VAR>' ], [ '<VAR><VAR VAR=""& '<!-- VAR VAR --><VAR><VAR VAR-VAR=""VAR"">VAR</VAR></VAR>' ], [ '<VAR><VAR VAR=""VAR:VAR(1)"">', '<!-- VAR VAR --><VAR VAR-VAR=""VAR""></VAR>' ], [ '<VAR><VAR VAR=""VAR:VAR(VAR);""><VAR>VAR</VAR></VAR>', '<!-- VAR VAR --><VAR><VAR VAR-VAR=""VAR""><VAR>VAR</VAR></VAR></VAR>', ], [ '<VAR><VAR><VAR VAR=""VAR:VAR(VAR);""><VAR>VAR</VAR></VAR></VAR>', '<!-- VAR VAR --><VAR><VAR><VAR VAR-VAR=""VAR""><VAR>VAR</VAR></VAR></VAR></VAR>', ], [ '<VAR><VAR><VAR VAR=""VAR:VAR(VAR);""><VAR>VAR</VAR></VAR></VAR>', '<!-- VAR VAR --><VAR><VAR><VAR VAR-VAR=""VAR""><VAR>VAR</VAR></VAR></VAR></VAR>', ], [ '<VAR><VAR><VAR VAR=""VAR:VAR(VAR);"">VAR</VAR></VAR>', '<!-- VAR VAR --><VAR><VAR><VAR VAR-VAR=""VAR"">VAR</VAR></VAR></VAR>', ], ]; } /** * VAR VAR VAR VAR * * @VAR VAR */ VAR VAR($VAR, $VAR) { $VAR = VAR VAR(['VAR' => VAR, 'VAR' => ['VAR']]); $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR""); * VAR VAR VAR VAR VAR() $VAR = '<VAR VAR=""&VAR;&VAR;&VAR;VAR&VAR;VAR(VAR.VAR)&VAR;/VAR&VAR;""><VAR></VAR></VAR>'; $VAR = '<!-- VAR VAR --><!-- VAR VAR --><VAR VAR=""VAR: $VAR = VAR VAR; $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR""); $VAR = '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"">VAR VAR!<VAR></VAR></VAR>'; $VAR = '<!-- VAR VAR --><!-- VAR VAR -->VAR VAR!<VAR VAR=""VAR: $VAR = VAR VAR; $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR""); $VAR = '<VAR>VAR VAR!<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)""></VAR></VAR>'; $VAR = '<VAR>VAR VAR!<VAR /></VAR>'; $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR""); $VAR = '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"" />'; $VAR = '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"" />'; $VAR = VAR VAR; $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR"");",7
roundcubemail_d44ca2308a96576b88d6bf27528964d4fe1a6b8b,tests/Framework/Washtml.php,"     * Test cases for SVG tests
    function data_wash_svg_tests()
        $svg1 = ""<svg id='x' width='100' height='100'><a xlink:href='javascript:alert(1)'><rect x='0' y='0' width='100' height='100' /></a></svg>"";

        return [
            [
                '<head xmlns=""&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;""><svg></svg></head>',
                '<!-- html ignored --><!-- head ignored --><svg xmlns=""http://www.w3.org/1999/xhtml""></svg>'
            ],
            [
                '<head xmlns=""&quot; onload=&quot;alert(document.domain)"">Hello victim!<svg></svg></head>',
                '<!-- html ignored --><!-- head ignored -->Hello victim!<svg xmlns=""http://www.w3.org/1999/xhtml""></svg>'
            ],
            [
                '<p>Hello victim!<svg xmlns=""&quot; onload=&quot;alert(document.domain)""></svg></p>',
                '<p>Hello victim!<svg /></p>'
            ],
            [
                '<html><p>Hello victim!<svg xmlns=""&quot; onload=&quot;alert(document.domain)""></svg></p>',
                '<!-- html ignored --><!-- body ignored --><p>Hello victim!<svg xmlns=""http://www.w3.org/1999/xhtml""></svg></p>'
            ],
            [
                '<svg xmlns=""&quot; onload=&quot;alert(document.domain)"" />',
                '<svg xmlns=""&quot; onload=&quot;alert(document.domain)"" />'
            ],
            [
                '<html><svg xmlns=""&quot; onload=&quot;alert(document.domain)"" />',
                '<!-- html ignored --><!-- body ignored --><svg xmlns=""http://www.w3.org/1999/xhtml""></svg>'
            ],
            [
                '<svg><a xlink:href=""javascript:alert(1)""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<svg><a x-washed=""xlink:href""><text x=""20"" y=""20"">XSS</text></a></svg>'
            ],
            [
                '<html><svg><a xlink:href=""javascript:alert(1)""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<!-- html ignored --><!-- body ignored --><svg xmlns=""http://www.w3.org/1999/xhtml""><a x-washed=""xlink:href""><text x=""20"" y=""20"">XSS</text></a></svg>'
            ],
            [
                '<svg><animate xlink:href=""#xss"" attributeName=""href"" values=""javascript:alert(1)"" />'
                    . '<a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<svg><!-- animate blocked --><a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
            ],
            [
                '<html><svg><animate xlink:href=""#xss"" attributeName=""href"" values=""javascript:alert(1)"" />'
                    . '<a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<!-- html ignored --><!-- body ignored --><svg xmlns=""http://www.w3.org/1999/xhtml"">'
                    . '<!-- animate blocked --><a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
            ],
            [
                '<svg><animate xlink:href=""#xss"" attributeName=""href"" from=""javascript:alert(1)"" to=""1"" />'
                    . '<a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<svg><!-- animate blocked --><a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
            ],
            [
                '<svg><set xlink:href=""#xss"" attributeName=""href"" from=""?"" to=""javascript:alert(1)"" />'
                    . '<a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<svg><!-- set blocked --><a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
            ],
            [
                '<svg><animate xlink:href=""#xss"" attributename=""href"" dur=""5s"" repeatCount=""indefinite"" keytimes=""0;0;1"" values=""https://portswigger.net?;javascript:alert(1);0"" />'
                    . '<a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
                '<svg><!-- animate blocked --><a id=""xss""><text x=""20"" y=""20"">XSS</text></a></svg>',
            ],
            [
                ""<svg><use href=\""data:image/svg+xml,&lt;svg id='x' xmlns='http://www.w3.org/2000/svg' ""
                    . ""xmlns:xlink='http://www.w3.org/1999/xlink' width='100' height='100'&gt;&lt;a xlink:href='javascript:alert(1)'&gt;""
                    . ""&lt;rect x='0' y='0' width='100' height='100' /&gt;&lt;/a&gt;&lt;/svg&gt;\""></use></svg>"",
                ""<svg><use href=\""data:image/svg+xml;base64,PHN2ZyB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53""
                    . ""My5vcmcvMTk5OS94bGluayIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBpZD0ie""
                    . ""CIgd2lkdGg9IjEwMCIgaGVpZ2h0PSIxMDAiPjxhIHgtd2FzaGVkPSJ4bGluazpocmVmIj48cmVjdC""
                    . ""B4PSIwIiB5PSIwIiB3aWR0aD0iMTAwIiBoZWlnaHQ9IjEwMCIgLz48L2E+PC9zdmc+\"" /></svg>""
            ],
            [
                ""<svg><use href=\""data:image/svg+xml;base64,"" . base64_encode($svg1) . ""\""></use></svg>"",
                ""<svg><use href=\""data:image/svg+xml;base64,PHN2ZyBpZD0ieCIgd2lkdGg9IjEwMCIgaGVpZ2h""
                    . ""0PSIxMDAiPjxhIHgtd2FzaGVkPSJ4bGluazpocmVmIj48cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0""
                    . ""iMTAwIiBoZWlnaHQ9IjEwMCIgLz48L2E+PC9zdmc+\"" /></svg>""
            ],
            [
                '<svg><script href=""data:text/javascript,alert(1)"" /><text x=""20"" y=""20"">XSS</text></svg>',
                '<svg><!-- script not allowed --><text x=""20"" y=""20"">XSS</text></svg>'
            ],
        ];
    }
    /**
     * Test SVG cleanup
     *
     * @dataProvider data_wash_svg_tests
     */
    function test_wash_svg_tests($input, $expected)
    {
        $washed = $washer->wash($input);
        $this->assertSame($expected, $washed, ""SVG content"");
    }
    /**
     * Test cases for various XSS issues
     */
    function data_wash_xss_tests()
    {
        return [
            [
                '<html><base href=""javascript:/a/-alert(1)///////""><a href=""../lol/safari.html"">test</a>',
                '<!-- html ignored --><body><!-- base ignored --><a x-washed=""href"">test</a></body>'
            ],
            [
                '<html><math><x href=""javascript:alert(1)"">blah</x>',
                '<!-- html ignored --><body><math><!-- x ignored -->blah</math></body>'
            ],
            [
                '<html><a href=""j&#x61vascript:alert(1)"">XSS</a>',
                '<!-- html ignored --><body><a x-washed=""href"">XSS</a></body>'
            ],
            [
                '<html><a href=""&#x6a avascript:alert(1)"">XSS</a>',
                '<!-- html ignored --><body><a x-washed=""href"">XSS</a></body>'
            ],
            [
                '<html><a href=""&#x6a avascript:alert(1)"">XSS</a>',
                '<!-- html ignored --><body><a x-washed=""href"">XSS</a></body>'
            ],
            [
                '<html><body background=""javascript:alert(1)"">',
                '<!-- html ignored --><body x-washed=""background""></body>'
            ],
            [
                '<html><math href=""javascript:alert(location);""><mi>clickme</mi></math>',
                '<!-- html ignored --><body><math x-washed=""href""><mi>clickme</mi></math></body>',
            ],
            [
                '<html><math><mstyle href=""javascript:alert(location);""><mi>clickme</mi></mstyle></math>',
                '<!-- html ignored --><body><math><mstyle x-washed=""href""><mi>clickme</mi></mstyle></math></body>',
            ],
            [
                '<html><math><msubsup href=""javascript:alert(location);""><mi>clickme</mi></msubsup></math>',
                '<!-- html ignored --><body><math><msubsup x-washed=""href""><mi>clickme</mi></msubsup></math></body>',
            ],
            [
                '<html><math><ms HREF=""javascript:alert(location);"">clickme</ms></math>',
                '<!-- html ignored --><body><math><ms x-washed=""href"">clickme</ms></math></body>',
            ],
        ];
    }
    /**
     * Test various XSS issues
     *
     * @dataProvider data_wash_xss_tests
     */
    function test_wash_xss_tests($input, $expected)
    {
        $washer = new rcube_washtml(['allow_remote' => true, 'html_elements' => ['body']]);
        $washed = $washer->wash($input);
        $this->assertSame($expected, $washed, ""XSS issues"");","     * Test SVG cleanup
    function test_wash_svg2()
        $svg = '<head xmlns=""&quot;&gt;&lt;script&gt;alert(document.domain)&lt;/script&gt;""><svg></svg></head>';
        $exp = '<!-- html ignored --><!-- head ignored --><svg xmlns=""http://www.w3.org/1999/xhtml""></svg>';

        $washer = new rcube_washtml;
        $washed = $washer->wash($svg);

        $this->assertSame($washed, $exp, ""SVG content"");

        $svg = '<head xmlns=""&quot; onload=&quot;alert(document.domain)"">Hello victim!<svg></svg></head>';
        $exp = '<!-- html ignored --><!-- head ignored -->Hello victim!<svg xmlns=""http://www.w3.org/1999/xhtml""></svg>';

        $washer = new rcube_washtml;
        $washed = $washer->wash($svg);

        $this->assertSame($washed, $exp, ""SVG content"");

        $svg = '<p>Hello victim!<svg xmlns=""&quot; onload=&quot;alert(document.domain)""></svg></p>';
        $exp = '<p>Hello victim!<svg /></p>';
        $washed = $washer->wash($svg);
        $this->assertSame($washed, $exp, ""SVG content"");
        $svg = '<svg xmlns=""&quot; onload=&quot;alert(document.domain)"" />';
        $exp = '<svg xmlns=""&quot; onload=&quot;alert(document.domain)"" />';
        $washer = new rcube_washtml;
        $washed = $washer->wash($svg);
        $this->assertSame($washed, $exp, ""SVG content"");",d44ca2308a96576b88d6bf27528964d4fe1a6b8b,CVE-2020-16145,d44ca2308a96576b88d6bf27528964d4fe1a6b8b,https://github.com/roundcube/roundcubemail,NVD_DIRECT_COMMIT,1337,COMPLETED,"* VAR VAR VAR VAR VAR VAR VAR() $VAR = ""<VAR VAR='VAR' VAR='100' VAR='100'><VAR VAR:VAR='VAR:VAR(1)'><VAR VAR='0' VAR='0' VAR='100' VAR='100' /></VAR></VAR>""; VAR [ [ '<VAR VAR=""&VAR;&VAR;&VAR;VAR&VAR;VAR(VAR.VAR)&VAR;/VAR&VAR;""><VAR></VAR></VAR>', '<!-- VAR VAR --><!-- VAR VAR --><VAR VAR=""VAR: ], [ '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"">VAR VAR!<VAR></VAR></VAR>', '<!-- VAR VAR --><!-- VAR VAR -->VAR VAR!<VAR VAR=""VAR: ], [ '<VAR>VAR VAR!<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)""></VAR></VAR>', '<VAR>VAR VAR!<VAR /></VAR>' ], [ '<VAR><VAR>VAR VAR!<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)""></VAR></VAR>', '<!-- VAR VAR --><!-- VAR VAR --><VAR>VAR VAR!<VAR VAR=""VAR: ], [ '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"" />', '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"" />' ], [ '<VAR><VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"" />', '<!-- VAR VAR --><!-- VAR VAR --><VAR VAR=""VAR: ], [ '<VAR><VAR VAR:VAR=""VAR:VAR(1)""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<VAR><VAR VAR-VAR=""VAR:VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>' ], [ '<VAR><VAR><VAR VAR:VAR=""VAR:VAR(1)""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<!-- VAR VAR --><!-- VAR VAR --><VAR VAR=""VAR: ], [ '<VAR><VAR VAR:VAR="" . '<VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<VAR><!-- VAR VAR --><VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', ], [ '<VAR><VAR><VAR VAR:VAR="" . '<VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<!-- VAR VAR --><!-- VAR VAR --><VAR VAR=""VAR: . '<!-- VAR VAR --><VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', ], [ '<VAR><VAR VAR:VAR="" . '<VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<VAR><!-- VAR VAR --><VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', ], [ '<VAR><VAR VAR:VAR="" . '<VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<VAR><!-- VAR VAR --><VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', ], [ '<VAR><VAR VAR:VAR="" . '<VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', '<VAR><!-- VAR VAR --><VAR VAR=""VAR""><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR></VAR>', ], [ ""<VAR><VAR VAR=\""VAR:VAR/VAR+VAR,&VAR;VAR VAR='VAR' VAR='VAR: . ""VAR:VAR='VAR: . ""&VAR;VAR VAR='0' VAR='0' VAR='100' VAR='100' /&VAR;&VAR;/VAR&VAR;&VAR;/VAR&VAR;\""></VAR></VAR>"", ""<VAR><VAR VAR=\""VAR:VAR/VAR+VAR;VAR,VAR"" . ""VAR"" . ""VAR"" . ""VAR+VAR+\"" /></VAR>"" ], [ ""<VAR><VAR VAR=\""VAR:VAR/VAR+VAR;VAR,"" . VAR($VAR) . ""\""></VAR></VAR>"", ""<VAR><VAR VAR=\""VAR:VAR/VAR+VAR;VAR,VAR"" . ""0PSIxMDAiPjxhIHgtd2FzaGVkPSJ4bGluazpocmVmIj48cmVjdCB4PSIwIiB5PSIwIiB3aWR0aD0"" . ""VAR+VAR+\"" /></VAR>"" ], [ '<VAR><VAR VAR=""VAR:VAR/VAR,VAR(1)"" /><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR>', '<VAR><!-- VAR VAR VAR --><VAR VAR=""20"" VAR=""20"">VAR</VAR></VAR>' ], ]; } /** * VAR VAR VAR * * @VAR VAR */ VAR VAR($VAR, $VAR) { $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR""); } /** * VAR VAR VAR VAR VAR VAR */ VAR VAR() { VAR [ [ '<VAR><VAR VAR=""VAR:/VAR/-VAR(1) '<!-- VAR VAR --><VAR><!-- VAR VAR --><VAR VAR-VAR=""VAR"">VAR</VAR></VAR>' ], [ '<VAR><VAR><VAR VAR=""VAR:VAR(1)"">VAR</VAR>', '<!-- VAR VAR --><VAR><VAR><!-- VAR VAR -->VAR</VAR></VAR>' ], [ '<VAR><VAR VAR=""VAR& '<!-- VAR VAR --><VAR><VAR VAR-VAR=""VAR"">VAR</VAR></VAR>' ], [ '<VAR><VAR VAR=""& '<!-- VAR VAR --><VAR><VAR VAR-VAR=""VAR"">VAR</VAR></VAR>' ], [ '<VAR><VAR VAR=""& '<!-- VAR VAR --><VAR><VAR VAR-VAR=""VAR"">VAR</VAR></VAR>' ], [ '<VAR><VAR VAR=""VAR:VAR(1)"">', '<!-- VAR VAR --><VAR VAR-VAR=""VAR""></VAR>' ], [ '<VAR><VAR VAR=""VAR:VAR(VAR);""><VAR>VAR</VAR></VAR>', '<!-- VAR VAR --><VAR><VAR VAR-VAR=""VAR""><VAR>VAR</VAR></VAR></VAR>', ], [ '<VAR><VAR><VAR VAR=""VAR:VAR(VAR);""><VAR>VAR</VAR></VAR></VAR>', '<!-- VAR VAR --><VAR><VAR><VAR VAR-VAR=""VAR""><VAR>VAR</VAR></VAR></VAR></VAR>', ], [ '<VAR><VAR><VAR VAR=""VAR:VAR(VAR);""><VAR>VAR</VAR></VAR></VAR>', '<!-- VAR VAR --><VAR><VAR><VAR VAR-VAR=""VAR""><VAR>VAR</VAR></VAR></VAR></VAR>', ], [ '<VAR><VAR><VAR VAR=""VAR:VAR(VAR);"">VAR</VAR></VAR>', '<!-- VAR VAR --><VAR><VAR><VAR VAR-VAR=""VAR"">VAR</VAR></VAR></VAR>', ], ]; } /** * VAR VAR VAR VAR * * @VAR VAR */ VAR VAR($VAR, $VAR) { $VAR = VAR VAR(['VAR' => VAR, 'VAR' => ['VAR']]); $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR""); * VAR VAR VAR VAR VAR() $VAR = '<VAR VAR=""&VAR;&VAR;&VAR;VAR&VAR;VAR(VAR.VAR)&VAR;/VAR&VAR;""><VAR></VAR></VAR>'; $VAR = '<!-- VAR VAR --><!-- VAR VAR --><VAR VAR=""VAR: $VAR = VAR VAR; $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR""); $VAR = '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"">VAR VAR!<VAR></VAR></VAR>'; $VAR = '<!-- VAR VAR --><!-- VAR VAR -->VAR VAR!<VAR VAR=""VAR: $VAR = VAR VAR; $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR""); $VAR = '<VAR>VAR VAR!<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)""></VAR></VAR>'; $VAR = '<VAR>VAR VAR!<VAR /></VAR>'; $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR""); $VAR = '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"" />'; $VAR = '<VAR VAR=""&VAR; VAR=&VAR;VAR(VAR.VAR)"" />'; $VAR = VAR VAR; $VAR = $VAR->VAR($VAR); $VAR->VAR($VAR, $VAR, ""VAR VAR"");",7
trafficserver_de7c8a78edd5b75e311561dfaa133e9d71ea8a5e,plugins/s3_auth/aws_auth_v4.cc,"    } else if (i == '+') {
      /* Only written in the example code, but a plus sign is treated as a space regardless of the position and it must be encoded
       * as ""%20"" instead of ""%2B"" */
      result << ""%20"";",,de7c8a78edd5b75e311561dfaa133e9d71ea8a5e,CVE-2023-41752,de7c8a78edd5b75e311561dfaa133e9d71ea8a5e,https://github.com/apache/trafficserver,CPE_GIT_REPOBASED,66,COMPLETED,"} VAR VAR (VAR == '+') { /* VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR ""%20"" VAR VAR ""%2B"" */ VAR << ""%20""; ",7
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,src/urllib3/util/timeout.py,"from __future__ import absolute_import
# The default socket timeout, used by httplib to indicate that no timeout was
# specified by the user
from socket import _GLOBAL_DEFAULT_TIMEOUT
import time

from ..exceptions import TimeoutStateError

# A sentinel value to indicate that no timeout was specified by the user in
# urllib3
_Default = object()


# Use time.monotonic if available.
current_time = getattr(time, ""monotonic"", time.time)


class Timeout(object):
    """""" Timeout configuration.

    Timeouts can be defined as a default for a pool::

        timeout = Timeout(connect=2.0, read=7.0)
        http = PoolManager(timeout=timeout)
        response = http.request('GET', 'http://example.com/')

    Or per-request (which overrides the default for the pool)::

        response = http.request('GET', 'http://example.com/', timeout=Timeout(10))

    Timeouts can be disabled by setting all the parameters to ``None``::

        no_timeout = Timeout(connect=None, read=None)
        response = http.request('GET', 'http://example.com/, timeout=no_timeout)


    :param total:
        This combines the connect and read timeouts into one; the read timeout
        will be set to the time leftover from the connect attempt. In the
        event that both a connect timeout and a total are specified, or a read
        timeout and a total are specified, the shorter timeout will be applied.

        Defaults to None.

    :type total: integer, float, or None

    :param connect:
        The maximum amount of time to wait for a connection attempt to a server
        to succeed. Omitting the parameter will default the connect timeout to
        the system default, probably `the global default timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout for connection attempts.

    :type connect: integer, float, or None

    :param read:
        The maximum amount of time to wait between consecutive
        read operations for a response from the server. Omitting
        the parameter will default the read timeout to the system
        default, probably `the global default timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout.

    :type read: integer, float, or None

    .. note::

        Many factors can affect the total amount of time for urllib3 to return
        an HTTP response.

        For example, Python's DNS resolver does not obey the timeout specified
        on the socket. Other factors that can affect total request time include
        high CPU load, high swap, the program running at a low priority level,
        or other behaviors.

        In addition, the read and total timeouts only measure the time between
        read operations on the socket connecting the client and the server,
        not the total amount of time for the request to return a complete
        response. For most requests, the timeout is raised because the server
        has not sent the first byte in the specified time. This is not always
        the case; if a server streams one byte every fifteen seconds, a timeout
        of 20 seconds will not trigger, even though the request will take
        several minutes to complete.

        If your goal is to cut off any request after a set amount of wall clock
        time, consider having a second ""watcher"" thread to cut off a slow
        request.
    """"""

    #: A sentinel object representing the default timeout value
    DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT

    def __init__(self, total=None, connect=_Default, read=_Default):
        self._connect = self._validate_timeout(connect, 'connect')
        self._read = self._validate_timeout(read, 'read')
        self.total = self._validate_timeout(total, 'total')
        self._start_connect = None

    def __str__(self):
        return '%s(connect=%r, read=%r, total=%r)' % (
            type(self).__name__, self._connect, self._read, self.total)

    @classmethod
    def _validate_timeout(cls, value, name):
        """""" Check that a timeout attribute is valid.

        :param value: The timeout value to validate
        :param name: The name of the timeout attribute to validate. This is
            used to specify in error messages.
        :return: The validated and casted version of the given value.
        :raises ValueError: If it is a numeric value less than or equal to
            zero, or the type is not an integer, float, or None.
        """"""
        if value is _Default:
            return cls.DEFAULT_TIMEOUT

        if value is None or value is cls.DEFAULT_TIMEOUT:
            return value

        if isinstance(value, bool):
            raise ValueError(""Timeout cannot be a boolean value. It must ""
                             ""be an int, float or None."")
        try:
            float(value)
        except (TypeError, ValueError):
            raise ValueError(""Timeout value %s was %s, but it must be an ""
                             ""int, float or None."" % (name, value))

        try:
            if value <= 0:
                raise ValueError(""Attempted to set %s timeout to %s, but the ""
                                 ""timeout cannot be set to a value less ""
                                 ""than or equal to 0."" % (name, value))
        except TypeError:  # Python 3
            raise ValueError(""Timeout value %s was %s, but it must be an ""
                             ""int, float or None."" % (name, value))

        return value

    @classmethod
    def from_float(cls, timeout):
        """""" Create a new Timeout from a legacy timeout value.

        The timeout value used by httplib.py sets the same timeout on the
        connect(), and recv() socket requests. This creates a :class:`Timeout`
        object that sets the individual timeouts to the ``timeout`` value
        passed to this function.

        :param timeout: The legacy timeout value.
        :type timeout: integer, float, sentinel default object, or None
        :return: Timeout object
        :rtype: :class:`Timeout`
        """"""
        return Timeout(read=timeout, connect=timeout)

    def clone(self):
        """""" Create a copy of the timeout object

        Timeout properties are stored per-pool but each request needs a fresh
        Timeout object to ensure each one has its own start/stop configured.

        :return: a copy of the timeout object
        :rtype: :class:`Timeout`
        """"""
        # We can't use copy.deepcopy because that will also create a new object
        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to
        # detect the user default.
        return Timeout(connect=self._connect, read=self._read,
                       total=self.total)

    def start_connect(self):
        """""" Start the timeout clock, used during a connect() attempt

        :raises urllib3.exceptions.TimeoutStateError: if you attempt
            to start a timer that has been started already.
        """"""
        if self._start_connect is not None:
            raise TimeoutStateError(""Timeout timer has already been started."")
        self._start_connect = current_time()
        return self._start_connect

    def get_connect_duration(self):
        """""" Gets the time elapsed since the call to :meth:`start_connect`.

        :return: Elapsed time.
        :rtype: float
        :raises urllib3.exceptions.TimeoutStateError: if you attempt
            to get duration for a timer that hasn't been started.
        """"""
        if self._start_connect is None:
            raise TimeoutStateError(""Can't get connect duration for timer ""
                                    ""that has not started."")
        return current_time() - self._start_connect

    @property
    def connect_timeout(self):
        """""" Get the value to use when setting a connection timeout.

        This will be a positive float or integer, the value None
        (never timeout), or the default system timeout.

        :return: Connect timeout.
        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
        """"""
        if self.total is None:
            return self._connect

        if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:
            return self.total

        return min(self._connect, self.total)

    @property
    def read_timeout(self):
        """""" Get the value for the read timeout.

        This assumes some time has elapsed in the connection timeout and
        computes the read timeout appropriately.

        If self.total is set, the read timeout is dependent on the amount of
        time taken by the connect timeout. If the connection time has not been
        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be
        raised.

        :return: Value to use for the read timeout.
        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`
            has not yet been called on this object.
        """"""
        if (self.total is not None and
                self.total is not self.DEFAULT_TIMEOUT and
                self._read is not None and
                self._read is not self.DEFAULT_TIMEOUT):
            # In case the connect timeout has not yet been established.
            if self._start_connect is None:
                return self._read
            return max(0, min(self.total - self.get_connect_duration(),
                              self._read))
        elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:
            return max(0, self.total - self.get_connect_duration())
        else:
            return self._read",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR   VAR VAR VAR VAR VAR VAR VAR ..VAR VAR VAR   VAR = VAR()  VAR = VAR(VAR, ""VAR"", VAR.VAR) VAR VAR(VAR): """""" VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR:: VAR = VAR(VAR=2.0, VAR=7.0) VAR = VAR(VAR=VAR) VAR = VAR.VAR('VAR', 'VAR: VAR VAR-VAR (VAR VAR VAR VAR VAR VAR VAR):: VAR = VAR.VAR('VAR', 'VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR``:: VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR.VAR('VAR', 'VAR: :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR `VAR VAR VAR VAR VAR VAR.VAR <VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR `VAR VAR VAR VAR VAR VAR.VAR <VAR: VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR .. VAR:: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR 20 VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR ""VAR"" VAR VAR VAR VAR VAR VAR VAR. """"""  VAR = VAR VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR.VAR = VAR.VAR(VAR, 'VAR') VAR.VAR = VAR.VAR(VAR, 'VAR') VAR.VAR = VAR.VAR(VAR, 'VAR') VAR.VAR = VAR VAR VAR(VAR): VAR '%VAR(VAR=%VAR, VAR=%VAR, VAR=%VAR)' % ( VAR(VAR).VAR, VAR.VAR, VAR.VAR, VAR.VAR) @VAR VAR VAR(VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR. """""" VAR VAR VAR VAR: VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR: VAR VAR VAR VAR(VAR, VAR): VAR VAR(""VAR VAR VAR VAR VAR VAR. VAR VAR "" ""VAR VAR VAR, VAR VAR VAR."") VAR: VAR(VAR) VAR (VAR, VAR): VAR VAR(""VAR VAR %VAR VAR %VAR, VAR VAR VAR VAR VAR "" ""VAR, VAR VAR VAR."" % (VAR, VAR)) VAR: VAR VAR <= 0: VAR VAR(""VAR VAR VAR %VAR VAR VAR %VAR, VAR VAR "" ""VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR 0."" % (VAR, VAR)) VAR VAR:  VAR VAR(""VAR VAR %VAR VAR %VAR, VAR VAR VAR VAR VAR "" ""VAR, VAR VAR VAR."" % (VAR, VAR)) VAR VAR @VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR(), VAR VAR() VAR VAR. VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR VAR, VAR VAR :VAR: VAR VAR :VAR: :VAR:`VAR` """""" VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR :VAR: :VAR:`VAR` """"""    VAR VAR(VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR() VAR :VAR VAR.VAR.VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR."") VAR.VAR = VAR() VAR VAR.VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR`. :VAR: VAR VAR. :VAR: VAR :VAR VAR.VAR.VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR. """""" VAR VAR.VAR VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR."") VAR VAR() - VAR.VAR @VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR (VAR VAR), VAR VAR VAR VAR VAR. :VAR: VAR VAR. :VAR: VAR, VAR, :VAR:`VAR.VAR` VAR VAR """""" VAR VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR VAR VAR(VAR.VAR, VAR.VAR) @VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR.VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR, VAR, :VAR:`VAR.VAR` VAR VAR :VAR VAR.VAR.VAR: VAR :VAR:`VAR` VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR (VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR):  VAR VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR(0, VAR(VAR.VAR - VAR.VAR(), VAR.VAR)) VAR VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR(0, VAR.VAR - VAR.VAR()) VAR: VAR VAR.VAR ",7
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,src/urllib3/util/timeout.py,"from __future__ import absolute_import

import time

# The default socket timeout, used by httplib to indicate that no timeout was
# specified by the user
from socket import _GLOBAL_DEFAULT_TIMEOUT

from ..exceptions import TimeoutStateError

# A sentinel value to indicate that no timeout was specified by the user in
# urllib3
_Default = object()


# Use time.monotonic if available.
current_time = getattr(time, ""monotonic"", time.time)


class Timeout(object):
    """"""Timeout configuration.

    Timeouts can be defined as a default for a pool:

    .. code-block:: python

       timeout = Timeout(connect=2.0, read=7.0)
       http = PoolManager(timeout=timeout)
       response = http.request('GET', 'http://example.com/')

    Or per-request (which overrides the default for the pool):

    .. code-block:: python

       response = http.request('GET', 'http://example.com/', timeout=Timeout(10))

    Timeouts can be disabled by setting all the parameters to ``None``:

    .. code-block:: python

       no_timeout = Timeout(connect=None, read=None)
       response = http.request('GET', 'http://example.com/, timeout=no_timeout)


    :param total:
        This combines the connect and read timeouts into one; the read timeout
        will be set to the time leftover from the connect attempt. In the
        event that both a connect timeout and a total are specified, or a read
        timeout and a total are specified, the shorter timeout will be applied.

        Defaults to None.

    :type total: int, float, or None

    :param connect:
        The maximum amount of time (in seconds) to wait for a connection
        attempt to a server to succeed. Omitting the parameter will default the
        connect timeout to the system default, probably `the global default
        timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout for connection attempts.

    :type connect: int, float, or None

    :param read:
        The maximum amount of time (in seconds) to wait between consecutive
        read operations for a response from the server. Omitting the parameter
        will default the read timeout to the system default, probably `the
        global default timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout.

    :type read: int, float, or None

    .. note::

        Many factors can affect the total amount of time for urllib3 to return
        an HTTP response.

        For example, Python's DNS resolver does not obey the timeout specified
        on the socket. Other factors that can affect total request time include
        high CPU load, high swap, the program running at a low priority level,
        or other behaviors.

        In addition, the read and total timeouts only measure the time between
        read operations on the socket connecting the client and the server,
        not the total amount of time for the request to return a complete
        response. For most requests, the timeout is raised because the server
        has not sent the first byte in the specified time. This is not always
        the case; if a server streams one byte every fifteen seconds, a timeout
        of 20 seconds will not trigger, even though the request will take
        several minutes to complete.

        If your goal is to cut off any request after a set amount of wall clock
        time, consider having a second ""watcher"" thread to cut off a slow
        request.
    """"""

    #: A sentinel object representing the default timeout value
    DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT

    def __init__(self, total=None, connect=_Default, read=_Default):
        self._connect = self._validate_timeout(connect, ""connect"")
        self._read = self._validate_timeout(read, ""read"")
        self.total = self._validate_timeout(total, ""total"")
        self._start_connect = None

    def __repr__(self):
        return ""%s(connect=%r, read=%r, total=%r)"" % (
            type(self).__name__,
            self._connect,
            self._read,
            self.total,
        )

    # __str__ provided for backwards compatibility
    __str__ = __repr__

    @classmethod
    def _validate_timeout(cls, value, name):
        """"""Check that a timeout attribute is valid.

        :param value: The timeout value to validate
        :param name: The name of the timeout attribute to validate. This is
            used to specify in error messages.
        :return: The validated and casted version of the given value.
        :raises ValueError: If it is a numeric value less than or equal to
            zero, or the type is not an integer, float, or None.
        """"""
        if value is _Default:
            return cls.DEFAULT_TIMEOUT

        if value is None or value is cls.DEFAULT_TIMEOUT:
            return value

        if isinstance(value, bool):
            raise ValueError(
                ""Timeout cannot be a boolean value. It must ""
                ""be an int, float or None.""
            )
        try:
            float(value)
        except (TypeError, ValueError):
            raise ValueError(
                ""Timeout value %s was %s, but it must be an ""
                ""int, float or None."" % (name, value)
            )

        try:
            if value <= 0:
                raise ValueError(
                    ""Attempted to set %s timeout to %s, but the ""
                    ""timeout cannot be set to a value less ""
                    ""than or equal to 0."" % (name, value)
                )
        except TypeError:
            # Python 3
            raise ValueError(
                ""Timeout value %s was %s, but it must be an ""
                ""int, float or None."" % (name, value)
            )

        return value

    @classmethod
    def from_float(cls, timeout):
        """"""Create a new Timeout from a legacy timeout value.

        The timeout value used by httplib.py sets the same timeout on the
        connect(), and recv() socket requests. This creates a :class:`Timeout`
        object that sets the individual timeouts to the ``timeout`` value
        passed to this function.

        :param timeout: The legacy timeout value.
        :type timeout: integer, float, sentinel default object, or None
        :return: Timeout object
        :rtype: :class:`Timeout`
        """"""
        return Timeout(read=timeout, connect=timeout)

    def clone(self):
        """"""Create a copy of the timeout object

        Timeout properties are stored per-pool but each request needs a fresh
        Timeout object to ensure each one has its own start/stop configured.

        :return: a copy of the timeout object
        :rtype: :class:`Timeout`
        """"""
        # We can't use copy.deepcopy because that will also create a new object
        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to
        # detect the user default.
        return Timeout(connect=self._connect, read=self._read, total=self.total)

    def start_connect(self):
        """"""Start the timeout clock, used during a connect() attempt

        :raises urllib3.exceptions.TimeoutStateError: if you attempt
            to start a timer that has been started already.
        """"""
        if self._start_connect is not None:
            raise TimeoutStateError(""Timeout timer has already been started."")
        self._start_connect = current_time()
        return self._start_connect

    def get_connect_duration(self):
        """"""Gets the time elapsed since the call to :meth:`start_connect`.

        :return: Elapsed time in seconds.
        :rtype: float
        :raises urllib3.exceptions.TimeoutStateError: if you attempt
            to get duration for a timer that hasn't been started.
        """"""
        if self._start_connect is None:
            raise TimeoutStateError(
                ""Can't get connect duration for timer that has not started.""
            )
        return current_time() - self._start_connect

    @property
    def connect_timeout(self):
        """"""Get the value to use when setting a connection timeout.

        This will be a positive float or integer, the value None
        (never timeout), or the default system timeout.

        :return: Connect timeout.
        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
        """"""
        if self.total is None:
            return self._connect

        if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:
            return self.total

        return min(self._connect, self.total)

    @property
    def read_timeout(self):
        """"""Get the value for the read timeout.

        This assumes some time has elapsed in the connection timeout and
        computes the read timeout appropriately.

        If self.total is set, the read timeout is dependent on the amount of
        time taken by the connect timeout. If the connection time has not been
        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be
        raised.

        :return: Value to use for the read timeout.
        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`
            has not yet been called on this object.
        """"""
        if (
            self.total is not None
            and self.total is not self.DEFAULT_TIMEOUT
            and self._read is not None
            and self._read is not self.DEFAULT_TIMEOUT
        ):
            # In case the connect timeout has not yet been established.
            if self._start_connect is None:
                return self._read
            return max(0, min(self.total - self.get_connect_duration(), self._read))
        elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:
            return max(0, self.total - self.get_connect_duration())
        else:
            return self._read",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR   VAR VAR VAR VAR VAR ..VAR VAR VAR   VAR = VAR()  VAR = VAR(VAR, ""VAR"", VAR.VAR) VAR VAR(VAR): """"""VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: .. VAR-VAR:: VAR VAR = VAR(VAR=2.0, VAR=7.0) VAR = VAR(VAR=VAR) VAR = VAR.VAR('VAR', 'VAR: VAR VAR-VAR (VAR VAR VAR VAR VAR VAR VAR): .. VAR-VAR:: VAR VAR = VAR.VAR('VAR', 'VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR``: .. VAR-VAR:: VAR VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR.VAR('VAR', 'VAR: :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR :VAR VAR: VAR VAR VAR VAR VAR (VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR `VAR VAR VAR VAR VAR VAR.VAR <VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR :VAR VAR: VAR VAR VAR VAR VAR (VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR `VAR VAR VAR VAR VAR VAR.VAR <VAR: VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR .. VAR:: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR 20 VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR ""VAR"" VAR VAR VAR VAR VAR VAR VAR. """"""  VAR = VAR VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR.VAR = VAR.VAR(VAR, ""VAR"") VAR.VAR = VAR.VAR(VAR, ""VAR"") VAR.VAR = VAR.VAR(VAR, ""VAR"") VAR.VAR = VAR VAR VAR(VAR): VAR ""%VAR(VAR=%VAR, VAR=%VAR, VAR=%VAR)"" % ( VAR(VAR).VAR, VAR.VAR, VAR.VAR, VAR.VAR, )  VAR = VAR @VAR VAR VAR(VAR, VAR, VAR): """"""VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR. """""" VAR VAR VAR VAR: VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR: VAR VAR VAR VAR(VAR, VAR): VAR VAR( ""VAR VAR VAR VAR VAR VAR. VAR VAR "" ""VAR VAR VAR, VAR VAR VAR."" ) VAR: VAR(VAR) VAR (VAR, VAR): VAR VAR( ""VAR VAR %VAR VAR %VAR, VAR VAR VAR VAR VAR "" ""VAR, VAR VAR VAR."" % (VAR, VAR) ) VAR: VAR VAR <= 0: VAR VAR( ""VAR VAR VAR %VAR VAR VAR %VAR, VAR VAR "" ""VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR 0."" % (VAR, VAR) ) VAR VAR:  VAR VAR( ""VAR VAR %VAR VAR %VAR, VAR VAR VAR VAR VAR "" ""VAR, VAR VAR VAR."" % (VAR, VAR) ) VAR VAR @VAR VAR VAR(VAR, VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR(), VAR VAR() VAR VAR. VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR VAR, VAR VAR :VAR: VAR VAR :VAR: :VAR:`VAR` """""" VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR :VAR: :VAR:`VAR` """"""    VAR VAR(VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR, VAR VAR VAR VAR() VAR :VAR VAR.VAR.VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR."") VAR.VAR = VAR() VAR VAR.VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR`. :VAR: VAR VAR VAR VAR. :VAR: VAR :VAR VAR.VAR.VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR. """""" VAR VAR.VAR VAR VAR: VAR VAR( ""VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."" ) VAR VAR() - VAR.VAR @VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR (VAR VAR), VAR VAR VAR VAR VAR. :VAR: VAR VAR. :VAR: VAR, VAR, :VAR:`VAR.VAR` VAR VAR """""" VAR VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR VAR VAR(VAR.VAR, VAR.VAR) @VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR.VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR, VAR, :VAR:`VAR.VAR` VAR VAR :VAR VAR.VAR.VAR: VAR :VAR:`VAR` VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR ( VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR ):  VAR VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR(0, VAR(VAR.VAR - VAR.VAR(), VAR.VAR)) VAR VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR(0, VAR.VAR - VAR.VAR()) VAR: VAR VAR.VAR ",7
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,src/urllib3/util/timeout.py,"from __future__ import absolute_import
# The default socket timeout, used by httplib to indicate that no timeout was
# specified by the user
from socket import _GLOBAL_DEFAULT_TIMEOUT
import time

from ..exceptions import TimeoutStateError

# A sentinel value to indicate that no timeout was specified by the user in
# urllib3
_Default = object()


# Use time.monotonic if available.
current_time = getattr(time, ""monotonic"", time.time)


class Timeout(object):
    """""" Timeout configuration.

    Timeouts can be defined as a default for a pool::

        timeout = Timeout(connect=2.0, read=7.0)
        http = PoolManager(timeout=timeout)
        response = http.request('GET', 'http://example.com/')

    Or per-request (which overrides the default for the pool)::

        response = http.request('GET', 'http://example.com/', timeout=Timeout(10))

    Timeouts can be disabled by setting all the parameters to ``None``::

        no_timeout = Timeout(connect=None, read=None)
        response = http.request('GET', 'http://example.com/, timeout=no_timeout)


    :param total:
        This combines the connect and read timeouts into one; the read timeout
        will be set to the time leftover from the connect attempt. In the
        event that both a connect timeout and a total are specified, or a read
        timeout and a total are specified, the shorter timeout will be applied.

        Defaults to None.

    :type total: integer, float, or None

    :param connect:
        The maximum amount of time to wait for a connection attempt to a server
        to succeed. Omitting the parameter will default the connect timeout to
        the system default, probably `the global default timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout for connection attempts.

    :type connect: integer, float, or None

    :param read:
        The maximum amount of time to wait between consecutive
        read operations for a response from the server. Omitting
        the parameter will default the read timeout to the system
        default, probably `the global default timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout.

    :type read: integer, float, or None

    .. note::

        Many factors can affect the total amount of time for urllib3 to return
        an HTTP response.

        For example, Python's DNS resolver does not obey the timeout specified
        on the socket. Other factors that can affect total request time include
        high CPU load, high swap, the program running at a low priority level,
        or other behaviors.

        In addition, the read and total timeouts only measure the time between
        read operations on the socket connecting the client and the server,
        not the total amount of time for the request to return a complete
        response. For most requests, the timeout is raised because the server
        has not sent the first byte in the specified time. This is not always
        the case; if a server streams one byte every fifteen seconds, a timeout
        of 20 seconds will not trigger, even though the request will take
        several minutes to complete.

        If your goal is to cut off any request after a set amount of wall clock
        time, consider having a second ""watcher"" thread to cut off a slow
        request.
    """"""

    #: A sentinel object representing the default timeout value
    DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT

    def __init__(self, total=None, connect=_Default, read=_Default):
        self._connect = self._validate_timeout(connect, 'connect')
        self._read = self._validate_timeout(read, 'read')
        self.total = self._validate_timeout(total, 'total')
        self._start_connect = None

    def __str__(self):
        return '%s(connect=%r, read=%r, total=%r)' % (
            type(self).__name__, self._connect, self._read, self.total)

    @classmethod
    def _validate_timeout(cls, value, name):
        """""" Check that a timeout attribute is valid.

        :param value: The timeout value to validate
        :param name: The name of the timeout attribute to validate. This is
            used to specify in error messages.
        :return: The validated and casted version of the given value.
        :raises ValueError: If it is a numeric value less than or equal to
            zero, or the type is not an integer, float, or None.
        """"""
        if value is _Default:
            return cls.DEFAULT_TIMEOUT

        if value is None or value is cls.DEFAULT_TIMEOUT:
            return value

        if isinstance(value, bool):
            raise ValueError(""Timeout cannot be a boolean value. It must ""
                             ""be an int, float or None."")
        try:
            float(value)
        except (TypeError, ValueError):
            raise ValueError(""Timeout value %s was %s, but it must be an ""
                             ""int, float or None."" % (name, value))

        try:
            if value <= 0:
                raise ValueError(""Attempted to set %s timeout to %s, but the ""
                                 ""timeout cannot be set to a value less ""
                                 ""than or equal to 0."" % (name, value))
        except TypeError:  # Python 3
            raise ValueError(""Timeout value %s was %s, but it must be an ""
                             ""int, float or None."" % (name, value))

        return value

    @classmethod
    def from_float(cls, timeout):
        """""" Create a new Timeout from a legacy timeout value.

        The timeout value used by httplib.py sets the same timeout on the
        connect(), and recv() socket requests. This creates a :class:`Timeout`
        object that sets the individual timeouts to the ``timeout`` value
        passed to this function.

        :param timeout: The legacy timeout value.
        :type timeout: integer, float, sentinel default object, or None
        :return: Timeout object
        :rtype: :class:`Timeout`
        """"""
        return Timeout(read=timeout, connect=timeout)

    def clone(self):
        """""" Create a copy of the timeout object

        Timeout properties are stored per-pool but each request needs a fresh
        Timeout object to ensure each one has its own start/stop configured.

        :return: a copy of the timeout object
        :rtype: :class:`Timeout`
        """"""
        # We can't use copy.deepcopy because that will also create a new object
        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to
        # detect the user default.
        return Timeout(connect=self._connect, read=self._read,
                       total=self.total)

    def start_connect(self):
        """""" Start the timeout clock, used during a connect() attempt

        :raises urllib3.exceptions.TimeoutStateError: if you attempt
            to start a timer that has been started already.
        """"""
        if self._start_connect is not None:
            raise TimeoutStateError(""Timeout timer has already been started."")
        self._start_connect = current_time()
        return self._start_connect

    def get_connect_duration(self):
        """""" Gets the time elapsed since the call to :meth:`start_connect`.

        :return: Elapsed time.
        :rtype: float
        :raises urllib3.exceptions.TimeoutStateError: if you attempt
            to get duration for a timer that hasn't been started.
        """"""
        if self._start_connect is None:
            raise TimeoutStateError(""Can't get connect duration for timer ""
                                    ""that has not started."")
        return current_time() - self._start_connect

    @property
    def connect_timeout(self):
        """""" Get the value to use when setting a connection timeout.

        This will be a positive float or integer, the value None
        (never timeout), or the default system timeout.

        :return: Connect timeout.
        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
        """"""
        if self.total is None:
            return self._connect

        if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:
            return self.total

        return min(self._connect, self.total)

    @property
    def read_timeout(self):
        """""" Get the value for the read timeout.

        This assumes some time has elapsed in the connection timeout and
        computes the read timeout appropriately.

        If self.total is set, the read timeout is dependent on the amount of
        time taken by the connect timeout. If the connection time has not been
        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be
        raised.

        :return: Value to use for the read timeout.
        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`
            has not yet been called on this object.
        """"""
        if (self.total is not None and
                self.total is not self.DEFAULT_TIMEOUT and
                self._read is not None and
                self._read is not self.DEFAULT_TIMEOUT):
            # In case the connect timeout has not yet been established.
            if self._start_connect is None:
                return self._read
            return max(0, min(self.total - self.get_connect_duration(),
                              self._read))
        elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:
            return max(0, self.total - self.get_connect_duration())
        else:
            return self._read",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR   VAR VAR VAR VAR VAR VAR VAR ..VAR VAR VAR   VAR = VAR()  VAR = VAR(VAR, ""VAR"", VAR.VAR) VAR VAR(VAR): """""" VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR:: VAR = VAR(VAR=2.0, VAR=7.0) VAR = VAR(VAR=VAR) VAR = VAR.VAR('VAR', 'VAR: VAR VAR-VAR (VAR VAR VAR VAR VAR VAR VAR):: VAR = VAR.VAR('VAR', 'VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR``:: VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR.VAR('VAR', 'VAR: :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR `VAR VAR VAR VAR VAR VAR.VAR <VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR `VAR VAR VAR VAR VAR VAR.VAR <VAR: VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR .. VAR:: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR 20 VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR ""VAR"" VAR VAR VAR VAR VAR VAR VAR. """"""  VAR = VAR VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR.VAR = VAR.VAR(VAR, 'VAR') VAR.VAR = VAR.VAR(VAR, 'VAR') VAR.VAR = VAR.VAR(VAR, 'VAR') VAR.VAR = VAR VAR VAR(VAR): VAR '%VAR(VAR=%VAR, VAR=%VAR, VAR=%VAR)' % ( VAR(VAR).VAR, VAR.VAR, VAR.VAR, VAR.VAR) @VAR VAR VAR(VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR. """""" VAR VAR VAR VAR: VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR: VAR VAR VAR VAR(VAR, VAR): VAR VAR(""VAR VAR VAR VAR VAR VAR. VAR VAR "" ""VAR VAR VAR, VAR VAR VAR."") VAR: VAR(VAR) VAR (VAR, VAR): VAR VAR(""VAR VAR %VAR VAR %VAR, VAR VAR VAR VAR VAR "" ""VAR, VAR VAR VAR."" % (VAR, VAR)) VAR: VAR VAR <= 0: VAR VAR(""VAR VAR VAR %VAR VAR VAR %VAR, VAR VAR "" ""VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR 0."" % (VAR, VAR)) VAR VAR:  VAR VAR(""VAR VAR %VAR VAR %VAR, VAR VAR VAR VAR VAR "" ""VAR, VAR VAR VAR."" % (VAR, VAR)) VAR VAR @VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR(), VAR VAR() VAR VAR. VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR VAR, VAR VAR :VAR: VAR VAR :VAR: :VAR:`VAR` """""" VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR :VAR: :VAR:`VAR` """"""    VAR VAR(VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR() VAR :VAR VAR.VAR.VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR."") VAR.VAR = VAR() VAR VAR.VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR`. :VAR: VAR VAR. :VAR: VAR :VAR VAR.VAR.VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR. """""" VAR VAR.VAR VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR."") VAR VAR() - VAR.VAR @VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR (VAR VAR), VAR VAR VAR VAR VAR. :VAR: VAR VAR. :VAR: VAR, VAR, :VAR:`VAR.VAR` VAR VAR """""" VAR VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR VAR VAR(VAR.VAR, VAR.VAR) @VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR.VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR, VAR, :VAR:`VAR.VAR` VAR VAR :VAR VAR.VAR.VAR: VAR :VAR:`VAR` VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR (VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR):  VAR VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR(0, VAR(VAR.VAR - VAR.VAR(), VAR.VAR)) VAR VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR(0, VAR.VAR - VAR.VAR()) VAR: VAR VAR.VAR ",7
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,src/urllib3/util/timeout.py,"from __future__ import absolute_import
# The default socket timeout, used by httplib to indicate that no timeout was
# specified by the user
from socket import _GLOBAL_DEFAULT_TIMEOUT
import time

from ..exceptions import TimeoutStateError

# A sentinel value to indicate that no timeout was specified by the user in
# urllib3
_Default = object()


# Use time.monotonic if available.
current_time = getattr(time, ""monotonic"", time.time)


class Timeout(object):
    """""" Timeout configuration.

    Timeouts can be defined as a default for a pool::

        timeout = Timeout(connect=2.0, read=7.0)
        http = PoolManager(timeout=timeout)
        response = http.request('GET', 'http://example.com/')

    Or per-request (which overrides the default for the pool)::

        response = http.request('GET', 'http://example.com/', timeout=Timeout(10))

    Timeouts can be disabled by setting all the parameters to ``None``::

        no_timeout = Timeout(connect=None, read=None)
        response = http.request('GET', 'http://example.com/, timeout=no_timeout)


    :param total:
        This combines the connect and read timeouts into one; the read timeout
        will be set to the time leftover from the connect attempt. In the
        event that both a connect timeout and a total are specified, or a read
        timeout and a total are specified, the shorter timeout will be applied.

        Defaults to None.

    :type total: integer, float, or None

    :param connect:
        The maximum amount of time to wait for a connection attempt to a server
        to succeed. Omitting the parameter will default the connect timeout to
        the system default, probably `the global default timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout for connection attempts.

    :type connect: integer, float, or None

    :param read:
        The maximum amount of time to wait between consecutive
        read operations for a response from the server. Omitting
        the parameter will default the read timeout to the system
        default, probably `the global default timeout in socket.py
        <http://hg.python.org/cpython/file/603b4d593758/Lib/socket.py#l535>`_.
        None will set an infinite timeout.

    :type read: integer, float, or None

    .. note::

        Many factors can affect the total amount of time for urllib3 to return
        an HTTP response.

        For example, Python's DNS resolver does not obey the timeout specified
        on the socket. Other factors that can affect total request time include
        high CPU load, high swap, the program running at a low priority level,
        or other behaviors.

        In addition, the read and total timeouts only measure the time between
        read operations on the socket connecting the client and the server,
        not the total amount of time for the request to return a complete
        response. For most requests, the timeout is raised because the server
        has not sent the first byte in the specified time. This is not always
        the case; if a server streams one byte every fifteen seconds, a timeout
        of 20 seconds will not trigger, even though the request will take
        several minutes to complete.

        If your goal is to cut off any request after a set amount of wall clock
        time, consider having a second ""watcher"" thread to cut off a slow
        request.
    """"""

    #: A sentinel object representing the default timeout value
    DEFAULT_TIMEOUT = _GLOBAL_DEFAULT_TIMEOUT

    def __init__(self, total=None, connect=_Default, read=_Default):
        self._connect = self._validate_timeout(connect, 'connect')
        self._read = self._validate_timeout(read, 'read')
        self.total = self._validate_timeout(total, 'total')
        self._start_connect = None

    def __str__(self):
        return '%s(connect=%r, read=%r, total=%r)' % (
            type(self).__name__, self._connect, self._read, self.total)

    @classmethod
    def _validate_timeout(cls, value, name):
        """""" Check that a timeout attribute is valid.

        :param value: The timeout value to validate
        :param name: The name of the timeout attribute to validate. This is
            used to specify in error messages.
        :return: The validated and casted version of the given value.
        :raises ValueError: If it is a numeric value less than or equal to
            zero, or the type is not an integer, float, or None.
        """"""
        if value is _Default:
            return cls.DEFAULT_TIMEOUT

        if value is None or value is cls.DEFAULT_TIMEOUT:
            return value

        if isinstance(value, bool):
            raise ValueError(""Timeout cannot be a boolean value. It must ""
                             ""be an int, float or None."")
        try:
            float(value)
        except (TypeError, ValueError):
            raise ValueError(""Timeout value %s was %s, but it must be an ""
                             ""int, float or None."" % (name, value))

        try:
            if value <= 0:
                raise ValueError(""Attempted to set %s timeout to %s, but the ""
                                 ""timeout cannot be set to a value less ""
                                 ""than or equal to 0."" % (name, value))
        except TypeError:
            # Python 3
            raise ValueError(""Timeout value %s was %s, but it must be an ""
                             ""int, float or None."" % (name, value))

        return value

    @classmethod
    def from_float(cls, timeout):
        """""" Create a new Timeout from a legacy timeout value.

        The timeout value used by httplib.py sets the same timeout on the
        connect(), and recv() socket requests. This creates a :class:`Timeout`
        object that sets the individual timeouts to the ``timeout`` value
        passed to this function.

        :param timeout: The legacy timeout value.
        :type timeout: integer, float, sentinel default object, or None
        :return: Timeout object
        :rtype: :class:`Timeout`
        """"""
        return Timeout(read=timeout, connect=timeout)

    def clone(self):
        """""" Create a copy of the timeout object

        Timeout properties are stored per-pool but each request needs a fresh
        Timeout object to ensure each one has its own start/stop configured.

        :return: a copy of the timeout object
        :rtype: :class:`Timeout`
        """"""
        # We can't use copy.deepcopy because that will also create a new object
        # for _GLOBAL_DEFAULT_TIMEOUT, which socket.py uses as a sentinel to
        # detect the user default.
        return Timeout(connect=self._connect, read=self._read,
                       total=self.total)

    def start_connect(self):
        """""" Start the timeout clock, used during a connect() attempt

        :raises urllib3.exceptions.TimeoutStateError: if you attempt
            to start a timer that has been started already.
        """"""
        if self._start_connect is not None:
            raise TimeoutStateError(""Timeout timer has already been started."")
        self._start_connect = current_time()
        return self._start_connect

    def get_connect_duration(self):
        """""" Gets the time elapsed since the call to :meth:`start_connect`.

        :return: Elapsed time.
        :rtype: float
        :raises urllib3.exceptions.TimeoutStateError: if you attempt
            to get duration for a timer that hasn't been started.
        """"""
        if self._start_connect is None:
            raise TimeoutStateError(""Can't get connect duration for timer ""
                                    ""that has not started."")
        return current_time() - self._start_connect

    @property
    def connect_timeout(self):
        """""" Get the value to use when setting a connection timeout.

        This will be a positive float or integer, the value None
        (never timeout), or the default system timeout.

        :return: Connect timeout.
        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
        """"""
        if self.total is None:
            return self._connect

        if self._connect is None or self._connect is self.DEFAULT_TIMEOUT:
            return self.total

        return min(self._connect, self.total)

    @property
    def read_timeout(self):
        """""" Get the value for the read timeout.

        This assumes some time has elapsed in the connection timeout and
        computes the read timeout appropriately.

        If self.total is set, the read timeout is dependent on the amount of
        time taken by the connect timeout. If the connection time has not been
        established, a :exc:`~urllib3.exceptions.TimeoutStateError` will be
        raised.

        :return: Value to use for the read timeout.
        :rtype: int, float, :attr:`Timeout.DEFAULT_TIMEOUT` or None
        :raises urllib3.exceptions.TimeoutStateError: If :meth:`start_connect`
            has not yet been called on this object.
        """"""
        if (self.total is not None and
                self.total is not self.DEFAULT_TIMEOUT and
                self._read is not None and
                self._read is not self.DEFAULT_TIMEOUT):
            # In case the connect timeout has not yet been established.
            if self._start_connect is None:
                return self._read
            return max(0, min(self.total - self.get_connect_duration(),
                              self._read))
        elif self.total is not None and self.total is not self.DEFAULT_TIMEOUT:
            return max(0, self.total - self.get_connect_duration())
        else:
            return self._read",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR   VAR VAR VAR VAR VAR VAR VAR ..VAR VAR VAR   VAR = VAR()  VAR = VAR(VAR, ""VAR"", VAR.VAR) VAR VAR(VAR): """""" VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR:: VAR = VAR(VAR=2.0, VAR=7.0) VAR = VAR(VAR=VAR) VAR = VAR.VAR('VAR', 'VAR: VAR VAR-VAR (VAR VAR VAR VAR VAR VAR VAR):: VAR = VAR.VAR('VAR', 'VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR``:: VAR = VAR(VAR=VAR, VAR=VAR) VAR = VAR.VAR('VAR', 'VAR: :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR `VAR VAR VAR VAR VAR VAR.VAR <VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR `VAR VAR VAR VAR VAR VAR.VAR <VAR: VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR .. VAR:: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR; VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR 20 VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR ""VAR"" VAR VAR VAR VAR VAR VAR VAR. """"""  VAR = VAR VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR.VAR = VAR.VAR(VAR, 'VAR') VAR.VAR = VAR.VAR(VAR, 'VAR') VAR.VAR = VAR.VAR(VAR, 'VAR') VAR.VAR = VAR VAR VAR(VAR): VAR '%VAR(VAR=%VAR, VAR=%VAR, VAR=%VAR)' % ( VAR(VAR).VAR, VAR.VAR, VAR.VAR, VAR.VAR) @VAR VAR VAR(VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR. """""" VAR VAR VAR VAR: VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR: VAR VAR VAR VAR(VAR, VAR): VAR VAR(""VAR VAR VAR VAR VAR VAR. VAR VAR "" ""VAR VAR VAR, VAR VAR VAR."") VAR: VAR(VAR) VAR (VAR, VAR): VAR VAR(""VAR VAR %VAR VAR %VAR, VAR VAR VAR VAR VAR "" ""VAR, VAR VAR VAR."" % (VAR, VAR)) VAR: VAR VAR <= 0: VAR VAR(""VAR VAR VAR %VAR VAR VAR %VAR, VAR VAR "" ""VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR 0."" % (VAR, VAR)) VAR VAR:  VAR VAR(""VAR VAR %VAR VAR %VAR, VAR VAR VAR VAR VAR "" ""VAR, VAR VAR VAR."" % (VAR, VAR)) VAR VAR @VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR(), VAR VAR() VAR VAR. VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. :VAR VAR: VAR, VAR, VAR VAR VAR, VAR VAR :VAR: VAR VAR :VAR: :VAR:`VAR` """""" VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR :VAR: :VAR:`VAR` """"""    VAR VAR(VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR() VAR :VAR VAR.VAR.VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR."") VAR.VAR = VAR() VAR VAR.VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR`. :VAR: VAR VAR. :VAR: VAR :VAR VAR.VAR.VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR. """""" VAR VAR.VAR VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR."") VAR VAR() - VAR.VAR @VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR (VAR VAR), VAR VAR VAR VAR VAR. :VAR: VAR VAR. :VAR: VAR, VAR, :VAR:`VAR.VAR` VAR VAR """""" VAR VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR VAR VAR(VAR.VAR, VAR.VAR) @VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR.VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR, VAR, :VAR:`VAR.VAR` VAR VAR :VAR VAR.VAR.VAR: VAR :VAR:`VAR` VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR (VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR):  VAR VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR(0, VAR(VAR.VAR - VAR.VAR(), VAR.VAR)) VAR VAR.VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR(0, VAR.VAR - VAR.VAR()) VAR: VAR VAR.VAR ",7
vim_91c7cbfe31bbef57d5fcf7d76989fc159f73ef15,src/eval.c,"/*
 * Initialize ""evalarg"" for use.
 */
    void
init_evalarg(evalarg_T *evalarg)
{
    CLEAR_POINTER(evalarg);
    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);
}

/*
 * If ""evalarg->eval_tofree"" is not NULL free it later.
 * Caller is expected to overwrite ""evalarg->eval_tofree"" next.
 */
    static void
free_eval_tofree_later(evalarg_T *evalarg)
{
    if (evalarg->eval_tofree != NULL)
    {
	if (ga_grow(&evalarg->eval_tofree_ga, 1) == OK)
	    ((char_u **)evalarg->eval_tofree_ga.ga_data)
		[evalarg->eval_tofree_ga.ga_len++]
		= evalarg->eval_tofree;
	else
	    vim_free(evalarg->eval_tofree);
    }
}

/*
 * After using ""evalarg"" filled from ""eap"": free the memory.
 */
    void
clear_evalarg(evalarg_T *evalarg, exarg_T *eap)
{
    if (evalarg != NULL)
    {
	if (evalarg->eval_tofree != NULL)
	{
	    if (eap != NULL)
	    {
		// We may need to keep the original command line, e.g. for
		// "":let"" it has the variable names.  But we may also need the
		// new one, ""nextcmd"" points into it.  Keep both.
		vim_free(eap->cmdline_tofree);
		eap->cmdline_tofree = *eap->cmdlinep;
		*eap->cmdlinep = evalarg->eval_tofree;
	    }
	    else
		vim_free(evalarg->eval_tofree);
	    evalarg->eval_tofree = NULL;
	}

	ga_clear_strings(&evalarg->eval_tofree_ga);
	VIM_CLEAR(evalarg->eval_tofree_lambda);
    }
}

		// later.  Also free ""eval_tofree"" later if needed.
		free_eval_tofree_later(evalarg);
	free_eval_tofree_later(evalarg);","		// later.
		vim_free(evalarg->eval_tofree);
	vim_free(evalarg->eval_tofree);
/*
 * Initialize ""evalarg"" for use.
 */
    void
init_evalarg(evalarg_T *evalarg)
{
    CLEAR_POINTER(evalarg);
    ga_init2(&evalarg->eval_tofree_ga, sizeof(char_u *), 20);
}

/*
 * After using ""evalarg"" filled from ""eap"": free the memory.
 */
    void
clear_evalarg(evalarg_T *evalarg, exarg_T *eap)
{
    if (evalarg != NULL)
    {
	if (evalarg->eval_tofree != NULL)
	{
	    if (eap != NULL)
	    {
		// We may need to keep the original command line, e.g. for
		// "":let"" it has the variable names.  But we may also need the
		// new one, ""nextcmd"" points into it.  Keep both.
		vim_free(eap->cmdline_tofree);
		eap->cmdline_tofree = *eap->cmdlinep;
		*eap->cmdlinep = evalarg->eval_tofree;
	    }
	    else
		vim_free(evalarg->eval_tofree);
	    evalarg->eval_tofree = NULL;
	}

	ga_clear_strings(&evalarg->eval_tofree_ga);
	VIM_CLEAR(evalarg->eval_tofree_lambda);
    }
}
",91c7cbfe31bbef57d5fcf7d76989fc159f73ef15,CVE-2022-2889,91c7cbfe31bbef57d5fcf7d76989fc159f73ef15,https://github.com/vim/vim,NVD_DIRECT_COMMIT,1337,COMPLETED,"/* * VAR ""VAR"" VAR VAR. */ VAR VAR(VAR *VAR) { VAR(VAR); VAR(&VAR->VAR, VAR(VAR *), 20); } /* * VAR ""VAR->VAR"" VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR ""VAR->VAR"" VAR. */ VAR VAR VAR(VAR *VAR) { VAR (VAR->VAR != VAR) { VAR (VAR(&VAR->VAR, 1) == VAR) ((VAR **)VAR->VAR.VAR) [VAR->VAR.VAR++] = VAR->VAR; VAR VAR(VAR->VAR); } } /* * VAR VAR ""VAR"" VAR VAR ""VAR"": VAR VAR VAR. */ VAR VAR(VAR *VAR, VAR *VAR) { VAR (VAR != VAR) { VAR (VAR->VAR != VAR) { VAR (VAR != VAR) {    VAR(VAR->VAR); VAR->VAR = *VAR->VAR; *VAR->VAR = VAR->VAR; } VAR VAR(VAR->VAR); VAR->VAR = VAR; } VAR(&VAR->VAR); VAR(VAR->VAR); } }  VAR(VAR); VAR(VAR);  VAR(VAR->VAR); VAR(VAR->VAR); /* * VAR ""VAR"" VAR VAR. */ VAR VAR(VAR *VAR) { VAR(VAR); VAR(&VAR->VAR, VAR(VAR *), 20); } /* * VAR VAR ""VAR"" VAR VAR ""VAR"": VAR VAR VAR. */ VAR VAR(VAR *VAR, VAR *VAR) { VAR (VAR != VAR) { VAR (VAR->VAR != VAR) { VAR (VAR != VAR) {    VAR(VAR->VAR); VAR->VAR = *VAR->VAR; *VAR->VAR = VAR->VAR; } VAR VAR(VAR->VAR); VAR->VAR = VAR; } VAR(&VAR->VAR); VAR(VAR->VAR); } }",7
vim_f12129f1714f7d2301935bb21d896609bdac221c,src/version.c,"/**/
    20,",,f12129f1714f7d2301935bb21d896609bdac221c,CVE-2022-2286,f12129f1714f7d2301935bb21d896609bdac221c,https://github.com/vim/vim,NVD_DIRECT_COMMIT,1337,COMPLETED," 20, ",7
xwiki-platform_217e5bb7a657f2991b154a16ef4d5ae9c29ad39c,xwiki-platform-core/xwiki-platform-notifications/xwiki-platform-notifications-ui/src/main/resources/XWiki/Notifications/Code/NotificationRSSService.xml,"#set ($feedContent = $services.notification.notifiers.getFeed(20))
  #set ($characterEncoding = 'utf-8')
  #set ($discard = $response.setContentType('application/xml'))
  ## Make sure the Character Encoding response header matches the character encoding used to write the response and
  ## compute its length.
  #set ($discard = $response.setCharacterEncoding($characterEncoding))
  ## We write the output directly to the response to avoid the execution of the Rendering Transformations.
  #set ($discard = $response.writer.print($feedContent))
  ## The content length is measured in bytes and one character can use more than one byte.
  #set ($discard = $response.setContentLength($feedContent.getBytes($characterEncoding).size()))
  ## Make sure the entire content is send back to the client.
  #set ($discard = $response.flushBuffer())
  ## Make sure XWiki doesn't write any more content to the response.
  #set ($discard = $xcontext.setFinished(true))
  {{code language=""xml"" source=""script:feedContent"" /}}","  #set($discard = $response.setContentType('application/xml'))
  {{code language=""xml""}}
#end
$services.notification.notifiers.getFeed(20)
#if ($xcontext.action != 'get' || ""$request.outputSyntax"" != 'plain')
  {{/code}}",217e5bb7a657f2991b154a16ef4d5ae9c29ad39c,CVE-2023-36469,217e5bb7a657f2991b154a16ef4d5ae9c29ad39c,https://github.com/xwiki/xwiki-platform,NVD_DIRECT_COMMIT,1337,COMPLETED,"              {{VAR VAR=""VAR"" VAR=""VAR:VAR"" /}}  {{VAR VAR=""VAR""}}  $VAR.VAR.VAR.VAR(20)  {{/VAR}}",7
xwiki-platform_45d182a4141ff22f3ff289cf71e4669bdc714544,xwiki-platform-core/xwiki-platform-office/xwiki-platform-office-importer/src/main/java/org/xwiki/officeimporter/internal/converter/OfficeConverterFileStorage.java,"import java.util.regex.Pattern;
import org.apache.commons.compress.utils.FileNameUtils;
    /**
     * Pattern for matching a file extension that is safe, i.e., contains between 1 and 20 alphanumeric
     * characters. The upper limit is arbitrary but should fit all extensions and is there to ensure that the
     * filename won't be too long.
     */
    private static final Pattern SAFE_EXTENSION = Pattern.compile(""^[a-zA-Z0-9]{1,20}$"");

    /**
     * Pattern for matching characters not allowed in filenames. Currently just matches directory separators.
     */
    private static final Pattern DISALLOWED_CHARACTERS = Pattern.compile(""[/\\\\]"");

    private static final String INPUT = ""input"";

            this.inputDir = new File(this.rootDir, INPUT);
                this.inputFile = new File(this.inputDir, cleanFilename(inputFileName));
                this.outputFile = new File(this.outputDir, cleanFilename(outputFileName));
    /**
     * Gets a filename that is safe to use as input filename for a conversion operation.
     * <p>
     * The extension is kept from the input filename if it is alphanumeric and contains between 1 and 20 characters.
     *
     * @param filename the filename for getting the extension
     * @return the input filename
     */
    public static String getSafeInputFilenameFromExtension(String filename)
    {
        String extension = FileNameUtils.getExtension(filename);
        if (!SAFE_EXTENSION.matcher(extension).matches()) {
            extension = """";
        }

        return StringUtils.isBlank(extension) ? INPUT : INPUT + ""."" + extension;
    }

    /**
     * Clean a file name for use as input or output name.
     *
     * @param name the filename to clean
     * @return the cleaned name, shortened to 255 characters if needed
     */
    public static String cleanFilename(String name)
    {
        String result = DISALLOWED_CHARACTERS.matcher(StringUtils.stripAccents(name)).replaceAll(""_"");

        // Make sure that the filename is not blank. Don't use an extension so maybe content guessing works.
        if (StringUtils.isBlank(result)) {
            result = ""fallback"";
        }

        // If the filename is too long, keep the part at the end as it contains the extension.
        if (result.length() > 255) {
            result = result.substring(result.length() - 255);
        }

        return result;
    }
","            this.inputDir = new File(this.rootDir, ""input"");
                this.inputFile = new File(this.inputDir, StringUtils.stripAccents(inputFileName));
                this.outputFile = new File(this.outputDir, StringUtils.stripAccents(outputFileName));",45d182a4141ff22f3ff289cf71e4669bdc714544,CVE-2023-37913,45d182a4141ff22f3ff289cf71e4669bdc714544,https://github.com/xwiki/xwiki-platform,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR.VAR.VAR.VAR; VAR VAR.VAR.VAR.VAR.VAR.VAR; /** * VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR.VAR., VAR VAR 1 VAR 20 VAR * VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR'VAR VAR VAR VAR. */ VAR VAR VAR VAR VAR = VAR.VAR(""^[VAR-VAR-VAR-9]{1,20}$""); /** * VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR. */ VAR VAR VAR VAR VAR = VAR.VAR(""[/\\\\]""); VAR VAR VAR VAR VAR = ""VAR""; VAR.VAR = VAR VAR(VAR.VAR, VAR); VAR.VAR = VAR VAR(VAR.VAR, VAR(VAR)); VAR.VAR = VAR VAR(VAR.VAR, VAR(VAR)); /** * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * <VAR> * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 1 VAR 20 VAR. * * @VAR VAR VAR VAR VAR VAR VAR VAR * @VAR VAR VAR VAR */ VAR VAR VAR VAR(VAR VAR) { VAR VAR = VAR.VAR(VAR); VAR (!VAR.VAR(VAR).VAR()) { VAR = """"; } VAR VAR.VAR(VAR) ? VAR : VAR + ""."" + VAR; } /** * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * @VAR VAR VAR VAR VAR VAR * @VAR VAR VAR VAR, VAR VAR 255 VAR VAR VAR */ VAR VAR VAR VAR(VAR VAR) { VAR VAR = VAR.VAR(VAR.VAR(VAR)).VAR(""VAR"");  VAR (VAR.VAR(VAR)) { VAR = ""VAR""; }  VAR (VAR.VAR() > 255) { VAR = VAR.VAR(VAR.VAR() - 255); } VAR VAR; } VAR.VAR = VAR VAR(VAR.VAR, ""VAR""); VAR.VAR = VAR VAR(VAR.VAR, VAR.VAR(VAR)); VAR.VAR = VAR VAR(VAR.VAR, VAR.VAR(VAR));",7

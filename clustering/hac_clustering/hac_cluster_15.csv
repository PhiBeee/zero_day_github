commit,file,added_code,deleted_code,hash_clean,cve_id,hash,repo_url,rel_type,score,extraction_status,text_norm,cluster_kmeans,cluster_hac
aiohttp_d5c12ba890557a575c313bb3017910d7616fce3d,aiohttp/http_parser.py,"# See https://www.rfc-editor.org/rfc/rfc9110.html#name-overview
# and https://www.rfc-editor.org/rfc/rfc9110.html#name-tokens
VERSRE: Final[Pattern[str]] = re.compile(r""HTTP/(\d).(\d)"")
HDRRE: Final[Pattern[bytes]] = re.compile(rb""[\x00-\x1F\x7F()<>@,;:\[\]={} \t\""\\]"")
            # https://www.rfc-editor.org/rfc/rfc9112.html#section-5.1-2
            if {bname[0], bname[-1]} & {32, 9}:  # {"" "", ""\t""}
                raise InvalidHeader(line)

            bvalue = bvalue.lstrip(b"" \t"")
            # Deprecated: https://www.rfc-editor.org/rfc/rfc9112.html#name-obsolete-line-folding
            bvalue = bvalue.strip(b"" \t"")
            # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-5
            if ""\n"" in value or ""\r"" in value or ""\x00"" in value:
                raise InvalidHeader(bvalue)

                            # Shouldn't allow +/- or other number formats.
                            # https://www.rfc-editor.org/rfc/rfc9110#section-8.6-2
                            if not length_hdr.strip("" \t"").isdigit():
                            return int(length_hdr)
        # https://www.rfc-editor.org/rfc/rfc9110.html#section-5.5-6
        # https://www.rfc-editor.org/rfc/rfc9110.html#name-collected-abnf
        singletons = (
            hdrs.CONTENT_LENGTH,
            hdrs.CONTENT_LOCATION,
            hdrs.CONTENT_RANGE,
            hdrs.CONTENT_TYPE,
            hdrs.ETAG,
            hdrs.HOST,
            hdrs.MAX_FORWARDS,
            hdrs.SERVER,
            hdrs.TRANSFER_ENCODING,
            hdrs.USER_AGENT,
        )
        bad_hdr = next((h for h in singletons if len(headers.getall(h, ())) > 1), None)
        if bad_hdr is not None:
            raise BadHttpMessage(f""Duplicate '{bad_hdr}' header found."")

            method, path, version = line.split(maxsplit=2)
        match = VERSRE.match(version)
        if match is None:
            raise BadStatusLine(line)
        version_o = HttpVersion(int(match.group(1)), int(match.group(2)))
            version, status = line.split(maxsplit=1)
            status, reason = status.split(maxsplit=1)
        if len(status) != 3 or not status.isdigit():
        status_i = int(status)
                        if not size_b.isdigit():
                            raise exc
                        size = int(bytes(size_b), 16)","# See https://tools.ietf.org/html/rfc7230#section-3.1.1
# and https://tools.ietf.org/html/rfc7230#appendix-B
VERSRE: Final[Pattern[str]] = re.compile(r""HTTP/(\d+).(\d+)"")
HDRRE: Final[Pattern[bytes]] = re.compile(rb""[\x00-\x1F\x7F()<>@,;:\[\]={} \t\\\\\""]"")
            bname = bname.strip(b"" \t"")
            bvalue = bvalue.lstrip()
            bvalue = bvalue.strip()
                            try:
                                length = int(length_hdr)
                            except ValueError:
                            if length < 0:
                                raise InvalidHeader(CONTENT_LENGTH)

                            return length
            method, path, version = line.split(None, 2)
        try:
            if version.startswith(""HTTP/""):
                n1, n2 = version[5:].split(""."", 1)
                version_o = HttpVersion(int(n1), int(n2))
            else:
                raise BadStatusLine(version)
        except Exception:
            raise BadStatusLine(version)
            version, status = line.split(None, 1)
            status, reason = status.split(None, 1)
        try:
            status_i = int(status)
        except ValueError:
            raise BadStatusLine(line) from None

        if status_i > 999:
                        try:
                            size = int(bytes(size_b), 16)
                        except ValueError:
                            raise exc from None",d5c12ba890557a575c313bb3017910d7616fce3d,CVE-2023-47627,d5c12ba890557a575c313bb3017910d7616fce3d,https://github.com/aio-libs/aiohttp,NVD_DIRECT_COMMIT,1337,COMPLETED,"  VAR: VAR[VAR[VAR]] = VAR.VAR(VAR""VAR/(\VAR).(\VAR)"") VAR: VAR[VAR[VAR]] = VAR.VAR(VAR""[\VAR-\VAR\VAR()<>@,;:\[\]={} \VAR\""\\]"")  VAR {VAR[0], VAR[-1]} & {32, 9}:  VAR VAR(VAR) VAR = VAR.VAR(VAR"" \VAR"")  VAR = VAR.VAR(VAR"" \VAR"")  VAR ""\VAR"" VAR VAR VAR ""\VAR"" VAR VAR VAR ""\VAR"" VAR VAR: VAR VAR(VAR)   VAR VAR VAR.VAR("" \VAR"").VAR(): VAR VAR(VAR)   VAR = ( VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, ) VAR = VAR((VAR VAR VAR VAR VAR VAR VAR(VAR.VAR(VAR, ())) > 1), VAR) VAR VAR VAR VAR VAR: VAR VAR(VAR""VAR '{VAR}' VAR VAR."") VAR, VAR, VAR = VAR.VAR(VAR=2) VAR = VAR.VAR(VAR) VAR VAR VAR VAR: VAR VAR(VAR) VAR = VAR(VAR(VAR.VAR(1)), VAR(VAR.VAR(2))) VAR, VAR = VAR.VAR(VAR=1) VAR, VAR = VAR.VAR(VAR=1) VAR VAR(VAR) != 3 VAR VAR VAR.VAR(): VAR = VAR(VAR) VAR VAR VAR.VAR(): VAR VAR VAR = VAR(VAR(VAR), 16)   VAR: VAR[VAR[VAR]] = VAR.VAR(VAR""VAR/(\VAR+).(\VAR+)"") VAR: VAR[VAR[VAR]] = VAR.VAR(VAR""[\VAR-\VAR\VAR()<>@,;:\[\]={} \VAR\\\\\""]"") VAR = VAR.VAR(VAR"" \VAR"") VAR = VAR.VAR() VAR = VAR.VAR() VAR: VAR = VAR(VAR) VAR VAR: VAR VAR < 0: VAR VAR(VAR) VAR VAR VAR, VAR, VAR = VAR.VAR(VAR, 2) VAR: VAR VAR.VAR(""VAR/""): VAR, VAR = VAR[5:].VAR(""."", 1) VAR = VAR(VAR(VAR), VAR(VAR)) VAR: VAR VAR(VAR) VAR VAR: VAR VAR(VAR) VAR, VAR = VAR.VAR(VAR, 1) VAR, VAR = VAR.VAR(VAR, 1) VAR: VAR = VAR(VAR) VAR VAR: VAR VAR(VAR) VAR VAR VAR VAR > 999: VAR: VAR = VAR(VAR(VAR), 16) VAR VAR: VAR VAR VAR VAR",1,15
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,frontend/src/components/Preloader.jsx,"export default function PreLoader() {
  return (
    <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
  );
}

export function FullScreenLoader() {
  return (
    <div
      id=""preloader""
      className=""fixed left-0 top-0 z-999999 flex h-screen w-screen items-center justify-center bg-white dark:bg-stone-800""
    >
      <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
    </div>
  );
}",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> ); } VAR VAR VAR() { VAR ( <VAR VAR=""VAR"" VAR=""VAR VAR-0 VAR-0 VAR-999999 VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR:VAR-VAR-800"" > <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> </VAR> ); } ",1,15
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/components/Preloader.jsx,"export default function PreLoader() {
  return (
    <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
  );
}

export function FullScreenLoader() {
  return (
    <div
      id=""preloader""
      className=""fixed left-0 top-0 z-999999 flex h-screen w-screen items-center justify-center bg-white dark:bg-stone-800""
    >
      <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> ); } VAR VAR VAR() { VAR ( <VAR VAR=""VAR"" VAR=""VAR VAR-0 VAR-0 VAR-999999 VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR:VAR-VAR-800"" > <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> </VAR> ); } ",1,15
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/components/Preloader.jsx,"export default function PreLoader() {
  return (
    <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
  );
}

export function FullScreenLoader() {
  return (
    <div
      id=""preloader""
      className=""fixed left-0 top-0 z-999999 flex h-screen w-screen items-center justify-center bg-white dark:bg-stone-800""
    >
      <div className=""h-16 w-16 animate-spin rounded-full border-4 border-solid border-primary border-t-transparent""></div>
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> ); } VAR VAR VAR() { VAR ( <VAR VAR=""VAR"" VAR=""VAR VAR-0 VAR-0 VAR-999999 VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR:VAR-VAR-800"" > <VAR VAR=""VAR-16 VAR-16 VAR-VAR VAR-VAR VAR-4 VAR-VAR VAR-VAR VAR-VAR-VAR""></VAR> </VAR> ); } ",1,15
argo-cd_17f7f4f462bdb233e1b9b36f67099f41052d8cb0,pkg/apiclient/grpcproxy.go,"	randSuffix, err := rand.String(16)
	if err != nil {
		return nil, nil, fmt.Errorf(""failed to generate random socket filename: %w"", err)
	}
	serverAddr := fmt.Sprintf(""%s/argocd-%s.sock"", os.TempDir(), randSuffix)","	serverAddr := fmt.Sprintf(""%s/argocd-%s.sock"", os.TempDir(), rand.RandString(16))",17f7f4f462bdb233e1b9b36f67099f41052d8cb0,CVE-2022-31034,17f7f4f462bdb233e1b9b36f67099f41052d8cb0,https://github.com/argoproj/argo-cd,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR, VAR := VAR.VAR(16) VAR VAR != VAR { VAR VAR, VAR, VAR.VAR(""VAR VAR VAR VAR VAR VAR: %VAR"", VAR) } VAR := VAR.VAR(""%VAR/VAR-%VAR.VAR"", VAR.VAR(), VAR) VAR := VAR.VAR(""%VAR/VAR-%VAR.VAR"", VAR.VAR(), VAR.VAR(16))",1,15
argo-cd_3a28c8a18cc2aa84fe81492625545d25c7a90bc3,docs/operator-manual/upgrading/2.4-2.5.md,"
## `argocd app create` for old CLI versions fails with API version >=2.5.16

Starting with Argo CD 2.5.16, the API returns `PermissionDenied` instead of `NotFound` for Application `GET` requests if
the Application does not exist.

The Argo CD CLI before versions starting with version 2.5.0-rc1 and before versions 2.5.16 and 2.6.7 does a `GET`
request before the `POST` request in `argocd app create`. The command does not gracefully handle the `PermissionDenied`
response and will therefore fail to create/update the Application.

To solve the issue, upgrade the CLI to at least 2.5.16, or 2.6.7.

CLIs older than 2.5.0-rc1 are unaffected.",,3a28c8a18cc2aa84fe81492625545d25c7a90bc3,CVE-2022-41354,3a28c8a18cc2aa84fe81492625545d25c7a90bc3,https://github.com/argoproj/argo-cd,GHSD_DIRECT_COMMIT,1337,COMPLETED," VAR VAR VAR VAR 2.5.16, VAR VAR VAR `VAR` VAR VAR `VAR` VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR 2.5.0-VAR VAR VAR VAR 2.5.16 VAR 2.6.7 VAR VAR `VAR` VAR VAR VAR `VAR` VAR VAR `VAR VAR VAR`. VAR VAR VAR VAR VAR VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR. VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR 2.5.16, VAR 2.6.7. VAR VAR VAR 2.5.0-VAR VAR VAR. ",1,15
argo-cd_3a28c8a18cc2aa84fe81492625545d25c7a90bc3,docs/operator-manual/upgrading/2.5-2.6.md,"
## `argocd app create` for old CLI versions fails with API version >=2.6.7

Starting with Argo CD 2.6.7, the API returns `PermissionDenied` instead of `NotFound` for Application `GET` requests if
the Application does not exist.

The Argo CD CLI before versions starting with version 2.5.0-rc1 and before versions 2.5.16 and 2.6.7 does a `GET`
request before the `POST` request in `argocd app create`. The command does not gracefully handle the `PermissionDenied`
response and will therefore fail to create/update the Application.

To solve the issue, upgrade the CLI to at least 2.5.16, or 2.6.7.

CLIs older than 2.5.0-rc1 are unaffected.
",,3a28c8a18cc2aa84fe81492625545d25c7a90bc3,CVE-2022-41354,3a28c8a18cc2aa84fe81492625545d25c7a90bc3,https://github.com/argoproj/argo-cd,GHSD_DIRECT_COMMIT,1337,COMPLETED," VAR VAR VAR VAR 2.6.7, VAR VAR VAR `VAR` VAR VAR `VAR` VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR 2.5.0-VAR VAR VAR VAR 2.5.16 VAR 2.6.7 VAR VAR `VAR` VAR VAR VAR `VAR` VAR VAR `VAR VAR VAR`. VAR VAR VAR VAR VAR VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR. VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR 2.5.16, VAR 2.6.7. VAR VAR VAR 2.5.0-VAR VAR VAR. ",1,15
cacti_80c2a88fb2afb93f87703ba4641f9970478c102d,tree.php,"			form_selectable_cell($tree['id'], $tree['id'], '', 'right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'right');","			form_selectable_cell($tree['id'], $tree['id'], '', 'text-align:right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'text-align:right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'text-align:right');",80c2a88fb2afb93f87703ba4641f9970478c102d,CVE-2018-20726,80c2a88fb2afb93f87703ba4641f9970478c102d,https://github.com/Cacti/cacti,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR');",1,15
cacti_80c2a88fb2afb93f87703ba4641f9970478c102d,tree.php,"			form_selectable_cell($tree['id'], $tree['id'], '', 'right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'right');","			form_selectable_cell($tree['id'], $tree['id'], '', 'text-align:right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'text-align:right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'text-align:right');",80c2a88fb2afb93f87703ba4641f9970478c102d,CVE-2018-20723,80c2a88fb2afb93f87703ba4641f9970478c102d,https://github.com/Cacti/cacti,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR');",1,15
cacti_80c2a88fb2afb93f87703ba4641f9970478c102d,tree.php,"			form_selectable_cell($tree['id'], $tree['id'], '', 'right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'right');","			form_selectable_cell($tree['id'], $tree['id'], '', 'text-align:right');
			form_selectable_cell(substr($tree['last_modified'],0,16), $tree['id'], '', 'text-align:right');
			form_selectable_cell(get_username($tree['modified_by']), $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['sites'] > 0 ? number_format_i18n($tree['sites'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['branches'] > 0 ? number_format_i18n($tree['branches'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['hosts'] > 0 ? number_format_i18n($tree['hosts'], '-1'):'-', $tree['id'], '', 'text-align:right');
			form_selectable_cell($tree['graphs'] > 0 ? number_format_i18n($tree['graphs'], '-1'):'-', $tree['id'], '', 'text-align:right');",80c2a88fb2afb93f87703ba4641f9970478c102d,CVE-2018-20725,80c2a88fb2afb93f87703ba4641f9970478c102d,https://github.com/Cacti/cacti,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR'); VAR($VAR['VAR'], $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR'],0,16), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR(VAR($VAR['VAR']), $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR'); VAR($VAR['VAR'] > 0 ? VAR($VAR['VAR'], '-1'):'-', $VAR['VAR'], '', 'VAR-VAR:VAR');",1,15
cpython_225e3659556616ad70186e7efc02baeebfeb5ec4,Litest/test_plistlib.py,"import struct
INVALID_BINARY_PLISTS = [
    ('too short data',
        b''
    ),
    ('too large offset_table_offset and offset_size = 1',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x2a'
    ),
    ('too large offset_table_offset and nonstandard offset_size',
        b'\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x03\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x2c'
    ),
    ('integer overflow in offset_table_offset',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\xff\xff\xff\xff\xff\xff\xff\xff'
    ),
    ('too large top_object',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('integer overflow in top_object',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\xff\xff\xff\xff\xff\xff\xff\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('too large num_objects and offset_size = 1',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('too large num_objects and nonstandard offset_size',
        b'\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x03\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('extremally large num_objects (32 bit)',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x7f\xff\xff\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('extremally large num_objects (64 bit)',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\xff\xff\xff\xff\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('integer overflow in num_objects',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\xff\xff\xff\xff\xff\xff\xff\xff'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('offset_size = 0',
        b'\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('ref_size = 0',
        b'\xa1\x01\x00\x08\x0a'
        b'\x00\x00\x00\x00\x00\x00\x01\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0b'
    ),
    ('too large offset',
        b'\x00\x2a'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('integer overflow in offset',
        b'\x00\xff\xff\xff\xff\xff\xff\xff\xff'
        b'\x00\x00\x00\x00\x00\x00\x08\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x09'
    ),
    ('too large array size',
        b'\xaf\x00\x01\xff\x00\x08\x0c'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0d'
    ),
    ('extremally large array size (32-bit)',
        b'\xaf\x02\x7f\xff\xff\xff\x01\x00\x08\x0f'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x10'
    ),
    ('extremally large array size (64-bit)',
        b'\xaf\x03\x00\x00\x00\xff\xff\xff\xff\xff\x01\x00\x08\x13'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x14'
    ),
    ('integer overflow in array size',
        b'\xaf\x03\xff\xff\xff\xff\xff\xff\xff\xff\x01\x00\x08\x13'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x14'
    ),
    ('too large reference index',
        b'\xa1\x02\x00\x08\x0a'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0b'
    ),
    ('integer overflow in reference index',
        b'\xa1\xff\xff\xff\xff\xff\xff\xff\xff\x00\x08\x11'
        b'\x00\x00\x00\x00\x00\x00\x01\x08'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x12'
    ),
    ('too large bytes size',
        b'\x4f\x00\x23\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0c'
    ),
    ('extremally large bytes size (32-bit)',
        b'\x4f\x02\x7f\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0f'
    ),
    ('extremally large bytes size (64-bit)',
        b'\x4f\x03\x00\x00\x00\xff\xff\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x13'
    ),
    ('integer overflow in bytes size',
        b'\x4f\x03\xff\xff\xff\xff\xff\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x13'
    ),
    ('too large ASCII size',
        b'\x5f\x00\x23\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0c'
    ),
    ('extremally large ASCII size (32-bit)',
        b'\x5f\x02\x7f\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0f'
    ),
    ('extremally large ASCII size (64-bit)',
        b'\x5f\x03\x00\x00\x00\xff\xff\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x13'
    ),
    ('integer overflow in ASCII size',
        b'\x5f\x03\xff\xff\xff\xff\xff\xff\xff\xff\x41\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x13'
    ),
    ('invalid ASCII',
        b'\x51\xff\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0a'
    ),
    ('too large UTF-16 size',
        b'\x6f\x00\x13\x20\xac\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0e'
    ),
    ('extremally large UTF-16 size (32-bit)',
        b'\x6f\x02\x4f\xff\xff\xff\x20\xac\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x11'
    ),
    ('extremally large UTF-16 size (64-bit)',
        b'\x6f\x03\x00\x00\x00\xff\xff\xff\xff\xff\x20\xac\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x15'
    ),
    ('integer overflow in UTF-16 size',
        b'\x6f\x03\xff\xff\xff\xff\xff\xff\xff\xff\x20\xac\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x15'
    ),
    ('invalid UTF-16',
        b'\x61\xd8\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0b'
    ),
    ('non-hashable key',
        b'\xd1\x01\x01\xa0\x08\x0b'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x02'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x0c'
    ),
    ('too large datetime (datetime overflow)',
        b'\x33\x42\x50\x00\x00\x00\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x11'
    ),
    ('too large datetime (timedelta overflow)',
        b'\x33\x42\xe0\x00\x00\x00\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x11'
    ),
    ('invalid datetime (Infinity)',
        b'\x33\x7f\xf0\x00\x00\x00\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x11'
    ),
    ('invalid datetime (NaN)',
        b'\x33\x7f\xf8\x00\x00\x00\x00\x00\x00\x08'
        b'\x00\x00\x00\x00\x00\x00\x01\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x01'
        b'\x00\x00\x00\x00\x00\x00\x00\x00'
        b'\x00\x00\x00\x00\x00\x00\x00\x11'
    ),
]

    @staticmethod
    def decode(*objects, offset_size=1, ref_size=1):
        data = [b'bplist00']
        offset = 8
        offsets = []
        for x in objects:
            offsets.append(offset.to_bytes(offset_size, 'big'))
            data.append(x)
            offset += len(x)
        tail = struct.pack('>6xBBQQQ', offset_size, ref_size,
                           len(objects), 0, offset)
        data.extend(offsets)
        data.append(tail)
        return plistlib.loads(b''.join(data), fmt=plistlib.FMT_BINARY)

        for x in (None, False, True, 12345, 123.45, 'abcde', 'абвгд', b'abcde',
    def test_deep_nesting(self):
        for N in [300, 100000]:
            chunks = [b'\xa1' + (i + 1).to_bytes(4, 'big') for i in range(N)]
            try:
                result = self.decode(*chunks, b'\x54seed', offset_size=4, ref_size=4)
            except RecursionError:
                pass
            else:
                for i in range(N):
                    self.assertIsInstance(result, list)
                    self.assertEqual(len(result), 1)
                    result = result[0]
                self.assertEqual(result, 'seed')

    def test_load_singletons(self):
        self.assertIs(self.decode(b'\x00'), None)
        self.assertIs(self.decode(b'\x08'), False)
        self.assertIs(self.decode(b'\x09'), True)
        self.assertEqual(self.decode(b'\x0f'), b'')

    def test_load_int(self):
        self.assertEqual(self.decode(b'\x10\x00'), 0)
        self.assertEqual(self.decode(b'\x10\xfe'), 0xfe)
        self.assertEqual(self.decode(b'\x11\xfe\xdc'), 0xfedc)
        self.assertEqual(self.decode(b'\x12\xfe\xdc\xba\x98'), 0xfedcba98)
        self.assertEqual(self.decode(b'\x13\x01\x23\x45\x67\x89\xab\xcd\xef'),
                         0x0123456789abcdef)
        self.assertEqual(self.decode(b'\x13\xfe\xdc\xba\x98\x76\x54\x32\x10'),
                         -0x123456789abcdf0)

    def test_unsupported(self):
        unsupported = [*range(1, 8), *range(10, 15),
                       0x20, 0x21, *range(0x24, 0x33), *range(0x34, 0x40)]
        for i in [0x70, 0x90, 0xb0, 0xc0, 0xe0, 0xf0]:
            unsupported.extend(i + j for j in range(16))
        for token in unsupported:
            with self.subTest(f'token {token:02x}'):
                with self.assertRaises(plistlib.InvalidFileException):
                    self.decode(bytes([token]) + b'\x00'*16)

        for name, data in INVALID_BINARY_PLISTS:
            with self.subTest(name):
                with self.assertRaises(plistlib.InvalidFileException):
                    plistlib.loads(b'bplist00' + data, fmt=plistlib.FMT_BINARY)
    unittest.main()","        for x in (None, False, True, 12345, 123.45, 'abcde', b'abcde',
        for data in [
                # too short data
                b'',
                # too large offset_table_offset and nonstandard offset_size
                b'\x00\x08'
                b'\x00\x00\x00\x00\x00\x00\x03\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x2a',
                # integer overflow in offset_table_offset
                b'\x00\x08'
                b'\x00\x00\x00\x00\x00\x00\x01\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\xff\xff\xff\xff\xff\xff\xff\xff',
                # offset_size = 0
                b'\x00\x08'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x09',
                # ref_size = 0
                b'\xa1\x01\x00\x08\x0a'
                b'\x00\x00\x00\x00\x00\x00\x01\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x02'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x0b',
                # integer overflow in offset
                b'\x00\xff\xff\xff\xff\xff\xff\xff\xff'
                b'\x00\x00\x00\x00\x00\x00\x08\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x09',
                # invalid ASCII
                b'\x51\xff\x08'
                b'\x00\x00\x00\x00\x00\x00\x01\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x0a',
                # invalid UTF-16
                b'\x61\xd8\x00\x08'
                b'\x00\x00\x00\x00\x00\x00\x01\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x01'
                b'\x00\x00\x00\x00\x00\x00\x00\x00'
                b'\x00\x00\x00\x00\x00\x00\x00\x0b',
                ]:
            with self.assertRaises(plistlib.InvalidFileException):
                plistlib.loads(b'bplist00' + data, fmt=plistlib.FMT_BINARY)
def test_main():
    support.run_unittest(TestPlistlib, TestPlistlibDeprecated, MiscTestCase)


    test_main()",225e3659556616ad70186e7efc02baeebfeb5ec4,CVE-2022-48564,225e3659556616ad70186e7efc02baeebfeb5ec4,https://github.com/python/cpython,CPE_GIT_REPOBASED,128,COMPLETED,"VAR VAR VAR = [ ('VAR VAR VAR', VAR'' ), ('VAR VAR VAR VAR VAR = 1', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR = 1', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR (32 VAR)', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR (64 VAR)', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR = 0', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR = 0', VAR'\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR', VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (32-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (64-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (32-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (64-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (32-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR (64-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR', VAR'\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR-16 VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR-16 VAR (32-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR-16 VAR (64-VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR VAR-16 VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR-16', VAR'\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR-VAR VAR', VAR'\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR (VAR VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR VAR (VAR VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR (VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ('VAR VAR (VAR)', VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' ), ] @VAR VAR VAR(*VAR, VAR=1, VAR=1): VAR = [VAR'VAR'] VAR = 8 VAR = [] VAR VAR VAR VAR: VAR.VAR(VAR.VAR(VAR, 'VAR')) VAR.VAR(VAR) VAR += VAR(VAR) VAR = VAR.VAR('>6xBBQQQ', VAR, VAR, VAR(VAR), 0, VAR) VAR.VAR(VAR) VAR.VAR(VAR) VAR VAR.VAR(VAR''.VAR(VAR), VAR=VAR.VAR) VAR VAR VAR (VAR, VAR, VAR, 12345, 123.45, 'VAR', 'абвгд', VAR'VAR', VAR VAR(VAR): VAR VAR VAR [300, 100000]: VAR = [VAR'\VAR' + (VAR + 1).VAR(4, 'VAR') VAR VAR VAR VAR(VAR)] VAR: VAR = VAR.VAR(*VAR, VAR'\VAR', VAR=4, VAR=4) VAR VAR: VAR VAR: VAR VAR VAR VAR(VAR): VAR.VAR(VAR, VAR) VAR.VAR(VAR(VAR), 1) VAR = VAR[0] VAR.VAR(VAR, 'VAR') VAR VAR(VAR): VAR.VAR(VAR.VAR(VAR'\VAR'), VAR) VAR.VAR(VAR.VAR(VAR'\VAR'), VAR) VAR.VAR(VAR.VAR(VAR'\VAR'), VAR) VAR.VAR(VAR.VAR(VAR'\VAR'), VAR'') VAR VAR(VAR): VAR.VAR(VAR.VAR(VAR'\VAR\VAR'), 0) VAR.VAR(VAR.VAR(VAR'\VAR\VAR'), 0xfe) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR'), 0xfedc) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR'), 0xfedcba98) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR'), 0x0123456789abcdef) VAR.VAR(VAR.VAR(VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR'), -0x123456789abcdf0) VAR VAR(VAR): VAR = [*VAR(1, 8), *VAR(10, 15), 0x20, 0x21, *VAR(0x24, 0x33), *VAR(0x34, 0x40)] VAR VAR VAR [0x70, 0x90, 0xb0, 0xc0, 0xe0, 0xf0]: VAR.VAR(VAR + VAR VAR VAR VAR VAR(16)) VAR VAR VAR VAR: VAR VAR.VAR(VAR'VAR {VAR:02x}'): VAR VAR.VAR(VAR.VAR): VAR.VAR(VAR([VAR]) + VAR'\VAR'*16) VAR VAR, VAR VAR VAR: VAR VAR.VAR(VAR): VAR VAR.VAR(VAR.VAR): VAR.VAR(VAR'VAR' + VAR, VAR=VAR.VAR) VAR.VAR() VAR VAR VAR (VAR, VAR, VAR, 12345, 123.45, 'VAR', VAR'VAR', VAR VAR VAR [  VAR'',  VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR',  VAR'\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR' VAR'\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR', ]: VAR VAR.VAR(VAR.VAR): VAR.VAR(VAR'VAR' + VAR, VAR=VAR.VAR) VAR VAR(): VAR.VAR(VAR, VAR, VAR) VAR()",1,15
envoy_79984e40b456f30cfb53564c4afe955aea19f9f9,docs/root/version_history/version_history.rst,  v1.16.0,,79984e40b456f30cfb53564c4afe955aea19f9f9,CVE-2020-35471,79984e40b456f30cfb53564c4afe955aea19f9f9,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,104,COMPLETED,VAR.16.0 ,1,15
FFmpeg_21270cffaeab2f67a613907516b2b0cd6c9eacf4,libavcodec/mpegvideo.c,"                for(i=0; i<avctx->height; i++)
                    memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, avctx->width);","                for(i=0; i<s->height; i++)
                    memset(s->last_picture_ptr->f.data[0] + s->last_picture_ptr->f.linesize[0]*i, 16, s->width);",21270cffaeab2f67a613907516b2b0cd6c9eacf4,CVE-2012-0856,21270cffaeab2f67a613907516b2b0cd6c9eacf4,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,90,COMPLETED,"VAR(VAR=0; VAR<VAR->VAR; VAR++) VAR(VAR->VAR->VAR.VAR[0] + VAR->VAR->VAR.VAR[0]*VAR, 16, VAR->VAR); VAR(VAR=0; VAR<VAR->VAR; VAR++) VAR(VAR->VAR->VAR.VAR[0] + VAR->VAR->VAR.VAR[0]*VAR, 16, VAR->VAR);",1,15
FFmpeg_4565747056a11356210ed8edcecb920105e40b60,libavcodec/evc_ps.c,"static int ref_pic_list_struct(EVCParserSPS *sps, GetBitContext *gb, RefPicListStruct *rpl)

    if ((unsigned)rpl->ref_pic_num  > sps->sps_max_dec_pic_buffering_minus1)
        return AVERROR_INVALIDDATA;

        if ((unsigned)sps->sps_max_dec_pic_buffering_minus1 > 16 - 1)
            return AVERROR_INVALIDDATA;
        for (int i = 0; i < sps->num_ref_pic_list_in_sps[0]; ++i) {
            ret = ref_pic_list_struct(sps, gb, &sps->rpls[0][i]);
            if (ret < 0)
                goto fail;
        }
            for (int i = 0; i < sps->num_ref_pic_list_in_sps[1]; ++i) {
                ret = ref_pic_list_struct(sps, gb, &sps->rpls[1][i]);
                if (ret < 0)
                    goto fail;
            }","static int ref_pic_list_struct(GetBitContext *gb, RefPicListStruct *rpl)
        for (int i = 0; i < sps->num_ref_pic_list_in_sps[0]; ++i)
            ref_pic_list_struct(gb, &sps->rpls[0][i]);
            for (int i = 0; i < sps->num_ref_pic_list_in_sps[1]; ++i)
                ref_pic_list_struct(gb, &sps->rpls[1][i]);",4565747056a11356210ed8edcecb920105e40b60,CVE-2023-47470,4565747056a11356210ed8edcecb920105e40b60,https://github.com/FFmpeg/FFmpeg,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR) VAR ((VAR)VAR->VAR > VAR->VAR) VAR VAR; VAR ((VAR)VAR->VAR > 16 - 1) VAR VAR; VAR (VAR VAR = 0; VAR < VAR->VAR[0]; ++VAR) { VAR = VAR(VAR, VAR, &VAR->VAR[0][VAR]); VAR (VAR < 0) VAR VAR; } VAR (VAR VAR = 0; VAR < VAR->VAR[1]; ++VAR) { VAR = VAR(VAR, VAR, &VAR->VAR[1][VAR]); VAR (VAR < 0) VAR VAR; } VAR VAR VAR(VAR *VAR, VAR *VAR) VAR (VAR VAR = 0; VAR < VAR->VAR[0]; ++VAR) VAR(VAR, &VAR->VAR[0][VAR]); VAR (VAR VAR = 0; VAR < VAR->VAR[1]; ++VAR) VAR(VAR, &VAR->VAR[1][VAR]);",1,15
FFmpeg_47b7c68ae54560e2308bdb6be4fb076c73b93081,libavcodec/utvideodec.c,"        c->pro         = 1;
        c->pro         = 1;
        c->pro         = 1;
    } else if (!c->pro && avctx->extradata_size >= 16) {
    } else if (c->pro && avctx->extradata_size == 8) {","    } else if (avctx->extradata_size >= 16) {
    } else if (avctx->extradata_size == 8) {
        c->pro         = 1;",47b7c68ae54560e2308bdb6be4fb076c73b93081,CVE-2018-10001,47b7c68ae54560e2308bdb6be4fb076c73b93081,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,88,COMPLETED,VAR->VAR = 1; VAR->VAR = 1; VAR->VAR = 1; } VAR VAR (!VAR->VAR && VAR->VAR >= 16) { } VAR VAR (VAR->VAR && VAR->VAR == 8) { } VAR VAR (VAR->VAR >= 16) { } VAR VAR (VAR->VAR == 8) { VAR->VAR = 1;,1,15
FFmpeg_73472053516f82b7d273a3d42c583f894077a191,libavcodec/qdm2.c,"    int i, out_size;
    out_size = 16 * s->channels * s->frame_size *
               av_get_bytes_per_sample(avctx->sample_fmt);
    if (*data_size < out_size) {
        av_log(avctx, AV_LOG_ERROR, ""Output buffer is too small\n"");
        return AVERROR(EINVAL);
    }

    *data_size = out_size;","    int i;
    *data_size = (uint8_t*)out - (uint8_t*)data;",73472053516f82b7d273a3d42c583f894077a191,CVE-2011-4351,73472053516f82b7d273a3d42c583f894077a191,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,70,COMPLETED,"VAR VAR, VAR; VAR = 16 * VAR->VAR * VAR->VAR * VAR(VAR->VAR); VAR (*VAR < VAR) { VAR(VAR, VAR, ""VAR VAR VAR VAR VAR\VAR""); VAR VAR(VAR); } *VAR = VAR; VAR VAR; *VAR = (VAR*)VAR - (VAR*)VAR;",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/ansi.c,"#include ""libavutil/frame.h""
    AVFrame *frame;
    s->frame = av_frame_alloc();
    if (!s->frame)
        return AVERROR(ENOMEM);

        memcpy(s->frame->data[0] + i * s->frame->linesize[0],
               s->frame->data[0] + (i + s->font_height) * s->frame->linesize[0],
        memset(s->frame->data[0] + i * s->frame->linesize[0],
        memset(s->frame->data[0] + (s->y + i)*s->frame->linesize[0] + xoffset,
        memset(s->frame->data[0] + i * s->frame->linesize[0], DEFAULT_BG_COLOR, avctx->width);
    ff_draw_pc_font(s->frame->data[0] + s->y * s->frame->linesize[0] + s->x,
                    s->frame->linesize[0], s->font, s->font_height, c, fg, bg);
            av_frame_unref(s->frame);
            ret = ff_get_buffer(avctx, s->frame, AV_GET_BUFFER_FLAG_REF);
            s->frame->pict_type           = AV_PICTURE_TYPE_I;
            s->frame->palette_has_changed = 1;
            memcpy(s->frame->data[1], ff_cga_palette, 16 * 4);
                memset(s->frame->data[0] + (s->y + s->font_height)*s->frame->linesize[0],
                    DEFAULT_BG_COLOR, (avctx->height - s->y - s->font_height)*s->frame->linesize[0]);
                memset(s->frame->data[0], DEFAULT_BG_COLOR, s->y * s->frame->linesize[0]);
    ret = ff_reget_buffer(avctx, s->frame);
        memset(s->frame->data[0], 0, avctx->height * FFABS(s->frame->linesize[0]));
        memset(s->frame->data[1], 0, AVPALETTE_SIZE);
    s->frame->pict_type           = AV_PICTURE_TYPE_I;
    s->frame->palette_has_changed = 1;
    memcpy(s->frame->data[1], ff_cga_palette, 16 * 4);
    if ((ret = av_frame_ref(data, s->frame)) < 0)
        return ret;

    av_frame_free(&s->frame);","    AVFrame frame;
        memcpy(s->frame.data[0] + i * s->frame.linesize[0],
               s->frame.data[0] + (i + s->font_height) * s->frame.linesize[0],
        memset(s->frame.data[0] + i * s->frame.linesize[0],
        memset(s->frame.data[0] + (s->y + i)*s->frame.linesize[0] + xoffset,
        memset(s->frame.data[0] + i * s->frame.linesize[0], DEFAULT_BG_COLOR, avctx->width);
    ff_draw_pc_font(s->frame.data[0] + s->y * s->frame.linesize[0] + s->x,
                    s->frame.linesize[0], s->font, s->font_height, c, fg, bg);
            if (s->frame.data[0])
                avctx->release_buffer(avctx, &s->frame);
            ret = ff_get_buffer(avctx, &s->frame);
            s->frame.pict_type           = AV_PICTURE_TYPE_I;
            s->frame.palette_has_changed = 1;
            memcpy(s->frame.data[1], ff_cga_palette, 16 * 4);
                memset(s->frame.data[0] + (s->y + s->font_height)*s->frame.linesize[0],
                    DEFAULT_BG_COLOR, (avctx->height - s->y - s->font_height)*s->frame.linesize[0]);
                memset(s->frame.data[0], DEFAULT_BG_COLOR, s->y * s->frame.linesize[0]);
    ret = avctx->reget_buffer(avctx, &s->frame);
        memset(s->frame.data[0], 0, avctx->height * FFABS(s->frame.linesize[0]));
        memset(s->frame.data[1], 0, AVPALETTE_SIZE);
    s->frame.pict_type           = AV_PICTURE_TYPE_I;
    s->frame.palette_has_changed = 1;
    memcpy(s->frame.data[1], ff_cga_palette, 16 * 4);
    *(AVFrame*)data = s->frame;
    if (s->frame.data[0])
        avctx->release_buffer(avctx, &s->frame);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED," VAR *VAR; VAR->VAR = VAR(); VAR (!VAR->VAR) VAR VAR(VAR); VAR(VAR->VAR->VAR[0] + VAR * VAR->VAR->VAR[0], VAR->VAR->VAR[0] + (VAR + VAR->VAR) * VAR->VAR->VAR[0], VAR(VAR->VAR->VAR[0] + VAR * VAR->VAR->VAR[0], VAR(VAR->VAR->VAR[0] + (VAR->VAR + VAR)*VAR->VAR->VAR[0] + VAR, VAR(VAR->VAR->VAR[0] + VAR * VAR->VAR->VAR[0], VAR, VAR->VAR); VAR(VAR->VAR->VAR[0] + VAR->VAR * VAR->VAR->VAR[0] + VAR->VAR, VAR->VAR->VAR[0], VAR->VAR, VAR->VAR, VAR, VAR, VAR); VAR(VAR->VAR); VAR = VAR(VAR, VAR->VAR, VAR); VAR->VAR->VAR = VAR; VAR->VAR->VAR = 1; VAR(VAR->VAR->VAR[1], VAR, 16 * 4); VAR(VAR->VAR->VAR[0] + (VAR->VAR + VAR->VAR)*VAR->VAR->VAR[0], VAR, (VAR->VAR - VAR->VAR - VAR->VAR)*VAR->VAR->VAR[0]); VAR(VAR->VAR->VAR[0], VAR, VAR->VAR * VAR->VAR->VAR[0]); VAR = VAR(VAR, VAR->VAR); VAR(VAR->VAR->VAR[0], 0, VAR->VAR * VAR(VAR->VAR->VAR[0])); VAR(VAR->VAR->VAR[1], 0, VAR); VAR->VAR->VAR = VAR; VAR->VAR->VAR = 1; VAR(VAR->VAR->VAR[1], VAR, 16 * 4); VAR ((VAR = VAR(VAR, VAR->VAR)) < 0) VAR VAR; VAR(&VAR->VAR); VAR VAR; VAR(VAR->VAR.VAR[0] + VAR * VAR->VAR.VAR[0], VAR->VAR.VAR[0] + (VAR + VAR->VAR) * VAR->VAR.VAR[0], VAR(VAR->VAR.VAR[0] + VAR * VAR->VAR.VAR[0], VAR(VAR->VAR.VAR[0] + (VAR->VAR + VAR)*VAR->VAR.VAR[0] + VAR, VAR(VAR->VAR.VAR[0] + VAR * VAR->VAR.VAR[0], VAR, VAR->VAR); VAR(VAR->VAR.VAR[0] + VAR->VAR * VAR->VAR.VAR[0] + VAR->VAR, VAR->VAR.VAR[0], VAR->VAR, VAR->VAR, VAR, VAR, VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR = VAR(VAR, &VAR->VAR); VAR->VAR.VAR = VAR; VAR->VAR.VAR = 1; VAR(VAR->VAR.VAR[1], VAR, 16 * 4); VAR(VAR->VAR.VAR[0] + (VAR->VAR + VAR->VAR)*VAR->VAR.VAR[0], VAR, (VAR->VAR - VAR->VAR - VAR->VAR)*VAR->VAR.VAR[0]); VAR(VAR->VAR.VAR[0], VAR, VAR->VAR * VAR->VAR.VAR[0]); VAR = VAR->VAR(VAR, &VAR->VAR); VAR(VAR->VAR.VAR[0], 0, VAR->VAR * VAR(VAR->VAR.VAR[0])); VAR(VAR->VAR.VAR[1], 0, VAR); VAR->VAR.VAR = VAR; VAR->VAR.VAR = 1; VAR(VAR->VAR.VAR[1], VAR, 16 * 4); *(VAR*)VAR = VAR->VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR);",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/asvdec.c,"static inline void idct_put(ASV1Context *a, AVFrame *frame, int mb_x, int mb_y)
    int linesize         = frame->linesize[0];
    uint8_t *dest_y  = frame->data[0] + (mb_y * 16* linesize              ) + mb_x * 16;
    uint8_t *dest_cb = frame->data[1] + (mb_y * 8 * frame->linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = frame->data[2] + (mb_y * 8 * frame->linesize[2]) + mb_x * 8;
        a->dsp.idct_put(dest_cb, frame->linesize[1], block[4]);
        a->dsp.idct_put(dest_cr, frame->linesize[2], block[5]);
    AVFrame * const p     = data;
    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {
            idct_put(a, p, mb_x, mb_y);
            idct_put(a, p, mb_x, mb_y);
            idct_put(a, p, mb_x, mb_y);","static inline void idct_put(ASV1Context *a, int mb_x, int mb_y)
    int linesize         = a->picture.linesize[0];
    uint8_t *dest_y  = a->picture.data[0] + (mb_y * 16* linesize              ) + mb_x * 16;
    uint8_t *dest_cb = a->picture.data[1] + (mb_y * 8 * a->picture.linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = a->picture.data[2] + (mb_y * 8 * a->picture.linesize[2]) + mb_x * 8;
        a->dsp.idct_put(dest_cb, a->picture.linesize[1], block[4]);
        a->dsp.idct_put(dest_cr, a->picture.linesize[2], block[5]);
    AVFrame *picture      = data;
    AVFrame * const p     = &a->picture;
    if (p->data[0])
        avctx->release_buffer(avctx, p);

    p->reference = 0;
    if ((ret = ff_get_buffer(avctx, p)) < 0) {
            idct_put(a, mb_x, mb_y);
            idct_put(a, mb_x, mb_y);
            idct_put(a, mb_x, mb_y);
    *picture   = a->picture;
    AVFrame *p            = &a->picture;
    p->qstride      = a->mb_width;
    p->qscale_table = av_malloc(p->qstride * a->mb_height);
    p->quality      = (32 * scale + a->inv_qscale / 2) / a->inv_qscale;
    memset(p->qscale_table, p->quality, p->qstride * a->mb_height);

    av_freep(&a->picture.qscale_table);
    if (a->picture.data[0])
        avctx->release_buffer(avctx, &a->picture);
",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR) VAR VAR = VAR->VAR[0]; VAR *VAR = VAR->VAR[0] + (VAR * 16* VAR ) + VAR * 16; VAR *VAR = VAR->VAR[1] + (VAR * 8 * VAR->VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR[2] + (VAR * 8 * VAR->VAR[2]) + VAR * 8; VAR->VAR.VAR(VAR, VAR->VAR[1], VAR[4]); VAR->VAR.VAR(VAR, VAR->VAR[2], VAR[5]); VAR * VAR VAR = VAR; VAR ((VAR = VAR(VAR, VAR, 0)) < 0) { VAR(VAR, VAR, VAR, VAR); VAR(VAR, VAR, VAR, VAR); VAR(VAR, VAR, VAR, VAR); VAR VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR) VAR VAR = VAR->VAR.VAR[0]; VAR *VAR = VAR->VAR.VAR[0] + (VAR * 16* VAR ) + VAR * 16; VAR *VAR = VAR->VAR.VAR[1] + (VAR * 8 * VAR->VAR.VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR.VAR[2] + (VAR * 8 * VAR->VAR.VAR[2]) + VAR * 8; VAR->VAR.VAR(VAR, VAR->VAR.VAR[1], VAR[4]); VAR->VAR.VAR(VAR, VAR->VAR.VAR[2], VAR[5]); VAR *VAR = VAR; VAR * VAR VAR = &VAR->VAR; VAR (VAR->VAR[0]) VAR->VAR(VAR, VAR); VAR->VAR = 0; VAR ((VAR = VAR(VAR, VAR)) < 0) { VAR(VAR, VAR, VAR); VAR(VAR, VAR, VAR); VAR(VAR, VAR, VAR); *VAR = VAR->VAR; VAR *VAR = &VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR(VAR->VAR * VAR->VAR); VAR->VAR = (32 * VAR + VAR->VAR / 2) / VAR->VAR; VAR(VAR->VAR, VAR->VAR, VAR->VAR * VAR->VAR); VAR(&VAR->VAR.VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR);",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/avcodec.h,"#if FF_API_GET_BUFFER
#endif

/**
 * The decoder will keep a reference to the frame and may reuse it later.
 */
#define AV_GET_BUFFER_FLAG_REF (1 << 0)
#if FF_API_GET_BUFFER
     *
     * @deprecated use get_buffer2()
    attribute_deprecated
     *
     * @deprecated custom freeing callbacks should be set from get_buffer2()
    attribute_deprecated
    attribute_deprecated
#endif
    /**
     * This callback is called at the beginning of each frame to get data
     * buffer(s) for it. There may be one contiguous buffer for all the data or
     * there may be a buffer per each data plane or anything in between. Each
     * buffer must be reference-counted using the AVBuffer API.
     *
     * The following fields will be set in the frame before this callback is
     * called:
     * - format
     * - width, height (video only)
     * - sample_rate, channel_layout, nb_samples (audio only)
     * Their values may differ from the corresponding values in
     * AVCodecContext. This callback must use the frame values, not the codec
     * context values, to calculate the required buffer size.
     *
     * This callback must fill the following fields in the frame:
     * - data[]
     * - linesize[]
     * - extended_data:
     *   * if the data is planar audio with more than 8 channels, then this
     *     callback must allocate and fill extended_data to contain all pointers
     *     to all data planes. data[] must hold as many pointers as it can.
     *     extended_data must be allocated with av_malloc() and will be freed in
     *     av_frame_unref().
     *   * otherwise exended_data must point to data
     * - buf[] must contain references to the buffers that contain the frame
     *   data.
     * - extended_buf and nb_extended_buf must be allocated with av_malloc() by
     *   this callback and filled with the extra buffers if there are more
     *   buffers than buf[] can hold. extended_buf will be freed in
     *   av_frame_unref().
     *
     * If CODEC_CAP_DR1 is not set then get_buffer2() must call
     * avcodec_default_get_buffer2() instead of providing buffers allocated by
     * some other means.
     *
     * Each data plane must be aligned to the maximum required by the target
     * CPU.
     *
     * @see avcodec_default_get_buffer2()
     *
     * Video:
     *
     * If AV_GET_BUFFER_FLAG_REF is set in flags then the frame may be reused
     * (read and/or written to if it is writable) later by libavcodec.
     *
     * If CODEC_FLAG_EMU_EDGE is not set in s->flags, the buffer must contain an
     * edge of the size returned by avcodec_get_edge_width() on all sides.
     *
     * avcodec_align_dimensions2() should be used to find the required width and
     * height, as they normally need to be rounded up to the next multiple of 16.
     *
     * If frame multithreading is used and thread_safe_callbacks is set,
     * this callback may be called from a different thread, but not from more
     * than one at once. Does not need to be reentrant.
     *
     * @see avcodec_align_dimensions2()
     *
     * Audio:
     *
     * Decoders request a buffer of a particular size by setting
     * AVFrame.nb_samples prior to calling get_buffer2(). The decoder may,
     * however, utilize only part of the buffer by setting AVFrame.nb_samples
     * to a smaller value in the output frame.
     *
     * As a convenience, av_samples_get_buffer_size() and
     * av_samples_fill_arrays() in libavutil may be used by custom get_buffer2()
     * functions to find the required data size and to fill data pointers and
     * linesize. In AVFrame.linesize, only linesize[0] may be set for audio
     * since all planes must be the same size.
     *
     * @see av_samples_get_buffer_size(), av_samples_fill_arrays()
     *
     * - encoding: unused
     * - decoding: Set by libavcodec, user can override.
     */
    int (*get_buffer2)(struct AVCodecContext *s, AVFrame *frame, int flags);

    /**
     * If non-zero, the decoded audio and video frames returned from
     * avcodec_decode_video2() and avcodec_decode_audio4() are reference-counted
     * and are valid indefinitely. The caller must free them with
     * av_frame_unref() when they are not needed anymore.
     * Otherwise, the decoded frames must not be freed by the caller and are
     * only valid until the next decode call.
     *
     * - encoding: unused
     * - decoding: set by the caller before avcodec_open2().
     */
    int refcounted_frames;
#if FF_API_GET_BUFFER
attribute_deprecated int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic);
attribute_deprecated void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic);
attribute_deprecated int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic);
#endif

/**
 * The default callback for AVCodecContext.get_buffer2(). It is made public so
 * it can be called by custom get_buffer2() implementations for decoders without
 * CODEC_CAP_DR1 set.
 */
int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags);","int avcodec_default_get_buffer(AVCodecContext *s, AVFrame *pic);
void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic);
int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic);
void avcodec_default_free_buffers(AVCodecContext *s);
",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"  /** * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. */   * * @VAR VAR VAR() VAR * * @VAR VAR VAR VAR VAR VAR VAR VAR VAR() VAR VAR  /** * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR(VAR) VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR * VAR VAR VAR VAR-VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR: * - VAR * - VAR, VAR (VAR VAR) * - VAR, VAR, VAR (VAR VAR) * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR * VAR VAR, VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: * - VAR[] * - VAR[] * - VAR: * * VAR VAR VAR VAR VAR VAR VAR VAR VAR 8 VAR, VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR. VAR[] VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR() VAR VAR VAR VAR VAR * VAR(). * * VAR VAR VAR VAR VAR VAR * - VAR[] VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. * - VAR VAR VAR VAR VAR VAR VAR VAR() VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR[] VAR VAR. VAR VAR VAR VAR VAR * VAR(). * * VAR VAR VAR VAR VAR VAR VAR() VAR VAR * VAR() VAR VAR VAR VAR VAR VAR * VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. * * @VAR VAR() * * VAR: * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * (VAR VAR/VAR VAR VAR VAR VAR VAR VAR) VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR->VAR, VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR() VAR VAR VAR. * * VAR() VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 16. * * VAR VAR VAR VAR VAR VAR VAR VAR VAR, * VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR * VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR. * * @VAR VAR() * * VAR: * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR.VAR VAR VAR VAR VAR(). VAR VAR VAR, * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR * VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR, VAR() VAR * VAR() VAR VAR VAR VAR VAR VAR VAR VAR() * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. VAR VAR.VAR, VAR VAR[0] VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR. * * @VAR VAR(), VAR() * * - VAR: VAR * - VAR: VAR VAR VAR, VAR VAR VAR. */ VAR (*VAR)(VAR VAR *VAR, VAR *VAR, VAR VAR); /** * VAR VAR-VAR, VAR VAR VAR VAR VAR VAR VAR VAR * VAR() VAR VAR() VAR VAR-VAR * VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR * VAR() VAR VAR VAR VAR VAR VAR. * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR. * * - VAR: VAR * - VAR: VAR VAR VAR VAR VAR VAR(). */ VAR VAR;  VAR VAR VAR(VAR *VAR, VAR *VAR); VAR VAR VAR(VAR *VAR, VAR *VAR); VAR VAR VAR(VAR *VAR, VAR *VAR);  /** * VAR VAR VAR VAR VAR.VAR(). VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR() VAR VAR VAR VAR * VAR VAR. */ VAR VAR(VAR *VAR, VAR *VAR, VAR VAR); VAR VAR(VAR *VAR, VAR *VAR); VAR VAR(VAR *VAR, VAR *VAR); VAR VAR(VAR *VAR, VAR *VAR); VAR VAR(VAR *VAR);",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/eamad.c,"static inline void comp_block(MadContext *t, AVFrame *frame,
                              int mb_x, int mb_y,
        comp(frame->data[0] + (mb_y*16 + ((j&2)<<2))*frame->linesize[0] + mb_x*16 + ((j&1)<<3),
             frame->linesize[0],
        comp(frame->data[index] + (mb_y*8)*frame->linesize[index] + mb_x * 8,
             frame->linesize[index],
static inline void idct_put(MadContext *t, AVFrame *frame, int16_t *block,
                            int mb_x, int mb_y, int j)
            frame->data[0] + (mb_y*16 + ((j&2)<<2))*frame->linesize[0] + mb_x*16 + ((j&1)<<3),
            frame->linesize[0], block);
            frame->data[index] + (mb_y*8)*frame->linesize[index] + mb_x*8,
            frame->linesize[index], block);
static void decode_mb(MadContext *s, AVFrame *frame, int inter)
            comp_block(s, frame, s->mb_x, s->mb_y, j, mv_x, mv_y, add);
            idct_put(s, frame, s->block, s->mb_x, s->mb_y, j);
    AVFrame *frame    = data;
    int inter, ret;
        av_frame_unref(&s->last_frame);
    if ((ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
        return ret;
            decode_mb(s, frame, inter);
    if (chunk_type != MADe_TAG) {
        av_frame_unref(&s->last_frame);
        if ((ret = av_frame_ref(&s->last_frame, frame)) < 0)
            return ret;
    }
    av_frame_unref(&t->last_frame);","    AVFrame frame;
static inline void comp_block(MadContext *t, int mb_x, int mb_y,
        comp(t->frame.data[0] + (mb_y*16 + ((j&2)<<2))*t->frame.linesize[0] + mb_x*16 + ((j&1)<<3),
             t->frame.linesize[0],
        comp(t->frame.data[index] + (mb_y*8)*t->frame.linesize[index] + mb_x * 8,
             t->frame.linesize[index],
static inline void idct_put(MadContext *t, int16_t *block, int mb_x, int mb_y, int j)
            t->frame.data[0] + (mb_y*16 + ((j&2)<<2))*t->frame.linesize[0] + mb_x*16 + ((j&1)<<3),
            t->frame.linesize[0], block);
            t->frame.data[index] + (mb_y*8)*t->frame.linesize[index] + mb_x*8,
            t->frame.linesize[index], block);
static void decode_mb(MadContext *s, int inter)
            comp_block(s, s->mb_x, s->mb_y, j, mv_x, mv_y, add);
            idct_put(s, s->block, s->mb_x, s->mb_y, j);
    int inter;
        if (s->frame.data[0])
            avctx->release_buffer(avctx, &s->frame);
    s->frame.reference = 1;
    if (!s->frame.data[0]) {
        if (ff_get_buffer(avctx, &s->frame) < 0) {
            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
            return -1;
        }
            decode_mb(s, inter);
    *(AVFrame*)data = s->frame;
    if (chunk_type != MADe_TAG)
        FFSWAP(AVFrame, s->frame, s->last_frame);
    if (t->frame.data[0])
        avctx->release_buffer(avctx, &t->frame);
    if (t->last_frame.data[0])
        avctx->release_buffer(avctx, &t->last_frame);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR, VAR(VAR->VAR[0] + (VAR*16 + ((VAR&2)<<2))*VAR->VAR[0] + VAR*16 + ((VAR&1)<<3), VAR->VAR[0], VAR(VAR->VAR[VAR] + (VAR*8)*VAR->VAR[VAR] + VAR * 8, VAR->VAR[VAR], VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR, VAR VAR, VAR VAR, VAR VAR) VAR->VAR[0] + (VAR*16 + ((VAR&2)<<2))*VAR->VAR[0] + VAR*16 + ((VAR&1)<<3), VAR->VAR[0], VAR); VAR->VAR[VAR] + (VAR*8)*VAR->VAR[VAR] + VAR*8, VAR->VAR[VAR], VAR); VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR(VAR, VAR, VAR->VAR, VAR->VAR, VAR, VAR, VAR, VAR); VAR(VAR, VAR, VAR->VAR, VAR->VAR, VAR->VAR, VAR); VAR *VAR = VAR; VAR VAR, VAR; VAR(&VAR->VAR); VAR ((VAR = VAR(VAR, VAR, VAR)) < 0) { VAR(VAR, VAR, ""VAR() VAR\VAR""); VAR VAR; VAR(VAR, VAR, VAR); VAR (VAR != VAR) { VAR(&VAR->VAR); VAR ((VAR = VAR(&VAR->VAR, VAR)) < 0) VAR VAR; } VAR(&VAR->VAR); VAR VAR; VAR VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR, VAR(VAR->VAR.VAR[0] + (VAR*16 + ((VAR&2)<<2))*VAR->VAR.VAR[0] + VAR*16 + ((VAR&1)<<3), VAR->VAR.VAR[0], VAR(VAR->VAR.VAR[VAR] + (VAR*8)*VAR->VAR.VAR[VAR] + VAR * 8, VAR->VAR.VAR[VAR], VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR, VAR VAR) VAR->VAR.VAR[0] + (VAR*16 + ((VAR&2)<<2))*VAR->VAR.VAR[0] + VAR*16 + ((VAR&1)<<3), VAR->VAR.VAR[0], VAR); VAR->VAR.VAR[VAR] + (VAR*8)*VAR->VAR.VAR[VAR] + VAR*8, VAR->VAR.VAR[VAR], VAR); VAR VAR VAR(VAR *VAR, VAR VAR) VAR(VAR, VAR->VAR, VAR->VAR, VAR, VAR, VAR, VAR); VAR(VAR, VAR->VAR, VAR->VAR, VAR->VAR, VAR); VAR VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR->VAR.VAR = 1; VAR (!VAR->VAR.VAR[0]) { VAR (VAR(VAR, &VAR->VAR) < 0) { VAR(VAR, VAR, ""VAR() VAR\VAR""); VAR -1; } VAR(VAR, VAR); *(VAR*)VAR = VAR->VAR; VAR (VAR != VAR) VAR(VAR, VAR->VAR, VAR->VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR);",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/eatgq.c,"static void tgq_idct_put_mb(TgqContext *s, int16_t (*block)[64], AVFrame *frame,
    int linesize = frame->linesize[0];
    uint8_t *dest_y  = frame->data[0] + (mb_y * 16 * linesize)           + mb_x * 16;
    uint8_t *dest_cb = frame->data[1] + (mb_y * 8  * frame->linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = frame->data[2] + (mb_y * 8  * frame->linesize[2]) + mb_x * 8;
         ff_ea_idct_put_c(dest_cb, frame->linesize[1], block[4]);
         ff_ea_idct_put_c(dest_cr, frame->linesize[2], block[5]);
static void tgq_idct_put_mb_dconly(TgqContext *s, AVFrame *frame,
                                   int mb_x, int mb_y, const int8_t *dc)
    int linesize = frame->linesize[0];
    uint8_t *dest_y  = frame->data[0] + (mb_y * 16 * linesize)             + mb_x * 16;
    uint8_t *dest_cb = frame->data[1] + (mb_y * 8  * frame->linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = frame->data[2] + (mb_y * 8  * frame->linesize[2]) + mb_x * 8;
        tgq_dconly(s, dest_cb, frame->linesize[1], dc[4]);
        tgq_dconly(s, dest_cr, frame->linesize[2], dc[5]);
static void tgq_decode_mb(TgqContext *s, AVFrame *frame, int mb_y, int mb_x)
        tgq_idct_put_mb(s, s->block, frame, mb_x, mb_y);
        tgq_idct_put_mb_dconly(s, frame, mb_x, mb_y, dc);
    AVFrame *frame     = data;
    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
        return ret;
    frame->key_frame = 1;
    frame->pict_type = AV_PICTURE_TYPE_I;
            tgq_decode_mb(s, frame, y, x);","    AVFrame frame;
static void tgq_idct_put_mb(TgqContext *s, int16_t (*block)[64],
    int linesize = s->frame.linesize[0];
    uint8_t *dest_y  = s->frame.data[0] + (mb_y * 16 * linesize)             + mb_x * 16;
    uint8_t *dest_cb = s->frame.data[1] + (mb_y * 8  * s->frame.linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = s->frame.data[2] + (mb_y * 8  * s->frame.linesize[2]) + mb_x * 8;
         ff_ea_idct_put_c(dest_cb, s->frame.linesize[1], block[4]);
         ff_ea_idct_put_c(dest_cr, s->frame.linesize[2], block[5]);
static void tgq_idct_put_mb_dconly(TgqContext *s, int mb_x, int mb_y, const int8_t *dc)
    int linesize = s->frame.linesize[0];
    uint8_t *dest_y  = s->frame.data[0] + (mb_y * 16 * linesize)             + mb_x * 16;
    uint8_t *dest_cb = s->frame.data[1] + (mb_y * 8  * s->frame.linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = s->frame.data[2] + (mb_y * 8  * s->frame.linesize[2]) + mb_x * 8;
        tgq_dconly(s, dest_cb, s->frame.linesize[1], dc[4]);
        tgq_dconly(s, dest_cr, s->frame.linesize[2], dc[5]);
static void tgq_decode_mb(TgqContext *s, int mb_y, int mb_x)
        tgq_idct_put_mb(s, s->block, mb_x, mb_y);
        tgq_idct_put_mb_dconly(s, mb_x, mb_y, dc);
        if (s->frame.data[0])
            avctx->release_buffer(avctx, &s->frame);
    if (!s->frame.data[0]) {
        s->frame.key_frame = 1;
        s->frame.pict_type = AV_PICTURE_TYPE_I;
        s->frame.buffer_hints = FF_BUFFER_HINTS_VALID;
        if ((ret = ff_get_buffer(avctx, &s->frame)) < 0) {
            av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
            return ret;
        }
            tgq_decode_mb(s, y, x);
    *(AVFrame*)data = s->frame;
static av_cold int tgq_decode_end(AVCodecContext *avctx)
{
    TgqContext *s = avctx->priv_data;
    if (s->frame.data[0])
        s->avctx->release_buffer(avctx, &s->frame);
    return 0;
}

    .close          = tgq_decode_end,",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR VAR(VAR *VAR, VAR (*VAR)[64], VAR *VAR, VAR VAR = VAR->VAR[0]; VAR *VAR = VAR->VAR[0] + (VAR * 16 * VAR) + VAR * 16; VAR *VAR = VAR->VAR[1] + (VAR * 8 * VAR->VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR[2] + (VAR * 8 * VAR->VAR[2]) + VAR * 8; VAR(VAR, VAR->VAR[1], VAR[4]); VAR(VAR, VAR->VAR[2], VAR[5]); VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR, VAR VAR *VAR) VAR VAR = VAR->VAR[0]; VAR *VAR = VAR->VAR[0] + (VAR * 16 * VAR) + VAR * 16; VAR *VAR = VAR->VAR[1] + (VAR * 8 * VAR->VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR[2] + (VAR * 8 * VAR->VAR[2]) + VAR * 8; VAR(VAR, VAR, VAR->VAR[1], VAR[4]); VAR(VAR, VAR, VAR->VAR[2], VAR[5]); VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR) VAR(VAR, VAR->VAR, VAR, VAR, VAR); VAR(VAR, VAR, VAR, VAR, VAR); VAR *VAR = VAR; VAR ((VAR = VAR(VAR, VAR, 0)) < 0) { VAR(VAR, VAR, ""VAR() VAR\VAR""); VAR VAR; VAR->VAR = 1; VAR->VAR = VAR; VAR(VAR, VAR, VAR, VAR); VAR VAR; VAR VAR VAR(VAR *VAR, VAR (*VAR)[64], VAR VAR = VAR->VAR.VAR[0]; VAR *VAR = VAR->VAR.VAR[0] + (VAR * 16 * VAR) + VAR * 16; VAR *VAR = VAR->VAR.VAR[1] + (VAR * 8 * VAR->VAR.VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR.VAR[2] + (VAR * 8 * VAR->VAR.VAR[2]) + VAR * 8; VAR(VAR, VAR->VAR.VAR[1], VAR[4]); VAR(VAR, VAR->VAR.VAR[2], VAR[5]); VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR, VAR VAR *VAR) VAR VAR = VAR->VAR.VAR[0]; VAR *VAR = VAR->VAR.VAR[0] + (VAR * 16 * VAR) + VAR * 16; VAR *VAR = VAR->VAR.VAR[1] + (VAR * 8 * VAR->VAR.VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR.VAR[2] + (VAR * 8 * VAR->VAR.VAR[2]) + VAR * 8; VAR(VAR, VAR, VAR->VAR.VAR[1], VAR[4]); VAR(VAR, VAR, VAR->VAR.VAR[2], VAR[5]); VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR) VAR(VAR, VAR->VAR, VAR, VAR); VAR(VAR, VAR, VAR, VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR (!VAR->VAR.VAR[0]) { VAR->VAR.VAR = 1; VAR->VAR.VAR = VAR; VAR->VAR.VAR = VAR; VAR ((VAR = VAR(VAR, &VAR->VAR)) < 0) { VAR(VAR, VAR, ""VAR() VAR\VAR""); VAR VAR; } VAR(VAR, VAR, VAR); *(VAR*)VAR = VAR->VAR; VAR VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR->VAR(VAR, &VAR->VAR); VAR 0; } .VAR = VAR,",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/eatqi.c,"static inline void tqi_idct_put(TqiContext *t, AVFrame *frame, int16_t (*block)[64])
    int linesize = frame->linesize[0];
    uint8_t *dest_y  = frame->data[0] + (s->mb_y * 16* linesize            ) + s->mb_x * 16;
    uint8_t *dest_cb = frame->data[1] + (s->mb_y * 8 * frame->linesize[1]) + s->mb_x * 8;
    uint8_t *dest_cr = frame->data[2] + (s->mb_y * 8 * frame->linesize[2]) + s->mb_x * 8;
        ff_ea_idct_put_c(dest_cb, frame->linesize[1], block[4]);
        ff_ea_idct_put_c(dest_cr, frame->linesize[2], block[5]);
    AVFrame *frame = data;
    int ret;
    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
        return ret;
        tqi_idct_put(t, frame, t->block);","    AVFrame frame;
static inline void tqi_idct_put(TqiContext *t, int16_t (*block)[64])
    int linesize= t->frame.linesize[0];
    uint8_t *dest_y  = t->frame.data[0] + (s->mb_y * 16* linesize            ) + s->mb_x * 16;
    uint8_t *dest_cb = t->frame.data[1] + (s->mb_y * 8 * t->frame.linesize[1]) + s->mb_x * 8;
    uint8_t *dest_cr = t->frame.data[2] + (s->mb_y * 8 * t->frame.linesize[2]) + s->mb_x * 8;
        ff_ea_idct_put_c(dest_cb, t->frame.linesize[1], block[4]);
        ff_ea_idct_put_c(dest_cr, t->frame.linesize[2], block[5]);
    if (t->frame.data[0])
        avctx->release_buffer(avctx, &t->frame);

    if(ff_get_buffer(avctx, &t->frame) < 0) {
        return -1;
        tqi_idct_put(t, t->block);
    *(AVFrame*)data = t->frame;
    if(t->frame.data[0])
        avctx->release_buffer(avctx, &t->frame);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR (*VAR)[64]) VAR VAR = VAR->VAR[0]; VAR *VAR = VAR->VAR[0] + (VAR->VAR * 16* VAR ) + VAR->VAR * 16; VAR *VAR = VAR->VAR[1] + (VAR->VAR * 8 * VAR->VAR[1]) + VAR->VAR * 8; VAR *VAR = VAR->VAR[2] + (VAR->VAR * 8 * VAR->VAR[2]) + VAR->VAR * 8; VAR(VAR, VAR->VAR[1], VAR[4]); VAR(VAR, VAR->VAR[2], VAR[5]); VAR *VAR = VAR; VAR VAR; VAR ((VAR = VAR(VAR, VAR, 0)) < 0) { VAR VAR; VAR(VAR, VAR, VAR->VAR); VAR VAR; VAR VAR VAR VAR(VAR *VAR, VAR (*VAR)[64]) VAR VAR= VAR->VAR.VAR[0]; VAR *VAR = VAR->VAR.VAR[0] + (VAR->VAR * 16* VAR ) + VAR->VAR * 16; VAR *VAR = VAR->VAR.VAR[1] + (VAR->VAR * 8 * VAR->VAR.VAR[1]) + VAR->VAR * 8; VAR *VAR = VAR->VAR.VAR[2] + (VAR->VAR * 8 * VAR->VAR.VAR[2]) + VAR->VAR * 8; VAR(VAR, VAR->VAR.VAR[1], VAR[4]); VAR(VAR, VAR->VAR.VAR[2], VAR[5]); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR(VAR(VAR, &VAR->VAR) < 0) { VAR -1; VAR(VAR, VAR->VAR); *(VAR*)VAR = VAR->VAR; VAR(VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR);",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/mdec.c,"    ThreadFrame frame;
static inline void idct_put(MDECContext *a, AVFrame *frame, int mb_x, int mb_y)
    int linesize = frame->linesize[0];
    uint8_t *dest_y  = frame->data[0] + (mb_y * 16* linesize              ) + mb_x * 16;
    uint8_t *dest_cb = frame->data[1] + (mb_y * 8 * frame->linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = frame->data[2] + (mb_y * 8 * frame->linesize[2]) + mb_x * 8;
        a->dsp.idct_put(dest_cb, frame->linesize[1], block[4]);
        a->dsp.idct_put(dest_cr, frame->linesize[2], block[5]);
    ThreadFrame frame     = { .f = data };
    if ((ret = ff_thread_get_buffer(avctx, &frame, 0)) < 0) {
    frame.f->pict_type = AV_PICTURE_TYPE_I;
    frame.f->key_frame = 1;
            idct_put(a, frame.f, a->mb_x, a->mb_y);","    AVFrame picture;
static inline void idct_put(MDECContext *a, int mb_x, int mb_y)
    int linesize = a->picture.linesize[0];
    uint8_t *dest_y  = a->picture.data[0] + (mb_y * 16 * linesize              ) + mb_x * 16;
    uint8_t *dest_cb = a->picture.data[1] + (mb_y * 8  * a->picture.linesize[1]) + mb_x * 8;
    uint8_t *dest_cr = a->picture.data[2] + (mb_y * 8  * a->picture.linesize[2]) + mb_x * 8;
        a->dsp.idct_put(dest_cb, a->picture.linesize[1], block[4]);
        a->dsp.idct_put(dest_cr, a->picture.linesize[2], block[5]);
    AVFrame *picture      = data;
    AVFrame * const p     = &a->picture;
    if (p->data[0])
        ff_thread_release_buffer(avctx, p);

    p->reference = 0;
    if ((ret = ff_thread_get_buffer(avctx, p)) < 0) {
    p->pict_type = AV_PICTURE_TYPE_I;
    p->key_frame = 1;
            idct_put(a, a->mb_x, a->mb_y);
    p->quality = a->qscale * FF_QP2LAMBDA;
    memset(p->qscale_table, a->qscale, a->mb_width);

    *picture   = a->picture;
    AVFrame *p            = &a->picture;
    avctx->coded_frame = &a->picture;
    p->qstride      = 0;
    p->qscale_table = av_mallocz(a->mb_width);
    AVFrame *p            = &a->picture;
    avctx->coded_frame = p;
    p->qscale_table = av_mallocz( a->mb_width);

    if (a->picture.data[0])
        avctx->release_buffer(avctx, &a->picture);
    av_freep(&a->picture.qscale_table);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR; VAR VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR) VAR VAR = VAR->VAR[0]; VAR *VAR = VAR->VAR[0] + (VAR * 16* VAR ) + VAR * 16; VAR *VAR = VAR->VAR[1] + (VAR * 8 * VAR->VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR[2] + (VAR * 8 * VAR->VAR[2]) + VAR * 8; VAR->VAR.VAR(VAR, VAR->VAR[1], VAR[4]); VAR->VAR.VAR(VAR, VAR->VAR[2], VAR[5]); VAR VAR = { .VAR = VAR }; VAR ((VAR = VAR(VAR, &VAR, 0)) < 0) { VAR.VAR->VAR = VAR; VAR.VAR->VAR = 1; VAR(VAR, VAR.VAR, VAR->VAR, VAR->VAR); VAR VAR; VAR VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR) VAR VAR = VAR->VAR.VAR[0]; VAR *VAR = VAR->VAR.VAR[0] + (VAR * 16 * VAR ) + VAR * 16; VAR *VAR = VAR->VAR.VAR[1] + (VAR * 8 * VAR->VAR.VAR[1]) + VAR * 8; VAR *VAR = VAR->VAR.VAR[2] + (VAR * 8 * VAR->VAR.VAR[2]) + VAR * 8; VAR->VAR.VAR(VAR, VAR->VAR.VAR[1], VAR[4]); VAR->VAR.VAR(VAR, VAR->VAR.VAR[2], VAR[5]); VAR *VAR = VAR; VAR * VAR VAR = &VAR->VAR; VAR (VAR->VAR[0]) VAR(VAR, VAR); VAR->VAR = 0; VAR ((VAR = VAR(VAR, VAR)) < 0) { VAR->VAR = VAR; VAR->VAR = 1; VAR(VAR, VAR->VAR, VAR->VAR); VAR->VAR = VAR->VAR * VAR; VAR(VAR->VAR, VAR->VAR, VAR->VAR); *VAR = VAR->VAR; VAR *VAR = &VAR->VAR; VAR->VAR = &VAR->VAR; VAR->VAR = 0; VAR->VAR = VAR(VAR->VAR); VAR *VAR = &VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR( VAR->VAR); VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR(&VAR->VAR.VAR);",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/mimic.c,"    ThreadFrame     frames     [16];
static av_cold int mimic_decode_end(AVCodecContext *avctx)
{
    MimicContext *ctx = avctx->priv_data;
    int i;

    av_free(ctx->swap_buf);

    for (i = 0; i < FF_ARRAY_ELEMS(ctx->frames); i++) {
        if (ctx->frames[i].f)
            ff_thread_release_buffer(avctx, &ctx->frames[i]);
        av_frame_free(&ctx->frames[i].f);
    }

    if (!avctx->internal->is_copy)
        ff_free_vlc(&ctx->vlc);

    return 0;
}

    int ret, i;

    avctx->internal->allocate_progress = 1;
    for (i = 0; i < FF_ARRAY_ELEMS(ctx->frames); i++) {
        ctx->frames[i].f = av_frame_alloc();
        if (!ctx->frames[i].f) {
            mimic_decode_end(avctx);
            return AVERROR(ENOMEM);
        }
    }

    int i, ret;
    for (i = 0; i < FF_ARRAY_ELEMS(dst->frames); i++) {
        ff_thread_release_buffer(avctx, &dst->frames[i]);
        if (src->frames[i].f->data[0]) {
            ret = ff_thread_ref_frame(&dst->frames[i], &src->frames[i]);
            if (ret < 0)
                return ret;
        }
    }
                            ff_thread_await_progress(&ctx->frames[index],
                    ff_thread_await_progress(&ctx->frames[ctx->prev_index],
            ff_thread_report_progress(&ctx->frames[ctx->cur_index],
    if (is_pframe && !ctx->frames[ctx->prev_index].f->data[0]) {
    ff_thread_release_buffer(avctx, &ctx->frames[ctx->cur_index]);
    ctx->frames[ctx->cur_index].f->pict_type = is_pframe ? AV_PICTURE_TYPE_P :
                                                           AV_PICTURE_TYPE_I;
    if ((res = ff_thread_get_buffer(avctx, &ctx->frames[ctx->cur_index],
                                    AV_GET_BUFFER_FLAG_REF)) < 0) {
                  ctx->frames[ctx->cur_index].f);
    ff_thread_report_progress(&ctx->frames[ctx->cur_index], INT_MAX, 0);
            ff_thread_release_buffer(avctx, &ctx->frames[ctx->cur_index]);
    if ((res = av_frame_ref(data, ctx->frames[ctx->cur_index].f)) < 0)
        return res;
    ff_thread_release_buffer(avctx, &ctx->frames[ctx->cur_index]);
static av_cold int mimic_init_thread_copy(AVCodecContext *avctx)
    for (i = 0; i < FF_ARRAY_ELEMS(ctx->frames); i++) {
        ctx->frames[i].f = av_frame_alloc();
        if (!ctx->frames[i].f) {
            mimic_decode_end(avctx);
            return AVERROR(ENOMEM);
        }
    }
    .update_thread_context = ONLY_IF_THREADS_ENABLED(mimic_decode_update_thread_context),
    .init_thread_copy      = ONLY_IF_THREADS_ENABLED(mimic_init_thread_copy),","    AVFrame         buf_ptrs    [16];
    int ret;
    memcpy(dst->buf_ptrs, src->buf_ptrs, sizeof(src->buf_ptrs));
    memset(&dst->buf_ptrs[dst->cur_index], 0, sizeof(AVFrame));
                            ff_thread_await_progress(&ctx->buf_ptrs[index],
                    ff_thread_await_progress(&ctx->buf_ptrs[ctx->prev_index],
            ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index],
    if (is_pframe && !ctx->buf_ptrs[ctx->prev_index].data[0]) {
    ctx->buf_ptrs[ctx->cur_index].reference = 1;
    ctx->buf_ptrs[ctx->cur_index].pict_type = is_pframe ? AV_PICTURE_TYPE_P :
                                                          AV_PICTURE_TYPE_I;
    if ((res = ff_thread_get_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index])) < 0) {
                  &ctx->buf_ptrs[ctx->cur_index]);
    ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index], INT_MAX, 0);
            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);
    *(AVFrame*)data = ctx->buf_ptrs[ctx->cur_index];
    if (ctx->buf_ptrs[ctx->cur_index].data[0])
        ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);
static av_cold int mimic_decode_end(AVCodecContext *avctx)
    av_free(ctx->swap_buf);

    if (avctx->internal->is_copy)
        return 0;

    for (i = 0; i < 16; i++)
        if (ctx->buf_ptrs[i].data[0])
            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[i]);
    ff_free_vlc(&ctx->vlc);
    .update_thread_context = ONLY_IF_THREADS_ENABLED(mimic_decode_update_thread_context)",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR [16]; VAR VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR VAR; VAR(VAR->VAR); VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR (VAR->VAR[VAR].VAR) VAR(VAR, &VAR->VAR[VAR]); VAR(&VAR->VAR[VAR].VAR); } VAR (!VAR->VAR->VAR) VAR(&VAR->VAR); VAR 0; } VAR VAR, VAR; VAR->VAR->VAR = 1; VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR->VAR[VAR].VAR = VAR(); VAR (!VAR->VAR[VAR].VAR) { VAR(VAR); VAR VAR(VAR); } } VAR VAR, VAR; VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR[VAR].VAR->VAR[0]) { VAR = VAR(&VAR->VAR[VAR], &VAR->VAR[VAR]); VAR (VAR < 0) VAR VAR; } } VAR(&VAR->VAR[VAR], VAR(&VAR->VAR[VAR->VAR], VAR(&VAR->VAR[VAR->VAR], VAR (VAR && !VAR->VAR[VAR->VAR].VAR->VAR[0]) { VAR(VAR, &VAR->VAR[VAR->VAR]); VAR->VAR[VAR->VAR].VAR->VAR = VAR ? VAR : VAR; VAR ((VAR = VAR(VAR, &VAR->VAR[VAR->VAR], VAR)) < 0) { VAR->VAR[VAR->VAR].VAR); VAR(&VAR->VAR[VAR->VAR], VAR, 0); VAR(VAR, &VAR->VAR[VAR->VAR]); VAR ((VAR = VAR(VAR, VAR->VAR[VAR->VAR].VAR)) < 0) VAR VAR; VAR(VAR, &VAR->VAR[VAR->VAR]); VAR VAR VAR VAR(VAR *VAR) VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR->VAR[VAR].VAR = VAR(); VAR (!VAR->VAR[VAR].VAR) { VAR(VAR); VAR VAR(VAR); } } .VAR = VAR(VAR), .VAR = VAR(VAR), VAR VAR [16]; VAR VAR; VAR(VAR->VAR, VAR->VAR, VAR(VAR->VAR)); VAR(&VAR->VAR[VAR->VAR], 0, VAR(VAR)); VAR(&VAR->VAR[VAR], VAR(&VAR->VAR[VAR->VAR], VAR(&VAR->VAR[VAR->VAR], VAR (VAR && !VAR->VAR[VAR->VAR].VAR[0]) { VAR->VAR[VAR->VAR].VAR = 1; VAR->VAR[VAR->VAR].VAR = VAR ? VAR : VAR; VAR ((VAR = VAR(VAR, &VAR->VAR[VAR->VAR])) < 0) { &VAR->VAR[VAR->VAR]); VAR(&VAR->VAR[VAR->VAR], VAR, 0); VAR(VAR, &VAR->VAR[VAR->VAR]); *(VAR*)VAR = VAR->VAR[VAR->VAR]; VAR (VAR->VAR[VAR->VAR].VAR[0]) VAR(VAR, &VAR->VAR[VAR->VAR]); VAR VAR VAR VAR(VAR *VAR) VAR(VAR->VAR); VAR (VAR->VAR->VAR) VAR 0; VAR (VAR = 0; VAR < 16; VAR++) VAR (VAR->VAR[VAR].VAR[0]) VAR(VAR, &VAR->VAR[VAR]); VAR(&VAR->VAR); .VAR = VAR(VAR)",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/mpegvideo_enc.c,"    int8_t * const qscale_table = s->current_picture.qscale_table;
    Picture *pic = NULL;
    int i, display_picture_number = 0, ret;
        if (!pic_arg->buf[0]);
            pic = &s->picture[i];
            if ((ret = av_frame_ref(&pic->f, pic_arg)) < 0)
                return ret;
            if (ff_alloc_picture(s, pic, 1) < 0) {
            pic = &s->picture[i];
            if (ff_alloc_picture(s, pic, 0) < 0) {
            if (pic->f.data[0] + INPLACE_OFFSET == pic_arg->data[0] &&
                pic->f.data[1] + INPLACE_OFFSET == pic_arg->data[1] &&
                pic->f.data[2] + INPLACE_OFFSET == pic_arg->data[2]) {
                    uint8_t *dst = pic->f.data[i];
        copy_picture_attributes(s, &pic->f, pic_arg);
        pic->f.display_picture_number = display_picture_number;
        pic->f.pts = pts; // we set this here to avoid modifiying pic_arg
                int off = p->shared ? 0 : 16;
            if (!pre_input.shared && i) {
    int i, ret;
                    av_frame_unref(&s->input_picture[0]->f);
        s->reordered_input_picture[0]->reference =
        ff_mpeg_unref_picture(s, &s->new_picture);
        if ((ret = ff_mpeg_ref_picture(s, &s->new_picture, s->reordered_input_picture[0])))
            return ret;
        if (s->reordered_input_picture[0]->shared || s->avctx->rc_buffer_size) {
            pic->reference = s->reordered_input_picture[0]->reference;
            /* mark us unused / free shared pic */
            av_frame_unref(&s->reordered_input_picture[0]->f);
            s->reordered_input_picture[0]->shared = 0;

        ff_mpeg_unref_picture(s, &s->current_picture);
        if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,
                                       s->current_picture_ptr)) < 0)
            return ret;
        ff_mpeg_unref_picture(s, &s->new_picture);
            s->qscale = s->current_picture_ptr->qscale_table[mb_xy];
                        s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0];
                        s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1];
                s->current_picture.qscale_table[xy] = best_s.qscale;
                        s->mv[0][i][0] = s->current_picture.motion_val[0][s->block_index[i]][0];
                        s->mv[0][i][1] = s->current_picture.motion_val[0][s->block_index[i]][1];","    int8_t * const qscale_table = s->current_picture.f.qscale_table;
    AVFrame *pic = NULL;
    int i, display_picture_number = 0;
        if (encoding_delay && !(s->flags & CODEC_FLAG_INPUT_PRESERVED))
            pic = &s->picture[i].f;
            for (i = 0; i < 4; i++) {
                pic->data[i]     = pic_arg->data[i];
                pic->linesize[i] = pic_arg->linesize[i];
            }
            if (ff_alloc_picture(s, (Picture *) pic, 1) < 0) {
            pic = &s->picture[i].f;
            if (ff_alloc_picture(s, (Picture *) pic, 0) < 0) {
            if (pic->data[0] + INPLACE_OFFSET == pic_arg->data[0] &&
                pic->data[1] + INPLACE_OFFSET == pic_arg->data[1] &&
                pic->data[2] + INPLACE_OFFSET == pic_arg->data[2]) {
                    uint8_t *dst = pic->data[i];
        copy_picture_attributes(s, pic, pic_arg);
        pic->display_picture_number = display_picture_number;
        pic->pts = pts; // we set this here to avoid modifiying pic_arg
                int off = p->f.type == FF_BUFFER_TYPE_SHARED ? 0 : 16;
            if (pre_input.f.type != FF_BUFFER_TYPE_SHARED && i) {
    int i;
                    if (s->input_picture[0]->f.type == FF_BUFFER_TYPE_SHARED) {
                        for (i = 0; i < 4; i++)
                            s->input_picture[0]->f.data[i] = NULL;
                        s->input_picture[0]->f.type = 0;
                    } else {
                        assert(s->input_picture[0]->f.type == FF_BUFFER_TYPE_USER ||
                               s->input_picture[0]->f.type == FF_BUFFER_TYPE_INTERNAL);

                        s->avctx->release_buffer(s->avctx,
                                                 &s->input_picture[0]->f);
                    }
        s->reordered_input_picture[0]->f.reference =
        ff_copy_picture(&s->new_picture, s->reordered_input_picture[0]);
        if (s->reordered_input_picture[0]->f.type == FF_BUFFER_TYPE_SHARED ||
            s->avctx->rc_buffer_size) {
            pic->f.reference = s->reordered_input_picture[0]->f.reference;
            /* mark us unused / free shared pic */
            if (s->reordered_input_picture[0]->f.type == FF_BUFFER_TYPE_INTERNAL)
                s->avctx->release_buffer(s->avctx,
                                         &s->reordered_input_picture[0]->f);
            for (i = 0; i < 4; i++)
                s->reordered_input_picture[0]->f.data[i] = NULL;
            s->reordered_input_picture[0]->f.type = 0;


            assert(s->reordered_input_picture[0]->f.type ==
                       FF_BUFFER_TYPE_USER ||
                   s->reordered_input_picture[0]->f.type ==
                       FF_BUFFER_TYPE_INTERNAL);

        ff_copy_picture(&s->current_picture, s->current_picture_ptr);
        memset(&s->new_picture, 0, sizeof(Picture));
            s->qscale = s->current_picture_ptr->f.qscale_table[mb_xy];
                        s->mv[0][i][0] = s->current_picture.f.motion_val[0][s->block_index[i]][0];
                        s->mv[0][i][1] = s->current_picture.f.motion_val[0][s->block_index[i]][1];
                s->current_picture.f.qscale_table[xy] = best_s.qscale;
                        s->mv[0][i][0] = s->current_picture.f.motion_val[0][s->block_index[i]][0];
                        s->mv[0][i][1] = s->current_picture.f.motion_val[0][s->block_index[i]][1];",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR * VAR VAR = VAR->VAR.VAR; VAR *VAR = VAR; VAR VAR, VAR = 0, VAR; VAR (!VAR->VAR[0]); VAR = &VAR->VAR[VAR]; VAR ((VAR = VAR(&VAR->VAR, VAR)) < 0) VAR VAR; VAR (VAR(VAR, VAR, 1) < 0) { VAR = &VAR->VAR[VAR]; VAR (VAR(VAR, VAR, 0) < 0) { VAR (VAR->VAR.VAR[0] + VAR == VAR->VAR[0] && VAR->VAR.VAR[1] + VAR == VAR->VAR[1] && VAR->VAR.VAR[2] + VAR == VAR->VAR[2]) { VAR *VAR = VAR->VAR.VAR[VAR]; VAR(VAR, &VAR->VAR, VAR); VAR->VAR.VAR = VAR; VAR->VAR.VAR = VAR;  VAR VAR = VAR->VAR ? 0 : 16; VAR (!VAR.VAR && VAR) { VAR VAR, VAR; VAR(&VAR->VAR[0]->VAR); VAR->VAR[0]->VAR = VAR(VAR, &VAR->VAR); VAR ((VAR = VAR(VAR, &VAR->VAR, VAR->VAR[0]))) VAR VAR; VAR (VAR->VAR[0]->VAR || VAR->VAR->VAR) { VAR->VAR = VAR->VAR[0]->VAR;  VAR(&VAR->VAR[0]->VAR); VAR->VAR[0]->VAR = 0; VAR(VAR, &VAR->VAR); VAR ((VAR = VAR(VAR, &VAR->VAR, VAR->VAR)) < 0) VAR VAR; VAR(VAR, &VAR->VAR); VAR->VAR = VAR->VAR->VAR[VAR]; VAR->VAR[0][VAR][0] = VAR->VAR.VAR[0][VAR->VAR[VAR]][0]; VAR->VAR[0][VAR][1] = VAR->VAR.VAR[0][VAR->VAR[VAR]][1]; VAR->VAR.VAR[VAR] = VAR.VAR; VAR->VAR[0][VAR][0] = VAR->VAR.VAR[0][VAR->VAR[VAR]][0]; VAR->VAR[0][VAR][1] = VAR->VAR.VAR[0][VAR->VAR[VAR]][1]; VAR * VAR VAR = VAR->VAR.VAR.VAR; VAR *VAR = VAR; VAR VAR, VAR = 0; VAR (VAR && !(VAR->VAR & VAR)) VAR = &VAR->VAR[VAR].VAR; VAR (VAR = 0; VAR < 4; VAR++) { VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR->VAR[VAR]; } VAR (VAR(VAR, (VAR *) VAR, 1) < 0) { VAR = &VAR->VAR[VAR].VAR; VAR (VAR(VAR, (VAR *) VAR, 0) < 0) { VAR (VAR->VAR[0] + VAR == VAR->VAR[0] && VAR->VAR[1] + VAR == VAR->VAR[1] && VAR->VAR[2] + VAR == VAR->VAR[2]) { VAR *VAR = VAR->VAR[VAR]; VAR(VAR, VAR, VAR); VAR->VAR = VAR; VAR->VAR = VAR;  VAR VAR = VAR->VAR.VAR == VAR ? 0 : 16; VAR (VAR.VAR.VAR != VAR && VAR) { VAR VAR; VAR (VAR->VAR[0]->VAR.VAR == VAR) { VAR (VAR = 0; VAR < 4; VAR++) VAR->VAR[0]->VAR.VAR[VAR] = VAR; VAR->VAR[0]->VAR.VAR = 0; } VAR { VAR(VAR->VAR[0]->VAR.VAR == VAR || VAR->VAR[0]->VAR.VAR == VAR); VAR->VAR->VAR(VAR->VAR, &VAR->VAR[0]->VAR); } VAR->VAR[0]->VAR.VAR = VAR(&VAR->VAR, VAR->VAR[0]); VAR (VAR->VAR[0]->VAR.VAR == VAR || VAR->VAR->VAR) { VAR->VAR.VAR = VAR->VAR[0]->VAR.VAR;  VAR (VAR->VAR[0]->VAR.VAR == VAR) VAR->VAR->VAR(VAR->VAR, &VAR->VAR[0]->VAR); VAR (VAR = 0; VAR < 4; VAR++) VAR->VAR[0]->VAR.VAR[VAR] = VAR; VAR->VAR[0]->VAR.VAR = 0; VAR(VAR->VAR[0]->VAR.VAR == VAR || VAR->VAR[0]->VAR.VAR == VAR); VAR(&VAR->VAR, VAR->VAR); VAR(&VAR->VAR, 0, VAR(VAR)); VAR->VAR = VAR->VAR->VAR.VAR[VAR]; VAR->VAR[0][VAR][0] = VAR->VAR.VAR.VAR[0][VAR->VAR[VAR]][0]; VAR->VAR[0][VAR][1] = VAR->VAR.VAR.VAR[0][VAR->VAR[VAR]][1]; VAR->VAR.VAR.VAR[VAR] = VAR.VAR; VAR->VAR[0][VAR][0] = VAR->VAR.VAR.VAR[0][VAR->VAR[VAR]][0]; VAR->VAR[0][VAR][1] = VAR->VAR.VAR.VAR[0][VAR->VAR[VAR]][1];",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/tmv.c,"    AVFrame *frame     = data;
    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
    frame->pict_type = AV_PICTURE_TYPE_I;
    frame->key_frame = 1;
    dst              = frame->data[0];
    frame->palette_has_changed = 1;
    memcpy(frame->data[1], ff_cga_palette, 16 * 4);
            ff_draw_pc_font(dst + x * 8, frame->linesize[0],
        dst += frame->linesize[0] * 8;
","typedef struct TMVContext {
    AVFrame pic;
} TMVContext;

    TMVContext *tmv    = avctx->priv_data;
    if (tmv->pic.data[0])
        avctx->release_buffer(avctx, &tmv->pic);

    if ((ret = ff_get_buffer(avctx, &tmv->pic)) < 0) {
    tmv->pic.pict_type = AV_PICTURE_TYPE_I;
    tmv->pic.key_frame = 1;
    dst                = tmv->pic.data[0];
    tmv->pic.palette_has_changed = 1;
    memcpy(tmv->pic.data[1], ff_cga_palette, 16 * 4);
            ff_draw_pc_font(dst + x * 8, tmv->pic.linesize[0],
        dst += tmv->pic.linesize[0] * 8;
    *(AVFrame *)data = tmv->pic;
static av_cold int tmv_decode_close(AVCodecContext *avctx)
{
    TMVContext *tmv = avctx->priv_data;

    if (tmv->pic.data[0])
        avctx->release_buffer(avctx, &tmv->pic);

    return 0;
}

    .priv_data_size = sizeof(TMVContext),
    .close          = tmv_decode_close,",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR *VAR = VAR; VAR ((VAR = VAR(VAR, VAR, 0)) < 0) { VAR->VAR = VAR; VAR->VAR = 1; VAR = VAR->VAR[0]; VAR->VAR = 1; VAR(VAR->VAR[1], VAR, 16 * 4); VAR(VAR + VAR * 8, VAR->VAR[0], VAR += VAR->VAR[0] * 8; VAR VAR VAR { VAR VAR; } VAR; VAR *VAR = VAR->VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR ((VAR = VAR(VAR, &VAR->VAR)) < 0) { VAR->VAR.VAR = VAR; VAR->VAR.VAR = 1; VAR = VAR->VAR.VAR[0]; VAR->VAR.VAR = 1; VAR(VAR->VAR.VAR[1], VAR, 16 * 4); VAR(VAR + VAR * 8, VAR->VAR.VAR[0], VAR += VAR->VAR.VAR[0] * 8; *(VAR *)VAR = VAR->VAR; VAR VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR 0; } .VAR = VAR(VAR), .VAR = VAR,",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/utils.c,"#include ""libavutil/frame.h""
static int update_frame_pool(AVCodecContext *avctx, AVFrame *frame)
    FramePool *pool = avctx->internal->pool;
    int i, ret;
    switch (avctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO: {
        int size[4] = { 0 };
        int w = frame->width;
        int h = frame->height;
        int tmpsize, unaligned;
        if (pool->format == frame->format &&
            pool->width == frame->width && pool->height == frame->height)
            return 0;
        avcodec_align_dimensions2(avctx, &w, &h, pool->stride_align);
        if (!(avctx->flags & CODEC_FLAG_EMU_EDGE)) {
            av_image_fill_linesizes(picture.linesize, avctx->pix_fmt, w);
                unaligned |= picture.linesize[i] % pool->stride_align[i];
        tmpsize = av_image_fill_pointers(picture.data, avctx->pix_fmt, h,
                                         NULL, picture.linesize);
        for (i = 0; i < 4; i++) {
            av_buffer_pool_uninit(&pool->pools[i]);
            pool->linesize[i] = picture.linesize[i];
            if (size[i]) {
                pool->pools[i] = av_buffer_pool_init(size[i] + 16, NULL);
                if (!pool->pools[i]) {
                    ret = AVERROR(ENOMEM);
                    goto fail;
                }
            }
        }
        pool->format = frame->format;
        pool->width  = frame->width;
        pool->height = frame->height;
        break;
        }
    case AVMEDIA_TYPE_AUDIO: {
        int ch     = av_get_channel_layout_nb_channels(frame->channel_layout);
        int planar = av_sample_fmt_is_planar(frame->format);
        int planes = planar ? ch : 1;

        if (pool->format == frame->format && pool->planes == planes &&
            pool->channels == ch && frame->nb_samples == pool->samples)
            return 0;

        av_buffer_pool_uninit(&pool->pools[0]);
        ret = av_samples_get_buffer_size(&pool->linesize[0], ch,
                                         frame->nb_samples, frame->format, 0);
        if (ret < 0)
            goto fail;

        pool->pools[0] = av_buffer_pool_init(pool->linesize[0], NULL);
        if (!pool->pools[0]) {
            ret = AVERROR(ENOMEM);
            goto fail;
        }
        pool->format     = frame->format;
        pool->planes     = planes;
        pool->channels   = ch;
        pool->samples = frame->nb_samples;
        break;
        }
    default: av_assert0(0);
    }
    return 0;
fail:
    for (i = 0; i < 4; i++)
        av_buffer_pool_uninit(&pool->pools[i]);
    pool->format = -1;
    pool->planes = pool->channels = pool->samples = 0;
    pool->width  = pool->height = 0;
    return ret;
}
static int audio_get_buffer(AVCodecContext *avctx, AVFrame *frame)
{
    FramePool *pool = avctx->internal->pool;
    int planes = pool->planes;
    int i;
    frame->linesize[0] = pool->linesize[0];

    if (planes > AV_NUM_DATA_POINTERS) {
        frame->extended_data = av_mallocz(planes * sizeof(*frame->extended_data));
        frame->nb_extended_buf = planes - AV_NUM_DATA_POINTERS;
        frame->extended_buf  = av_mallocz(frame->nb_extended_buf *
                                          sizeof(*frame->extended_buf));
        if (!frame->extended_data || !frame->extended_buf) {
            av_freep(&frame->extended_data);
            av_freep(&frame->extended_buf);
            return AVERROR(ENOMEM);
    } else
        frame->extended_data = frame->data;

    for (i = 0; i < FFMIN(planes, AV_NUM_DATA_POINTERS); i++) {
        frame->buf[i] = av_buffer_pool_get(pool->pools[0]);
        if (!frame->buf[i])
            goto fail;
        frame->extended_data[i] = frame->data[i] = frame->buf[i]->data;
    for (i = 0; i < frame->nb_extended_buf; i++) {
        frame->extended_buf[i] = av_buffer_pool_get(pool->pools[0]);
        if (!frame->extended_buf[i])
            goto fail;
        frame->extended_data[i + AV_NUM_DATA_POINTERS] = frame->extended_buf[i]->data;
    }

    if (avctx->debug & FF_DEBUG_BUFFERS)
        av_log(avctx, AV_LOG_DEBUG, ""default_get_buffer called on frame %p"", frame);

    return 0;
fail:
    av_frame_unref(frame);
    return AVERROR(ENOMEM);
}
static int video_get_buffer(AVCodecContext *s, AVFrame *pic)
{
    FramePool *pool = s->internal->pool;
    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(pic->format);
    int pixel_size = desc->comp[0].step_minus1 + 1;
    int h_chroma_shift, v_chroma_shift;
    int i;

    if (pic->data[0] != NULL) {
        av_log(s, AV_LOG_ERROR, ""pic->data[0]!=NULL in avcodec_default_get_buffer\n"");
        return -1;

    memset(pic->data, 0, sizeof(pic->data));

    av_pix_fmt_get_chroma_sub_sample(s->pix_fmt, &h_chroma_shift, &v_chroma_shift);

    for (i = 0; i < 4 && pool->pools[i]; i++) {
        const int h_shift = i == 0 ? 0 : h_chroma_shift;
        const int v_shift = i == 0 ? 0 : v_chroma_shift;

        pic->linesize[i] = pool->linesize[i];

        pic->buf[i] = av_buffer_pool_get(pool->pools[i]);
        if (!pic->buf[i])
            goto fail;

        // no edge if EDGE EMU or not planar YUV
        if ((s->flags & CODEC_FLAG_EMU_EDGE) || !pool->pools[2])
            pic->data[i] = pic->buf[i]->data;
        else {
            pic->data[i] = pic->buf[i]->data +
                FFALIGN((pic->linesize[i] * EDGE_WIDTH >> v_shift) +
                        (pixel_size * EDGE_WIDTH >> h_shift), pool->stride_align[i]);
        }
    }
    for (; i < AV_NUM_DATA_POINTERS; i++) {
        pic->data[i] = NULL;
        pic->linesize[i] = 0;
    }
    if (pic->data[1] && !pic->data[2])
        avpriv_set_systematic_pal2((uint32_t *)pic->data[1], s->pix_fmt);
        av_log(s, AV_LOG_DEBUG, ""default_get_buffer called on pic %p\n"", pic);
fail:
    av_frame_unref(pic);
    return AVERROR(ENOMEM);
int avcodec_default_get_buffer2(AVCodecContext *avctx, AVFrame *frame, int flags)
    int ret;

    if ((ret = update_frame_pool(avctx, frame)) < 0)
        return ret;

#if FF_API_GET_BUFFER
#endif

#if FF_API_GET_BUFFER
int avcodec_default_get_buffer(AVCodecContext *avctx, AVFrame *frame)
    return avcodec_default_get_buffer2(avctx, frame, 0);
}

typedef struct CompatReleaseBufPriv {
    AVCodecContext avctx;
    AVFrame frame;
} CompatReleaseBufPriv;

static void compat_free_buffer(void *opaque, uint8_t *data)
{
    CompatReleaseBufPriv *priv = opaque;
    priv->avctx.release_buffer(&priv->avctx, &priv->frame);
    av_freep(&priv);
}

static void compat_release_buffer(void *opaque, uint8_t *data)
{
    AVBufferRef *buf = opaque;
    av_buffer_unref(&buf);
}
#endif

int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame, int flags)
{
    int ret;


        if ((ret = av_image_check_size(avctx->width, avctx->height, 0, avctx)) < 0)
            return ret;
#if FF_API_GET_BUFFER
    /*
     * Wrap an old get_buffer()-allocated buffer in an bunch of AVBuffers.
     * We wrap each plane in its own AVBuffer. Each of those has a reference to
     * a dummy AVBuffer as its private data, unreffing it on free.
     * When all the planes are freed, the dummy buffer's free callback calls
     * release_buffer().
     */
    if (avctx->get_buffer) {
        CompatReleaseBufPriv *priv = NULL;
        AVBufferRef *dummy_buf = NULL;
        int planes, i, ret;
        if (flags & AV_GET_BUFFER_FLAG_REF)
            frame->reference    = 1;
        ret = avctx->get_buffer(avctx, frame);
        if (ret < 0)
            return ret;
        /* return if the buffers are already set up
         * this would happen e.g. when a custom get_buffer() calls
         * avcodec_default_get_buffer
         */
        if (frame->buf[0])
            return 0;

        priv = av_mallocz(sizeof(*priv));
        if (!priv) {
            ret = AVERROR(ENOMEM);
            goto fail;
        }
        priv->avctx = *avctx;
        priv->frame = *frame;
        dummy_buf = av_buffer_create(NULL, 0, compat_free_buffer, priv, 0);
        if (!dummy_buf) {
            ret = AVERROR(ENOMEM);
            goto fail;
#define WRAP_PLANE(ref_out, data, data_size)                            \
do {                                                                    \
    AVBufferRef *dummy_ref = av_buffer_ref(dummy_buf);                  \
    if (!dummy_ref) {                                                   \
        ret = AVERROR(ENOMEM);                                          \
        goto fail;                                                      \
    }                                                                   \
    ref_out = av_buffer_create(data, data_size, compat_release_buffer,  \
                               dummy_ref, 0);                           \
    if (!ref_out) {                                                     \
        av_frame_unref(frame);                                          \
        ret = AVERROR(ENOMEM);                                          \
        goto fail;                                                      \
    }                                                                   \
} while (0)

        if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {
            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format);

            if (!desc) {
                ret = AVERROR(EINVAL);
                goto fail;
            }
            planes = (desc->flags & PIX_FMT_PLANAR) ? desc->nb_components : 1;
            for (i = 0; i < planes; i++) {
                int h_shift    = (i == 1 || i == 2) ? desc->log2_chroma_h : 0;
                int plane_size = (frame->width >> h_shift) * frame->linesize[i];
                WRAP_PLANE(frame->buf[i], frame->data[i], plane_size);
            }
        } else {
            int planar = av_sample_fmt_is_planar(frame->format);
            planes = planar ? avctx->channels : 1;

            if (planes > FF_ARRAY_ELEMS(frame->buf)) {
                frame->nb_extended_buf = planes - FF_ARRAY_ELEMS(frame->buf);
                frame->extended_buf = av_malloc(sizeof(*frame->extended_buf) *
                                                frame->nb_extended_buf);
                if (!frame->extended_buf) {
                    ret = AVERROR(ENOMEM);
                    goto fail;
                }
            }
            for (i = 0; i < FFMIN(planes, FF_ARRAY_ELEMS(frame->buf)); i++)
                WRAP_PLANE(frame->buf[i], frame->extended_data[i], frame->linesize[0]);

            for (i = 0; i < planes - FF_ARRAY_ELEMS(frame->buf); i++)
                WRAP_PLANE(frame->extended_buf[i],
                           frame->extended_data[i + FF_ARRAY_ELEMS(frame->buf)],
                           frame->linesize[0]);
        }

        av_buffer_unref(&dummy_buf);
        return 0;
fail:
        avctx->release_buffer(avctx, frame);
        av_freep(&priv);
        av_buffer_unref(&dummy_buf);
        return ret;
#endif

    return avctx->get_buffer2(avctx, frame, flags);
}

int ff_reget_buffer(AVCodecContext *avctx, AVFrame *frame)
{
    AVFrame tmp;
    int ret;
    av_assert0(avctx->codec_type == AVMEDIA_TYPE_VIDEO);

    if (!frame->data[0])
        return ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF);
    if (av_frame_is_writable(frame))

    av_frame_move_ref(&tmp, frame);

    ret = ff_get_buffer(avctx, frame, AV_GET_BUFFER_FLAG_REF);
    if (ret < 0) {
        av_frame_unref(&tmp);
        return ret;
    av_image_copy(frame->data, frame->linesize, tmp.data, tmp.linesize,
                  frame->format, frame->width, frame->height);

    av_frame_unref(&tmp);

#if FF_API_GET_BUFFER
void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic)
{
    av_frame_unref(pic);
}

int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)
{
    av_assert0(0);
}
#endif

    avctx->internal->pool = av_mallocz(sizeof(*avctx->internal->pool));
    if (!avctx->internal->pool) {
        ret = AVERROR(ENOMEM);
        goto free_and_end;
    }

    if (avctx->internal)
        av_freep(&avctx->internal->pool);
    AVCodecInternal *avci = avctx->internal;
    if (!avctx->refcounted_frames)
        av_frame_unref(&avci->to_free);

        if (ret < 0 && picture->data[0])
            av_frame_unref(picture);

        if (*got_picture_ptr) {
            if (!avctx->refcounted_frames) {
                avci->to_free = *picture;
                avci->to_free.extended_data = avci->to_free.data;
            }

        }
    AVCodecInternal *avci = avctx->internal;
    if (!avctx->refcounted_frames)
        av_frame_unref(&avci->to_free);


            if (!avctx->refcounted_frames) {
                avci->to_free = *frame;
                avci->to_free.extended_data = avci->to_free.data;
            }

        if (ret < 0 && frame->data[0])
            av_frame_unref(frame);
        FramePool *pool = avctx->internal->pool;
        int i;
        if (!avctx->refcounted_frames)
            av_frame_unref(&avctx->internal->to_free);
        for (i = 0; i < FF_ARRAY_ELEMS(pool->pools); i++)
            av_buffer_pool_uninit(&pool->pools[i]);
        av_freep(&avctx->internal->pool);
int ff_thread_ref_frame(ThreadFrame *dst, ThreadFrame *src)
{
    int ret;

    dst->owner = src->owner;

    ret = av_frame_ref(dst->f, src->f);
    if (ret < 0)
        return ret;

    if (src->progress &&
        !(dst->progress = av_buffer_ref(src->progress))) {
        ff_thread_release_buffer(dst->owner, dst);
        return AVERROR(ENOMEM);
    }

    return 0;
}

int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f, int flags)
    return ff_get_buffer(avctx, f, flags);
    av_frame_unref(f);","#define INTERNAL_BUFFER_SIZE (32 + 1)

static int audio_get_buffer(AVCodecContext *avctx, AVFrame *frame)
{
    AVCodecInternal *avci = avctx->internal;
    int buf_size, ret;

    av_freep(&avci->audio_data);
    buf_size = av_samples_get_buffer_size(NULL, avctx->channels,
                                          frame->nb_samples, avctx->sample_fmt,
                                          0);
    if (buf_size < 0)
        return AVERROR(EINVAL);

    frame->data[0] = av_mallocz(buf_size);
    if (!frame->data[0])
        return AVERROR(ENOMEM);

    ret = avcodec_fill_audio_frame(frame, avctx->channels, avctx->sample_fmt,
                                   frame->data[0], buf_size, 0);
    if (ret < 0) {
        av_freep(&frame->data[0]);
        return ret;
    }

    avci->audio_data = frame->data[0];
    if (avctx->debug & FF_DEBUG_BUFFERS)
        av_log(avctx, AV_LOG_DEBUG, ""default_get_buffer called on frame %p, ""
                                    ""internal audio buffer used\n"", frame);

    return 0;
}

static int video_get_buffer(AVCodecContext *s, AVFrame *pic)
    int i;
    int w = s->width;
    int h = s->height;
    InternalBuffer *buf;
    AVCodecInternal *avci = s->internal;

    if (pic->data[0] != NULL) {
        av_log(s, AV_LOG_ERROR, ""pic->data[0]!=NULL in avcodec_default_get_buffer\n"");
        return -1;
    }
    if (avci->buffer_count >= INTERNAL_BUFFER_SIZE) {
        av_log(s, AV_LOG_ERROR, ""buffer_count overflow (missing release_buffer?)\n"");
        return -1;
    }
    if (av_image_check_size(w, h, 0, s))
        return -1;

    if (!avci->buffer) {
        avci->buffer = av_mallocz((INTERNAL_BUFFER_SIZE + 1) *
                                  sizeof(InternalBuffer));
    }

    buf = &avci->buffer[avci->buffer_count];

    if (buf->base[0] && (buf->width != w || buf->height != h || buf->pix_fmt != s->pix_fmt)) {
        for (i = 0; i < AV_NUM_DATA_POINTERS; i++) {
            av_freep(&buf->base[i]);
            buf->data[i] = NULL;
        }
    }

    if (!buf->base[0]) {
        int h_chroma_shift, v_chroma_shift;
        int size[4] = { 0 };
        int tmpsize;
        int unaligned;
        int stride_align[AV_NUM_DATA_POINTERS];
        const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(s->pix_fmt);
        const int pixel_size = desc->comp[0].step_minus1 + 1;
        av_pix_fmt_get_chroma_sub_sample(s->pix_fmt, &h_chroma_shift,
                                         &v_chroma_shift);
        avcodec_align_dimensions2(s, &w, &h, stride_align);
        if (!(s->flags & CODEC_FLAG_EMU_EDGE)) {
            av_image_fill_linesizes(picture.linesize, s->pix_fmt, w);
                unaligned |= picture.linesize[i] % stride_align[i];
        tmpsize = av_image_fill_pointers(picture.data, s->pix_fmt, h, NULL, picture.linesize);
        memset(buf->base, 0, sizeof(buf->base));
        memset(buf->data, 0, sizeof(buf->data));
        for (i = 0; i < 4 && size[i]; i++) {
            const int h_shift = i == 0 ? 0 : h_chroma_shift;
            const int v_shift = i == 0 ? 0 : v_chroma_shift;
            buf->linesize[i] = picture.linesize[i];
            buf->base[i] = av_malloc(size[i] + 16); //FIXME 16
            if (buf->base[i] == NULL)
                return -1;
            // no edge if EDGE EMU or not planar YUV
            if ((s->flags & CODEC_FLAG_EMU_EDGE) || !size[2])
                buf->data[i] = buf->base[i];
            else
                buf->data[i] = buf->base[i] + FFALIGN((buf->linesize[i] * EDGE_WIDTH >> v_shift) + (pixel_size * EDGE_WIDTH >> h_shift), stride_align[i]);
        }
        for (; i < AV_NUM_DATA_POINTERS; i++) {
            buf->base[i]     = buf->data[i] = NULL;
            buf->linesize[i] = 0;
        if (size[1] && !size[2])
            avpriv_set_systematic_pal2((uint32_t *)buf->data[1], s->pix_fmt);
        buf->width   = s->width;
        buf->height  = s->height;
        buf->pix_fmt = s->pix_fmt;
    for (i = 0; i < AV_NUM_DATA_POINTERS; i++) {
        pic->base[i]     = buf->base[i];
        pic->data[i]     = buf->data[i];
        pic->linesize[i] = buf->linesize[i];
    avci->buffer_count++;
        av_log(s, AV_LOG_DEBUG, ""default_get_buffer called on pic %p, %d ""
                                ""buffers used\n"", pic, avci->buffer_count);
int avcodec_default_get_buffer(AVCodecContext *avctx, AVFrame *frame)
int ff_get_buffer(AVCodecContext *avctx, AVFrame *frame)
    return avctx->get_buffer(avctx, frame);
}
void avcodec_default_release_buffer(AVCodecContext *s, AVFrame *pic)
{
    int i;
    InternalBuffer *buf, *last;
    AVCodecInternal *avci = s->internal;
    assert(s->codec_type == AVMEDIA_TYPE_VIDEO);
    assert(pic->type == FF_BUFFER_TYPE_INTERNAL);
    assert(avci->buffer_count);
    if (avci->buffer) {
        buf = NULL; /* avoids warning */
        for (i = 0; i < avci->buffer_count; i++) { //just 3-5 checks so is not worth to optimize
            buf = &avci->buffer[i];
            if (buf->data[0] == pic->data[0])
                break;
        assert(i < avci->buffer_count);
        avci->buffer_count--;
        last = &avci->buffer[avci->buffer_count];
        if (buf != last)
            FFSWAP(InternalBuffer, *buf, *last);
    }
    for (i = 0; i < AV_NUM_DATA_POINTERS; i++)
        pic->data[i] = NULL;
//        pic->base[i]=NULL;
    if (s->debug & FF_DEBUG_BUFFERS)
        av_log(s, AV_LOG_DEBUG, ""default_release_buffer called on pic %p, %d ""
                                ""buffers used\n"", pic, avci->buffer_count);
}
int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)
{
    AVFrame temp_pic;
    int i;
    assert(s->codec_type == AVMEDIA_TYPE_VIDEO);
    /* If no picture return a new buffer */
    if (pic->data[0] == NULL) {
        /* We will copy from buffer, so must be readable */
        pic->buffer_hints |= FF_BUFFER_HINTS_READABLE;
        return ff_get_buffer(s, pic);
    assert(s->pix_fmt == pic->format);
    /* If internal buffer type return the same buffer */
    if (pic->type == FF_BUFFER_TYPE_INTERNAL) {
        if (s->pkt)
            pic->pkt_pts = s->pkt->pts;
        else
            pic->pkt_pts = AV_NOPTS_VALUE;
        pic->reordered_opaque = s->reordered_opaque;
    /*
     * Not internal type and reget_buffer not overridden, emulate cr buffer
     */
    temp_pic = *pic;
    for (i = 0; i < AV_NUM_DATA_POINTERS; i++)
        pic->data[i] = pic->base[i] = NULL;
    pic->opaque = NULL;
    /* Allocate new frame */
    if (ff_get_buffer(s, pic))
        return -1;
    /* Copy image data from old buffer to new buffer */
    av_picture_copy((AVPicture *)pic, (AVPicture *)&temp_pic, s->pix_fmt, s->width,
                    s->height);
    s->release_buffer(s, &temp_pic); // Release old frame
        if (*got_picture_ptr)
        avcodec_default_free_buffers(avctx);
static void video_free_buffers(AVCodecContext *s)
{
    AVCodecInternal *avci = s->internal;
    int i, j;

    if (!avci->buffer)
        return;

    if (avci->buffer_count)
        av_log(s, AV_LOG_WARNING, ""Found %i unreleased buffers!\n"",
               avci->buffer_count);
    for (i = 0; i < INTERNAL_BUFFER_SIZE; i++) {
        InternalBuffer *buf = &avci->buffer[i];
        for (j = 0; j < 4; j++) {
            av_freep(&buf->base[j]);
            buf->data[j] = NULL;
        }
    }
    av_freep(&avci->buffer);

    avci->buffer_count = 0;
}

static void audio_free_buffers(AVCodecContext *avctx)
{
    AVCodecInternal *avci = avctx->internal;
    av_freep(&avci->audio_data);
}

void avcodec_default_free_buffers(AVCodecContext *avctx)
{
    switch (avctx->codec_type) {
    case AVMEDIA_TYPE_VIDEO:
        video_free_buffers(avctx);
        break;
    case AVMEDIA_TYPE_AUDIO:
        audio_free_buffers(avctx);
        break;
    default:
        break;
    }
}

int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)
    return ff_get_buffer(avctx, f);
    f->owner->release_buffer(f->owner, f);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED," VAR VAR VAR(VAR *VAR, VAR *VAR) VAR *VAR = VAR->VAR->VAR; VAR VAR, VAR; VAR (VAR->VAR) { VAR VAR: { VAR VAR[4] = { 0 }; VAR VAR = VAR->VAR; VAR VAR = VAR->VAR; VAR VAR, VAR; VAR (VAR->VAR == VAR->VAR && VAR->VAR == VAR->VAR && VAR->VAR == VAR->VAR) VAR 0; VAR(VAR, &VAR, &VAR, VAR->VAR); VAR (!(VAR->VAR & VAR)) { VAR(VAR.VAR, VAR->VAR, VAR); VAR |= VAR.VAR[VAR] % VAR->VAR[VAR]; VAR = VAR(VAR.VAR, VAR->VAR, VAR, VAR, VAR.VAR); VAR (VAR = 0; VAR < 4; VAR++) { VAR(&VAR->VAR[VAR]); VAR->VAR[VAR] = VAR.VAR[VAR]; VAR (VAR[VAR]) { VAR->VAR[VAR] = VAR(VAR[VAR] + 16, VAR); VAR (!VAR->VAR[VAR]) { VAR = VAR(VAR); VAR VAR; } } } VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR; } VAR VAR: { VAR VAR = VAR(VAR->VAR); VAR VAR = VAR(VAR->VAR); VAR VAR = VAR ? VAR : 1; VAR (VAR->VAR == VAR->VAR && VAR->VAR == VAR && VAR->VAR == VAR && VAR->VAR == VAR->VAR) VAR 0; VAR(&VAR->VAR[0]); VAR = VAR(&VAR->VAR[0], VAR, VAR->VAR, VAR->VAR, 0); VAR (VAR < 0) VAR VAR; VAR->VAR[0] = VAR(VAR->VAR[0], VAR); VAR (!VAR->VAR[0]) { VAR = VAR(VAR); VAR VAR; } VAR->VAR = VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR; } VAR: VAR(0); } VAR 0; VAR: VAR (VAR = 0; VAR < 4; VAR++) VAR(&VAR->VAR[VAR]); VAR->VAR = -1; VAR->VAR = VAR->VAR = VAR->VAR = 0; VAR->VAR = VAR->VAR = 0; VAR VAR; } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR *VAR = VAR->VAR->VAR; VAR VAR = VAR->VAR; VAR VAR; VAR->VAR[0] = VAR->VAR[0]; VAR (VAR > VAR) { VAR->VAR = VAR(VAR * VAR(*VAR->VAR)); VAR->VAR = VAR - VAR; VAR->VAR = VAR(VAR->VAR * VAR(*VAR->VAR)); VAR (!VAR->VAR || !VAR->VAR) { VAR(&VAR->VAR); VAR(&VAR->VAR); VAR VAR(VAR); } VAR VAR->VAR = VAR->VAR; VAR (VAR = 0; VAR < VAR(VAR, VAR); VAR++) { VAR->VAR[VAR] = VAR(VAR->VAR[0]); VAR (!VAR->VAR[VAR]) VAR VAR; VAR->VAR[VAR] = VAR->VAR[VAR] = VAR->VAR[VAR]->VAR; VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR->VAR[VAR] = VAR(VAR->VAR[0]); VAR (!VAR->VAR[VAR]) VAR VAR; VAR->VAR[VAR + VAR] = VAR->VAR[VAR]->VAR; } VAR (VAR->VAR & VAR) VAR(VAR, VAR, ""VAR VAR VAR VAR %VAR"", VAR); VAR 0; VAR: VAR(VAR); VAR VAR(VAR); } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR *VAR = VAR->VAR->VAR; VAR VAR *VAR = VAR(VAR->VAR); VAR VAR = VAR->VAR[0].VAR + 1; VAR VAR, VAR; VAR VAR; VAR (VAR->VAR[0] != VAR) { VAR(VAR, VAR, ""VAR->VAR[0]!=VAR VAR VAR\VAR""); VAR -1; VAR(VAR->VAR, 0, VAR(VAR->VAR)); VAR(VAR->VAR, &VAR, &VAR); VAR (VAR = 0; VAR < 4 && VAR->VAR[VAR]; VAR++) { VAR VAR VAR = VAR == 0 ? 0 : VAR; VAR VAR VAR = VAR == 0 ? 0 : VAR; VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR(VAR->VAR[VAR]); VAR (!VAR->VAR[VAR]) VAR VAR;  VAR ((VAR->VAR & VAR) || !VAR->VAR[2]) VAR->VAR[VAR] = VAR->VAR[VAR]->VAR; VAR { VAR->VAR[VAR] = VAR->VAR[VAR]->VAR + VAR((VAR->VAR[VAR] * VAR >> VAR) + (VAR * VAR >> VAR), VAR->VAR[VAR]); } } VAR (; VAR < VAR; VAR++) { VAR->VAR[VAR] = VAR; VAR->VAR[VAR] = 0; } VAR (VAR->VAR[1] && !VAR->VAR[2]) VAR((VAR *)VAR->VAR[1], VAR->VAR); VAR(VAR, VAR, ""VAR VAR VAR VAR %VAR\VAR"", VAR); VAR: VAR(VAR); VAR VAR(VAR); VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR VAR; VAR ((VAR = VAR(VAR, VAR)) < 0) VAR VAR;    VAR VAR(VAR *VAR, VAR *VAR) VAR VAR(VAR, VAR, 0); } VAR VAR VAR { VAR VAR; VAR VAR; } VAR; VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR *VAR = VAR; VAR->VAR.VAR(&VAR->VAR, &VAR->VAR); VAR(&VAR); } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR *VAR = VAR; VAR(&VAR); }  VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) { VAR VAR; VAR ((VAR = VAR(VAR->VAR, VAR->VAR, 0, VAR)) < 0) VAR VAR;  /* * VAR VAR VAR VAR()-VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR, VAR VAR VAR'VAR VAR VAR VAR * VAR(). */ VAR (VAR->VAR) { VAR *VAR = VAR; VAR *VAR = VAR; VAR VAR, VAR, VAR; VAR (VAR & VAR) VAR->VAR = 1; VAR = VAR->VAR(VAR, VAR); VAR (VAR < 0) VAR VAR; /* VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR.VAR. VAR VAR VAR VAR() VAR * VAR */ VAR (VAR->VAR[0]) VAR 0; VAR = VAR(VAR(*VAR)); VAR (!VAR) { VAR = VAR(VAR); VAR VAR; } VAR->VAR = *VAR; VAR->VAR = *VAR; VAR = VAR(VAR, 0, VAR, VAR, 0); VAR (!VAR) { VAR = VAR(VAR); VAR VAR;  VAR { \ VAR *VAR = VAR(VAR); \ VAR (!VAR) { \ VAR = VAR(VAR); \ VAR VAR; \ } \ VAR = VAR(VAR, VAR, VAR, \ VAR, 0); \ VAR (!VAR) { \ VAR(VAR); \ VAR = VAR(VAR); \ VAR VAR; \ } \ } VAR (0) VAR (VAR->VAR == VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR (!VAR) { VAR = VAR(VAR); VAR VAR; } VAR = (VAR->VAR & VAR) ? VAR->VAR : 1; VAR (VAR = 0; VAR < VAR; VAR++) { VAR VAR = (VAR == 1 || VAR == 2) ? VAR->VAR : 0; VAR VAR = (VAR->VAR >> VAR) * VAR->VAR[VAR]; VAR(VAR->VAR[VAR], VAR->VAR[VAR], VAR); } } VAR { VAR VAR = VAR(VAR->VAR); VAR = VAR ? VAR->VAR : 1; VAR (VAR > VAR(VAR->VAR)) { VAR->VAR = VAR - VAR(VAR->VAR); VAR->VAR = VAR(VAR(*VAR->VAR) * VAR->VAR); VAR (!VAR->VAR) { VAR = VAR(VAR); VAR VAR; } } VAR (VAR = 0; VAR < VAR(VAR, VAR(VAR->VAR)); VAR++) VAR(VAR->VAR[VAR], VAR->VAR[VAR], VAR->VAR[0]); VAR (VAR = 0; VAR < VAR - VAR(VAR->VAR); VAR++) VAR(VAR->VAR[VAR], VAR->VAR[VAR + VAR(VAR->VAR)], VAR->VAR[0]); } VAR(&VAR); VAR 0; VAR: VAR->VAR(VAR, VAR); VAR(&VAR); VAR(&VAR); VAR VAR;  VAR VAR->VAR(VAR, VAR, VAR); } VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR; VAR VAR; VAR(VAR->VAR == VAR); VAR (!VAR->VAR[0]) VAR VAR(VAR, VAR, VAR); VAR (VAR(VAR)) VAR(&VAR, VAR); VAR = VAR(VAR, VAR, VAR); VAR (VAR < 0) { VAR(&VAR); VAR VAR; VAR(VAR->VAR, VAR->VAR, VAR.VAR, VAR.VAR, VAR->VAR, VAR->VAR, VAR->VAR); VAR(&VAR);  VAR VAR(VAR *VAR, VAR *VAR) { VAR(VAR); } VAR VAR(VAR *VAR, VAR *VAR) { VAR(0); }  VAR->VAR->VAR = VAR(VAR(*VAR->VAR->VAR)); VAR (!VAR->VAR->VAR) { VAR = VAR(VAR); VAR VAR; } VAR (VAR->VAR) VAR(&VAR->VAR->VAR); VAR *VAR = VAR->VAR; VAR (!VAR->VAR) VAR(&VAR->VAR); VAR (VAR < 0 && VAR->VAR[0]) VAR(VAR); VAR (*VAR) { VAR (!VAR->VAR) { VAR->VAR = *VAR; VAR->VAR.VAR = VAR->VAR.VAR; } } VAR *VAR = VAR->VAR; VAR (!VAR->VAR) VAR(&VAR->VAR); VAR (!VAR->VAR) { VAR->VAR = *VAR; VAR->VAR.VAR = VAR->VAR.VAR; } VAR (VAR < 0 && VAR->VAR[0]) VAR(VAR); VAR *VAR = VAR->VAR->VAR; VAR VAR; VAR (!VAR->VAR) VAR(&VAR->VAR->VAR); VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) VAR(&VAR->VAR[VAR]); VAR(&VAR->VAR->VAR); VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR; VAR->VAR = VAR->VAR; VAR = VAR(VAR->VAR, VAR->VAR); VAR (VAR < 0) VAR VAR; VAR (VAR->VAR && !(VAR->VAR = VAR(VAR->VAR))) { VAR(VAR->VAR, VAR); VAR VAR(VAR); } VAR 0; } VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR VAR(VAR, VAR, VAR); VAR(VAR);  VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR *VAR = VAR->VAR; VAR VAR, VAR; VAR(&VAR->VAR); VAR = VAR(VAR, VAR->VAR, VAR->VAR, VAR->VAR, 0); VAR (VAR < 0) VAR VAR(VAR); VAR->VAR[0] = VAR(VAR); VAR (!VAR->VAR[0]) VAR VAR(VAR); VAR = VAR(VAR, VAR->VAR, VAR->VAR, VAR->VAR[0], VAR, 0); VAR (VAR < 0) { VAR(&VAR->VAR[0]); VAR VAR; } VAR->VAR = VAR->VAR[0]; VAR (VAR->VAR & VAR) VAR(VAR, VAR, ""VAR VAR VAR VAR %VAR, "" ""VAR VAR VAR VAR\VAR"", VAR); VAR 0; } VAR VAR VAR(VAR *VAR, VAR *VAR) VAR VAR; VAR VAR = VAR->VAR; VAR VAR = VAR->VAR; VAR *VAR; VAR *VAR = VAR->VAR; VAR (VAR->VAR[0] != VAR) { VAR(VAR, VAR, ""VAR->VAR[0]!=VAR VAR VAR\VAR""); VAR -1; } VAR (VAR->VAR >= VAR) { VAR(VAR, VAR, ""VAR VAR (VAR VAR?)\VAR""); VAR -1; } VAR (VAR(VAR, VAR, 0, VAR)) VAR -1; VAR (!VAR->VAR) { VAR->VAR = VAR((VAR + 1) * VAR(VAR)); } VAR = &VAR->VAR[VAR->VAR]; VAR (VAR->VAR[0] && (VAR->VAR != VAR || VAR->VAR != VAR || VAR->VAR != VAR->VAR)) { VAR (VAR = 0; VAR < VAR; VAR++) { VAR(&VAR->VAR[VAR]); VAR->VAR[VAR] = VAR; } } VAR (!VAR->VAR[0]) { VAR VAR, VAR; VAR VAR[4] = { 0 }; VAR VAR; VAR VAR; VAR VAR[VAR]; VAR VAR *VAR = VAR(VAR->VAR); VAR VAR VAR = VAR->VAR[0].VAR + 1; VAR(VAR->VAR, &VAR, &VAR); VAR(VAR, &VAR, &VAR, VAR); VAR (!(VAR->VAR & VAR)) { VAR(VAR.VAR, VAR->VAR, VAR); VAR |= VAR.VAR[VAR] % VAR[VAR]; VAR = VAR(VAR.VAR, VAR->VAR, VAR, VAR, VAR.VAR); VAR(VAR->VAR, 0, VAR(VAR->VAR)); VAR(VAR->VAR, 0, VAR(VAR->VAR)); VAR (VAR = 0; VAR < 4 && VAR[VAR]; VAR++) { VAR VAR VAR = VAR == 0 ? 0 : VAR; VAR VAR VAR = VAR == 0 ? 0 : VAR; VAR->VAR[VAR] = VAR.VAR[VAR]; VAR->VAR[VAR] = VAR(VAR[VAR] + 16);  VAR (VAR->VAR[VAR] == VAR) VAR -1;  VAR ((VAR->VAR & VAR) || !VAR[2]) VAR->VAR[VAR] = VAR->VAR[VAR]; VAR VAR->VAR[VAR] = VAR->VAR[VAR] + VAR((VAR->VAR[VAR] * VAR >> VAR) + (VAR * VAR >> VAR), VAR[VAR]); } VAR (; VAR < VAR; VAR++) { VAR->VAR[VAR] = VAR->VAR[VAR] = VAR; VAR->VAR[VAR] = 0; VAR (VAR[1] && !VAR[2]) VAR((VAR *)VAR->VAR[1], VAR->VAR); VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR++; VAR(VAR, VAR, ""VAR VAR VAR VAR %VAR, %VAR "" ""VAR VAR\VAR"", VAR, VAR->VAR); VAR VAR(VAR *VAR, VAR *VAR) VAR VAR(VAR *VAR, VAR *VAR) VAR VAR->VAR(VAR, VAR); } VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR; VAR *VAR, *VAR; VAR *VAR = VAR->VAR; VAR(VAR->VAR == VAR); VAR(VAR->VAR == VAR); VAR(VAR->VAR); VAR (VAR->VAR) { VAR = VAR;  VAR (VAR = 0; VAR < VAR->VAR; VAR++) {  VAR = &VAR->VAR[VAR]; VAR (VAR->VAR[0] == VAR->VAR[0]) VAR; VAR(VAR < VAR->VAR); VAR->VAR--; VAR = &VAR->VAR[VAR->VAR]; VAR (VAR != VAR) VAR(VAR, *VAR, *VAR); } VAR (VAR = 0; VAR < VAR; VAR++) VAR->VAR[VAR] = VAR;  VAR (VAR->VAR & VAR) VAR(VAR, VAR, ""VAR VAR VAR VAR %VAR, %VAR "" ""VAR VAR\VAR"", VAR, VAR->VAR); } VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR; VAR VAR; VAR(VAR->VAR == VAR);  VAR (VAR->VAR[0] == VAR) {  VAR->VAR |= VAR; VAR VAR(VAR, VAR); VAR(VAR->VAR == VAR->VAR);  VAR (VAR->VAR == VAR) { VAR (VAR->VAR) VAR->VAR = VAR->VAR->VAR; VAR VAR->VAR = VAR; VAR->VAR = VAR->VAR; /* * VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR */ VAR = *VAR; VAR (VAR = 0; VAR < VAR; VAR++) VAR->VAR[VAR] = VAR->VAR[VAR] = VAR; VAR->VAR = VAR;  VAR (VAR(VAR, VAR)) VAR -1;  VAR((VAR *)VAR, (VAR *)&VAR, VAR->VAR, VAR->VAR, VAR->VAR); VAR->VAR(VAR, &VAR);  VAR (*VAR) VAR(VAR); VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR VAR, VAR; VAR (!VAR->VAR) VAR; VAR (VAR->VAR) VAR(VAR, VAR, ""VAR %VAR VAR VAR!\VAR"", VAR->VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR *VAR = &VAR->VAR[VAR]; VAR (VAR = 0; VAR < 4; VAR++) { VAR(&VAR->VAR[VAR]); VAR->VAR[VAR] = VAR; } } VAR(&VAR->VAR); VAR->VAR = 0; } VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR(&VAR->VAR); } VAR VAR(VAR *VAR) { VAR (VAR->VAR) { VAR VAR: VAR(VAR); VAR; VAR VAR: VAR(VAR); VAR; VAR: VAR; } } VAR VAR(VAR *VAR, VAR *VAR) VAR VAR(VAR, VAR); VAR->VAR->VAR(VAR->VAR, VAR);",1,15
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/vp8.c,"static int vp8_alloc_frame(VP8Context *s, VP8Frame *f, int ref)
    if ((ret = ff_thread_get_buffer(s->avctx, &f->tf,
                                    ref ? AV_GET_BUFFER_FLAG_REF : 0)) < 0)
    if (!(f->seg_map = av_buffer_allocz(s->mb_width * s->mb_height))) {
        ff_thread_release_buffer(s->avctx, &f->tf);
static void vp8_release_frame(VP8Context *s, VP8Frame *f)
    av_buffer_unref(&f->seg_map);
    ff_thread_release_buffer(s->avctx, &f->tf);
}

static int vp8_ref_frame(VP8Context *s, VP8Frame *dst, VP8Frame *src)
{
    int ret;

    vp8_release_frame(s, dst);

    if ((ret = ff_thread_ref_frame(&dst->tf, &src->tf)) < 0)
        return ret;
    if (src->seg_map &&
        !(dst->seg_map = av_buffer_ref(src->seg_map))) {
        vp8_release_frame(s, dst);
        return AVERROR(ENOMEM);

    return 0;

static void vp8_decode_flush_impl(AVCodecContext *avctx, int free_mem)
    for (i = 0; i < FF_ARRAY_ELEMS(s->frames); i++)
        vp8_release_frame(s, &s->frames[i]);
    if (free_mem)
    vp8_decode_flush_impl(avctx, 0);
        vp8_decode_flush_impl(s->avctx, 1);
                 ThreadFrame *ref, const VP56mv *mv,
    uint8_t *src = ref->f->data[0];
                   ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off,
    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];
                 ThreadFrame *ref_frame, int x_off, int y_off,
        uint8_t **src= s->framep[ref]->tf.f->data;
    ThreadFrame *ref = &s->framep[mb->ref_frame]->tf;
static void vp8_decode_mv_mb_modes(AVCodecContext *avctx, VP8Frame *curframe,
                                   VP8Frame *prev_frame)
            decode_mb_mode(s, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy,
                           prev_frame && prev_frame->seg_map ?
                           prev_frame->seg_map->data + mb_xy : NULL, 1);
    VP8Frame *curframe = s->curframe, *prev_frame = s->prev_frame;
        curframe->tf.f->data[0] + 16*mb_y*s->linesize,
        curframe->tf.f->data[1] +  8*mb_y*s->uvlinesize,
        curframe->tf.f->data[2] +  8*mb_y*s->uvlinesize
                dst[i][y*curframe->tf.f->linesize[i]-1] = 129;
            decode_mb_mode(s, mb, mb_x, mb_y, curframe->seg_map->data + mb_xy,
                           prev_frame && prev_frame->seg_map ?
                           prev_frame->seg_map->data + mb_xy : NULL, 0);
    AVFrame *curframe = s->curframe->tf.f;
    VP8Frame *curframe = s->curframe;
            ff_thread_report_progress(&curframe->tf, mb_y, 0);
    VP8Frame *av_uninit(curframe), *prev_frame;
        if (s->frames[i].tf.f->data[0] &&
            vp8_release_frame(s, &s->frames[i]);
    if (curframe->tf.f->data[0])
        vp8_release_frame(s, curframe);
    curframe->tf.f->key_frame = s->keyframe;
    curframe->tf.f->pict_type = s->keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;
    if ((ret = vp8_alloc_frame(s, curframe, referenced))) {
    s->linesize   = curframe->tf.f->linesize[0];
    s->uvlinesize = curframe->tf.f->linesize[1];
        ff_thread_await_progress(&prev_frame->tf, 1, 0);
    ff_thread_report_progress(&curframe->tf, INT_MAX, 0);
        if ((ret = av_frame_ref(data, curframe->tf.f)) < 0)
            return ret;
static av_cold int vp8_decode_free(AVCodecContext *avctx)
{
    VP8Context *s = avctx->priv_data;
    int i;

    vp8_decode_flush_impl(avctx, 1);
    for (i = 0; i < FF_ARRAY_ELEMS(s->frames); i++)
        av_frame_free(&s->frames[i].tf.f);

    return 0;
}

static av_cold int vp8_init_frames(VP8Context *s)
{
    int i;
    for (i = 0; i < FF_ARRAY_ELEMS(s->frames); i++) {
        s->frames[i].tf.f = av_frame_alloc();
        if (!s->frames[i].tf.f)
            return AVERROR(ENOMEM);
    }
    return 0;
}

    int ret;
    avctx->internal->allocate_progress = 1;
    if ((ret = vp8_init_frames(s)) < 0) {
        vp8_decode_free(avctx);
        return ret;
    }
    int ret;
    if ((ret = vp8_init_frames(s)) < 0) {
        vp8_decode_free(avctx);
        return ret;
    }

    int i;
    for (i = 0; i < FF_ARRAY_ELEMS(s_src->frames); i++) {
        if (s_src->frames[i].tf.f->data[0]) {
            int ret = vp8_ref_frame(s, &s->frames[i], &s_src->frames[i]);
            if (ret < 0)
                return ret;
        }
    }
","static int vp8_alloc_frame(VP8Context *s, AVFrame *f)
    if ((ret = ff_thread_get_buffer(s->avctx, f)) < 0)
    if (s->num_maps_to_be_freed && !s->maps_are_invalid) {
        f->ref_index[0] = s->segmentation_maps[--s->num_maps_to_be_freed];
    } else if (!(f->ref_index[0] = av_mallocz(s->mb_width * s->mb_height))) {
        ff_thread_release_buffer(s->avctx, f);
static void vp8_release_frame(VP8Context *s, AVFrame *f, int prefer_delayed_free, int can_direct_free)
    if (f->ref_index[0]) {
        if (prefer_delayed_free) {
            /* Upon a size change, we want to free the maps but other threads may still
             * be using them, so queue them. Upon a seek, all threads are inactive so
             * we want to cache one to prevent re-allocation in the next decoding
             * iteration, but the rest we can free directly. */
            int max_queued_maps = can_direct_free ? 1 : FF_ARRAY_ELEMS(s->segmentation_maps);
            if (s->num_maps_to_be_freed < max_queued_maps) {
                s->segmentation_maps[s->num_maps_to_be_freed++] = f->ref_index[0];
            } else if (can_direct_free) /* vp8_decode_flush(), but our queue is full */ {
                av_free(f->ref_index[0]);
            } /* else: MEMLEAK (should never happen, but better that than crash) */
            f->ref_index[0] = NULL;
        } else /* vp8_decode_free() */ {
            av_free(f->ref_index[0]);
        }
    ff_thread_release_buffer(s->avctx, f);
static void vp8_decode_flush_impl(AVCodecContext *avctx,
                                  int prefer_delayed_free, int can_direct_free, int free_mem)
    if (!avctx->internal->is_copy) {
        for (i = 0; i < 5; i++)
            if (s->frames[i].data[0])
                vp8_release_frame(s, &s->frames[i], prefer_delayed_free, can_direct_free);
    }
    if (free_mem) {
        s->maps_are_invalid = 1;
    }
    vp8_decode_flush_impl(avctx, 1, 1, 0);
        vp8_decode_flush_impl(s->avctx, 1, 0, 1);
                 AVFrame *ref, const VP56mv *mv,
    uint8_t *src = ref->data[0];
                   AVFrame *ref, const VP56mv *mv, int x_off, int y_off,
    uint8_t *src1 = ref->data[1], *src2 = ref->data[2];
                 AVFrame *ref_frame, int x_off, int y_off,
        uint8_t **src= s->framep[ref]->data;
    AVFrame *ref = s->framep[mb->ref_frame];
static void release_queued_segmaps(VP8Context *s, int is_close)
{
    int leave_behind = is_close ? 0 : !s->maps_are_invalid;
    while (s->num_maps_to_be_freed > leave_behind)
        av_freep(&s->segmentation_maps[--s->num_maps_to_be_freed]);
    s->maps_are_invalid = 0;
}

static void vp8_decode_mv_mb_modes(AVCodecContext *avctx, AVFrame *curframe,
                                   AVFrame *prev_frame)
            decode_mb_mode(s, mb, mb_x, mb_y, curframe->ref_index[0] + mb_xy,
                           prev_frame && prev_frame->ref_index[0] ? prev_frame->ref_index[0] + mb_xy : NULL, 1);
    AVFrame *curframe = s->curframe, *prev_frame = s->prev_frame;
        curframe->data[0] + 16*mb_y*s->linesize,
        curframe->data[1] +  8*mb_y*s->uvlinesize,
        curframe->data[2] +  8*mb_y*s->uvlinesize
                dst[i][y*curframe->linesize[i]-1] = 129;
            decode_mb_mode(s, mb, mb_x, mb_y, curframe->ref_index[0] + mb_xy,
                           prev_frame && prev_frame->ref_index[0] ? prev_frame->ref_index[0] + mb_xy : NULL, 0);
    AVFrame *curframe = s->curframe;
    AVFrame *curframe = s->curframe;
            ff_thread_report_progress(curframe, mb_y, 0);
    AVFrame *av_uninit(curframe), *prev_frame;

    release_queued_segmaps(s, 0);
        if (s->frames[i].data[0] &&
            vp8_release_frame(s, &s->frames[i], 1, 0);
    if (curframe->data[0])
        vp8_release_frame(s, curframe, 1, 0);
    curframe->key_frame = s->keyframe;
    curframe->pict_type = s->keyframe ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;
    curframe->reference = referenced ? 3 : 0;
    if ((ret = vp8_alloc_frame(s, curframe))) {
    s->linesize   = curframe->linesize[0];
    s->uvlinesize = curframe->linesize[1];
        ff_thread_await_progress(prev_frame, 1, 0);
    ff_thread_report_progress(curframe, INT_MAX, 0);
        *(AVFrame*)data = *curframe;
    return 0;
}
static av_cold int vp8_decode_free(AVCodecContext *avctx)
{
    vp8_decode_flush_impl(avctx, 0, 1, 1);
    release_queued_segmaps(avctx->priv_data, 1);
        s->maps_are_invalid = 1;
    memcpy(&s->frames, &s_src->frames, sizeof(s->frames));",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR ((VAR = VAR(VAR->VAR, &VAR->VAR, VAR ? VAR : 0)) < 0) VAR (!(VAR->VAR = VAR(VAR->VAR * VAR->VAR))) { VAR(VAR->VAR, &VAR->VAR); VAR VAR VAR(VAR *VAR, VAR *VAR) VAR(&VAR->VAR); VAR(VAR->VAR, &VAR->VAR); } VAR VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR) { VAR VAR; VAR(VAR, VAR); VAR ((VAR = VAR(&VAR->VAR, &VAR->VAR)) < 0) VAR VAR; VAR (VAR->VAR && !(VAR->VAR = VAR(VAR->VAR))) { VAR(VAR, VAR); VAR VAR(VAR); VAR 0; VAR VAR VAR(VAR *VAR, VAR VAR) VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) VAR(VAR, &VAR->VAR[VAR]); VAR (VAR) VAR(VAR, 0); VAR(VAR->VAR, 1); VAR *VAR, VAR VAR *VAR, VAR *VAR = VAR->VAR->VAR[0]; VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR, VAR *VAR = VAR->VAR->VAR[1], *VAR = VAR->VAR->VAR[2]; VAR *VAR, VAR VAR, VAR VAR, VAR **VAR= VAR->VAR[VAR]->VAR.VAR->VAR; VAR *VAR = &VAR->VAR[VAR->VAR]->VAR; VAR VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR) VAR(VAR, VAR, VAR, VAR, VAR->VAR->VAR + VAR, VAR && VAR->VAR ? VAR->VAR->VAR + VAR : VAR, 1); VAR *VAR = VAR->VAR, *VAR = VAR->VAR; VAR->VAR.VAR->VAR[0] + 16*VAR*VAR->VAR, VAR->VAR.VAR->VAR[1] + 8*VAR*VAR->VAR, VAR->VAR.VAR->VAR[2] + 8*VAR*VAR->VAR VAR[VAR][VAR*VAR->VAR.VAR->VAR[VAR]-1] = 129; VAR(VAR, VAR, VAR, VAR, VAR->VAR->VAR + VAR, VAR && VAR->VAR ? VAR->VAR->VAR + VAR : VAR, 0); VAR *VAR = VAR->VAR->VAR.VAR; VAR *VAR = VAR->VAR; VAR(&VAR->VAR, VAR, 0); VAR *VAR(VAR), *VAR; VAR (VAR->VAR[VAR].VAR.VAR->VAR[0] && VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR.VAR->VAR[0]) VAR(VAR, VAR); VAR->VAR.VAR->VAR = VAR->VAR; VAR->VAR.VAR->VAR = VAR->VAR ? VAR : VAR; VAR ((VAR = VAR(VAR, VAR, VAR))) { VAR->VAR = VAR->VAR.VAR->VAR[0]; VAR->VAR = VAR->VAR.VAR->VAR[1]; VAR(&VAR->VAR, 1, 0); VAR(&VAR->VAR, VAR, 0); VAR ((VAR = VAR(VAR, VAR->VAR.VAR)) < 0) VAR VAR; VAR VAR VAR VAR(VAR *VAR) { VAR *VAR = VAR->VAR; VAR VAR; VAR(VAR, 1); VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) VAR(&VAR->VAR[VAR].VAR.VAR); VAR 0; } VAR VAR VAR VAR(VAR *VAR) { VAR VAR; VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR->VAR[VAR].VAR.VAR = VAR(); VAR (!VAR->VAR[VAR].VAR.VAR) VAR VAR(VAR); } VAR 0; } VAR VAR; VAR->VAR->VAR = 1; VAR ((VAR = VAR(VAR)) < 0) { VAR(VAR); VAR VAR; } VAR VAR; VAR ((VAR = VAR(VAR)) < 0) { VAR(VAR); VAR VAR; } VAR VAR; VAR (VAR = 0; VAR < VAR(VAR->VAR); VAR++) { VAR (VAR->VAR[VAR].VAR.VAR->VAR[0]) { VAR VAR = VAR(VAR, &VAR->VAR[VAR], &VAR->VAR[VAR]); VAR (VAR < 0) VAR VAR; } } VAR VAR VAR(VAR *VAR, VAR *VAR) VAR ((VAR = VAR(VAR->VAR, VAR)) < 0) VAR (VAR->VAR && !VAR->VAR) { VAR->VAR[0] = VAR->VAR[--VAR->VAR]; } VAR VAR (!(VAR->VAR[0] = VAR(VAR->VAR * VAR->VAR))) { VAR(VAR->VAR, VAR); VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR, VAR VAR) VAR (VAR->VAR[0]) { VAR (VAR) { /* VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR, VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR = VAR ? 1 : VAR(VAR->VAR); VAR (VAR->VAR < VAR) { VAR->VAR[VAR->VAR++] = VAR->VAR[0]; } VAR VAR (VAR) { VAR(VAR->VAR[0]); }  VAR->VAR[0] = VAR; } VAR { VAR(VAR->VAR[0]); } VAR(VAR->VAR, VAR); VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR, VAR VAR) VAR (!VAR->VAR->VAR) { VAR (VAR = 0; VAR < 5; VAR++) VAR (VAR->VAR[VAR].VAR[0]) VAR(VAR, &VAR->VAR[VAR], VAR, VAR); } VAR (VAR) { VAR->VAR = 1; } VAR(VAR, 1, 1, 0); VAR(VAR->VAR, 1, 0, 1); VAR *VAR, VAR VAR *VAR, VAR *VAR = VAR->VAR[0]; VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR, VAR *VAR = VAR->VAR[1], *VAR = VAR->VAR[2]; VAR *VAR, VAR VAR, VAR VAR, VAR **VAR= VAR->VAR[VAR]->VAR; VAR *VAR = VAR->VAR[VAR->VAR]; VAR VAR VAR(VAR *VAR, VAR VAR) { VAR VAR = VAR ? 0 : !VAR->VAR; VAR (VAR->VAR > VAR) VAR(&VAR->VAR[--VAR->VAR]); VAR->VAR = 0; } VAR VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR) VAR(VAR, VAR, VAR, VAR, VAR->VAR[0] + VAR, VAR && VAR->VAR[0] ? VAR->VAR[0] + VAR : VAR, 1); VAR *VAR = VAR->VAR, *VAR = VAR->VAR; VAR->VAR[0] + 16*VAR*VAR->VAR, VAR->VAR[1] + 8*VAR*VAR->VAR, VAR->VAR[2] + 8*VAR*VAR->VAR VAR[VAR][VAR*VAR->VAR[VAR]-1] = 129; VAR(VAR, VAR, VAR, VAR, VAR->VAR[0] + VAR, VAR && VAR->VAR[0] ? VAR->VAR[0] + VAR : VAR, 0); VAR *VAR = VAR->VAR; VAR *VAR = VAR->VAR; VAR(VAR, VAR, 0); VAR *VAR(VAR), *VAR; VAR(VAR, 0); VAR (VAR->VAR[VAR].VAR[0] && VAR(VAR, &VAR->VAR[VAR], 1, 0); VAR (VAR->VAR[0]) VAR(VAR, VAR, 1, 0); VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR ? VAR : VAR; VAR->VAR = VAR ? 3 : 0; VAR ((VAR = VAR(VAR, VAR))) { VAR->VAR = VAR->VAR[0]; VAR->VAR = VAR->VAR[1]; VAR(VAR, 1, 0); VAR(VAR, VAR, 0); *(VAR*)VAR = *VAR; VAR 0; } VAR VAR VAR VAR(VAR *VAR) { VAR(VAR, 0, 1, 1); VAR(VAR->VAR, 1); VAR->VAR = 1; VAR(&VAR->VAR, &VAR->VAR, VAR(VAR->VAR));",1,15
FFmpeg_821a5938d100458f4d09d634041b05c860554ce0,libavcodec/g2meet.c,"        c->tile_stride = FFALIGN(c->tile_width, 16) * 3;","        c->tile_stride = FFALIGN(c->tile_width * 3, 16);",821a5938d100458f4d09d634041b05c860554ce0,CVE-2013-7013,821a5938d100458f4d09d634041b05c860554ce0,https://github.com/FFmpeg/FFmpeg,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR->VAR = VAR(VAR->VAR, 16) * 3; VAR->VAR = VAR(VAR->VAR * 3, 16);",1,15
FFmpeg_92f9b28ed84a77138105475beba16c146bdaf984,libavcodec/rpzaenc.c,"        for (x = 0; x < bi->block_width; x++) {
        for (j = 0; j < bi->block_width; j++) {
        for (j = 0; j < bi->block_width; j++) {
    const int y_size = FFMIN(4, bi->image_height - bi->row * 4);

    for (int y = 0; y < y_size; y++) {
                int y_size, rgb555;
                y_size = FFMIN(4, bi.image_height - bi.row * 4);
                for (int y = 0; y < y_size; y++) {
                    for (int x = 0; x < 4; x++) {
                for (int y = y_size; y < 4; y++) {
                    for (int x = 0; x < 4; x++)
                        put_bits(&s->pb, 16, 0);
                }
","        for (x = 0; x < bi->block_width; x++){
        for (j = 0; j < bi->block_width; j++){
        for (j = 0; j < bi->block_width; j++){
    for (int y = 0; y < 4; y++) {
                int rgb555;
                for (int y = 0; y < 4; y++) {
                    for (int x = 0; x < 4; x++){",92f9b28ed84a77138105475beba16c146bdaf984,CVE-2022-3964,92f9b28ed84a77138105475beba16c146bdaf984,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,80,COMPLETED,"VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR VAR VAR = VAR(4, VAR->VAR - VAR->VAR * 4); VAR (VAR VAR = 0; VAR < VAR; VAR++) { VAR VAR, VAR; VAR = VAR(4, VAR.VAR - VAR.VAR * 4); VAR (VAR VAR = 0; VAR < VAR; VAR++) { VAR (VAR VAR = 0; VAR < 4; VAR++) { VAR (VAR VAR = VAR; VAR < 4; VAR++) { VAR (VAR VAR = 0; VAR < 4; VAR++) VAR(&VAR->VAR, 16, 0); } VAR (VAR = 0; VAR < VAR->VAR; VAR++){ VAR (VAR = 0; VAR < VAR->VAR; VAR++){ VAR (VAR = 0; VAR < VAR->VAR; VAR++){ VAR (VAR VAR = 0; VAR < 4; VAR++) { VAR VAR; VAR (VAR VAR = 0; VAR < 4; VAR++) { VAR (VAR VAR = 0; VAR < 4; VAR++){",1,15
FreeRDP_c098f21fdaadca57ff649eee1674f6cc321a2ec4,winpr/libwinpr/sspi/NTLM/ntlm_compute.c,"	if (Stream_GetRemainingLength(s) < 28)
		return -1;

	if (Stream_GetRemainingLength(s) < 16)
		return -1;",,c098f21fdaadca57ff649eee1674f6cc321a2ec4,CVE-2020-11086,c098f21fdaadca57ff649eee1674f6cc321a2ec4,https://github.com/FreeRDP/FreeRDP,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR (VAR(VAR) < 28) VAR -1; VAR (VAR(VAR) < 16) VAR -1; ,1,15
go_6446af942e2e2b161c4ec1b60d9703a2b55dc4dd,src/net/http/internal/chunked.go,"	checkEnd bool  // whether need to check for \r\n chunk footer
	excess   int64 // ""excessive"" chunk overhead, for malicious sender detection
	cr.excess += int64(len(line)) + 2 // header, plus \r\n after the chunk data
	line = trimTrailingWhitespace(line)
	line, cr.err = removeChunkExtension(line)
	if cr.err != nil {
		return
	}
	// A sender who sends one byte per chunk will send 5 bytes of overhead
	// for every byte of data. (""1\r\nX\r\n"" to send ""X"".)
	// We want to allow this, since streaming a byte at a time can be legitimate.
	//
	// A sender can use chunk extensions to add arbitrary amounts of additional
	// data per byte read. (""1;very long extension\r\nX\r\n"" to send ""X"".)
	// We don't want to disallow extensions (although we discard them),
	// but we also don't want to allow a sender to reduce the signal/noise ratio
	// arbitrarily.
	//
	// We track the amount of excess overhead read,
	// and produce an error if it grows too large.
	//
	// Currently, we say that we're willing to accept 16 bytes of overhead per chunk,
	// plus twice the amount of real data in the chunk.
	cr.excess -= 16 + (2 * int64(cr.n))
	if cr.excess < 0 {
		cr.excess = 0
	}
	if cr.excess > 16*1024 {
		cr.err = errors.New(""chunked encoding contains too much non-data"")
	}","	checkEnd bool // whether need to check for \r\n chunk footer
	p = trimTrailingWhitespace(p)
	p, err = removeChunkExtension(p)
	if err != nil {
		return nil, err
	}",6446af942e2e2b161c4ec1b60d9703a2b55dc4dd,CVE-2023-39326,6446af942e2e2b161c4ec1b60d9703a2b55dc4dd,https://github.com/golang/go,CPE_GIT_REPOBASED,150,COMPLETED,"VAR VAR  VAR VAR  VAR.VAR += VAR(VAR(VAR)) + 2  VAR = VAR(VAR) VAR, VAR.VAR = VAR(VAR) VAR VAR.VAR != VAR { VAR }                VAR.VAR -= 16 + (2 * VAR(VAR.VAR)) VAR VAR.VAR < 0 { VAR.VAR = 0 } VAR VAR.VAR > 16*1024 { VAR.VAR = VAR.VAR(""VAR VAR VAR VAR VAR VAR-VAR"") } VAR VAR  VAR = VAR(VAR) VAR, VAR = VAR(VAR) VAR VAR != VAR { VAR VAR, VAR }",1,15
gpac_3d17f9524b48e8564bba50055c3502e660c41a64,src/isomedia/box_code_base.c,"	if (ptr->original_4cc) {
		u32 t = s->type;
		s->type=ptr->original_4cc;
		e = gf_isom_box_write_header(s, bs);
		s->type=t;
	} else {
		e = gf_isom_box_write_header(s, bs);
	}
	if (p->grouping_type_parameter) p->version=1;

	GF_DefaultSampleGroupDescriptionEntry *ptr;
	case GF_4CC('l','i','n','f'):
	{
		GF_LHVCLayerInformation *ptr = gf_isom_linf_new_entry();
		u32 s = (u32) gf_bs_get_position(bs);
		gf_isom_linf_read_entry(ptr, bs);
		*total_bytes = (u32) gf_bs_get_position(bs) - s;
		return ptr;
	}
		break;
	case GF_4CC( 'n', 'a', 'l', 'm' ):
		u64 start = gf_bs_get_position(bs);
		Bool rle, large_size;
		u32 entry_count;
		gf_bs_read_int(bs, 6);
		large_size = gf_bs_read_int(bs, 1);
		rle = gf_bs_read_int(bs, 1);
		entry_count = gf_bs_read_int(bs, large_size ? 16 : 8);
		gf_bs_seek(bs, start);
		entry_size = 1 + large_size ? 2 : 1;
		entry_size += entry_count * 2;
		if (rle) entry_size += entry_count * (large_size ? 2 : 1);

		break;
	default:
		break;

	if (!entry_size) return NULL;
	GF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry);
	if (!ptr) return NULL;
	ptr->length = entry_size;
	ptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length);
	gf_bs_read_data(bs, (char *) ptr->data, ptr->length);
	*total_bytes = entry_size;
	return ptr;
	case GF_4CC( 'l', 'i', 'n', 'f' ):
		gf_isom_linf_del_entry(entry);
		return;
	case GF_4CC( 'l', 'i', 'n', 'f' ):
		gf_isom_linf_write_entry(entry, bs);
		return;
	case GF_4CC( 'l', 'i', 'n', 'f' ):
		return gf_isom_linf_size_entry(entry);","	e = gf_isom_box_write_header(s, bs);
	default:
		GF_DefaultSampleGroupDescriptionEntry *ptr;
		if (!entry_size) return NULL;
		GF_SAFEALLOC(ptr, GF_DefaultSampleGroupDescriptionEntry);
		if (!ptr) return NULL;
		ptr->length = entry_size;
		ptr->data = (u8 *) gf_malloc(sizeof(u8)*ptr->length);
		gf_bs_read_data(bs, (char *) ptr->data, ptr->length);
		*total_bytes = entry_size;
		return ptr;
	return NULL;",3d17f9524b48e8564bba50055c3502e660c41a64,CVE-2018-1000100,3d17f9524b48e8564bba50055c3502e660c41a64,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,76,COMPLETED,"VAR (VAR->VAR) { VAR VAR = VAR->VAR; VAR->VAR=VAR->VAR; VAR = VAR(VAR, VAR); VAR->VAR=VAR; } VAR { VAR = VAR(VAR, VAR); } VAR (VAR->VAR) VAR->VAR=1; VAR *VAR; VAR VAR('VAR','VAR','VAR','VAR'): { VAR *VAR = VAR(); VAR VAR = (VAR) VAR(VAR); VAR(VAR, VAR); *VAR = (VAR) VAR(VAR) - VAR; VAR VAR; } VAR; VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR' ): VAR VAR = VAR(VAR); VAR VAR, VAR; VAR VAR; VAR(VAR, 6); VAR = VAR(VAR, 1); VAR = VAR(VAR, 1); VAR = VAR(VAR, VAR ? 16 : 8); VAR(VAR, VAR); VAR = 1 + VAR ? 2 : 1; VAR += VAR * 2; VAR (VAR) VAR += VAR * (VAR ? 2 : 1); VAR; VAR: VAR; VAR (!VAR) VAR VAR; VAR(VAR, VAR); VAR (!VAR) VAR VAR; VAR->VAR = VAR; VAR->VAR = (VAR *) VAR(VAR(VAR)*VAR->VAR); VAR(VAR, (VAR *) VAR->VAR, VAR->VAR); *VAR = VAR; VAR VAR; VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR' ): VAR(VAR); VAR; VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR' ): VAR(VAR, VAR); VAR; VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR' ): VAR VAR(VAR); VAR = VAR(VAR, VAR); VAR: VAR *VAR; VAR (!VAR) VAR VAR; VAR(VAR, VAR); VAR (!VAR) VAR VAR; VAR->VAR = VAR; VAR->VAR = (VAR *) VAR(VAR(VAR)*VAR->VAR); VAR(VAR, (VAR *) VAR->VAR, VAR->VAR); *VAR = VAR; VAR VAR; VAR VAR;",1,15
gpac_3d17f9524b48e8564bba50055c3502e660c41a64,src/isomedia/box_dump.c,"	if (ptr->version==1) {
		if (isalnum(ptr->grouping_type_parameter&0xFF)) {
			fprintf(trace, "" grouping_type_parameter=\""%s\"""", gf_4cc_to_str(ptr->grouping_type_parameter) );
		} else {
			fprintf(trace, "" grouping_type_parameter=\""%d\"""", ptr->grouping_type_parameter);
		}
	}
static void linf_dump(GF_LHVCLayerInformation *ptr, FILE * trace)
{
	u32 i, count;

	count = gf_list_count(ptr->num_layers_in_track);
	fprintf(trace, ""<LayerInformation num_layers=\""%d\"">\n"", count );
	for (i = 0; i < count; i++) {
		LHVCLayerInfoItem *li = (LHVCLayerInfoItem *)gf_list_get(ptr->num_layers_in_track, i);
		fprintf(trace, ""<LayerInfoItem layer_id=\""%d\"" min_temporalId=\""%d\"" max_temporalId=\""%d\"" sub_layer_presence_flags=\""%d\""/>\n"", li->layer_id, li->min_TemporalId, li->max_TemporalId, li->sub_layer_presence_flags);
	}
	fprintf(trace, ""</LayerInformation>\n"");
	return;
}

static void trif_dump(FILE * trace, char *data, u32 data_size)
{
	GF_BitStream *bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);
	u32 x,y,w,h, id, independent, filter_disabled;
	Bool full_picture, has_dep, tile_group;

	id = gf_bs_read_u16(bs);
	tile_group = gf_bs_read_int(bs, 1);
	fprintf(trace, ""<TileRegionGroupEntry ID=\""%d\"" tileGroup=\""%d\"" "", id, tile_group);
	if (tile_group) {
		independent = gf_bs_read_int(bs, 2);
		full_picture = (Bool)gf_bs_read_int(bs, 1);
		filter_disabled = gf_bs_read_int(bs, 1);
		has_dep = gf_bs_read_int(bs, 1);
		gf_bs_read_int(bs, 2);
		fprintf(trace, ""independent=\""%d\"" full_picture=\""%d\"" filter_disabled=\""%d\"" "", independent, full_picture, filter_disabled);

		if (!full_picture) {
			fprintf(trace, ""x=\""%d\"" y=\""%d\"" "", gf_bs_read_u16(bs), gf_bs_read_u16(bs));
		}
		fprintf(trace, ""w=\""%d\"" h=\""%d\"" "", gf_bs_read_u16(bs), gf_bs_read_u16(bs));
		if (!has_dep) {
			fprintf(trace, ""/>\n"");
		} else {
			u32 count = gf_bs_read_u16(bs);
			fprintf(trace, "">\n"");
			while (count) {
				count--;
				fprintf(trace, ""<TileRegionDependency tileID=\""%d\""/>\n"", gf_bs_read_u16(bs) );
			}
			fprintf(trace, ""</TileRegionGroupEntry>\n"");
		}
	}
	gf_bs_del(bs);
}

static void nalm_dump(FILE * trace, char *data, u32 data_size)
{
	GF_BitStream *bs = gf_bs_new(data, data_size, GF_BITSTREAM_READ);
	Bool rle, large_size;
	u32 entry_count;
	gf_bs_read_int(bs, 6);
	large_size = gf_bs_read_int(bs, 1);
	rle = gf_bs_read_int(bs, 1);
	entry_count = gf_bs_read_int(bs, large_size ? 16 : 8);
	fprintf(trace, ""<NALUMap rle=\""%d\"" large_size=\""%d\"">\n"", rle, large_size);

	while (entry_count) {
		u32 ID;
		fprintf(trace, ""<NALUMapEntry "");
		if (rle) {
			u32 start_num = gf_bs_read_int(bs, large_size ? 16 : 8);
			fprintf(trace, ""NALU_startNumber=\""%d\"" "", start_num);
		}
		ID = gf_bs_read_u16(bs);
		fprintf(trace, ""groupID=\""%d\""/>\n"", ID);
		entry_count--;
	}
	gf_bs_del(bs);
	fprintf(trace, ""</NALUMap>\n"");
	return;
}

		case GF_4CC( 'l', 'i', 'n', 'f'):
			linf_dump(entry, trace);
			break;
			trif_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);
			break;

		case GF_4CC( 'n', 'a', 'l', 'm'):
			nalm_dump(trace, (char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data,  ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length);","	if (ptr->version==1) fprintf(trace, "" grouping_type_parameter=\""%d\"""", ptr->grouping_type_parameter);
		{
			u32 x,y,w,h, id, independent;
			Bool full_picture;

			gf_isom_parse_trif_info( (const char *) ((GF_DefaultSampleGroupDescriptionEntry*)entry)->data, ((GF_DefaultSampleGroupDescriptionEntry*)entry)->length, &id, &independent, &full_picture, &x, &y, &w, &h);
			fprintf(trace, ""<TileRegionGroupEntry ID=\""%d\"" independent=\""%d\"""", id, independent);
			if (!full_picture) fprintf(trace, "" horizontal_offset=\""%d\"" vertical_offset=\""%d\"""", x, y);
			fprintf(trace, "" region_width=\""%d\"" region_height=\""%d\""/>\n"", w, h);
		}",3d17f9524b48e8564bba50055c3502e660c41a64,CVE-2018-1000100,3d17f9524b48e8564bba50055c3502e660c41a64,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,76,COMPLETED,"VAR (VAR->VAR==1) { VAR (VAR(VAR->VAR&0xFF)) { VAR(VAR, "" VAR=\""%VAR\"""", VAR(VAR->VAR) ); } VAR { VAR(VAR, "" VAR=\""%VAR\"""", VAR->VAR); } } VAR VAR VAR(VAR *VAR, VAR * VAR) { VAR VAR, VAR; VAR = VAR(VAR->VAR); VAR(VAR, ""<VAR VAR=\""%VAR\"">\VAR"", VAR ); VAR (VAR = 0; VAR < VAR; VAR++) { VAR *VAR = (VAR *)VAR(VAR->VAR, VAR); VAR(VAR, ""<VAR VAR=\""%VAR\"" VAR=\""%VAR\"" VAR=\""%VAR\"" VAR=\""%VAR\""/>\VAR"", VAR->VAR, VAR->VAR, VAR->VAR, VAR->VAR); } VAR(VAR, ""</VAR>\VAR""); VAR; } VAR VAR VAR(VAR * VAR, VAR *VAR, VAR VAR) { VAR *VAR = VAR(VAR, VAR, VAR); VAR VAR,VAR,VAR,VAR, VAR, VAR, VAR; VAR VAR, VAR, VAR; VAR = VAR(VAR); VAR = VAR(VAR, 1); VAR(VAR, ""<VAR VAR=\""%VAR\"" VAR=\""%VAR\"" "", VAR, VAR); VAR (VAR) { VAR = VAR(VAR, 2); VAR = (VAR)VAR(VAR, 1); VAR = VAR(VAR, 1); VAR = VAR(VAR, 1); VAR(VAR, 2); VAR(VAR, ""VAR=\""%VAR\"" VAR=\""%VAR\"" VAR=\""%VAR\"" "", VAR, VAR, VAR); VAR (!VAR) { VAR(VAR, ""VAR=\""%VAR\"" VAR=\""%VAR\"" "", VAR(VAR), VAR(VAR)); } VAR(VAR, ""VAR=\""%VAR\"" VAR=\""%VAR\"" "", VAR(VAR), VAR(VAR)); VAR (!VAR) { VAR(VAR, ""/>\VAR""); } VAR { VAR VAR = VAR(VAR); VAR(VAR, "">\VAR""); VAR (VAR) { VAR--; VAR(VAR, ""<VAR VAR=\""%VAR\""/>\VAR"", VAR(VAR) ); } VAR(VAR, ""</VAR>\VAR""); } } VAR(VAR); } VAR VAR VAR(VAR * VAR, VAR *VAR, VAR VAR) { VAR *VAR = VAR(VAR, VAR, VAR); VAR VAR, VAR; VAR VAR; VAR(VAR, 6); VAR = VAR(VAR, 1); VAR = VAR(VAR, 1); VAR = VAR(VAR, VAR ? 16 : 8); VAR(VAR, ""<VAR VAR=\""%VAR\"" VAR=\""%VAR\"">\VAR"", VAR, VAR); VAR (VAR) { VAR VAR; VAR(VAR, ""<VAR ""); VAR (VAR) { VAR VAR = VAR(VAR, VAR ? 16 : 8); VAR(VAR, ""VAR=\""%VAR\"" "", VAR); } VAR = VAR(VAR); VAR(VAR, ""VAR=\""%VAR\""/>\VAR"", VAR); VAR--; } VAR(VAR); VAR(VAR, ""</VAR>\VAR""); VAR; } VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR'): VAR(VAR, VAR); VAR; VAR(VAR, (VAR *) ((VAR*)VAR)->VAR, ((VAR*)VAR)->VAR); VAR; VAR VAR( 'VAR', 'VAR', 'VAR', 'VAR'): VAR(VAR, (VAR *) ((VAR*)VAR)->VAR, ((VAR*)VAR)->VAR); VAR (VAR->VAR==1) VAR(VAR, "" VAR=\""%VAR\"""", VAR->VAR); { VAR VAR,VAR,VAR,VAR, VAR, VAR; VAR VAR; VAR( (VAR VAR *) ((VAR*)VAR)->VAR, ((VAR*)VAR)->VAR, &VAR, &VAR, &VAR, &VAR, &VAR, &VAR, &VAR); VAR(VAR, ""<VAR VAR=\""%VAR\"" VAR=\""%VAR\"""", VAR, VAR); VAR (!VAR) VAR(VAR, "" VAR=\""%VAR\"" VAR=\""%VAR\"""", VAR, VAR); VAR(VAR, "" VAR=\""%VAR\"" VAR=\""%VAR\""/>\VAR"", VAR, VAR); }",1,15
gpac_51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,src/media_tools/av_parsers.c,"	if ((sps_id < 0) || (sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 255)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 64))
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((sps_id<0) || (sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((pps_id<0) || (pps_id >= 64))","	if (sps_id >= 32) {
		return -1;
	}
	if (sps_id < 0) {
	if (pps_id >= 255) {
	if (pps->sps_id >= 32) {
	if (pps_id >= 64)
	if (vps_id >= 16) return -1;
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (vps_id >= 16) return -1;
	if (sps_id >= 16) {
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (pps_id >= 64)",51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,CVE-2021-30020,51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR ((VAR < 0) || (VAR >= 32)) { VAR ((VAR<0) || (VAR >= 255)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 32)) { VAR ((VAR<0) || (VAR >= 64)) VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 64)) VAR (VAR >= 32) { VAR -1; } VAR (VAR < 0) { VAR (VAR >= 255) { VAR (VAR->VAR >= 32) { VAR (VAR >= 64) VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 64),1,15
gpac_51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,src/media_tools/av_parsers.c,"	if ((sps_id < 0) || (sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 255)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 64))
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((sps_id<0) || (sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((pps_id<0) || (pps_id >= 64))","	if (sps_id >= 32) {
		return -1;
	}
	if (sps_id < 0) {
	if (pps_id >= 255) {
	if (pps->sps_id >= 32) {
	if (pps_id >= 64)
	if (vps_id >= 16) return -1;
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (vps_id >= 16) return -1;
	if (sps_id >= 16) {
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (pps_id >= 64)",51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,CVE-2021-30022,51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR ((VAR < 0) || (VAR >= 32)) { VAR ((VAR<0) || (VAR >= 255)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 32)) { VAR ((VAR<0) || (VAR >= 64)) VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 64)) VAR (VAR >= 32) { VAR -1; } VAR (VAR < 0) { VAR (VAR >= 255) { VAR (VAR->VAR >= 32) { VAR (VAR >= 64) VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 64),1,15
gpac_51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,src/media_tools/av_parsers.c,"	if ((sps_id < 0) || (sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 255)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 32)) {
	if ((pps_id<0) || (pps_id >= 64))
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) return -1;
	if ((sps_id<0) || (sps_id >= 16)) {
	if ((vps_id<0) || (vps_id >= 16)) {
	if ((pps->sps_id<0) || (pps->sps_id >= 16)) {
	if ((pps_id<0) || (pps_id >= 64))","	if (sps_id >= 32) {
		return -1;
	}
	if (sps_id < 0) {
	if (pps_id >= 255) {
	if (pps->sps_id >= 32) {
	if (pps_id >= 64)
	if (vps_id >= 16) return -1;
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (vps_id >= 16) return -1;
	if (sps_id >= 16) {
	if (vps_id >= 16) {
	if (pps->sps_id >= 16) {
	if (pps_id >= 64)",51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,CVE-2021-30014,51cdb67ff7c5f1242ac58c5aa603ceaf1793b788,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR ((VAR < 0) || (VAR >= 32)) { VAR ((VAR<0) || (VAR >= 255)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 32)) { VAR ((VAR<0) || (VAR >= 64)) VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) VAR -1; VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR<0) || (VAR >= 16)) { VAR ((VAR->VAR<0) || (VAR->VAR >= 16)) { VAR ((VAR<0) || (VAR >= 64)) VAR (VAR >= 32) { VAR -1; } VAR (VAR < 0) { VAR (VAR >= 255) { VAR (VAR->VAR >= 32) { VAR (VAR >= 64) VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 16) VAR -1; VAR (VAR >= 16) { VAR (VAR >= 16) { VAR (VAR->VAR >= 16) { VAR (VAR >= 64),1,15
gpac_8986422c21fbd9a7bf6561cae65aae42077447e8,src/isomedia/box_code_drm.c,"		if ((iv_size!=8) && (iv_size!=16)) {
			GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Invalid constant IV size %d, must be 8 or 16\n"", (u32) iv_size));
			ptr->key_info[20] = 16;
			return GF_NON_COMPLIANT_BITSTREAM;
		}
	else if ((iv_size!=0) && (iv_size!=8) && (iv_size!=16)) {
		GF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (""[iso file] Invalid IV size %d, must be 0, 8 or 16\n"", (u32) iv_size));
		return GF_NON_COMPLIANT_BITSTREAM;
	}",,8986422c21fbd9a7bf6561cae65aae42077447e8,CVE-2021-31254,8986422c21fbd9a7bf6561cae65aae42077447e8,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ((VAR!=8) && (VAR!=16)) { VAR(VAR, VAR, (""[VAR VAR] VAR VAR VAR VAR %VAR, VAR VAR 8 VAR 16\VAR"", (VAR) VAR)); VAR->VAR[20] = 16; VAR VAR; } VAR VAR ((VAR!=0) && (VAR!=8) && (VAR!=16)) { VAR(VAR, VAR, (""[VAR VAR] VAR VAR VAR %VAR, VAR VAR 0, 8 VAR 16\VAR"", (VAR) VAR)); VAR VAR; } ",1,15
gpac_c26b0aa605aaea1f0ebe8d21fe1398d94680adf7,src/odf/odf_code.c,			if (nbBytes + 16 > DescSize) return GF_ODF_INVALID_DESCRIPTOR;,			if (nbBytes>DescSize) break;,c26b0aa605aaea1f0ebe8d21fe1398d94680adf7,CVE-2020-19751,c26b0aa605aaea1f0ebe8d21fe1398d94680adf7,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,110,COMPLETED,VAR (VAR + 16 > VAR) VAR VAR; VAR (VAR>VAR) VAR;,1,15
gpac_d7c2bb5cc3c67566f506f51cbefbf66f8169ea85,src/media_tools/av_parsers.c,"	state->equal_picture_interval = gf_bs_read_int(bs, 3);
	if (state->equal_picture_interval) {
	u8 operating_points_cnt_minus_1, buffer_delay_length_minus_1 = 0;
	Bool timing_info_present_flag, initial_display_delay_present_flag;
			state->decoder_model_info_present_flag = gf_bs_read_int(bs, 1);
			if (state->decoder_model_info_present_flag) {
			state->decoder_model_info_present_flag = GF_FALSE;
			if (state->decoder_model_info_present_flag) {
	state->frame_width_bits_minus_1 = gf_bs_read_int(bs, 4);
	state->frame_height_bits_minus_1 = gf_bs_read_int(bs, 4);
	state->width = gf_bs_read_int(bs,  state->frame_width_bits_minus_1  + 1) + 1;
	state->height = gf_bs_read_int(bs, state->frame_height_bits_minus_1 + 1) + 1;
		state->delta_frame_id_length_minus_2 = gf_bs_read_int(bs, 4);
		state->additional_frame_id_length_minus_1 = gf_bs_read_int(bs, 3);
		enable_ref_frame_mvs = 0;*/
		state->enable_order_hint = GF_FALSE;
		state->OrderHintBits = 0;
		state->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;
		state->seq_force_screen_content_tools = 2/*SELECT_SCREEN_CONTENT_TOOLS*/;
		Bool seq_choose_screen_content_tools;
		state->enable_order_hint = gf_bs_read_int(bs, 1);
		if (state->enable_order_hint) {
			state->enable_ref_frame_mvs = gf_bs_read_int(bs, 1);
		state->seq_force_screen_content_tools = 0;
			state->seq_force_screen_content_tools = 2/*SELECT_SCREEN_CONTENT_TOOLS*/;
			state->seq_force_screen_content_tools = gf_bs_read_int(bs, 1);
		state->seq_force_integer_mv = 0;
		if (state->seq_force_screen_content_tools > 0) {
				state->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;
				state->seq_force_integer_mv = gf_bs_read_int(bs, 1);
			state->seq_force_integer_mv = 2/*SELECT_INTEGER_MV*/;
		if (state->enable_order_hint) {
			u8 order_hint_bits_minus_1 = gf_bs_read_int(bs, 3);
			state->OrderHintBits = order_hint_bits_minus_1 + 1;
			state->OrderHintBits = 0;
	state->enable_superres = gf_bs_read_int(bs, 1);
	AV1_KEY_FRAME = 0,
	AV1_INTER_FRAME = 1,
	AV1_INTRA_ONLY_FRAME = 2,
	AV1_SWITCH_FRAME = 3,
#define AV1_NUM_REF_FRAMES 8
#define AV1_ALL_FRAMES ((1 << AV1_NUM_REF_FRAMES) - 1)

#define AV1_SUPERRES_DENOM_MIN 9
#define AV1_SUPERRES_DENOM_BITS 3
#define AV1_SUPERRES_NUM 8

#define AV1_REFS_PER_FRAME 7
#define AV1_PRIMARY_REF_NONE 7

static u64 aom_av1_le(GF_BitStream *bs, u32 n) {
	u32 i = 0;
	u64 t = 0;
	for (i = 0; i < n; i++) {
		u8 byte = gf_bs_read_int(bs, 8);
		t += (byte << (i * 8));
	}
	return t;
}

static void av1_parse_tile_info(GF_BitStream *bs, AV1State *state)
		minLog2tileRows = MAX((int)(minLog2Tiles - state->tileColsLog2), 0);
			u32 maxWidth = MIN((int)(sbCols - startSb), maxTileWidthSb);
			u32 maxHeight = MIN((int)(sbRows - startSb), maxTileHeightSb);
		/*context_update_tile_id = */gf_bs_read_int(bs, state->tileRowsLog2 + state->tileColsLog2);
		state->tile_size_bytes = gf_bs_read_int(bs, 2) + 1;
	}
}

static void superres_params(GF_BitStream *bs, AV1State *state)
{
	u32 SuperresDenom;
	Bool use_superres;

	if (state->enable_superres) {
		use_superres = gf_bs_read_int(bs, 1);
	} else {
		use_superres = GF_FALSE;
	}
	if (use_superres) {
		u8 coded_denom = gf_bs_read_int(bs, AV1_SUPERRES_DENOM_BITS);
		SuperresDenom = coded_denom + AV1_SUPERRES_DENOM_MIN;
	} else {
		SuperresDenom = AV1_SUPERRES_NUM;
	}
	state->UpscaledWidth = state->width;
	state->width = (state->UpscaledWidth * AV1_SUPERRES_NUM + (SuperresDenom / 2)) / SuperresDenom;
}

static void frame_size(GF_BitStream *bs, AV1State *state, Bool frame_size_override_flag)
{
	if (frame_size_override_flag) {
		u32 frame_width_minus_1, frame_height_minus_1;
		u8 n = state->frame_width_bits_minus_1 + 1;
		frame_width_minus_1 = gf_bs_read_int(bs, n);
		n = state->frame_height_bits_minus_1 + 1;
		frame_height_minus_1 = gf_bs_read_int(bs, n);
		state->width = frame_width_minus_1 + 1;
		state->height = frame_height_minus_1 + 1;
	}
	superres_params(bs, state);
	//compute_image_size();
}

static void render_size(GF_BitStream *bs)
{
	Bool render_and_frame_size_different = gf_bs_read_int(bs, 1);
	if (render_and_frame_size_different == GF_TRUE) {
		/*render_width_minus_1 =*/ gf_bs_read_int(bs, 16);
		/*render_height_minus_1 =*/ gf_bs_read_int(bs, 16);
		//RenderWidth = render_width_minus_1 + 1;
		//RenderHeight = render_height_minus_1 + 1;
	} else {
		//RenderWidth = UpscaledWidth;
		//RenderHeight = FrameHeight;
	}
}

static void read_interpolation_filter(GF_BitStream *bs)
{
	Bool is_filter_switchable = gf_bs_read_int(bs, 1);
	if (!is_filter_switchable) {
		/*interpolation_filter =*/ gf_bs_read_int(bs, 2);
	}
}

static void frame_size_with_refs(GF_BitStream *bs, AV1State *state, Bool frame_size_override_flag)
{
	Bool found_ref = GF_FALSE;
	u32 i = 0;
	for (i = 0; i < AV1_REFS_PER_FRAME; i++) {
		found_ref = gf_bs_read_int(bs, 1);
		if (found_ref == 1) {
#if 0
			UpscaledWidth = RefUpscaledWidth[ref_frame_idx[i]];
			FrameWidth = UpscaledWidth;
			FrameHeight = RefFrameHeight[ref_frame_idx[i]];
			RenderWidth = RefRenderWidth[ref_frame_idx[i]];
			RenderHeight = RefRenderHeight[ref_frame_idx[i]];
#endif
			break;
		}
	}
	if (found_ref == 0) {
		frame_size(bs, state, frame_size_override_flag);
		render_size(bs);
	} else {
		superres_params(bs, state);
		//compute_image_size();
	Bool error_resilient_mode = GF_FALSE, allow_screen_content_tools = GF_FALSE, force_integer_mv = GF_FALSE;
	Bool use_ref_frame_mvs = GF_FALSE, FrameIsIntra = GF_FALSE, frame_size_override_flag = GF_FALSE;
	Bool disable_cdf_update = GF_FALSE, refresh_frame_flags = GF_FALSE;
	u8 primary_ref_frame;
	u16 idLen = 0;
	AV1FrameType frame_type;


		idLen = (state->additional_frame_id_length_minus_1 + state->delta_frame_id_length_minus_2 + 3);

		FrameIsIntra = GF_TRUE;
		frame_type = AV1_KEY_FRAME;
		frame_state->show_frame = GF_TRUE;
			/*frame_to_show_map_idx = gf_bs_read_int(bs, 3);
			if (state->decoder_model_info_present_flag && !state->equal_picture_interval) {
				temporal_point_info();
			refresh_frame_flags = 0;
				display_frame_id = gf_bs_read_int(bs, idLen);
			if (frame_type == AV1_KEY_FRAME) {
				refresh_frame_flags = AV1_ALL_FRAMES;
		FrameIsIntra = (frame_type == AV1_INTRA_ONLY_FRAME || frame_type == AV1_KEY_FRAME);
		frame_state->show_frame = gf_bs_read_int(bs, 1);
		frame_state->key_frame = frame_state->seen_seq_header && frame_state->show_frame && frame_type == AV1_KEY_FRAME && frame_state->seen_frame_header;
		if (frame_state->show_frame && state->decoder_model_info_present_flag && !state->equal_picture_interval) {
			GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[AV1] temporal_point_info() not implemented (1)\n""));
			assert(0);
			return;
		}
		if (!frame_state->show_frame) {
			/*showable_frame = */gf_bs_read_int(bs, 1);
		}
		if (frame_type == AV1_SWITCH_FRAME || (frame_type == AV1_KEY_FRAME && frame_state->show_frame))
			error_resilient_mode = GF_TRUE;
		else
			error_resilient_mode = gf_bs_read_int(bs, 1);
	}

	disable_cdf_update = gf_bs_read_int(bs, 1);
	if (state->seq_force_screen_content_tools == 2/*SELECT_SCREEN_CONTENT_TOOLS*/) {
		allow_screen_content_tools = gf_bs_read_int(bs, 1);
	} else {
		allow_screen_content_tools = state->seq_force_screen_content_tools;
	}
	if (allow_screen_content_tools) {
		if (state->seq_force_integer_mv == 2/*SELECT_INTEGER_MV*/) {
			force_integer_mv = gf_bs_read_int(bs, 1);
		} else {
			force_integer_mv = state->seq_force_integer_mv;
		}
	} else {
		force_integer_mv = 0;
	}
	if (FrameIsIntra) {
		force_integer_mv = 1;
	}
	if (state->frame_id_numbers_present_flag) {
		/*current_frame_id = */gf_bs_read_int(bs, idLen);
	}
	if (frame_type == AV1_SWITCH_FRAME)
		frame_size_override_flag =  GF_TRUE;
	else if (state->reduced_still_picture_header)
		frame_size_override_flag = GF_FALSE;
	else
		frame_size_override_flag = gf_bs_read_int(bs, 1);

	/*order_hint = */gf_bs_read_int(bs, state->OrderHintBits);
	if (FrameIsIntra || error_resilient_mode) {
		primary_ref_frame = AV1_PRIMARY_REF_NONE;
	} else {
		primary_ref_frame = gf_bs_read_int(bs, 3);
	}

	if (state->decoder_model_info_present_flag) {
		GF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (""[AV1] decoder model info present parsing\n""));
		assert(0);
		return;
#if 0
		buffer_removal_time_present_flag = gf_bs_read_int(bs, 1);
		if (buffer_removal_time_present_flag) {
			for (opNum = 0; opNum <= operating_points_cnt_minus_1; opNum++) {
				if (decoder_model_present_for_this_op[opNum]) {
					opPtIdc = operating_point_idc[opNum];
					inTemporalLayer = (opPtIdc >> temporal_id) & 1;
					inSpatialLayer = (opPtIdc >> (spatial_id + 8)) & 1;
					if (opPtIdc == 0 || (inTemporalLayer && inSpatialLayer)) {
						n = buffer_removal_time_length_minus_1 + 1;
						buffer_removal_time[opNum] = gf_bs_read_int(bs, n);
					}
				}
			}
		}
#endif
	}
	if (frame_type == AV1_SWITCH_FRAME || (frame_type == AV1_KEY_FRAME && frame_state->show_frame)) {
		refresh_frame_flags  = AV1_ALL_FRAMES;
	} else {
		refresh_frame_flags = gf_bs_read_int(bs, 8);
	}
	if (!FrameIsIntra || refresh_frame_flags != AV1_ALL_FRAMES) {
		if (error_resilient_mode && state->enable_order_hint) {
			u32 i = 0;
			for (i = 0; i < AV1_NUM_REF_FRAMES; i++) {
				/*ref_order_hint[i] = */gf_bs_read_int(bs, state->OrderHintBits);
			}
		}

	if (frame_type == AV1_KEY_FRAME) {
		frame_size(bs, state, frame_size_override_flag);
		render_size(bs);
		if (allow_screen_content_tools && state->UpscaledWidth == state->width) {
			/*allow_intrabc = */gf_bs_read_int(bs, 1);
		}
	} else {
		if (frame_type == AV1_INTRA_ONLY_FRAME) {
			frame_size(bs, state, frame_size_override_flag);
			render_size(bs);
			if (allow_screen_content_tools && state->UpscaledWidth == state->width) {
				/*allow_intrabc = */gf_bs_read_int(bs, 1);
			}
		} else {
			u32 i = 0;
			Bool frame_refs_short_signaling = GF_FALSE;
			if (state->enable_order_hint) {
				frame_refs_short_signaling = gf_bs_read_int(bs, 1);
				if (frame_refs_short_signaling) {
					/*last_frame_idx =*/ gf_bs_read_int(bs, 3);
					/*gold_frame_idx =*/ gf_bs_read_int(bs, 3);
					//set_frame_refs();
				}
			}
			for (i = 0; i < AV1_REFS_PER_FRAME; i++) {
				if (!frame_refs_short_signaling)
					/*ref_frame_idx[i] =*/ gf_bs_read_int(bs, 3);
					if (state->frame_id_numbers_present_flag) {
						u32 n = state->delta_frame_id_length_minus_2 + 2;
						/*delta_frame_id_minus_1 =*/ gf_bs_read_int(bs, n);
						//DeltaFrameId = delta_frame_id_minus_1 + 1;
						//expectedFrameId[i] = ((current_frame_id + (1 << idLen) - DeltaFrameId) % (1 << idLen));
					}
			}
			if (frame_size_override_flag && !error_resilient_mode) {
				frame_size_with_refs(bs, state, frame_size_override_flag);
			} else {
				frame_size(bs, state, frame_size_override_flag);
				render_size(bs);
			}
			if (!force_integer_mv) {
				/*allow_high_precision_mv = */gf_bs_read_int(bs, 1);
			}

			read_interpolation_filter(bs);

			/*is_motion_mode_switchable =*/ gf_bs_read_int(bs, 1);
			if (! (error_resilient_mode || !state->enable_ref_frame_mvs) ) {
				use_ref_frame_mvs = gf_bs_read_int(bs, 1);
			}
		}
	}

	if ( !(state->reduced_still_picture_header || disable_cdf_update) )
		/*disable_frame_end_update_cdf = */gf_bs_read_int(bs, 1);

	if (primary_ref_frame == AV1_PRIMARY_REF_NONE) {
		//init_non_coeff_cdfs();
		//setup_past_independence();
	} else {
		//load_cdfs(ref_frame_idx[primary_ref_frame]);
		//load_previous();
	}

	av1_parse_tile_info(bs, state);

	//incomplete parsing
static void av1_parse_tile_group(GF_BitStream *bs, AV1State *state, u64 bs_end_of_obu_position)
	u32 TileNum, tg_start, tg_end;
		/*state->frame_state.tg[0].start_idx = 0;
		state->frame_state.tg[0].end_idx = numTiles - 1;*/
		/*state->frame_state.tg[state->frame_state.tg_idx].start_idx*/ tg_start = gf_bs_read_int(bs, tileBits);
		/*state->frame_state.tg[state->frame_state.tg_idx].end_idx*/ tg_end = gf_bs_read_int(bs, tileBits);
	/*state->frame_state.tg_idx++;*/

	gf_bs_align(bs);
	for (TileNum = tg_start; TileNum <= tg_end; TileNum++) {
		u32 tileRow = TileNum / state->tileCols;
		u32 tileCol = TileNum % state->tileCols;
		Bool lastTile = TileNum == tg_end;
		u64 pos = gf_bs_get_position(bs);
		if (lastTile) {
			state->frame_state.tg[state->frame_state.tile_idx].bs_start = pos;
			state->frame_state.tg[state->frame_state.tile_idx].size = (u32)(bs_end_of_obu_position - pos);
		} else {
			u64 tile_size_minus_1 = aom_av1_le(bs, state->tile_size_bytes);
			pos = gf_bs_get_position(bs);
			state->frame_state.tg[state->frame_state.tile_idx].bs_start = pos;
			state->frame_state.tg[state->frame_state.tile_idx].size = (u32)(tile_size_minus_1 + 1/* + state->tile_size_bytes*/);
		}
		gf_bs_seek(bs, pos + state->frame_state.tg[state->frame_state.tile_idx].size);
		state->frame_state.tile_idx++;
	}
		const ObuMetadataType metadata_type = (u32)read_leb128(bs, NULL); we should check for 16 bits limit (AV1MetadataSampleGroupEntry) for ISOBMFF bindings, see https ://github.com/AOMediaCodec/av1-isobmff/pull/86#issuecomment-416659538
		av1_parse_tile_group(bs, state, pos + *obu_size);
		break;","	if (gf_bs_read_int(bs, 3) /*equal_picture_interval*/) {
	u8 operating_points_cnt_minus_1, frame_width_bits_minus_1, frame_height_bits_minus_1, buffer_delay_length_minus_1 = 0;
	Bool timing_info_present_flag, decoder_model_info_present_flag, initial_display_delay_present_flag;
		decoder_model_info_present_flag = GF_FALSE;
			decoder_model_info_present_flag = gf_bs_read_int(bs, 1);
			if (decoder_model_info_present_flag) {
			decoder_model_info_present_flag = 0;
			if (decoder_model_info_present_flag) {
	frame_width_bits_minus_1 = gf_bs_read_int(bs, 4);
	frame_height_bits_minus_1 = gf_bs_read_int(bs, 4);
	state->width = gf_bs_read_int(bs, frame_width_bits_minus_1 + 1) + 1;
	state->height = gf_bs_read_int(bs, frame_height_bits_minus_1 + 1) + 1;
		/*delta_frame_id_length_minus_2 =*/ gf_bs_read_int(bs, 4);
		/*additional_frame_id_length_minus_1 =*/ gf_bs_read_int(bs, 3);
		enable_order_hint = 0;
		enable_ref_frame_mvs = 0;
		seq_force_screen_content_tools = SELECT_SCREEN_CONTENT_TOOLS;
		seq_force_integer_mv = SELECT_INTEGER_MV;
		OrderHintBits = 0;*/
		Bool enable_order_hint, seq_choose_screen_content_tools;
		u8 seq_force_screen_content_tools/*, seq_force_integer_mv*/;
		enable_order_hint = gf_bs_read_int(bs, 1);
		if (enable_order_hint) {
			/*enable_ref_frame_mvs =*/ gf_bs_read_int(bs, 1);
		seq_force_screen_content_tools = 0;
			seq_force_screen_content_tools = 2/*SELECT_SCREEN_CONTENT_TOOLS*/;
			seq_force_screen_content_tools = gf_bs_read_int(bs, 1);
		/*seq_force_integer_mv = 0;*/
		if (seq_force_screen_content_tools > 0) {
				/*seq_force_integer_mv = 2*//*SELECT_INTEGER_MV*/;
				/*seq_force_integer_mv = */gf_bs_read_int(bs, 1);
			/*seq_force_integer_mv = 2*//*SELECT_INTEGER_MV*/;
		if (enable_order_hint) {
			/*u8 order_hint_bits_minus_1 = */gf_bs_read_int(bs, 3);
			/*OrderHintBits = order_hint_bits_minus_1 + 1*/;
			/*OrderHintBits = 0*/;
	/*enable_superres = */gf_bs_read_int(bs, 1);
	KEY_FRAME = 0,
	INTER_FRAME = 1,
	INTRA_ONLY_FRAME = 2,
	SWITCH_FRAME = 3,
static void tile_info(GF_BitStream *bs, AV1State *state)
		minLog2tileRows = MAX(minLog2Tiles - state->tileColsLog2, 0);
			u32 maxWidth = MIN(sbCols - startSb, maxTileWidthSb);
			u32 maxHeight = MIN(sbRows - startSb, maxTileHeightSb);
		/*context_update_tile_idcontext_update_tile_id = */gf_bs_read_int(bs, state->tileRowsLog2 + state->tileColsLog2);
		/*tile_size_bytes_minus_1tile_size_bytes_minus_1 = */gf_bs_read_int(bs, 2);
		//idLen = (additional_frame_id_length_minus_1 + delta_frame_id_length_minus_2 + 3);
	//allFrames = (1 << NUM_REF_FRAMES) - 1;
		AV1FrameType frame_type;
		Bool show_frame = GF_FALSE;
			/*frame_to_show_map_idx	f(3)
			if (decoder_model_info_present_flag && !equal_picture_interval) {
				temporal_point_info()
			refresh_frame_flags = 0
				display_frame_id	f(idLen)
			if (frame_type == KEY_FRAME) {
				refresh_frame_flags = allFrames
		show_frame = gf_bs_read_int(bs, 1);
		frame_state->key_frame = frame_state->seen_seq_header && show_frame && frame_type == KEY_FRAME && frame_state->seen_frame_header;
static void av1_parse_tile_group(GF_BitStream *bs, AV1State *state)
		state->frame_state.tg[0].start = 0;
		state->frame_state.tg[0].end = numTiles - 1;
		state->frame_state.tg[state->frame_state.tg_idx].start = gf_bs_read_int(bs, tileBits);
		state->frame_state.tg[state->frame_state.tg_idx].end = gf_bs_read_int(bs, tileBits);
	state->frame_state.tg_idx++;
	//incomplete parsing
		const ObuMetadataType metadata_type = (u32)read_leb128(bs, NULL); we should check for 16 bits limit for ISOBMFF bindings, see https ://github.com/AOMediaCodec/av1-isobmff/pull/86#issuecomment-416659538
		av1_parse_tile_group(bs, state);",d7c2bb5cc3c67566f506f51cbefbf66f8169ea85,CVE-2019-20160,d7c2bb5cc3c67566f506f51cbefbf66f8169ea85,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,80,COMPLETED,"VAR->VAR = VAR(VAR, 3); VAR (VAR->VAR) { VAR VAR, VAR = 0; VAR VAR, VAR; VAR->VAR = VAR(VAR, 1); VAR (VAR->VAR) { VAR->VAR = VAR; VAR (VAR->VAR) { VAR->VAR = VAR(VAR, 4); VAR->VAR = VAR(VAR, 4); VAR->VAR = VAR(VAR, VAR->VAR + 1) + 1; VAR->VAR = VAR(VAR, VAR->VAR + 1) + 1; VAR->VAR = VAR(VAR, 4); VAR->VAR = VAR(VAR, 3); VAR = 0;*/ VAR->VAR = VAR; VAR->VAR = 0; VAR->VAR = 2; VAR->VAR = 2; VAR VAR; VAR->VAR = VAR(VAR, 1); VAR (VAR->VAR) { VAR->VAR = VAR(VAR, 1); VAR->VAR = 0; VAR->VAR = 2; VAR->VAR = VAR(VAR, 1); VAR->VAR = 0; VAR (VAR->VAR > 0) { VAR->VAR = 2; VAR->VAR = VAR(VAR, 1); VAR->VAR = 2; VAR (VAR->VAR) { VAR VAR = VAR(VAR, 3); VAR->VAR = VAR + 1; VAR->VAR = 0; VAR->VAR = VAR(VAR, 1); VAR = 0, VAR = 1, VAR = 2, VAR = 3,        VAR VAR VAR(VAR *VAR, VAR VAR) { VAR VAR = 0; VAR VAR = 0; VAR (VAR = 0; VAR < VAR; VAR++) { VAR VAR = VAR(VAR, 8); VAR += (VAR << (VAR * 8)); } VAR VAR; } VAR VAR VAR(VAR *VAR, VAR *VAR) VAR = VAR((VAR)(VAR - VAR->VAR), 0); VAR VAR = VAR((VAR)(VAR - VAR), VAR); VAR VAR = VAR((VAR)(VAR - VAR), VAR); VAR(VAR, VAR->VAR + VAR->VAR); VAR->VAR = VAR(VAR, 2) + 1; } } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR; VAR VAR; VAR (VAR->VAR) { VAR = VAR(VAR, 1); } VAR { VAR = VAR; } VAR (VAR) { VAR VAR = VAR(VAR, VAR); VAR = VAR + VAR; } VAR { VAR = VAR; } VAR->VAR = VAR->VAR; VAR->VAR = (VAR->VAR * VAR + (VAR / 2)) / VAR; } VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) { VAR (VAR) { VAR VAR, VAR; VAR VAR = VAR->VAR + 1; VAR = VAR(VAR, VAR); VAR = VAR->VAR + 1; VAR = VAR(VAR, VAR); VAR->VAR = VAR + 1; VAR->VAR = VAR + 1; } VAR(VAR, VAR);  } VAR VAR VAR(VAR *VAR) { VAR VAR = VAR(VAR, 1); VAR (VAR == VAR) {  VAR(VAR, 16);  VAR(VAR, 16);   } VAR {   } } VAR VAR VAR(VAR *VAR) { VAR VAR = VAR(VAR, 1); VAR (!VAR) {  VAR(VAR, 2); } } VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) { VAR VAR = VAR; VAR VAR = 0; VAR (VAR = 0; VAR < VAR; VAR++) { VAR = VAR(VAR, 1); VAR (VAR == 1) {  VAR = VAR[VAR[VAR]]; VAR = VAR; VAR = VAR[VAR[VAR]]; VAR = VAR[VAR[VAR]]; VAR = VAR[VAR[VAR]];  VAR; } } VAR (VAR == 0) { VAR(VAR, VAR, VAR); VAR(VAR); } VAR { VAR(VAR, VAR);  VAR VAR = VAR, VAR = VAR, VAR = VAR; VAR VAR = VAR, VAR = VAR, VAR = VAR; VAR VAR = VAR, VAR = VAR; VAR VAR; VAR VAR = 0; VAR VAR; VAR = (VAR->VAR + VAR->VAR + 3); VAR = VAR; VAR = VAR; VAR->VAR = VAR; /*VAR = VAR(VAR, 3); VAR (VAR->VAR && !VAR->VAR) { VAR(); VAR = 0; VAR = VAR(VAR, VAR); VAR (VAR == VAR) { VAR = VAR; VAR = (VAR == VAR || VAR == VAR); VAR->VAR = VAR(VAR, 1); VAR->VAR = VAR->VAR && VAR->VAR && VAR == VAR && VAR->VAR; VAR (VAR->VAR && VAR->VAR && !VAR->VAR) { VAR(VAR, VAR, (""[VAR] VAR() VAR VAR (1)\VAR"")); VAR(0); VAR; } VAR (!VAR->VAR) { VAR(VAR, 1); } VAR (VAR == VAR || (VAR == VAR && VAR->VAR)) VAR = VAR; VAR VAR = VAR(VAR, 1); } VAR = VAR(VAR, 1); VAR (VAR->VAR == 2) { VAR = VAR(VAR, 1); } VAR { VAR = VAR->VAR; } VAR (VAR) { VAR (VAR->VAR == 2) { VAR = VAR(VAR, 1); } VAR { VAR = VAR->VAR; } } VAR { VAR = 0; } VAR (VAR) { VAR = 1; } VAR (VAR->VAR) { VAR(VAR, VAR); } VAR (VAR == VAR) VAR = VAR; VAR VAR (VAR->VAR) VAR = VAR; VAR VAR = VAR(VAR, 1); VAR(VAR, VAR->VAR); VAR (VAR || VAR) { VAR = VAR; } VAR { VAR = VAR(VAR, 3); } VAR (VAR->VAR) { VAR(VAR, VAR, (""[VAR] VAR VAR VAR VAR VAR\VAR"")); VAR(0); VAR;  VAR = VAR(VAR, 1); VAR (VAR) { VAR (VAR = 0; VAR <= VAR; VAR++) { VAR (VAR[VAR]) { VAR = VAR[VAR]; VAR = (VAR >> VAR) & 1; VAR = (VAR >> (VAR + 8)) & 1; VAR (VAR == 0 || (VAR && VAR)) { VAR = VAR + 1; VAR[VAR] = VAR(VAR, VAR); } } } }  } VAR (VAR == VAR || (VAR == VAR && VAR->VAR)) { VAR = VAR; } VAR { VAR = VAR(VAR, 8); } VAR (!VAR || VAR != VAR) { VAR (VAR && VAR->VAR) { VAR VAR = 0; VAR (VAR = 0; VAR < VAR; VAR++) { VAR(VAR, VAR->VAR); } } VAR (VAR == VAR) { VAR(VAR, VAR, VAR); VAR(VAR); VAR (VAR && VAR->VAR == VAR->VAR) { VAR(VAR, 1); } } VAR { VAR (VAR == VAR) { VAR(VAR, VAR, VAR); VAR(VAR); VAR (VAR && VAR->VAR == VAR->VAR) { VAR(VAR, 1); } } VAR { VAR VAR = 0; VAR VAR = VAR; VAR (VAR->VAR) { VAR = VAR(VAR, 1); VAR (VAR) {  VAR(VAR, 3);  VAR(VAR, 3);  } } VAR (VAR = 0; VAR < VAR; VAR++) { VAR (!VAR)  VAR(VAR, 3); VAR (VAR->VAR) { VAR VAR = VAR->VAR + 2;  VAR(VAR, VAR);   } } VAR (VAR && !VAR) { VAR(VAR, VAR, VAR); } VAR { VAR(VAR, VAR, VAR); VAR(VAR); } VAR (!VAR) { VAR(VAR, 1); } VAR(VAR);  VAR(VAR, 1); VAR (! (VAR || !VAR->VAR) ) { VAR = VAR(VAR, 1); } } } VAR ( !(VAR->VAR || VAR) ) VAR(VAR, 1); VAR (VAR == VAR) {   } VAR {   } VAR(VAR, VAR);  VAR VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR VAR, VAR, VAR; /*VAR->VAR.VAR[0].VAR = 0; VAR->VAR.VAR[0].VAR = VAR - 1;*/  VAR = VAR(VAR, VAR);  VAR = VAR(VAR, VAR);  VAR(VAR); VAR (VAR = VAR; VAR <= VAR; VAR++) { VAR VAR = VAR / VAR->VAR; VAR VAR = VAR % VAR->VAR; VAR VAR = VAR == VAR; VAR VAR = VAR(VAR); VAR (VAR) { VAR->VAR.VAR[VAR->VAR.VAR].VAR = VAR; VAR->VAR.VAR[VAR->VAR.VAR].VAR = (VAR)(VAR - VAR); } VAR { VAR VAR = VAR(VAR, VAR->VAR); VAR = VAR(VAR); VAR->VAR.VAR[VAR->VAR.VAR].VAR = VAR; VAR->VAR.VAR[VAR->VAR.VAR].VAR = (VAR)(VAR + 1); } VAR(VAR, VAR + VAR->VAR.VAR[VAR->VAR.VAR].VAR); VAR->VAR.VAR++; } VAR VAR VAR = (VAR)VAR(VAR, VAR); VAR VAR VAR VAR 16 VAR VAR (VAR) VAR VAR VAR, VAR VAR : VAR(VAR, VAR, VAR + *VAR); VAR; VAR (VAR(VAR, 3) ) { VAR VAR, VAR, VAR, VAR = 0; VAR VAR, VAR, VAR; VAR = VAR; VAR = VAR(VAR, 1); VAR (VAR) { VAR = 0; VAR (VAR) { VAR = VAR(VAR, 4); VAR = VAR(VAR, 4); VAR->VAR = VAR(VAR, VAR + 1) + 1; VAR->VAR = VAR(VAR, VAR + 1) + 1;  VAR(VAR, 4);  VAR(VAR, 3); VAR = 0; VAR = 0; VAR = VAR; VAR = VAR; VAR = 0;*/ VAR VAR, VAR; VAR VAR; VAR = VAR(VAR, 1); VAR (VAR) {  VAR(VAR, 1); VAR = 0; VAR = 2; VAR = VAR(VAR, 1);  VAR (VAR > 0) { /*VAR = 2* VAR(VAR, 1); /*VAR = 2* VAR (VAR) { VAR(VAR, 3); ; ; VAR(VAR, 1); VAR = 0, VAR = 1, VAR = 2, VAR = 3, VAR VAR VAR(VAR *VAR, VAR *VAR) VAR = VAR(VAR - VAR->VAR, 0); VAR VAR = VAR(VAR - VAR, VAR); VAR VAR = VAR(VAR - VAR, VAR); VAR(VAR, VAR->VAR + VAR->VAR); VAR(VAR, 2);   VAR VAR; VAR VAR = VAR; /*VAR VAR(3) VAR (VAR && !VAR) { VAR() VAR = 0 VAR VAR(VAR) VAR (VAR == VAR) { VAR = VAR VAR = VAR(VAR, 1); VAR->VAR = VAR->VAR && VAR && VAR == VAR && VAR->VAR; VAR VAR VAR(VAR *VAR, VAR *VAR) VAR->VAR.VAR[0].VAR = 0; VAR->VAR.VAR[0].VAR = VAR - 1; VAR->VAR.VAR[VAR->VAR.VAR].VAR = VAR(VAR, VAR); VAR->VAR.VAR[VAR->VAR.VAR].VAR = VAR(VAR, VAR); VAR->VAR.VAR++;  VAR VAR VAR = (VAR)VAR(VAR, VAR); VAR VAR VAR VAR 16 VAR VAR VAR VAR VAR, VAR VAR : VAR(VAR, VAR);",1,15
gpac_e79b0cf7e72404750630bc01340e999f3940dbc4,src/isomedia/isom_read.c,"		if ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && UUID && !memcmp(map->uuid, UUID, 16)) goto found;","		if ((map->boxType == GF_ISOM_BOX_TYPE_UUID) && !memcmp(map->uuid, UUID, 16)) goto found;",e79b0cf7e72404750630bc01340e999f3940dbc4,CVE-2023-46001,e79b0cf7e72404750630bc01340e999f3940dbc4,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ((VAR->VAR == VAR) && VAR && !VAR(VAR->VAR, VAR, 16)) VAR VAR; VAR ((VAR->VAR == VAR) && !VAR(VAR->VAR, VAR, 16)) VAR VAR;",1,15
linux_1202cdd665315c525b5237e96e0bedc76d7e754f,include/net/dn_fib.h,,"/* SPDX-License-Identifier: GPL-2.0 */
#ifndef _NET_DN_FIB_H
#define _NET_DN_FIB_H

#include <linux/netlink.h>
#include <linux/refcount.h>
#include <linux/rtnetlink.h>
#include <net/fib_rules.h>

extern const struct nla_policy rtm_dn_policy[];

struct dn_fib_res {
	struct fib_rule *r;
	struct dn_fib_info *fi;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
};

struct dn_fib_nh {
	struct net_device	*nh_dev;
	unsigned int		nh_flags;
	unsigned char		nh_scope;
	int			nh_weight;
	int			nh_power;
	int			nh_oif;
	__le16			nh_gw;
};

struct dn_fib_info {
	struct dn_fib_info	*fib_next;
	struct dn_fib_info	*fib_prev;
	refcount_t		fib_treeref;
	refcount_t		fib_clntref;
	int			fib_dead;
	unsigned int		fib_flags;
	int			fib_protocol;
	__le16			fib_prefsrc;
	__u32			fib_priority;
	__u32			fib_metrics[RTAX_MAX];
	int			fib_nhs;
	int			fib_power;
	struct dn_fib_nh	fib_nh[0];
#define dn_fib_dev		fib_nh[0].nh_dev
};


#define DN_FIB_RES_RESET(res)	((res).nh_sel = 0)
#define DN_FIB_RES_NH(res)	((res).fi->fib_nh[(res).nh_sel])

#define DN_FIB_RES_PREFSRC(res)	((res).fi->fib_prefsrc ? : __dn_fib_res_prefsrc(&res))
#define DN_FIB_RES_GW(res)	(DN_FIB_RES_NH(res).nh_gw)
#define DN_FIB_RES_DEV(res)	(DN_FIB_RES_NH(res).nh_dev)
#define DN_FIB_RES_OIF(res)	(DN_FIB_RES_NH(res).nh_oif)

typedef struct {
	__le16	datum;
} dn_fib_key_t;

typedef struct {
	__le16	datum;
} dn_fib_hash_t;

typedef struct {
	__u16	datum;
} dn_fib_idx_t;

struct dn_fib_node {
	struct dn_fib_node *fn_next;
	struct dn_fib_info *fn_info;
#define DN_FIB_INFO(f) ((f)->fn_info)
	dn_fib_key_t	fn_key;
	u8		fn_type;
	u8		fn_scope;
	u8		fn_state;
};


struct dn_fib_table {
	struct hlist_node hlist;
	u32 n;

	int (*insert)(struct dn_fib_table *t, struct rtmsg *r,
			struct nlattr *attrs[], struct nlmsghdr *n,
			struct netlink_skb_parms *req);
	int (*delete)(struct dn_fib_table *t, struct rtmsg *r,
			struct nlattr *attrs[], struct nlmsghdr *n,
			struct netlink_skb_parms *req);
	int (*lookup)(struct dn_fib_table *t, const struct flowidn *fld,
			struct dn_fib_res *res);
	int (*flush)(struct dn_fib_table *t);
	int (*dump)(struct dn_fib_table *t, struct sk_buff *skb, struct netlink_callback *cb);

	unsigned char data[];
};

#ifdef CONFIG_DECNET_ROUTER
/*
 * dn_fib.c
 */
void dn_fib_init(void);
void dn_fib_cleanup(void);

int dn_fib_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg);
struct dn_fib_info *dn_fib_create_info(const struct rtmsg *r,
				       struct nlattr *attrs[],
				       const struct nlmsghdr *nlh, int *errp);
int dn_fib_semantic_match(int type, struct dn_fib_info *fi,
			  const struct flowidn *fld, struct dn_fib_res *res);
void dn_fib_release_info(struct dn_fib_info *fi);
void dn_fib_flush(void);
void dn_fib_select_multipath(const struct flowidn *fld, struct dn_fib_res *res);

/*
 * dn_tables.c
 */
struct dn_fib_table *dn_fib_get_table(u32 n, int creat);
struct dn_fib_table *dn_fib_empty_table(void);
void dn_fib_table_init(void);
void dn_fib_table_cleanup(void);

/*
 * dn_rules.c
 */
void dn_fib_rules_init(void);
void dn_fib_rules_cleanup(void);
unsigned int dnet_addr_type(__le16 addr);
int dn_fib_lookup(struct flowidn *fld, struct dn_fib_res *res);

int dn_fib_dump(struct sk_buff *skb, struct netlink_callback *cb);

void dn_fib_free_info(struct dn_fib_info *fi);

static inline void dn_fib_info_put(struct dn_fib_info *fi)
{
	if (refcount_dec_and_test(&fi->fib_clntref))
		dn_fib_free_info(fi);
}

static inline void dn_fib_res_put(struct dn_fib_res *res)
{
	if (res->fi)
		dn_fib_info_put(res->fi);
	if (res->r)
		fib_rule_put(res->r);
}

#else /* Endnode */

#define dn_fib_init()  do { } while(0)
#define dn_fib_cleanup() do { } while(0)

#define dn_fib_lookup(fl, res) (-ESRCH)
#define dn_fib_info_put(fi) do { } while(0)
#define dn_fib_select_multipath(fl, res) do { } while(0)
#define dn_fib_rules_policy(saddr,res,flags) (0)
#define dn_fib_res_put(res) do { } while(0)

#endif /* CONFIG_DECNET_ROUTER */

static inline __le16 dnet_make_mask(int n)
{
	if (n)
		return cpu_to_le16(~((1 << (16 - n)) - 1));
	return cpu_to_le16(0);
}

#endif /* _NET_DN_FIB_H */",1202cdd665315c525b5237e96e0bedc76d7e754f,CVE-2023-3338,1202cdd665315c525b5237e96e0bedc76d7e754f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,"        VAR VAR VAR VAR VAR[]; VAR VAR { VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; }; VAR VAR { VAR VAR *VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR { VAR VAR *VAR; VAR VAR *VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR[VAR]; VAR VAR; VAR VAR; VAR VAR VAR[0];  };       VAR VAR { VAR VAR; } VAR; VAR VAR { VAR VAR; } VAR; VAR VAR { VAR VAR; } VAR; VAR VAR { VAR VAR *VAR; VAR VAR *VAR;  VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR { VAR VAR VAR; VAR VAR; VAR (*VAR)(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR[], VAR VAR *VAR, VAR VAR *VAR); VAR (*VAR)(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR[], VAR VAR *VAR, VAR VAR *VAR); VAR (*VAR)(VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR *VAR); VAR (*VAR)(VAR VAR *VAR); VAR (*VAR)(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR); VAR VAR VAR[]; };  /* * VAR.VAR */ VAR VAR(VAR); VAR VAR(VAR); VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR VAR); VAR VAR *VAR(VAR VAR VAR *VAR, VAR VAR *VAR[], VAR VAR VAR *VAR, VAR *VAR); VAR VAR(VAR VAR, VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR *VAR); VAR VAR(VAR VAR *VAR); VAR VAR(VAR); VAR VAR(VAR VAR VAR *VAR, VAR VAR *VAR); /* * VAR.VAR */ VAR VAR *VAR(VAR VAR, VAR VAR); VAR VAR *VAR(VAR); VAR VAR(VAR); VAR VAR(VAR); /* * VAR.VAR */ VAR VAR(VAR); VAR VAR(VAR); VAR VAR VAR(VAR VAR); VAR VAR(VAR VAR *VAR, VAR VAR *VAR); VAR VAR(VAR VAR *VAR, VAR VAR *VAR); VAR VAR(VAR VAR *VAR); VAR VAR VAR VAR(VAR VAR *VAR) { VAR (VAR(&VAR->VAR)) VAR(VAR); } VAR VAR VAR VAR(VAR VAR *VAR) { VAR (VAR->VAR) VAR(VAR->VAR); VAR (VAR->VAR) VAR(VAR->VAR); }          VAR VAR VAR VAR(VAR VAR) { VAR (VAR) VAR VAR(~((1 << (16 - VAR)) - 1)); VAR VAR(0); } ",1,15
linux_1202cdd665315c525b5237e96e0bedc76d7e754f,include/uapi/linux/dn.h,,"/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
#ifndef _LINUX_DN_H
#define _LINUX_DN_H

#include <linux/ioctl.h>
#include <linux/types.h>
#include <linux/if_ether.h>

/*

	DECnet Data Structures and Constants

*/

/*
 * DNPROTO_NSP can't be the same as SOL_SOCKET,
 * so increment each by one (compared to ULTRIX)
 */
#define DNPROTO_NSP     2                       /* NSP protocol number       */
#define DNPROTO_ROU     3                       /* Routing protocol number   */
#define DNPROTO_NML     4                       /* Net mgt protocol number   */
#define DNPROTO_EVL     5                       /* Evl protocol number (usr) */
#define DNPROTO_EVR     6                       /* Evl protocol number (evl) */
#define DNPROTO_NSPT    7                       /* NSP trace protocol number */


#define DN_ADDL		2
#define DN_MAXADDL	2 /* ULTRIX headers have 20 here, but pathworks has 2 */
#define DN_MAXOPTL	16
#define DN_MAXOBJL	16
#define DN_MAXACCL	40
#define DN_MAXALIASL	128
#define DN_MAXNODEL	256
#define DNBUFSIZE	65023

/*
 * SET/GET Socket options  - must match the DSO_ numbers below
 */
#define SO_CONDATA      1
#define SO_CONACCESS    2
#define SO_PROXYUSR     3
#define SO_LINKINFO     7

#define DSO_CONDATA     1        /* Set/Get connect data                */
#define DSO_DISDATA     10       /* Set/Get disconnect data             */
#define DSO_CONACCESS   2        /* Set/Get connect access data         */
#define DSO_ACCEPTMODE  4        /* Set/Get accept mode                 */
#define DSO_CONACCEPT   5        /* Accept deferred connection          */
#define DSO_CONREJECT   6        /* Reject deferred connection          */
#define DSO_LINKINFO    7        /* Set/Get link information            */
#define DSO_STREAM      8        /* Set socket type to stream           */
#define DSO_SEQPACKET   9        /* Set socket type to sequenced packet */
#define DSO_MAXWINDOW   11       /* Maximum window size allowed         */
#define DSO_NODELAY	12       /* Turn off nagle                      */
#define DSO_CORK        13       /* Wait for more data!                 */
#define DSO_SERVICES	14       /* NSP Services field                  */
#define DSO_INFO	15       /* NSP Info field                      */
#define DSO_MAX         15       /* Maximum option number               */


/* LINK States */
#define LL_INACTIVE	0
#define LL_CONNECTING	1
#define LL_RUNNING	2
#define LL_DISCONNECTING 3

#define ACC_IMMED 0
#define ACC_DEFER 1

#define SDF_WILD        1                  /* Wild card object          */
#define SDF_PROXY       2                  /* Addr eligible for proxy   */
#define SDF_UICPROXY    4                  /* Use uic-based proxy       */

/* Structures */


struct dn_naddr {
	__le16		a_len;
	__u8 a_addr[DN_MAXADDL]; /* Two bytes little endian */
};

struct sockaddr_dn {
	__u16		sdn_family;
	__u8		sdn_flags;
	__u8		sdn_objnum;
	__le16		sdn_objnamel;
	__u8		sdn_objname[DN_MAXOBJL];
	struct   dn_naddr	sdn_add;
};
#define sdn_nodeaddrl   sdn_add.a_len   /* Node address length  */
#define sdn_nodeaddr    sdn_add.a_addr  /* Node address         */



/*
 * DECnet set/get DSO_CONDATA, DSO_DISDATA (optional data) structure
 */
struct optdata_dn {
        __le16  opt_status;     /* Extended status return */
#define opt_sts opt_status
        __le16  opt_optl;       /* Length of user data    */
        __u8   opt_data[16];   /* User data              */
};

struct accessdata_dn {
	__u8		acc_accl;
	__u8		acc_acc[DN_MAXACCL];
	__u8 		acc_passl;
	__u8		acc_pass[DN_MAXACCL];
	__u8 		acc_userl;
	__u8		acc_user[DN_MAXACCL];
};

/*
 * DECnet logical link information structure
 */
struct linkinfo_dn {
        __u16  idn_segsize;    /* Segment size for link */
        __u8   idn_linkstate;  /* Logical link state    */
};

/*
 * Ethernet address format (for DECnet)
 */
union etheraddress {
        __u8 dne_addr[ETH_ALEN];      /* Full ethernet address */
  struct {
                __u8 dne_hiord[4];    /* DECnet HIORD prefix   */
                __u8 dne_nodeaddr[2]; /* DECnet node address   */
  } dne_remote;
};


/*
 * DECnet physical socket address format
 */
struct dn_addr {
        __le16 dna_family;      /* AF_DECnet               */
        union etheraddress dna_netaddr; /* DECnet ethernet address */
};

#define DECNET_IOCTL_BASE 0x89 /* PROTOPRIVATE range */

#define SIOCSNETADDR  _IOW(DECNET_IOCTL_BASE, 0xe0, struct dn_naddr)
#define SIOCGNETADDR  _IOR(DECNET_IOCTL_BASE, 0xe1, struct dn_naddr)
#define OSIOCSNETADDR _IOW(DECNET_IOCTL_BASE, 0xe0, int)
#define OSIOCGNETADDR _IOR(DECNET_IOCTL_BASE, 0xe1, int)

#endif /* _LINUX_DN_H */",1202cdd665315c525b5237e96e0bedc76d7e754f,CVE-2023-3338,1202cdd665315c525b5237e96e0bedc76d7e754f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,"       /* VAR VAR VAR VAR VAR */ /* * VAR VAR'VAR VAR VAR VAR VAR VAR, * VAR VAR VAR VAR VAR (VAR VAR VAR) */               /* * VAR/VAR VAR VAR - VAR VAR VAR VAR VAR VAR */                               VAR VAR { VAR VAR; VAR VAR[VAR];  }; VAR VAR { VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR[VAR]; VAR VAR VAR; };   /* * VAR VAR/VAR VAR, VAR (VAR VAR) VAR */ VAR VAR { VAR VAR;   VAR VAR;  VAR VAR[16];  }; VAR VAR { VAR VAR; VAR VAR[VAR]; VAR VAR; VAR VAR[VAR]; VAR VAR; VAR VAR[VAR]; }; /* * VAR VAR VAR VAR VAR */ VAR VAR { VAR VAR;  VAR VAR;  }; /* * VAR VAR VAR (VAR VAR) */ VAR VAR { VAR VAR[VAR];  VAR { VAR VAR[4];  VAR VAR[2];  } VAR; }; /* * VAR VAR VAR VAR VAR */ VAR VAR { VAR VAR;  VAR VAR VAR;  };      ",1,15
linux_1202cdd665315c525b5237e96e0bedc76d7e754f,net/decnet/dn_fib.c,,"// SPDX-License-Identifier: GPL-2.0
/*
 * DECnet       An implementation of the DECnet protocol suite for the LINUX
 *              operating system.  DECnet is implemented using the  BSD Socket
 *              interface as the means of communication with the user level.
 *
 *              DECnet Routing Forwarding Information Base (Glue/Info List)
 *
 * Author:      Steve Whitehouse <SteveW@ACM.org>
 *
 *
 * Changes:
 *              Alexey Kuznetsov : SMP locking changes
 *              Steve Whitehouse : Rewrote it... Well to be more correct, I
 *                                 copied most of it from the ipv4 fib code.
 *              Steve Whitehouse : Updated it in style and fixed a few bugs
 *                                 which were fixed in the ipv4 code since
 *                                 this code was copied from it.
 *
 */
#include <linux/string.h>
#include <linux/net.h>
#include <linux/socket.h>
#include <linux/slab.h>
#include <linux/sockios.h>
#include <linux/init.h>
#include <linux/skbuff.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/proc_fs.h>
#include <linux/netdevice.h>
#include <linux/timer.h>
#include <linux/spinlock.h>
#include <linux/atomic.h>
#include <linux/uaccess.h>
#include <net/neighbour.h>
#include <net/dst.h>
#include <net/flow.h>
#include <net/fib_rules.h>
#include <net/dn.h>
#include <net/dn_route.h>
#include <net/dn_fib.h>
#include <net/dn_neigh.h>
#include <net/dn_dev.h>
#include <net/rtnh.h>

#define RT_MIN_TABLE 1

#define for_fib_info() { struct dn_fib_info *fi;\
	for(fi = dn_fib_info_list; fi; fi = fi->fib_next)
#define endfor_fib_info() }

#define for_nexthops(fi) { int nhsel; const struct dn_fib_nh *nh;\
	for(nhsel = 0, nh = (fi)->fib_nh; nhsel < (fi)->fib_nhs; nh++, nhsel++)

#define change_nexthops(fi) { int nhsel; struct dn_fib_nh *nh;\
	for(nhsel = 0, nh = (struct dn_fib_nh *)((fi)->fib_nh); nhsel < (fi)->fib_nhs; nh++, nhsel++)

#define endfor_nexthops(fi) }

static DEFINE_SPINLOCK(dn_fib_multipath_lock);
static struct dn_fib_info *dn_fib_info_list;
static DEFINE_SPINLOCK(dn_fib_info_lock);

static struct
{
	int error;
	u8 scope;
} dn_fib_props[RTN_MAX+1] = {
	[RTN_UNSPEC] =      { .error = 0,       .scope = RT_SCOPE_NOWHERE },
	[RTN_UNICAST] =     { .error = 0,       .scope = RT_SCOPE_UNIVERSE },
	[RTN_LOCAL] =       { .error = 0,       .scope = RT_SCOPE_HOST },
	[RTN_BROADCAST] =   { .error = -EINVAL, .scope = RT_SCOPE_NOWHERE },
	[RTN_ANYCAST] =     { .error = -EINVAL, .scope = RT_SCOPE_NOWHERE },
	[RTN_MULTICAST] =   { .error = -EINVAL, .scope = RT_SCOPE_NOWHERE },
	[RTN_BLACKHOLE] =   { .error = -EINVAL, .scope = RT_SCOPE_UNIVERSE },
	[RTN_UNREACHABLE] = { .error = -EHOSTUNREACH, .scope = RT_SCOPE_UNIVERSE },
	[RTN_PROHIBIT] =    { .error = -EACCES, .scope = RT_SCOPE_UNIVERSE },
	[RTN_THROW] =       { .error = -EAGAIN, .scope = RT_SCOPE_UNIVERSE },
	[RTN_NAT] =         { .error = 0,       .scope = RT_SCOPE_NOWHERE },
	[RTN_XRESOLVE] =    { .error = -EINVAL, .scope = RT_SCOPE_NOWHERE },
};

static int dn_fib_sync_down(__le16 local, struct net_device *dev, int force);
static int dn_fib_sync_up(struct net_device *dev);

void dn_fib_free_info(struct dn_fib_info *fi)
{
	if (fi->fib_dead == 0) {
		printk(KERN_DEBUG ""DECnet: BUG! Attempt to free alive dn_fib_info\n"");
		return;
	}

	change_nexthops(fi) {
		dev_put(nh->nh_dev);
		nh->nh_dev = NULL;
	} endfor_nexthops(fi);
	kfree(fi);
}

void dn_fib_release_info(struct dn_fib_info *fi)
{
	spin_lock(&dn_fib_info_lock);
	if (fi && refcount_dec_and_test(&fi->fib_treeref)) {
		if (fi->fib_next)
			fi->fib_next->fib_prev = fi->fib_prev;
		if (fi->fib_prev)
			fi->fib_prev->fib_next = fi->fib_next;
		if (fi == dn_fib_info_list)
			dn_fib_info_list = fi->fib_next;
		fi->fib_dead = 1;
		dn_fib_info_put(fi);
	}
	spin_unlock(&dn_fib_info_lock);
}

static inline int dn_fib_nh_comp(const struct dn_fib_info *fi, const struct dn_fib_info *ofi)
{
	const struct dn_fib_nh *onh = ofi->fib_nh;

	for_nexthops(fi) {
		if (nh->nh_oif != onh->nh_oif ||
			nh->nh_gw != onh->nh_gw ||
			nh->nh_scope != onh->nh_scope ||
			nh->nh_weight != onh->nh_weight ||
			((nh->nh_flags^onh->nh_flags)&~RTNH_F_DEAD))
				return -1;
		onh++;
	} endfor_nexthops(fi);
	return 0;
}

static inline struct dn_fib_info *dn_fib_find_info(const struct dn_fib_info *nfi)
{
	for_fib_info() {
		if (fi->fib_nhs != nfi->fib_nhs)
			continue;
		if (nfi->fib_protocol == fi->fib_protocol &&
			nfi->fib_prefsrc == fi->fib_prefsrc &&
			nfi->fib_priority == fi->fib_priority &&
			memcmp(nfi->fib_metrics, fi->fib_metrics, sizeof(fi->fib_metrics)) == 0 &&
			((nfi->fib_flags^fi->fib_flags)&~RTNH_F_DEAD) == 0 &&
			(nfi->fib_nhs == 0 || dn_fib_nh_comp(fi, nfi) == 0))
				return fi;
	} endfor_fib_info();
	return NULL;
}

static int dn_fib_count_nhs(const struct nlattr *attr)
{
	struct rtnexthop *nhp = nla_data(attr);
	int nhs = 0, nhlen = nla_len(attr);

	while (rtnh_ok(nhp, nhlen)) {
		nhs++;
		nhp = rtnh_next(nhp, &nhlen);
	}

	/* leftover implies invalid nexthop configuration, discard it */
	return nhlen > 0 ? 0 : nhs;
}

static int dn_fib_get_nhs(struct dn_fib_info *fi, const struct nlattr *attr,
			  const struct rtmsg *r)
{
	struct rtnexthop *nhp = nla_data(attr);
	int nhlen = nla_len(attr);

	change_nexthops(fi) {
		int attrlen;

		if (!rtnh_ok(nhp, nhlen))
			return -EINVAL;

		nh->nh_flags  = (r->rtm_flags&~0xFF) | nhp->rtnh_flags;
		nh->nh_oif    = nhp->rtnh_ifindex;
		nh->nh_weight = nhp->rtnh_hops + 1;

		attrlen = rtnh_attrlen(nhp);
		if (attrlen > 0) {
			struct nlattr *gw_attr;

			gw_attr = nla_find((struct nlattr *) (nhp + 1), attrlen, RTA_GATEWAY);
			nh->nh_gw = gw_attr ? nla_get_le16(gw_attr) : 0;
		}

		nhp = rtnh_next(nhp, &nhlen);
	} endfor_nexthops(fi);

	return 0;
}


static int dn_fib_check_nh(const struct rtmsg *r, struct dn_fib_info *fi, struct dn_fib_nh *nh)
{
	int err;

	if (nh->nh_gw) {
		struct flowidn fld;
		struct dn_fib_res res;

		if (nh->nh_flags&RTNH_F_ONLINK) {
			struct net_device *dev;

			if (r->rtm_scope >= RT_SCOPE_LINK)
				return -EINVAL;
			if (dnet_addr_type(nh->nh_gw) != RTN_UNICAST)
				return -EINVAL;
			if ((dev = __dev_get_by_index(&init_net, nh->nh_oif)) == NULL)
				return -ENODEV;
			if (!(dev->flags&IFF_UP))
				return -ENETDOWN;
			nh->nh_dev = dev;
			dev_hold(dev);
			nh->nh_scope = RT_SCOPE_LINK;
			return 0;
		}

		memset(&fld, 0, sizeof(fld));
		fld.daddr = nh->nh_gw;
		fld.flowidn_oif = nh->nh_oif;
		fld.flowidn_scope = r->rtm_scope + 1;

		if (fld.flowidn_scope < RT_SCOPE_LINK)
			fld.flowidn_scope = RT_SCOPE_LINK;

		if ((err = dn_fib_lookup(&fld, &res)) != 0)
			return err;

		err = -EINVAL;
		if (res.type != RTN_UNICAST && res.type != RTN_LOCAL)
			goto out;
		nh->nh_scope = res.scope;
		nh->nh_oif = DN_FIB_RES_OIF(res);
		nh->nh_dev = DN_FIB_RES_DEV(res);
		if (nh->nh_dev == NULL)
			goto out;
		dev_hold(nh->nh_dev);
		err = -ENETDOWN;
		if (!(nh->nh_dev->flags & IFF_UP))
			goto out;
		err = 0;
out:
		dn_fib_res_put(&res);
		return err;
	} else {
		struct net_device *dev;

		if (nh->nh_flags&(RTNH_F_PERVASIVE|RTNH_F_ONLINK))
			return -EINVAL;

		dev = __dev_get_by_index(&init_net, nh->nh_oif);
		if (dev == NULL || dev->dn_ptr == NULL)
			return -ENODEV;
		if (!(dev->flags&IFF_UP))
			return -ENETDOWN;
		nh->nh_dev = dev;
		dev_hold(nh->nh_dev);
		nh->nh_scope = RT_SCOPE_HOST;
	}

	return 0;
}


struct dn_fib_info *dn_fib_create_info(const struct rtmsg *r, struct nlattr *attrs[],
				       const struct nlmsghdr *nlh, int *errp)
{
	int err;
	struct dn_fib_info *fi = NULL;
	struct dn_fib_info *ofi;
	int nhs = 1;

	if (r->rtm_type > RTN_MAX)
		goto err_inval;

	if (dn_fib_props[r->rtm_type].scope > r->rtm_scope)
		goto err_inval;

	if (attrs[RTA_MULTIPATH] &&
	    (nhs = dn_fib_count_nhs(attrs[RTA_MULTIPATH])) == 0)
		goto err_inval;

	fi = kzalloc(struct_size(fi, fib_nh, nhs), GFP_KERNEL);
	err = -ENOBUFS;
	if (fi == NULL)
		goto failure;

	fi->fib_protocol = r->rtm_protocol;
	fi->fib_nhs = nhs;
	fi->fib_flags = r->rtm_flags;

	if (attrs[RTA_PRIORITY])
		fi->fib_priority = nla_get_u32(attrs[RTA_PRIORITY]);

	if (attrs[RTA_METRICS]) {
		struct nlattr *attr;
		int rem;

		nla_for_each_nested(attr, attrs[RTA_METRICS], rem) {
			int type = nla_type(attr);

			if (type) {
				if (type > RTAX_MAX || type == RTAX_CC_ALGO ||
				    nla_len(attr) < 4)
					goto err_inval;

				fi->fib_metrics[type-1] = nla_get_u32(attr);
			}
		}
	}

	if (attrs[RTA_PREFSRC])
		fi->fib_prefsrc = nla_get_le16(attrs[RTA_PREFSRC]);

	if (attrs[RTA_MULTIPATH]) {
		if ((err = dn_fib_get_nhs(fi, attrs[RTA_MULTIPATH], r)) != 0)
			goto failure;

		if (attrs[RTA_OIF] &&
		    fi->fib_nh->nh_oif != nla_get_u32(attrs[RTA_OIF]))
			goto err_inval;

		if (attrs[RTA_GATEWAY] &&
		    fi->fib_nh->nh_gw != nla_get_le16(attrs[RTA_GATEWAY]))
			goto err_inval;
	} else {
		struct dn_fib_nh *nh = fi->fib_nh;

		if (attrs[RTA_OIF])
			nh->nh_oif = nla_get_u32(attrs[RTA_OIF]);

		if (attrs[RTA_GATEWAY])
			nh->nh_gw = nla_get_le16(attrs[RTA_GATEWAY]);

		nh->nh_flags = r->rtm_flags;
		nh->nh_weight = 1;
	}

	if (r->rtm_type == RTN_NAT) {
		if (!attrs[RTA_GATEWAY] || nhs != 1 || attrs[RTA_OIF])
			goto err_inval;

		fi->fib_nh->nh_gw = nla_get_le16(attrs[RTA_GATEWAY]);
		goto link_it;
	}

	if (dn_fib_props[r->rtm_type].error) {
		if (attrs[RTA_GATEWAY] || attrs[RTA_OIF] || attrs[RTA_MULTIPATH])
			goto err_inval;

		goto link_it;
	}

	if (r->rtm_scope > RT_SCOPE_HOST)
		goto err_inval;

	if (r->rtm_scope == RT_SCOPE_HOST) {
		struct dn_fib_nh *nh = fi->fib_nh;

		/* Local address is added */
		if (nhs != 1 || nh->nh_gw)
			goto err_inval;
		nh->nh_scope = RT_SCOPE_NOWHERE;
		nh->nh_dev = dev_get_by_index(&init_net, fi->fib_nh->nh_oif);
		err = -ENODEV;
		if (nh->nh_dev == NULL)
			goto failure;
	} else {
		change_nexthops(fi) {
			if ((err = dn_fib_check_nh(r, fi, nh)) != 0)
				goto failure;
		} endfor_nexthops(fi)
	}

	if (fi->fib_prefsrc) {
		if (r->rtm_type != RTN_LOCAL || !attrs[RTA_DST] ||
		    fi->fib_prefsrc != nla_get_le16(attrs[RTA_DST]))
			if (dnet_addr_type(fi->fib_prefsrc) != RTN_LOCAL)
				goto err_inval;
	}

link_it:
	if ((ofi = dn_fib_find_info(fi)) != NULL) {
		fi->fib_dead = 1;
		dn_fib_free_info(fi);
		refcount_inc(&ofi->fib_treeref);
		return ofi;
	}

	refcount_set(&fi->fib_treeref, 1);
	refcount_set(&fi->fib_clntref, 1);
	spin_lock(&dn_fib_info_lock);
	fi->fib_next = dn_fib_info_list;
	fi->fib_prev = NULL;
	if (dn_fib_info_list)
		dn_fib_info_list->fib_prev = fi;
	dn_fib_info_list = fi;
	spin_unlock(&dn_fib_info_lock);
	return fi;

err_inval:
	err = -EINVAL;

failure:
	*errp = err;
	if (fi) {
		fi->fib_dead = 1;
		dn_fib_free_info(fi);
	}

	return NULL;
}

int dn_fib_semantic_match(int type, struct dn_fib_info *fi, const struct flowidn *fld, struct dn_fib_res *res)
{
	int err = dn_fib_props[type].error;

	if (err == 0) {
		if (fi->fib_flags & RTNH_F_DEAD)
			return 1;

		res->fi = fi;

		switch (type) {
		case RTN_NAT:
			DN_FIB_RES_RESET(*res);
			refcount_inc(&fi->fib_clntref);
			return 0;
		case RTN_UNICAST:
		case RTN_LOCAL:
			for_nexthops(fi) {
				if (nh->nh_flags & RTNH_F_DEAD)
					continue;
				if (!fld->flowidn_oif ||
				    fld->flowidn_oif == nh->nh_oif)
					break;
			}
			if (nhsel < fi->fib_nhs) {
				res->nh_sel = nhsel;
				refcount_inc(&fi->fib_clntref);
				return 0;
			}
			endfor_nexthops(fi);
			res->fi = NULL;
			return 1;
		default:
			net_err_ratelimited(""DECnet: impossible routing event : dn_fib_semantic_match type=%d\n"",
					    type);
			res->fi = NULL;
			return -EINVAL;
		}
	}
	return err;
}

void dn_fib_select_multipath(const struct flowidn *fld, struct dn_fib_res *res)
{
	struct dn_fib_info *fi = res->fi;
	int w;

	spin_lock_bh(&dn_fib_multipath_lock);
	if (fi->fib_power <= 0) {
		int power = 0;
		change_nexthops(fi) {
			if (!(nh->nh_flags&RTNH_F_DEAD)) {
				power += nh->nh_weight;
				nh->nh_power = nh->nh_weight;
			}
		} endfor_nexthops(fi);
		fi->fib_power = power;
		if (power < 0) {
			spin_unlock_bh(&dn_fib_multipath_lock);
			res->nh_sel = 0;
			return;
		}
	}

	w = jiffies % fi->fib_power;

	change_nexthops(fi) {
		if (!(nh->nh_flags&RTNH_F_DEAD) && nh->nh_power) {
			if ((w -= nh->nh_power) <= 0) {
				nh->nh_power--;
				fi->fib_power--;
				res->nh_sel = nhsel;
				spin_unlock_bh(&dn_fib_multipath_lock);
				return;
			}
		}
	} endfor_nexthops(fi);
	res->nh_sel = 0;
	spin_unlock_bh(&dn_fib_multipath_lock);
}

static inline u32 rtm_get_table(struct nlattr *attrs[], u8 table)
{
	if (attrs[RTA_TABLE])
		table = nla_get_u32(attrs[RTA_TABLE]);

	return table;
}

static int dn_fib_rtm_delroute(struct sk_buff *skb, struct nlmsghdr *nlh,
			       struct netlink_ext_ack *extack)
{
	struct net *net = sock_net(skb->sk);
	struct dn_fib_table *tb;
	struct rtmsg *r = nlmsg_data(nlh);
	struct nlattr *attrs[RTA_MAX+1];
	int err;

	if (!netlink_capable(skb, CAP_NET_ADMIN))
		return -EPERM;

	if (!net_eq(net, &init_net))
		return -EINVAL;

	err = nlmsg_parse_deprecated(nlh, sizeof(*r), attrs, RTA_MAX,
				     rtm_dn_policy, extack);
	if (err < 0)
		return err;

	tb = dn_fib_get_table(rtm_get_table(attrs, r->rtm_table), 0);
	if (!tb)
		return -ESRCH;

	return tb->delete(tb, r, attrs, nlh, &NETLINK_CB(skb));
}

static int dn_fib_rtm_newroute(struct sk_buff *skb, struct nlmsghdr *nlh,
			       struct netlink_ext_ack *extack)
{
	struct net *net = sock_net(skb->sk);
	struct dn_fib_table *tb;
	struct rtmsg *r = nlmsg_data(nlh);
	struct nlattr *attrs[RTA_MAX+1];
	int err;

	if (!netlink_capable(skb, CAP_NET_ADMIN))
		return -EPERM;

	if (!net_eq(net, &init_net))
		return -EINVAL;

	err = nlmsg_parse_deprecated(nlh, sizeof(*r), attrs, RTA_MAX,
				     rtm_dn_policy, extack);
	if (err < 0)
		return err;

	tb = dn_fib_get_table(rtm_get_table(attrs, r->rtm_table), 1);
	if (!tb)
		return -ENOBUFS;

	return tb->insert(tb, r, attrs, nlh, &NETLINK_CB(skb));
}

static void fib_magic(int cmd, int type, __le16 dst, int dst_len, struct dn_ifaddr *ifa)
{
	struct dn_fib_table *tb;
	struct {
		struct nlmsghdr nlh;
		struct rtmsg rtm;
	} req;
	struct {
		struct nlattr hdr;
		__le16 dst;
	} dst_attr = {
		.dst = dst,
	};
	struct {
		struct nlattr hdr;
		__le16 prefsrc;
	} prefsrc_attr = {
		.prefsrc = ifa->ifa_local,
	};
	struct {
		struct nlattr hdr;
		u32 oif;
	} oif_attr = {
		.oif = ifa->ifa_dev->dev->ifindex,
	};
	struct nlattr *attrs[RTA_MAX+1] = {
		[RTA_DST] = (struct nlattr *) &dst_attr,
		[RTA_PREFSRC] = (struct nlattr * ) &prefsrc_attr,
		[RTA_OIF] = (struct nlattr *) &oif_attr,
	};

	memset(&req.rtm, 0, sizeof(req.rtm));

	if (type == RTN_UNICAST)
		tb = dn_fib_get_table(RT_MIN_TABLE, 1);
	else
		tb = dn_fib_get_table(RT_TABLE_LOCAL, 1);

	if (tb == NULL)
		return;

	req.nlh.nlmsg_len = sizeof(req);
	req.nlh.nlmsg_type = cmd;
	req.nlh.nlmsg_flags = NLM_F_REQUEST|NLM_F_CREATE|NLM_F_APPEND;
	req.nlh.nlmsg_pid = 0;
	req.nlh.nlmsg_seq = 0;

	req.rtm.rtm_dst_len = dst_len;
	req.rtm.rtm_table = tb->n;
	req.rtm.rtm_protocol = RTPROT_KERNEL;
	req.rtm.rtm_scope = (type != RTN_LOCAL ? RT_SCOPE_LINK : RT_SCOPE_HOST);
	req.rtm.rtm_type = type;

	if (cmd == RTM_NEWROUTE)
		tb->insert(tb, &req.rtm, attrs, &req.nlh, NULL);
	else
		tb->delete(tb, &req.rtm, attrs, &req.nlh, NULL);
}

static void dn_fib_add_ifaddr(struct dn_ifaddr *ifa)
{

	fib_magic(RTM_NEWROUTE, RTN_LOCAL, ifa->ifa_local, 16, ifa);

#if 0
	if (!(dev->flags&IFF_UP))
		return;
	/* In the future, we will want to add default routes here */

#endif
}

static void dn_fib_del_ifaddr(struct dn_ifaddr *ifa)
{
	int found_it = 0;
	struct net_device *dev;
	struct dn_dev *dn_db;
	struct dn_ifaddr *ifa2;

	ASSERT_RTNL();

	/* Scan device list */
	rcu_read_lock();
	for_each_netdev_rcu(&init_net, dev) {
		dn_db = rcu_dereference(dev->dn_ptr);
		if (dn_db == NULL)
			continue;
		for (ifa2 = rcu_dereference(dn_db->ifa_list);
		     ifa2 != NULL;
		     ifa2 = rcu_dereference(ifa2->ifa_next)) {
			if (ifa2->ifa_local == ifa->ifa_local) {
				found_it = 1;
				break;
			}
		}
	}
	rcu_read_unlock();

	if (found_it == 0) {
		fib_magic(RTM_DELROUTE, RTN_LOCAL, ifa->ifa_local, 16, ifa);

		if (dnet_addr_type(ifa->ifa_local) != RTN_LOCAL) {
			if (dn_fib_sync_down(ifa->ifa_local, NULL, 0))
				dn_fib_flush();
		}
	}
}

static void dn_fib_disable_addr(struct net_device *dev, int force)
{
	if (dn_fib_sync_down(0, dev, force))
		dn_fib_flush();
	dn_rt_cache_flush(0);
	neigh_ifdown(&dn_neigh_table, dev);
}

static int dn_fib_dnaddr_event(struct notifier_block *this, unsigned long event, void *ptr)
{
	struct dn_ifaddr *ifa = (struct dn_ifaddr *)ptr;

	switch (event) {
	case NETDEV_UP:
		dn_fib_add_ifaddr(ifa);
		dn_fib_sync_up(ifa->ifa_dev->dev);
		dn_rt_cache_flush(-1);
		break;
	case NETDEV_DOWN:
		dn_fib_del_ifaddr(ifa);
		if (ifa->ifa_dev && ifa->ifa_dev->ifa_list == NULL) {
			dn_fib_disable_addr(ifa->ifa_dev->dev, 1);
		} else {
			dn_rt_cache_flush(-1);
		}
		break;
	}
	return NOTIFY_DONE;
}

static int dn_fib_sync_down(__le16 local, struct net_device *dev, int force)
{
	int ret = 0;
	int scope = RT_SCOPE_NOWHERE;

	if (force)
		scope = -1;

	for_fib_info() {
		/*
		 * This makes no sense for DECnet.... we will almost
		 * certainly have more than one local address the same
		 * over all our interfaces. It needs thinking about
		 * some more.
		 */
		if (local && fi->fib_prefsrc == local) {
			fi->fib_flags |= RTNH_F_DEAD;
			ret++;
		} else if (dev && fi->fib_nhs) {
			int dead = 0;

			change_nexthops(fi) {
				if (nh->nh_flags&RTNH_F_DEAD)
					dead++;
				else if (nh->nh_dev == dev &&
						nh->nh_scope != scope) {
					spin_lock_bh(&dn_fib_multipath_lock);
					nh->nh_flags |= RTNH_F_DEAD;
					fi->fib_power -= nh->nh_power;
					nh->nh_power = 0;
					spin_unlock_bh(&dn_fib_multipath_lock);
					dead++;
				}
			} endfor_nexthops(fi)
			if (dead == fi->fib_nhs) {
				fi->fib_flags |= RTNH_F_DEAD;
				ret++;
			}
		}
	} endfor_fib_info();
	return ret;
}


static int dn_fib_sync_up(struct net_device *dev)
{
	int ret = 0;

	if (!(dev->flags&IFF_UP))
		return 0;

	for_fib_info() {
		int alive = 0;

		change_nexthops(fi) {
			if (!(nh->nh_flags&RTNH_F_DEAD)) {
				alive++;
				continue;
			}
			if (nh->nh_dev == NULL || !(nh->nh_dev->flags&IFF_UP))
				continue;
			if (nh->nh_dev != dev || dev->dn_ptr == NULL)
				continue;
			alive++;
			spin_lock_bh(&dn_fib_multipath_lock);
			nh->nh_power = 0;
			nh->nh_flags &= ~RTNH_F_DEAD;
			spin_unlock_bh(&dn_fib_multipath_lock);
		} endfor_nexthops(fi);

		if (alive > 0) {
			fi->fib_flags &= ~RTNH_F_DEAD;
			ret++;
		}
	} endfor_fib_info();
	return ret;
}

static struct notifier_block dn_fib_dnaddr_notifier = {
	.notifier_call = dn_fib_dnaddr_event,
};

void __exit dn_fib_cleanup(void)
{
	dn_fib_table_cleanup();
	dn_fib_rules_cleanup();

	unregister_dnaddr_notifier(&dn_fib_dnaddr_notifier);
}


void __init dn_fib_init(void)
{
	dn_fib_table_init();
	dn_fib_rules_init();

	register_dnaddr_notifier(&dn_fib_dnaddr_notifier);

	rtnl_register_module(THIS_MODULE, PF_DECnet, RTM_NEWROUTE,
			     dn_fib_rtm_newroute, NULL, 0);
	rtnl_register_module(THIS_MODULE, PF_DECnet, RTM_DELROUTE,
			     dn_fib_rtm_delroute, NULL, 0);
}",1202cdd665315c525b5237e96e0bedc76d7e754f,CVE-2023-3338,1202cdd665315c525b5237e96e0bedc76d7e754f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,"  /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR (VAR/VAR VAR) * * VAR: VAR VAR <VAR@VAR.VAR> * * * VAR: * VAR VAR : VAR VAR VAR * VAR VAR : VAR VAR... VAR VAR VAR VAR VAR, VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR : VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR. * */                            VAR(VAR = VAR; VAR; VAR = VAR->VAR)   VAR(VAR = 0, VAR = (VAR)->VAR; VAR < (VAR)->VAR; VAR++, VAR++)  VAR(VAR = 0, VAR = (VAR VAR *)((VAR)->VAR); VAR < (VAR)->VAR; VAR++, VAR++)  VAR VAR(VAR); VAR VAR VAR *VAR; VAR VAR(VAR); VAR VAR { VAR VAR; VAR VAR; } VAR[VAR+1] = { [VAR] = { .VAR = 0, .VAR = VAR }, [VAR] = { .VAR = 0, .VAR = VAR }, [VAR] = { .VAR = 0, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, [VAR] = { .VAR = 0, .VAR = VAR }, [VAR] = { .VAR = -VAR, .VAR = VAR }, }; VAR VAR VAR(VAR VAR, VAR VAR *VAR, VAR VAR); VAR VAR VAR(VAR VAR *VAR); VAR VAR(VAR VAR *VAR) { VAR (VAR->VAR == 0) { VAR(VAR ""VAR: VAR! VAR VAR VAR VAR VAR\VAR""); VAR; } VAR(VAR) { VAR(VAR->VAR); VAR->VAR = VAR; } VAR(VAR); VAR(VAR); } VAR VAR(VAR VAR *VAR) { VAR(&VAR); VAR (VAR && VAR(&VAR->VAR)) { VAR (VAR->VAR) VAR->VAR->VAR = VAR->VAR; VAR (VAR->VAR) VAR->VAR->VAR = VAR->VAR; VAR (VAR == VAR) VAR = VAR->VAR; VAR->VAR = 1; VAR(VAR); } VAR(&VAR); } VAR VAR VAR VAR(VAR VAR VAR *VAR, VAR VAR VAR *VAR) { VAR VAR VAR *VAR = VAR->VAR; VAR(VAR) { VAR (VAR->VAR != VAR->VAR || VAR->VAR != VAR->VAR || VAR->VAR != VAR->VAR || VAR->VAR != VAR->VAR || ((VAR->VAR^VAR->VAR)&~VAR)) VAR -1; VAR++; } VAR(VAR); VAR 0; } VAR VAR VAR VAR *VAR(VAR VAR VAR *VAR) { VAR() { VAR (VAR->VAR != VAR->VAR) VAR; VAR (VAR->VAR == VAR->VAR && VAR->VAR == VAR->VAR && VAR->VAR == VAR->VAR && VAR(VAR->VAR, VAR->VAR, VAR(VAR->VAR)) == 0 && ((VAR->VAR^VAR->VAR)&~VAR) == 0 && (VAR->VAR == 0 || VAR(VAR, VAR) == 0)) VAR VAR; } VAR(); VAR VAR; } VAR VAR VAR(VAR VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR = 0, VAR = VAR(VAR); VAR (VAR(VAR, VAR)) { VAR++; VAR = VAR(VAR, &VAR); }  VAR VAR > 0 ? 0 : VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR = VAR(VAR); VAR(VAR) { VAR VAR; VAR (!VAR(VAR, VAR)) VAR -VAR; VAR->VAR = (VAR->VAR&~0xFF) | VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR + 1; VAR = VAR(VAR); VAR (VAR > 0) { VAR VAR *VAR; VAR = VAR((VAR VAR *) (VAR + 1), VAR, VAR); VAR->VAR = VAR ? VAR(VAR) : 0; } VAR = VAR(VAR, &VAR); } VAR(VAR); VAR 0; } VAR VAR VAR(VAR VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR; VAR (VAR->VAR) { VAR VAR VAR; VAR VAR VAR; VAR (VAR->VAR&VAR) { VAR VAR *VAR; VAR (VAR->VAR >= VAR) VAR -VAR; VAR (VAR(VAR->VAR) != VAR) VAR -VAR; VAR ((VAR = VAR(&VAR, VAR->VAR)) == VAR) VAR -VAR; VAR (!(VAR->VAR&VAR)) VAR -VAR; VAR->VAR = VAR; VAR(VAR); VAR->VAR = VAR; VAR 0; } VAR(&VAR, 0, VAR(VAR)); VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR + 1; VAR (VAR.VAR < VAR) VAR.VAR = VAR; VAR ((VAR = VAR(&VAR, &VAR)) != 0) VAR VAR; VAR = -VAR; VAR (VAR.VAR != VAR && VAR.VAR != VAR) VAR VAR; VAR->VAR = VAR.VAR; VAR->VAR = VAR(VAR); VAR->VAR = VAR(VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR); VAR = -VAR; VAR (!(VAR->VAR->VAR & VAR)) VAR VAR; VAR = 0; VAR: VAR(&VAR); VAR VAR; } VAR { VAR VAR *VAR; VAR (VAR->VAR&(VAR|VAR)) VAR -VAR; VAR = VAR(&VAR, VAR->VAR); VAR (VAR == VAR || VAR->VAR == VAR) VAR -VAR; VAR (!(VAR->VAR&VAR)) VAR -VAR; VAR->VAR = VAR; VAR(VAR->VAR); VAR->VAR = VAR; } VAR 0; } VAR VAR *VAR(VAR VAR VAR *VAR, VAR VAR *VAR[], VAR VAR VAR *VAR, VAR *VAR) { VAR VAR; VAR VAR *VAR = VAR; VAR VAR *VAR; VAR VAR = 1; VAR (VAR->VAR > VAR) VAR VAR; VAR (VAR[VAR->VAR].VAR > VAR->VAR) VAR VAR; VAR (VAR[VAR] && (VAR = VAR(VAR[VAR])) == 0) VAR VAR; VAR = VAR(VAR(VAR, VAR, VAR), VAR); VAR = -VAR; VAR (VAR == VAR) VAR VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR (VAR[VAR]) VAR->VAR = VAR(VAR[VAR]); VAR (VAR[VAR]) { VAR VAR *VAR; VAR VAR; VAR(VAR, VAR[VAR], VAR) { VAR VAR = VAR(VAR); VAR (VAR) { VAR (VAR > VAR || VAR == VAR || VAR(VAR) < 4) VAR VAR; VAR->VAR[VAR-1] = VAR(VAR); } } } VAR (VAR[VAR]) VAR->VAR = VAR(VAR[VAR]); VAR (VAR[VAR]) { VAR ((VAR = VAR(VAR, VAR[VAR], VAR)) != 0) VAR VAR; VAR (VAR[VAR] && VAR->VAR->VAR != VAR(VAR[VAR])) VAR VAR; VAR (VAR[VAR] && VAR->VAR->VAR != VAR(VAR[VAR])) VAR VAR; } VAR { VAR VAR *VAR = VAR->VAR; VAR (VAR[VAR]) VAR->VAR = VAR(VAR[VAR]); VAR (VAR[VAR]) VAR->VAR = VAR(VAR[VAR]); VAR->VAR = VAR->VAR; VAR->VAR = 1; } VAR (VAR->VAR == VAR) { VAR (!VAR[VAR] || VAR != 1 || VAR[VAR]) VAR VAR; VAR->VAR->VAR = VAR(VAR[VAR]); VAR VAR; } VAR (VAR[VAR->VAR].VAR) { VAR (VAR[VAR] || VAR[VAR] || VAR[VAR]) VAR VAR; VAR VAR; } VAR (VAR->VAR > VAR) VAR VAR; VAR (VAR->VAR == VAR) { VAR VAR *VAR = VAR->VAR;  VAR (VAR != 1 || VAR->VAR) VAR VAR; VAR->VAR = VAR; VAR->VAR = VAR(&VAR, VAR->VAR->VAR); VAR = -VAR; VAR (VAR->VAR == VAR) VAR VAR; } VAR { VAR(VAR) { VAR ((VAR = VAR(VAR, VAR, VAR)) != 0) VAR VAR; } VAR(VAR) } VAR (VAR->VAR) { VAR (VAR->VAR != VAR || !VAR[VAR] || VAR->VAR != VAR(VAR[VAR])) VAR (VAR(VAR->VAR) != VAR) VAR VAR; } VAR: VAR ((VAR = VAR(VAR)) != VAR) { VAR->VAR = 1; VAR(VAR); VAR(&VAR->VAR); VAR VAR; } VAR(&VAR->VAR, 1); VAR(&VAR->VAR, 1); VAR(&VAR); VAR->VAR = VAR; VAR->VAR = VAR; VAR (VAR) VAR->VAR = VAR; VAR = VAR; VAR(&VAR); VAR VAR; VAR: VAR = -VAR; VAR: *VAR = VAR; VAR (VAR) { VAR->VAR = 1; VAR(VAR); } VAR VAR; } VAR VAR(VAR VAR, VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR *VAR) { VAR VAR = VAR[VAR].VAR; VAR (VAR == 0) { VAR (VAR->VAR & VAR) VAR 1; VAR->VAR = VAR; VAR (VAR) { VAR VAR: VAR(*VAR); VAR(&VAR->VAR); VAR 0; VAR VAR: VAR VAR: VAR(VAR) { VAR (VAR->VAR & VAR) VAR; VAR (!VAR->VAR || VAR->VAR == VAR->VAR) VAR; } VAR (VAR < VAR->VAR) { VAR->VAR = VAR; VAR(&VAR->VAR); VAR 0; } VAR(VAR); VAR->VAR = VAR; VAR 1; VAR: VAR(""VAR: VAR VAR VAR : VAR VAR=%VAR\VAR"", VAR); VAR->VAR = VAR; VAR -VAR; } } VAR VAR; } VAR VAR(VAR VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR; VAR(&VAR); VAR (VAR->VAR <= 0) { VAR VAR = 0; VAR(VAR) { VAR (!(VAR->VAR&VAR)) { VAR += VAR->VAR; VAR->VAR = VAR->VAR; } } VAR(VAR); VAR->VAR = VAR; VAR (VAR < 0) { VAR(&VAR); VAR->VAR = 0; VAR; } } VAR = VAR % VAR->VAR; VAR(VAR) { VAR (!(VAR->VAR&VAR) && VAR->VAR) { VAR ((VAR -= VAR->VAR) <= 0) { VAR->VAR--; VAR->VAR--; VAR->VAR = VAR; VAR(&VAR); VAR; } } } VAR(VAR); VAR->VAR = 0; VAR(&VAR); } VAR VAR VAR VAR(VAR VAR *VAR[], VAR VAR) { VAR (VAR[VAR]) VAR = VAR(VAR[VAR]); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR; VAR VAR *VAR = VAR(VAR); VAR VAR *VAR[VAR+1]; VAR VAR; VAR (!VAR(VAR, VAR)) VAR -VAR; VAR (!VAR(VAR, &VAR)) VAR -VAR; VAR = VAR(VAR, VAR(*VAR), VAR, VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR(VAR, VAR->VAR), 0); VAR (!VAR) VAR -VAR; VAR VAR->VAR(VAR, VAR, VAR, VAR, &VAR(VAR)); } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR; VAR VAR *VAR = VAR(VAR); VAR VAR *VAR[VAR+1]; VAR VAR; VAR (!VAR(VAR, VAR)) VAR -VAR; VAR (!VAR(VAR, &VAR)) VAR -VAR; VAR = VAR(VAR, VAR(*VAR), VAR, VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR(VAR, VAR->VAR), 1); VAR (!VAR) VAR -VAR; VAR VAR->VAR(VAR, VAR, VAR, VAR, &VAR(VAR)); } VAR VAR VAR(VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR *VAR) { VAR VAR *VAR; VAR { VAR VAR VAR; VAR VAR VAR; } VAR; VAR { VAR VAR VAR; VAR VAR; } VAR = { .VAR = VAR, }; VAR { VAR VAR VAR; VAR VAR; } VAR = { .VAR = VAR->VAR, }; VAR { VAR VAR VAR; VAR VAR; } VAR = { .VAR = VAR->VAR->VAR->VAR, }; VAR VAR *VAR[VAR+1] = { [VAR] = (VAR VAR *) &VAR, [VAR] = (VAR VAR * ) &VAR, [VAR] = (VAR VAR *) &VAR, }; VAR(&VAR.VAR, 0, VAR(VAR.VAR)); VAR (VAR == VAR) VAR = VAR(VAR, 1); VAR VAR = VAR(VAR, 1); VAR (VAR == VAR) VAR; VAR.VAR.VAR = VAR(VAR); VAR.VAR.VAR = VAR; VAR.VAR.VAR = VAR|VAR|VAR; VAR.VAR.VAR = 0; VAR.VAR.VAR = 0; VAR.VAR.VAR = VAR; VAR.VAR.VAR = VAR->VAR; VAR.VAR.VAR = VAR; VAR.VAR.VAR = (VAR != VAR ? VAR : VAR); VAR.VAR.VAR = VAR; VAR (VAR == VAR) VAR->VAR(VAR, &VAR.VAR, VAR, &VAR.VAR, VAR); VAR VAR->VAR(VAR, &VAR.VAR, VAR, &VAR.VAR, VAR); } VAR VAR VAR(VAR VAR *VAR) { VAR(VAR, VAR, VAR->VAR, 16, VAR);  VAR (!(VAR->VAR&VAR)) VAR;   } VAR VAR VAR(VAR VAR *VAR) { VAR VAR = 0; VAR VAR *VAR; VAR VAR *VAR; VAR VAR *VAR; VAR();  VAR(); VAR(&VAR, VAR) { VAR = VAR(VAR->VAR); VAR (VAR == VAR) VAR; VAR (VAR = VAR(VAR->VAR); VAR != VAR; VAR = VAR(VAR->VAR)) { VAR (VAR->VAR == VAR->VAR) { VAR = 1; VAR; } } } VAR(); VAR (VAR == 0) { VAR(VAR, VAR, VAR->VAR, 16, VAR); VAR (VAR(VAR->VAR) != VAR) { VAR (VAR(VAR->VAR, VAR, 0)) VAR(); } } } VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR (VAR(0, VAR, VAR)) VAR(); VAR(0); VAR(&VAR, VAR); } VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR *VAR) { VAR VAR *VAR = (VAR VAR *)VAR; VAR (VAR) { VAR VAR: VAR(VAR); VAR(VAR->VAR->VAR); VAR(-1); VAR; VAR VAR: VAR(VAR); VAR (VAR->VAR && VAR->VAR->VAR == VAR) { VAR(VAR->VAR->VAR, 1); } VAR { VAR(-1); } VAR; } VAR VAR; } VAR VAR VAR(VAR VAR, VAR VAR *VAR, VAR VAR) { VAR VAR = 0; VAR VAR = VAR; VAR (VAR) VAR = -1; VAR() { /* * VAR VAR VAR VAR VAR VAR.... VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR. VAR VAR VAR VAR * VAR VAR. */ VAR (VAR && VAR->VAR == VAR) { VAR->VAR |= VAR; VAR++; } VAR VAR (VAR && VAR->VAR) { VAR VAR = 0; VAR(VAR) { VAR (VAR->VAR&VAR) VAR++; VAR VAR (VAR->VAR == VAR && VAR->VAR != VAR) { VAR(&VAR); VAR->VAR |= VAR; VAR->VAR -= VAR->VAR; VAR->VAR = 0; VAR(&VAR); VAR++; } } VAR(VAR) VAR (VAR == VAR->VAR) { VAR->VAR |= VAR; VAR++; } } } VAR(); VAR VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR = 0; VAR (!(VAR->VAR&VAR)) VAR 0; VAR() { VAR VAR = 0; VAR(VAR) { VAR (!(VAR->VAR&VAR)) { VAR++; VAR; } VAR (VAR->VAR == VAR || !(VAR->VAR->VAR&VAR)) VAR; VAR (VAR->VAR != VAR || VAR->VAR == VAR) VAR; VAR++; VAR(&VAR); VAR->VAR = 0; VAR->VAR &= ~VAR; VAR(&VAR); } VAR(VAR); VAR (VAR > 0) { VAR->VAR &= ~VAR; VAR++; } } VAR(); VAR VAR; } VAR VAR VAR VAR = { .VAR = VAR, }; VAR VAR VAR(VAR) { VAR(); VAR(); VAR(&VAR); } VAR VAR VAR(VAR) { VAR(); VAR(); VAR(&VAR); VAR(VAR, VAR, VAR, VAR, VAR, 0); VAR(VAR, VAR, VAR, VAR, VAR, 0); }",1,15
linux_1202cdd665315c525b5237e96e0bedc76d7e754f,net/decnet/dn_table.c,,"// SPDX-License-Identifier: GPL-2.0
/*
 * DECnet       An implementation of the DECnet protocol suite for the LINUX
 *              operating system.  DECnet is implemented using the  BSD Socket
 *              interface as the means of communication with the user level.
 *
 *              DECnet Routing Forwarding Information Base (Routing Tables)
 *
 * Author:      Steve Whitehouse <SteveW@ACM.org>
 *              Mostly copied from the IPv4 routing code
 *
 *
 * Changes:
 *
 */
#include <linux/string.h>
#include <linux/net.h>
#include <linux/socket.h>
#include <linux/slab.h>
#include <linux/sockios.h>
#include <linux/init.h>
#include <linux/skbuff.h>
#include <linux/rtnetlink.h>
#include <linux/proc_fs.h>
#include <linux/netdevice.h>
#include <linux/timer.h>
#include <linux/spinlock.h>
#include <linux/atomic.h>
#include <linux/uaccess.h>
#include <linux/route.h> /* RTF_xxx */
#include <net/neighbour.h>
#include <net/netlink.h>
#include <net/tcp.h>
#include <net/dst.h>
#include <net/flow.h>
#include <net/fib_rules.h>
#include <net/dn.h>
#include <net/dn_route.h>
#include <net/dn_fib.h>
#include <net/dn_neigh.h>
#include <net/dn_dev.h>

struct dn_zone
{
	struct dn_zone		*dz_next;
	struct dn_fib_node 	**dz_hash;
	int			dz_nent;
	int			dz_divisor;
	u32			dz_hashmask;
#define DZ_HASHMASK(dz)	((dz)->dz_hashmask)
	int			dz_order;
	__le16			dz_mask;
#define DZ_MASK(dz)	((dz)->dz_mask)
};

struct dn_hash
{
	struct dn_zone	*dh_zones[17];
	struct dn_zone	*dh_zone_list;
};

#define dz_key_0(key)		((key).datum = 0)

#define for_nexthops(fi) { int nhsel; const struct dn_fib_nh *nh;\
	for(nhsel = 0, nh = (fi)->fib_nh; nhsel < (fi)->fib_nhs; nh++, nhsel++)

#define endfor_nexthops(fi) }

#define DN_MAX_DIVISOR 1024
#define DN_S_ZOMBIE 1
#define DN_S_ACCESSED 2

#define DN_FIB_SCAN(f, fp) \
for( ; ((f) = *(fp)) != NULL; (fp) = &(f)->fn_next)

#define DN_FIB_SCAN_KEY(f, fp, key) \
for( ; ((f) = *(fp)) != NULL && dn_key_eq((f)->fn_key, (key)); (fp) = &(f)->fn_next)

#define RT_TABLE_MIN 1
#define DN_FIB_TABLE_HASHSZ 256
static struct hlist_head dn_fib_table_hash[DN_FIB_TABLE_HASHSZ];
static DEFINE_RWLOCK(dn_fib_tables_lock);

static struct kmem_cache *dn_hash_kmem __read_mostly;
static int dn_fib_hash_zombies;

static inline dn_fib_idx_t dn_hash(dn_fib_key_t key, struct dn_zone *dz)
{
	u16 h = le16_to_cpu(key.datum)>>(16 - dz->dz_order);
	h ^= (h >> 10);
	h ^= (h >> 6);
	h &= DZ_HASHMASK(dz);
	return *(dn_fib_idx_t *)&h;
}

static inline dn_fib_key_t dz_key(__le16 dst, struct dn_zone *dz)
{
	dn_fib_key_t k;
	k.datum = dst & DZ_MASK(dz);
	return k;
}

static inline struct dn_fib_node **dn_chain_p(dn_fib_key_t key, struct dn_zone *dz)
{
	return &dz->dz_hash[dn_hash(key, dz).datum];
}

static inline struct dn_fib_node *dz_chain(dn_fib_key_t key, struct dn_zone *dz)
{
	return dz->dz_hash[dn_hash(key, dz).datum];
}

static inline int dn_key_eq(dn_fib_key_t a, dn_fib_key_t b)
{
	return a.datum == b.datum;
}

static inline int dn_key_leq(dn_fib_key_t a, dn_fib_key_t b)
{
	return a.datum <= b.datum;
}

static inline void dn_rebuild_zone(struct dn_zone *dz,
				   struct dn_fib_node **old_ht,
				   int old_divisor)
{
	struct dn_fib_node *f, **fp, *next;
	int i;

	for(i = 0; i < old_divisor; i++) {
		for(f = old_ht[i]; f; f = next) {
			next = f->fn_next;
			for(fp = dn_chain_p(f->fn_key, dz);
				*fp && dn_key_leq((*fp)->fn_key, f->fn_key);
				fp = &(*fp)->fn_next)
				/* NOTHING */;
			f->fn_next = *fp;
			*fp = f;
		}
	}
}

static void dn_rehash_zone(struct dn_zone *dz)
{
	struct dn_fib_node **ht, **old_ht;
	int old_divisor, new_divisor;
	u32 new_hashmask;

	old_divisor = dz->dz_divisor;

	switch (old_divisor) {
	case 16:
		new_divisor = 256;
		new_hashmask = 0xFF;
		break;
	default:
		printk(KERN_DEBUG ""DECnet: dn_rehash_zone: BUG! %d\n"",
		       old_divisor);
		fallthrough;
	case 256:
		new_divisor = 1024;
		new_hashmask = 0x3FF;
		break;
	}

	ht = kcalloc(new_divisor, sizeof(struct dn_fib_node*), GFP_KERNEL);
	if (ht == NULL)
		return;

	write_lock_bh(&dn_fib_tables_lock);
	old_ht = dz->dz_hash;
	dz->dz_hash = ht;
	dz->dz_hashmask = new_hashmask;
	dz->dz_divisor = new_divisor;
	dn_rebuild_zone(dz, old_ht, old_divisor);
	write_unlock_bh(&dn_fib_tables_lock);
	kfree(old_ht);
}

static void dn_free_node(struct dn_fib_node *f)
{
	dn_fib_release_info(DN_FIB_INFO(f));
	kmem_cache_free(dn_hash_kmem, f);
}


static struct dn_zone *dn_new_zone(struct dn_hash *table, int z)
{
	int i;
	struct dn_zone *dz = kzalloc(sizeof(struct dn_zone), GFP_KERNEL);
	if (!dz)
		return NULL;

	if (z) {
		dz->dz_divisor = 16;
		dz->dz_hashmask = 0x0F;
	} else {
		dz->dz_divisor = 1;
		dz->dz_hashmask = 0;
	}

	dz->dz_hash = kcalloc(dz->dz_divisor, sizeof(struct dn_fib_node *), GFP_KERNEL);
	if (!dz->dz_hash) {
		kfree(dz);
		return NULL;
	}

	dz->dz_order = z;
	dz->dz_mask = dnet_make_mask(z);

	for(i = z + 1; i <= 16; i++)
		if (table->dh_zones[i])
			break;

	write_lock_bh(&dn_fib_tables_lock);
	if (i>16) {
		dz->dz_next = table->dh_zone_list;
		table->dh_zone_list = dz;
	} else {
		dz->dz_next = table->dh_zones[i]->dz_next;
		table->dh_zones[i]->dz_next = dz;
	}
	table->dh_zones[z] = dz;
	write_unlock_bh(&dn_fib_tables_lock);
	return dz;
}


static int dn_fib_nh_match(struct rtmsg *r, struct nlmsghdr *nlh, struct nlattr *attrs[], struct dn_fib_info *fi)
{
	struct rtnexthop *nhp;
	int nhlen;

	if (attrs[RTA_PRIORITY] &&
	    nla_get_u32(attrs[RTA_PRIORITY]) != fi->fib_priority)
		return 1;

	if (attrs[RTA_OIF] || attrs[RTA_GATEWAY]) {
		if ((!attrs[RTA_OIF] || nla_get_u32(attrs[RTA_OIF]) == fi->fib_nh->nh_oif) &&
		    (!attrs[RTA_GATEWAY]  || nla_get_le16(attrs[RTA_GATEWAY]) != fi->fib_nh->nh_gw))
			return 0;
		return 1;
	}

	if (!attrs[RTA_MULTIPATH])
		return 0;

	nhp = nla_data(attrs[RTA_MULTIPATH]);
	nhlen = nla_len(attrs[RTA_MULTIPATH]);

	for_nexthops(fi) {
		int attrlen = nhlen - sizeof(struct rtnexthop);
		__le16 gw;

		if (attrlen < 0 || (nhlen -= nhp->rtnh_len) < 0)
			return -EINVAL;
		if (nhp->rtnh_ifindex && nhp->rtnh_ifindex != nh->nh_oif)
			return 1;
		if (attrlen) {
			struct nlattr *gw_attr;

			gw_attr = nla_find((struct nlattr *) (nhp + 1), attrlen, RTA_GATEWAY);
			gw = gw_attr ? nla_get_le16(gw_attr) : 0;

			if (gw && gw != nh->nh_gw)
				return 1;
		}
		nhp = RTNH_NEXT(nhp);
	} endfor_nexthops(fi);

	return 0;
}

static inline size_t dn_fib_nlmsg_size(struct dn_fib_info *fi)
{
	size_t payload = NLMSG_ALIGN(sizeof(struct rtmsg))
			 + nla_total_size(4) /* RTA_TABLE */
			 + nla_total_size(2) /* RTA_DST */
			 + nla_total_size(4) /* RTA_PRIORITY */
			 + nla_total_size(TCP_CA_NAME_MAX); /* RTAX_CC_ALGO */

	/* space for nested metrics */
	payload += nla_total_size((RTAX_MAX * nla_total_size(4)));

	if (fi->fib_nhs) {
		/* Also handles the special case fib_nhs == 1 */

		/* each nexthop is packed in an attribute */
		size_t nhsize = nla_total_size(sizeof(struct rtnexthop));

		/* may contain a gateway attribute */
		nhsize += nla_total_size(4);

		/* all nexthops are packed in a nested attribute */
		payload += nla_total_size(fi->fib_nhs * nhsize);
	}

	return payload;
}

static int dn_fib_dump_info(struct sk_buff *skb, u32 portid, u32 seq, int event,
			u32 tb_id, u8 type, u8 scope, void *dst, int dst_len,
			struct dn_fib_info *fi, unsigned int flags)
{
	struct rtmsg *rtm;
	struct nlmsghdr *nlh;

	nlh = nlmsg_put(skb, portid, seq, event, sizeof(*rtm), flags);
	if (!nlh)
		return -EMSGSIZE;

	rtm = nlmsg_data(nlh);
	rtm->rtm_family = AF_DECnet;
	rtm->rtm_dst_len = dst_len;
	rtm->rtm_src_len = 0;
	rtm->rtm_tos = 0;
	rtm->rtm_table = tb_id;
	rtm->rtm_flags = fi->fib_flags;
	rtm->rtm_scope = scope;
	rtm->rtm_type  = type;
	rtm->rtm_protocol = fi->fib_protocol;

	if (nla_put_u32(skb, RTA_TABLE, tb_id) < 0)
		goto errout;

	if (rtm->rtm_dst_len &&
	    nla_put(skb, RTA_DST, 2, dst) < 0)
		goto errout;

	if (fi->fib_priority &&
	    nla_put_u32(skb, RTA_PRIORITY, fi->fib_priority) < 0)
		goto errout;

	if (rtnetlink_put_metrics(skb, fi->fib_metrics) < 0)
		goto errout;

	if (fi->fib_nhs == 1) {
		if (fi->fib_nh->nh_gw &&
		    nla_put_le16(skb, RTA_GATEWAY, fi->fib_nh->nh_gw) < 0)
			goto errout;

		if (fi->fib_nh->nh_oif &&
		    nla_put_u32(skb, RTA_OIF, fi->fib_nh->nh_oif) < 0)
			goto errout;
	}

	if (fi->fib_nhs > 1) {
		struct rtnexthop *nhp;
		struct nlattr *mp_head;

		mp_head = nla_nest_start_noflag(skb, RTA_MULTIPATH);
		if (!mp_head)
			goto errout;

		for_nexthops(fi) {
			if (!(nhp = nla_reserve_nohdr(skb, sizeof(*nhp))))
				goto errout;

			nhp->rtnh_flags = nh->nh_flags & 0xFF;
			nhp->rtnh_hops = nh->nh_weight - 1;
			nhp->rtnh_ifindex = nh->nh_oif;

			if (nh->nh_gw &&
			    nla_put_le16(skb, RTA_GATEWAY, nh->nh_gw) < 0)
				goto errout;

			nhp->rtnh_len = skb_tail_pointer(skb) - (unsigned char *)nhp;
		} endfor_nexthops(fi);

		nla_nest_end(skb, mp_head);
	}

	nlmsg_end(skb, nlh);
	return 0;

errout:
	nlmsg_cancel(skb, nlh);
	return -EMSGSIZE;
}


static void dn_rtmsg_fib(int event, struct dn_fib_node *f, int z, u32 tb_id,
			struct nlmsghdr *nlh, struct netlink_skb_parms *req)
{
	struct sk_buff *skb;
	u32 portid = req ? req->portid : 0;
	int err = -ENOBUFS;

	skb = nlmsg_new(dn_fib_nlmsg_size(DN_FIB_INFO(f)), GFP_KERNEL);
	if (skb == NULL)
		goto errout;

	err = dn_fib_dump_info(skb, portid, nlh->nlmsg_seq, event, tb_id,
			       f->fn_type, f->fn_scope, &f->fn_key, z,
			       DN_FIB_INFO(f), 0);
	if (err < 0) {
		/* -EMSGSIZE implies BUG in dn_fib_nlmsg_size() */
		WARN_ON(err == -EMSGSIZE);
		kfree_skb(skb);
		goto errout;
	}
	rtnl_notify(skb, &init_net, portid, RTNLGRP_DECnet_ROUTE, nlh, GFP_KERNEL);
	return;
errout:
	if (err < 0)
		rtnl_set_sk_err(&init_net, RTNLGRP_DECnet_ROUTE, err);
}

static __inline__ int dn_hash_dump_bucket(struct sk_buff *skb,
				struct netlink_callback *cb,
				struct dn_fib_table *tb,
				struct dn_zone *dz,
				struct dn_fib_node *f)
{
	int i, s_i;

	s_i = cb->args[4];
	for(i = 0; f; i++, f = f->fn_next) {
		if (i < s_i)
			continue;
		if (f->fn_state & DN_S_ZOMBIE)
			continue;
		if (dn_fib_dump_info(skb, NETLINK_CB(cb->skb).portid,
				cb->nlh->nlmsg_seq,
				RTM_NEWROUTE,
				tb->n,
				(f->fn_state & DN_S_ZOMBIE) ? 0 : f->fn_type,
				f->fn_scope, &f->fn_key, dz->dz_order,
				f->fn_info, NLM_F_MULTI) < 0) {
			cb->args[4] = i;
			return -1;
		}
	}
	cb->args[4] = i;
	return skb->len;
}

static __inline__ int dn_hash_dump_zone(struct sk_buff *skb,
				struct netlink_callback *cb,
				struct dn_fib_table *tb,
				struct dn_zone *dz)
{
	int h, s_h;

	s_h = cb->args[3];
	for(h = 0; h < dz->dz_divisor; h++) {
		if (h < s_h)
			continue;
		if (h > s_h)
			memset(&cb->args[4], 0, sizeof(cb->args) - 4*sizeof(cb->args[0]));
		if (dz->dz_hash == NULL || dz->dz_hash[h] == NULL)
			continue;
		if (dn_hash_dump_bucket(skb, cb, tb, dz, dz->dz_hash[h]) < 0) {
			cb->args[3] = h;
			return -1;
		}
	}
	cb->args[3] = h;
	return skb->len;
}

static int dn_fib_table_dump(struct dn_fib_table *tb, struct sk_buff *skb,
				struct netlink_callback *cb)
{
	int m, s_m;
	struct dn_zone *dz;
	struct dn_hash *table = (struct dn_hash *)tb->data;

	s_m = cb->args[2];
	read_lock(&dn_fib_tables_lock);
	for(dz = table->dh_zone_list, m = 0; dz; dz = dz->dz_next, m++) {
		if (m < s_m)
			continue;
		if (m > s_m)
			memset(&cb->args[3], 0, sizeof(cb->args) - 3*sizeof(cb->args[0]));

		if (dn_hash_dump_zone(skb, cb, tb, dz) < 0) {
			cb->args[2] = m;
			read_unlock(&dn_fib_tables_lock);
			return -1;
		}
	}
	read_unlock(&dn_fib_tables_lock);
	cb->args[2] = m;

	return skb->len;
}

int dn_fib_dump(struct sk_buff *skb, struct netlink_callback *cb)
{
	struct net *net = sock_net(skb->sk);
	unsigned int h, s_h;
	unsigned int e = 0, s_e;
	struct dn_fib_table *tb;
	int dumped = 0;

	if (!net_eq(net, &init_net))
		return 0;

	if (nlmsg_len(cb->nlh) >= sizeof(struct rtmsg) &&
		((struct rtmsg *)nlmsg_data(cb->nlh))->rtm_flags&RTM_F_CLONED)
			return dn_cache_dump(skb, cb);

	s_h = cb->args[0];
	s_e = cb->args[1];

	for (h = s_h; h < DN_FIB_TABLE_HASHSZ; h++, s_h = 0) {
		e = 0;
		hlist_for_each_entry(tb, &dn_fib_table_hash[h], hlist) {
			if (e < s_e)
				goto next;
			if (dumped)
				memset(&cb->args[2], 0, sizeof(cb->args) -
						 2 * sizeof(cb->args[0]));
			if (tb->dump(tb, skb, cb) < 0)
				goto out;
			dumped = 1;
next:
			e++;
		}
	}
out:
	cb->args[1] = e;
	cb->args[0] = h;

	return skb->len;
}

static int dn_fib_table_insert(struct dn_fib_table *tb, struct rtmsg *r, struct nlattr *attrs[],
			       struct nlmsghdr *n, struct netlink_skb_parms *req)
{
	struct dn_hash *table = (struct dn_hash *)tb->data;
	struct dn_fib_node *new_f, *f, **fp, **del_fp;
	struct dn_zone *dz;
	struct dn_fib_info *fi;
	int z = r->rtm_dst_len;
	int type = r->rtm_type;
	dn_fib_key_t key;
	int err;

	if (z > 16)
		return -EINVAL;

	dz = table->dh_zones[z];
	if (!dz && !(dz = dn_new_zone(table, z)))
		return -ENOBUFS;

	dz_key_0(key);
	if (attrs[RTA_DST]) {
		__le16 dst = nla_get_le16(attrs[RTA_DST]);
		if (dst & ~DZ_MASK(dz))
			return -EINVAL;
		key = dz_key(dst, dz);
	}

	if ((fi = dn_fib_create_info(r, attrs, n, &err)) == NULL)
		return err;

	if (dz->dz_nent > (dz->dz_divisor << 2) &&
			dz->dz_divisor > DN_MAX_DIVISOR &&
			(z==16 || (1<<z) > dz->dz_divisor))
		dn_rehash_zone(dz);

	fp = dn_chain_p(key, dz);

	DN_FIB_SCAN(f, fp) {
		if (dn_key_leq(key, f->fn_key))
			break;
	}

	del_fp = NULL;

	if (f && (f->fn_state & DN_S_ZOMBIE) &&
			dn_key_eq(f->fn_key, key)) {
		del_fp = fp;
		fp = &f->fn_next;
		f = *fp;
		goto create;
	}

	DN_FIB_SCAN_KEY(f, fp, key) {
		if (fi->fib_priority <= DN_FIB_INFO(f)->fib_priority)
			break;
	}

	if (f && dn_key_eq(f->fn_key, key) &&
			fi->fib_priority == DN_FIB_INFO(f)->fib_priority) {
		struct dn_fib_node **ins_fp;

		err = -EEXIST;
		if (n->nlmsg_flags & NLM_F_EXCL)
			goto out;

		if (n->nlmsg_flags & NLM_F_REPLACE) {
			del_fp = fp;
			fp = &f->fn_next;
			f = *fp;
			goto replace;
		}

		ins_fp = fp;
		err = -EEXIST;

		DN_FIB_SCAN_KEY(f, fp, key) {
			if (fi->fib_priority != DN_FIB_INFO(f)->fib_priority)
				break;
			if (f->fn_type == type &&
			    f->fn_scope == r->rtm_scope &&
			    DN_FIB_INFO(f) == fi)
				goto out;
		}

		if (!(n->nlmsg_flags & NLM_F_APPEND)) {
			fp = ins_fp;
			f = *fp;
		}
	}

create:
	err = -ENOENT;
	if (!(n->nlmsg_flags & NLM_F_CREATE))
		goto out;

replace:
	err = -ENOBUFS;
	new_f = kmem_cache_zalloc(dn_hash_kmem, GFP_KERNEL);
	if (new_f == NULL)
		goto out;

	new_f->fn_key = key;
	new_f->fn_type = type;
	new_f->fn_scope = r->rtm_scope;
	DN_FIB_INFO(new_f) = fi;

	new_f->fn_next = f;
	write_lock_bh(&dn_fib_tables_lock);
	*fp = new_f;
	write_unlock_bh(&dn_fib_tables_lock);
	dz->dz_nent++;

	if (del_fp) {
		f = *del_fp;
		write_lock_bh(&dn_fib_tables_lock);
		*del_fp = f->fn_next;
		write_unlock_bh(&dn_fib_tables_lock);

		if (!(f->fn_state & DN_S_ZOMBIE))
			dn_rtmsg_fib(RTM_DELROUTE, f, z, tb->n, n, req);
		if (f->fn_state & DN_S_ACCESSED)
			dn_rt_cache_flush(-1);
		dn_free_node(f);
		dz->dz_nent--;
	} else {
		dn_rt_cache_flush(-1);
	}

	dn_rtmsg_fib(RTM_NEWROUTE, new_f, z, tb->n, n, req);

	return 0;
out:
	dn_fib_release_info(fi);
	return err;
}


static int dn_fib_table_delete(struct dn_fib_table *tb, struct rtmsg *r, struct nlattr *attrs[],
			       struct nlmsghdr *n, struct netlink_skb_parms *req)
{
	struct dn_hash *table = (struct dn_hash*)tb->data;
	struct dn_fib_node **fp, **del_fp, *f;
	int z = r->rtm_dst_len;
	struct dn_zone *dz;
	dn_fib_key_t key;
	int matched;


	if (z > 16)
		return -EINVAL;

	if ((dz = table->dh_zones[z]) == NULL)
		return -ESRCH;

	dz_key_0(key);
	if (attrs[RTA_DST]) {
		__le16 dst = nla_get_le16(attrs[RTA_DST]);
		if (dst & ~DZ_MASK(dz))
			return -EINVAL;
		key = dz_key(dst, dz);
	}

	fp = dn_chain_p(key, dz);

	DN_FIB_SCAN(f, fp) {
		if (dn_key_eq(f->fn_key, key))
			break;
		if (dn_key_leq(key, f->fn_key))
			return -ESRCH;
	}

	matched = 0;
	del_fp = NULL;
	DN_FIB_SCAN_KEY(f, fp, key) {
		struct dn_fib_info *fi = DN_FIB_INFO(f);

		if (f->fn_state & DN_S_ZOMBIE)
			return -ESRCH;

		matched++;

		if (del_fp == NULL &&
				(!r->rtm_type || f->fn_type == r->rtm_type) &&
				(r->rtm_scope == RT_SCOPE_NOWHERE || f->fn_scope == r->rtm_scope) &&
				(!r->rtm_protocol ||
					fi->fib_protocol == r->rtm_protocol) &&
				dn_fib_nh_match(r, n, attrs, fi) == 0)
			del_fp = fp;
	}

	if (del_fp) {
		f = *del_fp;
		dn_rtmsg_fib(RTM_DELROUTE, f, z, tb->n, n, req);

		if (matched != 1) {
			write_lock_bh(&dn_fib_tables_lock);
			*del_fp = f->fn_next;
			write_unlock_bh(&dn_fib_tables_lock);

			if (f->fn_state & DN_S_ACCESSED)
				dn_rt_cache_flush(-1);
			dn_free_node(f);
			dz->dz_nent--;
		} else {
			f->fn_state |= DN_S_ZOMBIE;
			if (f->fn_state & DN_S_ACCESSED) {
				f->fn_state &= ~DN_S_ACCESSED;
				dn_rt_cache_flush(-1);
			}
			if (++dn_fib_hash_zombies > 128)
				dn_fib_flush();
		}

		return 0;
	}

	return -ESRCH;
}

static inline int dn_flush_list(struct dn_fib_node **fp, int z, struct dn_hash *table)
{
	int found = 0;
	struct dn_fib_node *f;

	while((f = *fp) != NULL) {
		struct dn_fib_info *fi = DN_FIB_INFO(f);

		if (fi && ((f->fn_state & DN_S_ZOMBIE) || (fi->fib_flags & RTNH_F_DEAD))) {
			write_lock_bh(&dn_fib_tables_lock);
			*fp = f->fn_next;
			write_unlock_bh(&dn_fib_tables_lock);

			dn_free_node(f);
			found++;
			continue;
		}
		fp = &f->fn_next;
	}

	return found;
}

static int dn_fib_table_flush(struct dn_fib_table *tb)
{
	struct dn_hash *table = (struct dn_hash *)tb->data;
	struct dn_zone *dz;
	int found = 0;

	dn_fib_hash_zombies = 0;
	for(dz = table->dh_zone_list; dz; dz = dz->dz_next) {
		int i;
		int tmp = 0;
		for(i = dz->dz_divisor-1; i >= 0; i--)
			tmp += dn_flush_list(&dz->dz_hash[i], dz->dz_order, table);
		dz->dz_nent -= tmp;
		found += tmp;
	}

	return found;
}

static int dn_fib_table_lookup(struct dn_fib_table *tb, const struct flowidn *flp, struct dn_fib_res *res)
{
	int err;
	struct dn_zone *dz;
	struct dn_hash *t = (struct dn_hash *)tb->data;

	read_lock(&dn_fib_tables_lock);
	for(dz = t->dh_zone_list; dz; dz = dz->dz_next) {
		struct dn_fib_node *f;
		dn_fib_key_t k = dz_key(flp->daddr, dz);

		for(f = dz_chain(k, dz); f; f = f->fn_next) {
			if (!dn_key_eq(k, f->fn_key)) {
				if (dn_key_leq(k, f->fn_key))
					break;
				else
					continue;
			}

			f->fn_state |= DN_S_ACCESSED;

			if (f->fn_state&DN_S_ZOMBIE)
				continue;

			if (f->fn_scope < flp->flowidn_scope)
				continue;

			err = dn_fib_semantic_match(f->fn_type, DN_FIB_INFO(f), flp, res);

			if (err == 0) {
				res->type = f->fn_type;
				res->scope = f->fn_scope;
				res->prefixlen = dz->dz_order;
				goto out;
			}
			if (err < 0)
				goto out;
		}
	}
	err = 1;
out:
	read_unlock(&dn_fib_tables_lock);
	return err;
}


struct dn_fib_table *dn_fib_get_table(u32 n, int create)
{
	struct dn_fib_table *t;
	unsigned int h;

	if (n < RT_TABLE_MIN)
		return NULL;

	if (n > RT_TABLE_MAX)
		return NULL;

	h = n & (DN_FIB_TABLE_HASHSZ - 1);
	rcu_read_lock();
	hlist_for_each_entry_rcu(t, &dn_fib_table_hash[h], hlist) {
		if (t->n == n) {
			rcu_read_unlock();
			return t;
		}
	}
	rcu_read_unlock();

	if (!create)
		return NULL;

	if (in_interrupt()) {
		net_dbg_ratelimited(""DECnet: BUG! Attempt to create routing table from interrupt\n"");
		return NULL;
	}

	t = kzalloc(sizeof(struct dn_fib_table) + sizeof(struct dn_hash),
		    GFP_KERNEL);
	if (t == NULL)
		return NULL;

	t->n = n;
	t->insert = dn_fib_table_insert;
	t->delete = dn_fib_table_delete;
	t->lookup = dn_fib_table_lookup;
	t->flush  = dn_fib_table_flush;
	t->dump = dn_fib_table_dump;
	hlist_add_head_rcu(&t->hlist, &dn_fib_table_hash[h]);

	return t;
}

struct dn_fib_table *dn_fib_empty_table(void)
{
	u32 id;

	for(id = RT_TABLE_MIN; id <= RT_TABLE_MAX; id++)
		if (dn_fib_get_table(id, 0) == NULL)
			return dn_fib_get_table(id, 1);
	return NULL;
}

void dn_fib_flush(void)
{
	int flushed = 0;
	struct dn_fib_table *tb;
	unsigned int h;

	for (h = 0; h < DN_FIB_TABLE_HASHSZ; h++) {
		hlist_for_each_entry(tb, &dn_fib_table_hash[h], hlist)
			flushed += tb->flush(tb);
	}

	if (flushed)
		dn_rt_cache_flush(-1);
}

void __init dn_fib_table_init(void)
{
	dn_hash_kmem = kmem_cache_create(""dn_fib_info_cache"",
					sizeof(struct dn_fib_info),
					0, SLAB_HWCACHE_ALIGN,
					NULL);
}

void __exit dn_fib_table_cleanup(void)
{
	struct dn_fib_table *t;
	struct hlist_node *next;
	unsigned int h;

	write_lock(&dn_fib_tables_lock);
	for (h = 0; h < DN_FIB_TABLE_HASHSZ; h++) {
		hlist_for_each_entry_safe(t, next, &dn_fib_table_hash[h],
					  hlist) {
			hlist_del(&t->hlist);
			kfree(t);
		}
	}
	write_unlock(&dn_fib_tables_lock);
}",1202cdd665315c525b5237e96e0bedc76d7e754f,CVE-2023-3338,1202cdd665315c525b5237e96e0bedc76d7e754f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,"  /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR (VAR VAR) * * VAR: VAR VAR <VAR@VAR.VAR> * VAR VAR VAR VAR VAR VAR VAR * * * VAR: * */                           VAR VAR { VAR VAR *VAR; VAR VAR **VAR; VAR VAR; VAR VAR; VAR VAR;  VAR VAR; VAR VAR;  }; VAR VAR { VAR VAR *VAR[17]; VAR VAR *VAR; };   VAR(VAR = 0, VAR = (VAR)->VAR; VAR < (VAR)->VAR; VAR++, VAR++)      VAR( ; ((VAR) = *(VAR)) != VAR; (VAR) = &(VAR)->VAR)  VAR( ; ((VAR) = *(VAR)) != VAR && VAR((VAR)->VAR, (VAR)); (VAR) = &(VAR)->VAR)   VAR VAR VAR VAR[VAR]; VAR VAR(VAR); VAR VAR VAR *VAR VAR; VAR VAR VAR; VAR VAR VAR VAR(VAR VAR, VAR VAR *VAR) { VAR VAR = VAR(VAR.VAR)>>(16 - VAR->VAR); VAR ^= (VAR >> 10); VAR ^= (VAR >> 6); VAR &= VAR(VAR); VAR *(VAR *)&VAR; } VAR VAR VAR VAR(VAR VAR, VAR VAR *VAR) { VAR VAR; VAR.VAR = VAR & VAR(VAR); VAR VAR; } VAR VAR VAR VAR **VAR(VAR VAR, VAR VAR *VAR) { VAR &VAR->VAR[VAR(VAR, VAR).VAR]; } VAR VAR VAR VAR *VAR(VAR VAR, VAR VAR *VAR) { VAR VAR->VAR[VAR(VAR, VAR).VAR]; } VAR VAR VAR VAR(VAR VAR, VAR VAR) { VAR VAR.VAR == VAR.VAR; } VAR VAR VAR VAR(VAR VAR, VAR VAR) { VAR VAR.VAR <= VAR.VAR; } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR **VAR, VAR VAR) { VAR VAR *VAR, **VAR, *VAR; VAR VAR; VAR(VAR = 0; VAR < VAR; VAR++) { VAR(VAR = VAR[VAR]; VAR; VAR = VAR) { VAR = VAR->VAR; VAR(VAR = VAR(VAR->VAR, VAR); *VAR && VAR((*VAR)->VAR, VAR->VAR); VAR = &(*VAR)->VAR) ; VAR->VAR = *VAR; *VAR = VAR; } } } VAR VAR VAR(VAR VAR *VAR) { VAR VAR **VAR, **VAR; VAR VAR, VAR; VAR VAR; VAR = VAR->VAR; VAR (VAR) { VAR 16: VAR = 256; VAR = 0xFF; VAR; VAR: VAR(VAR ""VAR: VAR: VAR! %VAR\VAR"", VAR); VAR; VAR 256: VAR = 1024; VAR = 0x3FF; VAR; } VAR = VAR(VAR, VAR(VAR VAR*), VAR); VAR (VAR == VAR) VAR; VAR(&VAR); VAR = VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR(VAR, VAR, VAR); VAR(&VAR); VAR(VAR); } VAR VAR VAR(VAR VAR *VAR) { VAR(VAR(VAR)); VAR(VAR, VAR); } VAR VAR VAR *VAR(VAR VAR *VAR, VAR VAR) { VAR VAR; VAR VAR *VAR = VAR(VAR(VAR VAR), VAR); VAR (!VAR) VAR VAR; VAR (VAR) { VAR->VAR = 16; VAR->VAR = 0x0F; } VAR { VAR->VAR = 1; VAR->VAR = 0; } VAR->VAR = VAR(VAR->VAR, VAR(VAR VAR *), VAR); VAR (!VAR->VAR) { VAR(VAR); VAR VAR; } VAR->VAR = VAR; VAR->VAR = VAR(VAR); VAR(VAR = VAR + 1; VAR <= 16; VAR++) VAR (VAR->VAR[VAR]) VAR; VAR(&VAR); VAR (VAR>16) { VAR->VAR = VAR->VAR; VAR->VAR = VAR; } VAR { VAR->VAR = VAR->VAR[VAR]->VAR; VAR->VAR[VAR]->VAR = VAR; } VAR->VAR[VAR] = VAR; VAR(&VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR[], VAR VAR *VAR) { VAR VAR *VAR; VAR VAR; VAR (VAR[VAR] && VAR(VAR[VAR]) != VAR->VAR) VAR 1; VAR (VAR[VAR] || VAR[VAR]) { VAR ((!VAR[VAR] || VAR(VAR[VAR]) == VAR->VAR->VAR) && (!VAR[VAR] || VAR(VAR[VAR]) != VAR->VAR->VAR)) VAR 0; VAR 1; } VAR (!VAR[VAR]) VAR 0; VAR = VAR(VAR[VAR]); VAR = VAR(VAR[VAR]); VAR(VAR) { VAR VAR = VAR - VAR(VAR VAR); VAR VAR; VAR (VAR < 0 || (VAR -= VAR->VAR) < 0) VAR -VAR; VAR (VAR->VAR && VAR->VAR != VAR->VAR) VAR 1; VAR (VAR) { VAR VAR *VAR; VAR = VAR((VAR VAR *) (VAR + 1), VAR, VAR); VAR = VAR ? VAR(VAR) : 0; VAR (VAR && VAR != VAR->VAR) VAR 1; } VAR = VAR(VAR); } VAR(VAR); VAR 0; } VAR VAR VAR VAR(VAR VAR *VAR) { VAR VAR = VAR(VAR(VAR VAR)) + VAR(4)  + VAR(2)  + VAR(4)  + VAR(VAR);   VAR += VAR((VAR * VAR(4))); VAR (VAR->VAR) {   VAR VAR = VAR(VAR(VAR VAR));  VAR += VAR(4);  VAR += VAR(VAR->VAR * VAR); } VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR VAR, VAR *VAR, VAR VAR, VAR VAR *VAR, VAR VAR VAR) { VAR VAR *VAR; VAR VAR *VAR; VAR = VAR(VAR, VAR, VAR, VAR, VAR(*VAR), VAR); VAR (!VAR) VAR -VAR; VAR = VAR(VAR); VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = 0; VAR->VAR = 0; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR (VAR(VAR, VAR, VAR) < 0) VAR VAR; VAR (VAR->VAR && VAR(VAR, VAR, 2, VAR) < 0) VAR VAR; VAR (VAR->VAR && VAR(VAR, VAR, VAR->VAR) < 0) VAR VAR; VAR (VAR(VAR, VAR->VAR) < 0) VAR VAR; VAR (VAR->VAR == 1) { VAR (VAR->VAR->VAR && VAR(VAR, VAR, VAR->VAR->VAR) < 0) VAR VAR; VAR (VAR->VAR->VAR && VAR(VAR, VAR, VAR->VAR->VAR) < 0) VAR VAR; } VAR (VAR->VAR > 1) { VAR VAR *VAR; VAR VAR *VAR; VAR = VAR(VAR, VAR); VAR (!VAR) VAR VAR; VAR(VAR) { VAR (!(VAR = VAR(VAR, VAR(*VAR)))) VAR VAR; VAR->VAR = VAR->VAR & 0xFF; VAR->VAR = VAR->VAR - 1; VAR->VAR = VAR->VAR; VAR (VAR->VAR && VAR(VAR, VAR, VAR->VAR) < 0) VAR VAR; VAR->VAR = VAR(VAR) - (VAR VAR *)VAR; } VAR(VAR); VAR(VAR, VAR); } VAR(VAR, VAR); VAR 0; VAR: VAR(VAR, VAR); VAR -VAR; } VAR VAR VAR(VAR VAR, VAR VAR *VAR, VAR VAR, VAR VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR; VAR VAR = VAR ? VAR->VAR : 0; VAR VAR = -VAR; VAR = VAR(VAR(VAR(VAR)), VAR); VAR (VAR == VAR) VAR VAR; VAR = VAR(VAR, VAR, VAR->VAR, VAR, VAR, VAR->VAR, VAR->VAR, &VAR->VAR, VAR, VAR(VAR), 0); VAR (VAR < 0) {  VAR(VAR == -VAR); VAR(VAR); VAR VAR; } VAR(VAR, &VAR, VAR, VAR, VAR, VAR); VAR; VAR: VAR (VAR < 0) VAR(&VAR, VAR, VAR); } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR, VAR; VAR = VAR->VAR[4]; VAR(VAR = 0; VAR; VAR++, VAR = VAR->VAR) { VAR (VAR < VAR) VAR; VAR (VAR->VAR & VAR) VAR; VAR (VAR(VAR, VAR(VAR->VAR).VAR, VAR->VAR->VAR, VAR, VAR->VAR, (VAR->VAR & VAR) ? 0 : VAR->VAR, VAR->VAR, &VAR->VAR, VAR->VAR, VAR->VAR, VAR) < 0) { VAR->VAR[4] = VAR; VAR -1; } } VAR->VAR[4] = VAR; VAR VAR->VAR; } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR, VAR; VAR = VAR->VAR[3]; VAR(VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR < VAR) VAR; VAR (VAR > VAR) VAR(&VAR->VAR[4], 0, VAR(VAR->VAR) - 4*VAR(VAR->VAR[0])); VAR (VAR->VAR == VAR || VAR->VAR[VAR] == VAR) VAR; VAR (VAR(VAR, VAR, VAR, VAR, VAR->VAR[VAR]) < 0) { VAR->VAR[3] = VAR; VAR -1; } } VAR->VAR[3] = VAR; VAR VAR->VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR) { VAR VAR, VAR; VAR VAR *VAR; VAR VAR *VAR = (VAR VAR *)VAR->VAR; VAR = VAR->VAR[2]; VAR(&VAR); VAR(VAR = VAR->VAR, VAR = 0; VAR; VAR = VAR->VAR, VAR++) { VAR (VAR < VAR) VAR; VAR (VAR > VAR) VAR(&VAR->VAR[3], 0, VAR(VAR->VAR) - 3*VAR(VAR->VAR[0])); VAR (VAR(VAR, VAR, VAR, VAR) < 0) { VAR->VAR[2] = VAR; VAR(&VAR); VAR -1; } } VAR(&VAR); VAR->VAR[2] = VAR; VAR VAR->VAR; } VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR VAR, VAR; VAR VAR VAR = 0, VAR; VAR VAR *VAR; VAR VAR = 0; VAR (!VAR(VAR, &VAR)) VAR 0; VAR (VAR(VAR->VAR) >= VAR(VAR VAR) && ((VAR VAR *)VAR(VAR->VAR))->VAR&VAR) VAR VAR(VAR, VAR); VAR = VAR->VAR[0]; VAR = VAR->VAR[1]; VAR (VAR = VAR; VAR < VAR; VAR++, VAR = 0) { VAR = 0; VAR(VAR, &VAR[VAR], VAR) { VAR (VAR < VAR) VAR VAR; VAR (VAR) VAR(&VAR->VAR[2], 0, VAR(VAR->VAR) - 2 * VAR(VAR->VAR[0])); VAR (VAR->VAR(VAR, VAR, VAR) < 0) VAR VAR; VAR = 1; VAR: VAR++; } } VAR: VAR->VAR[1] = VAR; VAR->VAR[0] = VAR; VAR VAR->VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR[], VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = (VAR VAR *)VAR->VAR; VAR VAR *VAR, *VAR, **VAR, **VAR; VAR VAR *VAR; VAR VAR *VAR; VAR VAR = VAR->VAR; VAR VAR = VAR->VAR; VAR VAR; VAR VAR; VAR (VAR > 16) VAR -VAR; VAR = VAR->VAR[VAR]; VAR (!VAR && !(VAR = VAR(VAR, VAR))) VAR -VAR; VAR(VAR); VAR (VAR[VAR]) { VAR VAR = VAR(VAR[VAR]); VAR (VAR & ~VAR(VAR)) VAR -VAR; VAR = VAR(VAR, VAR); } VAR ((VAR = VAR(VAR, VAR, VAR, &VAR)) == VAR) VAR VAR; VAR (VAR->VAR > (VAR->VAR << 2) && VAR->VAR > VAR && (VAR==16 || (1<<VAR) > VAR->VAR)) VAR(VAR); VAR = VAR(VAR, VAR); VAR(VAR, VAR) { VAR (VAR(VAR, VAR->VAR)) VAR; } VAR = VAR; VAR (VAR && (VAR->VAR & VAR) && VAR(VAR->VAR, VAR)) { VAR = VAR; VAR = &VAR->VAR; VAR = *VAR; VAR VAR; } VAR(VAR, VAR, VAR) { VAR (VAR->VAR <= VAR(VAR)->VAR) VAR; } VAR (VAR && VAR(VAR->VAR, VAR) && VAR->VAR == VAR(VAR)->VAR) { VAR VAR **VAR; VAR = -VAR; VAR (VAR->VAR & VAR) VAR VAR; VAR (VAR->VAR & VAR) { VAR = VAR; VAR = &VAR->VAR; VAR = *VAR; VAR VAR; } VAR = VAR; VAR = -VAR; VAR(VAR, VAR, VAR) { VAR (VAR->VAR != VAR(VAR)->VAR) VAR; VAR (VAR->VAR == VAR && VAR->VAR == VAR->VAR && VAR(VAR) == VAR) VAR VAR; } VAR (!(VAR->VAR & VAR)) { VAR = VAR; VAR = *VAR; } } VAR: VAR = -VAR; VAR (!(VAR->VAR & VAR)) VAR VAR; VAR: VAR = -VAR; VAR = VAR(VAR, VAR); VAR (VAR == VAR) VAR VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR(VAR) = VAR; VAR->VAR = VAR; VAR(&VAR); *VAR = VAR; VAR(&VAR); VAR->VAR++; VAR (VAR) { VAR = *VAR; VAR(&VAR); *VAR = VAR->VAR; VAR(&VAR); VAR (!(VAR->VAR & VAR)) VAR(VAR, VAR, VAR, VAR->VAR, VAR, VAR); VAR (VAR->VAR & VAR) VAR(-1); VAR(VAR); VAR->VAR--; } VAR { VAR(-1); } VAR(VAR, VAR, VAR, VAR->VAR, VAR, VAR); VAR 0; VAR: VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR[], VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = (VAR VAR*)VAR->VAR; VAR VAR **VAR, **VAR, *VAR; VAR VAR = VAR->VAR; VAR VAR *VAR; VAR VAR; VAR VAR; VAR (VAR > 16) VAR -VAR; VAR ((VAR = VAR->VAR[VAR]) == VAR) VAR -VAR; VAR(VAR); VAR (VAR[VAR]) { VAR VAR = VAR(VAR[VAR]); VAR (VAR & ~VAR(VAR)) VAR -VAR; VAR = VAR(VAR, VAR); } VAR = VAR(VAR, VAR); VAR(VAR, VAR) { VAR (VAR(VAR->VAR, VAR)) VAR; VAR (VAR(VAR, VAR->VAR)) VAR -VAR; } VAR = 0; VAR = VAR; VAR(VAR, VAR, VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR->VAR & VAR) VAR -VAR; VAR++; VAR (VAR == VAR && (!VAR->VAR || VAR->VAR == VAR->VAR) && (VAR->VAR == VAR || VAR->VAR == VAR->VAR) && (!VAR->VAR || VAR->VAR == VAR->VAR) && VAR(VAR, VAR, VAR, VAR) == 0) VAR = VAR; } VAR (VAR) { VAR = *VAR; VAR(VAR, VAR, VAR, VAR->VAR, VAR, VAR); VAR (VAR != 1) { VAR(&VAR); *VAR = VAR->VAR; VAR(&VAR); VAR (VAR->VAR & VAR) VAR(-1); VAR(VAR); VAR->VAR--; } VAR { VAR->VAR |= VAR; VAR (VAR->VAR & VAR) { VAR->VAR &= ~VAR; VAR(-1); } VAR (++VAR > 128) VAR(); } VAR 0; } VAR -VAR; } VAR VAR VAR VAR(VAR VAR **VAR, VAR VAR, VAR VAR *VAR) { VAR VAR = 0; VAR VAR *VAR; VAR((VAR = *VAR) != VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR && ((VAR->VAR & VAR) || (VAR->VAR & VAR))) { VAR(&VAR); *VAR = VAR->VAR; VAR(&VAR); VAR(VAR); VAR++; VAR; } VAR = &VAR->VAR; } VAR VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = (VAR VAR *)VAR->VAR; VAR VAR *VAR; VAR VAR = 0; VAR = 0; VAR(VAR = VAR->VAR; VAR; VAR = VAR->VAR) { VAR VAR; VAR VAR = 0; VAR(VAR = VAR->VAR-1; VAR >= 0; VAR--) VAR += VAR(&VAR->VAR[VAR], VAR->VAR, VAR); VAR->VAR -= VAR; VAR += VAR; } VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR *VAR) { VAR VAR; VAR VAR *VAR; VAR VAR *VAR = (VAR VAR *)VAR->VAR; VAR(&VAR); VAR(VAR = VAR->VAR; VAR; VAR = VAR->VAR) { VAR VAR *VAR; VAR VAR = VAR(VAR->VAR, VAR); VAR(VAR = VAR(VAR, VAR); VAR; VAR = VAR->VAR) { VAR (!VAR(VAR, VAR->VAR)) { VAR (VAR(VAR, VAR->VAR)) VAR; VAR VAR; } VAR->VAR |= VAR; VAR (VAR->VAR&VAR) VAR; VAR (VAR->VAR < VAR->VAR) VAR; VAR = VAR(VAR->VAR, VAR(VAR), VAR, VAR); VAR (VAR == 0) { VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR VAR; } VAR (VAR < 0) VAR VAR; } } VAR = 1; VAR: VAR(&VAR); VAR VAR; } VAR VAR *VAR(VAR VAR, VAR VAR) { VAR VAR *VAR; VAR VAR VAR; VAR (VAR < VAR) VAR VAR; VAR (VAR > VAR) VAR VAR; VAR = VAR & (VAR - 1); VAR(); VAR(VAR, &VAR[VAR], VAR) { VAR (VAR->VAR == VAR) { VAR(); VAR VAR; } } VAR(); VAR (!VAR) VAR VAR; VAR (VAR()) { VAR(""VAR: VAR! VAR VAR VAR VAR VAR VAR VAR\VAR""); VAR VAR; } VAR = VAR(VAR(VAR VAR) + VAR(VAR VAR), VAR); VAR (VAR == VAR) VAR VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR->VAR = VAR; VAR(&VAR->VAR, &VAR[VAR]); VAR VAR; } VAR VAR *VAR(VAR) { VAR VAR; VAR(VAR = VAR; VAR <= VAR; VAR++) VAR (VAR(VAR, 0) == VAR) VAR VAR(VAR, 1); VAR VAR; } VAR VAR(VAR) { VAR VAR = 0; VAR VAR *VAR; VAR VAR VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR(VAR, &VAR[VAR], VAR) VAR += VAR->VAR(VAR); } VAR (VAR) VAR(-1); } VAR VAR VAR(VAR) { VAR = VAR(""VAR"", VAR(VAR VAR), 0, VAR, VAR); } VAR VAR VAR(VAR) { VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR; VAR(&VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR(VAR, VAR, &VAR[VAR], VAR) { VAR(&VAR->VAR); VAR(VAR); } } VAR(&VAR); }",1,15
linux_265b4da82dbf5df04bee5a5d46b7474b1aaf326a,net/sched/cls_rsvp.h,,"/* SPDX-License-Identifier: GPL-2.0-or-later */
/*
 * net/sched/cls_rsvp.h	Template file for RSVPv[46] classifiers.
 *
 * Authors:	Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
 */

/*
   Comparing to general packet classification problem,
   RSVP needs only several relatively simple rules:

   * (dst, protocol) are always specified,
     so that we are able to hash them.
   * src may be exact, or may be wildcard, so that
     we can keep a hash table plus one wildcard entry.
   * source port (or flow label) is important only if src is given.

   IMPLEMENTATION.

   We use a two level hash table: The top level is keyed by
   destination address and protocol ID, every bucket contains a list
   of ""rsvp sessions"", identified by destination address, protocol and
   DPI(=""Destination Port ID""): triple (key, mask, offset).

   Every bucket has a smaller hash table keyed by source address
   (cf. RSVP flowspec) and one wildcard entry for wildcard reservations.
   Every bucket is again a list of ""RSVP flows"", selected by
   source address and SPI(=""Source Port ID"" here rather than
   ""security parameter index""): triple (key, mask, offset).


   NOTE 1. All the packets with IPv6 extension headers (but AH and ESP)
   and all fragmented packets go to the best-effort traffic class.


   NOTE 2. Two ""port id""'s seems to be redundant, rfc2207 requires
   only one ""Generalized Port Identifier"". So that for classic
   ah, esp (and udp,tcp) both *pi should coincide or one of them
   should be wildcard.

   At first sight, this redundancy is just a waste of CPU
   resources. But DPI and SPI add the possibility to assign different
   priorities to GPIs. Look also at note 4 about tunnels below.


   NOTE 3. One complication is the case of tunneled packets.
   We implement it as following: if the first lookup
   matches a special session with ""tunnelhdr"" value not zero,
   flowid doesn't contain the true flow ID, but the tunnel ID (1...255).
   In this case, we pull tunnelhdr bytes and restart lookup
   with tunnel ID added to the list of keys. Simple and stupid 8)8)
   It's enough for PIMREG and IPIP.


   NOTE 4. Two GPIs make it possible to parse even GRE packets.
   F.e. DPI can select ETH_P_IP (and necessary flags to make
   tunnelhdr correct) in GRE protocol field and SPI matches
   GRE key. Is it not nice? 8)8)


   Well, as result, despite its simplicity, we get a pretty
   powerful classification engine.  */


struct rsvp_head {
	u32			tmap[256/32];
	u32			hgenerator;
	u8			tgenerator;
	struct rsvp_session __rcu *ht[256];
	struct rcu_head		rcu;
};

struct rsvp_session {
	struct rsvp_session __rcu	*next;
	__be32				dst[RSVP_DST_LEN];
	struct tc_rsvp_gpi		dpi;
	u8				protocol;
	u8				tunnelid;
	/* 16 (src,sport) hash slots, and one wildcard source slot */
	struct rsvp_filter __rcu	*ht[16 + 1];
	struct rcu_head			rcu;
};


struct rsvp_filter {
	struct rsvp_filter __rcu	*next;
	__be32				src[RSVP_DST_LEN];
	struct tc_rsvp_gpi		spi;
	u8				tunnelhdr;

	struct tcf_result		res;
	struct tcf_exts			exts;

	u32				handle;
	struct rsvp_session		*sess;
	struct rcu_work			rwork;
};

static inline unsigned int hash_dst(__be32 *dst, u8 protocol, u8 tunnelid)
{
	unsigned int h = (__force __u32)dst[RSVP_DST_LEN - 1];

	h ^= h>>16;
	h ^= h>>8;
	return (h ^ protocol ^ tunnelid) & 0xFF;
}

static inline unsigned int hash_src(__be32 *src)
{
	unsigned int h = (__force __u32)src[RSVP_DST_LEN-1];

	h ^= h>>16;
	h ^= h>>8;
	h ^= h>>4;
	return h & 0xF;
}

#define RSVP_APPLY_RESULT()				\
{							\
	int r = tcf_exts_exec(skb, &f->exts, res);	\
	if (r < 0)					\
		continue;				\
	else if (r > 0)					\
		return r;				\
}

TC_INDIRECT_SCOPE int RSVP_CLS(struct sk_buff *skb, const struct tcf_proto *tp,
			       struct tcf_result *res)
{
	struct rsvp_head *head = rcu_dereference_bh(tp->root);
	struct rsvp_session *s;
	struct rsvp_filter *f;
	unsigned int h1, h2;
	__be32 *dst, *src;
	u8 protocol;
	u8 tunnelid = 0;
	u8 *xprt;
#if RSVP_DST_LEN == 4
	struct ipv6hdr *nhptr;

	if (!pskb_network_may_pull(skb, sizeof(*nhptr)))
		return -1;
	nhptr = ipv6_hdr(skb);
#else
	struct iphdr *nhptr;

	if (!pskb_network_may_pull(skb, sizeof(*nhptr)))
		return -1;
	nhptr = ip_hdr(skb);
#endif
restart:

#if RSVP_DST_LEN == 4
	src = &nhptr->saddr.s6_addr32[0];
	dst = &nhptr->daddr.s6_addr32[0];
	protocol = nhptr->nexthdr;
	xprt = ((u8 *)nhptr) + sizeof(struct ipv6hdr);
#else
	src = &nhptr->saddr;
	dst = &nhptr->daddr;
	protocol = nhptr->protocol;
	xprt = ((u8 *)nhptr) + (nhptr->ihl<<2);
	if (ip_is_fragment(nhptr))
		return -1;
#endif

	h1 = hash_dst(dst, protocol, tunnelid);
	h2 = hash_src(src);

	for (s = rcu_dereference_bh(head->ht[h1]); s;
	     s = rcu_dereference_bh(s->next)) {
		if (dst[RSVP_DST_LEN-1] == s->dst[RSVP_DST_LEN - 1] &&
		    protocol == s->protocol &&
		    !(s->dpi.mask &
		      (*(u32 *)(xprt + s->dpi.offset) ^ s->dpi.key)) &&
#if RSVP_DST_LEN == 4
		    dst[0] == s->dst[0] &&
		    dst[1] == s->dst[1] &&
		    dst[2] == s->dst[2] &&
#endif
		    tunnelid == s->tunnelid) {

			for (f = rcu_dereference_bh(s->ht[h2]); f;
			     f = rcu_dereference_bh(f->next)) {
				if (src[RSVP_DST_LEN-1] == f->src[RSVP_DST_LEN - 1] &&
				    !(f->spi.mask & (*(u32 *)(xprt + f->spi.offset) ^ f->spi.key))
#if RSVP_DST_LEN == 4
				    &&
				    src[0] == f->src[0] &&
				    src[1] == f->src[1] &&
				    src[2] == f->src[2]
#endif
				    ) {
					*res = f->res;
					RSVP_APPLY_RESULT();

matched:
					if (f->tunnelhdr == 0)
						return 0;

					tunnelid = f->res.classid;
					nhptr = (void *)(xprt + f->tunnelhdr - sizeof(*nhptr));
					goto restart;
				}
			}

			/* And wildcard bucket... */
			for (f = rcu_dereference_bh(s->ht[16]); f;
			     f = rcu_dereference_bh(f->next)) {
				*res = f->res;
				RSVP_APPLY_RESULT();
				goto matched;
			}
			return -1;
		}
	}
	return -1;
}

static void rsvp_replace(struct tcf_proto *tp, struct rsvp_filter *n, u32 h)
{
	struct rsvp_head *head = rtnl_dereference(tp->root);
	struct rsvp_session *s;
	struct rsvp_filter __rcu **ins;
	struct rsvp_filter *pins;
	unsigned int h1 = h & 0xFF;
	unsigned int h2 = (h >> 8) & 0xFF;

	for (s = rtnl_dereference(head->ht[h1]); s;
	     s = rtnl_dereference(s->next)) {
		for (ins = &s->ht[h2], pins = rtnl_dereference(*ins); ;
		     ins = &pins->next, pins = rtnl_dereference(*ins)) {
			if (pins->handle == h) {
				RCU_INIT_POINTER(n->next, pins->next);
				rcu_assign_pointer(*ins, n);
				return;
			}
		}
	}

	/* Something went wrong if we are trying to replace a non-existent
	 * node. Mind as well halt instead of silently failing.
	 */
	BUG_ON(1);
}

static void *rsvp_get(struct tcf_proto *tp, u32 handle)
{
	struct rsvp_head *head = rtnl_dereference(tp->root);
	struct rsvp_session *s;
	struct rsvp_filter *f;
	unsigned int h1 = handle & 0xFF;
	unsigned int h2 = (handle >> 8) & 0xFF;

	if (h2 > 16)
		return NULL;

	for (s = rtnl_dereference(head->ht[h1]); s;
	     s = rtnl_dereference(s->next)) {
		for (f = rtnl_dereference(s->ht[h2]); f;
		     f = rtnl_dereference(f->next)) {
			if (f->handle == handle)
				return f;
		}
	}
	return NULL;
}

static int rsvp_init(struct tcf_proto *tp)
{
	struct rsvp_head *data;

	data = kzalloc(sizeof(struct rsvp_head), GFP_KERNEL);
	if (data) {
		rcu_assign_pointer(tp->root, data);
		return 0;
	}
	return -ENOBUFS;
}

static void __rsvp_delete_filter(struct rsvp_filter *f)
{
	tcf_exts_destroy(&f->exts);
	tcf_exts_put_net(&f->exts);
	kfree(f);
}

static void rsvp_delete_filter_work(struct work_struct *work)
{
	struct rsvp_filter *f = container_of(to_rcu_work(work),
					     struct rsvp_filter,
					     rwork);
	rtnl_lock();
	__rsvp_delete_filter(f);
	rtnl_unlock();
}

static void rsvp_delete_filter(struct tcf_proto *tp, struct rsvp_filter *f)
{
	tcf_unbind_filter(tp, &f->res);
	/* all classifiers are required to call tcf_exts_destroy() after rcu
	 * grace period, since converted-to-rcu actions are relying on that
	 * in cleanup() callback
	 */
	if (tcf_exts_get_net(&f->exts))
		tcf_queue_work(&f->rwork, rsvp_delete_filter_work);
	else
		__rsvp_delete_filter(f);
}

static void rsvp_destroy(struct tcf_proto *tp, bool rtnl_held,
			 struct netlink_ext_ack *extack)
{
	struct rsvp_head *data = rtnl_dereference(tp->root);
	int h1, h2;

	if (data == NULL)
		return;

	for (h1 = 0; h1 < 256; h1++) {
		struct rsvp_session *s;

		while ((s = rtnl_dereference(data->ht[h1])) != NULL) {
			RCU_INIT_POINTER(data->ht[h1], s->next);

			for (h2 = 0; h2 <= 16; h2++) {
				struct rsvp_filter *f;

				while ((f = rtnl_dereference(s->ht[h2])) != NULL) {
					rcu_assign_pointer(s->ht[h2], f->next);
					rsvp_delete_filter(tp, f);
				}
			}
			kfree_rcu(s, rcu);
		}
	}
	kfree_rcu(data, rcu);
}

static int rsvp_delete(struct tcf_proto *tp, void *arg, bool *last,
		       bool rtnl_held, struct netlink_ext_ack *extack)
{
	struct rsvp_head *head = rtnl_dereference(tp->root);
	struct rsvp_filter *nfp, *f = arg;
	struct rsvp_filter __rcu **fp;
	unsigned int h = f->handle;
	struct rsvp_session __rcu **sp;
	struct rsvp_session *nsp, *s = f->sess;
	int i, h1;

	fp = &s->ht[(h >> 8) & 0xFF];
	for (nfp = rtnl_dereference(*fp); nfp;
	     fp = &nfp->next, nfp = rtnl_dereference(*fp)) {
		if (nfp == f) {
			RCU_INIT_POINTER(*fp, f->next);
			rsvp_delete_filter(tp, f);

			/* Strip tree */

			for (i = 0; i <= 16; i++)
				if (s->ht[i])
					goto out;

			/* OK, session has no flows */
			sp = &head->ht[h & 0xFF];
			for (nsp = rtnl_dereference(*sp); nsp;
			     sp = &nsp->next, nsp = rtnl_dereference(*sp)) {
				if (nsp == s) {
					RCU_INIT_POINTER(*sp, s->next);
					kfree_rcu(s, rcu);
					goto out;
				}
			}

			break;
		}
	}

out:
	*last = true;
	for (h1 = 0; h1 < 256; h1++) {
		if (rcu_access_pointer(head->ht[h1])) {
			*last = false;
			break;
		}
	}

	return 0;
}

static unsigned int gen_handle(struct tcf_proto *tp, unsigned salt)
{
	struct rsvp_head *data = rtnl_dereference(tp->root);
	int i = 0xFFFF;

	while (i-- > 0) {
		u32 h;

		if ((data->hgenerator += 0x10000) == 0)
			data->hgenerator = 0x10000;
		h = data->hgenerator|salt;
		if (!rsvp_get(tp, h))
			return h;
	}
	return 0;
}

static int tunnel_bts(struct rsvp_head *data)
{
	int n = data->tgenerator >> 5;
	u32 b = 1 << (data->tgenerator & 0x1F);

	if (data->tmap[n] & b)
		return 0;
	data->tmap[n] |= b;
	return 1;
}

static void tunnel_recycle(struct rsvp_head *data)
{
	struct rsvp_session __rcu **sht = data->ht;
	u32 tmap[256/32];
	int h1, h2;

	memset(tmap, 0, sizeof(tmap));

	for (h1 = 0; h1 < 256; h1++) {
		struct rsvp_session *s;
		for (s = rtnl_dereference(sht[h1]); s;
		     s = rtnl_dereference(s->next)) {
			for (h2 = 0; h2 <= 16; h2++) {
				struct rsvp_filter *f;

				for (f = rtnl_dereference(s->ht[h2]); f;
				     f = rtnl_dereference(f->next)) {
					if (f->tunnelhdr == 0)
						continue;
					data->tgenerator = f->res.classid;
					tunnel_bts(data);
				}
			}
		}
	}

	memcpy(data->tmap, tmap, sizeof(tmap));
}

static u32 gen_tunnel(struct rsvp_head *data)
{
	int i, k;

	for (k = 0; k < 2; k++) {
		for (i = 255; i > 0; i--) {
			if (++data->tgenerator == 0)
				data->tgenerator = 1;
			if (tunnel_bts(data))
				return data->tgenerator;
		}
		tunnel_recycle(data);
	}
	return 0;
}

static const struct nla_policy rsvp_policy[TCA_RSVP_MAX + 1] = {
	[TCA_RSVP_CLASSID]	= { .type = NLA_U32 },
	[TCA_RSVP_DST]		= { .len = RSVP_DST_LEN * sizeof(u32) },
	[TCA_RSVP_SRC]		= { .len = RSVP_DST_LEN * sizeof(u32) },
	[TCA_RSVP_PINFO]	= { .len = sizeof(struct tc_rsvp_pinfo) },
};

static int rsvp_change(struct net *net, struct sk_buff *in_skb,
		       struct tcf_proto *tp, unsigned long base,
		       u32 handle, struct nlattr **tca,
		       void **arg, u32 flags,
		       struct netlink_ext_ack *extack)
{
	struct rsvp_head *data = rtnl_dereference(tp->root);
	struct rsvp_filter *f, *nfp;
	struct rsvp_filter __rcu **fp;
	struct rsvp_session *nsp, *s;
	struct rsvp_session __rcu **sp;
	struct tc_rsvp_pinfo *pinfo = NULL;
	struct nlattr *opt = tca[TCA_OPTIONS];
	struct nlattr *tb[TCA_RSVP_MAX + 1];
	struct tcf_exts e;
	unsigned int h1, h2;
	__be32 *dst;
	int err;

	if (opt == NULL)
		return handle ? -EINVAL : 0;

	err = nla_parse_nested_deprecated(tb, TCA_RSVP_MAX, opt, rsvp_policy,
					  NULL);
	if (err < 0)
		return err;

	err = tcf_exts_init(&e, net, TCA_RSVP_ACT, TCA_RSVP_POLICE);
	if (err < 0)
		return err;
	err = tcf_exts_validate(net, tp, tb, tca[TCA_RATE], &e, flags,
				extack);
	if (err < 0)
		goto errout2;

	f = *arg;
	if (f) {
		/* Node exists: adjust only classid */
		struct rsvp_filter *n;

		if (f->handle != handle && handle)
			goto errout2;

		n = kmemdup(f, sizeof(*f), GFP_KERNEL);
		if (!n) {
			err = -ENOMEM;
			goto errout2;
		}

		err = tcf_exts_init(&n->exts, net, TCA_RSVP_ACT,
				    TCA_RSVP_POLICE);
		if (err < 0) {
			kfree(n);
			goto errout2;
		}

		if (tb[TCA_RSVP_CLASSID]) {
			n->res.classid = nla_get_u32(tb[TCA_RSVP_CLASSID]);
			tcf_bind_filter(tp, &n->res, base);
		}

		tcf_exts_change(&n->exts, &e);
		rsvp_replace(tp, n, handle);
		return 0;
	}

	/* Now more serious part... */
	err = -EINVAL;
	if (handle)
		goto errout2;
	if (tb[TCA_RSVP_DST] == NULL)
		goto errout2;

	err = -ENOBUFS;
	f = kzalloc(sizeof(struct rsvp_filter), GFP_KERNEL);
	if (f == NULL)
		goto errout2;

	err = tcf_exts_init(&f->exts, net, TCA_RSVP_ACT, TCA_RSVP_POLICE);
	if (err < 0)
		goto errout;
	h2 = 16;
	if (tb[TCA_RSVP_SRC]) {
		memcpy(f->src, nla_data(tb[TCA_RSVP_SRC]), sizeof(f->src));
		h2 = hash_src(f->src);
	}
	if (tb[TCA_RSVP_PINFO]) {
		pinfo = nla_data(tb[TCA_RSVP_PINFO]);
		f->spi = pinfo->spi;
		f->tunnelhdr = pinfo->tunnelhdr;
	}
	if (tb[TCA_RSVP_CLASSID])
		f->res.classid = nla_get_u32(tb[TCA_RSVP_CLASSID]);

	dst = nla_data(tb[TCA_RSVP_DST]);
	h1 = hash_dst(dst, pinfo ? pinfo->protocol : 0, pinfo ? pinfo->tunnelid : 0);

	err = -ENOMEM;
	if ((f->handle = gen_handle(tp, h1 | (h2<<8))) == 0)
		goto errout;

	if (f->tunnelhdr) {
		err = -EINVAL;
		if (f->res.classid > 255)
			goto errout;

		err = -ENOMEM;
		if (f->res.classid == 0 &&
		    (f->res.classid = gen_tunnel(data)) == 0)
			goto errout;
	}

	for (sp = &data->ht[h1];
	     (s = rtnl_dereference(*sp)) != NULL;
	     sp = &s->next) {
		if (dst[RSVP_DST_LEN-1] == s->dst[RSVP_DST_LEN-1] &&
		    pinfo && pinfo->protocol == s->protocol &&
		    memcmp(&pinfo->dpi, &s->dpi, sizeof(s->dpi)) == 0 &&
#if RSVP_DST_LEN == 4
		    dst[0] == s->dst[0] &&
		    dst[1] == s->dst[1] &&
		    dst[2] == s->dst[2] &&
#endif
		    pinfo->tunnelid == s->tunnelid) {

insert:
			/* OK, we found appropriate session */

			fp = &s->ht[h2];

			f->sess = s;
			if (f->tunnelhdr == 0)
				tcf_bind_filter(tp, &f->res, base);

			tcf_exts_change(&f->exts, &e);

			fp = &s->ht[h2];
			for (nfp = rtnl_dereference(*fp); nfp;
			     fp = &nfp->next, nfp = rtnl_dereference(*fp)) {
				__u32 mask = nfp->spi.mask & f->spi.mask;

				if (mask != f->spi.mask)
					break;
			}
			RCU_INIT_POINTER(f->next, nfp);
			rcu_assign_pointer(*fp, f);

			*arg = f;
			return 0;
		}
	}

	/* No session found. Create new one. */

	err = -ENOBUFS;
	s = kzalloc(sizeof(struct rsvp_session), GFP_KERNEL);
	if (s == NULL)
		goto errout;
	memcpy(s->dst, dst, sizeof(s->dst));

	if (pinfo) {
		s->dpi = pinfo->dpi;
		s->protocol = pinfo->protocol;
		s->tunnelid = pinfo->tunnelid;
	}
	sp = &data->ht[h1];
	for (nsp = rtnl_dereference(*sp); nsp;
	     sp = &nsp->next, nsp = rtnl_dereference(*sp)) {
		if ((nsp->dpi.mask & s->dpi.mask) != s->dpi.mask)
			break;
	}
	RCU_INIT_POINTER(s->next, nsp);
	rcu_assign_pointer(*sp, s);

	goto insert;

errout:
	tcf_exts_destroy(&f->exts);
	kfree(f);
errout2:
	tcf_exts_destroy(&e);
	return err;
}

static void rsvp_walk(struct tcf_proto *tp, struct tcf_walker *arg,
		      bool rtnl_held)
{
	struct rsvp_head *head = rtnl_dereference(tp->root);
	unsigned int h, h1;

	if (arg->stop)
		return;

	for (h = 0; h < 256; h++) {
		struct rsvp_session *s;

		for (s = rtnl_dereference(head->ht[h]); s;
		     s = rtnl_dereference(s->next)) {
			for (h1 = 0; h1 <= 16; h1++) {
				struct rsvp_filter *f;

				for (f = rtnl_dereference(s->ht[h1]); f;
				     f = rtnl_dereference(f->next)) {
					if (!tc_cls_stats_dump(tp, arg, f))
						return;
				}
			}
		}
	}
}

static int rsvp_dump(struct net *net, struct tcf_proto *tp, void *fh,
		     struct sk_buff *skb, struct tcmsg *t, bool rtnl_held)
{
	struct rsvp_filter *f = fh;
	struct rsvp_session *s;
	struct nlattr *nest;
	struct tc_rsvp_pinfo pinfo;

	if (f == NULL)
		return skb->len;
	s = f->sess;

	t->tcm_handle = f->handle;

	nest = nla_nest_start_noflag(skb, TCA_OPTIONS);
	if (nest == NULL)
		goto nla_put_failure;

	if (nla_put(skb, TCA_RSVP_DST, sizeof(s->dst), &s->dst))
		goto nla_put_failure;
	pinfo.dpi = s->dpi;
	pinfo.spi = f->spi;
	pinfo.protocol = s->protocol;
	pinfo.tunnelid = s->tunnelid;
	pinfo.tunnelhdr = f->tunnelhdr;
	pinfo.pad = 0;
	if (nla_put(skb, TCA_RSVP_PINFO, sizeof(pinfo), &pinfo))
		goto nla_put_failure;
	if (f->res.classid &&
	    nla_put_u32(skb, TCA_RSVP_CLASSID, f->res.classid))
		goto nla_put_failure;
	if (((f->handle >> 8) & 0xFF) != 16 &&
	    nla_put(skb, TCA_RSVP_SRC, sizeof(f->src), f->src))
		goto nla_put_failure;

	if (tcf_exts_dump(skb, &f->exts) < 0)
		goto nla_put_failure;

	nla_nest_end(skb, nest);

	if (tcf_exts_dump_stats(skb, &f->exts) < 0)
		goto nla_put_failure;
	return skb->len;

nla_put_failure:
	nla_nest_cancel(skb, nest);
	return -1;
}

static void rsvp_bind_class(void *fh, u32 classid, unsigned long cl, void *q,
			    unsigned long base)
{
	struct rsvp_filter *f = fh;

	tc_cls_bind_class(classid, cl, q, &f->res, base);
}

static struct tcf_proto_ops RSVP_OPS __read_mostly = {
	.kind		=	RSVP_ID,
	.classify	=	RSVP_CLS,
	.init		=	rsvp_init,
	.destroy	=	rsvp_destroy,
	.get		=	rsvp_get,
	.change		=	rsvp_change,
	.delete		=	rsvp_delete,
	.walk		=	rsvp_walk,
	.dump		=	rsvp_dump,
	.bind_class	=	rsvp_bind_class,
	.owner		=	THIS_MODULE,
};

static int __init init_rsvp(void)
{
	return register_tcf_proto_ops(&RSVP_OPS);
}

static void __exit exit_rsvp(void)
{
	unregister_tcf_proto_ops(&RSVP_OPS);
}

module_init(init_rsvp)
module_exit(exit_rsvp)",265b4da82dbf5df04bee5a5d46b7474b1aaf326a,CVE-2023-42755,265b4da82dbf5df04bee5a5d46b7474b1aaf326a,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,"  /* * VAR/VAR/VAR.VAR VAR VAR VAR VAR[46] VAR. * * VAR: VAR VAR, <VAR@VAR.VAR.VAR.VAR> */ /* VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR: * (VAR, VAR) VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR (VAR VAR VAR) VAR VAR VAR VAR VAR VAR VAR. VAR. VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR ""VAR VAR"", VAR VAR VAR VAR, VAR VAR VAR(=""VAR VAR VAR""): VAR (VAR, VAR, VAR). VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR. VAR VAR) VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR ""VAR VAR"", VAR VAR VAR VAR VAR VAR(=""VAR VAR VAR"" VAR VAR VAR ""VAR VAR VAR""): VAR (VAR, VAR, VAR). VAR 1. VAR VAR VAR VAR VAR VAR VAR (VAR VAR VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR. VAR 2. VAR ""VAR VAR""'VAR VAR VAR VAR VAR, VAR VAR VAR VAR ""VAR VAR VAR"". VAR VAR VAR VAR VAR, VAR (VAR VAR,VAR) VAR *VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR 4 VAR VAR VAR. VAR 3. VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR ""VAR"" VAR VAR VAR, VAR VAR'VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR (1...255). VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR 8)8) VAR'VAR VAR VAR VAR VAR VAR. VAR 4. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR.VAR. VAR VAR VAR VAR (VAR VAR VAR VAR VAR VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR? 8)8) VAR, VAR VAR, VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR. */ VAR VAR { VAR VAR[256/32]; VAR VAR; VAR VAR; VAR VAR VAR *VAR[256]; VAR VAR VAR; }; VAR VAR { VAR VAR VAR *VAR; VAR VAR[VAR]; VAR VAR VAR; VAR VAR; VAR VAR;  VAR VAR VAR *VAR[16 + 1]; VAR VAR VAR; }; VAR VAR { VAR VAR VAR *VAR; VAR VAR[VAR]; VAR VAR VAR; VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR; VAR VAR *VAR; VAR VAR VAR; }; VAR VAR VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR) { VAR VAR VAR = (VAR VAR)VAR[VAR - 1]; VAR ^= VAR>>16; VAR ^= VAR>>8; VAR (VAR ^ VAR ^ VAR) & 0xFF; } VAR VAR VAR VAR VAR(VAR *VAR) { VAR VAR VAR = (VAR VAR)VAR[VAR-1]; VAR ^= VAR>>16; VAR ^= VAR>>8; VAR ^= VAR>>4; VAR VAR & 0xF; }  { \ VAR VAR = VAR(VAR, &VAR->VAR, VAR); \ VAR (VAR < 0) \ VAR; \ VAR VAR (VAR > 0) \ VAR VAR; \ } VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR *VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR, VAR; VAR *VAR, *VAR; VAR VAR; VAR VAR = 0; VAR *VAR;  VAR VAR *VAR; VAR (!VAR(VAR, VAR(*VAR))) VAR -1; VAR = VAR(VAR);  VAR VAR *VAR; VAR (!VAR(VAR, VAR(*VAR))) VAR -1; VAR = VAR(VAR);  VAR:  VAR = &VAR->VAR.VAR[0]; VAR = &VAR->VAR.VAR[0]; VAR = VAR->VAR; VAR = ((VAR *)VAR) + VAR(VAR VAR);  VAR = &VAR->VAR; VAR = &VAR->VAR; VAR = VAR->VAR; VAR = ((VAR *)VAR) + (VAR->VAR<<2); VAR (VAR(VAR)) VAR -1;  VAR = VAR(VAR, VAR, VAR); VAR = VAR(VAR); VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR[VAR-1] == VAR->VAR[VAR - 1] && VAR == VAR->VAR && !(VAR->VAR.VAR & (*(VAR *)(VAR + VAR->VAR.VAR) ^ VAR->VAR.VAR)) &&  VAR[0] == VAR->VAR[0] && VAR[1] == VAR->VAR[1] && VAR[2] == VAR->VAR[2] &&  VAR == VAR->VAR) { VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR[VAR-1] == VAR->VAR[VAR - 1] && !(VAR->VAR.VAR & (*(VAR *)(VAR + VAR->VAR.VAR) ^ VAR->VAR.VAR))  && VAR[0] == VAR->VAR[0] && VAR[1] == VAR->VAR[1] && VAR[2] == VAR->VAR[2]  ) { *VAR = VAR->VAR; VAR(); VAR: VAR (VAR->VAR == 0) VAR 0; VAR = VAR->VAR.VAR; VAR = (VAR *)(VAR + VAR->VAR - VAR(*VAR)); VAR VAR; } }  VAR (VAR = VAR(VAR->VAR[16]); VAR; VAR = VAR(VAR->VAR)) { *VAR = VAR->VAR; VAR(); VAR VAR; } VAR -1; } } VAR -1; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR; VAR VAR VAR **VAR; VAR VAR *VAR; VAR VAR VAR = VAR & 0xFF; VAR VAR VAR = (VAR >> 8) & 0xFF; VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR = &VAR->VAR[VAR], VAR = VAR(*VAR); ; VAR = &VAR->VAR, VAR = VAR(*VAR)) { VAR (VAR->VAR == VAR) { VAR(VAR->VAR, VAR->VAR); VAR(*VAR, VAR); VAR; } } } /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR * VAR. VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR(1); } VAR VAR *VAR(VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR = VAR & 0xFF; VAR VAR VAR = (VAR >> 8) & 0xFF; VAR (VAR > 16) VAR VAR; VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR->VAR == VAR) VAR VAR; } } VAR VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR; VAR = VAR(VAR(VAR VAR), VAR); VAR (VAR) { VAR(VAR->VAR, VAR); VAR 0; } VAR -VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(VAR); } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR(VAR), VAR VAR, VAR); VAR(); VAR(VAR); VAR(); } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR) { VAR(VAR, &VAR->VAR); /* VAR VAR VAR VAR VAR VAR VAR() VAR VAR * VAR VAR, VAR VAR-VAR-VAR VAR VAR VAR VAR VAR * VAR VAR() VAR */ VAR (VAR(&VAR->VAR)) VAR(&VAR->VAR, VAR); VAR VAR(VAR); } VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR, VAR; VAR (VAR == VAR) VAR; VAR (VAR = 0; VAR < 256; VAR++) { VAR VAR *VAR; VAR ((VAR = VAR(VAR->VAR[VAR])) != VAR) { VAR(VAR->VAR[VAR], VAR->VAR); VAR (VAR = 0; VAR <= 16; VAR++) { VAR VAR *VAR; VAR ((VAR = VAR(VAR->VAR[VAR])) != VAR) { VAR(VAR->VAR[VAR], VAR->VAR); VAR(VAR, VAR); } } VAR(VAR, VAR); } } VAR(VAR, VAR); } VAR VAR VAR(VAR VAR *VAR, VAR *VAR, VAR *VAR, VAR VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR, *VAR = VAR; VAR VAR VAR **VAR; VAR VAR VAR = VAR->VAR; VAR VAR VAR **VAR; VAR VAR *VAR, *VAR = VAR->VAR; VAR VAR, VAR; VAR = &VAR->VAR[(VAR >> 8) & 0xFF]; VAR (VAR = VAR(*VAR); VAR; VAR = &VAR->VAR, VAR = VAR(*VAR)) { VAR (VAR == VAR) { VAR(*VAR, VAR->VAR); VAR(VAR, VAR);  VAR (VAR = 0; VAR <= 16; VAR++) VAR (VAR->VAR[VAR]) VAR VAR;  VAR = &VAR->VAR[VAR & 0xFF]; VAR (VAR = VAR(*VAR); VAR; VAR = &VAR->VAR, VAR = VAR(*VAR)) { VAR (VAR == VAR) { VAR(*VAR, VAR->VAR); VAR(VAR, VAR); VAR VAR; } } VAR; } } VAR: *VAR = VAR; VAR (VAR = 0; VAR < 256; VAR++) { VAR (VAR(VAR->VAR[VAR])) { *VAR = VAR; VAR; } } VAR 0; } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR = 0xFFFF; VAR (VAR-- > 0) { VAR VAR; VAR ((VAR->VAR += 0x10000) == 0) VAR->VAR = 0x10000; VAR = VAR->VAR|VAR; VAR (!VAR(VAR, VAR)) VAR VAR; } VAR 0; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR = VAR->VAR >> 5; VAR VAR = 1 << (VAR->VAR & 0x1F); VAR (VAR->VAR[VAR] & VAR) VAR 0; VAR->VAR[VAR] |= VAR; VAR 1; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR VAR **VAR = VAR->VAR; VAR VAR[256/32]; VAR VAR, VAR; VAR(VAR, 0, VAR(VAR)); VAR (VAR = 0; VAR < 256; VAR++) { VAR VAR *VAR; VAR (VAR = VAR(VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR = 0; VAR <= 16; VAR++) { VAR VAR *VAR; VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR->VAR == 0) VAR; VAR->VAR = VAR->VAR.VAR; VAR(VAR); } } } } VAR(VAR->VAR, VAR, VAR(VAR)); } VAR VAR VAR(VAR VAR *VAR) { VAR VAR, VAR; VAR (VAR = 0; VAR < 2; VAR++) { VAR (VAR = 255; VAR > 0; VAR--) { VAR (++VAR->VAR == 0) VAR->VAR = 1; VAR (VAR(VAR)) VAR VAR->VAR; } VAR(VAR); } VAR 0; } VAR VAR VAR VAR VAR[VAR + 1] = { [VAR] = { .VAR = VAR }, [VAR] = { .VAR = VAR * VAR(VAR) }, [VAR] = { .VAR = VAR * VAR(VAR) }, [VAR] = { .VAR = VAR(VAR VAR) }, }; VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR VAR, VAR VAR, VAR VAR **VAR, VAR **VAR, VAR VAR, VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR *VAR, *VAR; VAR VAR VAR **VAR; VAR VAR *VAR, *VAR; VAR VAR VAR **VAR; VAR VAR *VAR = VAR; VAR VAR *VAR = VAR[VAR]; VAR VAR *VAR[VAR + 1]; VAR VAR VAR; VAR VAR VAR, VAR; VAR *VAR; VAR VAR; VAR (VAR == VAR) VAR VAR ? -VAR : 0; VAR = VAR(VAR, VAR, VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(&VAR, VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR, VAR, VAR, VAR[VAR], &VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = *VAR; VAR (VAR) {  VAR VAR *VAR; VAR (VAR->VAR != VAR && VAR) VAR VAR; VAR = VAR(VAR, VAR(*VAR), VAR); VAR (!VAR) { VAR = -VAR; VAR VAR; } VAR = VAR(&VAR->VAR, VAR, VAR, VAR); VAR (VAR < 0) { VAR(VAR); VAR VAR; } VAR (VAR[VAR]) { VAR->VAR.VAR = VAR(VAR[VAR]); VAR(VAR, &VAR->VAR, VAR); } VAR(&VAR->VAR, &VAR); VAR(VAR, VAR, VAR); VAR 0; }  VAR = -VAR; VAR (VAR) VAR VAR; VAR (VAR[VAR] == VAR) VAR VAR; VAR = -VAR; VAR = VAR(VAR(VAR VAR), VAR); VAR (VAR == VAR) VAR VAR; VAR = VAR(&VAR->VAR, VAR, VAR, VAR); VAR (VAR < 0) VAR VAR; VAR = 16; VAR (VAR[VAR]) { VAR(VAR->VAR, VAR(VAR[VAR]), VAR(VAR->VAR)); VAR = VAR(VAR->VAR); } VAR (VAR[VAR]) { VAR = VAR(VAR[VAR]); VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; } VAR (VAR[VAR]) VAR->VAR.VAR = VAR(VAR[VAR]); VAR = VAR(VAR[VAR]); VAR = VAR(VAR, VAR ? VAR->VAR : 0, VAR ? VAR->VAR : 0); VAR = -VAR; VAR ((VAR->VAR = VAR(VAR, VAR | (VAR<<8))) == 0) VAR VAR; VAR (VAR->VAR) { VAR = -VAR; VAR (VAR->VAR.VAR > 255) VAR VAR; VAR = -VAR; VAR (VAR->VAR.VAR == 0 && (VAR->VAR.VAR = VAR(VAR)) == 0) VAR VAR; } VAR (VAR = &VAR->VAR[VAR]; (VAR = VAR(*VAR)) != VAR; VAR = &VAR->VAR) { VAR (VAR[VAR-1] == VAR->VAR[VAR-1] && VAR && VAR->VAR == VAR->VAR && VAR(&VAR->VAR, &VAR->VAR, VAR(VAR->VAR)) == 0 &&  VAR[0] == VAR->VAR[0] && VAR[1] == VAR->VAR[1] && VAR[2] == VAR->VAR[2] &&  VAR->VAR == VAR->VAR) { VAR:  VAR = &VAR->VAR[VAR]; VAR->VAR = VAR; VAR (VAR->VAR == 0) VAR(VAR, &VAR->VAR, VAR); VAR(&VAR->VAR, &VAR); VAR = &VAR->VAR[VAR]; VAR (VAR = VAR(*VAR); VAR; VAR = &VAR->VAR, VAR = VAR(*VAR)) { VAR VAR = VAR->VAR.VAR & VAR->VAR.VAR; VAR (VAR != VAR->VAR.VAR) VAR; } VAR(VAR->VAR, VAR); VAR(*VAR, VAR); *VAR = VAR; VAR 0; } }  VAR = -VAR; VAR = VAR(VAR(VAR VAR), VAR); VAR (VAR == VAR) VAR VAR; VAR(VAR->VAR, VAR, VAR(VAR->VAR)); VAR (VAR) { VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; } VAR = &VAR->VAR[VAR]; VAR (VAR = VAR(*VAR); VAR; VAR = &VAR->VAR, VAR = VAR(*VAR)) { VAR ((VAR->VAR.VAR & VAR->VAR.VAR) != VAR->VAR.VAR) VAR; } VAR(VAR->VAR, VAR); VAR(*VAR, VAR); VAR VAR; VAR: VAR(&VAR->VAR); VAR(VAR); VAR: VAR(&VAR); VAR VAR; } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR->VAR); VAR VAR VAR, VAR; VAR (VAR->VAR) VAR; VAR (VAR = 0; VAR < 256; VAR++) { VAR VAR *VAR; VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (VAR = 0; VAR <= 16; VAR++) { VAR VAR *VAR; VAR (VAR = VAR(VAR->VAR[VAR]); VAR; VAR = VAR(VAR->VAR)) { VAR (!VAR(VAR, VAR, VAR)) VAR; } } } } } VAR VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR; VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR; VAR (VAR == VAR) VAR VAR->VAR; VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR = VAR(VAR, VAR); VAR (VAR == VAR) VAR VAR; VAR (VAR(VAR, VAR, VAR(VAR->VAR), &VAR->VAR)) VAR VAR; VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR; VAR.VAR = VAR->VAR; VAR.VAR = 0; VAR (VAR(VAR, VAR, VAR(VAR), &VAR)) VAR VAR; VAR (VAR->VAR.VAR && VAR(VAR, VAR, VAR->VAR.VAR)) VAR VAR; VAR (((VAR->VAR >> 8) & 0xFF) != 16 && VAR(VAR, VAR, VAR(VAR->VAR), VAR->VAR)) VAR VAR; VAR (VAR(VAR, &VAR->VAR) < 0) VAR VAR; VAR(VAR, VAR); VAR (VAR(VAR, &VAR->VAR) < 0) VAR VAR; VAR VAR->VAR; VAR: VAR(VAR, VAR); VAR -1; } VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR VAR, VAR *VAR, VAR VAR VAR) { VAR VAR *VAR = VAR; VAR(VAR, VAR, VAR, &VAR->VAR, VAR); } VAR VAR VAR VAR VAR = { .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, .VAR = VAR, }; VAR VAR VAR VAR(VAR) { VAR VAR(&VAR); } VAR VAR VAR VAR(VAR) { VAR(&VAR); } VAR(VAR) VAR(VAR)",1,15
linux_3b30460c5b0ed762be75a004e924ec3f8711e032,crypto/ccm.c,"	u8 idata[16];
	u8 *odata = pctx->odata;
	u8 *idata = pctx->idata;","	u8 odata[16];
	u8 idata[16];",3b30460c5b0ed762be75a004e924ec3f8711e032,CVE-2017-8065,3b30460c5b0ed762be75a004e924ec3f8711e032,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR VAR[16]; VAR *VAR = VAR->VAR; VAR *VAR = VAR->VAR; VAR VAR[16]; VAR VAR[16];,1,15
linux_41bdc78544b8a93a9c6814b8bbbfef966272abbe,arch/x86/kernel/tls.c,"static bool tls_desc_okay(const struct user_desc *info)
{
	if (LDT_empty(info))
		return true;

	/*
	 * espfix is required for 16-bit data segments, but espfix
	 * only works for LDT segments.
	 */
	if (!info->seg_32bit)
		return false;

	return true;
}

	if (!tls_desc_okay(&info))
		return -EINVAL;

	int i;
	for (i = 0; i < count / sizeof(struct user_desc); i++)
		if (!tls_desc_okay(info + i))
			return -EINVAL;
",,41bdc78544b8a93a9c6814b8bbbfef966272abbe,CVE-2014-8133,41bdc78544b8a93a9c6814b8bbbfef966272abbe,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR VAR VAR *VAR) { VAR (VAR(VAR)) VAR VAR; /* * VAR VAR VAR VAR 16-VAR VAR VAR, VAR VAR * VAR VAR VAR VAR VAR. */ VAR (!VAR->VAR) VAR VAR; VAR VAR; } VAR (!VAR(&VAR)) VAR -VAR; VAR VAR; VAR (VAR = 0; VAR < VAR / VAR(VAR VAR); VAR++) VAR (!VAR(VAR + VAR)) VAR -VAR; ",1,15
linux_4b842e4e25b12951fa10dedb4bc16bc47e3b850c,arch/x86/include/asm/uaccess_64.h,"	return copy_user_generic(dst, (__force void *)src, size);
	return copy_user_generic((__force void *)dst, src, size);","	int ret = 0;

	if (!__builtin_constant_p(size))
		return copy_user_generic(dst, (__force void *)src, size);
	switch (size) {
	case 1:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u8 *)dst, (u8 __user *)src,
			      ret, ""b"", ""b"", ""=q"", 1);
		__uaccess_end();
		return ret;
	case 2:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u16 *)dst, (u16 __user *)src,
			      ret, ""w"", ""w"", ""=r"", 2);
		__uaccess_end();
		return ret;
	case 4:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u32 *)dst, (u32 __user *)src,
			      ret, ""l"", ""k"", ""=r"", 4);
		__uaccess_end();
		return ret;
	case 8:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,
			      ret, ""q"", """", ""=r"", 8);
		__uaccess_end();
		return ret;
	case 10:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,
			       ret, ""q"", """", ""=r"", 10);
		if (likely(!ret))
			__get_user_asm_nozero(*(u16 *)(8 + (char *)dst),
				       (u16 __user *)(8 + (char __user *)src),
				       ret, ""w"", ""w"", ""=r"", 2);
		__uaccess_end();
		return ret;
	case 16:
		__uaccess_begin_nospec();
		__get_user_asm_nozero(*(u64 *)dst, (u64 __user *)src,
			       ret, ""q"", """", ""=r"", 16);
		if (likely(!ret))
			__get_user_asm_nozero(*(u64 *)(8 + (char *)dst),
				       (u64 __user *)(8 + (char __user *)src),
				       ret, ""q"", """", ""=r"", 8);
		__uaccess_end();
		return ret;
	default:
		return copy_user_generic(dst, (__force void *)src, size);
	}
	int ret = 0;

	if (!__builtin_constant_p(size))
		return copy_user_generic((__force void *)dst, src, size);
	switch (size) {
	case 1:
		__uaccess_begin();
		__put_user_asm(*(u8 *)src, (u8 __user *)dst,
			      ret, ""b"", ""b"", ""iq"", 1);
		__uaccess_end();
		return ret;
	case 2:
		__uaccess_begin();
		__put_user_asm(*(u16 *)src, (u16 __user *)dst,
			      ret, ""w"", ""w"", ""ir"", 2);
		__uaccess_end();
		return ret;
	case 4:
		__uaccess_begin();
		__put_user_asm(*(u32 *)src, (u32 __user *)dst,
			      ret, ""l"", ""k"", ""ir"", 4);
		__uaccess_end();
		return ret;
	case 8:
		__uaccess_begin();
		__put_user_asm(*(u64 *)src, (u64 __user *)dst,
			      ret, ""q"", """", ""er"", 8);
		__uaccess_end();
		return ret;
	case 10:
		__uaccess_begin();
		__put_user_asm(*(u64 *)src, (u64 __user *)dst,
			       ret, ""q"", """", ""er"", 10);
		if (likely(!ret)) {
			asm("""":::""memory"");
			__put_user_asm(4[(u16 *)src], 4 + (u16 __user *)dst,
				       ret, ""w"", ""w"", ""ir"", 2);
		}
		__uaccess_end();
		return ret;
	case 16:
		__uaccess_begin();
		__put_user_asm(*(u64 *)src, (u64 __user *)dst,
			       ret, ""q"", """", ""er"", 16);
		if (likely(!ret)) {
			asm("""":::""memory"");
			__put_user_asm(1[(u64 *)src], 1 + (u64 __user *)dst,
				       ret, ""q"", """", ""er"", 8);
		}
		__uaccess_end();
		return ret;
	default:
		return copy_user_generic((__force void *)dst, src, size);
	}",4b842e4e25b12951fa10dedb4bc16bc47e3b850c,CVE-2023-0459,4b842e4e25b12951fa10dedb4bc16bc47e3b850c,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR(VAR, (VAR VAR *)VAR, VAR); VAR VAR((VAR VAR *)VAR, VAR, VAR); VAR VAR = 0; VAR (!VAR(VAR)) VAR VAR(VAR, (VAR VAR *)VAR, VAR); VAR (VAR) { VAR 1: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""=VAR"", 1); VAR(); VAR VAR; VAR 2: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""=VAR"", 2); VAR(); VAR VAR; VAR 4: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""=VAR"", 4); VAR(); VAR VAR; VAR 8: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""=VAR"", 8); VAR(); VAR VAR; VAR 10: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""=VAR"", 10); VAR (VAR(!VAR)) VAR(*(VAR *)(8 + (VAR *)VAR), (VAR VAR *)(8 + (VAR VAR *)VAR), VAR, ""VAR"", ""VAR"", ""=VAR"", 2); VAR(); VAR VAR; VAR 16: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""=VAR"", 16); VAR (VAR(!VAR)) VAR(*(VAR *)(8 + (VAR *)VAR), (VAR VAR *)(8 + (VAR VAR *)VAR), VAR, ""VAR"", """", ""=VAR"", 8); VAR(); VAR VAR; VAR: VAR VAR(VAR, (VAR VAR *)VAR, VAR); } VAR VAR = 0; VAR (!VAR(VAR)) VAR VAR((VAR VAR *)VAR, VAR, VAR); VAR (VAR) { VAR 1: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""VAR"", 1); VAR(); VAR VAR; VAR 2: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""VAR"", 2); VAR(); VAR VAR; VAR 4: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""VAR"", 4); VAR(); VAR VAR; VAR 8: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""VAR"", 8); VAR(); VAR VAR; VAR 10: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""VAR"", 10); VAR (VAR(!VAR)) { VAR("""":::""VAR""); VAR(4[(VAR *)VAR], 4 + (VAR VAR *)VAR, VAR, ""VAR"", ""VAR"", ""VAR"", 2); } VAR(); VAR VAR; VAR 16: VAR(); VAR(*(VAR *)VAR, (VAR VAR *)VAR, VAR, ""VAR"", """", ""VAR"", 16); VAR (VAR(!VAR)) { VAR("""":::""VAR""); VAR(1[(VAR *)VAR], 1 + (VAR VAR *)VAR, VAR, ""VAR"", """", ""VAR"", 8); } VAR(); VAR VAR; VAR: VAR VAR((VAR VAR *)VAR, VAR, VAR); }",1,15
linux_4dcc29e1574d88f4465ba865ed82800032f76418,arch/ia64/kernel/patch.c,"/*
 * Disable the RSE workaround by turning the conditional branch
 * that we tagged in each place the workaround was used into an
 * unconditional branch.
 */
void __init
ia64_patch_rse (unsigned long start, unsigned long end)
{
	s32 *offp = (s32 *) start;
	u64 ip, *b;

	while (offp < (s32 *) end) {
		ip = (u64) offp + *offp;

		b = (u64 *)(ip & -16);
		b[1] &= ~0xf800000L;
		ia64_fc((void *) ip);
		++offp;
	}
	ia64_sync_i();
	ia64_srlz_i();
}
",,4dcc29e1574d88f4465ba865ed82800032f76418,CVE-2006-3635,4dcc29e1574d88f4465ba865ed82800032f76418,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"/* * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. */ VAR VAR VAR (VAR VAR VAR, VAR VAR VAR) { VAR *VAR = (VAR *) VAR; VAR VAR, *VAR; VAR (VAR < (VAR *) VAR) { VAR = (VAR) VAR + *VAR; VAR = (VAR *)(VAR & -16); VAR[1] &= ~0xf800000L; VAR((VAR *) VAR); ++VAR; } VAR(); VAR(); } ",1,15
linux_5146f95df782b0ac61abde36567e718692725c89,drivers/net/ushso.c,"	/* check if we have a valid interface */
	if (if_num > 16) {
		kfree(config_data);
		return -EINVAL;
	}

	if (id->driver_info) {
		/* if_num is controlled by the device, driver_info is a 0 terminated
		 * array. Make sure, the access is in bounds! */
		for (i = 0; i <= if_num; ++i)
			if (((u32 *)(id->driver_info))[i] == 0)
				goto exit;
	} else {
		if (port_spec < 0)
			goto exit;
	}","	if (id->driver_info)
	else",5146f95df782b0ac61abde36567e718692725c89,CVE-2019-9857,5146f95df782b0ac61abde36567e718692725c89,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,68,COMPLETED," VAR (VAR > 16) { VAR(VAR); VAR -VAR; } VAR (VAR->VAR) { /* VAR VAR VAR VAR VAR VAR, VAR VAR VAR 0 VAR * VAR. VAR VAR, VAR VAR VAR VAR VAR! */ VAR (VAR = 0; VAR <= VAR; ++VAR) VAR (((VAR *)(VAR->VAR))[VAR] == 0) VAR VAR; } VAR { VAR (VAR < 0) VAR VAR; } VAR (VAR->VAR) VAR",1,15
linux_5146f95df782b0ac61abde36567e718692725c89,drivers/net/ushso.c,"	/* check if we have a valid interface */
	if (if_num > 16) {
		kfree(config_data);
		return -EINVAL;
	}

	if (id->driver_info) {
		/* if_num is controlled by the device, driver_info is a 0 terminated
		 * array. Make sure, the access is in bounds! */
		for (i = 0; i <= if_num; ++i)
			if (((u32 *)(id->driver_info))[i] == 0)
				goto exit;
	} else {
		if (port_spec < 0)
			goto exit;
	}","	if (id->driver_info)
	else",5146f95df782b0ac61abde36567e718692725c89,CVE-2018-20669,5146f95df782b0ac61abde36567e718692725c89,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,72,COMPLETED," VAR (VAR > 16) { VAR(VAR); VAR -VAR; } VAR (VAR->VAR) { /* VAR VAR VAR VAR VAR VAR, VAR VAR VAR 0 VAR * VAR. VAR VAR, VAR VAR VAR VAR VAR! */ VAR (VAR = 0; VAR <= VAR; ++VAR) VAR (((VAR *)(VAR->VAR))[VAR] == 0) VAR VAR; } VAR { VAR (VAR < 0) VAR VAR; } VAR (VAR->VAR) VAR",1,15
linux_5146f95df782b0ac61abde36567e718692725c89,drivers/net/ushso.c,"	/* check if we have a valid interface */
	if (if_num > 16) {
		kfree(config_data);
		return -EINVAL;
	}

	if (id->driver_info) {
		/* if_num is controlled by the device, driver_info is a 0 terminated
		 * array. Make sure, the access is in bounds! */
		for (i = 0; i <= if_num; ++i)
			if (((u32 *)(id->driver_info))[i] == 0)
				goto exit;
	} else {
		if (port_spec < 0)
			goto exit;
	}","	if (id->driver_info)
	else",5146f95df782b0ac61abde36567e718692725c89,CVE-2018-19985,5146f95df782b0ac61abde36567e718692725c89,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,152,COMPLETED," VAR (VAR > 16) { VAR(VAR); VAR -VAR; } VAR (VAR->VAR) { /* VAR VAR VAR VAR VAR VAR, VAR VAR VAR 0 VAR * VAR. VAR VAR, VAR VAR VAR VAR VAR! */ VAR (VAR = 0; VAR <= VAR; ++VAR) VAR (((VAR *)(VAR->VAR))[VAR] == 0) VAR VAR; } VAR { VAR (VAR < 0) VAR VAR; } VAR (VAR->VAR) VAR",1,15
linux_57e734423adda83f3b05505875343284efe3b39c,livsprintf.c,"int kptr_restrict __read_mostly;

static noinline_for_stack
char *restricted_pointer(char *buf, char *end, const void *ptr,
			 struct printf_spec spec)
{
	spec.base = 16;
	spec.flags |= SMALL;
	if (spec.field_width == -1) {
		spec.field_width = 2 * sizeof(ptr);
		spec.flags |= ZEROPAD;
	}

	switch (kptr_restrict) {
	case 0:
		/* Always print %pK values */
		break;
	case 1: {
		const struct cred *cred;

		/*
		 * kptr_restrict==1 cannot be used in IRQ context
		 * because its test for CAP_SYSLOG would be meaningless.
		 */
		if (in_irq() || in_serving_softirq() || in_nmi())
			return string(buf, end, ""pK-error"", spec);

		/*
		 * Only print the real pointer value if the current
		 * process has CAP_SYSLOG and is running with the
		 * same credentials it started with. This is because
		 * access to files is checked at open() time, but %pK
		 * checks permission at read() time. We don't want to
		 * leak pointer values if a binary opens a file using
		 * %pK and then elevates privileges before reading it.
		 */
		cred = current_cred();
		if (!has_capability_noaudit(current, CAP_SYSLOG) ||
		    !uid_eq(cred->euid, cred->uid) ||
		    !gid_eq(cred->egid, cred->gid))
			ptr = NULL;
		break;
	}
	case 2:
	default:
		/* Always print 0's for %pK */
		ptr = NULL;
		break;
	}

	return number(buf, end, (unsigned long)ptr, spec);
}

		return restricted_pointer(buf, end, ptr, spec);","int kptr_restrict __read_mostly;

		switch (kptr_restrict) {
		case 0:
			/* Always print %pK values */
			break;
		case 1: {
			const struct cred *cred;

			/*
			 * kptr_restrict==1 cannot be used in IRQ context
			 * because its test for CAP_SYSLOG would be meaningless.
			 */
			if (in_irq() || in_serving_softirq() || in_nmi()) {
				if (spec.field_width == -1)
					spec.field_width = default_width;
				return string(buf, end, ""pK-error"", spec);
			}

			/*
			 * Only print the real pointer value if the current
			 * process has CAP_SYSLOG and is running with the
			 * same credentials it started with. This is because
			 * access to files is checked at open() time, but %pK
			 * checks permission at read() time. We don't want to
			 * leak pointer values if a binary opens a file using
			 * %pK and then elevates privileges before reading it.
			 */
			cred = current_cred();
			if (!has_capability_noaudit(current, CAP_SYSLOG) ||
			    !uid_eq(cred->euid, cred->uid) ||
			    !gid_eq(cred->egid, cred->gid))
				ptr = NULL;
			break;
		}
		case 2:
		default:
			/* Always print 0's for %pK */
			ptr = NULL;
			break;
		}
		break;
",57e734423adda83f3b05505875343284efe3b39c,CVE-2018-7754,57e734423adda83f3b05505875343284efe3b39c,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,68,COMPLETED,"VAR VAR VAR; VAR VAR VAR *VAR(VAR *VAR, VAR *VAR, VAR VAR *VAR, VAR VAR VAR) { VAR.VAR = 16; VAR.VAR |= VAR; VAR (VAR.VAR == -1) { VAR.VAR = 2 * VAR(VAR); VAR.VAR |= VAR; } VAR (VAR) { VAR 0:  VAR; VAR 1: { VAR VAR VAR *VAR; /* * VAR==1 VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR (VAR() || VAR() || VAR()) VAR VAR(VAR, VAR, ""VAR-VAR"", VAR); /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR() VAR, VAR %VAR * VAR VAR VAR VAR() VAR. VAR VAR'VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * %VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR = VAR(); VAR (!VAR(VAR, VAR) || !VAR(VAR->VAR, VAR->VAR) || !VAR(VAR->VAR, VAR->VAR)) VAR = VAR; VAR; } VAR 2: VAR:  VAR = VAR; VAR; } VAR VAR(VAR, VAR, (VAR VAR)VAR, VAR); } VAR VAR(VAR, VAR, VAR, VAR); VAR VAR VAR; VAR (VAR) { VAR 0:  VAR; VAR 1: { VAR VAR VAR *VAR; /* * VAR==1 VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR (VAR() || VAR() || VAR()) { VAR (VAR.VAR == -1) VAR.VAR = VAR; VAR VAR(VAR, VAR, ""VAR-VAR"", VAR); } /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR() VAR, VAR %VAR * VAR VAR VAR VAR() VAR. VAR VAR'VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * %VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR = VAR(); VAR (!VAR(VAR, VAR) || !VAR(VAR->VAR, VAR->VAR) || !VAR(VAR->VAR, VAR->VAR)) VAR = VAR; VAR; } VAR 2: VAR:  VAR = VAR; VAR; } VAR;",1,15
linux_59140797c5817363087b0ffb46e6bb81a11fe0dc,fs/cifs/sess.c,"static void
decode_unicode_ssetup(char **pbcc_area, int bleft, struct cifsSesInfo *ses,
		      const struct nls_table *nls_cp)
	int len;
	ses->serverOS = cifs_strndup(data, bleft, true, nls_cp);
	cFYI(1, (""serverOS=%s"", ses->serverOS));
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	ses->serverNOS = cifs_strndup(data, bleft, true, nls_cp);
	cFYI(1, (""serverNOS=%s"", ses->serverNOS));
	len = (UniStrnlen((wchar_t *) data, bleft / 2) * 2) + 2;
	data += len;
	bleft -= len;
	if (bleft <= 0)
		return;
	ses->serverDomain = cifs_strndup(data, bleft, true, nls_cp);
	cFYI(1, (""serverDomain=%s"", ses->serverDomain));
	return;
		decode_unicode_ssetup(&bcc_ptr, bytes_remaining, ses, nls_cp);","static int decode_unicode_ssetup(char **pbcc_area, int bleft,
				 struct cifsSesInfo *ses,
				 const struct nls_table *nls_cp)
	int rc = 0;
	int words_left, len;
	words_left = bleft / 2;

	/* save off server operating system */
	len = UniStrnlen((wchar_t *) data, words_left);

	if (len >= words_left)
		return rc;

	/* UTF-8 string will not grow more than four times as big as UCS-16 */
	ses->serverOS = kzalloc((4 * len) + 2 /* trailing null */, GFP_KERNEL);
	if (ses->serverOS != NULL) {
		cifs_strfromUCS_le(ses->serverOS, (__le16 *)data, len, nls_cp);
		cFYI(1, (""serverOS=%s"", ses->serverOS));
	}
	data += 2 * (len + 1);
	words_left -= len + 1;

	/* save off server network operating system */
	len = UniStrnlen((wchar_t *) data, words_left);

	if (len >= words_left)
		return rc;
	ses->serverNOS = kzalloc((4 * len) + 2 /* trailing null */, GFP_KERNEL);
	if (ses->serverNOS != NULL) {
		cifs_strfromUCS_le(ses->serverNOS, (__le16 *)data, len,
				   nls_cp);
		cFYI(1, (""serverNOS=%s"", ses->serverNOS));
		if (strncmp(ses->serverNOS, ""NT LAN Manager 4"", 16) == 0) {
			cFYI(1, (""NT4 server""));
			ses->flags |= CIFS_SES_NT4;
		}
	}
	data += 2 * (len + 1);
	words_left -= len + 1;

	/* save off server domain */
	len = UniStrnlen((wchar_t *) data, words_left);

	if (len > words_left)
		return rc;
	ses->serverDomain = kzalloc((4 * len) + 2, GFP_KERNEL);
	if (ses->serverDomain != NULL) {
		cifs_strfromUCS_le(ses->serverDomain, (__le16 *)data, len,
				   nls_cp);
		cFYI(1, (""serverDomain=%s"", ses->serverDomain));
	}
	data += 2 * (len + 1);
	words_left -= len + 1;
	cFYI(1, (""words left: %d"", words_left));

	return rc;
		rc = decode_unicode_ssetup(&bcc_ptr, bytes_remaining,
					   ses, nls_cp);",59140797c5817363087b0ffb46e6bb81a11fe0dc,CVE-2009-1633,59140797c5817363087b0ffb46e6bb81a11fe0dc,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,84,COMPLETED,"VAR VAR VAR(VAR **VAR, VAR VAR, VAR VAR *VAR, VAR VAR VAR *VAR) VAR VAR; VAR->VAR = VAR(VAR, VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); VAR = (VAR((VAR *) VAR, VAR / 2) * 2) + 2; VAR += VAR; VAR -= VAR; VAR (VAR <= 0) VAR; VAR->VAR = VAR(VAR, VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); VAR = (VAR((VAR *) VAR, VAR / 2) * 2) + 2; VAR += VAR; VAR -= VAR; VAR (VAR <= 0) VAR; VAR->VAR = VAR(VAR, VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); VAR; VAR(&VAR, VAR, VAR, VAR); VAR VAR VAR(VAR **VAR, VAR VAR, VAR VAR *VAR, VAR VAR VAR *VAR) VAR VAR = 0; VAR VAR, VAR; VAR = VAR / 2;  VAR = VAR((VAR *) VAR, VAR); VAR (VAR >= VAR) VAR VAR;  VAR->VAR = VAR((4 * VAR) + 2 , VAR); VAR (VAR->VAR != VAR) { VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); } VAR += 2 * (VAR + 1); VAR -= VAR + 1;  VAR = VAR((VAR *) VAR, VAR); VAR (VAR >= VAR) VAR VAR; VAR->VAR = VAR((4 * VAR) + 2 , VAR); VAR (VAR->VAR != VAR) { VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); VAR (VAR(VAR->VAR, ""VAR VAR VAR 4"", 16) == 0) { VAR(1, (""VAR VAR"")); VAR->VAR |= VAR; } } VAR += 2 * (VAR + 1); VAR -= VAR + 1;  VAR = VAR((VAR *) VAR, VAR); VAR (VAR > VAR) VAR VAR; VAR->VAR = VAR((4 * VAR) + 2, VAR); VAR (VAR->VAR != VAR) { VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR(1, (""VAR=%VAR"", VAR->VAR)); } VAR += 2 * (VAR + 1); VAR -= VAR + 1; VAR(1, (""VAR VAR: %VAR"", VAR)); VAR VAR; VAR = VAR(&VAR, VAR, VAR, VAR);",1,15
linux_854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,arch/x86/include/asm/kvm_host.h,"static inline u64 get_canonical(u64 la)
{
	return ((int64_t)la << 16) >> 16;
}

static inline bool is_noncanonical_address(u64 la)
{
#ifdef CONFIG_X86_64
	return get_canonical(la) != la;
#else
	return false;
#endif
}
",,854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,CVE-2014-3610,854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR VAR VAR VAR(VAR VAR) { VAR ((VAR)VAR << 16) >> 16; } VAR VAR VAR VAR(VAR VAR) {  VAR VAR(VAR) != VAR;  VAR VAR;  } ,1,15
linux_9b4416c5095c20e110c82ae602c254099b83b72f,arch/powerpc/kvm/book3s_hv_rmhandlers.S,"	std	r5, 8(r1)	// Save CR in caller's frame
	std	r0, 16(r1)	// Save LR in caller's frame
	// Create frame on emergency stack
	ld	r4, PACAEMERGSP(r13)
	stdu	r1, -SWITCH_FRAME_SIZE(r4)
	// Switch to new frame on emergency stack
	mr	r1, r4
	ld	r1, 0(r1)	// Switch back to caller stack
	ld	r0, 16(r1)	// Reload LR
	ld	r5, 8(r1)	// Reload CR","	ld	r4,PACAEMERGSP(r13)
	std	r1,0(r4)
	std	r5,8(r4)
	std	r0,16(r4)
	subi	r1,r4,STACK_FRAME_OVERHEAD
	addi	r1, r1, STACK_FRAME_OVERHEAD
	ld	r0, 16(r1)
	ld	r5, 8(r1)
	ld	r1, 0(r1)",9b4416c5095c20e110c82ae602c254099b83b72f,CVE-2021-43056,9b4416c5095c20e110c82ae602c254099b83b72f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,"VAR VAR, 8(VAR)  VAR VAR, 16(VAR)   VAR VAR, VAR(VAR) VAR VAR, -VAR(VAR)  VAR VAR, VAR VAR VAR, 0(VAR)  VAR VAR, 16(VAR)  VAR VAR, 8(VAR)  VAR VAR,VAR(VAR) VAR VAR,0(VAR) VAR VAR,8(VAR) VAR VAR,16(VAR) VAR VAR,VAR,VAR VAR VAR, VAR, VAR VAR VAR, 16(VAR) VAR VAR, 8(VAR) VAR VAR, 0(VAR)",1,15
linux_9b6e6a8334d56354853f9c255d1395c2ba570e0a,arch/x86/entry/entry_64.S,"	 *
	 * However, espfix prevents us from directly returning to userspace
	 * with a single IRET instruction.  Similarly, IRET to user mode
	 * can fault.  We therefore handle NMIs from user space like
	 * other IST entries.
	testb	$3, CS-RIP+8(%rsp)
	jz	.Lnmi_from_kernel

	/*
	 * NMI from user mode.  We need to run on the thread stack, but we
	 * can't go through the normal entry paths: NMIs are masked, and
	 * we don't want to enable interrupts, because then we'll end
	 * up in an awkward situation in which IRQs are on but NMIs
	 * are off.
	 */

	SWAPGS
	cld
	movq	%rsp, %rdx
	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
	pushq	5*8(%rdx)	/* pt_regs->ss */
	pushq	4*8(%rdx)	/* pt_regs->rsp */
	pushq	3*8(%rdx)	/* pt_regs->flags */
	pushq	2*8(%rdx)	/* pt_regs->cs */
	pushq	1*8(%rdx)	/* pt_regs->rip */
	pushq   $-1		/* pt_regs->orig_ax */
	pushq   %rdi		/* pt_regs->di */
	pushq   %rsi		/* pt_regs->si */
	pushq   (%rdx)		/* pt_regs->dx */
	pushq   %rcx		/* pt_regs->cx */
	pushq   %rax		/* pt_regs->ax */
	pushq   %r8		/* pt_regs->r8 */
	pushq   %r9		/* pt_regs->r9 */
	pushq   %r10		/* pt_regs->r10 */
	pushq   %r11		/* pt_regs->r11 */
	pushq	%rbx		/* pt_regs->rbx */
	pushq	%rbp		/* pt_regs->rbp */
	pushq	%r12		/* pt_regs->r12 */
	pushq	%r13		/* pt_regs->r13 */
	pushq	%r14		/* pt_regs->r14 */
	pushq	%r15		/* pt_regs->r15 */

	 * At this point we no longer need to worry about stack damage
	 * due to nesting -- we're on the normal thread stack and we're
	 * done with the NMI stack.
	movq	%rsp, %rdi
	movq	$-1, %rsi
	call	do_nmi

	/*
	 * Return back to user mode.  We must *not* do the normal exit
	 * work, because we don't want to enable interrupts.  Fortunately,
	 * do_nmi doesn't modify pt_regs.
	 */
	SWAPGS
	jmp	restore_c_regs_and_iret

.Lnmi_from_kernel:","	 * If %cs was not the kernel segment, then the NMI triggered in user
	 * space, which means it is definitely not nested.
	cmpl	$__KERNEL_CS, 16(%rsp)
	jne	first_nmi",9b6e6a8334d56354853f9c255d1395c2ba570e0a,CVE-2015-5157,9b6e6a8334d56354853f9c255d1395c2ba570e0a,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"* * VAR, VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR * VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR. VAR $3, VAR-VAR+8(%VAR) VAR .VAR /* * VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR * VAR'VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR, VAR * VAR VAR'VAR VAR VAR VAR VAR, VAR VAR VAR'VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. */ VAR VAR VAR %VAR, %VAR VAR VAR(VAR), %VAR VAR 5*8(%VAR)  VAR 4*8(%VAR)  VAR 3*8(%VAR)  VAR 2*8(%VAR)  VAR 1*8(%VAR)  VAR $-1  VAR %VAR  VAR %VAR  VAR (%VAR)  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR -- VAR'VAR VAR VAR VAR VAR VAR VAR VAR'VAR * VAR VAR VAR VAR VAR. VAR %VAR, %VAR VAR $-1, %VAR VAR VAR /* * VAR VAR VAR VAR VAR. VAR VAR *VAR* VAR VAR VAR VAR * VAR, VAR VAR VAR'VAR VAR VAR VAR VAR. VAR, * VAR VAR'VAR VAR VAR. */ VAR VAR VAR .VAR: * VAR %VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR. VAR $VAR, 16(%VAR) VAR VAR",1,15
linux_9b6e6a8334d56354853f9c255d1395c2ba570e0a,arch/x86/entry/entry_64.S,"	 *
	 * However, espfix prevents us from directly returning to userspace
	 * with a single IRET instruction.  Similarly, IRET to user mode
	 * can fault.  We therefore handle NMIs from user space like
	 * other IST entries.
	testb	$3, CS-RIP+8(%rsp)
	jz	.Lnmi_from_kernel

	/*
	 * NMI from user mode.  We need to run on the thread stack, but we
	 * can't go through the normal entry paths: NMIs are masked, and
	 * we don't want to enable interrupts, because then we'll end
	 * up in an awkward situation in which IRQs are on but NMIs
	 * are off.
	 */

	SWAPGS
	cld
	movq	%rsp, %rdx
	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
	pushq	5*8(%rdx)	/* pt_regs->ss */
	pushq	4*8(%rdx)	/* pt_regs->rsp */
	pushq	3*8(%rdx)	/* pt_regs->flags */
	pushq	2*8(%rdx)	/* pt_regs->cs */
	pushq	1*8(%rdx)	/* pt_regs->rip */
	pushq   $-1		/* pt_regs->orig_ax */
	pushq   %rdi		/* pt_regs->di */
	pushq   %rsi		/* pt_regs->si */
	pushq   (%rdx)		/* pt_regs->dx */
	pushq   %rcx		/* pt_regs->cx */
	pushq   %rax		/* pt_regs->ax */
	pushq   %r8		/* pt_regs->r8 */
	pushq   %r9		/* pt_regs->r9 */
	pushq   %r10		/* pt_regs->r10 */
	pushq   %r11		/* pt_regs->r11 */
	pushq	%rbx		/* pt_regs->rbx */
	pushq	%rbp		/* pt_regs->rbp */
	pushq	%r12		/* pt_regs->r12 */
	pushq	%r13		/* pt_regs->r13 */
	pushq	%r14		/* pt_regs->r14 */
	pushq	%r15		/* pt_regs->r15 */

	 * At this point we no longer need to worry about stack damage
	 * due to nesting -- we're on the normal thread stack and we're
	 * done with the NMI stack.
	movq	%rsp, %rdi
	movq	$-1, %rsi
	call	do_nmi

	/*
	 * Return back to user mode.  We must *not* do the normal exit
	 * work, because we don't want to enable interrupts.  Fortunately,
	 * do_nmi doesn't modify pt_regs.
	 */
	SWAPGS
	jmp	restore_c_regs_and_iret

.Lnmi_from_kernel:","	 * If %cs was not the kernel segment, then the NMI triggered in user
	 * space, which means it is definitely not nested.
	cmpl	$__KERNEL_CS, 16(%rsp)
	jne	first_nmi",9b6e6a8334d56354853f9c255d1395c2ba570e0a,CVE-2015-3290,9b6e6a8334d56354853f9c255d1395c2ba570e0a,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"* * VAR, VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR * VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR. VAR $3, VAR-VAR+8(%VAR) VAR .VAR /* * VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR * VAR'VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR, VAR * VAR VAR'VAR VAR VAR VAR VAR, VAR VAR VAR'VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. */ VAR VAR VAR %VAR, %VAR VAR VAR(VAR), %VAR VAR 5*8(%VAR)  VAR 4*8(%VAR)  VAR 3*8(%VAR)  VAR 2*8(%VAR)  VAR 1*8(%VAR)  VAR $-1  VAR %VAR  VAR %VAR  VAR (%VAR)  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  VAR %VAR  * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR -- VAR'VAR VAR VAR VAR VAR VAR VAR VAR'VAR * VAR VAR VAR VAR VAR. VAR %VAR, %VAR VAR $-1, %VAR VAR VAR /* * VAR VAR VAR VAR VAR. VAR VAR *VAR* VAR VAR VAR VAR * VAR, VAR VAR VAR'VAR VAR VAR VAR VAR. VAR, * VAR VAR'VAR VAR VAR. */ VAR VAR VAR .VAR: * VAR %VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR VAR VAR VAR VAR. VAR $VAR, 16(%VAR) VAR VAR",1,15
linux_a45f795c65b479b4ba107b6ccde29b896d51ee98,net/ceph/crypto.c,"static int ceph_aes_crypt(const struct ceph_crypto_key *key, bool encrypt,
			  void *buf, int buf_len, int in_len, int *pout_len)
{
	struct crypto_skcipher *tfm = ceph_crypto_alloc_cipher();
	SKCIPHER_REQUEST_ON_STACK(req, tfm);
	struct sg_table sgt;
	struct scatterlist prealloc_sg;
	char iv[AES_BLOCK_SIZE];
	int pad_byte = AES_BLOCK_SIZE - (in_len & (AES_BLOCK_SIZE - 1));
	int crypt_len = encrypt ? in_len + pad_byte : in_len;
	int ret;

	if (IS_ERR(tfm))
		return PTR_ERR(tfm);

	WARN_ON(crypt_len > buf_len);
	if (encrypt)
		memset(buf + in_len, pad_byte, pad_byte);
	ret = setup_sgtable(&sgt, &prealloc_sg, buf, crypt_len);
	if (ret)
		goto out_tfm;

	crypto_skcipher_setkey((void *)tfm, key->key, key->len);
	memcpy(iv, aes_iv, AES_BLOCK_SIZE);

	skcipher_request_set_tfm(req, tfm);
	skcipher_request_set_callback(req, 0, NULL, NULL);
	skcipher_request_set_crypt(req, sgt.sgl, sgt.sgl, crypt_len, iv);

	/*
	print_hex_dump(KERN_ERR, ""key: "", DUMP_PREFIX_NONE, 16, 1,
		       key->key, key->len, 1);
	print_hex_dump(KERN_ERR, "" in: "", DUMP_PREFIX_NONE, 16, 1,
		       buf, crypt_len, 1);
	*/
	if (encrypt)
		ret = crypto_skcipher_encrypt(req);
	else
		ret = crypto_skcipher_decrypt(req);
	skcipher_request_zero(req);
	if (ret) {
		pr_err(""%s %scrypt failed: %d\n"", __func__,
		       encrypt ? ""en"" : ""de"", ret);
		goto out_sgt;
	}
	/*
	print_hex_dump(KERN_ERR, ""out: "", DUMP_PREFIX_NONE, 16, 1,
		       buf, crypt_len, 1);
	*/

	if (encrypt) {
		*pout_len = crypt_len;
	} else {
		pad_byte = *(char *)(buf + in_len - 1);
		if (pad_byte > 0 && pad_byte <= AES_BLOCK_SIZE &&
		    in_len >= pad_byte) {
			*pout_len = in_len - pad_byte;
		} else {
			pr_err(""%s got bad padding %d on in_len %d\n"",
			       __func__, pad_byte, in_len);
			ret = -EPERM;
			goto out_sgt;
		}
	}

out_sgt:
	teardown_sgtable(&sgt);
out_tfm:
	crypto_free_skcipher(tfm);
	return ret;
}

int ceph_crypt(const struct ceph_crypto_key *key, bool encrypt,
	       void *buf, int buf_len, int in_len, int *pout_len)
{
	switch (key->type) {
	case CEPH_CRYPTO_NONE:
		*pout_len = in_len;
		return 0;
	case CEPH_CRYPTO_AES:
		return ceph_aes_crypt(key, encrypt, buf, buf_len, in_len,
				      pout_len);
	default:
		return -ENOTSUPP;
	}
}
",,a45f795c65b479b4ba107b6ccde29b896d51ee98,CVE-2016-10153,a45f795c65b479b4ba107b6ccde29b896d51ee98,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR VAR VAR *VAR, VAR VAR, VAR *VAR, VAR VAR, VAR VAR, VAR *VAR) { VAR VAR *VAR = VAR(); VAR(VAR, VAR); VAR VAR VAR; VAR VAR VAR; VAR VAR[VAR]; VAR VAR = VAR - (VAR & (VAR - 1)); VAR VAR = VAR ? VAR + VAR : VAR; VAR VAR; VAR (VAR(VAR)) VAR VAR(VAR); VAR(VAR > VAR); VAR (VAR) VAR(VAR + VAR, VAR, VAR); VAR = VAR(&VAR, &VAR, VAR, VAR); VAR (VAR) VAR VAR; VAR((VAR *)VAR, VAR->VAR, VAR->VAR); VAR(VAR, VAR, VAR); VAR(VAR, VAR); VAR(VAR, 0, VAR, VAR); VAR(VAR, VAR.VAR, VAR.VAR, VAR, VAR); /* VAR(VAR, ""VAR: "", VAR, 16, 1, VAR->VAR, VAR->VAR, 1); VAR(VAR, "" VAR: "", VAR, 16, 1, VAR, VAR, 1); */ VAR (VAR) VAR = VAR(VAR); VAR VAR = VAR(VAR); VAR(VAR); VAR (VAR) { VAR(""%VAR %VAR VAR: %VAR\VAR"", VAR, VAR ? ""VAR"" : ""VAR"", VAR); VAR VAR; } /* VAR(VAR, ""VAR: "", VAR, 16, 1, VAR, VAR, 1); */ VAR (VAR) { *VAR = VAR; } VAR { VAR = *(VAR *)(VAR + VAR - 1); VAR (VAR > 0 && VAR <= VAR && VAR >= VAR) { *VAR = VAR - VAR; } VAR { VAR(""%VAR VAR VAR VAR %VAR VAR VAR %VAR\VAR"", VAR, VAR, VAR); VAR = -VAR; VAR VAR; } } VAR: VAR(&VAR); VAR: VAR(VAR); VAR VAR; } VAR VAR(VAR VAR VAR *VAR, VAR VAR, VAR *VAR, VAR VAR, VAR VAR, VAR *VAR) { VAR (VAR->VAR) { VAR VAR: *VAR = VAR; VAR 0; VAR VAR: VAR VAR(VAR, VAR, VAR, VAR, VAR, VAR); VAR: VAR -VAR; } } ",1,15
linux_b9dd46188edc2f0d1f37328637860bb65a771124,include/linux/f2fs_fs.h,"/*
 * F2FS uses 4 bytes to represent block address. As a result, supported size of
 * disk is 16 TB and it equals to 16 * 1024 * 1024 / 2 segments.
 */
#define F2FS_MAX_SEGMENT       ((16 * 1024 * 1024) / 2)
",,b9dd46188edc2f0d1f37328637860bb65a771124,CVE-2017-10662,b9dd46188edc2f0d1f37328637860bb65a771124,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"/* * VAR VAR 4 VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR * VAR VAR 16 VAR VAR VAR VAR VAR 16 * 1024 * 1024 / 2 VAR. */  ",1,15
linux_c25b2ae136039ffa820c26138ed4a5e5f3ab3841,kernel/bpf/verifier.c,"	return base_type(type) == PTR_TO_SOCKET ||
		base_type(type) == PTR_TO_TCP_SOCK ||
		base_type(type) == PTR_TO_MEM;
/* string representation of 'enum bpf_reg_type'
 *
 * Note that reg_type_str() can not appear more than once in a single verbose()
 * statement.
 */
static const char *reg_type_str(struct bpf_verifier_env *env,
				enum bpf_reg_type type)
{
	char postfix[16] = {0};
	static const char * const str[] = {
		[NOT_INIT]		= ""?"",
		[SCALAR_VALUE]		= ""inv"",
		[PTR_TO_CTX]		= ""ctx"",
		[CONST_PTR_TO_MAP]	= ""map_ptr"",
		[PTR_TO_MAP_VALUE]	= ""map_value"",
		[PTR_TO_STACK]		= ""fp"",
		[PTR_TO_PACKET]		= ""pkt"",
		[PTR_TO_PACKET_META]	= ""pkt_meta"",
		[PTR_TO_PACKET_END]	= ""pkt_end"",
		[PTR_TO_FLOW_KEYS]	= ""flow_keys"",
		[PTR_TO_SOCKET]		= ""sock"",
		[PTR_TO_SOCK_COMMON]	= ""sock_common"",
		[PTR_TO_TCP_SOCK]	= ""tcp_sock"",
		[PTR_TO_TP_BUFFER]	= ""tp_buffer"",
		[PTR_TO_XDP_SOCK]	= ""xdp_sock"",
		[PTR_TO_BTF_ID]		= ""ptr_"",
		[PTR_TO_PERCPU_BTF_ID]	= ""percpu_ptr_"",
		[PTR_TO_MEM]		= ""mem"",
		[PTR_TO_RDONLY_BUF]	= ""rdonly_buf"",
		[PTR_TO_RDWR_BUF]	= ""rdwr_buf"",
		[PTR_TO_FUNC]		= ""func"",
		[PTR_TO_MAP_KEY]	= ""map_key"",
	};

	if (type & PTR_MAYBE_NULL) {
		if (base_type(type) == PTR_TO_BTF_ID ||
		    base_type(type) == PTR_TO_PERCPU_BTF_ID)
			strncpy(postfix, ""or_null_"", 16);
		else
			strncpy(postfix, ""_or_null"", 16);
	}

	snprintf(env->type_str_buf, TYPE_STR_BUF_LEN, ""%s%s"",
		 str[base_type(type)], postfix);
	return env->type_str_buf;
}
		verbose(env, ""=%s"", reg_type_str(env, t));
			if (base_type(t) == PTR_TO_BTF_ID ||
			    base_type(t) == PTR_TO_PERCPU_BTF_ID)
			else if (base_type(t) == CONST_PTR_TO_MAP ||
				 base_type(t) == PTR_TO_MAP_KEY ||
				 base_type(t) == PTR_TO_MAP_VALUE)
			verbose(env, ""=%s"", reg_type_str(env, t));
	if (base_type(reg->type) == PTR_TO_MAP_VALUE) {
		return;

	reg->type &= ~PTR_MAYBE_NULL;
				reg_type_str(env, parent->type),
	switch (base_type(type)) {
		if (base_type(*reg_type) == PTR_TO_BTF_ID) {
		regno, reg_type_str(env, reg->type), off, size);
				if (type_may_be_null(reg_type))
				if (base_type(reg_type) == PTR_TO_BTF_ID) {
				regno, reg_type_str(env, reg->type));
				regno, reg_type_str(env, reg->type));
			reg_type_str(env, reg->type));
			reg_type_str(env, reg_state(env, insn->dst_reg)->type));
		verbose(env, ""R%d type=%s "", regno,
			reg_type_str(env, reg->type));
		verbose(env, ""expected=%s\n"", reg_type_str(env, PTR_TO_STACK));
	if (type_may_be_null(reg->type)) {
	verbose(env, ""R%d type=%s expected="", regno, reg_type_str(env, type));
		verbose(env, ""%s, "", reg_type_str(env, compatible->types[j]));
	verbose(env, ""%s\n"", reg_type_str(env, compatible->types[j]));
	enum bpf_type_flag ret_flag;
	ret_flag = type_flag(fn->ret_type);
		regs[BPF_REG_0].type = PTR_TO_MAP_VALUE | ret_flag;
		if (!type_may_be_null(ret_type) &&
		    map_value_has_spin_lock(meta.map_ptr)) {
			regs[BPF_REG_0].id = ++env->id_gen;
		regs[BPF_REG_0].type = PTR_TO_SOCKET | ret_flag;
		regs[BPF_REG_0].type = PTR_TO_SOCK_COMMON | ret_flag;
		regs[BPF_REG_0].type = PTR_TO_TCP_SOCK | ret_flag;
		regs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;
			regs[BPF_REG_0].type = PTR_TO_MEM | ret_flag;
			regs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;
		regs[BPF_REG_0].type = PTR_TO_BTF_ID | ret_flag;
	if (type_may_be_null(regs[BPF_REG_0].type))
			reg_type_str(env, type), val);
			reg_type_str(env, type), reg->off);
			reg_type_str(env, type));
			smin, reg_type_str(env, type));
	if (ptr_reg->type & PTR_MAYBE_NULL) {
			dst, reg_type_str(env, ptr_reg->type));
	}

	switch (base_type(ptr_reg->type)) {
			dst, reg_type_str(env, ptr_reg->type));
	if (type_may_be_null(reg->type) && reg->id == id &&
	    type_may_be_null(dst_reg->type)) {
				reg_type_str(env, reg->type));
				reg_type_str(env, reg->type));
			reg_type_str(env, reg->type));
	switch (base_type(rold->type)) {
		/* a PTR_TO_MAP_VALUE could be safe to use as a
		 * PTR_TO_MAP_VALUE_OR_NULL into the same map.
		 * However, if the old PTR_TO_MAP_VALUE_OR_NULL then got NULL-
		 * checked, doing so could have affected others with the same
		 * id, and we can't check for that because we lost the id when
		 * we converted to a PTR_TO_MAP_VALUE.
		 */
		if (type_may_be_null(rold->type)) {
			if (!type_may_be_null(rcur->type))
				return false;
			if (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))
				return false;
			/* Check our ids match any regs they're supposed to */
			return check_ids(rold->id, rcur->id, idmap);
		}

	switch (base_type(type)) {
					reg_type_str(env, reg_state(env, insn->dst_reg)->type));","static bool reg_type_may_be_null(enum bpf_reg_type type)
{
	return type == PTR_TO_MAP_VALUE_OR_NULL ||
	       type == PTR_TO_SOCKET_OR_NULL ||
	       type == PTR_TO_SOCK_COMMON_OR_NULL ||
	       type == PTR_TO_TCP_SOCK_OR_NULL ||
	       type == PTR_TO_BTF_ID_OR_NULL ||
	       type == PTR_TO_MEM_OR_NULL ||
	       type == PTR_TO_RDONLY_BUF_OR_NULL ||
	       type == PTR_TO_RDWR_BUF_OR_NULL;
}

	return type == PTR_TO_SOCKET ||
		type == PTR_TO_SOCKET_OR_NULL ||
		type == PTR_TO_TCP_SOCK ||
		type == PTR_TO_TCP_SOCK_OR_NULL ||
		type == PTR_TO_MEM ||
		type == PTR_TO_MEM_OR_NULL;
/* string representation of 'enum bpf_reg_type' */
static const char * const reg_type_str[] = {
	[NOT_INIT]		= ""?"",
	[SCALAR_VALUE]		= ""inv"",
	[PTR_TO_CTX]		= ""ctx"",
	[CONST_PTR_TO_MAP]	= ""map_ptr"",
	[PTR_TO_MAP_VALUE]	= ""map_value"",
	[PTR_TO_MAP_VALUE_OR_NULL] = ""map_value_or_null"",
	[PTR_TO_STACK]		= ""fp"",
	[PTR_TO_PACKET]		= ""pkt"",
	[PTR_TO_PACKET_META]	= ""pkt_meta"",
	[PTR_TO_PACKET_END]	= ""pkt_end"",
	[PTR_TO_FLOW_KEYS]	= ""flow_keys"",
	[PTR_TO_SOCKET]		= ""sock"",
	[PTR_TO_SOCKET_OR_NULL] = ""sock_or_null"",
	[PTR_TO_SOCK_COMMON]	= ""sock_common"",
	[PTR_TO_SOCK_COMMON_OR_NULL] = ""sock_common_or_null"",
	[PTR_TO_TCP_SOCK]	= ""tcp_sock"",
	[PTR_TO_TCP_SOCK_OR_NULL] = ""tcp_sock_or_null"",
	[PTR_TO_TP_BUFFER]	= ""tp_buffer"",
	[PTR_TO_XDP_SOCK]	= ""xdp_sock"",
	[PTR_TO_BTF_ID]		= ""ptr_"",
	[PTR_TO_BTF_ID_OR_NULL]	= ""ptr_or_null_"",
	[PTR_TO_PERCPU_BTF_ID]	= ""percpu_ptr_"",
	[PTR_TO_MEM]		= ""mem"",
	[PTR_TO_MEM_OR_NULL]	= ""mem_or_null"",
	[PTR_TO_RDONLY_BUF]	= ""rdonly_buf"",
	[PTR_TO_RDONLY_BUF_OR_NULL] = ""rdonly_buf_or_null"",
	[PTR_TO_RDWR_BUF]	= ""rdwr_buf"",
	[PTR_TO_RDWR_BUF_OR_NULL] = ""rdwr_buf_or_null"",
	[PTR_TO_FUNC]		= ""func"",
	[PTR_TO_MAP_KEY]	= ""map_key"",
};
		verbose(env, ""=%s"", reg_type_str[t]);
			if (t == PTR_TO_BTF_ID ||
			    t == PTR_TO_BTF_ID_OR_NULL ||
			    t == PTR_TO_PERCPU_BTF_ID)
			else if (t == CONST_PTR_TO_MAP ||
				 t == PTR_TO_MAP_KEY ||
				 t == PTR_TO_MAP_VALUE ||
				 t == PTR_TO_MAP_VALUE_OR_NULL)
			verbose(env, ""=%s"", reg_type_str[t]);
	switch (reg->type) {
	case PTR_TO_MAP_VALUE_OR_NULL: {
		break;
	}
	case PTR_TO_SOCKET_OR_NULL:
		reg->type = PTR_TO_SOCKET;
		break;
	case PTR_TO_SOCK_COMMON_OR_NULL:
		reg->type = PTR_TO_SOCK_COMMON;
		break;
	case PTR_TO_TCP_SOCK_OR_NULL:
		reg->type = PTR_TO_TCP_SOCK;
		break;
	case PTR_TO_BTF_ID_OR_NULL:
		reg->type = PTR_TO_BTF_ID;
		break;
	case PTR_TO_MEM_OR_NULL:
		reg->type = PTR_TO_MEM;
		break;
	case PTR_TO_RDONLY_BUF_OR_NULL:
		reg->type = PTR_TO_RDONLY_BUF;
		break;
	case PTR_TO_RDWR_BUF_OR_NULL:
		reg->type = PTR_TO_RDWR_BUF;
		break;
	default:
		WARN_ONCE(1, ""unknown nullable register type"");
				reg_type_str[parent->type],
	switch (type) {
	case PTR_TO_MAP_VALUE_OR_NULL:
	case PTR_TO_SOCKET_OR_NULL:
	case PTR_TO_SOCK_COMMON_OR_NULL:
	case PTR_TO_TCP_SOCK_OR_NULL:
	case PTR_TO_BTF_ID_OR_NULL:
	case PTR_TO_RDONLY_BUF_OR_NULL:
	case PTR_TO_RDWR_BUF_OR_NULL:
	case PTR_TO_MEM_OR_NULL:
		if (*reg_type == PTR_TO_BTF_ID || *reg_type == PTR_TO_BTF_ID_OR_NULL) {
		regno, reg_type_str[reg->type], off, size);
				if (reg_type_may_be_null(reg_type))
				if (reg_type == PTR_TO_BTF_ID ||
				    reg_type == PTR_TO_BTF_ID_OR_NULL) {
				regno, reg_type_str[reg->type]);
				regno, reg_type_str[reg->type]);
			reg_type_str[reg->type]);
			reg_type_str[reg_state(env, insn->dst_reg)->type]);
		verbose(env, ""R%d type=%s expected=%s\n"", regno,
			reg_type_str[reg->type],
			reg_type_str[PTR_TO_STACK]);
	if (reg_type_may_be_null(reg->type)) {
	verbose(env, ""R%d type=%s expected="", regno, reg_type_str[type]);
		verbose(env, ""%s, "", reg_type_str[compatible->types[j]]);
	verbose(env, ""%s\n"", reg_type_str[compatible->types[j]]);
		if (type_may_be_null(ret_type)) {
			regs[BPF_REG_0].type = PTR_TO_MAP_VALUE_OR_NULL;
		} else {
			regs[BPF_REG_0].type = PTR_TO_MAP_VALUE;
			if (map_value_has_spin_lock(meta.map_ptr))
				regs[BPF_REG_0].id = ++env->id_gen;
		regs[BPF_REG_0].type = PTR_TO_SOCKET_OR_NULL;
		regs[BPF_REG_0].type = PTR_TO_SOCK_COMMON_OR_NULL;
		regs[BPF_REG_0].type = PTR_TO_TCP_SOCK_OR_NULL;
		regs[BPF_REG_0].type = PTR_TO_MEM_OR_NULL;
			regs[BPF_REG_0].type =
				(ret_type & PTR_MAYBE_NULL) ?
				PTR_TO_MEM_OR_NULL : PTR_TO_MEM;
			regs[BPF_REG_0].type =
				(ret_type & PTR_MAYBE_NULL) ?
				PTR_TO_BTF_ID_OR_NULL : PTR_TO_BTF_ID;
		regs[BPF_REG_0].type = (ret_type & PTR_MAYBE_NULL) ?
						     PTR_TO_BTF_ID_OR_NULL :
						     PTR_TO_BTF_ID;
	if (reg_type_may_be_null(regs[BPF_REG_0].type))
			reg_type_str[type], val);
			reg_type_str[type], reg->off);
			reg_type_str[type]);
			smin, reg_type_str[type]);
	switch (ptr_reg->type) {
	case PTR_TO_MAP_VALUE_OR_NULL:
			dst, reg_type_str[ptr_reg->type]);
	case PTR_TO_SOCKET_OR_NULL:
	case PTR_TO_SOCK_COMMON_OR_NULL:
	case PTR_TO_TCP_SOCK_OR_NULL:
			dst, reg_type_str[ptr_reg->type]);
	if (reg_type_may_be_null(reg->type) && reg->id == id &&
	    reg_type_may_be_null(dst_reg->type)) {
				reg_type_str[reg->type]);
				reg_type_str[reg->type]);
			reg_type_str[reg->type]);
	switch (rold->type) {
	case PTR_TO_MAP_VALUE_OR_NULL:
		/* a PTR_TO_MAP_VALUE could be safe to use as a
		 * PTR_TO_MAP_VALUE_OR_NULL into the same map.
		 * However, if the old PTR_TO_MAP_VALUE_OR_NULL then got NULL-
		 * checked, doing so could have affected others with the same
		 * id, and we can't check for that because we lost the id when
		 * we converted to a PTR_TO_MAP_VALUE.
		 */
		if (rcur->type != PTR_TO_MAP_VALUE_OR_NULL)
			return false;
		if (memcmp(rold, rcur, offsetof(struct bpf_reg_state, id)))
			return false;
		/* Check our ids match any regs they're supposed to */
		return check_ids(rold->id, rcur->id, idmap);
	case PTR_TO_SOCKET_OR_NULL:
	case PTR_TO_SOCK_COMMON_OR_NULL:
	case PTR_TO_TCP_SOCK_OR_NULL:
	switch (type) {
	case PTR_TO_SOCKET_OR_NULL:
	case PTR_TO_SOCK_COMMON_OR_NULL:
	case PTR_TO_TCP_SOCK_OR_NULL:
	case PTR_TO_BTF_ID_OR_NULL:
					reg_type_str[reg_state(env, insn->dst_reg)->type]);",c25b2ae136039ffa820c26138ed4a5e5f3ab3841,CVE-2022-0500,c25b2ae136039ffa820c26138ed4a5e5f3ab3841,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,80,COMPLETED,"VAR VAR(VAR) == VAR || VAR(VAR) == VAR || VAR(VAR) == VAR; /* VAR VAR VAR 'VAR VAR' * * VAR VAR VAR() VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR() * VAR. */ VAR VAR VAR *VAR(VAR VAR *VAR, VAR VAR VAR) { VAR VAR[16] = {0}; VAR VAR VAR * VAR VAR[] = { [VAR] = ""?"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", }; VAR (VAR & VAR) { VAR (VAR(VAR) == VAR || VAR(VAR) == VAR) VAR(VAR, ""VAR"", 16); VAR VAR(VAR, ""VAR"", 16); } VAR(VAR->VAR, VAR, ""%VAR%VAR"", VAR[VAR(VAR)], VAR); VAR VAR->VAR; } VAR(VAR, ""=%VAR"", VAR(VAR, VAR)); VAR (VAR(VAR) == VAR || VAR(VAR) == VAR) VAR VAR (VAR(VAR) == VAR || VAR(VAR) == VAR || VAR(VAR) == VAR) VAR(VAR, ""=%VAR"", VAR(VAR, VAR)); VAR (VAR(VAR->VAR) == VAR) { VAR; VAR->VAR &= ~VAR; VAR(VAR, VAR->VAR), VAR (VAR(VAR)) { VAR (VAR(*VAR) == VAR) { VAR, VAR(VAR, VAR->VAR), VAR, VAR); VAR (VAR(VAR)) VAR (VAR(VAR) == VAR) { VAR, VAR(VAR, VAR->VAR)); VAR, VAR(VAR, VAR->VAR)); VAR(VAR, VAR->VAR)); VAR(VAR, VAR(VAR, VAR->VAR)->VAR)); VAR(VAR, ""VAR%VAR VAR=%VAR "", VAR, VAR(VAR, VAR->VAR)); VAR(VAR, ""VAR=%VAR\VAR"", VAR(VAR, VAR)); VAR (VAR(VAR->VAR)) { VAR(VAR, ""VAR%VAR VAR=%VAR VAR="", VAR, VAR(VAR, VAR)); VAR(VAR, ""%VAR, "", VAR(VAR, VAR->VAR[VAR])); VAR(VAR, ""%VAR\VAR"", VAR(VAR, VAR->VAR[VAR])); VAR VAR VAR; VAR = VAR(VAR->VAR); VAR[VAR].VAR = VAR | VAR; VAR (!VAR(VAR) && VAR(VAR.VAR)) { VAR[VAR].VAR = ++VAR->VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR[VAR].VAR = VAR | VAR; VAR (VAR(VAR[VAR].VAR)) VAR(VAR, VAR), VAR); VAR(VAR, VAR), VAR->VAR); VAR(VAR, VAR)); VAR, VAR(VAR, VAR)); VAR (VAR->VAR & VAR) { VAR, VAR(VAR, VAR->VAR)); } VAR (VAR(VAR->VAR)) { VAR, VAR(VAR, VAR->VAR)); VAR (VAR(VAR->VAR) && VAR->VAR == VAR && VAR(VAR->VAR)) { VAR(VAR, VAR->VAR)); VAR(VAR, VAR->VAR)); VAR(VAR, VAR->VAR)); VAR (VAR(VAR->VAR)) { /* VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. * VAR, VAR VAR VAR VAR VAR VAR VAR- * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. */ VAR (VAR(VAR->VAR)) { VAR (!VAR(VAR->VAR)) VAR VAR; VAR (VAR(VAR, VAR, VAR(VAR VAR, VAR))) VAR VAR;  VAR VAR(VAR->VAR, VAR->VAR, VAR); } VAR (VAR(VAR)) { VAR(VAR, VAR(VAR, VAR->VAR)->VAR)); VAR VAR VAR(VAR VAR VAR) { VAR VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR; } VAR VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR;  VAR VAR VAR * VAR VAR[] = { [VAR] = ""?"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", [VAR] = ""VAR"", }; VAR(VAR, ""=%VAR"", VAR[VAR]); VAR (VAR == VAR || VAR == VAR || VAR == VAR) VAR VAR (VAR == VAR || VAR == VAR || VAR == VAR || VAR == VAR) VAR(VAR, ""=%VAR"", VAR[VAR]); VAR (VAR->VAR) { VAR VAR: { VAR; } VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR VAR: VAR->VAR = VAR; VAR; VAR: VAR(1, ""VAR VAR VAR VAR""); VAR[VAR->VAR], VAR (VAR) { VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR (*VAR == VAR || *VAR == VAR) { VAR, VAR[VAR->VAR], VAR, VAR); VAR (VAR(VAR)) VAR (VAR == VAR || VAR == VAR) { VAR, VAR[VAR->VAR]); VAR, VAR[VAR->VAR]); VAR[VAR->VAR]); VAR[VAR(VAR, VAR->VAR)->VAR]); VAR(VAR, ""VAR%VAR VAR=%VAR VAR=%VAR\VAR"", VAR, VAR[VAR->VAR], VAR[VAR]); VAR (VAR(VAR->VAR)) { VAR(VAR, ""VAR%VAR VAR=%VAR VAR="", VAR, VAR[VAR]); VAR(VAR, ""%VAR, "", VAR[VAR->VAR[VAR]]); VAR(VAR, ""%VAR\VAR"", VAR[VAR->VAR[VAR]]); VAR (VAR(VAR)) { VAR[VAR].VAR = VAR; } VAR { VAR[VAR].VAR = VAR; VAR (VAR(VAR.VAR)) VAR[VAR].VAR = ++VAR->VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = VAR; VAR[VAR].VAR = (VAR & VAR) ? VAR : VAR; VAR[VAR].VAR = (VAR & VAR) ? VAR : VAR; VAR[VAR].VAR = (VAR & VAR) ? VAR : VAR; VAR (VAR(VAR[VAR].VAR)) VAR[VAR], VAR); VAR[VAR], VAR->VAR); VAR[VAR]); VAR, VAR[VAR]); VAR (VAR->VAR) { VAR VAR: VAR, VAR[VAR->VAR]); VAR VAR: VAR VAR: VAR VAR: VAR, VAR[VAR->VAR]); VAR (VAR(VAR->VAR) && VAR->VAR == VAR && VAR(VAR->VAR)) { VAR[VAR->VAR]); VAR[VAR->VAR]); VAR[VAR->VAR]); VAR (VAR->VAR) { VAR VAR: /* VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. * VAR, VAR VAR VAR VAR VAR VAR VAR- * VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR, VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. */ VAR (VAR->VAR != VAR) VAR VAR; VAR (VAR(VAR, VAR, VAR(VAR VAR, VAR))) VAR VAR;  VAR VAR(VAR->VAR, VAR->VAR, VAR); VAR VAR: VAR VAR: VAR VAR: VAR (VAR) { VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR[VAR(VAR, VAR->VAR)->VAR]);",1,15
linux_dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,include/linux/hrtimer.h,," * @start_pid:  timer statistics field to store the pid of the task which
 *		started the timer
 * @start_site:	timer statistics field to store the site where the timer
 *		was started
 * @start_comm: timer statistics field to store the name of the process which
 *		started the timer
#ifdef CONFIG_TIMER_STATS
	int				start_pid;
	void				*start_site;
	char				start_comm[16];
#endif",dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,CVE-2017-5967,dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,98,COMPLETED, * @VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR * @VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR * @VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR  VAR VAR; VAR *VAR; VAR VAR[16]; ,1,15
linux_dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,include/linux/timer.h,,"#ifdef CONFIG_TIMER_STATS
	int			start_pid;
	void			*start_site;
	char			start_comm[16];
#endif
/*
 * Timer-statistics info:
 */
#ifdef CONFIG_TIMER_STATS

extern int timer_stats_active;

extern void init_timer_stats(void);

extern void timer_stats_update_stats(void *timer, pid_t pid, void *startf,
				     void *timerf, char *comm, u32 flags);

extern void __timer_stats_timer_set_start_info(struct timer_list *timer,
					       void *addr);

static inline void timer_stats_timer_set_start_info(struct timer_list *timer)
{
	if (likely(!timer_stats_active))
		return;
	__timer_stats_timer_set_start_info(timer, __builtin_return_address(0));
}

static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
	timer->start_site = NULL;
}
#else
static inline void init_timer_stats(void)
{
}

static inline void timer_stats_timer_set_start_info(struct timer_list *timer)
{
}

static inline void timer_stats_timer_clear_start_info(struct timer_list *timer)
{
}
#endif
",dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,CVE-2017-5967,dfb4357da6ddbdf57d583ba64361c9d792b0e0b1,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,98,COMPLETED,"  VAR VAR; VAR *VAR; VAR VAR[16];  /* * VAR-VAR VAR: */  VAR VAR VAR; VAR VAR VAR(VAR); VAR VAR VAR(VAR *VAR, VAR VAR, VAR *VAR, VAR *VAR, VAR *VAR, VAR VAR); VAR VAR VAR(VAR VAR *VAR, VAR *VAR); VAR VAR VAR VAR(VAR VAR *VAR) { VAR (VAR(!VAR)) VAR; VAR(VAR, VAR(0)); } VAR VAR VAR VAR(VAR VAR *VAR) { VAR->VAR = VAR; }  VAR VAR VAR VAR(VAR) { } VAR VAR VAR VAR(VAR VAR *VAR) { } VAR VAR VAR VAR(VAR VAR *VAR) { } ",1,15
linux_f58841666bc22e827ca0dcef7b71c7bc2758ce82,fs/cifs/misc.c,,"/* Convert 16 bit Unicode pathname from wire format to string in current code
   page.  Conversion may involve remapping up the seven characters that are
   only legal in POSIX-like OS (if they are present in the string). Path
   names are little endian 16 bit Unicode on the wire */
int
cifs_convertUCSpath(char *target, const __le16 *source, int maxlen,
		    const struct nls_table *cp)
{
	int i, j, len;
	__u16 src_char;

	for (i = 0, j = 0; i < maxlen; i++) {
		src_char = le16_to_cpu(source[i]);
		switch (src_char) {
			case 0:
				goto cUCS_out; /* BB check this BB */
			case UNI_COLON:
				target[j] = ':';
				break;
			case UNI_ASTERIK:
				target[j] = '*';
				break;
			case UNI_QUESTION:
				target[j] = '?';
				break;
			/* BB We can not handle remapping slash until
			   all the calls to build_path_from_dentry
			   are modified, as they use slash as separator BB */
			/* case UNI_SLASH:
				target[j] = '\\';
				break;*/
			case UNI_PIPE:
				target[j] = '|';
				break;
			case UNI_GRTRTHAN:
				target[j] = '>';
				break;
			case UNI_LESSTHAN:
				target[j] = '<';
				break;
			default:
				len = cp->uni2char(src_char, &target[j],
						NLS_MAX_CHARSET_SIZE);
				if (len > 0) {
					j += len;
					continue;
				} else {
					target[j] = '?';
				}
		}
		j++;
		/* make sure we do not overrun callers allocated temp buffer */
		if (j >= (2 * NAME_MAX))
			break;
	}
cUCS_out:
	target[j] = 0;
	return j;
}
",f58841666bc22e827ca0dcef7b71c7bc2758ce82,CVE-2009-1633,f58841666bc22e827ca0dcef7b71c7bc2758ce82,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,92,COMPLETED," /* VAR 16 VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR (VAR VAR VAR VAR VAR VAR VAR). VAR VAR VAR VAR VAR 16 VAR VAR VAR VAR VAR */ VAR VAR(VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR VAR *VAR) { VAR VAR, VAR, VAR; VAR VAR; VAR (VAR = 0, VAR = 0; VAR < VAR; VAR++) { VAR = VAR(VAR[VAR]); VAR (VAR) { VAR 0: VAR VAR;  VAR VAR: VAR[VAR] = ':'; VAR; VAR VAR: VAR[VAR] = '*'; VAR; VAR VAR: VAR[VAR] = '?'; VAR; /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR */ /* VAR VAR: VAR[VAR] = '\\'; VAR;*/ VAR VAR: VAR[VAR] = '|'; VAR; VAR VAR: VAR[VAR] = '>'; VAR; VAR VAR: VAR[VAR] = '<'; VAR; VAR: VAR = VAR->VAR(VAR, &VAR[VAR], VAR); VAR (VAR > 0) { VAR += VAR; VAR; } VAR { VAR[VAR] = '?'; } } VAR++;  VAR (VAR >= (2 * VAR)) VAR; } VAR: VAR[VAR] = 0; VAR VAR; }",1,15
moodle_c73f6d03e5037729097bb9f5f5a55be15f3cab18,liflowplayer/flowplayer.controls-3.2.16.swf.php,"<?php
// This file is part of Moodle - http://moodle.org/
//
// Moodle is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Moodle is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.

/**
 * Flowplayer audio controls handling.
 *
 * @package core
 * @copyright  Petr Skoda <petr.skoda@totaralms.com>
 * @license http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
 */

define('NO_DEBUG_DISPLAY', true);
define('NO_MOODLE_COOKIES', true);
define('NO_UPGRADE_CHECK', true);

require('../../config.php');
require('../../lib/flowplayer/lib.php');

flowplayer_send_flash_content('flowplayer.controls-3.2.16.swf');",,c73f6d03e5037729097bb9f5f5a55be15f3cab18,CVE-2015-5337,c73f6d03e5037729097bb9f5f5a55be15f3cab18,https://github.com/moodle/moodle,GHSD_DIRECT_COMMIT,1337,COMPLETED,"<?VAR               /** * VAR VAR VAR VAR. * * @VAR VAR * @VAR VAR VAR <VAR.VAR@VAR.VAR> * @VAR VAR: */ VAR('VAR', VAR); VAR('VAR', VAR); VAR('VAR', VAR); VAR('../../VAR.VAR'); VAR('../../VAR/VAR/VAR.VAR'); VAR('VAR.VAR-3.2.16.VAR'); ",1,15
openssl_43e6a58d4991a451daf4891ff05a48735df871ac,crypto/dsa/dsa_ossl.c,    q_bits = BN_num_bits(dsa->q) + sizeof(dsa->q->d[0]) * 16;,    q_bits = BN_num_bits(dsa->q);,43e6a58d4991a451daf4891ff05a48735df871ac,CVE-2018-0734,43e6a58d4991a451daf4891ff05a48735df871ac,https://github.com/openssl/openssl,CPE_GIT_REPOBASED,148,COMPLETED,VAR = VAR(VAR->VAR) + VAR(VAR->VAR->VAR[0]) * 16; VAR = VAR(VAR->VAR);,1,15
openssl_4443cf7aa0099e5ce615c18cee249fff77fb0871,crypto/bn/asm/x86_64-mont5.pl,"	xor	$zero,$zero
	sub	16+8(%rsp),%rbx		# mov 16(%rsp),%cf
	adcx	$zero,%r8
	adcx	$zero,%r9
	adc	\$0,%r10
	adc	\$0,%r11
	adc	\$0,%r12
	adc	\$0,%r13
	adc	\$0,%r14
	adc	\$0,%r15","	sub	16+8(%rsp),%r8		# consume last carry
	xor	%ebp,%ebp		# xor	$zero,$zero",4443cf7aa0099e5ce615c18cee249fff77fb0871,CVE-2017-3736,4443cf7aa0099e5ce615c18cee249fff77fb0871,https://github.com/openssl/openssl,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR $VAR,$VAR VAR 16+8(%VAR),%VAR  VAR $VAR,%VAR VAR $VAR,%VAR VAR \$0,%VAR VAR \$0,%VAR VAR \$0,%VAR VAR \$0,%VAR VAR \$0,%VAR VAR \$0,%VAR VAR 16+8(%VAR),%VAR  VAR %VAR,%VAR ",1,15
tomcat_c8acd2ab7371e39aeca7c306f3b5380f00afe552,test/org/apache/coyote/http2/TestHttp2Section_5_1.java,"        doTestImplicitClose(5);
    }


    // https://bz.apache.org/bugzilla/show_bug.cgi?id=64467
    @Test
    public void testImplicitCloseLargeId() throws Exception {
        doTestImplicitClose(Integer.MAX_VALUE - 8);
    }


    private void doTestImplicitClose(int lastStreamId) throws Exception {

        long startFirst = System.nanoTime();
        long durationFirst = System.nanoTime() - startFirst;
        sendPriority(lastStreamId, 0, 16);
        long startSecond = System.nanoTime();
        sendSimpleGetRequest(lastStreamId);
        long durationSecond = System.nanoTime() - startSecond;

        Assert.assertEquals(getSimpleResponseTrace(lastStreamId), output.getTrace());
        // Allow second request to take up to 5 times first request or up to 1 second - whichever is the larger - mainly
        // to allow for CI systems under load that can exhibit significant timing variation.
        Assert.assertTrue(""First request took ["" + durationFirst/1000000 + ""ms], second request took ["" +
                durationSecond/1000000 + ""ms]"", durationSecond < 1000000000 || durationSecond < durationFirst * 3);

        handleGoAwayResponse(lastStreamId);","        sendPriority(5, 0, 16);
        sendSimpleGetRequest(5);
        Assert.assertEquals(getSimpleResponseTrace(5), output.getTrace());
        handleGoAwayResponse(5);",c8acd2ab7371e39aeca7c306f3b5380f00afe552,CVE-2020-11996,c8acd2ab7371e39aeca7c306f3b5380f00afe552,https://github.com/apache/tomcat,CPE_GIT_REPOBASED,66,COMPLETED,"VAR(5); }  @VAR VAR VAR VAR() VAR VAR { VAR(VAR.VAR - 8); } VAR VAR VAR(VAR VAR) VAR VAR { VAR VAR = VAR.VAR(); VAR VAR = VAR.VAR() - VAR; VAR(VAR, 0, 16); VAR VAR = VAR.VAR(); VAR(VAR); VAR VAR = VAR.VAR() - VAR; VAR.VAR(VAR(VAR), VAR.VAR());   VAR.VAR(""VAR VAR VAR ["" + VAR/1000000 + ""VAR], VAR VAR VAR ["" + VAR/1000000 + ""VAR]"", VAR < 1000000000 || VAR < VAR * 3); VAR(VAR); VAR(5, 0, 16); VAR(5); VAR.VAR(VAR(5), VAR.VAR()); VAR(5);",1,15
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,docs/requirements.txt,"-r ../dev-requirements.txt
ndg-httpsclient
sphinx
alabaster
requests>=2.0,<2.16",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"-VAR ../VAR-VAR.VAR VAR-VAR VAR VAR VAR>=2.0,<2.16 ",1,15
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,src/urllib3/filepost.py,"from __future__ import absolute_import
import binascii
import codecs
import os

from io import BytesIO

from .packages import six
from .packages.six import b
from .fields import RequestField

writer = codecs.lookup('utf-8')[3]


def choose_boundary():
    """"""
    Our embarrassingly-simple replacement for mimetools.choose_boundary.
    """"""
    boundary = binascii.hexlify(os.urandom(16))
    if six.PY3:
        boundary = boundary.decode('ascii')
    return boundary


def iter_field_objects(fields):
    """"""
    Iterate over fields.

    Supports list of (k, v) tuples and dicts, and lists of
    :class:`~urllib3.fields.RequestField`.

    """"""
    if isinstance(fields, dict):
        i = six.iteritems(fields)
    else:
        i = iter(fields)

    for field in i:
        if isinstance(field, RequestField):
            yield field
        else:
            yield RequestField.from_tuples(*field)


def iter_fields(fields):
    """"""
    .. deprecated:: 1.6

    Iterate over fields.

    The addition of :class:`~urllib3.fields.RequestField` makes this function
    obsolete. Instead, use :func:`iter_field_objects`, which returns
    :class:`~urllib3.fields.RequestField` objects.

    Supports list of (k, v) tuples and dicts.
    """"""
    if isinstance(fields, dict):
        return ((k, v) for k, v in six.iteritems(fields))

    return ((k, v) for k, v in fields)


def encode_multipart_formdata(fields, boundary=None):
    """"""
    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.

    :param fields:
        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).

    :param boundary:
        If not specified, then a random boundary will be generated using
        :func:`urllib3.filepost.choose_boundary`.
    """"""
    body = BytesIO()
    if boundary is None:
        boundary = choose_boundary()

    for field in iter_field_objects(fields):
        body.write(b('--%s\r\n' % (boundary)))

        writer(body).write(field.render_headers())
        data = field.data

        if isinstance(data, int):
            data = str(data)  # Backwards compatibility

        if isinstance(data, six.text_type):
            writer(body).write(data)
        else:
            body.write(data)

        body.write(b'\r\n')

    body.write(b('--%s--\r\n' % (boundary)))

    content_type = str('multipart/form-data; boundary=%s' % boundary)

    return body.getvalue(), content_type",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR.VAR VAR VAR VAR .VAR VAR VAR VAR = VAR.VAR('VAR-8')[3] VAR VAR(): """""" VAR VAR-VAR VAR VAR VAR.VAR. """""" VAR = VAR.VAR(VAR.VAR(16)) VAR VAR.VAR: VAR = VAR.VAR('VAR') VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR, VAR VAR VAR :VAR:`~VAR.VAR.VAR`. """""" VAR VAR(VAR, VAR): VAR = VAR.VAR(VAR) VAR: VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR.VAR(*VAR) VAR VAR(VAR): """""" .. VAR:: 1.6 VAR VAR VAR. VAR VAR VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR VAR. VAR, VAR :VAR:`VAR`, VAR VAR :VAR:`~VAR.VAR.VAR` VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR ((VAR, VAR) VAR VAR, VAR VAR VAR.VAR(VAR)) VAR ((VAR, VAR) VAR VAR, VAR VAR VAR) VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR ``VAR`` VAR VAR VAR/VAR-VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR (VAR, :VAR:`~VAR.VAR.VAR`). :VAR VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR`. """""" VAR = VAR() VAR VAR VAR VAR: VAR = VAR() VAR VAR VAR VAR(VAR): VAR.VAR(VAR('--%VAR\VAR\VAR' % (VAR))) VAR(VAR).VAR(VAR.VAR()) VAR = VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR)  VAR VAR(VAR, VAR.VAR): VAR(VAR).VAR(VAR) VAR: VAR.VAR(VAR) VAR.VAR(VAR'\VAR\VAR') VAR.VAR(VAR('--%VAR--\VAR\VAR' % (VAR))) VAR = VAR('VAR/VAR-VAR; VAR=%VAR' % VAR) VAR VAR.VAR(), VAR ",1,15
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,src/urllib3/response.py,"from __future__ import absolute_import
from contextlib import contextmanager
import zlib
import io
import logging
from socket import timeout as SocketTimeout
from socket import error as SocketError

from ._collections import HTTPHeaderDict
from .exceptions import (
    BodyNotHttplibCompatible, ProtocolError, DecodeError, ReadTimeoutError,
    ResponseNotChunked, IncompleteRead, InvalidHeader
)
from .packages.six import string_types as basestring, PY3
from .packages.six.moves import http_client as httplib
from .connection import HTTPException, BaseSSLError
from .util.response import is_fp_closed, is_response_to_head

log = logging.getLogger(__name__)


class DeflateDecoder(object):

    def __init__(self):
        self._first_try = True
        self._data = b''
        self._obj = zlib.decompressobj()

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        if not data:
            return data

        if not self._first_try:
            return self._obj.decompress(data)

        self._data += data
        try:
            decompressed = self._obj.decompress(data)
            if decompressed:
                self._first_try = False
                self._data = None
            return decompressed
        except zlib.error:
            self._first_try = False
            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
            try:
                return self.decompress(self._data)
            finally:
                self._data = None


class GzipDecoderState(object):

    FIRST_MEMBER = 0
    OTHER_MEMBERS = 1
    SWALLOW_DATA = 2


class GzipDecoder(object):

    def __init__(self):
        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
        self._state = GzipDecoderState.FIRST_MEMBER

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        ret = bytearray()
        if self._state == GzipDecoderState.SWALLOW_DATA or not data:
            return bytes(ret)
        while True:
            try:
                ret += self._obj.decompress(data)
            except zlib.error:
                previous_state = self._state
                # Ignore data after the first error
                self._state = GzipDecoderState.SWALLOW_DATA
                if previous_state == GzipDecoderState.OTHER_MEMBERS:
                    # Allow trailing garbage acceptable in other gzip clients
                    return bytes(ret)
                raise
            data = self._obj.unused_data
            if not data:
                return bytes(ret)
            self._state = GzipDecoderState.OTHER_MEMBERS
            self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)


class MultiDecoder(object):
    """"""
    From RFC7231:
        If one or more encodings have been applied to a representation, the
        sender that applied the encodings MUST generate a Content-Encoding
        header field that lists the content codings in the order in which
        they were applied.
    """"""

    def __init__(self, modes):
        self._decoders = [_get_decoder(m.strip()) for m in modes.split(',')]

    def flush(self):
        return self._decoders[0].flush()

    def decompress(self, data):
        for d in reversed(self._decoders):
            data = d.decompress(data)
        return data


def _get_decoder(mode):
    if ',' in mode:
        return MultiDecoder(mode)

    if mode == 'gzip':
        return GzipDecoder()

    return DeflateDecoder()


class HTTPResponse(io.IOBase):
    """"""
    HTTP Response container.

    Backwards-compatible to httplib's HTTPResponse but the response ``body`` is
    loaded and decoded on-demand when the ``data`` property is accessed.  This
    class is also compatible with the Python standard library's :mod:`io`
    module, and can hence be treated as a readable object in the context of that
    framework.

    Extra parameters for behaviour not present in httplib.HTTPResponse:

    :param preload_content:
        If True, the response's body will be preloaded during construction.

    :param decode_content:
        If True, will attempt to decode the body based on the
        'content-encoding' header.

    :param original_response:
        When this HTTPResponse wrapper is generated from an httplib.HTTPResponse
        object, it's convenient to include the original for debug purposes. It's
        otherwise unused.

    :param retries:
        The retries contains the last :class:`~urllib3.util.retry.Retry` that
        was used during the request.

    :param enforce_content_length:
        Enforce content length checking. Body returned by server must match
        value of Content-Length header, if present. Otherwise, raise error.
    """"""

    CONTENT_DECODERS = ['gzip', 'deflate']
    REDIRECT_STATUSES = [301, 302, 303, 307, 308]

    def __init__(self, body='', headers=None, status=0, version=0, reason=None,
                 strict=0, preload_content=True, decode_content=True,
                 original_response=None, pool=None, connection=None, msg=None,
                 retries=None, enforce_content_length=False,
                 request_method=None, request_url=None):

        if isinstance(headers, HTTPHeaderDict):
            self.headers = headers
        else:
            self.headers = HTTPHeaderDict(headers)
        self.status = status
        self.version = version
        self.reason = reason
        self.strict = strict
        self.decode_content = decode_content
        self.retries = retries
        self.enforce_content_length = enforce_content_length

        self._decoder = None
        self._body = None
        self._fp = None
        self._original_response = original_response
        self._fp_bytes_read = 0
        self.msg = msg
        self._request_url = request_url

        if body and isinstance(body, (basestring, bytes)):
            self._body = body

        self._pool = pool
        self._connection = connection

        if hasattr(body, 'read'):
            self._fp = body

        # Are we using the chunked-style of transfer encoding?
        self.chunked = False
        self.chunk_left = None
        tr_enc = self.headers.get('transfer-encoding', '').lower()
        # Don't incur the penalty of creating a list and then discarding it
        encodings = (enc.strip() for enc in tr_enc.split("",""))
        if ""chunked"" in encodings:
            self.chunked = True

        # Determine length of response
        self.length_remaining = self._init_length(request_method)

        # If requested, preload the body.
        if preload_content and not self._body:
            self._body = self.read(decode_content=decode_content)

    def get_redirect_location(self):
        """"""
        Should we redirect and where to?

        :returns: Truthy redirect location string if we got a redirect status
            code and valid location. ``None`` if redirect status and no
            location. ``False`` if not a redirect status code.
        """"""
        if self.status in self.REDIRECT_STATUSES:
            return self.headers.get('location')

        return False

    def release_conn(self):
        if not self._pool or not self._connection:
            return

        self._pool._put_conn(self._connection)
        self._connection = None

    @property
    def data(self):
        # For backwords-compat with earlier urllib3 0.4 and earlier.
        if self._body:
            return self._body

        if self._fp:
            return self.read(cache_content=True)

    @property
    def connection(self):
        return self._connection

    def isclosed(self):
        return is_fp_closed(self._fp)

    def tell(self):
        """"""
        Obtain the number of bytes pulled over the wire so far. May differ from
        the amount of content returned by :meth:``HTTPResponse.read`` if bytes
        are encoded on the wire (e.g, compressed).
        """"""
        return self._fp_bytes_read

    def _init_length(self, request_method):
        """"""
        Set initial length value for Response content if available.
        """"""
        length = self.headers.get('content-length')

        if length is not None:
            if self.chunked:
                # This Response will fail with an IncompleteRead if it can't be
                # received as chunked. This method falls back to attempt reading
                # the response before raising an exception.
                log.warning(""Received response with both Content-Length and ""
                            ""Transfer-Encoding set. This is expressly forbidden ""
                            ""by RFC 7230 sec 3.3.2. Ignoring Content-Length and ""
                            ""attempting to process response as Transfer-Encoding: ""
                            ""chunked."")
                return None

            try:
                # RFC 7230 section 3.3.2 specifies multiple content lengths can
                # be sent in a single Content-Length header
                # (e.g. Content-Length: 42, 42). This line ensures the values
                # are all valid ints and that as long as the `set` length is 1,
                # all values are the same. Otherwise, the header is invalid.
                lengths = set([int(val) for val in length.split(',')])
                if len(lengths) > 1:
                    raise InvalidHeader(""Content-Length contained multiple ""
                                        ""unmatching values (%s)"" % length)
                length = lengths.pop()
            except ValueError:
                length = None
            else:
                if length < 0:
                    length = None

        # Convert status to int for comparison
        # In some cases, httplib returns a status of ""_UNKNOWN""
        try:
            status = int(self.status)
        except ValueError:
            status = 0

        # Check for responses that shouldn't include a body
        if status in (204, 304) or 100 <= status < 200 or request_method == 'HEAD':
            length = 0

        return length

    def _init_decoder(self):
        """"""
        Set-up the _decoder attribute if necessary.
        """"""
        # Note: content-encoding value should be case-insensitive, per RFC 7230
        # Section 3.2
        content_encoding = self.headers.get('content-encoding', '').lower()
        if self._decoder is None:
            if content_encoding in self.CONTENT_DECODERS:
                self._decoder = _get_decoder(content_encoding)
            elif ',' in content_encoding:
                encodings = [
                    e.strip() for e in content_encoding.split(',')
                    if e.strip() in self.CONTENT_DECODERS]
                if len(encodings):
                    self._decoder = _get_decoder(content_encoding)

    def _decode(self, data, decode_content, flush_decoder):
        """"""
        Decode the data passed in and potentially flush the decoder.
        """"""
        try:
            if decode_content and self._decoder:
                data = self._decoder.decompress(data)
        except (IOError, zlib.error) as e:
            content_encoding = self.headers.get('content-encoding', '').lower()
            raise DecodeError(
                ""Received response with content-encoding: %s, but ""
                ""failed to decode it."" % content_encoding, e)

        if flush_decoder and decode_content:
            data += self._flush_decoder()

        return data

    def _flush_decoder(self):
        """"""
        Flushes the decoder. Should only be called if the decoder is actually
        being used.
        """"""
        if self._decoder:
            buf = self._decoder.decompress(b'')
            return buf + self._decoder.flush()

        return b''

    @contextmanager
    def _error_catcher(self):
        """"""
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.

        On exit, release the connection back to the pool.
        """"""
        clean_exit = False

        try:
            try:
                yield

            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if 'read operation timed out' not in str(e):  # Defensive:
                    # This shouldn't happen but just in case we're missing an edge
                    # case, let's avoid swallowing SSL errors.
                    raise

                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
                raise ProtocolError('Connection broken: %r' % e, e)

            # If no exception is thrown, we should avoid cleaning up
            # unnecessarily.
            clean_exit = True
        finally:
            # If we didn't terminate cleanly, we need to throw away our
            # connection.
            if not clean_exit:
                # The response may not be closed but we're not going to use it
                # anymore so close it now to ensure that the connection is
                # released back to the pool.
                if self._original_response:
                    self._original_response.close()

                # Closing the response may not actually be sufficient to close
                # everything, so if we have a hold of the connection close that
                # too.
                if self._connection:
                    self._connection.close()

            # If we hold the original response but it's closed now, we should
            # return the connection back to the pool.
            if self._original_response and self._original_response.isclosed():
                self.release_conn()

    def read(self, amt=None, decode_content=None, cache_content=False):
        """"""
        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional
        parameters: ``decode_content`` and ``cache_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.

        :param cache_content:
            If True, will save the returned data such that the same result is
            returned despite of the state of the underlying file object. This
            is useful if you want the ``.data`` property to continue working
            after having ``.read()`` the file object. (Overridden if ``amt`` is
            set.)
        """"""
        self._init_decoder()
        if decode_content is None:
            decode_content = self.decode_content

        if self._fp is None:
            return

        flush_decoder = False
        data = None

        with self._error_catcher():
            if amt is None:
                # cStringIO doesn't like amt=None
                data = self._fp.read()
                flush_decoder = True
            else:
                cache_content = False
                data = self._fp.read(amt)
                if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.
                    # Close the connection when no data is returned
                    #
                    # This is redundant to what httplib/http.client _should_
                    # already do.  However, versions of python released before
                    # December 15, 2012 (http://bugs.python.org/issue16298) do
                    # not properly close the connection in all cases. There is
                    # no harm in redundantly calling close.
                    self._fp.close()
                    flush_decoder = True
                    if self.enforce_content_length and self.length_remaining not in (0, None):
                        # This is an edge case that httplib failed to cover due
                        # to concerns of backward compatibility. We're
                        # addressing it here to make sure IncompleteRead is
                        # raised during streaming, so all calls with incorrect
                        # Content-Length are caught.
                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)

        if data:
            self._fp_bytes_read += len(data)
            if self.length_remaining is not None:
                self.length_remaining -= len(data)

            data = self._decode(data, decode_content, flush_decoder)

            if cache_content:
                self._body = data

        return data

    def stream(self, amt=2**16, decode_content=None):
        """"""
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.

        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        if self.chunked and self.supports_chunked_reads():
            for line in self.read_chunked(amt, decode_content=decode_content):
                yield line
        else:
            while not is_fp_closed(self._fp):
                data = self.read(amt=amt, decode_content=decode_content)

                if data:
                    yield data

    @classmethod
    def from_httplib(ResponseCls, r, **response_kw):
        """"""
        Given an :class:`httplib.HTTPResponse` instance ``r``, return a
        corresponding :class:`urllib3.response.HTTPResponse` object.

        Remaining parameters are passed to the HTTPResponse constructor, along
        with ``original_response=r``.
        """"""
        headers = r.msg

        if not isinstance(headers, HTTPHeaderDict):
            if PY3:  # Python 3
                headers = HTTPHeaderDict(headers.items())
            else:  # Python 2
                headers = HTTPHeaderDict.from_httplib(headers)

        # HTTPResponse objects in Python 3 don't have a .strict attribute
        strict = getattr(r, 'strict', 0)
        resp = ResponseCls(body=r,
                           headers=headers,
                           status=r.status,
                           version=r.version,
                           reason=r.reason,
                           strict=strict,
                           original_response=r,
                           **response_kw)
        return resp

    # Backwards-compatibility methods for httplib.HTTPResponse
    def getheaders(self):
        return self.headers

    def getheader(self, name, default=None):
        return self.headers.get(name, default)

    # Backwards compatibility for http.cookiejar
    def info(self):
        return self.headers

    # Overrides from io.IOBase
    def close(self):
        if not self.closed:
            self._fp.close()

        if self._connection:
            self._connection.close()

    @property
    def closed(self):
        if self._fp is None:
            return True
        elif hasattr(self._fp, 'isclosed'):
            return self._fp.isclosed()
        elif hasattr(self._fp, 'closed'):
            return self._fp.closed
        else:
            return True

    def fileno(self):
        if self._fp is None:
            raise IOError(""HTTPResponse has no file to get a fileno from"")
        elif hasattr(self._fp, ""fileno""):
            return self._fp.fileno()
        else:
            raise IOError(""The file-like object this HTTPResponse is wrapped ""
                          ""around has no file descriptor"")

    def flush(self):
        if self._fp is not None and hasattr(self._fp, 'flush'):
            return self._fp.flush()

    def readable(self):
        # This method is required for `io` module compatibility.
        return True

    def readinto(self, b):
        # This method is required for `io` module compatibility.
        temp = self.read(len(b))
        if len(temp) == 0:
            return 0
        else:
            b[:len(temp)] = temp
            return len(temp)

    def supports_chunked_reads(self):
        """"""
        Checks if the underlying file-like object looks like a
        httplib.HTTPResponse object. We do this by testing for the fp
        attribute. If it is present we assume it returns raw chunks as
        processed by read_chunked().
        """"""
        return hasattr(self._fp, 'fp')

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b';', 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
            raise httplib.IncompleteRead(line)

    def _handle_chunk(self, amt):
        returned_chunk = None
        if amt is None:
            chunk = self._fp._safe_read(self.chunk_left)
            returned_chunk = chunk
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        elif amt < self.chunk_left:
            value = self._fp._safe_read(amt)
            self.chunk_left = self.chunk_left - amt
            returned_chunk = value
        elif amt == self.chunk_left:
            value = self._fp._safe_read(amt)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
            returned_chunk = value
        else:  # amt > self.chunk_left
            returned_chunk = self._fp._safe_read(self.chunk_left)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        return returned_chunk

    def read_chunked(self, amt=None, decode_content=None):
        """"""
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                ""Response is not chunked. ""
                ""Header 'transfer-encoding: chunked' is missing."")
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                ""Body should be httplib.HTTPResponse like. ""
                ""It should have have an fp attribute which returns raw chunks."")

        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return

            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return

            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(chunk, decode_content=decode_content,
                                       flush_decoder=False)
                if decoded:
                    yield decoded

            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded

            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b'\r\n':
                    break

            # We read everything; close the ""file"".
            if self._original_response:
                self._original_response.close()

    def geturl(self):
        """"""
        Returns the URL that was the source of this response.
        If the request that generated this response redirected, this method
        will return the final redirect location.
        """"""
        if self.retries is not None and len(self.retries.history):
            return self.retries.history[-1].redirect_location
        else:
            return self._request_url

    def __iter__(self):
        buffer = [b""""]
        for chunk in self.stream(decode_content=True):
            if b""\n"" in chunk:
                chunk = chunk.split(b""\n"")
                yield b"""".join(buffer) + chunk[0] + b""\n""
                for x in chunk[1:-1]:
                    yield x + b""\n""
                if chunk[-1]:
                    buffer = [chunk[-1]]
                else:
                    buffer = []
            else:
                buffer.append(chunk)
        if buffer:
            yield b"""".join(buffer)",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR ) VAR .VAR.VAR VAR VAR VAR VAR, VAR VAR .VAR.VAR.VAR VAR VAR VAR VAR VAR .VAR VAR VAR, VAR VAR .VAR.VAR VAR VAR, VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR) VAR.VAR += VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR: VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR VAR.VAR = VAR.VAR(-VAR.VAR) VAR: VAR VAR.VAR(VAR.VAR) VAR: VAR.VAR = VAR VAR VAR(VAR): VAR = 0 VAR = 1 VAR = 2 VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR.VAR = VAR.VAR VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR = VAR() VAR VAR.VAR == VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR VAR: VAR: VAR += VAR.VAR.VAR(VAR) VAR VAR.VAR: VAR = VAR.VAR  VAR.VAR = VAR.VAR VAR VAR == VAR.VAR:  VAR VAR(VAR) VAR VAR = VAR.VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR.VAR = VAR.VAR VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR VAR(VAR): """""" VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = [VAR(VAR.VAR()) VAR VAR VAR VAR.VAR(',')] VAR VAR(VAR): VAR VAR.VAR[0].VAR() VAR VAR(VAR, VAR): VAR VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR ',' VAR VAR: VAR VAR(VAR) VAR VAR == 'VAR': VAR VAR() VAR VAR() VAR VAR(VAR.VAR): """""" VAR VAR VAR. VAR-VAR VAR VAR'VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR-VAR VAR VAR ``VAR`` VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR :VAR:`VAR` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR.VAR: :VAR VAR: VAR VAR, VAR VAR'VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR'VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR, VAR VAR. VAR, VAR VAR. """""" VAR = ['VAR', 'VAR'] VAR = [301, 302, 303, 307, 308] VAR VAR(VAR, VAR='', VAR=VAR, VAR=0, VAR=0, VAR=VAR, VAR=0, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR VAR(VAR, VAR): VAR.VAR = VAR VAR: VAR.VAR = VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR(VAR, (VAR, VAR)): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, 'VAR'): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR VAR = VAR.VAR.VAR('VAR-VAR', '').VAR()  VAR = (VAR.VAR() VAR VAR VAR VAR.VAR("","")) VAR ""VAR"" VAR VAR: VAR.VAR = VAR  VAR.VAR = VAR.VAR(VAR)  VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR.VAR(VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR? :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR.VAR('VAR') VAR VAR VAR VAR(VAR): VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR.VAR) VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR VAR.VAR: VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR(VAR=VAR) @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:``VAR.VAR`` VAR VAR VAR VAR VAR VAR VAR (VAR.VAR, VAR). """""" VAR VAR.VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR') VAR VAR VAR VAR VAR: VAR VAR.VAR:    VAR.VAR(""VAR VAR VAR VAR VAR-VAR VAR "" ""VAR-VAR VAR. VAR VAR VAR VAR "" ""VAR VAR 7230 VAR 3.3.2. VAR VAR-VAR VAR "" ""VAR VAR VAR VAR VAR VAR-VAR: "" ""VAR."") VAR VAR VAR:      VAR = VAR([VAR(VAR) VAR VAR VAR VAR.VAR(',')]) VAR VAR(VAR) > 1: VAR VAR(""VAR-VAR VAR VAR "" ""VAR VAR (%VAR)"" % VAR) VAR = VAR.VAR() VAR VAR: VAR = VAR VAR: VAR VAR < 0: VAR = VAR   VAR: VAR = VAR(VAR.VAR) VAR VAR: VAR = 0  VAR VAR VAR (204, 304) VAR 100 <= VAR < 200 VAR VAR == 'VAR': VAR = 0 VAR VAR VAR VAR(VAR): """""" VAR-VAR VAR VAR VAR VAR VAR. """"""   VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR.VAR VAR VAR: VAR VAR VAR VAR.VAR: VAR.VAR = VAR(VAR) VAR ',' VAR VAR: VAR = [ VAR.VAR() VAR VAR VAR VAR.VAR(',') VAR VAR.VAR() VAR VAR.VAR] VAR VAR(VAR): VAR.VAR = VAR(VAR) VAR VAR(VAR, VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR: VAR VAR VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR (VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR( ""VAR VAR VAR VAR-VAR: %VAR, VAR "" ""VAR VAR VAR VAR."" % VAR, VAR) VAR VAR VAR VAR: VAR += VAR.VAR() VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR'') VAR VAR + VAR.VAR.VAR() VAR VAR'' @VAR VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR, VAR VAR-VAR VAR VAR, VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR VAR: VAR: VAR VAR VAR:   VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR VAR VAR VAR:  VAR 'VAR VAR VAR VAR' VAR VAR VAR(VAR):    VAR VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR (VAR, VAR) VAR VAR:  VAR VAR('VAR VAR: %VAR' % VAR, VAR)   VAR = VAR VAR:   VAR VAR VAR:    VAR VAR.VAR: VAR.VAR.VAR()    VAR VAR.VAR: VAR.VAR.VAR()   VAR VAR.VAR VAR VAR.VAR.VAR(): VAR.VAR() VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR`` VAR ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR ``.VAR`` VAR VAR VAR VAR VAR VAR ``.VAR()`` VAR VAR VAR. (VAR VAR ``VAR`` VAR VAR.) """""" VAR.VAR() VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR.VAR VAR VAR: VAR VAR = VAR VAR = VAR VAR VAR.VAR(): VAR VAR VAR VAR:  VAR = VAR.VAR.VAR() VAR = VAR VAR: VAR = VAR VAR = VAR.VAR.VAR(VAR) VAR VAR != 0 VAR VAR VAR:         VAR.VAR.VAR() VAR = VAR VAR VAR.VAR VAR VAR.VAR VAR VAR (0, VAR):      VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR += VAR(VAR) VAR VAR.VAR VAR VAR VAR: VAR.VAR -= VAR(VAR) VAR = VAR.VAR(VAR, VAR, VAR) VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=2**16, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR() VAR. VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR VAR.VAR VAR VAR.VAR(): VAR VAR VAR VAR.VAR(VAR, VAR=VAR): VAR VAR VAR: VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR=VAR, VAR=VAR) VAR VAR: VAR VAR @VAR VAR VAR(VAR, VAR, **VAR): """""" VAR VAR :VAR:`VAR.VAR` VAR ``VAR``, VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR ``VAR=VAR``. """""" VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR VAR:  VAR = VAR(VAR.VAR()) VAR:  VAR = VAR.VAR(VAR)  VAR = VAR(VAR, 'VAR', 0) VAR = VAR(VAR=VAR, VAR=VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR, **VAR) VAR VAR  VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR, VAR, VAR=VAR): VAR VAR.VAR.VAR(VAR, VAR)  VAR VAR(VAR): VAR VAR.VAR  VAR VAR(VAR): VAR VAR VAR.VAR: VAR.VAR.VAR() VAR VAR.VAR: VAR.VAR.VAR() @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR VAR: VAR VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR: VAR VAR(""VAR VAR-VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR"") VAR VAR(VAR): VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR):  VAR VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR(VAR(VAR)) VAR VAR(VAR) == 0: VAR 0 VAR: VAR[:VAR(VAR)] = VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR.VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR(). """""" VAR VAR(VAR.VAR, 'VAR') VAR VAR(VAR):   VAR VAR.VAR VAR VAR VAR: VAR VAR = VAR.VAR.VAR.VAR() VAR = VAR.VAR(VAR';', 1)[0] VAR: VAR.VAR = VAR(VAR, 16) VAR VAR:  VAR.VAR() VAR VAR.VAR(VAR) VAR VAR(VAR, VAR): VAR = VAR VAR VAR VAR VAR: VAR = VAR.VAR.VAR(VAR.VAR) VAR = VAR VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR < VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR = VAR.VAR - VAR VAR = VAR VAR VAR == VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR = VAR VAR:  VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR.VAR()  VAR VAR VAR.VAR: VAR VAR( ""VAR VAR VAR VAR. "" ""VAR 'VAR-VAR: VAR' VAR VAR."") VAR VAR VAR.VAR(): VAR VAR( ""VAR VAR VAR VAR.VAR VAR. "" ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR.VAR():  VAR VAR.VAR VAR VAR(VAR.VAR): VAR.VAR.VAR() VAR   VAR VAR.VAR.VAR VAR VAR: VAR VAR VAR: VAR.VAR() VAR VAR.VAR == 0: VAR VAR = VAR.VAR(VAR) VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR: VAR VAR VAR VAR:    VAR = VAR.VAR() VAR VAR:  VAR VAR  VAR VAR: VAR = VAR.VAR.VAR.VAR() VAR VAR VAR:  VAR VAR VAR == VAR'\VAR\VAR': VAR  VAR VAR.VAR: VAR.VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR.VAR): VAR VAR.VAR.VAR[-1].VAR VAR: VAR VAR.VAR VAR VAR(VAR): VAR = [VAR""""] VAR VAR VAR VAR.VAR(VAR=VAR): VAR VAR""\VAR"" VAR VAR: VAR = VAR.VAR(VAR""\VAR"") VAR VAR"""".VAR(VAR) + VAR[0] + VAR""\VAR"" VAR VAR VAR VAR[1:-1]: VAR VAR + VAR""\VAR"" VAR VAR[-1]: VAR = [VAR[-1]] VAR: VAR = [] VAR: VAR.VAR(VAR) VAR VAR: VAR VAR"""".VAR(VAR) ",1,15
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,test/test_response.py,"import socket
import zlib

from io import BytesIO, BufferedReader

import pytest
import mock

from urllib3.response import HTTPResponse
from urllib3.exceptions import (
    DecodeError, ResponseNotChunked, ProtocolError, InvalidHeader
)
from urllib3.packages.six.moves import http_client as httplib
from urllib3.util.retry import Retry, RequestHistory
from urllib3.util.response import is_fp_closed

from base64 import b64decode

# A known random (i.e, not-too-compressible) payload generated with:
#    """".join(random.choice(string.printable) for i in xrange(512))
#    .encode(""zlib"").encode(""base64"")
# Randomness in tests == bad, and fixing a seed may not be sufficient.
ZLIB_PAYLOAD = b64decode(b""""""\
eJwFweuaoQAAANDfineQhiKLUiaiCzvuTEmNNlJGiL5QhnGpZ99z8luQfe1AHoMioB+QSWHQu/L+
lzd7W5CipqYmeVTBjdgSATdg4l4Z2zhikbuF+EKn69Q0DTpdmNJz8S33odfJoVEexw/l2SS9nFdi
pis7KOwXzfSqarSo9uJYgbDGrs1VNnQpT9f8zAorhYCEZronZQF9DuDFfNK3Hecc+WHLnZLQptwk
nufw8S9I43sEwxsT71BiqedHo0QeIrFE01F/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/nNvDGKZ
Khe5TF36JbnKVjdcL1EUNpwrWVfQpFYJ/WWm2b74qNeSZeQv5/xBhRdOmKTJFYgO96PwrHBlsnLn
a3l0LwJsloWpMbzByU5WLbRE6X5INFqjQOtIwYz5BAlhkn+kVqJvWM5vBlfrwP42ifonM5yF4ciJ
auHVks62997mNGOsM7WXNG3P98dBHPo2NhbTvHleL0BI5dus2JY81MUOnK3SGWLH8HeWPa1t5KcW
S5moAj5HexY/g/F8TctpxwsvyZp38dXeLDjSQvEQIkF7XR3YXbeZgKk3V34KGCPOAeeuQDIgyVhV
nP4HF2uWHA=="""""")


@pytest.fixture
def sock():
    s = socket.socket()
    yield s
    s.close()


class TestLegacyResponse(object):
    def test_getheaders(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheaders() == headers

    def test_getheader(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheader('host') == 'example.com'


class TestResponse(object):
    def test_cache_content(self):
        r = HTTPResponse('foo')
        assert r.data == 'foo'
        assert r._body == 'foo'

    def test_default(self):
        r = HTTPResponse()
        assert r.data is None

    def test_none(self):
        r = HTTPResponse(None)
        assert r.data is None

    def test_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=True)

        assert fp.tell() == len(b'foo')
        assert r.data == b'foo'

    def test_no_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=False)

        assert fp.tell() == 0
        assert r.data == b'foo'
        assert fp.tell() == len(b'foo')

    def test_decode_bad_data(self):
        fp = BytesIO(b'\x00' * 10)
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'deflate'})

    def test_reference_read(self):
        fp = BytesIO(b'foo')
        r = HTTPResponse(fp, preload_content=False)

        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'})

        assert r.data == b'foo'

    def test_decode_deflate_case_insensitve(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'DeFlAtE'})

        assert r.data == b'foo'

    def test_chunked_decoding_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(3) == b''
        # Buffer in case we need to switch to the raw stream
        assert r._decoder._data is not None
        assert r.read(1) == b'f'
        # Now that we've decoded data, we just stream through the decoder
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_deflate2(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(1) == b''
        assert r.read(1) == b'f'
        # Once we've decoded data, we just stream to the decoder; no buffering
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                         preload_content=False)

        assert r.read(11) == b''
        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_gzip_multi_member(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    def test_decode_gzip_error(self):
        fp = BytesIO(b'foo')
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'gzip'})

    def test_decode_gzip_swallow_garbage(self):
        # When data comes from multiple calls to read(), data after
        # the first zlib error (here triggered by garbage) should be
        # ignored.
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={'content-encoding': 'gzip'}, preload_content=False)
        ret = b''
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break

        assert ret == b'foofoofoo'

    def test_chunked_decoding_gzip_swallow_garbage(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    def test_multi_decoding_deflate_deflate(self):
        data = zlib.compress(zlib.compress(b'foo'))

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, deflate'})

        assert r.data == b'foo'

    def test_multi_decoding_deflate_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(zlib.compress(b'foo'))
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, gzip'})

        assert r.data == b'foo'

    def test_multi_decoding_gzip_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(data)
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip, gzip'})

        assert r.data == b'foo'

    def test_body_blob(self):
        resp = HTTPResponse(b'foo')
        assert resp.data == b'foo'
        assert resp.closed

    def test_io(self, sock):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)

        assert not resp.closed
        assert resp.readable()
        assert not resp.writable()
        with pytest.raises(IOError):
            resp.fileno()

        resp.close()
        assert resp.closed

        # Try closing with an `httplib.HTTPResponse`, because it has an
        # `isclosed` method.
        try:
            hlr = httplib.HTTPResponse(sock)
            resp2 = HTTPResponse(hlr, preload_content=False)
            assert not resp2.closed
            resp2.close()
            assert resp2.closed
        finally:
            hlr.close()

        # also try when only data is present.
        resp3 = HTTPResponse('foodata')
        with pytest.raises(IOError):
            resp3.fileno()

        resp3._fp = 2
        # A corner case where _fp is present but doesn't have `closed`,
        # `isclosed`, or `fileno`.  Unlikely, but possible.
        assert resp3.closed
        with pytest.raises(IOError):
            resp3.fileno()

    def test_io_closed_consistently(self, sock):
        try:
            hlr = httplib.HTTPResponse(sock)
            hlr.fp = BytesIO(b'foo')
            hlr.chunked = 0
            hlr.length = 3
            with HTTPResponse(hlr, preload_content=False) as resp:
                assert not resp.closed
                assert not resp._fp.isclosed()
                assert not is_fp_closed(resp._fp)
                assert not resp.isclosed()
                resp.read()
                assert resp.closed
                assert resp._fp.isclosed()
                assert is_fp_closed(resp._fp)
                assert resp.isclosed()
        finally:
            hlr.close()

    def test_io_bufferedreader(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp)

        assert br.read() == b'foo'

        br.close()
        assert resp.closed

        b = b'fooandahalf'
        fp = BytesIO(b)
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp, 5)

        br.read(1)  # sets up the buffer, reading 5
        assert len(fp.read()) == (len(b) - 5)

        # This is necessary to make sure the ""no bytes left"" part of `readinto`
        # gets tested.
        while not br.closed:
            br.read(5)

    def test_streaming(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_streaming_tell(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        position = 0

        position += len(next(stream))
        assert 2 == position
        assert position == resp.tell()

        position += len(next(stream))
        assert 3 == position
        assert position == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming_tell(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        uncompressed_data = b'foo'
        data = compress.compress(uncompressed_data)
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream()

        # Read everything
        payload = next(stream)
        assert payload == uncompressed_data

        assert len(data) == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate_streaming_tell_intermediate_point(self):
        # Ensure that ``tell()`` returns the correct number of bytes when
        # part-way through streaming compressed content.
        NUMBER_OF_READS = 10

        class MockCompressedDataReading(BytesIO):
            """"""
            A ByteIO-like reader returning ``payload`` in ``NUMBER_OF_READS``
            calls to ``read``.
            """"""

            def __init__(self, payload, payload_part_size):
                self.payloads = [
                    payload[i*payload_part_size:(i+1)*payload_part_size]
                    for i in range(NUMBER_OF_READS+1)]

                assert b"""".join(self.payloads) == payload

            def read(self, _):
                # Amount is unused.
                if len(self.payloads) > 0:
                    return self.payloads.pop(0)
                return b""""

        uncompressed_data = zlib.decompress(ZLIB_PAYLOAD)

        payload_part_size = len(ZLIB_PAYLOAD) // NUMBER_OF_READS
        fp = MockCompressedDataReading(ZLIB_PAYLOAD, payload_part_size)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream()

        parts_positions = [(part, resp.tell()) for part in stream]
        end_of_stream = resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

        parts, positions = zip(*parts_positions)

        # Check that the payload is equal to the uncompressed data
        payload = b"""".join(parts)
        assert uncompressed_data == payload

        # Check that the positions in the stream are correct
        expected = [(i+1)*payload_part_size for i in range(NUMBER_OF_READS)]
        assert expected == list(positions)

        # Check that the end of the stream is in the correct place
        assert len(ZLIB_PAYLOAD) == end_of_stream

    def test_deflate_streaming(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate2_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_empty_stream(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        with pytest.raises(StopIteration):
            next(stream)

    def test_length_no_header(self):
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        assert resp.length_remaining is None

    def test_length_w_valid_header(self):
        headers = {""content-length"": ""5""}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

    def test_length_w_bad_header(self):
        garbage = {'content-length': 'foo'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

        garbage['content-length'] = ""-10""
        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

    def test_length_when_chunked(self):
        # This is expressly forbidden in RFC 7230 sec 3.3.2
        # We fall back to chunked in this case and try to
        # handle response ignoring content length.
        headers = {'content-length': '5',
                   'transfer-encoding': 'chunked'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining is None

    def test_length_with_multiple_content_lengths(self):
        headers = {'content-length': '5, 5, 5'}
        garbage = {'content-length': '5, 42'}
        fp = BytesIO(b'abcde')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

        with pytest.raises(InvalidHeader):
            HTTPResponse(fp, headers=garbage, preload_content=False)

    def test_length_after_read(self):
        headers = {""content-length"": ""5""}

        # Test no defined length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        resp.read()
        assert resp.length_remaining is None

        # Test our update from content-length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        resp.read()
        assert resp.length_remaining == 0

        # Test partial read
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        data = resp.stream(2)
        next(data)
        assert resp.length_remaining == 3

    def test_mock_httpresponse_stream(self):
        # Mock out a HTTP Request that does enough to make it through urllib3's
        # read() and close() calls, and also exhausts and underlying file
        # object.
        class MockHTTPRequest(object):
            self.fp = None

            def read(self, amt):
                data = self.fp.read(amt)
                if not data:
                    self.fp = None

                return data

            def close(self):
                self.fp = None

        bio = BytesIO(b'foo')
        fp = MockHTTPRequest()
        fp.fp = bio
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_mock_transfer_encoding_chunked(self):
        stream = [b""fo"", b""o"", b""bar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})

        for i, c in enumerate(resp.stream()):
            assert c == stream[i]

    def test_mock_gzipped_transfer_encoding_chunked_decoded(self):
        """"""Show that we can decode the gizpped and chunked body.""""""
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b'foobar')
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i:i+2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {'transfer-encoding': 'chunked', 'content-encoding': 'gzip'}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b''
        for c in resp.stream(decode_content=True):
            data += c

        assert b'foobar' == data

    def test_mock_transfer_encoding_chunked_custom_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        expected_response = [b'fo', b'oo', b'o', b'bb', b'bb', b'aa', b'aa', b'ar']
        response = list(resp.read_chunked(2))
        assert expected_response == response

    def test_mock_transfer_encoding_chunked_unlmtd_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.read_chunked())

    def test_read_not_chunked_response_as_chunks(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        r = resp.read_chunked()
        with pytest.raises(ResponseNotChunked):
            next(r)

    def test_invalid_chunks(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedInvalidEncoding(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        with pytest.raises(ProtocolError):
            next(resp.read_chunked())

    def test_chunked_response_without_crlf_on_end(self):
        stream = [b""foo"", b""bar"", b""baz""]
        fp = MockChunkedEncodingWithoutCRLFOnEnd(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_response_with_extensions(self):
        stream = [b""foo"", b""bar""]
        fp = MockChunkedEncodingWithExtensions(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_head_response(self):
        r = httplib.HTTPResponse(MockSock, method='HEAD')
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse('',
                            preload_content=False,
                            headers={'transfer-encoding': 'chunked'},
                            original_response=r)
        assert resp.chunked is True

        resp.supports_chunked_reads = lambda: True
        resp.release_conn = mock.Mock()
        for _ in resp.stream():
            continue
        resp.release_conn.assert_called_once_with()

    def test_get_case_insensitive_headers(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.headers.get('host') == 'example.com'
        assert r.headers.get('Host') == 'example.com'

    def test_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp)
        assert resp.retries is None
        retry = Retry()
        resp = HTTPResponse(fp, retries=retry)
        assert resp.retries == retry

    def test_geturl(self):
        fp = BytesIO(b'')
        request_url = 'https://example.com'
        resp = HTTPResponse(fp, request_url=request_url)
        assert resp.geturl() == request_url

    def test_geturl_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, request_url='http://example.com')
        request_histories = [
            RequestHistory(method='GET', url='http://example.com', error=None,
                           status=301, redirect_location='https://example.com/'),
            RequestHistory(method='GET', url='https://example.com/', error=None,
                           status=301, redirect_location='https://www.example.com')]
        retry = Retry(history=request_histories)
        resp = HTTPResponse(fp, retries=retry)
        assert resp.geturl() == 'https://www.example.com'

    @pytest.mark.parametrize(
        [""payload"", ""expected_stream""],
        [(b"""", [b""""]),
         (b""\n"", [b""\n""]),
         (b""abc\ndef"", [b""abc\n"", b""def""]),
         (b""Hello\nworld\n\n\n!"", [b""Hello\n"", b""world\n"", b""\n"", b""\n"", b""!""])]
    )
    def test__iter__(self, payload, expected_stream):
        actual_stream = []
        for chunk in HTTPResponse(BytesIO(payload), preload_content=False):
            actual_stream.append(chunk)

        assert actual_stream == expected_stream

    def test__iter__decode_content(self):
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b'foo\nbar')
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i:i + 2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {'transfer-encoding': 'chunked', 'content-encoding': 'gzip'}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b''
        for c in resp:
            data += c

        assert b'foo\nbar' == data


class MockChunkedEncodingResponse(object):

    def __init__(self, content):
        """"""
        content: collection of str, each str is a chunk in response
        """"""
        self.content = content
        self.index = 0  # This class iterates over self.content.
        self.closed = False
        self.cur_chunk = b''
        self.chunks_exhausted = False

    @staticmethod
    def _encode_chunk(chunk):
        # In the general case, we can't decode the chunk to unicode
        length = '%X\r\n' % len(chunk)
        return length.encode() + chunk + b'\r\n'

    def _pop_new_chunk(self):
        if self.chunks_exhausted:
            return b""""
        try:
            chunk = self.content[self.index]
        except IndexError:
            chunk = b''
            self.chunks_exhausted = True
        else:
            self.index += 1
        chunk = self._encode_chunk(chunk)
        if not isinstance(chunk, bytes):
            chunk = chunk.encode()
        return chunk

    def pop_current_chunk(self, amt=-1, till_crlf=False):
        if amt > 0 and till_crlf:
            raise ValueError(""Can't specify amt and till_crlf."")
        if len(self.cur_chunk) <= 0:
            self.cur_chunk = self._pop_new_chunk()
        if till_crlf:
            try:
                i = self.cur_chunk.index(b""\r\n"")
            except ValueError:
                # No CRLF in current chunk -- probably caused by encoder.
                self.cur_chunk = b""""
                return b""""
            else:
                chunk_part = self.cur_chunk[:i+2]
                self.cur_chunk = self.cur_chunk[i+2:]
                return chunk_part
        elif amt <= -1:
            chunk_part = self.cur_chunk
            self.cur_chunk = b''
            return chunk_part
        else:
            try:
                chunk_part = self.cur_chunk[:amt]
            except IndexError:
                chunk_part = self.cur_chunk
                self.cur_chunk = b''
            else:
                self.cur_chunk = self.cur_chunk[amt:]
            return chunk_part

    def readline(self):
        return self.pop_current_chunk(till_crlf=True)

    def read(self, amt=-1):
        return self.pop_current_chunk(amt)

    def flush(self):
        # Python 3 wants this method.
        pass

    def close(self):
        self.closed = True


class MockChunkedInvalidEncoding(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return 'ZZZ\r\n%s\r\n' % chunk.decode()


class MockChunkedEncodingWithoutCRLFOnEnd(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X\r\n%s%s' % (len(chunk), chunk.decode(),
                               ""\r\n"" if len(chunk) > 0 else """")


class MockChunkedEncodingWithExtensions(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X;asd=qwe\r\n%s\r\n' % (len(chunk), chunk.decode())


class MockSock(object):
    @classmethod
    def makefile(cls, *args, **kwargs):
        return",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR ) VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR VAR VAR     VAR = VAR(VAR""""""\ VAR+VAR/VAR+ VAR+VAR/VAR VAR+VAR VAR/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/VAR VAR/VAR/VAR VAR+VAR VAR VAR/VAR/VAR VAR=="""""") @VAR.VAR VAR VAR(): VAR = VAR.VAR() VAR VAR VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR VAR(VAR): VAR = VAR('VAR') VAR VAR.VAR == 'VAR' VAR VAR.VAR == 'VAR' VAR VAR(VAR): VAR = VAR() VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 0 VAR VAR.VAR == VAR'VAR' VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR(VAR): VAR = VAR(VAR'\VAR' * 10) VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(3) == VAR''  VAR VAR.VAR.VAR VAR VAR VAR VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(1) == VAR'' VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(11) == VAR'' VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR):    VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR( VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR VAR.VAR() VAR VAR VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR.VAR   VAR: VAR = VAR.VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR.VAR() VAR VAR.VAR VAR: VAR.VAR()  VAR = VAR('VAR') VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR = 2   VAR VAR.VAR VAR VAR.VAR(VAR): VAR.VAR() VAR VAR(VAR, VAR): VAR: VAR = VAR.VAR(VAR) VAR.VAR = VAR(VAR'VAR') VAR.VAR = 0 VAR.VAR = 3 VAR VAR(VAR, VAR=VAR) VAR VAR: VAR VAR VAR.VAR VAR VAR VAR.VAR.VAR() VAR VAR VAR(VAR.VAR) VAR VAR VAR.VAR() VAR.VAR() VAR VAR.VAR VAR VAR.VAR.VAR() VAR VAR(VAR.VAR) VAR VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR) VAR VAR.VAR() == VAR'VAR' VAR.VAR() VAR VAR.VAR VAR = VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR, 5) VAR.VAR(1)  VAR VAR(VAR.VAR()) == (VAR(VAR) - 5)   VAR VAR VAR.VAR: VAR.VAR(5) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR = 0 VAR += VAR(VAR(VAR)) VAR 2 == VAR VAR VAR == VAR.VAR() VAR += VAR(VAR(VAR)) VAR 3 == VAR VAR VAR == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR'VAR' VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR()  VAR = VAR(VAR) VAR VAR == VAR VAR VAR(VAR) == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR):   VAR = 10 VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR ``VAR`` VAR ``VAR`` VAR VAR ``VAR``. """""" VAR VAR(VAR, VAR, VAR): VAR.VAR = [ VAR[VAR*VAR:(VAR+1)*VAR] VAR VAR VAR VAR(VAR+1)] VAR VAR"""".VAR(VAR.VAR) == VAR VAR VAR(VAR, VAR):  VAR VAR(VAR.VAR) > 0: VAR VAR.VAR.VAR(0) VAR VAR"""" VAR = VAR.VAR(VAR) VAR = VAR(VAR)  VAR = VAR(VAR, VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR() VAR = [(VAR, VAR.VAR()) VAR VAR VAR VAR] VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR, VAR = VAR(*VAR)  VAR = VAR"""".VAR(VAR) VAR VAR == VAR  VAR = [(VAR+1)*VAR VAR VAR VAR VAR(VAR)] VAR VAR == VAR(VAR)  VAR VAR(VAR) == VAR VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR['VAR-VAR'] = ""-10"" VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR):    VAR = {'VAR-VAR': '5', 'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {'VAR-VAR': '5, 5, 5'} VAR = {'VAR-VAR': '5, 42'} VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR.VAR(VAR): VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""}  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR VAR VAR  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR == 0  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR(2) VAR(VAR) VAR VAR.VAR == 3 VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(VAR) VAR VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR): VAR.VAR = VAR VAR = VAR(VAR'VAR') VAR = VAR() VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR, VAR VAR VAR(VAR.VAR()): VAR VAR == VAR[VAR] VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR:VAR+2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': 'VAR'} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR.VAR(VAR=VAR): VAR += VAR VAR VAR'VAR' == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR = [VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR'] VAR = VAR(VAR.VAR(2)) VAR VAR == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR = VAR VAR.VAR = VAR VAR = VAR('', VAR=VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR VAR VAR VAR.VAR = VAR: VAR VAR.VAR = VAR.VAR() VAR VAR VAR VAR.VAR(): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR = VAR() VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = 'VAR: VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR='VAR: VAR = [ VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR = VAR(VAR=VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 'VAR: @VAR.VAR.VAR( [""VAR"", ""VAR""], [(VAR"""", [VAR""""]), (VAR""\VAR"", [VAR""\VAR""]), (VAR""VAR\VAR"", [VAR""VAR\VAR"", VAR""VAR""]), (VAR""VAR\VAR\VAR\VAR\VAR!"", [VAR""VAR\VAR"", VAR""VAR\VAR"", VAR""\VAR"", VAR""\VAR"", VAR""!""])] ) VAR VAR(VAR, VAR, VAR): VAR = [] VAR VAR VAR VAR(VAR(VAR), VAR=VAR): VAR.VAR(VAR) VAR VAR == VAR VAR VAR(VAR): VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR\VAR') VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR:VAR + 2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': 'VAR'} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR: VAR += VAR VAR VAR'VAR\VAR' == VAR VAR VAR(VAR): VAR VAR(VAR, VAR): """""" VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR """""" VAR.VAR = VAR VAR.VAR = 0  VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR = '%VAR\VAR\VAR' % VAR(VAR) VAR VAR.VAR() + VAR + VAR'\VAR\VAR' VAR VAR(VAR): VAR VAR.VAR: VAR VAR"""" VAR: VAR = VAR.VAR[VAR.VAR] VAR VAR: VAR = VAR'' VAR.VAR = VAR VAR: VAR.VAR += 1 VAR = VAR.VAR(VAR) VAR VAR VAR(VAR, VAR): VAR = VAR.VAR() VAR VAR VAR VAR(VAR, VAR=-1, VAR=VAR): VAR VAR > 0 VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR."") VAR VAR(VAR.VAR) <= 0: VAR.VAR = VAR.VAR() VAR VAR: VAR: VAR = VAR.VAR.VAR(VAR""\VAR\VAR"") VAR VAR:  VAR.VAR = VAR"""" VAR VAR"""" VAR: VAR = VAR.VAR[:VAR+2] VAR.VAR = VAR.VAR[VAR+2:] VAR VAR VAR VAR <= -1: VAR = VAR.VAR VAR.VAR = VAR'' VAR VAR VAR: VAR: VAR = VAR.VAR[:VAR] VAR VAR: VAR = VAR.VAR VAR.VAR = VAR'' VAR: VAR.VAR = VAR.VAR[VAR:] VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR=VAR) VAR VAR(VAR, VAR=-1): VAR VAR.VAR(VAR) VAR VAR(VAR):  VAR VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR): VAR VAR(VAR, VAR): VAR 'VAR\VAR\VAR%VAR\VAR\VAR' % VAR.VAR() VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR\VAR\VAR%VAR%VAR' % (VAR(VAR), VAR.VAR(), ""\VAR\VAR"" VAR VAR(VAR) > 0 VAR """") VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR;VAR=VAR\VAR\VAR%VAR\VAR\VAR' % (VAR(VAR), VAR.VAR()) VAR VAR(VAR): @VAR VAR VAR(VAR, *VAR, **VAR): VAR ",1,15
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,docs/requirements.txt,"-r ../dev-requirements.txt
sphinx>3.0.0
requests>=2,<2.16
furo",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"-VAR ../VAR-VAR.VAR VAR>3.0.0 VAR>=2,<2.16 VAR ",1,15
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,src/urllib3/filepost.py,"from __future__ import absolute_import

import binascii
import codecs
import os
from io import BytesIO

from .fields import RequestField
from .packages import six
from .packages.six import b

writer = codecs.lookup(""utf-8"")[3]


def choose_boundary():
    """"""
    Our embarrassingly-simple replacement for mimetools.choose_boundary.
    """"""
    boundary = binascii.hexlify(os.urandom(16))
    if not six.PY2:
        boundary = boundary.decode(""ascii"")
    return boundary


def iter_field_objects(fields):
    """"""
    Iterate over fields.

    Supports list of (k, v) tuples and dicts, and lists of
    :class:`~urllib3.fields.RequestField`.

    """"""
    if isinstance(fields, dict):
        i = six.iteritems(fields)
    else:
        i = iter(fields)

    for field in i:
        if isinstance(field, RequestField):
            yield field
        else:
            yield RequestField.from_tuples(*field)


def iter_fields(fields):
    """"""
    .. deprecated:: 1.6

    Iterate over fields.

    The addition of :class:`~urllib3.fields.RequestField` makes this function
    obsolete. Instead, use :func:`iter_field_objects`, which returns
    :class:`~urllib3.fields.RequestField` objects.

    Supports list of (k, v) tuples and dicts.
    """"""
    if isinstance(fields, dict):
        return ((k, v) for k, v in six.iteritems(fields))

    return ((k, v) for k, v in fields)


def encode_multipart_formdata(fields, boundary=None):
    """"""
    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.

    :param fields:
        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).

    :param boundary:
        If not specified, then a random boundary will be generated using
        :func:`urllib3.filepost.choose_boundary`.
    """"""
    body = BytesIO()
    if boundary is None:
        boundary = choose_boundary()

    for field in iter_field_objects(fields):
        body.write(b(""--%s\r\n"" % (boundary)))

        writer(body).write(field.render_headers())
        data = field.data

        if isinstance(data, int):
            data = str(data)  # Backwards compatibility

        if isinstance(data, six.text_type):
            writer(body).write(data)
        else:
            body.write(data)

        body.write(b""\r\n"")

    body.write(b(""--%s--\r\n"" % (boundary)))

    content_type = str(""multipart/form-data; boundary=%s"" % boundary)

    return body.getvalue(), content_type",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR VAR VAR VAR .VAR.VAR VAR VAR VAR = VAR.VAR(""VAR-8"")[3] VAR VAR(): """""" VAR VAR-VAR VAR VAR VAR.VAR. """""" VAR = VAR.VAR(VAR.VAR(16)) VAR VAR VAR.VAR: VAR = VAR.VAR(""VAR"") VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR, VAR VAR VAR :VAR:`~VAR.VAR.VAR`. """""" VAR VAR(VAR, VAR): VAR = VAR.VAR(VAR) VAR: VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR.VAR(*VAR) VAR VAR(VAR): """""" .. VAR:: 1.6 VAR VAR VAR. VAR VAR VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR VAR. VAR, VAR :VAR:`VAR`, VAR VAR :VAR:`~VAR.VAR.VAR` VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR ((VAR, VAR) VAR VAR, VAR VAR VAR.VAR(VAR)) VAR ((VAR, VAR) VAR VAR, VAR VAR VAR) VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR ``VAR`` VAR VAR VAR/VAR-VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR (VAR, :VAR:`~VAR.VAR.VAR`). :VAR VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR`. """""" VAR = VAR() VAR VAR VAR VAR: VAR = VAR() VAR VAR VAR VAR(VAR): VAR.VAR(VAR(""--%VAR\VAR\VAR"" % (VAR))) VAR(VAR).VAR(VAR.VAR()) VAR = VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR)  VAR VAR(VAR, VAR.VAR): VAR(VAR).VAR(VAR) VAR: VAR.VAR(VAR) VAR.VAR(VAR""\VAR\VAR"") VAR.VAR(VAR(""--%VAR--\VAR\VAR"" % (VAR))) VAR = VAR(""VAR/VAR-VAR; VAR=%VAR"" % VAR) VAR VAR.VAR(), VAR ",1,15
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,src/urllib3/response.py,"from __future__ import absolute_import

import io
import logging
import zlib
from contextlib import contextmanager
from socket import error as SocketError
from socket import timeout as SocketTimeout

try:
    import brotli
except ImportError:
    brotli = None

from ._collections import HTTPHeaderDict
from .connection import BaseSSLError, HTTPException
from .exceptions import (
    BodyNotHttplibCompatible,
    DecodeError,
    HTTPError,
    IncompleteRead,
    InvalidChunkLength,
    InvalidHeader,
    ProtocolError,
    ReadTimeoutError,
    ResponseNotChunked,
    SSLError,
)
from .packages import six
from .util.response import is_fp_closed, is_response_to_head

log = logging.getLogger(__name__)


class DeflateDecoder(object):
    def __init__(self):
        self._first_try = True
        self._data = b""""
        self._obj = zlib.decompressobj()

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        if not data:
            return data

        if not self._first_try:
            return self._obj.decompress(data)

        self._data += data
        try:
            decompressed = self._obj.decompress(data)
            if decompressed:
                self._first_try = False
                self._data = None
            return decompressed
        except zlib.error:
            self._first_try = False
            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
            try:
                return self.decompress(self._data)
            finally:
                self._data = None


class GzipDecoderState(object):

    FIRST_MEMBER = 0
    OTHER_MEMBERS = 1
    SWALLOW_DATA = 2


class GzipDecoder(object):
    def __init__(self):
        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
        self._state = GzipDecoderState.FIRST_MEMBER

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        ret = bytearray()
        if self._state == GzipDecoderState.SWALLOW_DATA or not data:
            return bytes(ret)
        while True:
            try:
                ret += self._obj.decompress(data)
            except zlib.error:
                previous_state = self._state
                # Ignore data after the first error
                self._state = GzipDecoderState.SWALLOW_DATA
                if previous_state == GzipDecoderState.OTHER_MEMBERS:
                    # Allow trailing garbage acceptable in other gzip clients
                    return bytes(ret)
                raise
            data = self._obj.unused_data
            if not data:
                return bytes(ret)
            self._state = GzipDecoderState.OTHER_MEMBERS
            self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)


if brotli is not None:

    class BrotliDecoder(object):
        # Supports both 'brotlipy' and 'Brotli' packages
        # since they share an import name. The top branches
        # are for 'brotlipy' and bottom branches for 'Brotli'
        def __init__(self):
            self._obj = brotli.Decompressor()
            if hasattr(self._obj, ""decompress""):
                self.decompress = self._obj.decompress
            else:
                self.decompress = self._obj.process

        def flush(self):
            if hasattr(self._obj, ""flush""):
                return self._obj.flush()
            return b""""


class MultiDecoder(object):
    """"""
    From RFC7231:
        If one or more encodings have been applied to a representation, the
        sender that applied the encodings MUST generate a Content-Encoding
        header field that lists the content codings in the order in which
        they were applied.
    """"""

    def __init__(self, modes):
        self._decoders = [_get_decoder(m.strip()) for m in modes.split("","")]

    def flush(self):
        return self._decoders[0].flush()

    def decompress(self, data):
        for d in reversed(self._decoders):
            data = d.decompress(data)
        return data


def _get_decoder(mode):
    if "","" in mode:
        return MultiDecoder(mode)

    if mode == ""gzip"":
        return GzipDecoder()

    if brotli is not None and mode == ""br"":
        return BrotliDecoder()

    return DeflateDecoder()


class HTTPResponse(io.IOBase):
    """"""
    HTTP Response container.

    Backwards-compatible with :class:`http.client.HTTPResponse` but the response ``body`` is
    loaded and decoded on-demand when the ``data`` property is accessed.  This
    class is also compatible with the Python standard library's :mod:`io`
    module, and can hence be treated as a readable object in the context of that
    framework.

    Extra parameters for behaviour not present in :class:`http.client.HTTPResponse`:

    :param preload_content:
        If True, the response's body will be preloaded during construction.

    :param decode_content:
        If True, will attempt to decode the body based on the
        'content-encoding' header.

    :param original_response:
        When this HTTPResponse wrapper is generated from an :class:`http.client.HTTPResponse`
        object, it's convenient to include the original for debug purposes. It's
        otherwise unused.

    :param retries:
        The retries contains the last :class:`~urllib3.util.retry.Retry` that
        was used during the request.

    :param enforce_content_length:
        Enforce content length checking. Body returned by server must match
        value of Content-Length header, if present. Otherwise, raise error.
    """"""

    CONTENT_DECODERS = [""gzip"", ""deflate""]
    if brotli is not None:
        CONTENT_DECODERS += [""br""]
    REDIRECT_STATUSES = [301, 302, 303, 307, 308]

    def __init__(
        self,
        body="""",
        headers=None,
        status=0,
        version=0,
        reason=None,
        strict=0,
        preload_content=True,
        decode_content=True,
        original_response=None,
        pool=None,
        connection=None,
        msg=None,
        retries=None,
        enforce_content_length=False,
        request_method=None,
        request_url=None,
        auto_close=True,
    ):

        if isinstance(headers, HTTPHeaderDict):
            self.headers = headers
        else:
            self.headers = HTTPHeaderDict(headers)
        self.status = status
        self.version = version
        self.reason = reason
        self.strict = strict
        self.decode_content = decode_content
        self.retries = retries
        self.enforce_content_length = enforce_content_length
        self.auto_close = auto_close

        self._decoder = None
        self._body = None
        self._fp = None
        self._original_response = original_response
        self._fp_bytes_read = 0
        self.msg = msg
        self._request_url = request_url

        if body and isinstance(body, (six.string_types, bytes)):
            self._body = body

        self._pool = pool
        self._connection = connection

        if hasattr(body, ""read""):
            self._fp = body

        # Are we using the chunked-style of transfer encoding?
        self.chunked = False
        self.chunk_left = None
        tr_enc = self.headers.get(""transfer-encoding"", """").lower()
        # Don't incur the penalty of creating a list and then discarding it
        encodings = (enc.strip() for enc in tr_enc.split("",""))
        if ""chunked"" in encodings:
            self.chunked = True

        # Determine length of response
        self.length_remaining = self._init_length(request_method)

        # If requested, preload the body.
        if preload_content and not self._body:
            self._body = self.read(decode_content=decode_content)

    def get_redirect_location(self):
        """"""
        Should we redirect and where to?

        :returns: Truthy redirect location string if we got a redirect status
            code and valid location. ``None`` if redirect status and no
            location. ``False`` if not a redirect status code.
        """"""
        if self.status in self.REDIRECT_STATUSES:
            return self.headers.get(""location"")

        return False

    def release_conn(self):
        if not self._pool or not self._connection:
            return

        self._pool._put_conn(self._connection)
        self._connection = None

    def drain_conn(self):
        """"""
        Read and discard any remaining HTTP response data in the response connection.

        Unread data in the HTTPResponse connection blocks the connection from being released back to the pool.
        """"""
        try:
            self.read()
        except (HTTPError, SocketError, BaseSSLError, HTTPException):
            pass

    @property
    def data(self):
        # For backwards-compat with earlier urllib3 0.4 and earlier.
        if self._body:
            return self._body

        if self._fp:
            return self.read(cache_content=True)

    @property
    def connection(self):
        return self._connection

    def isclosed(self):
        return is_fp_closed(self._fp)

    def tell(self):
        """"""
        Obtain the number of bytes pulled over the wire so far. May differ from
        the amount of content returned by :meth:``urllib3.response.HTTPResponse.read``
        if bytes are encoded on the wire (e.g, compressed).
        """"""
        return self._fp_bytes_read

    def _init_length(self, request_method):
        """"""
        Set initial length value for Response content if available.
        """"""
        length = self.headers.get(""content-length"")

        if length is not None:
            if self.chunked:
                # This Response will fail with an IncompleteRead if it can't be
                # received as chunked. This method falls back to attempt reading
                # the response before raising an exception.
                log.warning(
                    ""Received response with both Content-Length and ""
                    ""Transfer-Encoding set. This is expressly forbidden ""
                    ""by RFC 7230 sec 3.3.2. Ignoring Content-Length and ""
                    ""attempting to process response as Transfer-Encoding: ""
                    ""chunked.""
                )
                return None

            try:
                # RFC 7230 section 3.3.2 specifies multiple content lengths can
                # be sent in a single Content-Length header
                # (e.g. Content-Length: 42, 42). This line ensures the values
                # are all valid ints and that as long as the `set` length is 1,
                # all values are the same. Otherwise, the header is invalid.
                lengths = set([int(val) for val in length.split("","")])
                if len(lengths) > 1:
                    raise InvalidHeader(
                        ""Content-Length contained multiple ""
                        ""unmatching values (%s)"" % length
                    )
                length = lengths.pop()
            except ValueError:
                length = None
            else:
                if length < 0:
                    length = None

        # Convert status to int for comparison
        # In some cases, httplib returns a status of ""_UNKNOWN""
        try:
            status = int(self.status)
        except ValueError:
            status = 0

        # Check for responses that shouldn't include a body
        if status in (204, 304) or 100 <= status < 200 or request_method == ""HEAD"":
            length = 0

        return length

    def _init_decoder(self):
        """"""
        Set-up the _decoder attribute if necessary.
        """"""
        # Note: content-encoding value should be case-insensitive, per RFC 7230
        # Section 3.2
        content_encoding = self.headers.get(""content-encoding"", """").lower()
        if self._decoder is None:
            if content_encoding in self.CONTENT_DECODERS:
                self._decoder = _get_decoder(content_encoding)
            elif "","" in content_encoding:
                encodings = [
                    e.strip()
                    for e in content_encoding.split("","")
                    if e.strip() in self.CONTENT_DECODERS
                ]
                if len(encodings):
                    self._decoder = _get_decoder(content_encoding)

    DECODER_ERROR_CLASSES = (IOError, zlib.error)
    if brotli is not None:
        DECODER_ERROR_CLASSES += (brotli.error,)

    def _decode(self, data, decode_content, flush_decoder):
        """"""
        Decode the data passed in and potentially flush the decoder.
        """"""
        if not decode_content:
            return data

        try:
            if self._decoder:
                data = self._decoder.decompress(data)
        except self.DECODER_ERROR_CLASSES as e:
            content_encoding = self.headers.get(""content-encoding"", """").lower()
            raise DecodeError(
                ""Received response with content-encoding: %s, but ""
                ""failed to decode it."" % content_encoding,
                e,
            )
        if flush_decoder:
            data += self._flush_decoder()

        return data

    def _flush_decoder(self):
        """"""
        Flushes the decoder. Should only be called if the decoder is actually
        being used.
        """"""
        if self._decoder:
            buf = self._decoder.decompress(b"""")
            return buf + self._decoder.flush()

        return b""""

    @contextmanager
    def _error_catcher(self):
        """"""
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.

        On exit, release the connection back to the pool.
        """"""
        clean_exit = False

        try:
            try:
                yield

            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, ""Read timed out."")

            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if ""read operation timed out"" not in str(e):
                    # SSL errors related to framing/MAC get wrapped and reraised here
                    raise SSLError(e)

                raise ReadTimeoutError(self._pool, None, ""Read timed out."")

            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
                raise ProtocolError(""Connection broken: %r"" % e, e)

            # If no exception is thrown, we should avoid cleaning up
            # unnecessarily.
            clean_exit = True
        finally:
            # If we didn't terminate cleanly, we need to throw away our
            # connection.
            if not clean_exit:
                # The response may not be closed but we're not going to use it
                # anymore so close it now to ensure that the connection is
                # released back to the pool.
                if self._original_response:
                    self._original_response.close()

                # Closing the response may not actually be sufficient to close
                # everything, so if we have a hold of the connection close that
                # too.
                if self._connection:
                    self._connection.close()

            # If we hold the original response but it's closed now, we should
            # return the connection back to the pool.
            if self._original_response and self._original_response.isclosed():
                self.release_conn()

    def read(self, amt=None, decode_content=None, cache_content=False):
        """"""
        Similar to :meth:`http.client.HTTPResponse.read`, but with two additional
        parameters: ``decode_content`` and ``cache_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.

        :param cache_content:
            If True, will save the returned data such that the same result is
            returned despite of the state of the underlying file object. This
            is useful if you want the ``.data`` property to continue working
            after having ``.read()`` the file object. (Overridden if ``amt`` is
            set.)
        """"""
        self._init_decoder()
        if decode_content is None:
            decode_content = self.decode_content

        if self._fp is None:
            return

        flush_decoder = False
        fp_closed = getattr(self._fp, ""closed"", False)

        with self._error_catcher():
            if amt is None:
                # cStringIO doesn't like amt=None
                data = self._fp.read() if not fp_closed else b""""
                flush_decoder = True
            else:
                cache_content = False
                data = self._fp.read(amt) if not fp_closed else b""""
                if (
                    amt != 0 and not data
                ):  # Platform-specific: Buggy versions of Python.
                    # Close the connection when no data is returned
                    #
                    # This is redundant to what httplib/http.client _should_
                    # already do.  However, versions of python released before
                    # December 15, 2012 (http://bugs.python.org/issue16298) do
                    # not properly close the connection in all cases. There is
                    # no harm in redundantly calling close.
                    self._fp.close()
                    flush_decoder = True
                    if self.enforce_content_length and self.length_remaining not in (
                        0,
                        None,
                    ):
                        # This is an edge case that httplib failed to cover due
                        # to concerns of backward compatibility. We're
                        # addressing it here to make sure IncompleteRead is
                        # raised during streaming, so all calls with incorrect
                        # Content-Length are caught.
                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)

        if data:
            self._fp_bytes_read += len(data)
            if self.length_remaining is not None:
                self.length_remaining -= len(data)

            data = self._decode(data, decode_content, flush_decoder)

            if cache_content:
                self._body = data

        return data

    def stream(self, amt=2 ** 16, decode_content=None):
        """"""
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.

        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        if self.chunked and self.supports_chunked_reads():
            for line in self.read_chunked(amt, decode_content=decode_content):
                yield line
        else:
            while not is_fp_closed(self._fp):
                data = self.read(amt=amt, decode_content=decode_content)

                if data:
                    yield data

    @classmethod
    def from_httplib(ResponseCls, r, **response_kw):
        """"""
        Given an :class:`http.client.HTTPResponse` instance ``r``, return a
        corresponding :class:`urllib3.response.HTTPResponse` object.

        Remaining parameters are passed to the HTTPResponse constructor, along
        with ``original_response=r``.
        """"""
        headers = r.msg

        if not isinstance(headers, HTTPHeaderDict):
            if six.PY2:
                # Python 2.7
                headers = HTTPHeaderDict.from_httplib(headers)
            else:
                headers = HTTPHeaderDict(headers.items())

        # HTTPResponse objects in Python 3 don't have a .strict attribute
        strict = getattr(r, ""strict"", 0)
        resp = ResponseCls(
            body=r,
            headers=headers,
            status=r.status,
            version=r.version,
            reason=r.reason,
            strict=strict,
            original_response=r,
            **response_kw
        )
        return resp

    # Backwards-compatibility methods for http.client.HTTPResponse
    def getheaders(self):
        return self.headers

    def getheader(self, name, default=None):
        return self.headers.get(name, default)

    # Backwards compatibility for http.cookiejar
    def info(self):
        return self.headers

    # Overrides from io.IOBase
    def close(self):
        if not self.closed:
            self._fp.close()

        if self._connection:
            self._connection.close()

        if not self.auto_close:
            io.IOBase.close(self)

    @property
    def closed(self):
        if not self.auto_close:
            return io.IOBase.closed.__get__(self)
        elif self._fp is None:
            return True
        elif hasattr(self._fp, ""isclosed""):
            return self._fp.isclosed()
        elif hasattr(self._fp, ""closed""):
            return self._fp.closed
        else:
            return True

    def fileno(self):
        if self._fp is None:
            raise IOError(""HTTPResponse has no file to get a fileno from"")
        elif hasattr(self._fp, ""fileno""):
            return self._fp.fileno()
        else:
            raise IOError(
                ""The file-like object this HTTPResponse is wrapped ""
                ""around has no file descriptor""
            )

    def flush(self):
        if (
            self._fp is not None
            and hasattr(self._fp, ""flush"")
            and not getattr(self._fp, ""closed"", False)
        ):
            return self._fp.flush()

    def readable(self):
        # This method is required for `io` module compatibility.
        return True

    def readinto(self, b):
        # This method is required for `io` module compatibility.
        temp = self.read(len(b))
        if len(temp) == 0:
            return 0
        else:
            b[: len(temp)] = temp
            return len(temp)

    def supports_chunked_reads(self):
        """"""
        Checks if the underlying file-like object looks like a
        :class:`http.client.HTTPResponse` object. We do this by testing for
        the fp attribute. If it is present we assume it returns raw chunks as
        processed by read_chunked().
        """"""
        return hasattr(self._fp, ""fp"")

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b"";"", 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
            raise InvalidChunkLength(self, line)

    def _handle_chunk(self, amt):
        returned_chunk = None
        if amt is None:
            chunk = self._fp._safe_read(self.chunk_left)
            returned_chunk = chunk
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        elif amt < self.chunk_left:
            value = self._fp._safe_read(amt)
            self.chunk_left = self.chunk_left - amt
            returned_chunk = value
        elif amt == self.chunk_left:
            value = self._fp._safe_read(amt)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
            returned_chunk = value
        else:  # amt > self.chunk_left
            returned_chunk = self._fp._safe_read(self.chunk_left)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        return returned_chunk

    def read_chunked(self, amt=None, decode_content=None):
        """"""
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                ""Response is not chunked. ""
                ""Header 'transfer-encoding: chunked' is missing.""
            )
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                ""Body should be http.client.HTTPResponse like. ""
                ""It should have have an fp attribute which returns raw chunks.""
            )

        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return

            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return

            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(
                    chunk, decode_content=decode_content, flush_decoder=False
                )
                if decoded:
                    yield decoded

            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded

            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b""\r\n"":
                    break

            # We read everything; close the ""file"".
            if self._original_response:
                self._original_response.close()

    def geturl(self):
        """"""
        Returns the URL that was the source of this response.
        If the request that generated this response redirected, this method
        will return the final redirect location.
        """"""
        if self.retries is not None and len(self.retries.history):
            return self.retries.history[-1].redirect_location
        else:
            return self._request_url

    def __iter__(self):
        buffer = []
        for chunk in self.stream(decode_content=True):
            if b""\n"" in chunk:
                chunk = chunk.split(b""\n"")
                yield b"""".join(buffer) + chunk[0] + b""\n""
                for x in chunk[1:-1]:
                    yield x + b""\n""
                if chunk[-1]:
                    buffer = [chunk[-1]]
                else:
                    buffer = []
            else:
                buffer.append(chunk)
        if buffer:
            yield b"""".join(buffer)",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR: VAR = VAR VAR .VAR VAR VAR VAR .VAR VAR VAR, VAR VAR .VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR .VAR VAR VAR VAR .VAR.VAR VAR VAR, VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR VAR.VAR = VAR"""" VAR.VAR = VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR) VAR.VAR += VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR: VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR VAR.VAR = VAR.VAR(-VAR.VAR) VAR: VAR VAR.VAR(VAR.VAR) VAR: VAR.VAR = VAR VAR VAR(VAR): VAR = 0 VAR = 1 VAR = 2 VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR.VAR = VAR.VAR VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR = VAR() VAR VAR.VAR == VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR VAR: VAR: VAR += VAR.VAR.VAR(VAR) VAR VAR.VAR: VAR = VAR.VAR  VAR.VAR = VAR.VAR VAR VAR == VAR.VAR:  VAR VAR(VAR) VAR VAR = VAR.VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR.VAR = VAR.VAR VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR VAR VAR VAR VAR: VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR.VAR() VAR VAR(VAR.VAR, ""VAR""): VAR.VAR = VAR.VAR.VAR VAR: VAR.VAR = VAR.VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR VAR"""" VAR VAR(VAR): """""" VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = [VAR(VAR.VAR()) VAR VAR VAR VAR.VAR("","")] VAR VAR(VAR): VAR VAR.VAR[0].VAR() VAR VAR(VAR, VAR): VAR VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR "","" VAR VAR: VAR VAR(VAR) VAR VAR == ""VAR"": VAR VAR() VAR VAR VAR VAR VAR VAR VAR == ""VAR"": VAR VAR() VAR VAR() VAR VAR(VAR.VAR): """""" VAR VAR VAR. VAR-VAR VAR :VAR:`VAR.VAR.VAR` VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR-VAR VAR VAR ``VAR`` VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR :VAR:`VAR` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR`: :VAR VAR: VAR VAR, VAR VAR'VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR'VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR, VAR VAR. VAR, VAR VAR. """""" VAR = [""VAR"", ""VAR""] VAR VAR VAR VAR VAR: VAR += [""VAR""] VAR = [301, 302, 303, 307, 308] VAR VAR( VAR, VAR="""", VAR=VAR, VAR=0, VAR=0, VAR=VAR, VAR=0, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, ): VAR VAR(VAR, VAR): VAR.VAR = VAR VAR: VAR.VAR = VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR(VAR, (VAR.VAR, VAR)): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, ""VAR""): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR VAR = VAR.VAR.VAR(""VAR-VAR"", """").VAR()  VAR = (VAR.VAR() VAR VAR VAR VAR.VAR("","")) VAR ""VAR"" VAR VAR: VAR.VAR = VAR  VAR.VAR = VAR.VAR(VAR)  VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR.VAR(VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR? :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR.VAR(""VAR"") VAR VAR VAR VAR(VAR): VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR.VAR) VAR.VAR = VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR: VAR.VAR() VAR (VAR, VAR, VAR, VAR): VAR @VAR VAR VAR(VAR):  VAR VAR.VAR: VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR(VAR=VAR) @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:``VAR.VAR.VAR.VAR`` VAR VAR VAR VAR VAR VAR VAR (VAR.VAR, VAR). """""" VAR VAR.VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR(""VAR-VAR"") VAR VAR VAR VAR VAR: VAR VAR.VAR:    VAR.VAR( ""VAR VAR VAR VAR VAR-VAR VAR "" ""VAR-VAR VAR. VAR VAR VAR VAR "" ""VAR VAR 7230 VAR 3.3.2. VAR VAR-VAR VAR "" ""VAR VAR VAR VAR VAR VAR-VAR: "" ""VAR."" ) VAR VAR VAR:      VAR = VAR([VAR(VAR) VAR VAR VAR VAR.VAR("","")]) VAR VAR(VAR) > 1: VAR VAR( ""VAR-VAR VAR VAR "" ""VAR VAR (%VAR)"" % VAR ) VAR = VAR.VAR() VAR VAR: VAR = VAR VAR: VAR VAR < 0: VAR = VAR   VAR: VAR = VAR(VAR.VAR) VAR VAR: VAR = 0  VAR VAR VAR (204, 304) VAR 100 <= VAR < 200 VAR VAR == ""VAR"": VAR = 0 VAR VAR VAR VAR(VAR): """""" VAR-VAR VAR VAR VAR VAR VAR. """"""   VAR = VAR.VAR.VAR(""VAR-VAR"", """").VAR() VAR VAR.VAR VAR VAR: VAR VAR VAR VAR.VAR: VAR.VAR = VAR(VAR) VAR "","" VAR VAR: VAR = [ VAR.VAR() VAR VAR VAR VAR.VAR("","") VAR VAR.VAR() VAR VAR.VAR ] VAR VAR(VAR): VAR.VAR = VAR(VAR) VAR = (VAR, VAR.VAR) VAR VAR VAR VAR VAR: VAR += (VAR.VAR,) VAR VAR(VAR, VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR VAR: VAR VAR VAR: VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR.VAR VAR VAR: VAR = VAR.VAR.VAR(""VAR-VAR"", """").VAR() VAR VAR( ""VAR VAR VAR VAR-VAR: %VAR, VAR "" ""VAR VAR VAR VAR."" % VAR, VAR, ) VAR VAR: VAR += VAR.VAR() VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR"""") VAR VAR + VAR.VAR.VAR() VAR VAR"""" @VAR VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR, VAR VAR-VAR VAR VAR, VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR VAR: VAR: VAR VAR VAR:   VAR VAR(VAR.VAR, VAR, ""VAR VAR VAR."") VAR VAR VAR VAR:  VAR ""VAR VAR VAR VAR"" VAR VAR VAR(VAR):  VAR VAR(VAR) VAR VAR(VAR.VAR, VAR, ""VAR VAR VAR."") VAR (VAR, VAR) VAR VAR:  VAR VAR(""VAR VAR: %VAR"" % VAR, VAR)   VAR = VAR VAR:   VAR VAR VAR:    VAR VAR.VAR: VAR.VAR.VAR()    VAR VAR.VAR: VAR.VAR.VAR()   VAR VAR.VAR VAR VAR.VAR.VAR(): VAR.VAR() VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR.VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR`` VAR ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR ``.VAR`` VAR VAR VAR VAR VAR VAR ``.VAR()`` VAR VAR VAR. (VAR VAR ``VAR`` VAR VAR.) """""" VAR.VAR() VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR.VAR VAR VAR: VAR VAR = VAR VAR = VAR(VAR.VAR, ""VAR"", VAR) VAR VAR.VAR(): VAR VAR VAR VAR:  VAR = VAR.VAR.VAR() VAR VAR VAR VAR VAR"""" VAR = VAR VAR: VAR = VAR VAR = VAR.VAR.VAR(VAR) VAR VAR VAR VAR VAR"""" VAR ( VAR != 0 VAR VAR VAR ):         VAR.VAR.VAR() VAR = VAR VAR VAR.VAR VAR VAR.VAR VAR VAR ( 0, VAR, ):      VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR += VAR(VAR) VAR VAR.VAR VAR VAR VAR: VAR.VAR -= VAR(VAR) VAR = VAR.VAR(VAR, VAR, VAR) VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=2 ** 16, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR() VAR. VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR VAR.VAR VAR VAR.VAR(): VAR VAR VAR VAR.VAR(VAR, VAR=VAR): VAR VAR VAR: VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR=VAR, VAR=VAR) VAR VAR: VAR VAR @VAR VAR VAR(VAR, VAR, **VAR): """""" VAR VAR :VAR:`VAR.VAR.VAR` VAR ``VAR``, VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR ``VAR=VAR``. """""" VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR VAR.VAR:  VAR = VAR.VAR(VAR) VAR: VAR = VAR(VAR.VAR())  VAR = VAR(VAR, ""VAR"", 0) VAR = VAR( VAR=VAR, VAR=VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR, **VAR ) VAR VAR  VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR, VAR, VAR=VAR): VAR VAR.VAR.VAR(VAR, VAR)  VAR VAR(VAR): VAR VAR.VAR  VAR VAR(VAR): VAR VAR VAR.VAR: VAR.VAR.VAR() VAR VAR.VAR: VAR.VAR.VAR() VAR VAR VAR.VAR: VAR.VAR.VAR(VAR) @VAR VAR VAR(VAR): VAR VAR VAR.VAR: VAR VAR.VAR.VAR.VAR(VAR) VAR VAR.VAR VAR VAR: VAR VAR VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR VAR: VAR VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR: VAR VAR( ""VAR VAR-VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR"" ) VAR VAR(VAR): VAR ( VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR, ""VAR"") VAR VAR VAR(VAR.VAR, ""VAR"", VAR) ): VAR VAR.VAR.VAR() VAR VAR(VAR):  VAR VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR(VAR(VAR)) VAR VAR(VAR) == 0: VAR 0 VAR: VAR[: VAR(VAR)] = VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR(). """""" VAR VAR(VAR.VAR, ""VAR"") VAR VAR(VAR):   VAR VAR.VAR VAR VAR VAR: VAR VAR = VAR.VAR.VAR.VAR() VAR = VAR.VAR(VAR"";"", 1)[0] VAR: VAR.VAR = VAR(VAR, 16) VAR VAR:  VAR.VAR() VAR VAR(VAR, VAR) VAR VAR(VAR, VAR): VAR = VAR VAR VAR VAR VAR: VAR = VAR.VAR.VAR(VAR.VAR) VAR = VAR VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR < VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR = VAR.VAR - VAR VAR = VAR VAR VAR == VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR = VAR VAR:  VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR.VAR()  VAR VAR VAR.VAR: VAR VAR( ""VAR VAR VAR VAR. "" ""VAR 'VAR-VAR: VAR' VAR VAR."" ) VAR VAR VAR.VAR(): VAR VAR( ""VAR VAR VAR VAR.VAR.VAR VAR. "" ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."" ) VAR VAR.VAR():  VAR VAR.VAR VAR VAR(VAR.VAR): VAR.VAR.VAR() VAR   VAR VAR.VAR.VAR VAR VAR: VAR VAR VAR: VAR.VAR() VAR VAR.VAR == 0: VAR VAR = VAR.VAR(VAR) VAR = VAR.VAR( VAR, VAR=VAR, VAR=VAR ) VAR VAR: VAR VAR VAR VAR:    VAR = VAR.VAR() VAR VAR:  VAR VAR  VAR VAR: VAR = VAR.VAR.VAR.VAR() VAR VAR VAR:  VAR VAR VAR == VAR""\VAR\VAR"": VAR  VAR VAR.VAR: VAR.VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR.VAR): VAR VAR.VAR.VAR[-1].VAR VAR: VAR VAR.VAR VAR VAR(VAR): VAR = [] VAR VAR VAR VAR.VAR(VAR=VAR): VAR VAR""\VAR"" VAR VAR: VAR = VAR.VAR(VAR""\VAR"") VAR VAR"""".VAR(VAR) + VAR[0] + VAR""\VAR"" VAR VAR VAR VAR[1:-1]: VAR VAR + VAR""\VAR"" VAR VAR[-1]: VAR = [VAR[-1]] VAR: VAR = [] VAR: VAR.VAR(VAR) VAR VAR: VAR VAR"""".VAR(VAR) ",1,15
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,test/test_response.py,"# -*- coding: utf-8 -*-

import contextlib
import re
import socket
import ssl
import zlib
from base64 import b64decode
from io import BufferedReader, BytesIO, TextIOWrapper
from test import onlyBrotlipy

import mock
import pytest
import six

from urllib3.exceptions import (
    DecodeError,
    IncompleteRead,
    InvalidChunkLength,
    InvalidHeader,
    ProtocolError,
    ResponseNotChunked,
    SSLError,
    httplib_IncompleteRead,
)
from urllib3.packages.six.moves import http_client as httplib
from urllib3.response import HTTPResponse, brotli
from urllib3.util.response import is_fp_closed
from urllib3.util.retry import RequestHistory, Retry

# A known random (i.e, not-too-compressible) payload generated with:
#    """".join(random.choice(string.printable) for i in xrange(512))
#    .encode(""zlib"").encode(""base64"")
# Randomness in tests == bad, and fixing a seed may not be sufficient.
ZLIB_PAYLOAD = b64decode(
    b""""""\
eJwFweuaoQAAANDfineQhiKLUiaiCzvuTEmNNlJGiL5QhnGpZ99z8luQfe1AHoMioB+QSWHQu/L+
lzd7W5CipqYmeVTBjdgSATdg4l4Z2zhikbuF+EKn69Q0DTpdmNJz8S33odfJoVEexw/l2SS9nFdi
pis7KOwXzfSqarSo9uJYgbDGrs1VNnQpT9f8zAorhYCEZronZQF9DuDFfNK3Hecc+WHLnZLQptwk
nufw8S9I43sEwxsT71BiqedHo0QeIrFE01F/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/nNvDGKZ
Khe5TF36JbnKVjdcL1EUNpwrWVfQpFYJ/WWm2b74qNeSZeQv5/xBhRdOmKTJFYgO96PwrHBlsnLn
a3l0LwJsloWpMbzByU5WLbRE6X5INFqjQOtIwYz5BAlhkn+kVqJvWM5vBlfrwP42ifonM5yF4ciJ
auHVks62997mNGOsM7WXNG3P98dBHPo2NhbTvHleL0BI5dus2JY81MUOnK3SGWLH8HeWPa1t5KcW
S5moAj5HexY/g/F8TctpxwsvyZp38dXeLDjSQvEQIkF7XR3YXbeZgKk3V34KGCPOAeeuQDIgyVhV
nP4HF2uWHA==""""""
)


@pytest.fixture
def sock():
    s = socket.socket()
    yield s
    s.close()


class TestLegacyResponse(object):
    def test_getheaders(self):
        headers = {""host"": ""example.com""}
        r = HTTPResponse(headers=headers)
        assert r.getheaders() == headers

    def test_getheader(self):
        headers = {""host"": ""example.com""}
        r = HTTPResponse(headers=headers)
        assert r.getheader(""host"") == ""example.com""


class TestResponse(object):
    def test_cache_content(self):
        r = HTTPResponse(""foo"")
        assert r.data == ""foo""
        assert r._body == ""foo""

    def test_default(self):
        r = HTTPResponse()
        assert r.data is None

    def test_none(self):
        r = HTTPResponse(None)
        assert r.data is None

    def test_preload(self):
        fp = BytesIO(b""foo"")

        r = HTTPResponse(fp, preload_content=True)

        assert fp.tell() == len(b""foo"")
        assert r.data == b""foo""

    def test_no_preload(self):
        fp = BytesIO(b""foo"")

        r = HTTPResponse(fp, preload_content=False)

        assert fp.tell() == 0
        assert r.data == b""foo""
        assert fp.tell() == len(b""foo"")

    def test_decode_bad_data(self):
        fp = BytesIO(b""\x00"" * 10)
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={""content-encoding"": ""deflate""})

    def test_reference_read(self):
        fp = BytesIO(b""foo"")
        r = HTTPResponse(fp, preload_content=False)

        assert r.read(1) == b""f""
        assert r.read(2) == b""oo""
        assert r.read() == b""""
        assert r.read() == b""""

    def test_decode_deflate(self):
        data = zlib.compress(b""foo"")

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""deflate""})

        assert r.data == b""foo""

    def test_decode_deflate_case_insensitve(self):
        data = zlib.compress(b""foo"")

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""DeFlAtE""})

        assert r.data == b""foo""

    def test_chunked_decoding_deflate(self):
        data = zlib.compress(b""foo"")

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={""content-encoding"": ""deflate""}, preload_content=False
        )

        assert r.read(3) == b""""
        # Buffer in case we need to switch to the raw stream
        assert r._decoder._data is not None
        assert r.read(1) == b""f""
        # Now that we've decoded data, we just stream through the decoder
        assert r._decoder._data is None
        assert r.read(2) == b""oo""
        assert r.read() == b""""
        assert r.read() == b""""

    def test_chunked_decoding_deflate2(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={""content-encoding"": ""deflate""}, preload_content=False
        )

        assert r.read(1) == b""""
        assert r.read(1) == b""f""
        # Once we've decoded data, we just stream to the decoder; no buffering
        assert r._decoder._data is None
        assert r.read(2) == b""oo""
        assert r.read() == b""""
        assert r.read() == b""""

    def test_chunked_decoding_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={""content-encoding"": ""gzip""}, preload_content=False
        )

        assert r.read(11) == b""""
        assert r.read(1) == b""f""
        assert r.read(2) == b""oo""
        assert r.read() == b""""
        assert r.read() == b""""

    def test_decode_gzip_multi_member(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()
        data = data * 3

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""gzip""})

        assert r.data == b""foofoofoo""

    def test_decode_gzip_error(self):
        fp = BytesIO(b""foo"")
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={""content-encoding"": ""gzip""})

    def test_decode_gzip_swallow_garbage(self):
        # When data comes from multiple calls to read(), data after
        # the first zlib error (here triggered by garbage) should be
        # ignored.
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()
        data = data * 3 + b""foo""

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={""content-encoding"": ""gzip""}, preload_content=False
        )
        ret = b""""
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break

        assert ret == b""foofoofoo""

    def test_chunked_decoding_gzip_swallow_garbage(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()
        data = data * 3 + b""foo""

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""gzip""})

        assert r.data == b""foofoofoo""

    @onlyBrotlipy()
    def test_decode_brotli(self):
        data = brotli.compress(b""foo"")

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""br""})
        assert r.data == b""foo""

    @onlyBrotlipy()
    def test_chunked_decoding_brotli(self):
        data = brotli.compress(b""foobarbaz"")

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""br""}, preload_content=False)

        ret = b""""
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break
        assert ret == b""foobarbaz""

    @onlyBrotlipy()
    def test_decode_brotli_error(self):
        fp = BytesIO(b""foo"")
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={""content-encoding"": ""br""})

    def test_multi_decoding_deflate_deflate(self):
        data = zlib.compress(zlib.compress(b""foo""))

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""deflate, deflate""})

        assert r.data == b""foo""

    def test_multi_decoding_deflate_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(zlib.compress(b""foo""))
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""deflate, gzip""})

        assert r.data == b""foo""

    def test_multi_decoding_gzip_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()

        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(data)
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={""content-encoding"": ""gzip, gzip""})

        assert r.data == b""foo""

    def test_body_blob(self):
        resp = HTTPResponse(b""foo"")
        assert resp.data == b""foo""
        assert resp.closed

    def test_io(self, sock):
        fp = BytesIO(b""foo"")
        resp = HTTPResponse(fp, preload_content=False)

        assert not resp.closed
        assert resp.readable()
        assert not resp.writable()
        with pytest.raises(IOError):
            resp.fileno()

        resp.close()
        assert resp.closed

        # Try closing with an `httplib.HTTPResponse`, because it has an
        # `isclosed` method.
        try:
            hlr = httplib.HTTPResponse(sock)
            resp2 = HTTPResponse(hlr, preload_content=False)
            assert not resp2.closed
            resp2.close()
            assert resp2.closed
        finally:
            hlr.close()

        # also try when only data is present.
        resp3 = HTTPResponse(""foodata"")
        with pytest.raises(IOError):
            resp3.fileno()

        resp3._fp = 2
        # A corner case where _fp is present but doesn't have `closed`,
        # `isclosed`, or `fileno`.  Unlikely, but possible.
        assert resp3.closed
        with pytest.raises(IOError):
            resp3.fileno()

    def test_io_closed_consistently(self, sock):
        try:
            hlr = httplib.HTTPResponse(sock)
            hlr.fp = BytesIO(b""foo"")
            hlr.chunked = 0
            hlr.length = 3
            with HTTPResponse(hlr, preload_content=False) as resp:
                assert not resp.closed
                assert not resp._fp.isclosed()
                assert not is_fp_closed(resp._fp)
                assert not resp.isclosed()
                resp.read()
                assert resp.closed
                assert resp._fp.isclosed()
                assert is_fp_closed(resp._fp)
                assert resp.isclosed()
        finally:
            hlr.close()

    def test_io_bufferedreader(self):
        fp = BytesIO(b""foo"")
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp)

        assert br.read() == b""foo""

        br.close()
        assert resp.closed

        # HTTPResponse.read() by default closes the response
        # https://github.com/urllib3/urllib3/issues/1305
        fp = BytesIO(b""hello\nworld"")
        resp = HTTPResponse(fp, preload_content=False)
        with pytest.raises(ValueError) as ctx:
            list(BufferedReader(resp))
        assert str(ctx.value) == ""readline of closed file""

        b = b""fooandahalf""
        fp = BytesIO(b)
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp, 5)

        br.read(1)  # sets up the buffer, reading 5
        assert len(fp.read()) == (len(b) - 5)

        # This is necessary to make sure the ""no bytes left"" part of `readinto`
        # gets tested.
        while not br.closed:
            br.read(5)

    def test_io_not_autoclose_bufferedreader(self):
        fp = BytesIO(b""hello\nworld"")
        resp = HTTPResponse(fp, preload_content=False, auto_close=False)
        reader = BufferedReader(resp)
        assert list(reader) == [b""hello\n"", b""world""]

        assert not reader.closed
        assert not resp.closed
        with pytest.raises(StopIteration):
            next(reader)

        reader.close()
        assert reader.closed
        assert resp.closed
        with pytest.raises(ValueError) as ctx:
            next(reader)
        assert str(ctx.value) == ""readline of closed file""

    def test_io_textiowrapper(self):
        fp = BytesIO(b""\xc3\xa4\xc3\xb6\xc3\xbc\xc3\x9f"")
        resp = HTTPResponse(fp, preload_content=False)
        br = TextIOWrapper(resp, encoding=""utf8"")

        assert br.read() == u""äöüß""

        br.close()
        assert resp.closed

        # HTTPResponse.read() by default closes the response
        # https://github.com/urllib3/urllib3/issues/1305
        fp = BytesIO(
            b""\xc3\xa4\xc3\xb6\xc3\xbc\xc3\x9f\n\xce\xb1\xce\xb2\xce\xb3\xce\xb4""
        )
        resp = HTTPResponse(fp, preload_content=False)
        with pytest.raises(ValueError) as ctx:
            if six.PY2:
                # py2's implementation of TextIOWrapper requires `read1`
                # method which is provided by `BufferedReader` wrapper
                resp = BufferedReader(resp)
            list(TextIOWrapper(resp))
        assert re.match(""I/O operation on closed file.?"", str(ctx.value))

    def test_io_not_autoclose_textiowrapper(self):
        fp = BytesIO(
            b""\xc3\xa4\xc3\xb6\xc3\xbc\xc3\x9f\n\xce\xb1\xce\xb2\xce\xb3\xce\xb4""
        )
        resp = HTTPResponse(fp, preload_content=False, auto_close=False)
        if six.PY2:
            # py2's implementation of TextIOWrapper requires `read1`
            # method which is provided by `BufferedReader` wrapper
            resp = BufferedReader(resp)
        reader = TextIOWrapper(resp, encoding=""utf8"")
        assert list(reader) == [u""äöüß\n"", u""αβγδ""]

        assert not reader.closed
        assert not resp.closed
        with pytest.raises(StopIteration):
            next(reader)

        reader.close()
        assert reader.closed
        assert resp.closed
        with pytest.raises(ValueError) as ctx:
            next(reader)
        assert re.match(""I/O operation on closed file.?"", str(ctx.value))

    def test_streaming(self):
        fp = BytesIO(b""foo"")
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        assert next(stream) == b""fo""
        assert next(stream) == b""o""
        with pytest.raises(StopIteration):
            next(stream)

    def test_streaming_tell(self):
        fp = BytesIO(b""foo"")
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        position = 0

        position += len(next(stream))
        assert 2 == position
        assert position == resp.tell()

        position += len(next(stream))
        assert 3 == position
        assert position == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(
            fp, headers={""content-encoding"": ""gzip""}, preload_content=False
        )
        stream = resp.stream(2)

        assert next(stream) == b""f""
        assert next(stream) == b""oo""
        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming_tell(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        uncompressed_data = b""foo""
        data = compress.compress(uncompressed_data)
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(
            fp, headers={""content-encoding"": ""gzip""}, preload_content=False
        )
        stream = resp.stream()

        # Read everything
        payload = next(stream)
        assert payload == uncompressed_data

        assert len(data) == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate_streaming_tell_intermediate_point(self):
        # Ensure that ``tell()`` returns the correct number of bytes when
        # part-way through streaming compressed content.
        NUMBER_OF_READS = 10

        class MockCompressedDataReading(BytesIO):
            """"""
            A BytesIO-like reader returning ``payload`` in ``NUMBER_OF_READS``
            calls to ``read``.
            """"""

            def __init__(self, payload, payload_part_size):
                self.payloads = [
                    payload[i * payload_part_size : (i + 1) * payload_part_size]
                    for i in range(NUMBER_OF_READS + 1)
                ]

                assert b"""".join(self.payloads) == payload

            def read(self, _):
                # Amount is unused.
                if len(self.payloads) > 0:
                    return self.payloads.pop(0)
                return b""""

        uncompressed_data = zlib.decompress(ZLIB_PAYLOAD)

        payload_part_size = len(ZLIB_PAYLOAD) // NUMBER_OF_READS
        fp = MockCompressedDataReading(ZLIB_PAYLOAD, payload_part_size)
        resp = HTTPResponse(
            fp, headers={""content-encoding"": ""deflate""}, preload_content=False
        )
        stream = resp.stream()

        parts_positions = [(part, resp.tell()) for part in stream]
        end_of_stream = resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

        parts, positions = zip(*parts_positions)

        # Check that the payload is equal to the uncompressed data
        payload = b"""".join(parts)
        assert uncompressed_data == payload

        # Check that the positions in the stream are correct
        expected = [(i + 1) * payload_part_size for i in range(NUMBER_OF_READS)]
        assert expected == list(positions)

        # Check that the end of the stream is in the correct place
        assert len(ZLIB_PAYLOAD) == end_of_stream

    def test_deflate_streaming(self):
        data = zlib.compress(b""foo"")

        fp = BytesIO(data)
        resp = HTTPResponse(
            fp, headers={""content-encoding"": ""deflate""}, preload_content=False
        )
        stream = resp.stream(2)

        assert next(stream) == b""f""
        assert next(stream) == b""oo""
        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate2_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b""foo"")
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(
            fp, headers={""content-encoding"": ""deflate""}, preload_content=False
        )
        stream = resp.stream(2)

        assert next(stream) == b""f""
        assert next(stream) == b""oo""
        with pytest.raises(StopIteration):
            next(stream)

    def test_empty_stream(self):
        fp = BytesIO(b"""")
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        with pytest.raises(StopIteration):
            next(stream)

    def test_length_no_header(self):
        fp = BytesIO(b""12345"")
        resp = HTTPResponse(fp, preload_content=False)
        assert resp.length_remaining is None

    def test_length_w_valid_header(self):
        headers = {""content-length"": ""5""}
        fp = BytesIO(b""12345"")

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

    def test_length_w_bad_header(self):
        garbage = {""content-length"": ""foo""}
        fp = BytesIO(b""12345"")

        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

        garbage[""content-length""] = ""-10""
        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

    def test_length_when_chunked(self):
        # This is expressly forbidden in RFC 7230 sec 3.3.2
        # We fall back to chunked in this case and try to
        # handle response ignoring content length.
        headers = {""content-length"": ""5"", ""transfer-encoding"": ""chunked""}
        fp = BytesIO(b""12345"")

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining is None

    def test_length_with_multiple_content_lengths(self):
        headers = {""content-length"": ""5, 5, 5""}
        garbage = {""content-length"": ""5, 42""}
        fp = BytesIO(b""abcde"")

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

        with pytest.raises(InvalidHeader):
            HTTPResponse(fp, headers=garbage, preload_content=False)

    def test_length_after_read(self):
        headers = {""content-length"": ""5""}

        # Test no defined length
        fp = BytesIO(b""12345"")
        resp = HTTPResponse(fp, preload_content=False)
        resp.read()
        assert resp.length_remaining is None

        # Test our update from content-length
        fp = BytesIO(b""12345"")
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        resp.read()
        assert resp.length_remaining == 0

        # Test partial read
        fp = BytesIO(b""12345"")
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        data = resp.stream(2)
        next(data)
        assert resp.length_remaining == 3

    def test_mock_httpresponse_stream(self):
        # Mock out a HTTP Request that does enough to make it through urllib3's
        # read() and close() calls, and also exhausts and underlying file
        # object.
        class MockHTTPRequest(object):
            self.fp = None

            def read(self, amt):
                data = self.fp.read(amt)
                if not data:
                    self.fp = None

                return data

            def close(self):
                self.fp = None

        bio = BytesIO(b""foo"")
        fp = MockHTTPRequest()
        fp.fp = bio
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b""fo""
        assert next(stream) == b""o""
        with pytest.raises(StopIteration):
            next(stream)

    def test_mock_transfer_encoding_chunked(self):
        stream = [b""fo"", b""o"", b""bar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )

        for i, c in enumerate(resp.stream()):
            assert c == stream[i]

    def test_mock_gzipped_transfer_encoding_chunked_decoded(self):
        """"""Show that we can decode the gzipped and chunked body.""""""

        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b""foobar"")
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i : i + 2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {""transfer-encoding"": ""chunked"", ""content-encoding"": ""gzip""}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b""""
        for c in resp.stream(decode_content=True):
            data += c

        assert b""foobar"" == data

    def test_mock_transfer_encoding_chunked_custom_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        expected_response = [b""fo"", b""oo"", b""o"", b""bb"", b""bb"", b""aa"", b""aa"", b""ar""]
        response = list(resp.read_chunked(2))
        assert expected_response == response

    def test_mock_transfer_encoding_chunked_unlmtd_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        assert stream == list(resp.read_chunked())

    def test_read_not_chunked_response_as_chunks(self):
        fp = BytesIO(b""foo"")
        resp = HTTPResponse(fp, preload_content=False)
        r = resp.read_chunked()
        with pytest.raises(ResponseNotChunked):
            next(r)

    def test_buggy_incomplete_read(self):
        # Simulate buggy versions of Python (<2.7.4)
        # See http://bugs.python.org/issue16298
        content_length = 1337
        fp = BytesIO(b"""")
        resp = HTTPResponse(
            fp,
            headers={""content-length"": str(content_length)},
            preload_content=False,
            enforce_content_length=True,
        )
        with pytest.raises(ProtocolError) as ctx:
            resp.read(3)

        orig_ex = ctx.value.args[1]
        assert isinstance(orig_ex, IncompleteRead)
        assert orig_ex.partial == 0
        assert orig_ex.expected == content_length

    def test_incomplete_chunk(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedIncompleteRead(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        with pytest.raises(ProtocolError) as ctx:
            next(resp.read_chunked())

        orig_ex = ctx.value.args[1]
        assert isinstance(orig_ex, httplib_IncompleteRead)

    def test_invalid_chunk_length(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedInvalidChunkLength(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        with pytest.raises(ProtocolError) as ctx:
            next(resp.read_chunked())

        orig_ex = ctx.value.args[1]
        assert isinstance(orig_ex, InvalidChunkLength)
        assert orig_ex.length == six.b(fp.BAD_LENGTH_LINE)

    def test_chunked_response_without_crlf_on_end(self):
        stream = [b""foo"", b""bar"", b""baz""]
        fp = MockChunkedEncodingWithoutCRLFOnEnd(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        assert stream == list(resp.stream())

    def test_chunked_response_with_extensions(self):
        stream = [b""foo"", b""bar""]
        fp = MockChunkedEncodingWithExtensions(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            r, preload_content=False, headers={""transfer-encoding"": ""chunked""}
        )
        assert stream == list(resp.stream())

    def test_chunked_head_response(self):
        r = httplib.HTTPResponse(MockSock, method=""HEAD"")
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(
            """",
            preload_content=False,
            headers={""transfer-encoding"": ""chunked""},
            original_response=r,
        )
        assert resp.chunked is True

        resp.supports_chunked_reads = lambda: True
        resp.release_conn = mock.Mock()
        for _ in resp.stream():
            continue
        resp.release_conn.assert_called_once_with()

    def test_get_case_insensitive_headers(self):
        headers = {""host"": ""example.com""}
        r = HTTPResponse(headers=headers)
        assert r.headers.get(""host"") == ""example.com""
        assert r.headers.get(""Host"") == ""example.com""

    def test_retries(self):
        fp = BytesIO(b"""")
        resp = HTTPResponse(fp)
        assert resp.retries is None
        retry = Retry()
        resp = HTTPResponse(fp, retries=retry)
        assert resp.retries == retry

    def test_geturl(self):
        fp = BytesIO(b"""")
        request_url = ""https://example.com""
        resp = HTTPResponse(fp, request_url=request_url)
        assert resp.geturl() == request_url

    def test_geturl_retries(self):
        fp = BytesIO(b"""")
        resp = HTTPResponse(fp, request_url=""http://example.com"")
        request_histories = [
            RequestHistory(
                method=""GET"",
                url=""http://example.com"",
                error=None,
                status=301,
                redirect_location=""https://example.com/"",
            ),
            RequestHistory(
                method=""GET"",
                url=""https://example.com/"",
                error=None,
                status=301,
                redirect_location=""https://www.example.com"",
            ),
        ]
        retry = Retry(history=request_histories)
        resp = HTTPResponse(fp, retries=retry)
        assert resp.geturl() == ""https://www.example.com""

    @pytest.mark.parametrize(
        [""payload"", ""expected_stream""],
        [
            (b"""", []),
            (b""\n"", [b""\n""]),
            (b""\n\n\n"", [b""\n"", b""\n"", b""\n""]),
            (b""abc\ndef"", [b""abc\n"", b""def""]),
            (b""Hello\nworld\n\n\n!"", [b""Hello\n"", b""world\n"", b""\n"", b""\n"", b""!""]),
        ],
    )
    def test__iter__(self, payload, expected_stream):
        actual_stream = []
        for chunk in HTTPResponse(BytesIO(payload), preload_content=False):
            actual_stream.append(chunk)

        assert actual_stream == expected_stream

    def test__iter__decode_content(self):
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b""foo\nbar"")
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i : i + 2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {""transfer-encoding"": ""chunked"", ""content-encoding"": ""gzip""}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b""""
        for c in resp:
            data += c

        assert b""foo\nbar"" == data

    def test_non_timeout_ssl_error_on_read(self):
        mac_error = ssl.SSLError(
            ""SSL routines"", ""ssl3_get_record"", ""decryption failed or bad record mac""
        )

        @contextlib.contextmanager
        def make_bad_mac_fp():
            fp = BytesIO(b"""")
            with mock.patch.object(fp, ""read"") as fp_read:
                # mac/decryption error
                fp_read.side_effect = mac_error
                yield fp

        with make_bad_mac_fp() as fp:
            with pytest.raises(SSLError) as e:
                HTTPResponse(fp)
            assert e.value.args[0] == mac_error

        with make_bad_mac_fp() as fp:
            resp = HTTPResponse(fp, preload_content=False)
            with pytest.raises(SSLError) as e:
                resp.read()
            assert e.value.args[0] == mac_error


class MockChunkedEncodingResponse(object):
    def __init__(self, content):
        """"""
        content: collection of str, each str is a chunk in response
        """"""
        self.content = content
        self.index = 0  # This class iterates over self.content.
        self.closed = False
        self.cur_chunk = b""""
        self.chunks_exhausted = False

    @staticmethod
    def _encode_chunk(chunk):
        # In the general case, we can't decode the chunk to unicode
        length = ""%X\r\n"" % len(chunk)
        return length.encode() + chunk + b""\r\n""

    def _pop_new_chunk(self):
        if self.chunks_exhausted:
            return b""""
        try:
            chunk = self.content[self.index]
        except IndexError:
            chunk = b""""
            self.chunks_exhausted = True
        else:
            self.index += 1
        chunk = self._encode_chunk(chunk)
        if not isinstance(chunk, bytes):
            chunk = chunk.encode()
        return chunk

    def pop_current_chunk(self, amt=-1, till_crlf=False):
        if amt > 0 and till_crlf:
            raise ValueError(""Can't specify amt and till_crlf."")
        if len(self.cur_chunk) <= 0:
            self.cur_chunk = self._pop_new_chunk()
        if till_crlf:
            try:
                i = self.cur_chunk.index(b""\r\n"")
            except ValueError:
                # No CRLF in current chunk -- probably caused by encoder.
                self.cur_chunk = b""""
                return b""""
            else:
                chunk_part = self.cur_chunk[: i + 2]
                self.cur_chunk = self.cur_chunk[i + 2 :]
                return chunk_part
        elif amt <= -1:
            chunk_part = self.cur_chunk
            self.cur_chunk = b""""
            return chunk_part
        else:
            try:
                chunk_part = self.cur_chunk[:amt]
            except IndexError:
                chunk_part = self.cur_chunk
                self.cur_chunk = b""""
            else:
                self.cur_chunk = self.cur_chunk[amt:]
            return chunk_part

    def readline(self):
        return self.pop_current_chunk(till_crlf=True)

    def read(self, amt=-1):
        return self.pop_current_chunk(amt)

    def flush(self):
        # Python 3 wants this method.
        pass

    def close(self):
        self.closed = True


class MockChunkedIncompleteRead(MockChunkedEncodingResponse):
    def _encode_chunk(self, chunk):
        return ""9999\r\n%s\r\n"" % chunk.decode()


class MockChunkedInvalidChunkLength(MockChunkedEncodingResponse):
    BAD_LENGTH_LINE = ""ZZZ\r\n""

    def _encode_chunk(self, chunk):
        return ""%s%s\r\n"" % (self.BAD_LENGTH_LINE, chunk.decode())


class MockChunkedEncodingWithoutCRLFOnEnd(MockChunkedEncodingResponse):
    def _encode_chunk(self, chunk):
        return ""%X\r\n%s%s"" % (
            len(chunk),
            chunk.decode(),
            ""\r\n"" if len(chunk) > 0 else """",
        )


class MockChunkedEncodingWithExtensions(MockChunkedEncodingResponse):
    def _encode_chunk(self, chunk):
        return ""%X;asd=qwe\r\n%s\r\n"" % (len(chunk), chunk.decode())


class MockSock(object):
    @classmethod
    def makefile(cls, *args, **kwargs):
        return",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED," VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, ) VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR     VAR = VAR( VAR""""""\ VAR+VAR/VAR+ VAR+VAR/VAR VAR+VAR VAR/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/VAR VAR/VAR/VAR VAR+VAR VAR VAR/VAR/VAR VAR=="""""" ) @VAR.VAR VAR VAR(): VAR = VAR.VAR() VAR VAR VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = {""VAR"": ""VAR.VAR""} VAR = VAR(VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = {""VAR"": ""VAR.VAR""} VAR = VAR(VAR=VAR) VAR VAR.VAR(""VAR"") == ""VAR.VAR"" VAR VAR(VAR): VAR VAR(VAR): VAR = VAR(""VAR"") VAR VAR.VAR == ""VAR"" VAR VAR.VAR == ""VAR"" VAR VAR(VAR): VAR = VAR() VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR(VAR""VAR"") VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 0 VAR VAR.VAR == VAR""VAR"" VAR VAR.VAR() == VAR(VAR""VAR"") VAR VAR(VAR): VAR = VAR(VAR""\VAR"" * 10) VAR VAR.VAR(VAR): VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(1) == VAR""VAR"" VAR VAR.VAR(2) == VAR""VAR"" VAR VAR.VAR() == VAR"""" VAR VAR.VAR() == VAR"""" VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR VAR.VAR(3) == VAR""""  VAR VAR.VAR.VAR VAR VAR VAR VAR VAR.VAR(1) == VAR""VAR""  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR""VAR"" VAR VAR.VAR() == VAR"""" VAR VAR.VAR() == VAR"""" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR VAR.VAR(1) == VAR"""" VAR VAR.VAR(1) == VAR""VAR""  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR""VAR"" VAR VAR.VAR() == VAR"""" VAR VAR.VAR() == VAR"""" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR VAR.VAR(11) == VAR"""" VAR VAR.VAR(1) == VAR""VAR"" VAR VAR.VAR(2) == VAR""VAR"" VAR VAR.VAR() == VAR"""" VAR VAR.VAR() == VAR"""" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR * 3 VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR VAR.VAR(VAR): VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR(VAR):    VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR * 3 + VAR""VAR"" VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR"""" VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR * 3 + VAR""VAR"" VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR.VAR == VAR""VAR"" @VAR() VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR.VAR == VAR""VAR"" @VAR() VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR) VAR = VAR"""" VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR""VAR"" @VAR() VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR VAR.VAR(VAR): VAR(VAR, VAR={""VAR-VAR"": ""VAR""}) VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR(VAR""VAR"")) VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR, VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR.VAR(VAR""VAR"")) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR, VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={""VAR-VAR"": ""VAR, VAR""}) VAR VAR.VAR == VAR""VAR"" VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR VAR.VAR == VAR""VAR"" VAR VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR VAR.VAR() VAR VAR VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR.VAR   VAR: VAR = VAR.VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR.VAR() VAR VAR.VAR VAR: VAR.VAR()  VAR = VAR(""VAR"") VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR = 2   VAR VAR.VAR VAR VAR.VAR(VAR): VAR.VAR() VAR VAR(VAR, VAR): VAR: VAR = VAR.VAR(VAR) VAR.VAR = VAR(VAR""VAR"") VAR.VAR = 0 VAR.VAR = 3 VAR VAR(VAR, VAR=VAR) VAR VAR: VAR VAR VAR.VAR VAR VAR VAR.VAR.VAR() VAR VAR VAR(VAR.VAR) VAR VAR VAR.VAR() VAR.VAR() VAR VAR.VAR VAR VAR.VAR.VAR() VAR VAR(VAR.VAR) VAR VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR) VAR VAR.VAR() == VAR""VAR"" VAR.VAR() VAR VAR.VAR   VAR = VAR(VAR""VAR\VAR"") VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(VAR) VAR VAR: VAR(VAR(VAR)) VAR VAR(VAR.VAR) == ""VAR VAR VAR VAR"" VAR = VAR""VAR"" VAR = VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR, 5) VAR.VAR(1)  VAR VAR(VAR.VAR()) == (VAR(VAR) - 5)   VAR VAR VAR.VAR: VAR.VAR(5) VAR VAR(VAR): VAR = VAR(VAR""VAR\VAR"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR(VAR) VAR VAR(VAR) == [VAR""VAR\VAR"", VAR""VAR""] VAR VAR VAR.VAR VAR VAR VAR.VAR VAR VAR.VAR(VAR): VAR(VAR) VAR.VAR() VAR VAR.VAR VAR VAR.VAR VAR VAR.VAR(VAR) VAR VAR: VAR(VAR) VAR VAR(VAR.VAR) == ""VAR VAR VAR VAR"" VAR VAR(VAR): VAR = VAR(VAR""\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR"") VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR, VAR=""VAR"") VAR VAR.VAR() == VAR""äöüß"" VAR.VAR() VAR VAR.VAR   VAR = VAR( VAR""\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR"" ) VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(VAR) VAR VAR: VAR VAR.VAR:   VAR = VAR(VAR) VAR(VAR(VAR)) VAR VAR.VAR(""VAR/VAR VAR VAR VAR VAR.?"", VAR(VAR.VAR)) VAR VAR(VAR): VAR = VAR( VAR""\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR\VAR"" ) VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR:   VAR = VAR(VAR) VAR = VAR(VAR, VAR=""VAR"") VAR VAR(VAR) == [VAR""äöüß\VAR"", VAR""αβγδ""] VAR VAR VAR.VAR VAR VAR VAR.VAR VAR VAR.VAR(VAR): VAR(VAR) VAR.VAR() VAR VAR.VAR VAR VAR.VAR VAR VAR.VAR(VAR) VAR VAR: VAR(VAR) VAR VAR.VAR(""VAR/VAR VAR VAR VAR VAR.?"", VAR(VAR.VAR)) VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR(VAR) == VAR""VAR"" VAR VAR(VAR) == VAR""VAR"" VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR = 0 VAR += VAR(VAR(VAR)) VAR 2 == VAR VAR VAR == VAR.VAR() VAR += VAR(VAR(VAR)) VAR 3 == VAR VAR VAR == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR""VAR"" VAR VAR(VAR) == VAR""VAR"" VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR""VAR"" VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR.VAR()  VAR = VAR(VAR) VAR VAR == VAR VAR VAR(VAR) == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR):   VAR = 10 VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR ``VAR`` VAR ``VAR`` VAR VAR ``VAR``. """""" VAR VAR(VAR, VAR, VAR): VAR.VAR = [ VAR[VAR * VAR : (VAR + 1) * VAR] VAR VAR VAR VAR(VAR + 1) ] VAR VAR"""".VAR(VAR.VAR) == VAR VAR VAR(VAR, VAR):  VAR VAR(VAR.VAR) > 0: VAR VAR.VAR.VAR(0) VAR VAR"""" VAR = VAR.VAR(VAR) VAR = VAR(VAR)  VAR = VAR(VAR, VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR.VAR() VAR = [(VAR, VAR.VAR()) VAR VAR VAR VAR] VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR, VAR = VAR(*VAR)  VAR = VAR"""".VAR(VAR) VAR VAR == VAR  VAR = [(VAR + 1) * VAR VAR VAR VAR VAR(VAR)] VAR VAR == VAR(VAR)  VAR VAR(VAR) == VAR VAR VAR(VAR): VAR = VAR.VAR(VAR""VAR"") VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR""VAR"" VAR VAR(VAR) == VAR""VAR"" VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR( VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR ) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR""VAR"" VAR VAR(VAR) == VAR""VAR"" VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR"""") VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""} VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR(VAR): VAR = {""VAR-VAR"": ""VAR""} VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR[""VAR-VAR""] = ""-10"" VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR):    VAR = {""VAR-VAR"": ""5"", ""VAR-VAR"": ""VAR""} VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""5, 5, 5""} VAR = {""VAR-VAR"": ""5, 42""} VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR.VAR(VAR): VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""}  VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR VAR VAR  VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR == 0  VAR = VAR(VAR""12345"") VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR(2) VAR(VAR) VAR VAR.VAR == 3 VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(VAR) VAR VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR): VAR.VAR = VAR VAR = VAR(VAR""VAR"") VAR = VAR() VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR""VAR"" VAR VAR(VAR) == VAR""VAR"" VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR, VAR VAR VAR(VAR.VAR()): VAR VAR == VAR[VAR] VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR"") VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR : VAR + 2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {""VAR-VAR"": ""VAR"", ""VAR-VAR"": ""VAR""} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR"""" VAR VAR VAR VAR.VAR(VAR=VAR): VAR += VAR VAR VAR""VAR"" == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR"", VAR""VAR"", VAR""VAR"", VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR.VAR(2)) VAR VAR == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR(VAR""VAR"") VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR):   VAR = 1337 VAR = VAR(VAR"""") VAR = VAR( VAR, VAR={""VAR-VAR"": VAR(VAR)}, VAR=VAR, VAR=VAR, ) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(3) VAR = VAR.VAR.VAR[1] VAR VAR(VAR, VAR) VAR VAR.VAR == 0 VAR VAR.VAR == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR.VAR(VAR) VAR VAR: VAR(VAR.VAR()) VAR = VAR.VAR.VAR[1] VAR VAR(VAR, VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR.VAR(VAR) VAR VAR: VAR(VAR.VAR()) VAR = VAR.VAR.VAR[1] VAR VAR(VAR, VAR) VAR VAR.VAR == VAR.VAR(VAR.VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( VAR, VAR=VAR, VAR={""VAR-VAR"": ""VAR""} ) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR(VAR, VAR=""VAR"") VAR.VAR = VAR VAR.VAR = VAR VAR = VAR( """", VAR=VAR, VAR={""VAR-VAR"": ""VAR""}, VAR=VAR, ) VAR VAR.VAR VAR VAR VAR.VAR = VAR: VAR VAR.VAR = VAR.VAR() VAR VAR VAR VAR.VAR(): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR = {""VAR"": ""VAR.VAR""} VAR = VAR(VAR=VAR) VAR VAR.VAR.VAR(""VAR"") == ""VAR.VAR"" VAR VAR.VAR.VAR(""VAR"") == ""VAR.VAR"" VAR VAR(VAR): VAR = VAR(VAR"""") VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR = VAR() VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR == VAR VAR VAR(VAR): VAR = VAR(VAR"""") VAR = ""VAR: VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = VAR(VAR"""") VAR = VAR(VAR, VAR=""VAR: VAR = [ VAR( VAR=""VAR"", VAR=""VAR: VAR=VAR, VAR=301, VAR=""VAR: ), VAR( VAR=""VAR"", VAR=""VAR: VAR=VAR, VAR=301, VAR=""VAR: ), ] VAR = VAR(VAR=VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == ""VAR: @VAR.VAR.VAR( [""VAR"", ""VAR""], [ (VAR"""", []), (VAR""\VAR"", [VAR""\VAR""]), (VAR""\VAR\VAR\VAR"", [VAR""\VAR"", VAR""\VAR"", VAR""\VAR""]), (VAR""VAR\VAR"", [VAR""VAR\VAR"", VAR""VAR""]), (VAR""VAR\VAR\VAR\VAR\VAR!"", [VAR""VAR\VAR"", VAR""VAR\VAR"", VAR""\VAR"", VAR""\VAR"", VAR""!""]), ], ) VAR VAR(VAR, VAR, VAR): VAR = [] VAR VAR VAR VAR(VAR(VAR), VAR=VAR): VAR.VAR(VAR) VAR VAR == VAR VAR VAR(VAR): VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR""VAR\VAR"") VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR : VAR + 2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {""VAR-VAR"": ""VAR"", ""VAR-VAR"": ""VAR""} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR"""" VAR VAR VAR VAR: VAR += VAR VAR VAR""VAR\VAR"" == VAR VAR VAR(VAR): VAR = VAR.VAR( ""VAR VAR"", ""VAR"", ""VAR VAR VAR VAR VAR VAR"" ) @VAR.VAR VAR VAR(): VAR = VAR(VAR"""") VAR VAR.VAR.VAR(VAR, ""VAR"") VAR VAR:  VAR.VAR = VAR VAR VAR VAR VAR() VAR VAR: VAR VAR.VAR(VAR) VAR VAR: VAR(VAR) VAR VAR.VAR.VAR[0] == VAR VAR VAR() VAR VAR: VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(VAR) VAR VAR: VAR.VAR() VAR VAR.VAR.VAR[0] == VAR VAR VAR(VAR): VAR VAR(VAR, VAR): """""" VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR """""" VAR.VAR = VAR VAR.VAR = 0  VAR.VAR = VAR VAR.VAR = VAR"""" VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR = ""%VAR\VAR\VAR"" % VAR(VAR) VAR VAR.VAR() + VAR + VAR""\VAR\VAR"" VAR VAR(VAR): VAR VAR.VAR: VAR VAR"""" VAR: VAR = VAR.VAR[VAR.VAR] VAR VAR: VAR = VAR"""" VAR.VAR = VAR VAR: VAR.VAR += 1 VAR = VAR.VAR(VAR) VAR VAR VAR(VAR, VAR): VAR = VAR.VAR() VAR VAR VAR VAR(VAR, VAR=-1, VAR=VAR): VAR VAR > 0 VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR."") VAR VAR(VAR.VAR) <= 0: VAR.VAR = VAR.VAR() VAR VAR: VAR: VAR = VAR.VAR.VAR(VAR""\VAR\VAR"") VAR VAR:  VAR.VAR = VAR"""" VAR VAR"""" VAR: VAR = VAR.VAR[: VAR + 2] VAR.VAR = VAR.VAR[VAR + 2 :] VAR VAR VAR VAR <= -1: VAR = VAR.VAR VAR.VAR = VAR"""" VAR VAR VAR: VAR: VAR = VAR.VAR[:VAR] VAR VAR: VAR = VAR.VAR VAR.VAR = VAR"""" VAR: VAR.VAR = VAR.VAR[VAR:] VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR=VAR) VAR VAR(VAR, VAR=-1): VAR VAR.VAR(VAR) VAR VAR(VAR):  VAR VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR): VAR VAR(VAR, VAR): VAR ""9999\VAR\VAR%VAR\VAR\VAR"" % VAR.VAR() VAR VAR(VAR): VAR = ""VAR\VAR\VAR"" VAR VAR(VAR, VAR): VAR ""%VAR%VAR\VAR\VAR"" % (VAR.VAR, VAR.VAR()) VAR VAR(VAR): VAR VAR(VAR, VAR): VAR ""%VAR\VAR\VAR%VAR%VAR"" % ( VAR(VAR), VAR.VAR(), ""\VAR\VAR"" VAR VAR(VAR) > 0 VAR """", ) VAR VAR(VAR): VAR VAR(VAR, VAR): VAR ""%VAR;VAR=VAR\VAR\VAR%VAR\VAR\VAR"" % (VAR(VAR), VAR.VAR()) VAR VAR(VAR): @VAR VAR VAR(VAR, *VAR, **VAR): VAR ",1,15
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,docs/requirements.txt,"-r ../dev-requirements.txt
ndg-httpsclient
sphinx
alabaster
requests>=2.0,<2.16",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"-VAR ../VAR-VAR.VAR VAR-VAR VAR VAR VAR>=2.0,<2.16 ",1,15
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,src/urllib3/filepost.py,"from __future__ import absolute_import
import binascii
import codecs
import os

from io import BytesIO

from .packages import six
from .packages.six import b
from .fields import RequestField

writer = codecs.lookup('utf-8')[3]


def choose_boundary():
    """"""
    Our embarrassingly-simple replacement for mimetools.choose_boundary.
    """"""
    boundary = binascii.hexlify(os.urandom(16))
    if six.PY3:
        boundary = boundary.decode('ascii')
    return boundary


def iter_field_objects(fields):
    """"""
    Iterate over fields.

    Supports list of (k, v) tuples and dicts, and lists of
    :class:`~urllib3.fields.RequestField`.

    """"""
    if isinstance(fields, dict):
        i = six.iteritems(fields)
    else:
        i = iter(fields)

    for field in i:
        if isinstance(field, RequestField):
            yield field
        else:
            yield RequestField.from_tuples(*field)


def iter_fields(fields):
    """"""
    .. deprecated:: 1.6

    Iterate over fields.

    The addition of :class:`~urllib3.fields.RequestField` makes this function
    obsolete. Instead, use :func:`iter_field_objects`, which returns
    :class:`~urllib3.fields.RequestField` objects.

    Supports list of (k, v) tuples and dicts.
    """"""
    if isinstance(fields, dict):
        return ((k, v) for k, v in six.iteritems(fields))

    return ((k, v) for k, v in fields)


def encode_multipart_formdata(fields, boundary=None):
    """"""
    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.

    :param fields:
        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).

    :param boundary:
        If not specified, then a random boundary will be generated using
        :func:`urllib3.filepost.choose_boundary`.
    """"""
    body = BytesIO()
    if boundary is None:
        boundary = choose_boundary()

    for field in iter_field_objects(fields):
        body.write(b('--%s\r\n' % (boundary)))

        writer(body).write(field.render_headers())
        data = field.data

        if isinstance(data, int):
            data = str(data)  # Backwards compatibility

        if isinstance(data, six.text_type):
            writer(body).write(data)
        else:
            body.write(data)

        body.write(b'\r\n')

    body.write(b('--%s--\r\n' % (boundary)))

    content_type = str('multipart/form-data; boundary=%s' % boundary)

    return body.getvalue(), content_type",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR.VAR VAR VAR VAR .VAR VAR VAR VAR = VAR.VAR('VAR-8')[3] VAR VAR(): """""" VAR VAR-VAR VAR VAR VAR.VAR. """""" VAR = VAR.VAR(VAR.VAR(16)) VAR VAR.VAR: VAR = VAR.VAR('VAR') VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR, VAR VAR VAR :VAR:`~VAR.VAR.VAR`. """""" VAR VAR(VAR, VAR): VAR = VAR.VAR(VAR) VAR: VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR.VAR(*VAR) VAR VAR(VAR): """""" .. VAR:: 1.6 VAR VAR VAR. VAR VAR VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR VAR. VAR, VAR :VAR:`VAR`, VAR VAR :VAR:`~VAR.VAR.VAR` VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR ((VAR, VAR) VAR VAR, VAR VAR VAR.VAR(VAR)) VAR ((VAR, VAR) VAR VAR, VAR VAR VAR) VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR ``VAR`` VAR VAR VAR/VAR-VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR (VAR, :VAR:`~VAR.VAR.VAR`). :VAR VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR`. """""" VAR = VAR() VAR VAR VAR VAR: VAR = VAR() VAR VAR VAR VAR(VAR): VAR.VAR(VAR('--%VAR\VAR\VAR' % (VAR))) VAR(VAR).VAR(VAR.VAR()) VAR = VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR)  VAR VAR(VAR, VAR.VAR): VAR(VAR).VAR(VAR) VAR: VAR.VAR(VAR) VAR.VAR(VAR'\VAR\VAR') VAR.VAR(VAR('--%VAR--\VAR\VAR' % (VAR))) VAR = VAR('VAR/VAR-VAR; VAR=%VAR' % VAR) VAR VAR.VAR(), VAR ",1,15
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,src/urllib3/response.py,"from __future__ import absolute_import
from contextlib import contextmanager
import zlib
import io
import logging
from socket import timeout as SocketTimeout
from socket import error as SocketError

from ._collections import HTTPHeaderDict
from .exceptions import (
    BodyNotHttplibCompatible, ProtocolError, DecodeError, ReadTimeoutError,
    ResponseNotChunked, IncompleteRead, InvalidHeader
)
from .packages.six import string_types as basestring, PY3
from .packages.six.moves import http_client as httplib
from .connection import HTTPException, BaseSSLError
from .util.response import is_fp_closed, is_response_to_head

log = logging.getLogger(__name__)


class DeflateDecoder(object):

    def __init__(self):
        self._first_try = True
        self._data = b''
        self._obj = zlib.decompressobj()

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        if not data:
            return data

        if not self._first_try:
            return self._obj.decompress(data)

        self._data += data
        try:
            decompressed = self._obj.decompress(data)
            if decompressed:
                self._first_try = False
                self._data = None
            return decompressed
        except zlib.error:
            self._first_try = False
            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
            try:
                return self.decompress(self._data)
            finally:
                self._data = None


class GzipDecoderState(object):

    FIRST_MEMBER = 0
    OTHER_MEMBERS = 1
    SWALLOW_DATA = 2


class GzipDecoder(object):

    def __init__(self):
        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
        self._state = GzipDecoderState.FIRST_MEMBER

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        ret = bytearray()
        if self._state == GzipDecoderState.SWALLOW_DATA or not data:
            return bytes(ret)
        while True:
            try:
                ret += self._obj.decompress(data)
            except zlib.error:
                previous_state = self._state
                # Ignore data after the first error
                self._state = GzipDecoderState.SWALLOW_DATA
                if previous_state == GzipDecoderState.OTHER_MEMBERS:
                    # Allow trailing garbage acceptable in other gzip clients
                    return bytes(ret)
                raise
            data = self._obj.unused_data
            if not data:
                return bytes(ret)
            self._state = GzipDecoderState.OTHER_MEMBERS
            self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)


class MultiDecoder(object):
    """"""
    From RFC7231:
        If one or more encodings have been applied to a representation, the
        sender that applied the encodings MUST generate a Content-Encoding
        header field that lists the content codings in the order in which
        they were applied.
    """"""

    def __init__(self, modes):
        self._decoders = [_get_decoder(m.strip()) for m in modes.split(',')]

    def flush(self):
        return self._decoders[0].flush()

    def decompress(self, data):
        for d in reversed(self._decoders):
            data = d.decompress(data)
        return data


def _get_decoder(mode):
    if ',' in mode:
        return MultiDecoder(mode)

    if mode == 'gzip':
        return GzipDecoder()

    return DeflateDecoder()


class HTTPResponse(io.IOBase):
    """"""
    HTTP Response container.

    Backwards-compatible to httplib's HTTPResponse but the response ``body`` is
    loaded and decoded on-demand when the ``data`` property is accessed.  This
    class is also compatible with the Python standard library's :mod:`io`
    module, and can hence be treated as a readable object in the context of that
    framework.

    Extra parameters for behaviour not present in httplib.HTTPResponse:

    :param preload_content:
        If True, the response's body will be preloaded during construction.

    :param decode_content:
        If True, will attempt to decode the body based on the
        'content-encoding' header.

    :param original_response:
        When this HTTPResponse wrapper is generated from an httplib.HTTPResponse
        object, it's convenient to include the original for debug purposes. It's
        otherwise unused.

    :param retries:
        The retries contains the last :class:`~urllib3.util.retry.Retry` that
        was used during the request.

    :param enforce_content_length:
        Enforce content length checking. Body returned by server must match
        value of Content-Length header, if present. Otherwise, raise error.
    """"""

    CONTENT_DECODERS = ['gzip', 'deflate']
    REDIRECT_STATUSES = [301, 302, 303, 307, 308]

    def __init__(self, body='', headers=None, status=0, version=0, reason=None,
                 strict=0, preload_content=True, decode_content=True,
                 original_response=None, pool=None, connection=None, msg=None,
                 retries=None, enforce_content_length=False,
                 request_method=None, request_url=None):

        if isinstance(headers, HTTPHeaderDict):
            self.headers = headers
        else:
            self.headers = HTTPHeaderDict(headers)
        self.status = status
        self.version = version
        self.reason = reason
        self.strict = strict
        self.decode_content = decode_content
        self.retries = retries
        self.enforce_content_length = enforce_content_length

        self._decoder = None
        self._body = None
        self._fp = None
        self._original_response = original_response
        self._fp_bytes_read = 0
        self.msg = msg
        self._request_url = request_url

        if body and isinstance(body, (basestring, bytes)):
            self._body = body

        self._pool = pool
        self._connection = connection

        if hasattr(body, 'read'):
            self._fp = body

        # Are we using the chunked-style of transfer encoding?
        self.chunked = False
        self.chunk_left = None
        tr_enc = self.headers.get('transfer-encoding', '').lower()
        # Don't incur the penalty of creating a list and then discarding it
        encodings = (enc.strip() for enc in tr_enc.split("",""))
        if ""chunked"" in encodings:
            self.chunked = True

        # Determine length of response
        self.length_remaining = self._init_length(request_method)

        # If requested, preload the body.
        if preload_content and not self._body:
            self._body = self.read(decode_content=decode_content)

    def get_redirect_location(self):
        """"""
        Should we redirect and where to?

        :returns: Truthy redirect location string if we got a redirect status
            code and valid location. ``None`` if redirect status and no
            location. ``False`` if not a redirect status code.
        """"""
        if self.status in self.REDIRECT_STATUSES:
            return self.headers.get('location')

        return False

    def release_conn(self):
        if not self._pool or not self._connection:
            return

        self._pool._put_conn(self._connection)
        self._connection = None

    @property
    def data(self):
        # For backwords-compat with earlier urllib3 0.4 and earlier.
        if self._body:
            return self._body

        if self._fp:
            return self.read(cache_content=True)

    @property
    def connection(self):
        return self._connection

    def isclosed(self):
        return is_fp_closed(self._fp)

    def tell(self):
        """"""
        Obtain the number of bytes pulled over the wire so far. May differ from
        the amount of content returned by :meth:``HTTPResponse.read`` if bytes
        are encoded on the wire (e.g, compressed).
        """"""
        return self._fp_bytes_read

    def _init_length(self, request_method):
        """"""
        Set initial length value for Response content if available.
        """"""
        length = self.headers.get('content-length')

        if length is not None:
            if self.chunked:
                # This Response will fail with an IncompleteRead if it can't be
                # received as chunked. This method falls back to attempt reading
                # the response before raising an exception.
                log.warning(""Received response with both Content-Length and ""
                            ""Transfer-Encoding set. This is expressly forbidden ""
                            ""by RFC 7230 sec 3.3.2. Ignoring Content-Length and ""
                            ""attempting to process response as Transfer-Encoding: ""
                            ""chunked."")
                return None

            try:
                # RFC 7230 section 3.3.2 specifies multiple content lengths can
                # be sent in a single Content-Length header
                # (e.g. Content-Length: 42, 42). This line ensures the values
                # are all valid ints and that as long as the `set` length is 1,
                # all values are the same. Otherwise, the header is invalid.
                lengths = set([int(val) for val in length.split(',')])
                if len(lengths) > 1:
                    raise InvalidHeader(""Content-Length contained multiple ""
                                        ""unmatching values (%s)"" % length)
                length = lengths.pop()
            except ValueError:
                length = None
            else:
                if length < 0:
                    length = None

        # Convert status to int for comparison
        # In some cases, httplib returns a status of ""_UNKNOWN""
        try:
            status = int(self.status)
        except ValueError:
            status = 0

        # Check for responses that shouldn't include a body
        if status in (204, 304) or 100 <= status < 200 or request_method == 'HEAD':
            length = 0

        return length

    def _init_decoder(self):
        """"""
        Set-up the _decoder attribute if necessary.
        """"""
        # Note: content-encoding value should be case-insensitive, per RFC 7230
        # Section 3.2
        content_encoding = self.headers.get('content-encoding', '').lower()
        if self._decoder is None:
            if content_encoding in self.CONTENT_DECODERS:
                self._decoder = _get_decoder(content_encoding)
            elif ',' in content_encoding:
                encodings = [
                    e.strip() for e in content_encoding.split(',')
                    if e.strip() in self.CONTENT_DECODERS]
                if len(encodings):
                    self._decoder = _get_decoder(content_encoding)

    def _decode(self, data, decode_content, flush_decoder):
        """"""
        Decode the data passed in and potentially flush the decoder.
        """"""
        try:
            if decode_content and self._decoder:
                data = self._decoder.decompress(data)
        except (IOError, zlib.error) as e:
            content_encoding = self.headers.get('content-encoding', '').lower()
            raise DecodeError(
                ""Received response with content-encoding: %s, but ""
                ""failed to decode it."" % content_encoding, e)

        if flush_decoder and decode_content:
            data += self._flush_decoder()

        return data

    def _flush_decoder(self):
        """"""
        Flushes the decoder. Should only be called if the decoder is actually
        being used.
        """"""
        if self._decoder:
            buf = self._decoder.decompress(b'')
            return buf + self._decoder.flush()

        return b''

    @contextmanager
    def _error_catcher(self):
        """"""
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.

        On exit, release the connection back to the pool.
        """"""
        clean_exit = False

        try:
            try:
                yield

            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if 'read operation timed out' not in str(e):  # Defensive:
                    # This shouldn't happen but just in case we're missing an edge
                    # case, let's avoid swallowing SSL errors.
                    raise

                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
                raise ProtocolError('Connection broken: %r' % e, e)

            # If no exception is thrown, we should avoid cleaning up
            # unnecessarily.
            clean_exit = True
        finally:
            # If we didn't terminate cleanly, we need to throw away our
            # connection.
            if not clean_exit:
                # The response may not be closed but we're not going to use it
                # anymore so close it now to ensure that the connection is
                # released back to the pool.
                if self._original_response:
                    self._original_response.close()

                # Closing the response may not actually be sufficient to close
                # everything, so if we have a hold of the connection close that
                # too.
                if self._connection:
                    self._connection.close()

            # If we hold the original response but it's closed now, we should
            # return the connection back to the pool.
            if self._original_response and self._original_response.isclosed():
                self.release_conn()

    def read(self, amt=None, decode_content=None, cache_content=False):
        """"""
        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional
        parameters: ``decode_content`` and ``cache_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.

        :param cache_content:
            If True, will save the returned data such that the same result is
            returned despite of the state of the underlying file object. This
            is useful if you want the ``.data`` property to continue working
            after having ``.read()`` the file object. (Overridden if ``amt`` is
            set.)
        """"""
        self._init_decoder()
        if decode_content is None:
            decode_content = self.decode_content

        if self._fp is None:
            return

        flush_decoder = False
        data = None

        with self._error_catcher():
            if amt is None:
                # cStringIO doesn't like amt=None
                data = self._fp.read()
                flush_decoder = True
            else:
                cache_content = False
                data = self._fp.read(amt)
                if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.
                    # Close the connection when no data is returned
                    #
                    # This is redundant to what httplib/http.client _should_
                    # already do.  However, versions of python released before
                    # December 15, 2012 (http://bugs.python.org/issue16298) do
                    # not properly close the connection in all cases. There is
                    # no harm in redundantly calling close.
                    self._fp.close()
                    flush_decoder = True
                    if self.enforce_content_length and self.length_remaining not in (0, None):
                        # This is an edge case that httplib failed to cover due
                        # to concerns of backward compatibility. We're
                        # addressing it here to make sure IncompleteRead is
                        # raised during streaming, so all calls with incorrect
                        # Content-Length are caught.
                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)

        if data:
            self._fp_bytes_read += len(data)
            if self.length_remaining is not None:
                self.length_remaining -= len(data)

            data = self._decode(data, decode_content, flush_decoder)

            if cache_content:
                self._body = data

        return data

    def stream(self, amt=2**16, decode_content=None):
        """"""
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.

        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        if self.chunked and self.supports_chunked_reads():
            for line in self.read_chunked(amt, decode_content=decode_content):
                yield line
        else:
            while not is_fp_closed(self._fp):
                data = self.read(amt=amt, decode_content=decode_content)

                if data:
                    yield data

    @classmethod
    def from_httplib(ResponseCls, r, **response_kw):
        """"""
        Given an :class:`httplib.HTTPResponse` instance ``r``, return a
        corresponding :class:`urllib3.response.HTTPResponse` object.

        Remaining parameters are passed to the HTTPResponse constructor, along
        with ``original_response=r``.
        """"""
        headers = r.msg

        if not isinstance(headers, HTTPHeaderDict):
            if PY3:  # Python 3
                headers = HTTPHeaderDict(headers.items())
            else:  # Python 2
                headers = HTTPHeaderDict.from_httplib(headers)

        # HTTPResponse objects in Python 3 don't have a .strict attribute
        strict = getattr(r, 'strict', 0)
        resp = ResponseCls(body=r,
                           headers=headers,
                           status=r.status,
                           version=r.version,
                           reason=r.reason,
                           strict=strict,
                           original_response=r,
                           **response_kw)
        return resp

    # Backwards-compatibility methods for httplib.HTTPResponse
    def getheaders(self):
        return self.headers

    def getheader(self, name, default=None):
        return self.headers.get(name, default)

    # Backwards compatibility for http.cookiejar
    def info(self):
        return self.headers

    # Overrides from io.IOBase
    def close(self):
        if not self.closed:
            self._fp.close()

        if self._connection:
            self._connection.close()

    @property
    def closed(self):
        if self._fp is None:
            return True
        elif hasattr(self._fp, 'isclosed'):
            return self._fp.isclosed()
        elif hasattr(self._fp, 'closed'):
            return self._fp.closed
        else:
            return True

    def fileno(self):
        if self._fp is None:
            raise IOError(""HTTPResponse has no file to get a fileno from"")
        elif hasattr(self._fp, ""fileno""):
            return self._fp.fileno()
        else:
            raise IOError(""The file-like object this HTTPResponse is wrapped ""
                          ""around has no file descriptor"")

    def flush(self):
        if self._fp is not None and hasattr(self._fp, 'flush'):
            return self._fp.flush()

    def readable(self):
        # This method is required for `io` module compatibility.
        return True

    def readinto(self, b):
        # This method is required for `io` module compatibility.
        temp = self.read(len(b))
        if len(temp) == 0:
            return 0
        else:
            b[:len(temp)] = temp
            return len(temp)

    def supports_chunked_reads(self):
        """"""
        Checks if the underlying file-like object looks like a
        httplib.HTTPResponse object. We do this by testing for the fp
        attribute. If it is present we assume it returns raw chunks as
        processed by read_chunked().
        """"""
        return hasattr(self._fp, 'fp')

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b';', 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
            raise httplib.IncompleteRead(line)

    def _handle_chunk(self, amt):
        returned_chunk = None
        if amt is None:
            chunk = self._fp._safe_read(self.chunk_left)
            returned_chunk = chunk
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        elif amt < self.chunk_left:
            value = self._fp._safe_read(amt)
            self.chunk_left = self.chunk_left - amt
            returned_chunk = value
        elif amt == self.chunk_left:
            value = self._fp._safe_read(amt)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
            returned_chunk = value
        else:  # amt > self.chunk_left
            returned_chunk = self._fp._safe_read(self.chunk_left)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        return returned_chunk

    def read_chunked(self, amt=None, decode_content=None):
        """"""
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                ""Response is not chunked. ""
                ""Header 'transfer-encoding: chunked' is missing."")
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                ""Body should be httplib.HTTPResponse like. ""
                ""It should have have an fp attribute which returns raw chunks."")

        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return

            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return

            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(chunk, decode_content=decode_content,
                                       flush_decoder=False)
                if decoded:
                    yield decoded

            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded

            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b'\r\n':
                    break

            # We read everything; close the ""file"".
            if self._original_response:
                self._original_response.close()

    def geturl(self):
        """"""
        Returns the URL that was the source of this response.
        If the request that generated this response redirected, this method
        will return the final redirect location.
        """"""
        if self.retries is not None and len(self.retries.history):
            return self.retries.history[-1].redirect_location
        else:
            return self._request_url",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR ) VAR .VAR.VAR VAR VAR VAR VAR, VAR VAR .VAR.VAR.VAR VAR VAR VAR VAR VAR .VAR VAR VAR, VAR VAR .VAR.VAR VAR VAR, VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR) VAR.VAR += VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR: VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR VAR.VAR = VAR.VAR(-VAR.VAR) VAR: VAR VAR.VAR(VAR.VAR) VAR: VAR.VAR = VAR VAR VAR(VAR): VAR = 0 VAR = 1 VAR = 2 VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR.VAR = VAR.VAR VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR = VAR() VAR VAR.VAR == VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR VAR: VAR: VAR += VAR.VAR.VAR(VAR) VAR VAR.VAR: VAR = VAR.VAR  VAR.VAR = VAR.VAR VAR VAR == VAR.VAR:  VAR VAR(VAR) VAR VAR = VAR.VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR.VAR = VAR.VAR VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR VAR(VAR): """""" VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = [VAR(VAR.VAR()) VAR VAR VAR VAR.VAR(',')] VAR VAR(VAR): VAR VAR.VAR[0].VAR() VAR VAR(VAR, VAR): VAR VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR ',' VAR VAR: VAR VAR(VAR) VAR VAR == 'VAR': VAR VAR() VAR VAR() VAR VAR(VAR.VAR): """""" VAR VAR VAR. VAR-VAR VAR VAR'VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR-VAR VAR VAR ``VAR`` VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR :VAR:`VAR` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR.VAR: :VAR VAR: VAR VAR, VAR VAR'VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR'VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR, VAR VAR. VAR, VAR VAR. """""" VAR = ['VAR', 'VAR'] VAR = [301, 302, 303, 307, 308] VAR VAR(VAR, VAR='', VAR=VAR, VAR=0, VAR=0, VAR=VAR, VAR=0, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR VAR(VAR, VAR): VAR.VAR = VAR VAR: VAR.VAR = VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR(VAR, (VAR, VAR)): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, 'VAR'): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR VAR = VAR.VAR.VAR('VAR-VAR', '').VAR()  VAR = (VAR.VAR() VAR VAR VAR VAR.VAR("","")) VAR ""VAR"" VAR VAR: VAR.VAR = VAR  VAR.VAR = VAR.VAR(VAR)  VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR.VAR(VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR? :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR.VAR('VAR') VAR VAR VAR VAR(VAR): VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR.VAR) VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR VAR.VAR: VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR(VAR=VAR) @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:``VAR.VAR`` VAR VAR VAR VAR VAR VAR VAR (VAR.VAR, VAR). """""" VAR VAR.VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR') VAR VAR VAR VAR VAR: VAR VAR.VAR:    VAR.VAR(""VAR VAR VAR VAR VAR-VAR VAR "" ""VAR-VAR VAR. VAR VAR VAR VAR "" ""VAR VAR 7230 VAR 3.3.2. VAR VAR-VAR VAR "" ""VAR VAR VAR VAR VAR VAR-VAR: "" ""VAR."") VAR VAR VAR:      VAR = VAR([VAR(VAR) VAR VAR VAR VAR.VAR(',')]) VAR VAR(VAR) > 1: VAR VAR(""VAR-VAR VAR VAR "" ""VAR VAR (%VAR)"" % VAR) VAR = VAR.VAR() VAR VAR: VAR = VAR VAR: VAR VAR < 0: VAR = VAR   VAR: VAR = VAR(VAR.VAR) VAR VAR: VAR = 0  VAR VAR VAR (204, 304) VAR 100 <= VAR < 200 VAR VAR == 'VAR': VAR = 0 VAR VAR VAR VAR(VAR): """""" VAR-VAR VAR VAR VAR VAR VAR. """"""   VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR.VAR VAR VAR: VAR VAR VAR VAR.VAR: VAR.VAR = VAR(VAR) VAR ',' VAR VAR: VAR = [ VAR.VAR() VAR VAR VAR VAR.VAR(',') VAR VAR.VAR() VAR VAR.VAR] VAR VAR(VAR): VAR.VAR = VAR(VAR) VAR VAR(VAR, VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR: VAR VAR VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR (VAR, VAR.VAR) VAR VAR: VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR( ""VAR VAR VAR VAR-VAR: %VAR, VAR "" ""VAR VAR VAR VAR."" % VAR, VAR) VAR VAR VAR VAR: VAR += VAR.VAR() VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR'') VAR VAR + VAR.VAR.VAR() VAR VAR'' @VAR VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR, VAR VAR-VAR VAR VAR, VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR VAR: VAR: VAR VAR VAR:   VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR VAR VAR VAR:  VAR 'VAR VAR VAR VAR' VAR VAR VAR(VAR):    VAR VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR (VAR, VAR) VAR VAR:  VAR VAR('VAR VAR: %VAR' % VAR, VAR)   VAR = VAR VAR:   VAR VAR VAR:    VAR VAR.VAR: VAR.VAR.VAR()    VAR VAR.VAR: VAR.VAR.VAR()   VAR VAR.VAR VAR VAR.VAR.VAR(): VAR.VAR() VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR`` VAR ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR ``.VAR`` VAR VAR VAR VAR VAR VAR ``.VAR()`` VAR VAR VAR. (VAR VAR ``VAR`` VAR VAR.) """""" VAR.VAR() VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR.VAR VAR VAR: VAR VAR = VAR VAR = VAR VAR VAR.VAR(): VAR VAR VAR VAR:  VAR = VAR.VAR.VAR() VAR = VAR VAR: VAR = VAR VAR = VAR.VAR.VAR(VAR) VAR VAR != 0 VAR VAR VAR:         VAR.VAR.VAR() VAR = VAR VAR VAR.VAR VAR VAR.VAR VAR VAR (0, VAR):      VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR += VAR(VAR) VAR VAR.VAR VAR VAR VAR: VAR.VAR -= VAR(VAR) VAR = VAR.VAR(VAR, VAR, VAR) VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=2**16, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR() VAR. VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR VAR.VAR VAR VAR.VAR(): VAR VAR VAR VAR.VAR(VAR, VAR=VAR): VAR VAR VAR: VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR=VAR, VAR=VAR) VAR VAR: VAR VAR @VAR VAR VAR(VAR, VAR, **VAR): """""" VAR VAR :VAR:`VAR.VAR` VAR ``VAR``, VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR ``VAR=VAR``. """""" VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR VAR:  VAR = VAR(VAR.VAR()) VAR:  VAR = VAR.VAR(VAR)  VAR = VAR(VAR, 'VAR', 0) VAR = VAR(VAR=VAR, VAR=VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR, **VAR) VAR VAR  VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR, VAR, VAR=VAR): VAR VAR.VAR.VAR(VAR, VAR)  VAR VAR(VAR): VAR VAR.VAR  VAR VAR(VAR): VAR VAR VAR.VAR: VAR.VAR.VAR() VAR VAR.VAR: VAR.VAR.VAR() @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR VAR: VAR VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR: VAR VAR(""VAR VAR-VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR"") VAR VAR(VAR): VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR):  VAR VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR(VAR(VAR)) VAR VAR(VAR) == 0: VAR 0 VAR: VAR[:VAR(VAR)] = VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR.VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR(). """""" VAR VAR(VAR.VAR, 'VAR') VAR VAR(VAR):   VAR VAR.VAR VAR VAR VAR: VAR VAR = VAR.VAR.VAR.VAR() VAR = VAR.VAR(VAR';', 1)[0] VAR: VAR.VAR = VAR(VAR, 16) VAR VAR:  VAR.VAR() VAR VAR.VAR(VAR) VAR VAR(VAR, VAR): VAR = VAR VAR VAR VAR VAR: VAR = VAR.VAR.VAR(VAR.VAR) VAR = VAR VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR < VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR = VAR.VAR - VAR VAR = VAR VAR VAR == VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR = VAR VAR:  VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR.VAR()  VAR VAR VAR.VAR: VAR VAR( ""VAR VAR VAR VAR. "" ""VAR 'VAR-VAR: VAR' VAR VAR."") VAR VAR VAR.VAR(): VAR VAR( ""VAR VAR VAR VAR.VAR VAR. "" ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR.VAR():  VAR VAR.VAR VAR VAR(VAR.VAR): VAR.VAR.VAR() VAR   VAR VAR.VAR.VAR VAR VAR: VAR VAR VAR: VAR.VAR() VAR VAR.VAR == 0: VAR VAR = VAR.VAR(VAR) VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR: VAR VAR VAR VAR:    VAR = VAR.VAR() VAR VAR:  VAR VAR  VAR VAR: VAR = VAR.VAR.VAR.VAR() VAR VAR VAR:  VAR VAR VAR == VAR'\VAR\VAR': VAR  VAR VAR.VAR: VAR.VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR.VAR): VAR VAR.VAR.VAR[-1].VAR VAR: VAR VAR.VAR ",1,15
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,test/test_response.py,"import socket
import zlib

from io import BytesIO, BufferedReader

import pytest
import mock

from urllib3.response import HTTPResponse
from urllib3.exceptions import (
    DecodeError, ResponseNotChunked, ProtocolError, InvalidHeader
)
from urllib3.packages.six.moves import http_client as httplib
from urllib3.util.retry import Retry, RequestHistory
from urllib3.util.response import is_fp_closed

from base64 import b64decode

# A known random (i.e, not-too-compressible) payload generated with:
#    """".join(random.choice(string.printable) for i in xrange(512))
#    .encode(""zlib"").encode(""base64"")
# Randomness in tests == bad, and fixing a seed may not be sufficient.
ZLIB_PAYLOAD = b64decode(b""""""\
eJwFweuaoQAAANDfineQhiKLUiaiCzvuTEmNNlJGiL5QhnGpZ99z8luQfe1AHoMioB+QSWHQu/L+
lzd7W5CipqYmeVTBjdgSATdg4l4Z2zhikbuF+EKn69Q0DTpdmNJz8S33odfJoVEexw/l2SS9nFdi
pis7KOwXzfSqarSo9uJYgbDGrs1VNnQpT9f8zAorhYCEZronZQF9DuDFfNK3Hecc+WHLnZLQptwk
nufw8S9I43sEwxsT71BiqedHo0QeIrFE01F/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/nNvDGKZ
Khe5TF36JbnKVjdcL1EUNpwrWVfQpFYJ/WWm2b74qNeSZeQv5/xBhRdOmKTJFYgO96PwrHBlsnLn
a3l0LwJsloWpMbzByU5WLbRE6X5INFqjQOtIwYz5BAlhkn+kVqJvWM5vBlfrwP42ifonM5yF4ciJ
auHVks62997mNGOsM7WXNG3P98dBHPo2NhbTvHleL0BI5dus2JY81MUOnK3SGWLH8HeWPa1t5KcW
S5moAj5HexY/g/F8TctpxwsvyZp38dXeLDjSQvEQIkF7XR3YXbeZgKk3V34KGCPOAeeuQDIgyVhV
nP4HF2uWHA=="""""")


@pytest.fixture
def sock():
    s = socket.socket()
    yield s
    s.close()


class TestLegacyResponse(object):
    def test_getheaders(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheaders() == headers

    def test_getheader(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheader('host') == 'example.com'


class TestResponse(object):
    def test_cache_content(self):
        r = HTTPResponse('foo')
        assert r.data == 'foo'
        assert r._body == 'foo'

    def test_default(self):
        r = HTTPResponse()
        assert r.data is None

    def test_none(self):
        r = HTTPResponse(None)
        assert r.data is None

    def test_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=True)

        assert fp.tell() == len(b'foo')
        assert r.data == b'foo'

    def test_no_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=False)

        assert fp.tell() == 0
        assert r.data == b'foo'
        assert fp.tell() == len(b'foo')

    def test_decode_bad_data(self):
        fp = BytesIO(b'\x00' * 10)
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'deflate'})

    def test_reference_read(self):
        fp = BytesIO(b'foo')
        r = HTTPResponse(fp, preload_content=False)

        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'})

        assert r.data == b'foo'

    def test_decode_deflate_case_insensitve(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'DeFlAtE'})

        assert r.data == b'foo'

    def test_chunked_decoding_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(3) == b''
        # Buffer in case we need to switch to the raw stream
        assert r._decoder._data is not None
        assert r.read(1) == b'f'
        # Now that we've decoded data, we just stream through the decoder
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_deflate2(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(1) == b''
        assert r.read(1) == b'f'
        # Once we've decoded data, we just stream to the decoder; no buffering
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                         preload_content=False)

        assert r.read(11) == b''
        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_gzip_multi_member(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    def test_decode_gzip_error(self):
        fp = BytesIO(b'foo')
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'gzip'})

    def test_decode_gzip_swallow_garbage(self):
        # When data comes from multiple calls to read(), data after
        # the first zlib error (here triggered by garbage) should be
        # ignored.
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={'content-encoding': 'gzip'}, preload_content=False)
        ret = b''
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break

        assert ret == b'foofoofoo'

    def test_chunked_decoding_gzip_swallow_garbage(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    def test_multi_decoding_deflate_deflate(self):
        data = zlib.compress(zlib.compress(b'foo'))

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, deflate'})

        assert r.data == b'foo'

    def test_multi_decoding_deflate_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(zlib.compress(b'foo'))
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, gzip'})

        assert r.data == b'foo'

    def test_multi_decoding_gzip_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(data)
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip, gzip'})

        assert r.data == b'foo'

    def test_body_blob(self):
        resp = HTTPResponse(b'foo')
        assert resp.data == b'foo'
        assert resp.closed

    def test_io(self, sock):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)

        assert not resp.closed
        assert resp.readable()
        assert not resp.writable()
        with pytest.raises(IOError):
            resp.fileno()

        resp.close()
        assert resp.closed

        # Try closing with an `httplib.HTTPResponse`, because it has an
        # `isclosed` method.
        try:
            hlr = httplib.HTTPResponse(sock)
            resp2 = HTTPResponse(hlr, preload_content=False)
            assert not resp2.closed
            resp2.close()
            assert resp2.closed
        finally:
            hlr.close()

        # also try when only data is present.
        resp3 = HTTPResponse('foodata')
        with pytest.raises(IOError):
            resp3.fileno()

        resp3._fp = 2
        # A corner case where _fp is present but doesn't have `closed`,
        # `isclosed`, or `fileno`.  Unlikely, but possible.
        assert resp3.closed
        with pytest.raises(IOError):
            resp3.fileno()

    def test_io_closed_consistently(self, sock):
        try:
            hlr = httplib.HTTPResponse(sock)
            hlr.fp = BytesIO(b'foo')
            hlr.chunked = 0
            hlr.length = 3
            with HTTPResponse(hlr, preload_content=False) as resp:
                assert not resp.closed
                assert not resp._fp.isclosed()
                assert not is_fp_closed(resp._fp)
                assert not resp.isclosed()
                resp.read()
                assert resp.closed
                assert resp._fp.isclosed()
                assert is_fp_closed(resp._fp)
                assert resp.isclosed()
        finally:
            hlr.close()

    def test_io_bufferedreader(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp)

        assert br.read() == b'foo'

        br.close()
        assert resp.closed

        b = b'fooandahalf'
        fp = BytesIO(b)
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp, 5)

        br.read(1)  # sets up the buffer, reading 5
        assert len(fp.read()) == (len(b) - 5)

        # This is necessary to make sure the ""no bytes left"" part of `readinto`
        # gets tested.
        while not br.closed:
            br.read(5)

    def test_streaming(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_streaming_tell(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        position = 0

        position += len(next(stream))
        assert 2 == position
        assert position == resp.tell()

        position += len(next(stream))
        assert 3 == position
        assert position == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming_tell(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        uncompressed_data = b'foo'
        data = compress.compress(uncompressed_data)
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream()

        # Read everything
        payload = next(stream)
        assert payload == uncompressed_data

        assert len(data) == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate_streaming_tell_intermediate_point(self):
        # Ensure that ``tell()`` returns the correct number of bytes when
        # part-way through streaming compressed content.
        NUMBER_OF_READS = 10

        class MockCompressedDataReading(BytesIO):
            """"""
            A ByteIO-like reader returning ``payload`` in ``NUMBER_OF_READS``
            calls to ``read``.
            """"""

            def __init__(self, payload, payload_part_size):
                self.payloads = [
                    payload[i*payload_part_size:(i+1)*payload_part_size]
                    for i in range(NUMBER_OF_READS+1)]

                assert b"""".join(self.payloads) == payload

            def read(self, _):
                # Amount is unused.
                if len(self.payloads) > 0:
                    return self.payloads.pop(0)
                return b""""

        uncompressed_data = zlib.decompress(ZLIB_PAYLOAD)

        payload_part_size = len(ZLIB_PAYLOAD) // NUMBER_OF_READS
        fp = MockCompressedDataReading(ZLIB_PAYLOAD, payload_part_size)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream()

        parts_positions = [(part, resp.tell()) for part in stream]
        end_of_stream = resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

        parts, positions = zip(*parts_positions)

        # Check that the payload is equal to the uncompressed data
        payload = b"""".join(parts)
        assert uncompressed_data == payload

        # Check that the positions in the stream are correct
        expected = [(i+1)*payload_part_size for i in range(NUMBER_OF_READS)]
        assert expected == list(positions)

        # Check that the end of the stream is in the correct place
        assert len(ZLIB_PAYLOAD) == end_of_stream

    def test_deflate_streaming(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate2_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_empty_stream(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        with pytest.raises(StopIteration):
            next(stream)

    def test_length_no_header(self):
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        assert resp.length_remaining is None

    def test_length_w_valid_header(self):
        headers = {""content-length"": ""5""}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

    def test_length_w_bad_header(self):
        garbage = {'content-length': 'foo'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

        garbage['content-length'] = ""-10""
        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

    def test_length_when_chunked(self):
        # This is expressly forbidden in RFC 7230 sec 3.3.2
        # We fall back to chunked in this case and try to
        # handle response ignoring content length.
        headers = {'content-length': '5',
                   'transfer-encoding': 'chunked'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining is None

    def test_length_with_multiple_content_lengths(self):
        headers = {'content-length': '5, 5, 5'}
        garbage = {'content-length': '5, 42'}
        fp = BytesIO(b'abcde')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

        with pytest.raises(InvalidHeader):
            HTTPResponse(fp, headers=garbage, preload_content=False)

    def test_length_after_read(self):
        headers = {""content-length"": ""5""}

        # Test no defined length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        resp.read()
        assert resp.length_remaining is None

        # Test our update from content-length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        resp.read()
        assert resp.length_remaining == 0

        # Test partial read
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        data = resp.stream(2)
        next(data)
        assert resp.length_remaining == 3

    def test_mock_httpresponse_stream(self):
        # Mock out a HTTP Request that does enough to make it through urllib3's
        # read() and close() calls, and also exhausts and underlying file
        # object.
        class MockHTTPRequest(object):
            self.fp = None

            def read(self, amt):
                data = self.fp.read(amt)
                if not data:
                    self.fp = None

                return data

            def close(self):
                self.fp = None

        bio = BytesIO(b'foo')
        fp = MockHTTPRequest()
        fp.fp = bio
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_mock_transfer_encoding_chunked(self):
        stream = [b""fo"", b""o"", b""bar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})

        for i, c in enumerate(resp.stream()):
            assert c == stream[i]

    def test_mock_gzipped_transfer_encoding_chunked_decoded(self):
        """"""Show that we can decode the gizpped and chunked body.""""""
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b'foobar')
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i:i+2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {'transfer-encoding': 'chunked', 'content-encoding': 'gzip'}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b''
        for c in resp.stream(decode_content=True):
            data += c

        assert b'foobar' == data

    def test_mock_transfer_encoding_chunked_custom_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        expected_response = [b'fo', b'oo', b'o', b'bb', b'bb', b'aa', b'aa', b'ar']
        response = list(resp.read_chunked(2))
        assert expected_response == response

    def test_mock_transfer_encoding_chunked_unlmtd_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.read_chunked())

    def test_read_not_chunked_response_as_chunks(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        r = resp.read_chunked()
        with pytest.raises(ResponseNotChunked):
            next(r)

    def test_invalid_chunks(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedInvalidEncoding(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        with pytest.raises(ProtocolError):
            next(resp.read_chunked())

    def test_chunked_response_without_crlf_on_end(self):
        stream = [b""foo"", b""bar"", b""baz""]
        fp = MockChunkedEncodingWithoutCRLFOnEnd(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_response_with_extensions(self):
        stream = [b""foo"", b""bar""]
        fp = MockChunkedEncodingWithExtensions(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_head_response(self):
        r = httplib.HTTPResponse(MockSock, method='HEAD')
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse('',
                            preload_content=False,
                            headers={'transfer-encoding': 'chunked'},
                            original_response=r)
        assert resp.chunked is True

        resp.supports_chunked_reads = lambda: True
        resp.release_conn = mock.Mock()
        for _ in resp.stream():
            continue
        resp.release_conn.assert_called_once_with()

    def test_get_case_insensitive_headers(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.headers.get('host') == 'example.com'
        assert r.headers.get('Host') == 'example.com'

    def test_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp)
        assert resp.retries is None
        retry = Retry()
        resp = HTTPResponse(fp, retries=retry)
        assert resp.retries == retry

    def test_geturl(self):
        fp = BytesIO(b'')
        request_url = 'https://example.com'
        resp = HTTPResponse(fp, request_url=request_url)
        assert resp.geturl() == request_url

    def test_geturl_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, request_url='http://example.com')
        request_histories = [
            RequestHistory(method='GET', url='http://example.com', error=None,
                           status=301, redirect_location='https://example.com/'),
            RequestHistory(method='GET', url='https://example.com/', error=None,
                           status=301, redirect_location='https://www.example.com')]
        retry = Retry(history=request_histories)
        resp = HTTPResponse(fp, retries=retry)
        assert resp.geturl() == 'https://www.example.com'


class MockChunkedEncodingResponse(object):

    def __init__(self, content):
        """"""
        content: collection of str, each str is a chunk in response
        """"""
        self.content = content
        self.index = 0  # This class iterates over self.content.
        self.closed = False
        self.cur_chunk = b''
        self.chunks_exhausted = False

    @staticmethod
    def _encode_chunk(chunk):
        # In the general case, we can't decode the chunk to unicode
        length = '%X\r\n' % len(chunk)
        return length.encode() + chunk + b'\r\n'

    def _pop_new_chunk(self):
        if self.chunks_exhausted:
            return b""""
        try:
            chunk = self.content[self.index]
        except IndexError:
            chunk = b''
            self.chunks_exhausted = True
        else:
            self.index += 1
        chunk = self._encode_chunk(chunk)
        if not isinstance(chunk, bytes):
            chunk = chunk.encode()
        return chunk

    def pop_current_chunk(self, amt=-1, till_crlf=False):
        if amt > 0 and till_crlf:
            raise ValueError(""Can't specify amt and till_crlf."")
        if len(self.cur_chunk) <= 0:
            self.cur_chunk = self._pop_new_chunk()
        if till_crlf:
            try:
                i = self.cur_chunk.index(b""\r\n"")
            except ValueError:
                # No CRLF in current chunk -- probably caused by encoder.
                self.cur_chunk = b""""
                return b""""
            else:
                chunk_part = self.cur_chunk[:i+2]
                self.cur_chunk = self.cur_chunk[i+2:]
                return chunk_part
        elif amt <= -1:
            chunk_part = self.cur_chunk
            self.cur_chunk = b''
            return chunk_part
        else:
            try:
                chunk_part = self.cur_chunk[:amt]
            except IndexError:
                chunk_part = self.cur_chunk
                self.cur_chunk = b''
            else:
                self.cur_chunk = self.cur_chunk[amt:]
            return chunk_part

    def readline(self):
        return self.pop_current_chunk(till_crlf=True)

    def read(self, amt=-1):
        return self.pop_current_chunk(amt)

    def flush(self):
        # Python 3 wants this method.
        pass

    def close(self):
        self.closed = True


class MockChunkedInvalidEncoding(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return 'ZZZ\r\n%s\r\n' % chunk.decode()


class MockChunkedEncodingWithoutCRLFOnEnd(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X\r\n%s%s' % (len(chunk), chunk.decode(),
                               ""\r\n"" if len(chunk) > 0 else """")


class MockChunkedEncodingWithExtensions(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X;asd=qwe\r\n%s\r\n' % (len(chunk), chunk.decode())


class MockSock(object):
    @classmethod
    def makefile(cls, *args, **kwargs):
        return",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR ) VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR VAR VAR     VAR = VAR(VAR""""""\ VAR+VAR/VAR+ VAR+VAR/VAR VAR+VAR VAR/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/VAR VAR/VAR/VAR VAR+VAR VAR VAR/VAR/VAR VAR=="""""") @VAR.VAR VAR VAR(): VAR = VAR.VAR() VAR VAR VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR VAR(VAR): VAR = VAR('VAR') VAR VAR.VAR == 'VAR' VAR VAR.VAR == 'VAR' VAR VAR(VAR): VAR = VAR() VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 0 VAR VAR.VAR == VAR'VAR' VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR(VAR): VAR = VAR(VAR'\VAR' * 10) VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(3) == VAR''  VAR VAR.VAR.VAR VAR VAR VAR VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(1) == VAR'' VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(11) == VAR'' VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR):    VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR( VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR VAR.VAR() VAR VAR VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR.VAR   VAR: VAR = VAR.VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR.VAR() VAR VAR.VAR VAR: VAR.VAR()  VAR = VAR('VAR') VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR = 2   VAR VAR.VAR VAR VAR.VAR(VAR): VAR.VAR() VAR VAR(VAR, VAR): VAR: VAR = VAR.VAR(VAR) VAR.VAR = VAR(VAR'VAR') VAR.VAR = 0 VAR.VAR = 3 VAR VAR(VAR, VAR=VAR) VAR VAR: VAR VAR VAR.VAR VAR VAR VAR.VAR.VAR() VAR VAR VAR(VAR.VAR) VAR VAR VAR.VAR() VAR.VAR() VAR VAR.VAR VAR VAR.VAR.VAR() VAR VAR(VAR.VAR) VAR VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR) VAR VAR.VAR() == VAR'VAR' VAR.VAR() VAR VAR.VAR VAR = VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR, 5) VAR.VAR(1)  VAR VAR(VAR.VAR()) == (VAR(VAR) - 5)   VAR VAR VAR.VAR: VAR.VAR(5) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR = 0 VAR += VAR(VAR(VAR)) VAR 2 == VAR VAR VAR == VAR.VAR() VAR += VAR(VAR(VAR)) VAR 3 == VAR VAR VAR == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR'VAR' VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR()  VAR = VAR(VAR) VAR VAR == VAR VAR VAR(VAR) == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR):   VAR = 10 VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR ``VAR`` VAR ``VAR`` VAR VAR ``VAR``. """""" VAR VAR(VAR, VAR, VAR): VAR.VAR = [ VAR[VAR*VAR:(VAR+1)*VAR] VAR VAR VAR VAR(VAR+1)] VAR VAR"""".VAR(VAR.VAR) == VAR VAR VAR(VAR, VAR):  VAR VAR(VAR.VAR) > 0: VAR VAR.VAR.VAR(0) VAR VAR"""" VAR = VAR.VAR(VAR) VAR = VAR(VAR)  VAR = VAR(VAR, VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR() VAR = [(VAR, VAR.VAR()) VAR VAR VAR VAR] VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR, VAR = VAR(*VAR)  VAR = VAR"""".VAR(VAR) VAR VAR == VAR  VAR = [(VAR+1)*VAR VAR VAR VAR VAR(VAR)] VAR VAR == VAR(VAR)  VAR VAR(VAR) == VAR VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR['VAR-VAR'] = ""-10"" VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR):    VAR = {'VAR-VAR': '5', 'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {'VAR-VAR': '5, 5, 5'} VAR = {'VAR-VAR': '5, 42'} VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR.VAR(VAR): VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""}  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR VAR VAR  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR == 0  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR(2) VAR(VAR) VAR VAR.VAR == 3 VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(VAR) VAR VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR): VAR.VAR = VAR VAR = VAR(VAR'VAR') VAR = VAR() VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR, VAR VAR VAR(VAR.VAR()): VAR VAR == VAR[VAR] VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR:VAR+2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': 'VAR'} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR.VAR(VAR=VAR): VAR += VAR VAR VAR'VAR' == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR = [VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR'] VAR = VAR(VAR.VAR(2)) VAR VAR == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR = VAR VAR.VAR = VAR VAR = VAR('', VAR=VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR VAR VAR VAR.VAR = VAR: VAR VAR.VAR = VAR.VAR() VAR VAR VAR VAR.VAR(): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR = VAR() VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = 'VAR: VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR='VAR: VAR = [ VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR = VAR(VAR=VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 'VAR: VAR VAR(VAR): VAR VAR(VAR, VAR): """""" VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR """""" VAR.VAR = VAR VAR.VAR = 0  VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR = '%VAR\VAR\VAR' % VAR(VAR) VAR VAR.VAR() + VAR + VAR'\VAR\VAR' VAR VAR(VAR): VAR VAR.VAR: VAR VAR"""" VAR: VAR = VAR.VAR[VAR.VAR] VAR VAR: VAR = VAR'' VAR.VAR = VAR VAR: VAR.VAR += 1 VAR = VAR.VAR(VAR) VAR VAR VAR(VAR, VAR): VAR = VAR.VAR() VAR VAR VAR VAR(VAR, VAR=-1, VAR=VAR): VAR VAR > 0 VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR."") VAR VAR(VAR.VAR) <= 0: VAR.VAR = VAR.VAR() VAR VAR: VAR: VAR = VAR.VAR.VAR(VAR""\VAR\VAR"") VAR VAR:  VAR.VAR = VAR"""" VAR VAR"""" VAR: VAR = VAR.VAR[:VAR+2] VAR.VAR = VAR.VAR[VAR+2:] VAR VAR VAR VAR <= -1: VAR = VAR.VAR VAR.VAR = VAR'' VAR VAR VAR: VAR: VAR = VAR.VAR[:VAR] VAR VAR: VAR = VAR.VAR VAR.VAR = VAR'' VAR: VAR.VAR = VAR.VAR[VAR:] VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR=VAR) VAR VAR(VAR, VAR=-1): VAR VAR.VAR(VAR) VAR VAR(VAR):  VAR VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR): VAR VAR(VAR, VAR): VAR 'VAR\VAR\VAR%VAR\VAR\VAR' % VAR.VAR() VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR\VAR\VAR%VAR%VAR' % (VAR(VAR), VAR.VAR(), ""\VAR\VAR"" VAR VAR(VAR) > 0 VAR """") VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR;VAR=VAR\VAR\VAR%VAR\VAR\VAR' % (VAR(VAR), VAR.VAR()) VAR VAR(VAR): @VAR VAR VAR(VAR, *VAR, **VAR): VAR ",1,15
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,docs/requirements.txt,"-r ../dev-requirements.txt
sphinx
alabaster
requests>=2,<2.16",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"-VAR ../VAR-VAR.VAR VAR VAR VAR>=2,<2.16 ",1,15
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,src/urllib3/filepost.py,"from __future__ import absolute_import
import binascii
import codecs
import os

from io import BytesIO

from .packages import six
from .packages.six import b
from .fields import RequestField

writer = codecs.lookup('utf-8')[3]


def choose_boundary():
    """"""
    Our embarrassingly-simple replacement for mimetools.choose_boundary.
    """"""
    boundary = binascii.hexlify(os.urandom(16))
    if six.PY3:
        boundary = boundary.decode('ascii')
    return boundary


def iter_field_objects(fields):
    """"""
    Iterate over fields.

    Supports list of (k, v) tuples and dicts, and lists of
    :class:`~urllib3.fields.RequestField`.

    """"""
    if isinstance(fields, dict):
        i = six.iteritems(fields)
    else:
        i = iter(fields)

    for field in i:
        if isinstance(field, RequestField):
            yield field
        else:
            yield RequestField.from_tuples(*field)


def iter_fields(fields):
    """"""
    .. deprecated:: 1.6

    Iterate over fields.

    The addition of :class:`~urllib3.fields.RequestField` makes this function
    obsolete. Instead, use :func:`iter_field_objects`, which returns
    :class:`~urllib3.fields.RequestField` objects.

    Supports list of (k, v) tuples and dicts.
    """"""
    if isinstance(fields, dict):
        return ((k, v) for k, v in six.iteritems(fields))

    return ((k, v) for k, v in fields)


def encode_multipart_formdata(fields, boundary=None):
    """"""
    Encode a dictionary of ``fields`` using the multipart/form-data MIME format.

    :param fields:
        Dictionary of fields or list of (key, :class:`~urllib3.fields.RequestField`).

    :param boundary:
        If not specified, then a random boundary will be generated using
        :func:`urllib3.filepost.choose_boundary`.
    """"""
    body = BytesIO()
    if boundary is None:
        boundary = choose_boundary()

    for field in iter_field_objects(fields):
        body.write(b('--%s\r\n' % (boundary)))

        writer(body).write(field.render_headers())
        data = field.data

        if isinstance(data, int):
            data = str(data)  # Backwards compatibility

        if isinstance(data, six.text_type):
            writer(body).write(data)
        else:
            body.write(data)

        body.write(b'\r\n')

    body.write(b('--%s--\r\n' % (boundary)))

    content_type = str('multipart/form-data; boundary=%s' % boundary)

    return body.getvalue(), content_type",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR VAR .VAR.VAR VAR VAR VAR .VAR VAR VAR VAR = VAR.VAR('VAR-8')[3] VAR VAR(): """""" VAR VAR-VAR VAR VAR VAR.VAR. """""" VAR = VAR.VAR(VAR.VAR(16)) VAR VAR.VAR: VAR = VAR.VAR('VAR') VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR, VAR VAR VAR :VAR:`~VAR.VAR.VAR`. """""" VAR VAR(VAR, VAR): VAR = VAR.VAR(VAR) VAR: VAR = VAR(VAR) VAR VAR VAR VAR: VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR.VAR(*VAR) VAR VAR(VAR): """""" .. VAR:: 1.6 VAR VAR VAR. VAR VAR VAR :VAR:`~VAR.VAR.VAR` VAR VAR VAR VAR. VAR, VAR :VAR:`VAR`, VAR VAR :VAR:`~VAR.VAR.VAR` VAR. VAR VAR VAR (VAR, VAR) VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR ((VAR, VAR) VAR VAR, VAR VAR VAR.VAR(VAR)) VAR ((VAR, VAR) VAR VAR, VAR VAR VAR) VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR ``VAR`` VAR VAR VAR/VAR-VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR (VAR, :VAR:`~VAR.VAR.VAR`). :VAR VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR.VAR`. """""" VAR = VAR() VAR VAR VAR VAR: VAR = VAR() VAR VAR VAR VAR(VAR): VAR.VAR(VAR('--%VAR\VAR\VAR' % (VAR))) VAR(VAR).VAR(VAR.VAR()) VAR = VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR)  VAR VAR(VAR, VAR.VAR): VAR(VAR).VAR(VAR) VAR: VAR.VAR(VAR) VAR.VAR(VAR'\VAR\VAR') VAR.VAR(VAR('--%VAR--\VAR\VAR' % (VAR))) VAR = VAR('VAR/VAR-VAR; VAR=%VAR' % VAR) VAR VAR.VAR(), VAR ",1,15
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,src/urllib3/response.py,"from __future__ import absolute_import
from contextlib import contextmanager
import zlib
import io
import logging
from socket import timeout as SocketTimeout
from socket import error as SocketError

try:
    import brotli
except ImportError:
    brotli = None

from ._collections import HTTPHeaderDict
from .exceptions import (
    BodyNotHttplibCompatible, ProtocolError, DecodeError, ReadTimeoutError,
    ResponseNotChunked, IncompleteRead, InvalidHeader
)
from .packages.six import string_types as basestring, PY3
from .packages.six.moves import http_client as httplib
from .connection import HTTPException, BaseSSLError
from .util.response import is_fp_closed, is_response_to_head

log = logging.getLogger(__name__)


class DeflateDecoder(object):

    def __init__(self):
        self._first_try = True
        self._data = b''
        self._obj = zlib.decompressobj()

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        if not data:
            return data

        if not self._first_try:
            return self._obj.decompress(data)

        self._data += data
        try:
            decompressed = self._obj.decompress(data)
            if decompressed:
                self._first_try = False
                self._data = None
            return decompressed
        except zlib.error:
            self._first_try = False
            self._obj = zlib.decompressobj(-zlib.MAX_WBITS)
            try:
                return self.decompress(self._data)
            finally:
                self._data = None


class GzipDecoderState(object):

    FIRST_MEMBER = 0
    OTHER_MEMBERS = 1
    SWALLOW_DATA = 2


class GzipDecoder(object):

    def __init__(self):
        self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)
        self._state = GzipDecoderState.FIRST_MEMBER

    def __getattr__(self, name):
        return getattr(self._obj, name)

    def decompress(self, data):
        ret = bytearray()
        if self._state == GzipDecoderState.SWALLOW_DATA or not data:
            return bytes(ret)
        while True:
            try:
                ret += self._obj.decompress(data)
            except zlib.error:
                previous_state = self._state
                # Ignore data after the first error
                self._state = GzipDecoderState.SWALLOW_DATA
                if previous_state == GzipDecoderState.OTHER_MEMBERS:
                    # Allow trailing garbage acceptable in other gzip clients
                    return bytes(ret)
                raise
            data = self._obj.unused_data
            if not data:
                return bytes(ret)
            self._state = GzipDecoderState.OTHER_MEMBERS
            self._obj = zlib.decompressobj(16 + zlib.MAX_WBITS)


if brotli is not None:
    class BrotliDecoder(object):
        # Supports both 'brotlipy' and 'Brotli' packages
        # since they share an import name. The top branches
        # are for 'brotlipy' and bottom branches for 'Brotli'
        def __init__(self):
            self._obj = brotli.Decompressor()

        def decompress(self, data):
            if hasattr(self._obj, 'decompress'):
                return self._obj.decompress(data)
            return self._obj.process(data)

        def flush(self):
            if hasattr(self._obj, 'flush'):
                return self._obj.flush()
            return b''


class MultiDecoder(object):
    """"""
    From RFC7231:
        If one or more encodings have been applied to a representation, the
        sender that applied the encodings MUST generate a Content-Encoding
        header field that lists the content codings in the order in which
        they were applied.
    """"""

    def __init__(self, modes):
        self._decoders = [_get_decoder(m.strip()) for m in modes.split(',')]

    def flush(self):
        return self._decoders[0].flush()

    def decompress(self, data):
        for d in reversed(self._decoders):
            data = d.decompress(data)
        return data


def _get_decoder(mode):
    if ',' in mode:
        return MultiDecoder(mode)

    if mode == 'gzip':
        return GzipDecoder()

    if brotli is not None and mode == 'br':
        return BrotliDecoder()

    return DeflateDecoder()


class HTTPResponse(io.IOBase):
    """"""
    HTTP Response container.

    Backwards-compatible to httplib's HTTPResponse but the response ``body`` is
    loaded and decoded on-demand when the ``data`` property is accessed.  This
    class is also compatible with the Python standard library's :mod:`io`
    module, and can hence be treated as a readable object in the context of that
    framework.

    Extra parameters for behaviour not present in httplib.HTTPResponse:

    :param preload_content:
        If True, the response's body will be preloaded during construction.

    :param decode_content:
        If True, will attempt to decode the body based on the
        'content-encoding' header.

    :param original_response:
        When this HTTPResponse wrapper is generated from an httplib.HTTPResponse
        object, it's convenient to include the original for debug purposes. It's
        otherwise unused.

    :param retries:
        The retries contains the last :class:`~urllib3.util.retry.Retry` that
        was used during the request.

    :param enforce_content_length:
        Enforce content length checking. Body returned by server must match
        value of Content-Length header, if present. Otherwise, raise error.
    """"""

    CONTENT_DECODERS = ['gzip', 'deflate']
    if brotli is not None:
        CONTENT_DECODERS += ['br']
    REDIRECT_STATUSES = [301, 302, 303, 307, 308]

    def __init__(self, body='', headers=None, status=0, version=0, reason=None,
                 strict=0, preload_content=True, decode_content=True,
                 original_response=None, pool=None, connection=None, msg=None,
                 retries=None, enforce_content_length=False,
                 request_method=None, request_url=None):

        if isinstance(headers, HTTPHeaderDict):
            self.headers = headers
        else:
            self.headers = HTTPHeaderDict(headers)
        self.status = status
        self.version = version
        self.reason = reason
        self.strict = strict
        self.decode_content = decode_content
        self.retries = retries
        self.enforce_content_length = enforce_content_length

        self._decoder = None
        self._body = None
        self._fp = None
        self._original_response = original_response
        self._fp_bytes_read = 0
        self.msg = msg
        self._request_url = request_url

        if body and isinstance(body, (basestring, bytes)):
            self._body = body

        self._pool = pool
        self._connection = connection

        if hasattr(body, 'read'):
            self._fp = body

        # Are we using the chunked-style of transfer encoding?
        self.chunked = False
        self.chunk_left = None
        tr_enc = self.headers.get('transfer-encoding', '').lower()
        # Don't incur the penalty of creating a list and then discarding it
        encodings = (enc.strip() for enc in tr_enc.split("",""))
        if ""chunked"" in encodings:
            self.chunked = True

        # Determine length of response
        self.length_remaining = self._init_length(request_method)

        # If requested, preload the body.
        if preload_content and not self._body:
            self._body = self.read(decode_content=decode_content)

    def get_redirect_location(self):
        """"""
        Should we redirect and where to?

        :returns: Truthy redirect location string if we got a redirect status
            code and valid location. ``None`` if redirect status and no
            location. ``False`` if not a redirect status code.
        """"""
        if self.status in self.REDIRECT_STATUSES:
            return self.headers.get('location')

        return False

    def release_conn(self):
        if not self._pool or not self._connection:
            return

        self._pool._put_conn(self._connection)
        self._connection = None

    @property
    def data(self):
        # For backwords-compat with earlier urllib3 0.4 and earlier.
        if self._body:
            return self._body

        if self._fp:
            return self.read(cache_content=True)

    @property
    def connection(self):
        return self._connection

    def isclosed(self):
        return is_fp_closed(self._fp)

    def tell(self):
        """"""
        Obtain the number of bytes pulled over the wire so far. May differ from
        the amount of content returned by :meth:``HTTPResponse.read`` if bytes
        are encoded on the wire (e.g, compressed).
        """"""
        return self._fp_bytes_read

    def _init_length(self, request_method):
        """"""
        Set initial length value for Response content if available.
        """"""
        length = self.headers.get('content-length')

        if length is not None:
            if self.chunked:
                # This Response will fail with an IncompleteRead if it can't be
                # received as chunked. This method falls back to attempt reading
                # the response before raising an exception.
                log.warning(""Received response with both Content-Length and ""
                            ""Transfer-Encoding set. This is expressly forbidden ""
                            ""by RFC 7230 sec 3.3.2. Ignoring Content-Length and ""
                            ""attempting to process response as Transfer-Encoding: ""
                            ""chunked."")
                return None

            try:
                # RFC 7230 section 3.3.2 specifies multiple content lengths can
                # be sent in a single Content-Length header
                # (e.g. Content-Length: 42, 42). This line ensures the values
                # are all valid ints and that as long as the `set` length is 1,
                # all values are the same. Otherwise, the header is invalid.
                lengths = set([int(val) for val in length.split(',')])
                if len(lengths) > 1:
                    raise InvalidHeader(""Content-Length contained multiple ""
                                        ""unmatching values (%s)"" % length)
                length = lengths.pop()
            except ValueError:
                length = None
            else:
                if length < 0:
                    length = None

        # Convert status to int for comparison
        # In some cases, httplib returns a status of ""_UNKNOWN""
        try:
            status = int(self.status)
        except ValueError:
            status = 0

        # Check for responses that shouldn't include a body
        if status in (204, 304) or 100 <= status < 200 or request_method == 'HEAD':
            length = 0

        return length

    def _init_decoder(self):
        """"""
        Set-up the _decoder attribute if necessary.
        """"""
        # Note: content-encoding value should be case-insensitive, per RFC 7230
        # Section 3.2
        content_encoding = self.headers.get('content-encoding', '').lower()
        if self._decoder is None:
            if content_encoding in self.CONTENT_DECODERS:
                self._decoder = _get_decoder(content_encoding)
            elif ',' in content_encoding:
                encodings = [
                    e.strip() for e in content_encoding.split(',')
                    if e.strip() in self.CONTENT_DECODERS]
                if len(encodings):
                    self._decoder = _get_decoder(content_encoding)

    DECODER_ERROR_CLASSES = (IOError, zlib.error)
    if brotli is not None:
        DECODER_ERROR_CLASSES += (brotli.error,)

    def _decode(self, data, decode_content, flush_decoder):
        """"""
        Decode the data passed in and potentially flush the decoder.
        """"""
        if not decode_content:
            return data

        try:
            if self._decoder:
                data = self._decoder.decompress(data)
        except self.DECODER_ERROR_CLASSES as e:
            content_encoding = self.headers.get('content-encoding', '').lower()
            raise DecodeError(
                ""Received response with content-encoding: %s, but ""
                ""failed to decode it."" % content_encoding, e)
        if flush_decoder:
            data += self._flush_decoder()

        return data

    def _flush_decoder(self):
        """"""
        Flushes the decoder. Should only be called if the decoder is actually
        being used.
        """"""
        if self._decoder:
            buf = self._decoder.decompress(b'')
            return buf + self._decoder.flush()

        return b''

    @contextmanager
    def _error_catcher(self):
        """"""
        Catch low-level python exceptions, instead re-raising urllib3
        variants, so that low-level exceptions are not leaked in the
        high-level api.

        On exit, release the connection back to the pool.
        """"""
        clean_exit = False

        try:
            try:
                yield

            except SocketTimeout:
                # FIXME: Ideally we'd like to include the url in the ReadTimeoutError but
                # there is yet no clean way to get at it from this context.
                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except BaseSSLError as e:
                # FIXME: Is there a better way to differentiate between SSLErrors?
                if 'read operation timed out' not in str(e):  # Defensive:
                    # This shouldn't happen but just in case we're missing an edge
                    # case, let's avoid swallowing SSL errors.
                    raise

                raise ReadTimeoutError(self._pool, None, 'Read timed out.')

            except (HTTPException, SocketError) as e:
                # This includes IncompleteRead.
                raise ProtocolError('Connection broken: %r' % e, e)

            # If no exception is thrown, we should avoid cleaning up
            # unnecessarily.
            clean_exit = True
        finally:
            # If we didn't terminate cleanly, we need to throw away our
            # connection.
            if not clean_exit:
                # The response may not be closed but we're not going to use it
                # anymore so close it now to ensure that the connection is
                # released back to the pool.
                if self._original_response:
                    self._original_response.close()

                # Closing the response may not actually be sufficient to close
                # everything, so if we have a hold of the connection close that
                # too.
                if self._connection:
                    self._connection.close()

            # If we hold the original response but it's closed now, we should
            # return the connection back to the pool.
            if self._original_response and self._original_response.isclosed():
                self.release_conn()

    def read(self, amt=None, decode_content=None, cache_content=False):
        """"""
        Similar to :meth:`httplib.HTTPResponse.read`, but with two additional
        parameters: ``decode_content`` and ``cache_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.

        :param cache_content:
            If True, will save the returned data such that the same result is
            returned despite of the state of the underlying file object. This
            is useful if you want the ``.data`` property to continue working
            after having ``.read()`` the file object. (Overridden if ``amt`` is
            set.)
        """"""
        self._init_decoder()
        if decode_content is None:
            decode_content = self.decode_content

        if self._fp is None:
            return

        flush_decoder = False
        data = None

        with self._error_catcher():
            if amt is None:
                # cStringIO doesn't like amt=None
                data = self._fp.read()
                flush_decoder = True
            else:
                cache_content = False
                data = self._fp.read(amt)
                if amt != 0 and not data:  # Platform-specific: Buggy versions of Python.
                    # Close the connection when no data is returned
                    #
                    # This is redundant to what httplib/http.client _should_
                    # already do.  However, versions of python released before
                    # December 15, 2012 (http://bugs.python.org/issue16298) do
                    # not properly close the connection in all cases. There is
                    # no harm in redundantly calling close.
                    self._fp.close()
                    flush_decoder = True
                    if self.enforce_content_length and self.length_remaining not in (0, None):
                        # This is an edge case that httplib failed to cover due
                        # to concerns of backward compatibility. We're
                        # addressing it here to make sure IncompleteRead is
                        # raised during streaming, so all calls with incorrect
                        # Content-Length are caught.
                        raise IncompleteRead(self._fp_bytes_read, self.length_remaining)

        if data:
            self._fp_bytes_read += len(data)
            if self.length_remaining is not None:
                self.length_remaining -= len(data)

            data = self._decode(data, decode_content, flush_decoder)

            if cache_content:
                self._body = data

        return data

    def stream(self, amt=2**16, decode_content=None):
        """"""
        A generator wrapper for the read() method. A call will block until
        ``amt`` bytes have been read from the connection or until the
        connection is closed.

        :param amt:
            How much of the content to read. The generator will return up to
            much data per iteration, but may return less. This is particularly
            likely when using compressed data. However, the empty string will
            never be returned.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        if self.chunked and self.supports_chunked_reads():
            for line in self.read_chunked(amt, decode_content=decode_content):
                yield line
        else:
            while not is_fp_closed(self._fp):
                data = self.read(amt=amt, decode_content=decode_content)

                if data:
                    yield data

    @classmethod
    def from_httplib(ResponseCls, r, **response_kw):
        """"""
        Given an :class:`httplib.HTTPResponse` instance ``r``, return a
        corresponding :class:`urllib3.response.HTTPResponse` object.

        Remaining parameters are passed to the HTTPResponse constructor, along
        with ``original_response=r``.
        """"""
        headers = r.msg

        if not isinstance(headers, HTTPHeaderDict):
            if PY3:
                headers = HTTPHeaderDict(headers.items())
            else:
                # Python 2.7
                headers = HTTPHeaderDict.from_httplib(headers)

        # HTTPResponse objects in Python 3 don't have a .strict attribute
        strict = getattr(r, 'strict', 0)
        resp = ResponseCls(body=r,
                           headers=headers,
                           status=r.status,
                           version=r.version,
                           reason=r.reason,
                           strict=strict,
                           original_response=r,
                           **response_kw)
        return resp

    # Backwards-compatibility methods for httplib.HTTPResponse
    def getheaders(self):
        return self.headers

    def getheader(self, name, default=None):
        return self.headers.get(name, default)

    # Backwards compatibility for http.cookiejar
    def info(self):
        return self.headers

    # Overrides from io.IOBase
    def close(self):
        if not self.closed:
            self._fp.close()

        if self._connection:
            self._connection.close()

    @property
    def closed(self):
        if self._fp is None:
            return True
        elif hasattr(self._fp, 'isclosed'):
            return self._fp.isclosed()
        elif hasattr(self._fp, 'closed'):
            return self._fp.closed
        else:
            return True

    def fileno(self):
        if self._fp is None:
            raise IOError(""HTTPResponse has no file to get a fileno from"")
        elif hasattr(self._fp, ""fileno""):
            return self._fp.fileno()
        else:
            raise IOError(""The file-like object this HTTPResponse is wrapped ""
                          ""around has no file descriptor"")

    def flush(self):
        if self._fp is not None and hasattr(self._fp, 'flush'):
            return self._fp.flush()

    def readable(self):
        # This method is required for `io` module compatibility.
        return True

    def readinto(self, b):
        # This method is required for `io` module compatibility.
        temp = self.read(len(b))
        if len(temp) == 0:
            return 0
        else:
            b[:len(temp)] = temp
            return len(temp)

    def supports_chunked_reads(self):
        """"""
        Checks if the underlying file-like object looks like a
        httplib.HTTPResponse object. We do this by testing for the fp
        attribute. If it is present we assume it returns raw chunks as
        processed by read_chunked().
        """"""
        return hasattr(self._fp, 'fp')

    def _update_chunk_length(self):
        # First, we'll figure out length of a chunk and then
        # we'll try to read it from socket.
        if self.chunk_left is not None:
            return
        line = self._fp.fp.readline()
        line = line.split(b';', 1)[0]
        try:
            self.chunk_left = int(line, 16)
        except ValueError:
            # Invalid chunked protocol response, abort.
            self.close()
            raise httplib.IncompleteRead(line)

    def _handle_chunk(self, amt):
        returned_chunk = None
        if amt is None:
            chunk = self._fp._safe_read(self.chunk_left)
            returned_chunk = chunk
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        elif amt < self.chunk_left:
            value = self._fp._safe_read(amt)
            self.chunk_left = self.chunk_left - amt
            returned_chunk = value
        elif amt == self.chunk_left:
            value = self._fp._safe_read(amt)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
            returned_chunk = value
        else:  # amt > self.chunk_left
            returned_chunk = self._fp._safe_read(self.chunk_left)
            self._fp._safe_read(2)  # Toss the CRLF at the end of the chunk.
            self.chunk_left = None
        return returned_chunk

    def read_chunked(self, amt=None, decode_content=None):
        """"""
        Similar to :meth:`HTTPResponse.read`, but with an additional
        parameter: ``decode_content``.

        :param amt:
            How much of the content to read. If specified, caching is skipped
            because it doesn't make sense to cache partial content as the full
            response.

        :param decode_content:
            If True, will attempt to decode the body based on the
            'content-encoding' header.
        """"""
        self._init_decoder()
        # FIXME: Rewrite this method and make it a class with a better structured logic.
        if not self.chunked:
            raise ResponseNotChunked(
                ""Response is not chunked. ""
                ""Header 'transfer-encoding: chunked' is missing."")
        if not self.supports_chunked_reads():
            raise BodyNotHttplibCompatible(
                ""Body should be httplib.HTTPResponse like. ""
                ""It should have have an fp attribute which returns raw chunks."")

        with self._error_catcher():
            # Don't bother reading the body of a HEAD request.
            if self._original_response and is_response_to_head(self._original_response):
                self._original_response.close()
                return

            # If a response is already read and closed
            # then return immediately.
            if self._fp.fp is None:
                return

            while True:
                self._update_chunk_length()
                if self.chunk_left == 0:
                    break
                chunk = self._handle_chunk(amt)
                decoded = self._decode(chunk, decode_content=decode_content,
                                       flush_decoder=False)
                if decoded:
                    yield decoded

            if decode_content:
                # On CPython and PyPy, we should never need to flush the
                # decoder. However, on Jython we *might* need to, so
                # lets defensively do it anyway.
                decoded = self._flush_decoder()
                if decoded:  # Platform-specific: Jython.
                    yield decoded

            # Chunk content ends with \r\n: discard it.
            while True:
                line = self._fp.fp.readline()
                if not line:
                    # Some sites may not end with '\r\n'.
                    break
                if line == b'\r\n':
                    break

            # We read everything; close the ""file"".
            if self._original_response:
                self._original_response.close()

    def geturl(self):
        """"""
        Returns the URL that was the source of this response.
        If the request that generated this response redirected, this method
        will return the final redirect location.
        """"""
        if self.retries is not None and len(self.retries.history):
            return self.retries.history[-1].redirect_location
        else:
            return self._request_url

    def __iter__(self):
        buffer = [b""""]
        for chunk in self.stream(decode_content=True):
            if b""\n"" in chunk:
                chunk = chunk.split(b""\n"")
                yield b"""".join(buffer) + chunk[0] + b""\n""
                for x in chunk[1:-1]:
                    yield x + b""\n""
                if chunk[-1]:
                    buffer = [chunk[-1]]
                else:
                    buffer = []
            else:
                buffer.append(chunk)
        if buffer:
            yield b"""".join(buffer)",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR: VAR = VAR VAR .VAR VAR VAR VAR .VAR VAR ( VAR, VAR, VAR, VAR, VAR, VAR, VAR ) VAR .VAR.VAR VAR VAR VAR VAR, VAR VAR .VAR.VAR.VAR VAR VAR VAR VAR VAR .VAR VAR VAR, VAR VAR .VAR.VAR VAR VAR, VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR VAR VAR: VAR VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR) VAR.VAR += VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR: VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR VAR.VAR = VAR.VAR(-VAR.VAR) VAR: VAR VAR.VAR(VAR.VAR) VAR: VAR.VAR = VAR VAR VAR(VAR): VAR = 0 VAR = 1 VAR = 2 VAR VAR(VAR): VAR VAR(VAR): VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR.VAR = VAR.VAR VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, VAR) VAR VAR(VAR, VAR): VAR = VAR() VAR VAR.VAR == VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR VAR: VAR: VAR += VAR.VAR.VAR(VAR) VAR VAR.VAR: VAR = VAR.VAR  VAR.VAR = VAR.VAR VAR VAR == VAR.VAR:  VAR VAR(VAR) VAR VAR = VAR.VAR.VAR VAR VAR VAR: VAR VAR(VAR) VAR.VAR = VAR.VAR VAR.VAR = VAR.VAR(16 + VAR.VAR) VAR VAR VAR VAR VAR: VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR.VAR() VAR VAR(VAR, VAR): VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR(VAR) VAR VAR.VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR'' VAR VAR(VAR): """""" VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR, VAR): VAR.VAR = [VAR(VAR.VAR()) VAR VAR VAR VAR.VAR(',')] VAR VAR(VAR): VAR VAR.VAR[0].VAR() VAR VAR(VAR, VAR): VAR VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR ',' VAR VAR: VAR VAR(VAR) VAR VAR == 'VAR': VAR VAR() VAR VAR VAR VAR VAR VAR VAR == 'VAR': VAR VAR() VAR VAR() VAR VAR(VAR.VAR): """""" VAR VAR VAR. VAR-VAR VAR VAR'VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR-VAR VAR VAR ``VAR`` VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR :VAR:`VAR` VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR.VAR: :VAR VAR: VAR VAR, VAR VAR'VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR, VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR'VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR :VAR:`~VAR.VAR.VAR.VAR` VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR, VAR VAR. VAR, VAR VAR. """""" VAR = ['VAR', 'VAR'] VAR VAR VAR VAR VAR: VAR += ['VAR'] VAR = [301, 302, 303, 307, 308] VAR VAR(VAR, VAR='', VAR=VAR, VAR=0, VAR=0, VAR=VAR, VAR=0, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR VAR(VAR, VAR): VAR.VAR = VAR VAR: VAR.VAR = VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR VAR VAR VAR(VAR, (VAR, VAR)): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, 'VAR'): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR VAR = VAR.VAR.VAR('VAR-VAR', '').VAR()  VAR = (VAR.VAR() VAR VAR VAR VAR.VAR("","")) VAR ""VAR"" VAR VAR: VAR.VAR = VAR  VAR.VAR = VAR.VAR(VAR)  VAR VAR VAR VAR VAR.VAR: VAR.VAR = VAR.VAR(VAR=VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR? :VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. ``VAR`` VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR.VAR('VAR') VAR VAR VAR VAR(VAR): VAR VAR VAR.VAR VAR VAR VAR.VAR: VAR VAR.VAR.VAR(VAR.VAR) VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR VAR.VAR: VAR VAR.VAR VAR VAR.VAR: VAR VAR.VAR(VAR=VAR) @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR): VAR VAR(VAR.VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:``VAR.VAR`` VAR VAR VAR VAR VAR VAR VAR (VAR.VAR, VAR). """""" VAR VAR.VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR') VAR VAR VAR VAR VAR: VAR VAR.VAR:    VAR.VAR(""VAR VAR VAR VAR VAR-VAR VAR "" ""VAR-VAR VAR. VAR VAR VAR VAR "" ""VAR VAR 7230 VAR 3.3.2. VAR VAR-VAR VAR "" ""VAR VAR VAR VAR VAR VAR-VAR: "" ""VAR."") VAR VAR VAR:      VAR = VAR([VAR(VAR) VAR VAR VAR VAR.VAR(',')]) VAR VAR(VAR) > 1: VAR VAR(""VAR-VAR VAR VAR "" ""VAR VAR (%VAR)"" % VAR) VAR = VAR.VAR() VAR VAR: VAR = VAR VAR: VAR VAR < 0: VAR = VAR   VAR: VAR = VAR(VAR.VAR) VAR VAR: VAR = 0  VAR VAR VAR (204, 304) VAR 100 <= VAR < 200 VAR VAR == 'VAR': VAR = 0 VAR VAR VAR VAR(VAR): """""" VAR-VAR VAR VAR VAR VAR VAR. """"""   VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR.VAR VAR VAR: VAR VAR VAR VAR.VAR: VAR.VAR = VAR(VAR) VAR ',' VAR VAR: VAR = [ VAR.VAR() VAR VAR VAR VAR.VAR(',') VAR VAR.VAR() VAR VAR.VAR] VAR VAR(VAR): VAR.VAR = VAR(VAR) VAR = (VAR, VAR.VAR) VAR VAR VAR VAR VAR: VAR += (VAR.VAR,) VAR VAR(VAR, VAR, VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR VAR: VAR VAR VAR: VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR.VAR VAR VAR: VAR = VAR.VAR.VAR('VAR-VAR', '').VAR() VAR VAR( ""VAR VAR VAR VAR-VAR: %VAR, VAR "" ""VAR VAR VAR VAR."" % VAR, VAR) VAR VAR: VAR += VAR.VAR() VAR VAR VAR VAR(VAR): """""" VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR: VAR = VAR.VAR.VAR(VAR'') VAR VAR + VAR.VAR.VAR() VAR VAR'' @VAR VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR, VAR VAR-VAR VAR VAR, VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR VAR: VAR: VAR VAR VAR:   VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR VAR VAR VAR:  VAR 'VAR VAR VAR VAR' VAR VAR VAR(VAR):    VAR VAR VAR(VAR.VAR, VAR, 'VAR VAR VAR.') VAR (VAR, VAR) VAR VAR:  VAR VAR('VAR VAR: %VAR' % VAR, VAR)   VAR = VAR VAR:   VAR VAR VAR:    VAR VAR.VAR: VAR.VAR.VAR()    VAR VAR.VAR: VAR.VAR.VAR()   VAR VAR.VAR VAR VAR.VAR.VAR(): VAR.VAR() VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR`` VAR ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR ``.VAR`` VAR VAR VAR VAR VAR VAR ``.VAR()`` VAR VAR VAR. (VAR VAR ``VAR`` VAR VAR.) """""" VAR.VAR() VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR.VAR VAR VAR: VAR VAR = VAR VAR = VAR VAR VAR.VAR(): VAR VAR VAR VAR:  VAR = VAR.VAR.VAR() VAR = VAR VAR: VAR = VAR VAR = VAR.VAR.VAR(VAR) VAR VAR != 0 VAR VAR VAR:         VAR.VAR.VAR() VAR = VAR VAR VAR.VAR VAR VAR.VAR VAR VAR (0, VAR):      VAR VAR(VAR.VAR, VAR.VAR) VAR VAR: VAR.VAR += VAR(VAR) VAR VAR.VAR VAR VAR VAR: VAR.VAR -= VAR(VAR) VAR = VAR.VAR(VAR, VAR, VAR) VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=2**16, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR() VAR. VAR VAR VAR VAR VAR ``VAR`` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR VAR.VAR VAR VAR.VAR(): VAR VAR VAR VAR.VAR(VAR, VAR=VAR): VAR VAR VAR: VAR VAR VAR(VAR.VAR): VAR = VAR.VAR(VAR=VAR, VAR=VAR) VAR VAR: VAR VAR @VAR VAR VAR(VAR, VAR, **VAR): """""" VAR VAR :VAR:`VAR.VAR` VAR ``VAR``, VAR VAR VAR :VAR:`VAR.VAR.VAR` VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR ``VAR=VAR``. """""" VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR VAR: VAR = VAR(VAR.VAR()) VAR:  VAR = VAR.VAR(VAR)  VAR = VAR(VAR, 'VAR', 0) VAR = VAR(VAR=VAR, VAR=VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR.VAR, VAR=VAR, VAR=VAR, **VAR) VAR VAR  VAR VAR(VAR): VAR VAR.VAR VAR VAR(VAR, VAR, VAR=VAR): VAR VAR.VAR.VAR(VAR, VAR)  VAR VAR(VAR): VAR VAR.VAR  VAR VAR(VAR): VAR VAR VAR.VAR: VAR.VAR.VAR() VAR VAR.VAR: VAR.VAR.VAR() @VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR VAR: VAR VAR VAR VAR(VAR): VAR VAR.VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR.VAR, ""VAR""): VAR VAR.VAR.VAR() VAR: VAR VAR(""VAR VAR-VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR"") VAR VAR(VAR): VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR, 'VAR'): VAR VAR.VAR.VAR() VAR VAR(VAR):  VAR VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR(VAR(VAR)) VAR VAR(VAR) == 0: VAR 0 VAR: VAR[:VAR(VAR)] = VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR.VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR(). """""" VAR VAR(VAR.VAR, 'VAR') VAR VAR(VAR):   VAR VAR.VAR VAR VAR VAR: VAR VAR = VAR.VAR.VAR.VAR() VAR = VAR.VAR(VAR';', 1)[0] VAR: VAR.VAR = VAR(VAR, 16) VAR VAR:  VAR.VAR() VAR VAR.VAR(VAR) VAR VAR(VAR, VAR): VAR = VAR VAR VAR VAR VAR: VAR = VAR.VAR.VAR(VAR.VAR) VAR = VAR VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR < VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR = VAR.VAR - VAR VAR = VAR VAR VAR == VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR = VAR VAR:  VAR = VAR.VAR.VAR(VAR.VAR) VAR.VAR.VAR(2)  VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): """""" VAR VAR :VAR:`VAR.VAR`, VAR VAR VAR VAR VAR: ``VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR-VAR' VAR. """""" VAR.VAR()  VAR VAR VAR.VAR: VAR VAR( ""VAR VAR VAR VAR. "" ""VAR 'VAR-VAR: VAR' VAR VAR."") VAR VAR VAR.VAR(): VAR VAR( ""VAR VAR VAR VAR.VAR VAR. "" ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."") VAR VAR.VAR():  VAR VAR.VAR VAR VAR(VAR.VAR): VAR.VAR.VAR() VAR   VAR VAR.VAR.VAR VAR VAR: VAR VAR VAR: VAR.VAR() VAR VAR.VAR == 0: VAR VAR = VAR.VAR(VAR) VAR = VAR.VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR: VAR VAR VAR VAR:    VAR = VAR.VAR() VAR VAR:  VAR VAR  VAR VAR: VAR = VAR.VAR.VAR.VAR() VAR VAR VAR:  VAR VAR VAR == VAR'\VAR\VAR': VAR  VAR VAR.VAR: VAR.VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR VAR VAR VAR VAR VAR(VAR.VAR.VAR): VAR VAR.VAR.VAR[-1].VAR VAR: VAR VAR.VAR VAR VAR(VAR): VAR = [VAR""""] VAR VAR VAR VAR.VAR(VAR=VAR): VAR VAR""\VAR"" VAR VAR: VAR = VAR.VAR(VAR""\VAR"") VAR VAR"""".VAR(VAR) + VAR[0] + VAR""\VAR"" VAR VAR VAR VAR[1:-1]: VAR VAR + VAR""\VAR"" VAR VAR[-1]: VAR = [VAR[-1]] VAR: VAR = [] VAR: VAR.VAR(VAR) VAR VAR: VAR VAR"""".VAR(VAR) ",1,15
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,test/test_response.py,"import socket
import zlib

from io import BytesIO, BufferedReader

import pytest
import mock

from urllib3.response import HTTPResponse, brotli
from urllib3.exceptions import (
    DecodeError, ResponseNotChunked, ProtocolError, InvalidHeader
)
from urllib3.packages.six.moves import http_client as httplib
from urllib3.util.retry import Retry, RequestHistory
from urllib3.util.response import is_fp_closed

from test import onlyBrotlipy

from base64 import b64decode

# A known random (i.e, not-too-compressible) payload generated with:
#    """".join(random.choice(string.printable) for i in xrange(512))
#    .encode(""zlib"").encode(""base64"")
# Randomness in tests == bad, and fixing a seed may not be sufficient.
ZLIB_PAYLOAD = b64decode(b""""""\
eJwFweuaoQAAANDfineQhiKLUiaiCzvuTEmNNlJGiL5QhnGpZ99z8luQfe1AHoMioB+QSWHQu/L+
lzd7W5CipqYmeVTBjdgSATdg4l4Z2zhikbuF+EKn69Q0DTpdmNJz8S33odfJoVEexw/l2SS9nFdi
pis7KOwXzfSqarSo9uJYgbDGrs1VNnQpT9f8zAorhYCEZronZQF9DuDFfNK3Hecc+WHLnZLQptwk
nufw8S9I43sEwxsT71BiqedHo0QeIrFE01F/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/nNvDGKZ
Khe5TF36JbnKVjdcL1EUNpwrWVfQpFYJ/WWm2b74qNeSZeQv5/xBhRdOmKTJFYgO96PwrHBlsnLn
a3l0LwJsloWpMbzByU5WLbRE6X5INFqjQOtIwYz5BAlhkn+kVqJvWM5vBlfrwP42ifonM5yF4ciJ
auHVks62997mNGOsM7WXNG3P98dBHPo2NhbTvHleL0BI5dus2JY81MUOnK3SGWLH8HeWPa1t5KcW
S5moAj5HexY/g/F8TctpxwsvyZp38dXeLDjSQvEQIkF7XR3YXbeZgKk3V34KGCPOAeeuQDIgyVhV
nP4HF2uWHA=="""""")


@pytest.fixture
def sock():
    s = socket.socket()
    yield s
    s.close()


class TestLegacyResponse(object):
    def test_getheaders(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheaders() == headers

    def test_getheader(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.getheader('host') == 'example.com'


class TestResponse(object):
    def test_cache_content(self):
        r = HTTPResponse('foo')
        assert r.data == 'foo'
        assert r._body == 'foo'

    def test_default(self):
        r = HTTPResponse()
        assert r.data is None

    def test_none(self):
        r = HTTPResponse(None)
        assert r.data is None

    def test_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=True)

        assert fp.tell() == len(b'foo')
        assert r.data == b'foo'

    def test_no_preload(self):
        fp = BytesIO(b'foo')

        r = HTTPResponse(fp, preload_content=False)

        assert fp.tell() == 0
        assert r.data == b'foo'
        assert fp.tell() == len(b'foo')

    def test_decode_bad_data(self):
        fp = BytesIO(b'\x00' * 10)
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'deflate'})

    def test_reference_read(self):
        fp = BytesIO(b'foo')
        r = HTTPResponse(fp, preload_content=False)

        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'})

        assert r.data == b'foo'

    def test_decode_deflate_case_insensitve(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'DeFlAtE'})

        assert r.data == b'foo'

    def test_chunked_decoding_deflate(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(3) == b''
        # Buffer in case we need to switch to the raw stream
        assert r._decoder._data is not None
        assert r.read(1) == b'f'
        # Now that we've decoded data, we just stream through the decoder
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_deflate2(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                         preload_content=False)

        assert r.read(1) == b''
        assert r.read(1) == b'f'
        # Once we've decoded data, we just stream to the decoder; no buffering
        assert r._decoder._data is None
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_chunked_decoding_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                         preload_content=False)

        assert r.read(11) == b''
        assert r.read(1) == b'f'
        assert r.read(2) == b'oo'
        assert r.read() == b''
        assert r.read() == b''

    def test_decode_gzip_multi_member(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    def test_decode_gzip_error(self):
        fp = BytesIO(b'foo')
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'gzip'})

    def test_decode_gzip_swallow_garbage(self):
        # When data comes from multiple calls to read(), data after
        # the first zlib error (here triggered by garbage) should be
        # ignored.
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={'content-encoding': 'gzip'}, preload_content=False)
        ret = b''
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break

        assert ret == b'foofoofoo'

    def test_chunked_decoding_gzip_swallow_garbage(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()
        data = data * 3 + b'foo'

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip'})

        assert r.data == b'foofoofoo'

    @onlyBrotlipy()
    def test_decode_brotli(self):
        data = brotli.compress(b'foo')

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'br'})
        assert r.data == b'foo'

    @onlyBrotlipy()
    def test_chunked_decoding_brotli(self):
        data = brotli.compress(b'foobarbaz')

        fp = BytesIO(data)
        r = HTTPResponse(
            fp, headers={'content-encoding': 'br'}, preload_content=False)

        ret = b''
        for _ in range(100):
            ret += r.read(1)
            if r.closed:
                break
        assert ret == b'foobarbaz'

    @onlyBrotlipy()
    def test_decode_brotli_error(self):
        fp = BytesIO(b'foo')
        with pytest.raises(DecodeError):
            HTTPResponse(fp, headers={'content-encoding': 'br'})

    def test_multi_decoding_deflate_deflate(self):
        data = zlib.compress(zlib.compress(b'foo'))

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, deflate'})

        assert r.data == b'foo'

    def test_multi_decoding_deflate_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(zlib.compress(b'foo'))
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'deflate, gzip'})

        assert r.data == b'foo'

    def test_multi_decoding_gzip_gzip(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(data)
        data += compress.flush()

        fp = BytesIO(data)
        r = HTTPResponse(fp, headers={'content-encoding': 'gzip, gzip'})

        assert r.data == b'foo'

    def test_body_blob(self):
        resp = HTTPResponse(b'foo')
        assert resp.data == b'foo'
        assert resp.closed

    def test_io(self, sock):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)

        assert not resp.closed
        assert resp.readable()
        assert not resp.writable()
        with pytest.raises(IOError):
            resp.fileno()

        resp.close()
        assert resp.closed

        # Try closing with an `httplib.HTTPResponse`, because it has an
        # `isclosed` method.
        try:
            hlr = httplib.HTTPResponse(sock)
            resp2 = HTTPResponse(hlr, preload_content=False)
            assert not resp2.closed
            resp2.close()
            assert resp2.closed
        finally:
            hlr.close()

        # also try when only data is present.
        resp3 = HTTPResponse('foodata')
        with pytest.raises(IOError):
            resp3.fileno()

        resp3._fp = 2
        # A corner case where _fp is present but doesn't have `closed`,
        # `isclosed`, or `fileno`.  Unlikely, but possible.
        assert resp3.closed
        with pytest.raises(IOError):
            resp3.fileno()

    def test_io_closed_consistently(self, sock):
        try:
            hlr = httplib.HTTPResponse(sock)
            hlr.fp = BytesIO(b'foo')
            hlr.chunked = 0
            hlr.length = 3
            with HTTPResponse(hlr, preload_content=False) as resp:
                assert not resp.closed
                assert not resp._fp.isclosed()
                assert not is_fp_closed(resp._fp)
                assert not resp.isclosed()
                resp.read()
                assert resp.closed
                assert resp._fp.isclosed()
                assert is_fp_closed(resp._fp)
                assert resp.isclosed()
        finally:
            hlr.close()

    def test_io_bufferedreader(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp)

        assert br.read() == b'foo'

        br.close()
        assert resp.closed

        b = b'fooandahalf'
        fp = BytesIO(b)
        resp = HTTPResponse(fp, preload_content=False)
        br = BufferedReader(resp, 5)

        br.read(1)  # sets up the buffer, reading 5
        assert len(fp.read()) == (len(b) - 5)

        # This is necessary to make sure the ""no bytes left"" part of `readinto`
        # gets tested.
        while not br.closed:
            br.read(5)

    def test_streaming(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_streaming_tell(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        position = 0

        position += len(next(stream))
        assert 2 == position
        assert position == resp.tell()

        position += len(next(stream))
        assert 3 == position
        assert position == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_gzipped_streaming_tell(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
        uncompressed_data = b'foo'
        data = compress.compress(uncompressed_data)
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'gzip'},
                            preload_content=False)
        stream = resp.stream()

        # Read everything
        payload = next(stream)
        assert payload == uncompressed_data

        assert len(data) == resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate_streaming_tell_intermediate_point(self):
        # Ensure that ``tell()`` returns the correct number of bytes when
        # part-way through streaming compressed content.
        NUMBER_OF_READS = 10

        class MockCompressedDataReading(BytesIO):
            """"""
            A ByteIO-like reader returning ``payload`` in ``NUMBER_OF_READS``
            calls to ``read``.
            """"""

            def __init__(self, payload, payload_part_size):
                self.payloads = [
                    payload[i*payload_part_size:(i+1)*payload_part_size]
                    for i in range(NUMBER_OF_READS+1)]

                assert b"""".join(self.payloads) == payload

            def read(self, _):
                # Amount is unused.
                if len(self.payloads) > 0:
                    return self.payloads.pop(0)
                return b""""

        uncompressed_data = zlib.decompress(ZLIB_PAYLOAD)

        payload_part_size = len(ZLIB_PAYLOAD) // NUMBER_OF_READS
        fp = MockCompressedDataReading(ZLIB_PAYLOAD, payload_part_size)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream()

        parts_positions = [(part, resp.tell()) for part in stream]
        end_of_stream = resp.tell()

        with pytest.raises(StopIteration):
            next(stream)

        parts, positions = zip(*parts_positions)

        # Check that the payload is equal to the uncompressed data
        payload = b"""".join(parts)
        assert uncompressed_data == payload

        # Check that the positions in the stream are correct
        expected = [(i+1)*payload_part_size for i in range(NUMBER_OF_READS)]
        assert expected == list(positions)

        # Check that the end of the stream is in the correct place
        assert len(ZLIB_PAYLOAD) == end_of_stream

    def test_deflate_streaming(self):
        data = zlib.compress(b'foo')

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_deflate2_streaming(self):
        compress = zlib.compressobj(6, zlib.DEFLATED, -zlib.MAX_WBITS)
        data = compress.compress(b'foo')
        data += compress.flush()

        fp = BytesIO(data)
        resp = HTTPResponse(fp, headers={'content-encoding': 'deflate'},
                            preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'f'
        assert next(stream) == b'oo'
        with pytest.raises(StopIteration):
            next(stream)

    def test_empty_stream(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2, decode_content=False)

        with pytest.raises(StopIteration):
            next(stream)

    def test_length_no_header(self):
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        assert resp.length_remaining is None

    def test_length_w_valid_header(self):
        headers = {""content-length"": ""5""}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

    def test_length_w_bad_header(self):
        garbage = {'content-length': 'foo'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

        garbage['content-length'] = ""-10""
        resp = HTTPResponse(fp, headers=garbage, preload_content=False)
        assert resp.length_remaining is None

    def test_length_when_chunked(self):
        # This is expressly forbidden in RFC 7230 sec 3.3.2
        # We fall back to chunked in this case and try to
        # handle response ignoring content length.
        headers = {'content-length': '5',
                   'transfer-encoding': 'chunked'}
        fp = BytesIO(b'12345')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining is None

    def test_length_with_multiple_content_lengths(self):
        headers = {'content-length': '5, 5, 5'}
        garbage = {'content-length': '5, 42'}
        fp = BytesIO(b'abcde')

        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        assert resp.length_remaining == 5

        with pytest.raises(InvalidHeader):
            HTTPResponse(fp, headers=garbage, preload_content=False)

    def test_length_after_read(self):
        headers = {""content-length"": ""5""}

        # Test no defined length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, preload_content=False)
        resp.read()
        assert resp.length_remaining is None

        # Test our update from content-length
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        resp.read()
        assert resp.length_remaining == 0

        # Test partial read
        fp = BytesIO(b'12345')
        resp = HTTPResponse(fp, headers=headers, preload_content=False)
        data = resp.stream(2)
        next(data)
        assert resp.length_remaining == 3

    def test_mock_httpresponse_stream(self):
        # Mock out a HTTP Request that does enough to make it through urllib3's
        # read() and close() calls, and also exhausts and underlying file
        # object.
        class MockHTTPRequest(object):
            self.fp = None

            def read(self, amt):
                data = self.fp.read(amt)
                if not data:
                    self.fp = None

                return data

            def close(self):
                self.fp = None

        bio = BytesIO(b'foo')
        fp = MockHTTPRequest()
        fp.fp = bio
        resp = HTTPResponse(fp, preload_content=False)
        stream = resp.stream(2)

        assert next(stream) == b'fo'
        assert next(stream) == b'o'
        with pytest.raises(StopIteration):
            next(stream)

    def test_mock_transfer_encoding_chunked(self):
        stream = [b""fo"", b""o"", b""bar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})

        for i, c in enumerate(resp.stream()):
            assert c == stream[i]

    def test_mock_gzipped_transfer_encoding_chunked_decoded(self):
        """"""Show that we can decode the gizpped and chunked body.""""""
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b'foobar')
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i:i+2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {'transfer-encoding': 'chunked', 'content-encoding': 'gzip'}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b''
        for c in resp.stream(decode_content=True):
            data += c

        assert b'foobar' == data

    def test_mock_transfer_encoding_chunked_custom_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        expected_response = [b'fo', b'oo', b'o', b'bb', b'bb', b'aa', b'aa', b'ar']
        response = list(resp.read_chunked(2))
        assert expected_response == response

    def test_mock_transfer_encoding_chunked_unlmtd_read(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedEncodingResponse(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.read_chunked())

    def test_read_not_chunked_response_as_chunks(self):
        fp = BytesIO(b'foo')
        resp = HTTPResponse(fp, preload_content=False)
        r = resp.read_chunked()
        with pytest.raises(ResponseNotChunked):
            next(r)

    def test_invalid_chunks(self):
        stream = [b""foooo"", b""bbbbaaaaar""]
        fp = MockChunkedInvalidEncoding(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        with pytest.raises(ProtocolError):
            next(resp.read_chunked())

    def test_chunked_response_without_crlf_on_end(self):
        stream = [b""foo"", b""bar"", b""baz""]
        fp = MockChunkedEncodingWithoutCRLFOnEnd(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_response_with_extensions(self):
        stream = [b""foo"", b""bar""]
        fp = MockChunkedEncodingWithExtensions(stream)
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse(r, preload_content=False, headers={'transfer-encoding': 'chunked'})
        assert stream == list(resp.stream())

    def test_chunked_head_response(self):
        r = httplib.HTTPResponse(MockSock, method='HEAD')
        r.chunked = True
        r.chunk_left = None
        resp = HTTPResponse('',
                            preload_content=False,
                            headers={'transfer-encoding': 'chunked'},
                            original_response=r)
        assert resp.chunked is True

        resp.supports_chunked_reads = lambda: True
        resp.release_conn = mock.Mock()
        for _ in resp.stream():
            continue
        resp.release_conn.assert_called_once_with()

    def test_get_case_insensitive_headers(self):
        headers = {'host': 'example.com'}
        r = HTTPResponse(headers=headers)
        assert r.headers.get('host') == 'example.com'
        assert r.headers.get('Host') == 'example.com'

    def test_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp)
        assert resp.retries is None
        retry = Retry()
        resp = HTTPResponse(fp, retries=retry)
        assert resp.retries == retry

    def test_geturl(self):
        fp = BytesIO(b'')
        request_url = 'https://example.com'
        resp = HTTPResponse(fp, request_url=request_url)
        assert resp.geturl() == request_url

    def test_geturl_retries(self):
        fp = BytesIO(b'')
        resp = HTTPResponse(fp, request_url='http://example.com')
        request_histories = [
            RequestHistory(method='GET', url='http://example.com', error=None,
                           status=301, redirect_location='https://example.com/'),
            RequestHistory(method='GET', url='https://example.com/', error=None,
                           status=301, redirect_location='https://www.example.com')]
        retry = Retry(history=request_histories)
        resp = HTTPResponse(fp, retries=retry)
        assert resp.geturl() == 'https://www.example.com'

    @pytest.mark.parametrize(
        [""payload"", ""expected_stream""],
        [(b"""", [b""""]),
         (b""\n"", [b""\n""]),
         (b""abc\ndef"", [b""abc\n"", b""def""]),
         (b""Hello\nworld\n\n\n!"", [b""Hello\n"", b""world\n"", b""\n"", b""\n"", b""!""])]
    )
    def test__iter__(self, payload, expected_stream):
        actual_stream = []
        for chunk in HTTPResponse(BytesIO(payload), preload_content=False):
            actual_stream.append(chunk)

        assert actual_stream == expected_stream

    def test__iter__decode_content(self):
        def stream():
            # Set up a generator to chunk the gzipped body
            compress = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)
            data = compress.compress(b'foo\nbar')
            data += compress.flush()
            for i in range(0, len(data), 2):
                yield data[i:i + 2]

        fp = MockChunkedEncodingResponse(list(stream()))
        r = httplib.HTTPResponse(MockSock)
        r.fp = fp
        headers = {'transfer-encoding': 'chunked', 'content-encoding': 'gzip'}
        resp = HTTPResponse(r, preload_content=False, headers=headers)

        data = b''
        for c in resp:
            data += c

        assert b'foo\nbar' == data


class MockChunkedEncodingResponse(object):

    def __init__(self, content):
        """"""
        content: collection of str, each str is a chunk in response
        """"""
        self.content = content
        self.index = 0  # This class iterates over self.content.
        self.closed = False
        self.cur_chunk = b''
        self.chunks_exhausted = False

    @staticmethod
    def _encode_chunk(chunk):
        # In the general case, we can't decode the chunk to unicode
        length = '%X\r\n' % len(chunk)
        return length.encode() + chunk + b'\r\n'

    def _pop_new_chunk(self):
        if self.chunks_exhausted:
            return b""""
        try:
            chunk = self.content[self.index]
        except IndexError:
            chunk = b''
            self.chunks_exhausted = True
        else:
            self.index += 1
        chunk = self._encode_chunk(chunk)
        if not isinstance(chunk, bytes):
            chunk = chunk.encode()
        return chunk

    def pop_current_chunk(self, amt=-1, till_crlf=False):
        if amt > 0 and till_crlf:
            raise ValueError(""Can't specify amt and till_crlf."")
        if len(self.cur_chunk) <= 0:
            self.cur_chunk = self._pop_new_chunk()
        if till_crlf:
            try:
                i = self.cur_chunk.index(b""\r\n"")
            except ValueError:
                # No CRLF in current chunk -- probably caused by encoder.
                self.cur_chunk = b""""
                return b""""
            else:
                chunk_part = self.cur_chunk[:i+2]
                self.cur_chunk = self.cur_chunk[i+2:]
                return chunk_part
        elif amt <= -1:
            chunk_part = self.cur_chunk
            self.cur_chunk = b''
            return chunk_part
        else:
            try:
                chunk_part = self.cur_chunk[:amt]
            except IndexError:
                chunk_part = self.cur_chunk
                self.cur_chunk = b''
            else:
                self.cur_chunk = self.cur_chunk[amt:]
            return chunk_part

    def readline(self):
        return self.pop_current_chunk(till_crlf=True)

    def read(self, amt=-1):
        return self.pop_current_chunk(amt)

    def flush(self):
        # Python 3 wants this method.
        pass

    def close(self):
        self.closed = True


class MockChunkedInvalidEncoding(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return 'ZZZ\r\n%s\r\n' % chunk.decode()


class MockChunkedEncodingWithoutCRLFOnEnd(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X\r\n%s%s' % (len(chunk), chunk.decode(),
                               ""\r\n"" if len(chunk) > 0 else """")


class MockChunkedEncodingWithExtensions(MockChunkedEncodingResponse):

    def _encode_chunk(self, chunk):
        return '%X;asd=qwe\r\n%s\r\n' % (len(chunk), chunk.decode())


class MockSock(object):
    @classmethod
    def makefile(cls, *args, **kwargs):
        return",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR, VAR VAR VAR.VAR VAR ( VAR, VAR, VAR, VAR ) VAR VAR.VAR.VAR.VAR VAR VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR     VAR = VAR(VAR""""""\ VAR+VAR/VAR+ VAR+VAR/VAR VAR+VAR VAR/4atVFXuJs2yxIOak3bvtXjUKAA6OKnQJ/VAR VAR/VAR/VAR VAR+VAR VAR VAR/VAR/VAR VAR=="""""") @VAR.VAR VAR VAR(): VAR = VAR.VAR() VAR VAR VAR.VAR() VAR VAR(VAR): VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR VAR(VAR): VAR = VAR('VAR') VAR VAR.VAR == 'VAR' VAR VAR.VAR == 'VAR' VAR VAR(VAR): VAR = VAR() VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 0 VAR VAR.VAR == VAR'VAR' VAR VAR.VAR() == VAR(VAR'VAR') VAR VAR(VAR): VAR = VAR(VAR'\VAR' * 10) VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(3) == VAR''  VAR VAR.VAR.VAR VAR VAR VAR VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(1) == VAR'' VAR VAR.VAR(1) == VAR'VAR'  VAR VAR.VAR.VAR VAR VAR VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR(11) == VAR'' VAR VAR.VAR(1) == VAR'VAR' VAR VAR.VAR(2) == VAR'VAR' VAR VAR.VAR() == VAR'' VAR VAR.VAR() == VAR'' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR):    VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR( VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR * 3 + VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' @VAR() VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR == VAR'VAR' @VAR() VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR( VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR(100): VAR += VAR.VAR(1) VAR VAR.VAR: VAR VAR VAR == VAR'VAR' @VAR() VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR(VAR): VAR(VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR(VAR): VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR.VAR(VAR'VAR')) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR, VAR'}) VAR VAR.VAR == VAR'VAR' VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR VAR.VAR == VAR'VAR' VAR VAR.VAR VAR VAR(VAR, VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR VAR.VAR() VAR VAR VAR.VAR() VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR() VAR VAR.VAR   VAR: VAR = VAR.VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR VAR.VAR VAR.VAR() VAR VAR.VAR VAR: VAR.VAR()  VAR = VAR('VAR') VAR VAR.VAR(VAR): VAR.VAR() VAR.VAR = 2   VAR VAR.VAR VAR VAR.VAR(VAR): VAR.VAR() VAR VAR(VAR, VAR): VAR: VAR = VAR.VAR(VAR) VAR.VAR = VAR(VAR'VAR') VAR.VAR = 0 VAR.VAR = 3 VAR VAR(VAR, VAR=VAR) VAR VAR: VAR VAR VAR.VAR VAR VAR VAR.VAR.VAR() VAR VAR VAR(VAR.VAR) VAR VAR VAR.VAR() VAR.VAR() VAR VAR.VAR VAR VAR.VAR.VAR() VAR VAR(VAR.VAR) VAR VAR.VAR() VAR: VAR.VAR() VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR) VAR VAR.VAR() == VAR'VAR' VAR.VAR() VAR VAR.VAR VAR = VAR'VAR' VAR = VAR(VAR) VAR = VAR(VAR, VAR=VAR) VAR = VAR(VAR, 5) VAR.VAR(1)  VAR VAR(VAR.VAR()) == (VAR(VAR) - 5)   VAR VAR VAR.VAR: VAR.VAR(5) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR = 0 VAR += VAR(VAR(VAR)) VAR 2 == VAR VAR VAR == VAR.VAR() VAR += VAR(VAR(VAR)) VAR 3 == VAR VAR VAR == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR'VAR' VAR = VAR.VAR(VAR) VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR()  VAR = VAR(VAR) VAR VAR == VAR VAR VAR(VAR) == VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR):   VAR = 10 VAR VAR(VAR): """""" VAR VAR-VAR VAR VAR ``VAR`` VAR ``VAR`` VAR VAR ``VAR``. """""" VAR VAR(VAR, VAR, VAR): VAR.VAR = [ VAR[VAR*VAR:(VAR+1)*VAR] VAR VAR VAR VAR(VAR+1)] VAR VAR"""".VAR(VAR.VAR) == VAR VAR VAR(VAR, VAR):  VAR VAR(VAR.VAR) > 0: VAR VAR.VAR.VAR(0) VAR VAR"""" VAR = VAR.VAR(VAR) VAR = VAR(VAR)  VAR = VAR(VAR, VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR() VAR = [(VAR, VAR.VAR()) VAR VAR VAR VAR] VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR, VAR = VAR(*VAR)  VAR = VAR"""".VAR(VAR) VAR VAR == VAR  VAR = [(VAR+1)*VAR VAR VAR VAR VAR(VAR)] VAR VAR == VAR(VAR)  VAR VAR(VAR) == VAR VAR VAR(VAR): VAR = VAR.VAR(VAR'VAR') VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR.VAR(6, VAR.VAR, -VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR = VAR(VAR) VAR = VAR(VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2, VAR=VAR) VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR(VAR): VAR = {'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR['VAR-VAR'] = ""-10"" VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR):    VAR = {'VAR-VAR': '5', 'VAR-VAR': 'VAR'} VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR VAR VAR VAR VAR(VAR): VAR = {'VAR-VAR': '5, 5, 5'} VAR = {'VAR-VAR': '5, 42'} VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR.VAR == 5 VAR VAR.VAR(VAR): VAR(VAR, VAR=VAR, VAR=VAR) VAR VAR(VAR): VAR = {""VAR-VAR"": ""5""}  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR VAR VAR  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR.VAR() VAR VAR.VAR == 0  VAR = VAR(VAR'12345') VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR.VAR(2) VAR(VAR) VAR VAR.VAR == 3 VAR VAR(VAR):    VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(VAR) VAR VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR(VAR): VAR.VAR = VAR VAR = VAR(VAR'VAR') VAR = VAR() VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR(2) VAR VAR(VAR) == VAR'VAR' VAR VAR(VAR) == VAR'VAR' VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR, VAR VAR VAR(VAR.VAR()): VAR VAR == VAR[VAR] VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR') VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR:VAR+2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': 'VAR'} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR.VAR(VAR=VAR): VAR += VAR VAR VAR'VAR' == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR = [VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR', VAR'VAR'] VAR = VAR(VAR.VAR(2)) VAR VAR == VAR VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR(VAR'VAR') VAR = VAR(VAR, VAR=VAR) VAR = VAR.VAR() VAR VAR.VAR(VAR): VAR(VAR) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR.VAR(VAR): VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = [VAR""VAR"", VAR""VAR""] VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR = VAR(VAR, VAR=VAR, VAR={'VAR-VAR': 'VAR'}) VAR VAR == VAR(VAR.VAR()) VAR VAR(VAR): VAR = VAR.VAR(VAR, VAR='VAR') VAR.VAR = VAR VAR.VAR = VAR VAR = VAR('', VAR=VAR, VAR={'VAR-VAR': 'VAR'}, VAR=VAR) VAR VAR.VAR VAR VAR VAR.VAR = VAR: VAR VAR.VAR = VAR.VAR() VAR VAR VAR VAR.VAR(): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR = {'VAR': 'VAR.VAR'} VAR = VAR(VAR=VAR) VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR.VAR.VAR('VAR') == 'VAR.VAR' VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR) VAR VAR.VAR VAR VAR VAR = VAR() VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = 'VAR: VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == VAR VAR VAR(VAR): VAR = VAR(VAR'') VAR = VAR(VAR, VAR='VAR: VAR = [ VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR(VAR='VAR', VAR='VAR: VAR=301, VAR='VAR: VAR = VAR(VAR=VAR) VAR = VAR(VAR, VAR=VAR) VAR VAR.VAR() == 'VAR: @VAR.VAR.VAR( [""VAR"", ""VAR""], [(VAR"""", [VAR""""]), (VAR""\VAR"", [VAR""\VAR""]), (VAR""VAR\VAR"", [VAR""VAR\VAR"", VAR""VAR""]), (VAR""VAR\VAR\VAR\VAR\VAR!"", [VAR""VAR\VAR"", VAR""VAR\VAR"", VAR""\VAR"", VAR""\VAR"", VAR""!""])] ) VAR VAR(VAR, VAR, VAR): VAR = [] VAR VAR VAR VAR(VAR(VAR), VAR=VAR): VAR.VAR(VAR) VAR VAR == VAR VAR VAR(VAR): VAR VAR():  VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR = VAR.VAR(VAR'VAR\VAR') VAR += VAR.VAR() VAR VAR VAR VAR(0, VAR(VAR), 2): VAR VAR[VAR:VAR + 2] VAR = VAR(VAR(VAR())) VAR = VAR.VAR(VAR) VAR.VAR = VAR VAR = {'VAR-VAR': 'VAR', 'VAR-VAR': 'VAR'} VAR = VAR(VAR, VAR=VAR, VAR=VAR) VAR = VAR'' VAR VAR VAR VAR: VAR += VAR VAR VAR'VAR\VAR' == VAR VAR VAR(VAR): VAR VAR(VAR, VAR): """""" VAR: VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR """""" VAR.VAR = VAR VAR.VAR = 0  VAR.VAR = VAR VAR.VAR = VAR'' VAR.VAR = VAR @VAR VAR VAR(VAR):  VAR = '%VAR\VAR\VAR' % VAR(VAR) VAR VAR.VAR() + VAR + VAR'\VAR\VAR' VAR VAR(VAR): VAR VAR.VAR: VAR VAR"""" VAR: VAR = VAR.VAR[VAR.VAR] VAR VAR: VAR = VAR'' VAR.VAR = VAR VAR: VAR.VAR += 1 VAR = VAR.VAR(VAR) VAR VAR VAR(VAR, VAR): VAR = VAR.VAR() VAR VAR VAR VAR(VAR, VAR=-1, VAR=VAR): VAR VAR > 0 VAR VAR: VAR VAR(""VAR'VAR VAR VAR VAR VAR."") VAR VAR(VAR.VAR) <= 0: VAR.VAR = VAR.VAR() VAR VAR: VAR: VAR = VAR.VAR.VAR(VAR""\VAR\VAR"") VAR VAR:  VAR.VAR = VAR"""" VAR VAR"""" VAR: VAR = VAR.VAR[:VAR+2] VAR.VAR = VAR.VAR[VAR+2:] VAR VAR VAR VAR <= -1: VAR = VAR.VAR VAR.VAR = VAR'' VAR VAR VAR: VAR: VAR = VAR.VAR[:VAR] VAR VAR: VAR = VAR.VAR VAR.VAR = VAR'' VAR: VAR.VAR = VAR.VAR[VAR:] VAR VAR VAR VAR(VAR): VAR VAR.VAR(VAR=VAR) VAR VAR(VAR, VAR=-1): VAR VAR.VAR(VAR) VAR VAR(VAR):  VAR VAR VAR(VAR): VAR.VAR = VAR VAR VAR(VAR): VAR VAR(VAR, VAR): VAR 'VAR\VAR\VAR%VAR\VAR\VAR' % VAR.VAR() VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR\VAR\VAR%VAR%VAR' % (VAR(VAR), VAR.VAR(), ""\VAR\VAR"" VAR VAR(VAR) > 0 VAR """") VAR VAR(VAR): VAR VAR(VAR, VAR): VAR '%VAR;VAR=VAR\VAR\VAR%VAR\VAR\VAR' % (VAR(VAR), VAR.VAR()) VAR VAR(VAR): @VAR VAR VAR(VAR, *VAR, **VAR): VAR ",1,15

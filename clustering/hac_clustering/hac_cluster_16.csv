commit,file,added_code,deleted_code,hash_clean,cve_id,hash,repo_url,rel_type,score,extraction_status,text_norm,cluster_kmeans,cluster_hac
aiohttp_f016f0680e4ace6742b03a70cb0382ce86abe371,CHANGES/6182.bugfix,Raise ``400: Content-Length can't be present with Transfer-Encoding`` if both ``Content-Length`` and ``Transfer-Encoding`` are sent by peer by both C and Python implementations,,f016f0680e4ace6742b03a70cb0382ce86abe371,CVE-2023-47641,f016f0680e4ace6742b03a70cb0382ce86abe371,https://github.com/aio-libs/aiohttp,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR ``400: VAR-VAR VAR'VAR VAR VAR VAR VAR-VAR`` VAR VAR ``VAR-VAR`` VAR ``VAR-VAR`` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ,0,16
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,frontend/src/components/Sidebar/IndexCount.jsx,"import pluralize from ""pluralize"";
import React, { useEffect, useState } from ""react"";
import System from ""../../models/system"";
import { numberWithCommas } from ""../../utils/numbers"";

export default function IndexCount() {
  const [indexes, setIndexes] = useState(null);
  useEffect(() => {
    async function indexCount() {
      setIndexes(await System.totalIndexes());
    }
    indexCount();
  }, []);

  if (indexes === null || indexes === 0) {
    return (
      <div className=""flex w-full items-center justify-end gap-x-2"">
        <div className=""flex items-center gap-x-1 px-2 rounded-full"">
          <p className=""text-slate-400 leading-tight text-sm""></p>
        </div>
      </div>
    );
  }

  return (
    <div className=""flex w-full items-center justify-end gap-x-2"">
      <div className=""flex items-center gap-x-1  px-2 rounded-full"">
        <p className=""text-slate-400 leading-tight text-sm"">
          {numberWithCommas(indexes)} {pluralize(""index"", indexes)}
        </p>
      </div>
    </div>
  );
}",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR ""VAR""; VAR VAR, { VAR, VAR } VAR ""VAR""; VAR VAR VAR ""../../VAR/VAR""; VAR { VAR } VAR ""../../VAR/VAR""; VAR VAR VAR VAR() { VAR [VAR, VAR] = VAR(VAR); VAR(() => { VAR VAR VAR() { VAR(VAR VAR.VAR()); } VAR(); }, []); VAR (VAR === VAR || VAR === 0) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR""></VAR> </VAR> </VAR> ); } VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR""> {VAR(VAR)} {VAR(""VAR"", VAR)} </VAR> </VAR> </VAR> ); } ",0,16
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,frontend/src/components/Sidebar/LLMStatus.jsx,"import React, { useEffect, useState } from ""react"";
import { AlertCircle, Circle } from ""react-feather"";
import System from ""../../models/system"";

export default function LLMStatus() {
  const [status, setStatus] = useState(null);
  useEffect(() => {
    async function checkPing() {
      setStatus(await System.ping());
    }
    checkPing();
  }, []);

  if (status === null) {
    return (
      <div className=""flex w-full items-center justify-start gap-x-2"">
        <p className=""text-slate-400 leading-loose text-sm"">LLM</p>
        <div className=""flex items-center gap-x-1 border border-slate-400 px-2 rounded-full"">
          <p className=""text-slate-400 leading-tight text-sm"">unknown</p>
          <Circle className=""h-3 w-3 stroke-slate-700 fill-slate-400 animate-pulse"" />
        </div>
      </div>
    );
  }

  // TODO: add modal or toast on click to identify why this is broken
  // need to likely start server.
  if (status === false) {
    return (
      <div className=""flex w-full items-center justify-end gap-x-2"">
        <p className=""text-slate-400 leading-loose text-sm"">LLM</p>
        <div className=""flex items-center gap-x-1 border border-red-400 px-2 bg-red-200 rounded-full"">
          <p className=""text-red-700 leading-tight text-sm"">offline</p>
          <AlertCircle className=""h-3 w-3 stroke-red-100 fill-red-400"" />
        </div>
      </div>
    );
  }

  return (
    <div className=""flex w-full items-center justify-end gap-x-2"">
      <p className=""text-slate-400 leading-loose text-sm"">LLM</p>
      <div className=""flex items-center gap-x-1 border border-slate-400 px-2 rounded-full"">
        <p className=""text-slate-400 leading-tight text-sm"">online</p>
        <Circle className=""h-3 w-3 stroke-green-100 fill-green-400 animate-pulse"" />
      </div>
    </div>
  );
}",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR, { VAR, VAR } VAR ""VAR""; VAR { VAR, VAR } VAR ""VAR-VAR""; VAR VAR VAR ""../../VAR/VAR""; VAR VAR VAR VAR() { VAR [VAR, VAR] = VAR(VAR); VAR(() => { VAR VAR VAR() { VAR(VAR VAR.VAR()); } VAR(); }, []); VAR (VAR === VAR) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR VAR-VAR-400 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR-3 VAR-3 VAR-VAR-700 VAR-VAR-400 VAR-VAR"" /> </VAR> </VAR> ); }   VAR (VAR === VAR) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR VAR-VAR-400 VAR-2 VAR-VAR-200 VAR-VAR""> <VAR VAR=""VAR-VAR-700 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR-3 VAR-3 VAR-VAR-100 VAR-VAR-400"" /> </VAR> </VAR> ); } VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR VAR-VAR-400 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR-3 VAR-3 VAR-VAR-100 VAR-VAR-400 VAR-VAR"" /> </VAR> </VAR> ); } ",0,16
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,frontend/src/components/WorkspaceChat/ChatContainer/ChatHistory/index.jsx,"import { Frown } from ""react-feather"";
import HistoricalMessage from ""./HistoricalMessage"";
import PromptReply from ""./PromptReply"";
import { useEffect, useRef } from ""react"";

export default function ChatHistory({ history = [], workspace }) {
  const replyRef = useRef(null);

  useEffect(() => {
    if (replyRef.current) {
      setTimeout(() => {
        replyRef.current.scrollIntoView({ behavior: ""smooth"", block: ""end"" });
      }, 700);
    }
  }, [history]);

  if (history.length === 0) {
    return (
      <div className=""flex flex-col h-[89%] md:mt-0 pb-5 w-full justify-center items-center"">
        <div className=""w-fit flex items-center gap-x-2"">
          <Frown className=""h-4 w-4 text-slate-400"" />
          <p className=""text-slate-400"">No chat history found.</p>
        </div>
        <p className=""text-slate-400 text-xs"">
          Send your first message to get started.
        </p>
      </div>
    );
  }

  return (
    <div
      className=""h-[89%] pb-[100px] md:pt-[50px] md:pt-0 md:pb-5 mx-2 md:mx-0 overflow-y-scroll flex flex-col justify-start no-scroll""
      id=""chat-history""
    >
      {history.map((props, index) => {
        const isLastMessage = index === history.length - 1;

        if (props.role === ""assistant"" && props.animate) {
          return (
            <PromptReply
              key={props.uuid}
              ref={isLastMessage ? replyRef : null}
              uuid={props.uuid}
              reply={props.content}
              pending={props.pending}
              sources={props.sources}
              error={props.error}
              workspace={workspace}
              closed={props.closed}
            />
          );
        }

        return (
          <HistoricalMessage
            key={index}
            ref={isLastMessage ? replyRef : null}
            message={props.content}
            role={props.role}
            workspace={workspace}
            sources={props.sources}
            error={props.error}
          />
        );
      })}
    </div>
  );
}",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } VAR ""VAR-VAR""; VAR VAR VAR ""./VAR""; VAR VAR VAR ""./VAR""; VAR { VAR, VAR } VAR ""VAR""; VAR VAR VAR VAR({ VAR = [], VAR }) { VAR VAR = VAR(VAR); VAR(() => { VAR (VAR.VAR) { VAR(() => { VAR.VAR.VAR({ VAR: ""VAR"", VAR: ""VAR"" }); }, 700); } }, [VAR]); VAR (VAR.VAR === 0) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-[89%] VAR:VAR-0 VAR-5 VAR-VAR VAR-VAR VAR-VAR""> <VAR VAR=""VAR-VAR VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-4 VAR-4 VAR-VAR-400"" /> <VAR VAR=""VAR-VAR-400"">VAR VAR VAR VAR.</VAR> </VAR> <VAR VAR=""VAR-VAR-400 VAR-VAR""> VAR VAR VAR VAR VAR VAR VAR. </VAR> </VAR> ); } VAR ( <VAR VAR=""VAR-[89%] VAR-[100px] VAR:VAR-[50px] VAR:VAR-0 VAR:VAR-5 VAR-2 VAR:VAR-0 VAR-VAR-VAR VAR VAR-VAR VAR-VAR VAR-VAR"" VAR=""VAR-VAR"" > {VAR.VAR((VAR, VAR) => { VAR VAR = VAR === VAR.VAR - 1; VAR (VAR.VAR === ""VAR"" && VAR.VAR) { VAR ( <VAR VAR={VAR.VAR} VAR={VAR ? VAR : VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR} VAR={VAR.VAR} /> ); } VAR ( <VAR VAR={VAR} VAR={VAR ? VAR : VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR} VAR={VAR.VAR} VAR={VAR.VAR} /> ); })} </VAR> ); } ",0,16
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/components/Sidebar/IndexCount.jsx,"import pluralize from ""pluralize"";
import React, { useEffect, useState } from ""react"";
import System from ""../../models/system"";
import { numberWithCommas } from ""../../utils/numbers"";

export default function IndexCount() {
  const [indexes, setIndexes] = useState(null);
  useEffect(() => {
    async function indexCount() {
      setIndexes(await System.totalIndexes());
    }
    indexCount();
  }, []);

  if (indexes === null || indexes === 0) {
    return (
      <div className=""flex w-full items-center justify-end gap-x-2"">
        <div className=""flex items-center gap-x-1 px-2 rounded-full"">
          <p className=""text-slate-400 leading-tight text-sm""></p>
        </div>
      </div>
    );
  }

  return (
    <div className=""flex w-full items-center justify-end gap-x-2"">
      <div className=""flex items-center gap-x-1  px-2 rounded-full"">
        <p className=""text-slate-400 leading-tight text-sm"">
          {numberWithCommas(indexes)} {pluralize(""index"", indexes)}
        </p>
      </div>
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR ""VAR""; VAR VAR, { VAR, VAR } VAR ""VAR""; VAR VAR VAR ""../../VAR/VAR""; VAR { VAR } VAR ""../../VAR/VAR""; VAR VAR VAR VAR() { VAR [VAR, VAR] = VAR(VAR); VAR(() => { VAR VAR VAR() { VAR(VAR VAR.VAR()); } VAR(); }, []); VAR (VAR === VAR || VAR === 0) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR""></VAR> </VAR> </VAR> ); } VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR""> {VAR(VAR)} {VAR(""VAR"", VAR)} </VAR> </VAR> </VAR> ); } ",0,16
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/components/Sidebar/IndexCount.jsx,"import pluralize from ""pluralize"";
import React, { useEffect, useState } from ""react"";
import System from ""../../models/system"";
import { numberWithCommas } from ""../../utils/numbers"";

export default function IndexCount() {
  const [indexes, setIndexes] = useState(null);
  useEffect(() => {
    async function indexCount() {
      setIndexes(await System.totalIndexes());
    }
    indexCount();
  }, []);

  if (indexes === null || indexes === 0) {
    return (
      <div className=""flex w-full items-center justify-end gap-x-2"">
        <div className=""flex items-center gap-x-1 px-2 rounded-full"">
          <p className=""text-slate-400 leading-tight text-sm""></p>
        </div>
      </div>
    );
  }

  return (
    <div className=""flex w-full items-center justify-end gap-x-2"">
      <div className=""flex items-center gap-x-1  px-2 rounded-full"">
        <p className=""text-slate-400 leading-tight text-sm"">
          {numberWithCommas(indexes)} {pluralize(""index"", indexes)}
        </p>
      </div>
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR ""VAR""; VAR VAR, { VAR, VAR } VAR ""VAR""; VAR VAR VAR ""../../VAR/VAR""; VAR { VAR } VAR ""../../VAR/VAR""; VAR VAR VAR VAR() { VAR [VAR, VAR] = VAR(VAR); VAR(() => { VAR VAR VAR() { VAR(VAR VAR.VAR()); } VAR(); }, []); VAR (VAR === VAR || VAR === 0) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR""></VAR> </VAR> </VAR> ); } VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR""> {VAR(VAR)} {VAR(""VAR"", VAR)} </VAR> </VAR> </VAR> ); } ",0,16
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/components/Sidebar/LLMStatus.jsx,"import React, { useEffect, useState } from ""react"";
import { AlertCircle, Circle } from ""react-feather"";
import System from ""../../models/system"";

export default function LLMStatus() {
  const [status, setStatus] = useState(null);
  useEffect(() => {
    async function checkPing() {
      setStatus(await System.ping());
    }
    checkPing();
  }, []);

  if (status === null) {
    return (
      <div className=""flex w-full items-center justify-start gap-x-2"">
        <p className=""text-slate-400 leading-loose text-sm"">LLM</p>
        <div className=""flex items-center gap-x-1 border border-slate-400 px-2 rounded-full"">
          <p className=""text-slate-400 leading-tight text-sm"">unknown</p>
          <Circle className=""h-3 w-3 stroke-slate-700 fill-slate-400 animate-pulse"" />
        </div>
      </div>
    );
  }

  // TODO: add modal or toast on click to identify why this is broken
  // need to likely start server.
  if (status === false) {
    return (
      <div className=""flex w-full items-center justify-end gap-x-2"">
        <p className=""text-slate-400 leading-loose text-sm"">LLM</p>
        <div className=""flex items-center gap-x-1 border border-red-400 px-2 bg-red-200 rounded-full"">
          <p className=""text-red-700 leading-tight text-sm"">offline</p>
          <AlertCircle className=""h-3 w-3 stroke-red-100 fill-red-400"" />
        </div>
      </div>
    );
  }

  return (
    <div className=""flex w-full items-center justify-end gap-x-2"">
      <p className=""text-slate-400 leading-loose text-sm"">LLM</p>
      <div className=""flex items-center gap-x-1 border border-slate-400 px-2 rounded-full"">
        <p className=""text-slate-400 leading-tight text-sm"">online</p>
        <Circle className=""h-3 w-3 stroke-green-100 fill-green-400 animate-pulse"" />
      </div>
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR, { VAR, VAR } VAR ""VAR""; VAR { VAR, VAR } VAR ""VAR-VAR""; VAR VAR VAR ""../../VAR/VAR""; VAR VAR VAR VAR() { VAR [VAR, VAR] = VAR(VAR); VAR(() => { VAR VAR VAR() { VAR(VAR VAR.VAR()); } VAR(); }, []); VAR (VAR === VAR) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR VAR-VAR-400 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR-3 VAR-3 VAR-VAR-700 VAR-VAR-400 VAR-VAR"" /> </VAR> </VAR> ); }   VAR (VAR === VAR) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR VAR-VAR-400 VAR-2 VAR-VAR-200 VAR-VAR""> <VAR VAR=""VAR-VAR-700 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR-3 VAR-3 VAR-VAR-100 VAR-VAR-400"" /> </VAR> </VAR> ); } VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR VAR-VAR-400 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR-3 VAR-3 VAR-VAR-100 VAR-VAR-400 VAR-VAR"" /> </VAR> </VAR> ); } ",0,16
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/components/Sidebar/LLMStatus.jsx,"import React, { useEffect, useState } from ""react"";
import { AlertCircle, Circle } from ""react-feather"";
import System from ""../../models/system"";

export default function LLMStatus() {
  const [status, setStatus] = useState(null);
  useEffect(() => {
    async function checkPing() {
      setStatus(await System.ping());
    }
    checkPing();
  }, []);

  if (status === null) {
    return (
      <div className=""flex w-full items-center justify-start gap-x-2"">
        <p className=""text-slate-400 leading-loose text-sm"">LLM</p>
        <div className=""flex items-center gap-x-1 border border-slate-400 px-2 rounded-full"">
          <p className=""text-slate-400 leading-tight text-sm"">unknown</p>
          <Circle className=""h-3 w-3 stroke-slate-700 fill-slate-400 animate-pulse"" />
        </div>
      </div>
    );
  }

  // TODO: add modal or toast on click to identify why this is broken
  // need to likely start server.
  if (status === false) {
    return (
      <div className=""flex w-full items-center justify-end gap-x-2"">
        <p className=""text-slate-400 leading-loose text-sm"">LLM</p>
        <div className=""flex items-center gap-x-1 border border-red-400 px-2 bg-red-200 rounded-full"">
          <p className=""text-red-700 leading-tight text-sm"">offline</p>
          <AlertCircle className=""h-3 w-3 stroke-red-100 fill-red-400"" />
        </div>
      </div>
    );
  }

  return (
    <div className=""flex w-full items-center justify-end gap-x-2"">
      <p className=""text-slate-400 leading-loose text-sm"">LLM</p>
      <div className=""flex items-center gap-x-1 border border-slate-400 px-2 rounded-full"">
        <p className=""text-slate-400 leading-tight text-sm"">online</p>
        <Circle className=""h-3 w-3 stroke-green-100 fill-green-400 animate-pulse"" />
      </div>
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR, { VAR, VAR } VAR ""VAR""; VAR { VAR, VAR } VAR ""VAR-VAR""; VAR VAR VAR ""../../VAR/VAR""; VAR VAR VAR VAR() { VAR [VAR, VAR] = VAR(VAR); VAR(() => { VAR VAR VAR() { VAR(VAR VAR.VAR()); } VAR(); }, []); VAR (VAR === VAR) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR VAR-VAR-400 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR-3 VAR-3 VAR-VAR-700 VAR-VAR-400 VAR-VAR"" /> </VAR> </VAR> ); }   VAR (VAR === VAR) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR VAR-VAR-400 VAR-2 VAR-VAR-200 VAR-VAR""> <VAR VAR=""VAR-VAR-700 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR-3 VAR-3 VAR-VAR-100 VAR-VAR-400"" /> </VAR> </VAR> ); } VAR ( <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR VAR-VAR VAR-VAR-1 VAR VAR-VAR-400 VAR-2 VAR-VAR""> <VAR VAR=""VAR-VAR-400 VAR-VAR VAR-VAR"">VAR</VAR> <VAR VAR=""VAR-3 VAR-3 VAR-VAR-100 VAR-VAR-400 VAR-VAR"" /> </VAR> </VAR> ); } ",0,16
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/components/WorkspaceChat/ChatContainer/ChatHistory/index.jsx,"import { Frown } from ""react-feather"";
import HistoricalMessage from ""./HistoricalMessage"";
import PromptReply from ""./PromptReply"";
import { useEffect, useRef } from ""react"";

export default function ChatHistory({ history = [], workspace }) {
  const replyRef = useRef(null);

  useEffect(() => {
    if (replyRef.current) {
      setTimeout(() => {
        replyRef.current.scrollIntoView({ behavior: ""smooth"", block: ""end"" });
      }, 700);
    }
  }, [history]);

  if (history.length === 0) {
    return (
      <div className=""flex flex-col h-[89%] md:mt-0 pb-5 w-full justify-center items-center"">
        <div className=""w-fit flex items-center gap-x-2"">
          <Frown className=""h-4 w-4 text-slate-400"" />
          <p className=""text-slate-400"">No chat history found.</p>
        </div>
        <p className=""text-slate-400 text-xs"">
          Send your first message to get started.
        </p>
      </div>
    );
  }

  return (
    <div
      className=""h-[89%] pb-[100px] md:pt-[50px] md:pt-0 md:pb-5 mx-2 md:mx-0 overflow-y-scroll flex flex-col justify-start no-scroll""
      id=""chat-history""
    >
      {history.map((props, index) => {
        const isLastMessage = index === history.length - 1;

        if (props.role === ""assistant"" && props.animate) {
          return (
            <PromptReply
              key={props.uuid}
              ref={isLastMessage ? replyRef : null}
              uuid={props.uuid}
              reply={props.content}
              pending={props.pending}
              sources={props.sources}
              error={props.error}
              workspace={workspace}
              closed={props.closed}
            />
          );
        }

        return (
          <HistoricalMessage
            key={index}
            ref={isLastMessage ? replyRef : null}
            message={props.content}
            role={props.role}
            workspace={workspace}
            sources={props.sources}
            error={props.error}
          />
        );
      })}
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } VAR ""VAR-VAR""; VAR VAR VAR ""./VAR""; VAR VAR VAR ""./VAR""; VAR { VAR, VAR } VAR ""VAR""; VAR VAR VAR VAR({ VAR = [], VAR }) { VAR VAR = VAR(VAR); VAR(() => { VAR (VAR.VAR) { VAR(() => { VAR.VAR.VAR({ VAR: ""VAR"", VAR: ""VAR"" }); }, 700); } }, [VAR]); VAR (VAR.VAR === 0) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-[89%] VAR:VAR-0 VAR-5 VAR-VAR VAR-VAR VAR-VAR""> <VAR VAR=""VAR-VAR VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-4 VAR-4 VAR-VAR-400"" /> <VAR VAR=""VAR-VAR-400"">VAR VAR VAR VAR.</VAR> </VAR> <VAR VAR=""VAR-VAR-400 VAR-VAR""> VAR VAR VAR VAR VAR VAR VAR. </VAR> </VAR> ); } VAR ( <VAR VAR=""VAR-[89%] VAR-[100px] VAR:VAR-[50px] VAR:VAR-0 VAR:VAR-5 VAR-2 VAR:VAR-0 VAR-VAR-VAR VAR VAR-VAR VAR-VAR VAR-VAR"" VAR=""VAR-VAR"" > {VAR.VAR((VAR, VAR) => { VAR VAR = VAR === VAR.VAR - 1; VAR (VAR.VAR === ""VAR"" && VAR.VAR) { VAR ( <VAR VAR={VAR.VAR} VAR={VAR ? VAR : VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR} VAR={VAR.VAR} /> ); } VAR ( <VAR VAR={VAR} VAR={VAR ? VAR : VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR} VAR={VAR.VAR} VAR={VAR.VAR} /> ); })} </VAR> ); } ",0,16
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/components/WorkspaceChat/ChatContainer/ChatHistory/index.jsx,"import { Frown } from ""react-feather"";
import HistoricalMessage from ""./HistoricalMessage"";
import PromptReply from ""./PromptReply"";
import { useEffect, useRef } from ""react"";

export default function ChatHistory({ history = [], workspace }) {
  const replyRef = useRef(null);

  useEffect(() => {
    if (replyRef.current) {
      setTimeout(() => {
        replyRef.current.scrollIntoView({ behavior: ""smooth"", block: ""end"" });
      }, 700);
    }
  }, [history]);

  if (history.length === 0) {
    return (
      <div className=""flex flex-col h-[89%] md:mt-0 pb-5 w-full justify-center items-center"">
        <div className=""w-fit flex items-center gap-x-2"">
          <Frown className=""h-4 w-4 text-slate-400"" />
          <p className=""text-slate-400"">No chat history found.</p>
        </div>
        <p className=""text-slate-400 text-xs"">
          Send your first message to get started.
        </p>
      </div>
    );
  }

  return (
    <div
      className=""h-[89%] pb-[100px] md:pt-[50px] md:pt-0 md:pb-5 mx-2 md:mx-0 overflow-y-scroll flex flex-col justify-start no-scroll""
      id=""chat-history""
    >
      {history.map((props, index) => {
        const isLastMessage = index === history.length - 1;

        if (props.role === ""assistant"" && props.animate) {
          return (
            <PromptReply
              key={props.uuid}
              ref={isLastMessage ? replyRef : null}
              uuid={props.uuid}
              reply={props.content}
              pending={props.pending}
              sources={props.sources}
              error={props.error}
              workspace={workspace}
              closed={props.closed}
            />
          );
        }

        return (
          <HistoricalMessage
            key={index}
            ref={isLastMessage ? replyRef : null}
            message={props.content}
            role={props.role}
            workspace={workspace}
            sources={props.sources}
            error={props.error}
          />
        );
      })}
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } VAR ""VAR-VAR""; VAR VAR VAR ""./VAR""; VAR VAR VAR ""./VAR""; VAR { VAR, VAR } VAR ""VAR""; VAR VAR VAR VAR({ VAR = [], VAR }) { VAR VAR = VAR(VAR); VAR(() => { VAR (VAR.VAR) { VAR(() => { VAR.VAR.VAR({ VAR: ""VAR"", VAR: ""VAR"" }); }, 700); } }, [VAR]); VAR (VAR.VAR === 0) { VAR ( <VAR VAR=""VAR VAR-VAR VAR-[89%] VAR:VAR-0 VAR-5 VAR-VAR VAR-VAR VAR-VAR""> <VAR VAR=""VAR-VAR VAR VAR-VAR VAR-VAR-2""> <VAR VAR=""VAR-4 VAR-4 VAR-VAR-400"" /> <VAR VAR=""VAR-VAR-400"">VAR VAR VAR VAR.</VAR> </VAR> <VAR VAR=""VAR-VAR-400 VAR-VAR""> VAR VAR VAR VAR VAR VAR VAR. </VAR> </VAR> ); } VAR ( <VAR VAR=""VAR-[89%] VAR-[100px] VAR:VAR-[50px] VAR:VAR-0 VAR:VAR-5 VAR-2 VAR:VAR-0 VAR-VAR-VAR VAR VAR-VAR VAR-VAR VAR-VAR"" VAR=""VAR-VAR"" > {VAR.VAR((VAR, VAR) => { VAR VAR = VAR === VAR.VAR - 1; VAR (VAR.VAR === ""VAR"" && VAR.VAR) { VAR ( <VAR VAR={VAR.VAR} VAR={VAR ? VAR : VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR} VAR={VAR.VAR} /> ); } VAR ( <VAR VAR={VAR} VAR={VAR ? VAR : VAR} VAR={VAR.VAR} VAR={VAR.VAR} VAR={VAR} VAR={VAR.VAR} VAR={VAR.VAR} /> ); })} </VAR> ); } ",0,16
cpython_0cb0c238d520a8718e313b52cffc356a5a7561bf,Litest/test_ssl.py,"import re
import struct
import http.client
def set_socket_so_linger_on_with_zero_timeout(sock):
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack('ii', 1, 0))


class TestPreHandshakeClose(unittest.TestCase):
    """"""Verify behavior of close sockets with received data before to the handshake.
    """"""

    class SingleConnectionTestServerThread(threading.Thread):

        def __init__(self, *, name, call_after_accept):
            self.call_after_accept = call_after_accept
            self.received_data = b''  # set by .run()
            self.wrap_error = None  # set by .run()
            self.listener = None  # set by .start()
            self.port = None  # set by .start()
            super().__init__(name=name)

        def __enter__(self):
            self.start()
            return self

        def __exit__(self, *args):
            try:
                if self.listener:
                    self.listener.close()
            except OSError:
                pass
            self.join()
            self.wrap_error = None  # avoid dangling references

        def start(self):
            self.ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            self.ssl_ctx.verify_mode = ssl.CERT_REQUIRED
            self.ssl_ctx.load_verify_locations(cafile=ONLYCERT)
            self.ssl_ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)
            self.listener = socket.socket()
            self.port = socket_helper.bind_port(self.listener)
            self.listener.settimeout(2.0)
            self.listener.listen(1)
            super().start()

        def run(self):
            conn, address = self.listener.accept()
            self.listener.close()
            with conn:
                if self.call_after_accept(conn):
                    return
                try:
                    tls_socket = self.ssl_ctx.wrap_socket(conn, server_side=True)
                except OSError as err:  # ssl.SSLError inherits from OSError
                    self.wrap_error = err
                else:
                    try:
                        self.received_data = tls_socket.recv(400)
                    except OSError:
                        pass  # closed, protocol error, etc.

    def non_linux_skip_if_other_okay_error(self, err):
        if sys.platform == ""linux"":
            return  # Expect the full test setup to always work on Linux.
        if (isinstance(err, ConnectionResetError) or
            (isinstance(err, OSError) and err.errno == errno.EINVAL) or
            re.search('wrong.version.number', getattr(err, ""reason"", """"), re.I)):
            # On Windows the TCP RST leads to a ConnectionResetError
            # (ECONNRESET) which Linux doesn't appear to surface to userspace.
            # If wrap_socket() winds up on the ""if connected:"" path and doing
            # the actual wrapping... we get an SSLError from OpenSSL. Typically
            # WRONG_VERSION_NUMBER. While appropriate, neither is the scenario
            # we're specifically trying to test. The way this test is written
            # is known to work on Linux. We'll skip it anywhere else that it
            # does not present as doing so.
            self.skipTest(f""Could not recreate conditions on {sys.platform}:""
                          f"" {err=}"")
        # If maintaining this conditional winds up being a problem.
        # just turn this into an unconditional skip anything but Linux.
        # The important thing is that our CI has the logic covered.

    def test_preauth_data_to_tls_server(self):
        server_accept_called = threading.Event()
        ready_for_server_wrap_socket = threading.Event()

        def call_after_accept(unused):
            server_accept_called.set()
            if not ready_for_server_wrap_socket.wait(2.0):
                raise RuntimeError(""wrap_socket event never set, test may fail."")
            return False  # Tell the server thread to continue.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""preauth_data_to_tls_server"")
        self.enterContext(server)  # starts it & unittest.TestCase stops it.

        with socket.socket() as client:
            client.connect(server.listener.getsockname())
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(client)
            client.setblocking(False)

            server_accept_called.wait()
            client.send(b""DELETE /data HTTP/1.0\r\n\r\n"")
            client.close()  # RST

        ready_for_server_wrap_socket.set()
        server.join()
        wrap_error = server.wrap_error
        self.assertEqual(b"""", server.received_data)
        self.assertIsInstance(wrap_error, OSError)  # All platforms.
        self.non_linux_skip_if_other_okay_error(wrap_error)
        self.assertIsInstance(wrap_error, ssl.SSLError)
        self.assertIn(""before TLS handshake with data"", wrap_error.args[1])
        self.assertIn(""before TLS handshake with data"", wrap_error.reason)
        self.assertNotEqual(0, wrap_error.args[0])
        self.assertIsNone(wrap_error.library, msg=""attr must exist"")

    def test_preauth_data_to_tls_client(self):
        client_can_continue_with_wrap_socket = threading.Event()

        def call_after_accept(conn_to_client):
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(conn_to_client)
            conn_to_client.send(
                    b""HTTP/1.0 307 Temporary Redirect\r\n""
                    b""Location: https://example.com/someone-elses-server\r\n""
                    b""\r\n"")
            conn_to_client.close()  # RST
            client_can_continue_with_wrap_socket.set()
            return True  # Tell the server to stop.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""preauth_data_to_tls_client"")
        self.enterContext(server)  # starts it & unittest.TestCase stops it.
        # Redundant; call_after_accept sets SO_LINGER on the accepted conn.
        set_socket_so_linger_on_with_zero_timeout(server.listener)

        with socket.socket() as client:
            client.connect(server.listener.getsockname())
            if not client_can_continue_with_wrap_socket.wait(2.0):
                self.fail(""test server took too long."")
            ssl_ctx = ssl.create_default_context()
            try:
                tls_client = ssl_ctx.wrap_socket(
                        client, server_hostname=""localhost"")
            except OSError as err:  # SSLError inherits from OSError
                wrap_error = err
                received_data = b""""
            else:
                wrap_error = None
                received_data = tls_client.recv(400)
                tls_client.close()

        server.join()
        self.assertEqual(b"""", received_data)
        self.assertIsInstance(wrap_error, OSError)  # All platforms.
        self.non_linux_skip_if_other_okay_error(wrap_error)
        self.assertIsInstance(wrap_error, ssl.SSLError)
        self.assertIn(""before TLS handshake with data"", wrap_error.args[1])
        self.assertIn(""before TLS handshake with data"", wrap_error.reason)
        self.assertNotEqual(0, wrap_error.args[0])
        self.assertIsNone(wrap_error.library, msg=""attr must exist"")

    def test_https_client_non_tls_response_ignored(self):

        server_responding = threading.Event()

        class SynchronizedHTTPSConnection(http.client.HTTPSConnection):
            def connect(self):
                http.client.HTTPConnection.connect(self)
                # Wait for our fault injection server to have done its thing.
                if not server_responding.wait(1.0) and support.verbose:
                    sys.stdout.write(""server_responding event never set."")
                self.sock = self._context.wrap_socket(
                        self.sock, server_hostname=self.host)

        def call_after_accept(conn_to_client):
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(conn_to_client)
            conn_to_client.send(
                    b""HTTP/1.0 402 Payment Required\r\n""
                    b""\r\n"")
            conn_to_client.close()  # RST
            server_responding.set()
            return True  # Tell the server to stop.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""non_tls_http_RST_responder"")
        self.enterContext(server)  # starts it & unittest.TestCase stops it.
        # Redundant; call_after_accept sets SO_LINGER on the accepted conn.
        set_socket_so_linger_on_with_zero_timeout(server.listener)

        connection = SynchronizedHTTPSConnection(
                f""localhost"",
                port=server.port,
                context=ssl.create_default_context(),
                timeout=2.0,
        )
        # There are lots of reasons this raises as desired, long before this
        # test was added. Sending the request requires a successful TLS wrapped
        # socket; that fails if the connection is broken. It may seem pointless
        # to test this. It serves as an illustration of something that we never
        # want to happen... properly not happening.
        with self.assertRaises(OSError) as err_ctx:
            connection.request(""HEAD"", ""/test"", headers={""Host"": ""localhost""})
            response = connection.getresponse()

",,0cb0c238d520a8718e313b52cffc356a5a7561bf,CVE-2023-40217,0cb0c238d520a8718e313b52cffc356a5a7561bf,https://github.com/python/cpython,CPE_GIT_REPOBASED,218,COMPLETED,"VAR VAR VAR VAR VAR VAR.VAR VAR VAR(VAR): VAR.VAR(VAR.VAR, VAR.VAR, VAR.VAR('VAR', 1, 0)) VAR VAR(VAR.VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR.VAR): VAR VAR(VAR, *, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR''  VAR.VAR = VAR  VAR.VAR = VAR  VAR.VAR = VAR  VAR().VAR(VAR=VAR) VAR VAR(VAR): VAR.VAR() VAR VAR VAR VAR(VAR, *VAR): VAR: VAR VAR.VAR: VAR.VAR.VAR() VAR VAR: VAR VAR.VAR() VAR.VAR = VAR  VAR VAR(VAR): VAR.VAR = VAR.VAR(VAR.VAR.VAR) VAR.VAR.VAR = VAR.VAR VAR.VAR.VAR(VAR=VAR) VAR.VAR.VAR(VAR=VAR, VAR=VAR) VAR.VAR = VAR.VAR() VAR.VAR = VAR.VAR(VAR.VAR) VAR.VAR.VAR(2.0) VAR.VAR.VAR(1) VAR().VAR() VAR VAR(VAR): VAR, VAR = VAR.VAR.VAR() VAR.VAR.VAR() VAR VAR: VAR VAR.VAR(VAR): VAR VAR: VAR = VAR.VAR.VAR(VAR, VAR=VAR) VAR VAR VAR VAR:  VAR.VAR = VAR VAR: VAR: VAR.VAR = VAR.VAR(400) VAR VAR: VAR  VAR VAR(VAR, VAR): VAR VAR.VAR == ""VAR"": VAR  VAR (VAR(VAR, VAR) VAR (VAR(VAR, VAR) VAR VAR.VAR == VAR.VAR) VAR VAR.VAR('VAR.VAR.VAR', VAR(VAR, ""VAR"", """"), VAR.VAR)):         VAR.VAR(VAR""VAR VAR VAR VAR VAR {VAR.VAR}:"" VAR"" {VAR=}"")    VAR VAR(VAR): VAR = VAR.VAR() VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR VAR VAR.VAR(2.0): VAR VAR(""VAR VAR VAR VAR, VAR VAR VAR."") VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR(VAR)  VAR VAR.VAR() VAR VAR: VAR.VAR(VAR.VAR.VAR())  VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR(VAR""VAR /VAR VAR/1.0\VAR\VAR\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR.VAR() VAR = VAR.VAR VAR.VAR(VAR"""", VAR.VAR) VAR.VAR(VAR, VAR)  VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR[1]) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR) VAR.VAR(0, VAR.VAR[0]) VAR.VAR(VAR.VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR):  VAR(VAR) VAR.VAR( VAR""VAR/1.0 307 VAR VAR\VAR\VAR"" VAR""VAR: VAR: VAR""\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR(VAR)   VAR(VAR.VAR) VAR VAR.VAR() VAR VAR: VAR.VAR(VAR.VAR.VAR()) VAR VAR VAR.VAR(2.0): VAR.VAR(""VAR VAR VAR VAR VAR."") VAR = VAR.VAR() VAR: VAR = VAR.VAR( VAR, VAR=""VAR"") VAR VAR VAR VAR:  VAR = VAR VAR = VAR"""" VAR: VAR = VAR VAR = VAR.VAR(400) VAR.VAR() VAR.VAR() VAR.VAR(VAR"""", VAR) VAR.VAR(VAR, VAR)  VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR[1]) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR) VAR.VAR(0, VAR.VAR[0]) VAR.VAR(VAR.VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR.VAR.VAR): VAR VAR(VAR): VAR.VAR.VAR.VAR(VAR)  VAR VAR VAR.VAR(1.0) VAR VAR.VAR: VAR.VAR.VAR(""VAR VAR VAR VAR."") VAR.VAR = VAR.VAR.VAR( VAR.VAR, VAR=VAR.VAR) VAR VAR(VAR):  VAR(VAR) VAR.VAR( VAR""VAR/1.0 402 VAR VAR\VAR\VAR"" VAR""\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR(VAR)   VAR(VAR.VAR) VAR = VAR( VAR""VAR"", VAR=VAR.VAR, VAR=VAR.VAR(), VAR=2.0, )      VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""VAR""}) VAR = VAR.VAR() ",0,16
cpython_256586ab8776e4526ca594b4866b9a3492e628f1,Litest/test_ssl.py,"import re
import struct
import http.client
def set_socket_so_linger_on_with_zero_timeout(sock):
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack('ii', 1, 0))


class TestPreHandshakeClose(unittest.TestCase):
    """"""Verify behavior of close sockets with received data before to the handshake.
    """"""

    class SingleConnectionTestServerThread(threading.Thread):

        def __init__(self, *, name, call_after_accept):
            self.call_after_accept = call_after_accept
            self.received_data = b''  # set by .run()
            self.wrap_error = None  # set by .run()
            self.listener = None  # set by .start()
            self.port = None  # set by .start()
            super().__init__(name=name)

        def __enter__(self):
            self.start()
            return self

        def __exit__(self, *args):
            try:
                if self.listener:
                    self.listener.close()
            except OSError:
                pass
            self.join()
            self.wrap_error = None  # avoid dangling references

        def start(self):
            self.ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            self.ssl_ctx.verify_mode = ssl.CERT_REQUIRED
            self.ssl_ctx.load_verify_locations(cafile=ONLYCERT)
            self.ssl_ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)
            self.listener = socket.socket()
            self.port = socket_helper.bind_port(self.listener)
            self.listener.settimeout(2.0)
            self.listener.listen(1)
            super().start()

        def run(self):
            conn, address = self.listener.accept()
            self.listener.close()
            with conn:
                if self.call_after_accept(conn):
                    return
                try:
                    tls_socket = self.ssl_ctx.wrap_socket(conn, server_side=True)
                except OSError as err:  # ssl.SSLError inherits from OSError
                    self.wrap_error = err
                else:
                    try:
                        self.received_data = tls_socket.recv(400)
                    except OSError:
                        pass  # closed, protocol error, etc.

    def non_linux_skip_if_other_okay_error(self, err):
        if sys.platform == ""linux"":
            return  # Expect the full test setup to always work on Linux.
        if (isinstance(err, ConnectionResetError) or
            (isinstance(err, OSError) and err.errno == errno.EINVAL) or
            re.search('wrong.version.number', getattr(err, ""reason"", """"), re.I)):
            # On Windows the TCP RST leads to a ConnectionResetError
            # (ECONNRESET) which Linux doesn't appear to surface to userspace.
            # If wrap_socket() winds up on the ""if connected:"" path and doing
            # the actual wrapping... we get an SSLError from OpenSSL. Typically
            # WRONG_VERSION_NUMBER. While appropriate, neither is the scenario
            # we're specifically trying to test. The way this test is written
            # is known to work on Linux. We'll skip it anywhere else that it
            # does not present as doing so.
            self.skipTest(f""Could not recreate conditions on {sys.platform}:""
                          f"" {err=}"")
        # If maintaining this conditional winds up being a problem.
        # just turn this into an unconditional skip anything but Linux.
        # The important thing is that our CI has the logic covered.

    def test_preauth_data_to_tls_server(self):
        server_accept_called = threading.Event()
        ready_for_server_wrap_socket = threading.Event()

        def call_after_accept(unused):
            server_accept_called.set()
            if not ready_for_server_wrap_socket.wait(2.0):
                raise RuntimeError(""wrap_socket event never set, test may fail."")
            return False  # Tell the server thread to continue.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""preauth_data_to_tls_server"")
        self.enterContext(server)  # starts it & unittest.TestCase stops it.

        with socket.socket() as client:
            client.connect(server.listener.getsockname())
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(client)
            client.setblocking(False)

            server_accept_called.wait()
            client.send(b""DELETE /data HTTP/1.0\r\n\r\n"")
            client.close()  # RST

        ready_for_server_wrap_socket.set()
        server.join()
        wrap_error = server.wrap_error
        self.assertEqual(b"""", server.received_data)
        self.assertIsInstance(wrap_error, OSError)  # All platforms.
        self.non_linux_skip_if_other_okay_error(wrap_error)
        self.assertIsInstance(wrap_error, ssl.SSLError)
        self.assertIn(""before TLS handshake with data"", wrap_error.args[1])
        self.assertIn(""before TLS handshake with data"", wrap_error.reason)
        self.assertNotEqual(0, wrap_error.args[0])
        self.assertIsNone(wrap_error.library, msg=""attr must exist"")

    def test_preauth_data_to_tls_client(self):
        client_can_continue_with_wrap_socket = threading.Event()

        def call_after_accept(conn_to_client):
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(conn_to_client)
            conn_to_client.send(
                    b""HTTP/1.0 307 Temporary Redirect\r\n""
                    b""Location: https://example.com/someone-elses-server\r\n""
                    b""\r\n"")
            conn_to_client.close()  # RST
            client_can_continue_with_wrap_socket.set()
            return True  # Tell the server to stop.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""preauth_data_to_tls_client"")
        self.enterContext(server)  # starts it & unittest.TestCase stops it.
        # Redundant; call_after_accept sets SO_LINGER on the accepted conn.
        set_socket_so_linger_on_with_zero_timeout(server.listener)

        with socket.socket() as client:
            client.connect(server.listener.getsockname())
            if not client_can_continue_with_wrap_socket.wait(2.0):
                self.fail(""test server took too long."")
            ssl_ctx = ssl.create_default_context()
            try:
                tls_client = ssl_ctx.wrap_socket(
                        client, server_hostname=""localhost"")
            except OSError as err:  # SSLError inherits from OSError
                wrap_error = err
                received_data = b""""
            else:
                wrap_error = None
                received_data = tls_client.recv(400)
                tls_client.close()

        server.join()
        self.assertEqual(b"""", received_data)
        self.assertIsInstance(wrap_error, OSError)  # All platforms.
        self.non_linux_skip_if_other_okay_error(wrap_error)
        self.assertIsInstance(wrap_error, ssl.SSLError)
        self.assertIn(""before TLS handshake with data"", wrap_error.args[1])
        self.assertIn(""before TLS handshake with data"", wrap_error.reason)
        self.assertNotEqual(0, wrap_error.args[0])
        self.assertIsNone(wrap_error.library, msg=""attr must exist"")

    def test_https_client_non_tls_response_ignored(self):

        server_responding = threading.Event()

        class SynchronizedHTTPSConnection(http.client.HTTPSConnection):
            def connect(self):
                http.client.HTTPConnection.connect(self)
                # Wait for our fault injection server to have done its thing.
                if not server_responding.wait(1.0) and support.verbose:
                    sys.stdout.write(""server_responding event never set."")
                self.sock = self._context.wrap_socket(
                        self.sock, server_hostname=self.host)

        def call_after_accept(conn_to_client):
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(conn_to_client)
            conn_to_client.send(
                    b""HTTP/1.0 402 Payment Required\r\n""
                    b""\r\n"")
            conn_to_client.close()  # RST
            server_responding.set()
            return True  # Tell the server to stop.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""non_tls_http_RST_responder"")
        self.enterContext(server)  # starts it & unittest.TestCase stops it.
        # Redundant; call_after_accept sets SO_LINGER on the accepted conn.
        set_socket_so_linger_on_with_zero_timeout(server.listener)

        connection = SynchronizedHTTPSConnection(
                f""localhost"",
                port=server.port,
                context=ssl.create_default_context(),
                timeout=2.0,
        )
        # There are lots of reasons this raises as desired, long before this
        # test was added. Sending the request requires a successful TLS wrapped
        # socket; that fails if the connection is broken. It may seem pointless
        # to test this. It serves as an illustration of something that we never
        # want to happen... properly not happening.
        with self.assertRaises(OSError) as err_ctx:
            connection.request(""HEAD"", ""/test"", headers={""Host"": ""localhost""})
            response = connection.getresponse()

",,256586ab8776e4526ca594b4866b9a3492e628f1,CVE-2023-40217,256586ab8776e4526ca594b4866b9a3492e628f1,https://github.com/python/cpython,CPE_GIT_REPOBASED,156,COMPLETED,"VAR VAR VAR VAR VAR VAR.VAR VAR VAR(VAR): VAR.VAR(VAR.VAR, VAR.VAR, VAR.VAR('VAR', 1, 0)) VAR VAR(VAR.VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR.VAR): VAR VAR(VAR, *, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR''  VAR.VAR = VAR  VAR.VAR = VAR  VAR.VAR = VAR  VAR().VAR(VAR=VAR) VAR VAR(VAR): VAR.VAR() VAR VAR VAR VAR(VAR, *VAR): VAR: VAR VAR.VAR: VAR.VAR.VAR() VAR VAR: VAR VAR.VAR() VAR.VAR = VAR  VAR VAR(VAR): VAR.VAR = VAR.VAR(VAR.VAR.VAR) VAR.VAR.VAR = VAR.VAR VAR.VAR.VAR(VAR=VAR) VAR.VAR.VAR(VAR=VAR, VAR=VAR) VAR.VAR = VAR.VAR() VAR.VAR = VAR.VAR(VAR.VAR) VAR.VAR.VAR(2.0) VAR.VAR.VAR(1) VAR().VAR() VAR VAR(VAR): VAR, VAR = VAR.VAR.VAR() VAR.VAR.VAR() VAR VAR: VAR VAR.VAR(VAR): VAR VAR: VAR = VAR.VAR.VAR(VAR, VAR=VAR) VAR VAR VAR VAR:  VAR.VAR = VAR VAR: VAR: VAR.VAR = VAR.VAR(400) VAR VAR: VAR  VAR VAR(VAR, VAR): VAR VAR.VAR == ""VAR"": VAR  VAR (VAR(VAR, VAR) VAR (VAR(VAR, VAR) VAR VAR.VAR == VAR.VAR) VAR VAR.VAR('VAR.VAR.VAR', VAR(VAR, ""VAR"", """"), VAR.VAR)):         VAR.VAR(VAR""VAR VAR VAR VAR VAR {VAR.VAR}:"" VAR"" {VAR=}"")    VAR VAR(VAR): VAR = VAR.VAR() VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR VAR VAR.VAR(2.0): VAR VAR(""VAR VAR VAR VAR, VAR VAR VAR."") VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR(VAR)  VAR VAR.VAR() VAR VAR: VAR.VAR(VAR.VAR.VAR())  VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR(VAR""VAR /VAR VAR/1.0\VAR\VAR\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR.VAR() VAR = VAR.VAR VAR.VAR(VAR"""", VAR.VAR) VAR.VAR(VAR, VAR)  VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR[1]) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR) VAR.VAR(0, VAR.VAR[0]) VAR.VAR(VAR.VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR):  VAR(VAR) VAR.VAR( VAR""VAR/1.0 307 VAR VAR\VAR\VAR"" VAR""VAR: VAR: VAR""\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR(VAR)   VAR(VAR.VAR) VAR VAR.VAR() VAR VAR: VAR.VAR(VAR.VAR.VAR()) VAR VAR VAR.VAR(2.0): VAR.VAR(""VAR VAR VAR VAR VAR."") VAR = VAR.VAR() VAR: VAR = VAR.VAR( VAR, VAR=""VAR"") VAR VAR VAR VAR:  VAR = VAR VAR = VAR"""" VAR: VAR = VAR VAR = VAR.VAR(400) VAR.VAR() VAR.VAR() VAR.VAR(VAR"""", VAR) VAR.VAR(VAR, VAR)  VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR[1]) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR) VAR.VAR(0, VAR.VAR[0]) VAR.VAR(VAR.VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR.VAR.VAR): VAR VAR(VAR): VAR.VAR.VAR.VAR(VAR)  VAR VAR VAR.VAR(1.0) VAR VAR.VAR: VAR.VAR.VAR(""VAR VAR VAR VAR."") VAR.VAR = VAR.VAR.VAR( VAR.VAR, VAR=VAR.VAR) VAR VAR(VAR):  VAR(VAR) VAR.VAR( VAR""VAR/1.0 402 VAR VAR\VAR\VAR"" VAR""\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR(VAR)   VAR(VAR.VAR) VAR = VAR( VAR""VAR"", VAR=VAR.VAR, VAR=VAR.VAR(), VAR=2.0, )      VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""VAR""}) VAR = VAR.VAR() ",0,16
cpython_264b1dacc67346efa0933d1e63f622676e0ed96b,Litest/test_ssl.py,"import re
import struct
import http.client
def set_socket_so_linger_on_with_zero_timeout(sock):
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack('ii', 1, 0))


class TestPreHandshakeClose(unittest.TestCase):
    """"""Verify behavior of close sockets with received data before to the handshake.
    """"""

    class SingleConnectionTestServerThread(threading.Thread):

        def __init__(self, *, name, call_after_accept):
            self.call_after_accept = call_after_accept
            self.received_data = b''  # set by .run()
            self.wrap_error = None  # set by .run()
            self.listener = None  # set by .start()
            self.port = None  # set by .start()
            super().__init__(name=name)

        def __enter__(self):
            self.start()
            return self

        def __exit__(self, *args):
            try:
                if self.listener:
                    self.listener.close()
            except OSError:
                pass
            self.join()
            self.wrap_error = None  # avoid dangling references

        def start(self):
            self.ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            self.ssl_ctx.verify_mode = ssl.CERT_REQUIRED
            self.ssl_ctx.load_verify_locations(cafile=ONLYCERT)
            self.ssl_ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)
            self.listener = socket.socket()
            self.port = socket_helper.bind_port(self.listener)
            self.listener.settimeout(2.0)
            self.listener.listen(1)
            super().start()

        def run(self):
            conn, address = self.listener.accept()
            self.listener.close()
            with conn:
                if self.call_after_accept(conn):
                    return
                try:
                    tls_socket = self.ssl_ctx.wrap_socket(conn, server_side=True)
                except OSError as err:  # ssl.SSLError inherits from OSError
                    self.wrap_error = err
                else:
                    try:
                        self.received_data = tls_socket.recv(400)
                    except OSError:
                        pass  # closed, protocol error, etc.

    def non_linux_skip_if_other_okay_error(self, err):
        if sys.platform == ""linux"":
            return  # Expect the full test setup to always work on Linux.
        if (isinstance(err, ConnectionResetError) or
            (isinstance(err, OSError) and err.errno == errno.EINVAL) or
            re.search('wrong.version.number', getattr(err, ""reason"", """"), re.I)):
            # On Windows the TCP RST leads to a ConnectionResetError
            # (ECONNRESET) which Linux doesn't appear to surface to userspace.
            # If wrap_socket() winds up on the ""if connected:"" path and doing
            # the actual wrapping... we get an SSLError from OpenSSL. Typically
            # WRONG_VERSION_NUMBER. While appropriate, neither is the scenario
            # we're specifically trying to test. The way this test is written
            # is known to work on Linux. We'll skip it anywhere else that it
            # does not present as doing so.
            self.skipTest(f""Could not recreate conditions on {sys.platform}:""
                          f"" {err=}"")
        # If maintaining this conditional winds up being a problem.
        # just turn this into an unconditional skip anything but Linux.
        # The important thing is that our CI has the logic covered.

    def test_preauth_data_to_tls_server(self):
        server_accept_called = threading.Event()
        ready_for_server_wrap_socket = threading.Event()

        def call_after_accept(unused):
            server_accept_called.set()
            if not ready_for_server_wrap_socket.wait(2.0):
                raise RuntimeError(""wrap_socket event never set, test may fail."")
            return False  # Tell the server thread to continue.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""preauth_data_to_tls_server"")
        server.__enter__()  # starts it
        self.addCleanup(server.__exit__)  # ... & unittest.TestCase stops it.

        with socket.socket() as client:
            client.connect(server.listener.getsockname())
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(client)
            client.setblocking(False)

            server_accept_called.wait()
            client.send(b""DELETE /data HTTP/1.0\r\n\r\n"")
            client.close()  # RST

        ready_for_server_wrap_socket.set()
        server.join()
        wrap_error = server.wrap_error
        self.assertEqual(b"""", server.received_data)
        self.assertIsInstance(wrap_error, OSError)  # All platforms.
        self.non_linux_skip_if_other_okay_error(wrap_error)
        self.assertIsInstance(wrap_error, ssl.SSLError)
        self.assertIn(""before TLS handshake with data"", wrap_error.args[1])
        self.assertIn(""before TLS handshake with data"", wrap_error.reason)
        self.assertNotEqual(0, wrap_error.args[0])
        self.assertIsNone(wrap_error.library, msg=""attr must exist"")

    def test_preauth_data_to_tls_client(self):
        client_can_continue_with_wrap_socket = threading.Event()

        def call_after_accept(conn_to_client):
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(conn_to_client)
            conn_to_client.send(
                    b""HTTP/1.0 307 Temporary Redirect\r\n""
                    b""Location: https://example.com/someone-elses-server\r\n""
                    b""\r\n"")
            conn_to_client.close()  # RST
            client_can_continue_with_wrap_socket.set()
            return True  # Tell the server to stop.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""preauth_data_to_tls_client"")
        server.__enter__()  # starts it
        self.addCleanup(server.__exit__)  # ... & unittest.TestCase stops it.

        # Redundant; call_after_accept sets SO_LINGER on the accepted conn.
        set_socket_so_linger_on_with_zero_timeout(server.listener)

        with socket.socket() as client:
            client.connect(server.listener.getsockname())
            if not client_can_continue_with_wrap_socket.wait(2.0):
                self.fail(""test server took too long."")
            ssl_ctx = ssl.create_default_context()
            try:
                tls_client = ssl_ctx.wrap_socket(
                        client, server_hostname=""localhost"")
            except OSError as err:  # SSLError inherits from OSError
                wrap_error = err
                received_data = b""""
            else:
                wrap_error = None
                received_data = tls_client.recv(400)
                tls_client.close()

        server.join()
        self.assertEqual(b"""", received_data)
        self.assertIsInstance(wrap_error, OSError)  # All platforms.
        self.non_linux_skip_if_other_okay_error(wrap_error)
        self.assertIsInstance(wrap_error, ssl.SSLError)
        self.assertIn(""before TLS handshake with data"", wrap_error.args[1])
        self.assertIn(""before TLS handshake with data"", wrap_error.reason)
        self.assertNotEqual(0, wrap_error.args[0])
        self.assertIsNone(wrap_error.library, msg=""attr must exist"")

    def test_https_client_non_tls_response_ignored(self):

        server_responding = threading.Event()

        class SynchronizedHTTPSConnection(http.client.HTTPSConnection):
            def connect(self):
                http.client.HTTPConnection.connect(self)
                # Wait for our fault injection server to have done its thing.
                if not server_responding.wait(1.0) and support.verbose:
                    sys.stdout.write(""server_responding event never set."")
                self.sock = self._context.wrap_socket(
                        self.sock, server_hostname=self.host)

        def call_after_accept(conn_to_client):
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(conn_to_client)
            conn_to_client.send(
                    b""HTTP/1.0 402 Payment Required\r\n""
                    b""\r\n"")
            conn_to_client.close()  # RST
            server_responding.set()
            return True  # Tell the server to stop.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""non_tls_http_RST_responder"")
        server.__enter__()  # starts it
        self.addCleanup(server.__exit__)  # ... & unittest.TestCase stops it.
        # Redundant; call_after_accept sets SO_LINGER on the accepted conn.
        set_socket_so_linger_on_with_zero_timeout(server.listener)

        connection = SynchronizedHTTPSConnection(
                f""localhost"",
                port=server.port,
                context=ssl.create_default_context(),
                timeout=2.0,
        )
        # There are lots of reasons this raises as desired, long before this
        # test was added. Sending the request requires a successful TLS wrapped
        # socket; that fails if the connection is broken. It may seem pointless
        # to test this. It serves as an illustration of something that we never
        # want to happen... properly not happening.
        with self.assertRaises(OSError) as err_ctx:
            connection.request(""HEAD"", ""/test"", headers={""Host"": ""localhost""})
            response = connection.getresponse()

",,264b1dacc67346efa0933d1e63f622676e0ed96b,CVE-2023-40217,264b1dacc67346efa0933d1e63f622676e0ed96b,https://github.com/python/cpython,CPE_GIT_REPOBASED,154,COMPLETED,"VAR VAR VAR VAR VAR VAR.VAR VAR VAR(VAR): VAR.VAR(VAR.VAR, VAR.VAR, VAR.VAR('VAR', 1, 0)) VAR VAR(VAR.VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR.VAR): VAR VAR(VAR, *, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR''  VAR.VAR = VAR  VAR.VAR = VAR  VAR.VAR = VAR  VAR().VAR(VAR=VAR) VAR VAR(VAR): VAR.VAR() VAR VAR VAR VAR(VAR, *VAR): VAR: VAR VAR.VAR: VAR.VAR.VAR() VAR VAR: VAR VAR.VAR() VAR.VAR = VAR  VAR VAR(VAR): VAR.VAR = VAR.VAR(VAR.VAR.VAR) VAR.VAR.VAR = VAR.VAR VAR.VAR.VAR(VAR=VAR) VAR.VAR.VAR(VAR=VAR, VAR=VAR) VAR.VAR = VAR.VAR() VAR.VAR = VAR.VAR(VAR.VAR) VAR.VAR.VAR(2.0) VAR.VAR.VAR(1) VAR().VAR() VAR VAR(VAR): VAR, VAR = VAR.VAR.VAR() VAR.VAR.VAR() VAR VAR: VAR VAR.VAR(VAR): VAR VAR: VAR = VAR.VAR.VAR(VAR, VAR=VAR) VAR VAR VAR VAR:  VAR.VAR = VAR VAR: VAR: VAR.VAR = VAR.VAR(400) VAR VAR: VAR  VAR VAR(VAR, VAR): VAR VAR.VAR == ""VAR"": VAR  VAR (VAR(VAR, VAR) VAR (VAR(VAR, VAR) VAR VAR.VAR == VAR.VAR) VAR VAR.VAR('VAR.VAR.VAR', VAR(VAR, ""VAR"", """"), VAR.VAR)):         VAR.VAR(VAR""VAR VAR VAR VAR VAR {VAR.VAR}:"" VAR"" {VAR=}"")    VAR VAR(VAR): VAR = VAR.VAR() VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR VAR VAR.VAR(2.0): VAR VAR(""VAR VAR VAR VAR, VAR VAR VAR."") VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR()  VAR.VAR(VAR.VAR)  VAR VAR.VAR() VAR VAR: VAR.VAR(VAR.VAR.VAR())  VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR(VAR""VAR /VAR VAR/1.0\VAR\VAR\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR.VAR() VAR = VAR.VAR VAR.VAR(VAR"""", VAR.VAR) VAR.VAR(VAR, VAR)  VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR[1]) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR) VAR.VAR(0, VAR.VAR[0]) VAR.VAR(VAR.VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR):  VAR(VAR) VAR.VAR( VAR""VAR/1.0 307 VAR VAR\VAR\VAR"" VAR""VAR: VAR: VAR""\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR()  VAR.VAR(VAR.VAR)   VAR(VAR.VAR) VAR VAR.VAR() VAR VAR: VAR.VAR(VAR.VAR.VAR()) VAR VAR VAR.VAR(2.0): VAR.VAR(""VAR VAR VAR VAR VAR."") VAR = VAR.VAR() VAR: VAR = VAR.VAR( VAR, VAR=""VAR"") VAR VAR VAR VAR:  VAR = VAR VAR = VAR"""" VAR: VAR = VAR VAR = VAR.VAR(400) VAR.VAR() VAR.VAR() VAR.VAR(VAR"""", VAR) VAR.VAR(VAR, VAR)  VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR[1]) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR) VAR.VAR(0, VAR.VAR[0]) VAR.VAR(VAR.VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR.VAR.VAR): VAR VAR(VAR): VAR.VAR.VAR.VAR(VAR)  VAR VAR VAR.VAR(1.0) VAR VAR.VAR: VAR.VAR.VAR(""VAR VAR VAR VAR."") VAR.VAR = VAR.VAR.VAR( VAR.VAR, VAR=VAR.VAR) VAR VAR(VAR):  VAR(VAR) VAR.VAR( VAR""VAR/1.0 402 VAR VAR\VAR\VAR"" VAR""\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR()  VAR.VAR(VAR.VAR)   VAR(VAR.VAR) VAR = VAR( VAR""VAR"", VAR=VAR.VAR, VAR=VAR.VAR(), VAR=2.0, )      VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""VAR""}) VAR = VAR.VAR() ",0,16
cpython_75a875e0df0530b75b1470d797942f90f4a718d3,Litest/test_ssl.py,"import re
import struct
import http.client
def set_socket_so_linger_on_with_zero_timeout(sock):
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack('ii', 1, 0))


class TestPreHandshakeClose(unittest.TestCase):
    """"""Verify behavior of close sockets with received data before to the handshake.
    """"""

    class SingleConnectionTestServerThread(threading.Thread):

        def __init__(self, *, name, call_after_accept):
            self.call_after_accept = call_after_accept
            self.received_data = b''  # set by .run()
            self.wrap_error = None  # set by .run()
            self.listener = None  # set by .start()
            self.port = None  # set by .start()
            super().__init__(name=name)

        def __enter__(self):
            self.start()
            return self

        def __exit__(self, *args):
            try:
                if self.listener:
                    self.listener.close()
            except OSError:
                pass
            self.join()
            self.wrap_error = None  # avoid dangling references

        def start(self):
            self.ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            self.ssl_ctx.verify_mode = ssl.CERT_REQUIRED
            self.ssl_ctx.load_verify_locations(cafile=ONLYCERT)
            self.ssl_ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)
            self.listener = socket.socket()
            self.port = socket_helper.bind_port(self.listener)
            self.listener.settimeout(2.0)
            self.listener.listen(1)
            super().start()

        def run(self):
            conn, address = self.listener.accept()
            self.listener.close()
            with conn:
                if self.call_after_accept(conn):
                    return
                try:
                    tls_socket = self.ssl_ctx.wrap_socket(conn, server_side=True)
                except OSError as err:  # ssl.SSLError inherits from OSError
                    self.wrap_error = err
                else:
                    try:
                        self.received_data = tls_socket.recv(400)
                    except OSError:
                        pass  # closed, protocol error, etc.

    def non_linux_skip_if_other_okay_error(self, err):
        if sys.platform == ""linux"":
            return  # Expect the full test setup to always work on Linux.
        if (isinstance(err, ConnectionResetError) or
            (isinstance(err, OSError) and err.errno == errno.EINVAL) or
            re.search('wrong.version.number', getattr(err, ""reason"", """"), re.I)):
            # On Windows the TCP RST leads to a ConnectionResetError
            # (ECONNRESET) which Linux doesn't appear to surface to userspace.
            # If wrap_socket() winds up on the ""if connected:"" path and doing
            # the actual wrapping... we get an SSLError from OpenSSL. Typically
            # WRONG_VERSION_NUMBER. While appropriate, neither is the scenario
            # we're specifically trying to test. The way this test is written
            # is known to work on Linux. We'll skip it anywhere else that it
            # does not present as doing so.
            self.skipTest(f""Could not recreate conditions on {sys.platform}:""
                          f"" {err=}"")
        # If maintaining this conditional winds up being a problem.
        # just turn this into an unconditional skip anything but Linux.
        # The important thing is that our CI has the logic covered.

    def test_preauth_data_to_tls_server(self):
        server_accept_called = threading.Event()
        ready_for_server_wrap_socket = threading.Event()

        def call_after_accept(unused):
            server_accept_called.set()
            if not ready_for_server_wrap_socket.wait(2.0):
                raise RuntimeError(""wrap_socket event never set, test may fail."")
            return False  # Tell the server thread to continue.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""preauth_data_to_tls_server"")
        self.enterContext(server)  # starts it & unittest.TestCase stops it.

        with socket.socket() as client:
            client.connect(server.listener.getsockname())
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(client)
            client.setblocking(False)

            server_accept_called.wait()
            client.send(b""DELETE /data HTTP/1.0\r\n\r\n"")
            client.close()  # RST

        ready_for_server_wrap_socket.set()
        server.join()
        wrap_error = server.wrap_error
        self.assertEqual(b"""", server.received_data)
        self.assertIsInstance(wrap_error, OSError)  # All platforms.
        self.non_linux_skip_if_other_okay_error(wrap_error)
        self.assertIsInstance(wrap_error, ssl.SSLError)
        self.assertIn(""before TLS handshake with data"", wrap_error.args[1])
        self.assertIn(""before TLS handshake with data"", wrap_error.reason)
        self.assertNotEqual(0, wrap_error.args[0])
        self.assertIsNone(wrap_error.library, msg=""attr must exist"")

    def test_preauth_data_to_tls_client(self):
        client_can_continue_with_wrap_socket = threading.Event()

        def call_after_accept(conn_to_client):
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(conn_to_client)
            conn_to_client.send(
                    b""HTTP/1.0 307 Temporary Redirect\r\n""
                    b""Location: https://example.com/someone-elses-server\r\n""
                    b""\r\n"")
            conn_to_client.close()  # RST
            client_can_continue_with_wrap_socket.set()
            return True  # Tell the server to stop.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""preauth_data_to_tls_client"")
        self.enterContext(server)  # starts it & unittest.TestCase stops it.
        # Redundant; call_after_accept sets SO_LINGER on the accepted conn.
        set_socket_so_linger_on_with_zero_timeout(server.listener)

        with socket.socket() as client:
            client.connect(server.listener.getsockname())
            if not client_can_continue_with_wrap_socket.wait(2.0):
                self.fail(""test server took too long."")
            ssl_ctx = ssl.create_default_context()
            try:
                tls_client = ssl_ctx.wrap_socket(
                        client, server_hostname=""localhost"")
            except OSError as err:  # SSLError inherits from OSError
                wrap_error = err
                received_data = b""""
            else:
                wrap_error = None
                received_data = tls_client.recv(400)
                tls_client.close()

        server.join()
        self.assertEqual(b"""", received_data)
        self.assertIsInstance(wrap_error, OSError)  # All platforms.
        self.non_linux_skip_if_other_okay_error(wrap_error)
        self.assertIsInstance(wrap_error, ssl.SSLError)
        self.assertIn(""before TLS handshake with data"", wrap_error.args[1])
        self.assertIn(""before TLS handshake with data"", wrap_error.reason)
        self.assertNotEqual(0, wrap_error.args[0])
        self.assertIsNone(wrap_error.library, msg=""attr must exist"")

    def test_https_client_non_tls_response_ignored(self):

        server_responding = threading.Event()

        class SynchronizedHTTPSConnection(http.client.HTTPSConnection):
            def connect(self):
                http.client.HTTPConnection.connect(self)
                # Wait for our fault injection server to have done its thing.
                if not server_responding.wait(1.0) and support.verbose:
                    sys.stdout.write(""server_responding event never set."")
                self.sock = self._context.wrap_socket(
                        self.sock, server_hostname=self.host)

        def call_after_accept(conn_to_client):
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(conn_to_client)
            conn_to_client.send(
                    b""HTTP/1.0 402 Payment Required\r\n""
                    b""\r\n"")
            conn_to_client.close()  # RST
            server_responding.set()
            return True  # Tell the server to stop.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""non_tls_http_RST_responder"")
        self.enterContext(server)  # starts it & unittest.TestCase stops it.
        # Redundant; call_after_accept sets SO_LINGER on the accepted conn.
        set_socket_so_linger_on_with_zero_timeout(server.listener)

        connection = SynchronizedHTTPSConnection(
                f""localhost"",
                port=server.port,
                context=ssl.create_default_context(),
                timeout=2.0,
        )
        # There are lots of reasons this raises as desired, long before this
        # test was added. Sending the request requires a successful TLS wrapped
        # socket; that fails if the connection is broken. It may seem pointless
        # to test this. It serves as an illustration of something that we never
        # want to happen... properly not happening.
        with self.assertRaises(OSError) as err_ctx:
            connection.request(""HEAD"", ""/test"", headers={""Host"": ""localhost""})
            response = connection.getresponse()

",,75a875e0df0530b75b1470d797942f90f4a718d3,CVE-2023-40217,75a875e0df0530b75b1470d797942f90f4a718d3,https://github.com/python/cpython,CPE_GIT_REPOBASED,154,COMPLETED,"VAR VAR VAR VAR VAR VAR.VAR VAR VAR(VAR): VAR.VAR(VAR.VAR, VAR.VAR, VAR.VAR('VAR', 1, 0)) VAR VAR(VAR.VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR.VAR): VAR VAR(VAR, *, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR''  VAR.VAR = VAR  VAR.VAR = VAR  VAR.VAR = VAR  VAR().VAR(VAR=VAR) VAR VAR(VAR): VAR.VAR() VAR VAR VAR VAR(VAR, *VAR): VAR: VAR VAR.VAR: VAR.VAR.VAR() VAR VAR: VAR VAR.VAR() VAR.VAR = VAR  VAR VAR(VAR): VAR.VAR = VAR.VAR(VAR.VAR.VAR) VAR.VAR.VAR = VAR.VAR VAR.VAR.VAR(VAR=VAR) VAR.VAR.VAR(VAR=VAR, VAR=VAR) VAR.VAR = VAR.VAR() VAR.VAR = VAR.VAR(VAR.VAR) VAR.VAR.VAR(2.0) VAR.VAR.VAR(1) VAR().VAR() VAR VAR(VAR): VAR, VAR = VAR.VAR.VAR() VAR.VAR.VAR() VAR VAR: VAR VAR.VAR(VAR): VAR VAR: VAR = VAR.VAR.VAR(VAR, VAR=VAR) VAR VAR VAR VAR:  VAR.VAR = VAR VAR: VAR: VAR.VAR = VAR.VAR(400) VAR VAR: VAR  VAR VAR(VAR, VAR): VAR VAR.VAR == ""VAR"": VAR  VAR (VAR(VAR, VAR) VAR (VAR(VAR, VAR) VAR VAR.VAR == VAR.VAR) VAR VAR.VAR('VAR.VAR.VAR', VAR(VAR, ""VAR"", """"), VAR.VAR)):         VAR.VAR(VAR""VAR VAR VAR VAR VAR {VAR.VAR}:"" VAR"" {VAR=}"")    VAR VAR(VAR): VAR = VAR.VAR() VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR VAR VAR.VAR(2.0): VAR VAR(""VAR VAR VAR VAR, VAR VAR VAR."") VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR(VAR)  VAR VAR.VAR() VAR VAR: VAR.VAR(VAR.VAR.VAR())  VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR(VAR""VAR /VAR VAR/1.0\VAR\VAR\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR.VAR() VAR = VAR.VAR VAR.VAR(VAR"""", VAR.VAR) VAR.VAR(VAR, VAR)  VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR[1]) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR) VAR.VAR(0, VAR.VAR[0]) VAR.VAR(VAR.VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR):  VAR(VAR) VAR.VAR( VAR""VAR/1.0 307 VAR VAR\VAR\VAR"" VAR""VAR: VAR: VAR""\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR(VAR)   VAR(VAR.VAR) VAR VAR.VAR() VAR VAR: VAR.VAR(VAR.VAR.VAR()) VAR VAR VAR.VAR(2.0): VAR.VAR(""VAR VAR VAR VAR VAR."") VAR = VAR.VAR() VAR: VAR = VAR.VAR( VAR, VAR=""VAR"") VAR VAR VAR VAR:  VAR = VAR VAR = VAR"""" VAR: VAR = VAR VAR = VAR.VAR(400) VAR.VAR() VAR.VAR() VAR.VAR(VAR"""", VAR) VAR.VAR(VAR, VAR)  VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR[1]) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR) VAR.VAR(0, VAR.VAR[0]) VAR.VAR(VAR.VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR.VAR.VAR): VAR VAR(VAR): VAR.VAR.VAR.VAR(VAR)  VAR VAR VAR.VAR(1.0) VAR VAR.VAR: VAR.VAR.VAR(""VAR VAR VAR VAR."") VAR.VAR = VAR.VAR.VAR( VAR.VAR, VAR=VAR.VAR) VAR VAR(VAR):  VAR(VAR) VAR.VAR( VAR""VAR/1.0 402 VAR VAR\VAR\VAR"" VAR""\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR(VAR)   VAR(VAR.VAR) VAR = VAR( VAR""VAR"", VAR=VAR.VAR, VAR=VAR.VAR(), VAR=2.0, )      VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""VAR""}) VAR = VAR.VAR() ",0,16
cpython_b4bcc06a9cfe13d96d5270809d963f8ba278f89b,Litest/test_ssl.py,"import re
import struct
import http.client
def set_socket_so_linger_on_with_zero_timeout(sock):
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_LINGER, struct.pack('ii', 1, 0))


class TestPreHandshakeClose(unittest.TestCase):
    """"""Verify behavior of close sockets with received data before to the handshake.
    """"""

    class SingleConnectionTestServerThread(threading.Thread):

        def __init__(self, *, name, call_after_accept):
            self.call_after_accept = call_after_accept
            self.received_data = b''  # set by .run()
            self.wrap_error = None  # set by .run()
            self.listener = None  # set by .start()
            self.port = None  # set by .start()
            super().__init__(name=name)

        def __enter__(self):
            self.start()
            return self

        def __exit__(self, *args):
            try:
                if self.listener:
                    self.listener.close()
            except OSError:
                pass
            self.join()
            self.wrap_error = None  # avoid dangling references

        def start(self):
            self.ssl_ctx = ssl.create_default_context(ssl.Purpose.CLIENT_AUTH)
            self.ssl_ctx.verify_mode = ssl.CERT_REQUIRED
            self.ssl_ctx.load_verify_locations(cafile=ONLYCERT)
            self.ssl_ctx.load_cert_chain(certfile=ONLYCERT, keyfile=ONLYKEY)
            self.listener = socket.socket()
            self.port = support.bind_port(self.listener)
            self.listener.settimeout(2.0)
            self.listener.listen(1)
            super().start()

        def run(self):
            conn, address = self.listener.accept()
            self.listener.close()
            with conn:
                if self.call_after_accept(conn):
                    return
                try:
                    tls_socket = self.ssl_ctx.wrap_socket(conn, server_side=True)
                except OSError as err:  # ssl.SSLError inherits from OSError
                    self.wrap_error = err
                else:
                    try:
                        self.received_data = tls_socket.recv(400)
                    except OSError:
                        pass  # closed, protocol error, etc.

    def non_linux_skip_if_other_okay_error(self, err):
        if sys.platform == ""linux"":
            return  # Expect the full test setup to always work on Linux.
        if (isinstance(err, ConnectionResetError) or
            (isinstance(err, OSError) and err.errno == errno.EINVAL) or
            re.search('wrong.version.number', getattr(err, ""reason"", """"), re.I)):
            # On Windows the TCP RST leads to a ConnectionResetError
            # (ECONNRESET) which Linux doesn't appear to surface to userspace.
            # If wrap_socket() winds up on the ""if connected:"" path and doing
            # the actual wrapping... we get an SSLError from OpenSSL. Typically
            # WRONG_VERSION_NUMBER. While appropriate, neither is the scenario
            # we're specifically trying to test. The way this test is written
            # is known to work on Linux. We'll skip it anywhere else that it
            # does not present as doing so.
            self.skipTest(f""Could not recreate conditions on {sys.platform}:""
                          f"" {err=}"")
        # If maintaining this conditional winds up being a problem.
        # just turn this into an unconditional skip anything but Linux.
        # The important thing is that our CI has the logic covered.

    def test_preauth_data_to_tls_server(self):
        server_accept_called = threading.Event()
        ready_for_server_wrap_socket = threading.Event()

        def call_after_accept(unused):
            server_accept_called.set()
            if not ready_for_server_wrap_socket.wait(2.0):
                raise RuntimeError(""wrap_socket event never set, test may fail."")
            return False  # Tell the server thread to continue.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""preauth_data_to_tls_server"")
        server.__enter__()  # starts it
        self.addCleanup(server.__exit__)  # ... & unittest.TestCase stops it.

        with socket.socket() as client:
            client.connect(server.listener.getsockname())
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(client)
            client.setblocking(False)

            server_accept_called.wait()
            client.send(b""DELETE /data HTTP/1.0\r\n\r\n"")
            client.close()  # RST

        ready_for_server_wrap_socket.set()
        server.join()
        wrap_error = server.wrap_error
        self.assertEqual(b"""", server.received_data)
        self.assertIsInstance(wrap_error, OSError)  # All platforms.
        self.non_linux_skip_if_other_okay_error(wrap_error)
        self.assertIsInstance(wrap_error, ssl.SSLError)
        self.assertIn(""before TLS handshake with data"", wrap_error.args[1])
        self.assertIn(""before TLS handshake with data"", wrap_error.reason)
        self.assertNotEqual(0, wrap_error.args[0])
        self.assertIsNone(wrap_error.library, msg=""attr must exist"")

    def test_preauth_data_to_tls_client(self):
        client_can_continue_with_wrap_socket = threading.Event()

        def call_after_accept(conn_to_client):
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(conn_to_client)
            conn_to_client.send(
                    b""HTTP/1.0 307 Temporary Redirect\r\n""
                    b""Location: https://example.com/someone-elses-server\r\n""
                    b""\r\n"")
            conn_to_client.close()  # RST
            client_can_continue_with_wrap_socket.set()
            return True  # Tell the server to stop.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""preauth_data_to_tls_client"")
        server.__enter__()  # starts it
        self.addCleanup(server.__exit__)  # ... & unittest.TestCase stops it.

        # Redundant; call_after_accept sets SO_LINGER on the accepted conn.
        set_socket_so_linger_on_with_zero_timeout(server.listener)

        with socket.socket() as client:
            client.connect(server.listener.getsockname())
            if not client_can_continue_with_wrap_socket.wait(2.0):
                self.fail(""test server took too long."")
            ssl_ctx = ssl.create_default_context()
            try:
                tls_client = ssl_ctx.wrap_socket(
                        client, server_hostname=""localhost"")
            except OSError as err:  # SSLError inherits from OSError
                wrap_error = err
                received_data = b""""
            else:
                wrap_error = None
                received_data = tls_client.recv(400)
                tls_client.close()

        server.join()
        self.assertEqual(b"""", received_data)
        self.assertIsInstance(wrap_error, OSError)  # All platforms.
        self.non_linux_skip_if_other_okay_error(wrap_error)
        self.assertIsInstance(wrap_error, ssl.SSLError)
        self.assertIn(""before TLS handshake with data"", wrap_error.args[1])
        self.assertIn(""before TLS handshake with data"", wrap_error.reason)
        self.assertNotEqual(0, wrap_error.args[0])
        self.assertIsNone(wrap_error.library, msg=""attr must exist"")

    def test_https_client_non_tls_response_ignored(self):

        server_responding = threading.Event()

        class SynchronizedHTTPSConnection(http.client.HTTPSConnection):
            def connect(self):
                http.client.HTTPConnection.connect(self)
                # Wait for our fault injection server to have done its thing.
                if not server_responding.wait(1.0) and support.verbose:
                    sys.stdout.write(""server_responding event never set."")
                self.sock = self._context.wrap_socket(
                        self.sock, server_hostname=self.host)

        def call_after_accept(conn_to_client):
            # This forces an immediate connection close via RST on .close().
            set_socket_so_linger_on_with_zero_timeout(conn_to_client)
            conn_to_client.send(
                    b""HTTP/1.0 402 Payment Required\r\n""
                    b""\r\n"")
            conn_to_client.close()  # RST
            server_responding.set()
            return True  # Tell the server to stop.

        server = self.SingleConnectionTestServerThread(
                call_after_accept=call_after_accept,
                name=""non_tls_http_RST_responder"")
        server.__enter__()  # starts it
        self.addCleanup(server.__exit__)  # ... & unittest.TestCase stops it.
        # Redundant; call_after_accept sets SO_LINGER on the accepted conn.
        set_socket_so_linger_on_with_zero_timeout(server.listener)

        connection = SynchronizedHTTPSConnection(
                f""localhost"",
                port=server.port,
                context=ssl.create_default_context(),
                timeout=2.0,
        )
        # There are lots of reasons this raises as desired, long before this
        # test was added. Sending the request requires a successful TLS wrapped
        # socket; that fails if the connection is broken. It may seem pointless
        # to test this. It serves as an illustration of something that we never
        # want to happen... properly not happening.
        with self.assertRaises(OSError) as err_ctx:
            connection.request(""HEAD"", ""/test"", headers={""Host"": ""localhost""})
            response = connection.getresponse()

",,b4bcc06a9cfe13d96d5270809d963f8ba278f89b,CVE-2023-40217,b4bcc06a9cfe13d96d5270809d963f8ba278f89b,https://github.com/python/cpython,CPE_GIT_REPOBASED,154,COMPLETED,"VAR VAR VAR VAR VAR VAR.VAR VAR VAR(VAR): VAR.VAR(VAR.VAR, VAR.VAR, VAR.VAR('VAR', 1, 0)) VAR VAR(VAR.VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR(VAR.VAR): VAR VAR(VAR, *, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR''  VAR.VAR = VAR  VAR.VAR = VAR  VAR.VAR = VAR  VAR().VAR(VAR=VAR) VAR VAR(VAR): VAR.VAR() VAR VAR VAR VAR(VAR, *VAR): VAR: VAR VAR.VAR: VAR.VAR.VAR() VAR VAR: VAR VAR.VAR() VAR.VAR = VAR  VAR VAR(VAR): VAR.VAR = VAR.VAR(VAR.VAR.VAR) VAR.VAR.VAR = VAR.VAR VAR.VAR.VAR(VAR=VAR) VAR.VAR.VAR(VAR=VAR, VAR=VAR) VAR.VAR = VAR.VAR() VAR.VAR = VAR.VAR(VAR.VAR) VAR.VAR.VAR(2.0) VAR.VAR.VAR(1) VAR().VAR() VAR VAR(VAR): VAR, VAR = VAR.VAR.VAR() VAR.VAR.VAR() VAR VAR: VAR VAR.VAR(VAR): VAR VAR: VAR = VAR.VAR.VAR(VAR, VAR=VAR) VAR VAR VAR VAR:  VAR.VAR = VAR VAR: VAR: VAR.VAR = VAR.VAR(400) VAR VAR: VAR  VAR VAR(VAR, VAR): VAR VAR.VAR == ""VAR"": VAR  VAR (VAR(VAR, VAR) VAR (VAR(VAR, VAR) VAR VAR.VAR == VAR.VAR) VAR VAR.VAR('VAR.VAR.VAR', VAR(VAR, ""VAR"", """"), VAR.VAR)):         VAR.VAR(VAR""VAR VAR VAR VAR VAR {VAR.VAR}:"" VAR"" {VAR=}"")    VAR VAR(VAR): VAR = VAR.VAR() VAR = VAR.VAR() VAR VAR(VAR): VAR.VAR() VAR VAR VAR.VAR(2.0): VAR VAR(""VAR VAR VAR VAR, VAR VAR VAR."") VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR()  VAR.VAR(VAR.VAR)  VAR VAR.VAR() VAR VAR: VAR.VAR(VAR.VAR.VAR())  VAR(VAR) VAR.VAR(VAR) VAR.VAR() VAR.VAR(VAR""VAR /VAR VAR/1.0\VAR\VAR\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR.VAR() VAR = VAR.VAR VAR.VAR(VAR"""", VAR.VAR) VAR.VAR(VAR, VAR)  VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR[1]) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR) VAR.VAR(0, VAR.VAR[0]) VAR.VAR(VAR.VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR):  VAR(VAR) VAR.VAR( VAR""VAR/1.0 307 VAR VAR\VAR\VAR"" VAR""VAR: VAR: VAR""\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR()  VAR.VAR(VAR.VAR)   VAR(VAR.VAR) VAR VAR.VAR() VAR VAR: VAR.VAR(VAR.VAR.VAR()) VAR VAR VAR.VAR(2.0): VAR.VAR(""VAR VAR VAR VAR VAR."") VAR = VAR.VAR() VAR: VAR = VAR.VAR( VAR, VAR=""VAR"") VAR VAR VAR VAR:  VAR = VAR VAR = VAR"""" VAR: VAR = VAR VAR = VAR.VAR(400) VAR.VAR() VAR.VAR() VAR.VAR(VAR"""", VAR) VAR.VAR(VAR, VAR)  VAR.VAR(VAR) VAR.VAR(VAR, VAR.VAR) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR[1]) VAR.VAR(""VAR VAR VAR VAR VAR"", VAR.VAR) VAR.VAR(0, VAR.VAR[0]) VAR.VAR(VAR.VAR, VAR=""VAR VAR VAR"") VAR VAR(VAR): VAR = VAR.VAR() VAR VAR(VAR.VAR.VAR): VAR VAR(VAR): VAR.VAR.VAR.VAR(VAR)  VAR VAR VAR.VAR(1.0) VAR VAR.VAR: VAR.VAR.VAR(""VAR VAR VAR VAR."") VAR.VAR = VAR.VAR.VAR( VAR.VAR, VAR=VAR.VAR) VAR VAR(VAR):  VAR(VAR) VAR.VAR( VAR""VAR/1.0 402 VAR VAR\VAR\VAR"" VAR""\VAR\VAR"") VAR.VAR()  VAR.VAR() VAR VAR  VAR = VAR.VAR( VAR=VAR, VAR=""VAR"") VAR.VAR()  VAR.VAR(VAR.VAR)   VAR(VAR.VAR) VAR = VAR( VAR""VAR"", VAR=VAR.VAR, VAR=VAR.VAR(), VAR=2.0, )      VAR VAR.VAR(VAR) VAR VAR: VAR.VAR(""VAR"", ""/VAR"", VAR={""VAR"": ""VAR""}) VAR = VAR.VAR() ",0,16
discourse_2da0001965c6d8632d723c46ea5df9f22a1a23f1,limiddleware/discourse_public_exceptions.rb,"            return [400, { ""Cache-Control"" => ""private, max-age=0, must-revalidate"" }, [""Invalid MIME type""]]","            return [400, {}, [""Invalid MIME type""]]",2da0001965c6d8632d723c46ea5df9f22a1a23f1,CVE-2021-43794,2da0001965c6d8632d723c46ea5df9f22a1a23f1,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR [400, { ""VAR-VAR"" => ""VAR, VAR-VAR=0, VAR-VAR"" }, [""VAR VAR VAR""]] VAR [400, {}, [""VAR VAR VAR""]]",0,16
discourse_2da0001965c6d8632d723c46ea5df9f22a1a23f1,limiddleware/discourse_public_exceptions.rb,"            return [400, { ""Cache-Control"" => ""private, max-age=0, must-revalidate"" }, [""Invalid MIME type""]]","            return [400, {}, [""Invalid MIME type""]]",2da0001965c6d8632d723c46ea5df9f22a1a23f1,CVE-2021-41271,2da0001965c6d8632d723c46ea5df9f22a1a23f1,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR [400, { ""VAR-VAR"" => ""VAR, VAR-VAR=0, VAR-VAR"" }, [""VAR VAR VAR""]] VAR [400, {}, [""VAR VAR VAR""]]",0,16
discourse_6d92c3cbdac431db99a450f360a3048bb3aaf458,limobile_detection.rb,"  USER_AGENT_MAX_LENGTH = 400

    user_agent[0...USER_AGENT_MAX_LENGTH].match?(MODERN_MOBILE_REGEX)",    user_agent.match?(MODERN_MOBILE_REGEX),6d92c3cbdac431db99a450f360a3048bb3aaf458,CVE-2023-23621,6d92c3cbdac431db99a450f360a3048bb3aaf458,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,VAR = 400 VAR[0...VAR].VAR?(VAR) VAR.VAR?(VAR),0,16
discourse_bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,spec/requests/examples/invalid_limit_params.rb,"# frozen_string_literal: true

RSpec.shared_examples ""invalid limit params"" do |endpoint, max_limit, extra_params|
  let(:params) { extra_params&.dig(:params) || {} }

  it ""returns 400 response code when limit params is negative"" do
    get endpoint, params: { limit: -1 }.merge(params)

    expect(response.status).to eq(400)
  end

  it ""returns 400 response code when limit params is suspicious"" do
    get endpoint, params: { limit: ""1; DROP TABLE users"" }.merge(params)

    expect(response.status).to eq(400)
  end

  it ""returns 400 response code when limit params exceeds the max limit"" do
    get endpoint, params: { limit: max_limit + 1 }.merge(params)

    expect(response.status).to eq(400)
  end
end",,bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,CVE-2023-38684,bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED," VAR.VAR ""VAR VAR VAR"" VAR |VAR, VAR, VAR| VAR(:VAR) { VAR&.VAR(:VAR) || {} } VAR ""VAR 400 VAR VAR VAR VAR VAR VAR VAR"" VAR VAR VAR, VAR: { VAR: -1 }.VAR(VAR) VAR(VAR.VAR).VAR VAR(400) VAR VAR ""VAR 400 VAR VAR VAR VAR VAR VAR VAR"" VAR VAR VAR, VAR: { VAR: ""1; VAR VAR VAR"" }.VAR(VAR) VAR(VAR.VAR).VAR VAR(400) VAR VAR ""VAR 400 VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR VAR, VAR: { VAR: VAR + 1 }.VAR(VAR) VAR(VAR.VAR).VAR VAR(400) VAR VAR ",0,16
discourse_bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,spec/requests/tags_controller_spec.rb,"      describe ""when limit params is invalid"" do
        include_examples ""invalid limit params"",
                         ""/tags/filter/search.json"",
                         SiteSetting.max_tag_search_results","      it ""returns error 400 for negative limit"" do
        get ""/tags/filter/search.json"", params: { q: """", limit: -1 }

        expect(response.status).to eq(400)
        expect(response.parsed_body[""errors""].first).to eq(
          I18n.t(""invalid_params"", message: ""limit""),
        )
      end

      it ""returns error 400 for suspicious limit"" do
        get ""/tags/filter/search.json"", params: { q: """", limit: ""1; SELECT 1"" }

        expect(response.status).to eq(400)
        expect(response.parsed_body[""errors""].first).to eq(
          I18n.t(""invalid_params"", message: ""limit""),
        )",bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,CVE-2023-38684,bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ""VAR VAR VAR VAR VAR"" VAR VAR ""VAR VAR VAR"", ""/VAR/VAR/VAR.VAR"", VAR.VAR VAR ""VAR VAR 400 VAR VAR VAR"" VAR VAR ""/VAR/VAR/VAR.VAR"", VAR: { VAR: """", VAR: -1 } VAR(VAR.VAR).VAR VAR(400) VAR(VAR.VAR[""VAR""].VAR).VAR VAR( VAR.VAR(""VAR"", VAR: ""VAR""), ) VAR VAR ""VAR VAR 400 VAR VAR VAR"" VAR VAR ""/VAR/VAR/VAR.VAR"", VAR: { VAR: """", VAR: ""1; VAR 1"" } VAR(VAR.VAR).VAR VAR(400) VAR(VAR.VAR[""VAR""].VAR).VAR VAR( VAR.VAR(""VAR"", VAR: ""VAR""), )",0,16
discourse_bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,spec/requests/users_controller_spec.rb,"  fab!(:user1) { Fabricate(:user, username: ""someusername"") }
    describe ""when limit params is invalid"" do
      include_examples ""invalid limit params"",
                       ""/u/search/users.json"",
                       described_class::SEARCH_USERS_LIMIT

    describe ""when limit params is invalid"" do
      before { sign_in(user1) }

      include_examples ""invalid limit params"",
                       ""/u/someusername/bookmarks.json"",
                       described_class::BOOKMARKS_LIMIT
    end","  fab!(:user1) { Fabricate(:user) }
    context ""with limit"" do
      it ""returns an error if value is invalid"" do
        get ""/u/search/users.json"", params: { limit: ""-1"" }
        expect(response.status).to eq(400)
      end",bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,CVE-2023-38684,bfc3132bb22bd5b7e86f428746b89c4d3d7f5a70,https://github.com/discourse/discourse,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR!(:VAR) { VAR(:VAR, VAR: ""VAR"") } VAR ""VAR VAR VAR VAR VAR"" VAR VAR ""VAR VAR VAR"", ""/VAR/VAR/VAR.VAR"", VAR::VAR VAR ""VAR VAR VAR VAR VAR"" VAR VAR { VAR(VAR) } VAR ""VAR VAR VAR"", ""/VAR/VAR/VAR.VAR"", VAR::VAR VAR VAR!(:VAR) { VAR(:VAR) } VAR ""VAR VAR"" VAR VAR ""VAR VAR VAR VAR VAR VAR VAR"" VAR VAR ""/VAR/VAR/VAR.VAR"", VAR: { VAR: ""-1"" } VAR(VAR.VAR).VAR VAR(400) VAR",0,16
envoy_5333b928d8bcffa26ab19bf018369a835f697585,test/integration/protocol_integration_test.cc,"TEST_P(DownstreamProtocolIntegrationTest, HeaderNormalizationRejection) {
  config_helper_.addConfigModifier(
      [](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
             hcm) -> void {
        hcm.set_path_with_escaped_slashes_action(
            envoy::extensions::filters::network::http_connection_manager::v3::
                HttpConnectionManager::REJECT_REQUEST);
      });

  initialize();
  codec_client_ = makeHttpConnection(lookupPort(""http""));
  default_request_headers_.setPath(""/test/long%2Furl"");
  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);

  EXPECT_TRUE(response->waitForEndStream());
  EXPECT_TRUE(response->complete());
  EXPECT_EQ(""400"", response->headers().getStatusValue());
}
",,5333b928d8bcffa26ab19bf018369a835f697585,CVE-2021-29492,5333b928d8bcffa26ab19bf018369a835f697585,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,162,COMPLETED,"VAR(VAR, VAR) { VAR.VAR( [](VAR::VAR::VAR::VAR::VAR::VAR::VAR& VAR) -> VAR { VAR.VAR( VAR::VAR::VAR::VAR::VAR::VAR:: VAR::VAR); }); VAR(); VAR = VAR(VAR(""VAR"")); VAR.VAR(""/VAR/VAR%2Furl""); VAR VAR = VAR->VAR(VAR); VAR(VAR->VAR()); VAR(VAR->VAR()); VAR(""400"", VAR->VAR().VAR()); } ",0,16
envoy_60bb7d662b26a4e25391c34a6f2c62f722a70196,test/extensions/filters/http/lua/lua_integration_test.cc,"  void initializeFilter(const std::string& filter_config, const std::string& domain = ""*"") {
        [domain](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager&
                     hcm) {
          hcm.mutable_route_config()->mutable_virtual_hosts(0)->set_domains(0, domain);
// Regression test for pulling route info during early local replies using the Lua filter
// metadata() API. Covers both the upgrade required and no authority cases.
TEST_P(LuaIntegrationTest, CallMetadataDuringLocalReply) {
  const std::string FILTER_AND_CODE =
      R""EOF(
name: envoy.lua
typed_config:
  ""@type"": type.googleapis.com/envoy.config.filter.http.lua.v2.Lua
  inline_code: |
    function envoy_on_response(response_handle)
      local metadata = response_handle:metadata():get(""foo.bar"")
      if metadata == nil then
      end
    end
)EOF"";

  initializeFilter(FILTER_AND_CODE, ""foo"");
  std::string response;
  sendRawHttpAndWaitForResponse(lookupPort(""http""), ""GET / HTTP/1.0\r\n\r\n"", &response, true);
  EXPECT_TRUE(response.find(""HTTP/1.1 426 Upgrade Required\r\n"") == 0);

  response = """";
  sendRawHttpAndWaitForResponse(lookupPort(""http""), ""GET / HTTP/1.1\r\n\r\n"", &response, true);
  EXPECT_TRUE(response.find(""HTTP/1.1 400 Bad Request\r\n"") == 0);
}
","  void initializeFilter(const std::string& filter_config) {
        [](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager&
               hcm) {",60bb7d662b26a4e25391c34a6f2c62f722a70196,CVE-2019-18838,60bb7d662b26a4e25391c34a6f2c62f722a70196,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,92,COMPLETED,"VAR VAR(VAR VAR::VAR& VAR, VAR VAR::VAR& VAR = ""*"") { [VAR](VAR::VAR::VAR::VAR::VAR::VAR::VAR& VAR) { VAR.VAR()->VAR(0)->VAR(0, VAR);   VAR(VAR, VAR) { VAR VAR::VAR VAR = VAR""VAR( VAR: VAR.VAR VAR: ""@VAR"": VAR.VAR.VAR/VAR.VAR.VAR.VAR.VAR.VAR.VAR VAR: | VAR VAR(VAR) VAR VAR = VAR:VAR():VAR(""VAR.VAR"") VAR VAR == VAR VAR VAR VAR )VAR""; VAR(VAR, ""VAR""); VAR::VAR VAR; VAR(VAR(""VAR""), ""VAR / VAR/1.0\VAR\VAR\VAR\VAR"", &VAR, VAR); VAR(VAR.VAR(""VAR/1.1 426 VAR VAR\VAR\VAR"") == 0); VAR = """"; VAR(VAR(""VAR""), ""VAR / VAR/1.1\VAR\VAR\VAR\VAR"", &VAR, VAR); VAR(VAR.VAR(""VAR/1.1 400 VAR VAR\VAR\VAR"") == 0); } VAR VAR(VAR VAR::VAR& VAR) { [](VAR::VAR::VAR::VAR::VAR::VAR::VAR& VAR) {",0,16
envoy_6a6ac1ccf928aa9866f19e2cf151c5dd339bb8e6,test/integration/protocol_integration_test.cc,"// Make sure that invalid authority headers get blocked at or before the HCM.
TEST_P(DownstreamProtocolIntegrationTest, InvalidAuth) {
  initialize();
  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);

  codec_client_ = makeHttpConnection(lookupPort(""http""));

  Http::TestHeaderMapImpl request_headers{{"":method"", ""POST""},
                                          {"":path"", ""/test/long/url""},
                                          {"":scheme"", ""http""},
                                          {"":authority"", ""ho|st|""}};

  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);
  if (downstreamProtocol() == Http::CodecClient::Type::HTTP1) {
    // For HTTP/1 this is handled by the HCM, which sends a full 400 response.
    response->waitForEndStream();
    ASSERT_TRUE(response->complete());
    EXPECT_EQ(""400"", response->headers().Status()->value().getStringView());
  } else {
    // For HTTP/2 this is handled by nghttp2 which resets the connection without
    // sending an HTTP response.
    codec_client_->waitForDisconnect();
    ASSERT_FALSE(response->complete());
  }
}
",,6a6ac1ccf928aa9866f19e2cf151c5dd339bb8e6,CVE-2019-18802,6a6ac1ccf928aa9866f19e2cf151c5dd339bb8e6,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED," VAR(VAR, VAR) { VAR(); VAR[0]->VAR(VAR); VAR = VAR(VAR(""VAR"")); VAR::VAR VAR{{"":VAR"", ""VAR""}, {"":VAR"", ""/VAR/VAR/VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR|VAR|""}}; VAR VAR = VAR->VAR(VAR); VAR (VAR() == VAR::VAR::VAR::VAR) {  VAR->VAR(); VAR(VAR->VAR()); VAR(""400"", VAR->VAR().VAR()->VAR().VAR()); } VAR {   VAR->VAR(); VAR(VAR->VAR()); } } ",0,16
envoy_6a95a21ce49d1144d3cde7159c767c192a44d8a4,test/integration/protocol_integration_test.cc,"// Make sure that invalid authority headers get blocked at or before the HCM.
TEST_P(DownstreamProtocolIntegrationTest, InvalidAuth) {
  initialize();
  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);

  codec_client_ = makeHttpConnection(lookupPort(""http""));

  Http::TestHeaderMapImpl request_headers{{"":method"", ""POST""},
                                          {"":path"", ""/test/long/url""},
                                          {"":scheme"", ""http""},
                                          {"":authority"", ""ho|st|""}};

  auto response = codec_client_->makeHeaderOnlyRequest(request_headers);
  if (downstreamProtocol() == Http::CodecClient::Type::HTTP1) {
    // For HTTP/1 this is handled by the HCM, which sends a full 400 response.
    response->waitForEndStream();
    ASSERT_TRUE(response->complete());
    EXPECT_EQ(""400"", response->headers().Status()->value().getStringView());
  } else {
    // For HTTP/2 this is handled by nghttp2 which resets the connection without
    // sending an HTTP response.
    codec_client_->waitForDisconnect();
    ASSERT_FALSE(response->complete());
  }
}
",,6a95a21ce49d1144d3cde7159c767c192a44d8a4,CVE-2019-18802,6a95a21ce49d1144d3cde7159c767c192a44d8a4,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED," VAR(VAR, VAR) { VAR(); VAR[0]->VAR(VAR); VAR = VAR(VAR(""VAR"")); VAR::VAR VAR{{"":VAR"", ""VAR""}, {"":VAR"", ""/VAR/VAR/VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR|VAR|""}}; VAR VAR = VAR->VAR(VAR); VAR (VAR() == VAR::VAR::VAR::VAR) {  VAR->VAR(); VAR(VAR->VAR()); VAR(""400"", VAR->VAR().VAR()->VAR().VAR()); } VAR {   VAR->VAR(); VAR(VAR->VAR()); } } ",0,16
envoy_b3f42a4ebbd51e816cfde63ee672ce31e420602a,test/integration/protocol_integration_test.cc,"// Regression tests for CVE-2019-18801. We only validate the behavior of large
// :method request headers, since the case of other large headers is
// covered in the various testLargeRequest-based integration tests here.
//
// The table below describes the expected behaviors (in addition we should never
// see an ASSERT or ASAN failure trigger).
//
// Downstream    Upstream   Behavior expected
// ------------------------------------------
// H1            H1         Envoy will reject (HTTP/1 codec behavior)
// H1            H2         Envoy will reject (HTTP/1 codec behavior)
// H2            H1         Envoy will forward but backend will reject (HTTP/1
//                          codec behavior)
// H2            H2         Success
TEST_P(ProtocolIntegrationTest, LargeRequestMethod) {
  const std::string long_method = std::string(48 * 1024, 'a');
  const Http::TestHeaderMapImpl request_headers{{"":method"", long_method},
                                                {"":path"", ""/test/long/url""},
                                                {"":scheme"", ""http""},
                                                {"":authority"", ""host""}};

  initialize();
  codec_client_ = makeHttpConnection(lookupPort(""http""));

  if (downstreamProtocol() == Http::CodecClient::Type::HTTP1) {
    auto encoder_decoder = codec_client_->startRequest(request_headers);
    request_encoder_ = &encoder_decoder.first;
    auto response = std::move(encoder_decoder.second);
    codec_client_->waitForDisconnect();
    EXPECT_TRUE(response->complete());
    EXPECT_EQ(""400"", response->headers().Status()->value().getStringView());
  } else {
    ASSERT(downstreamProtocol() == Http::CodecClient::Type::HTTP2);
    if (upstreamProtocol() == FakeHttpConnection::Type::HTTP1) {
      auto response = codec_client_->makeHeaderOnlyRequest(request_headers);
      ASSERT_TRUE(
          fake_upstreams_[0]->waitForHttpConnection(*dispatcher_, fake_upstream_connection_));
      response->waitForEndStream();
      EXPECT_TRUE(response->complete());
      EXPECT_EQ(""400"", response->headers().Status()->value().getStringView());
    } else {
      ASSERT(upstreamProtocol() == FakeHttpConnection::Type::HTTP2);
      auto response =
          sendRequestAndWaitForResponse(request_headers, 0, default_response_headers_, 0);
      EXPECT_TRUE(response->complete());
    }
  }
}
",,b3f42a4ebbd51e816cfde63ee672ce31e420602a,CVE-2019-18801,b3f42a4ebbd51e816cfde63ee672ce31e420602a,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,80,COMPLETED,"              VAR(VAR, VAR) { VAR VAR::VAR VAR = VAR::VAR(48 * 1024, 'VAR'); VAR VAR::VAR VAR{{"":VAR"", VAR}, {"":VAR"", ""/VAR/VAR/VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR""}}; VAR(); VAR = VAR(VAR(""VAR"")); VAR (VAR() == VAR::VAR::VAR::VAR) { VAR VAR = VAR->VAR(VAR); VAR = &VAR.VAR; VAR VAR = VAR::VAR(VAR.VAR); VAR->VAR(); VAR(VAR->VAR()); VAR(""400"", VAR->VAR().VAR()->VAR().VAR()); } VAR { VAR(VAR() == VAR::VAR::VAR::VAR); VAR (VAR() == VAR::VAR::VAR) { VAR VAR = VAR->VAR(VAR); VAR( VAR[0]->VAR(*VAR, VAR)); VAR->VAR(); VAR(VAR->VAR()); VAR(""400"", VAR->VAR().VAR()->VAR().VAR()); } VAR { VAR(VAR() == VAR::VAR::VAR); VAR VAR = VAR(VAR, 0, VAR, 0); VAR(VAR->VAR()); } } } ",0,16
go_1e43cfa15b4b618812e85c00c9e92c2615b324c8,src/net/textproto/reader.go,"	return readMIMEHeader(r, math.MaxInt64, math.MaxInt64)
func readMIMEHeader(r *Reader, maxMemory, maxHeaders int64) (MIMEHeader, error) {
	maxMemory -= 400
		maxHeaders--
		if maxHeaders < 0 {
			return nil, errors.New(""message too large"")
		}

			maxMemory -= int64(len(key))
			maxMemory -= mapEntryOverhead
		maxMemory -= int64(len(value))
		if maxMemory < 0 {","	return readMIMEHeader(r, math.MaxInt64)
func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
	lim -= 400
			lim -= int64(len(key))
			lim -= mapEntryOverhead
		lim -= int64(len(value))
		if lim < 0 {",1e43cfa15b4b618812e85c00c9e92c2615b324c8,CVE-2023-24536,1e43cfa15b4b618812e85c00c9e92c2615b324c8,https://github.com/golang/go,CPE_GIT_REPOBASED,134,COMPLETED,"VAR VAR(VAR, VAR.VAR, VAR.VAR) VAR VAR(VAR *VAR, VAR, VAR VAR) (VAR, VAR) { VAR -= 400 VAR-- VAR VAR < 0 { VAR VAR, VAR.VAR(""VAR VAR VAR"") } VAR -= VAR(VAR(VAR)) VAR -= VAR VAR -= VAR(VAR(VAR)) VAR VAR < 0 { VAR VAR(VAR, VAR.VAR) VAR VAR(VAR *VAR, VAR VAR) (VAR, VAR) { VAR -= 400 VAR -= VAR(VAR(VAR)) VAR -= VAR VAR -= VAR(VAR(VAR)) VAR VAR < 0 {",0,16
go_3c010f2c2182a12f28ad86c5e1ff984f1f2d880a,src/net/textproto/reader.go,"	// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.
	// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large
	// MIMEHeaders average about 200 bytes per entry.
	lim -= 400
	const mapEntryOverhead = 200

			lim -= mapEntryOverhead",			lim -= 100 // map entry overhead,3c010f2c2182a12f28ad86c5e1ff984f1f2d880a,CVE-2023-24536,3c010f2c2182a12f28ad86c5e1ff984f1f2d880a,https://github.com/golang/go,CPE_GIT_REPOBASED,122,COMPLETED,   VAR -= 400 VAR VAR = 200 VAR -= VAR VAR -= 100 ,8,16
go_6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8,src/net/http/serve_test.go,"		// Spaces between the header key and colon are not allowed.
		// See RFC 7230, Section 3.2.4.
		{""Foo : bar\r\n"", 400},
		{""Foo\t: bar\r\n"", 400},",,6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8,CVE-2019-16276,6e6f4aaf70c8b1cc81e65a26332aa9409de03ad8,https://github.com/golang/go,NVD_GIT_REPOBASED,160,COMPLETED,"  {""VAR : VAR\VAR\VAR"", 400}, {""VAR\VAR: VAR\VAR\VAR"", 400}, ",0,16
go_7917b5f31204528ea72e0629f0b7d52b35b27538,src/net/textproto/reader.go,"	return readMIMEHeader(r, math.MaxInt64, math.MaxInt64)
func readMIMEHeader(r *Reader, maxMemory, maxHeaders int64) (MIMEHeader, error) {
	maxMemory -= 400
		maxHeaders--
		if maxHeaders < 0 {
			return nil, errors.New(""message too large"")
		}

			maxMemory -= int64(len(key))
			maxMemory -= mapEntryOverhead
		maxMemory -= int64(len(value))
		if maxMemory < 0 {","	return readMIMEHeader(r, math.MaxInt64)
func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
	lim -= 400
			lim -= int64(len(key))
			lim -= mapEntryOverhead
		lim -= int64(len(value))
		if lim < 0 {",7917b5f31204528ea72e0629f0b7d52b35b27538,CVE-2023-24536,7917b5f31204528ea72e0629f0b7d52b35b27538,https://github.com/golang/go,CPE_GIT_REPOBASED,166,COMPLETED,"VAR VAR(VAR, VAR.VAR, VAR.VAR) VAR VAR(VAR *VAR, VAR, VAR VAR) (VAR, VAR) { VAR -= 400 VAR-- VAR VAR < 0 { VAR VAR, VAR.VAR(""VAR VAR VAR"") } VAR -= VAR(VAR(VAR)) VAR -= VAR VAR -= VAR(VAR(VAR)) VAR VAR < 0 { VAR VAR(VAR, VAR.VAR) VAR VAR(VAR *VAR, VAR VAR) (VAR, VAR) { VAR -= 400 VAR -= VAR(VAR(VAR)) VAR -= VAR VAR -= VAR(VAR(VAR)) VAR VAR < 0 {",0,16
go_7a359a651c7ebdb29e0a1c03102fce793e9f58f0,src/net/textproto/reader.go,"	// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.
	// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large
	// MIMEHeaders average about 200 bytes per entry.
	lim -= 400
	const mapEntryOverhead = 200

			lim -= mapEntryOverhead",			lim -= 100 // map entry overhead,7a359a651c7ebdb29e0a1c03102fce793e9f58f0,CVE-2023-24536,7a359a651c7ebdb29e0a1c03102fce793e9f58f0,https://github.com/golang/go,CPE_GIT_REPOBASED,154,COMPLETED,   VAR -= 400 VAR VAR = 200 VAR -= VAR VAR -= 100 ,8,16
go_bf8c7c575c8a552d9d79deb29e80854dc88528d0,src/net/textproto/reader.go,"	return readMIMEHeader(r, math.MaxInt64, math.MaxInt64)
func readMIMEHeader(r *Reader, maxMemory, maxHeaders int64) (MIMEHeader, error) {
	maxMemory -= 400
		maxHeaders--
		if maxHeaders < 0 {
			return nil, errors.New(""message too large"")
		}

			maxMemory -= int64(len(key))
			maxMemory -= mapEntryOverhead
		maxMemory -= int64(len(value))
		if maxMemory < 0 {","	return readMIMEHeader(r, math.MaxInt64)
func readMIMEHeader(r *Reader, lim int64) (MIMEHeader, error) {
	lim -= 400
			lim -= int64(len(key))
			lim -= mapEntryOverhead
		lim -= int64(len(value))
		if lim < 0 {",bf8c7c575c8a552d9d79deb29e80854dc88528d0,CVE-2023-24536,bf8c7c575c8a552d9d79deb29e80854dc88528d0,https://github.com/golang/go,CPE_GIT_REPOBASED,230,COMPLETED,"VAR VAR(VAR, VAR.VAR, VAR.VAR) VAR VAR(VAR *VAR, VAR, VAR VAR) (VAR, VAR) { VAR -= 400 VAR-- VAR VAR < 0 { VAR VAR, VAR.VAR(""VAR VAR VAR"") } VAR -= VAR(VAR(VAR)) VAR -= VAR VAR -= VAR(VAR(VAR)) VAR VAR < 0 { VAR VAR(VAR, VAR.VAR) VAR VAR(VAR *VAR, VAR VAR) (VAR, VAR) { VAR -= 400 VAR -= VAR(VAR(VAR)) VAR -= VAR VAR -= VAR(VAR(VAR)) VAR VAR < 0 {",0,16
go_ec18f62df59d8f857e63ed3d7480754c49b072c3,src/net/textproto/reader.go,"	// Account for 400 bytes of overhead for the MIMEHeader, plus 200 bytes per entry.
	// Benchmarking map creation as of go1.20, a one-entry MIMEHeader is 416 bytes and large
	// MIMEHeaders average about 200 bytes per entry.
	lim -= 400
	const mapEntryOverhead = 200

			lim -= mapEntryOverhead",			lim -= 100 // map entry overhead,ec18f62df59d8f857e63ed3d7480754c49b072c3,CVE-2023-24536,ec18f62df59d8f857e63ed3d7480754c49b072c3,https://github.com/golang/go,CPE_GIT_REPOBASED,158,COMPLETED,   VAR -= 400 VAR VAR = 200 VAR -= VAR VAR -= 100 ,8,16
parse-server_5fad2928fb8ee17304abcdcf259932f827d8c81f,spec/vulnerabilities.spec.js,"    it('denies creating global config with polluted data', async () => {
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-Master-Key': 'test',
      };
      const params = {
        method: 'PUT',
        url: 'http://localhost:8378/1/config',
        json: true,
        body: {
          params: {
            welcomeMesssage: 'Welcome to Parse',
            foo: { _bsontype: 'Code', code: 'shell' },
          },
        },
        headers,
      };
      const response = await request(params).catch(e => e);
      expect(response.status).toBe(400);
      const text = JSON.parse(response.text);
      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);
      expect(text.error).toBe(
        'Prohibited keyword in request data: {""key"":""_bsontype"",""value"":""Code""}.'
      );
    });

    it('denies direct database write wih prohibited keys', async () => {
      const Config = require('../lib/Config');
      const config = Config.get(Parse.applicationId);
      const user = {
        objectId: '1234567890',
        username: 'hello',
        password: 'pass',
        _session_token: 'abc',
        foo: { _bsontype: 'Code', code: 'shell' },
      };
      await expectAsync(config.database.create('_User', user)).toBeRejectedWith(
        new Parse.Error(
          Parse.Error.INVALID_KEY_NAME,
          'Prohibited keyword in request data: {""key"":""_bsontype"",""value"":""Code""}.'
        )
      );
    });

    it('denies direct database update wih prohibited keys', async () => {
      const Config = require('../lib/Config');
      const config = Config.get(Parse.applicationId);
      const user = {
        objectId: '1234567890',
        username: 'hello',
        password: 'pass',
        _session_token: 'abc',
        foo: { _bsontype: 'Code', code: 'shell' },
      };
      await expectAsync(
        config.database.update('_User', { _id: user.objectId }, user)
      ).toBeRejectedWith(
        new Parse.Error(
          Parse.Error.INVALID_KEY_NAME,
          'Prohibited keyword in request data: {""key"":""_bsontype"",""value"":""Code""}.'
        )
      );
    });
",,5fad2928fb8ee17304abcdcf259932f827d8c81f,CVE-2023-36475,5fad2928fb8ee17304abcdcf259932f827d8c81f,https://github.com/parse-community/parse-server,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR('VAR VAR VAR VAR VAR VAR VAR', VAR () => { VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = { VAR: 'VAR', VAR: 'VAR: VAR: VAR, VAR: { VAR: { VAR: 'VAR VAR VAR', VAR: { VAR: 'VAR', VAR: 'VAR' }, }, }, VAR, }; VAR VAR = VAR VAR(VAR).VAR(VAR => VAR); VAR(VAR.VAR).VAR(400); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(VAR.VAR.VAR); VAR(VAR.VAR).VAR( 'VAR VAR VAR VAR VAR: {""VAR"":""VAR"",""VAR"":""VAR""}.' ); }); VAR('VAR VAR VAR VAR VAR VAR VAR', VAR () => { VAR VAR = VAR('../VAR/VAR'); VAR VAR = VAR.VAR(VAR.VAR); VAR VAR = { VAR: '1234567890', VAR: 'VAR', VAR: 'VAR', VAR: 'VAR', VAR: { VAR: 'VAR', VAR: 'VAR' }, }; VAR VAR(VAR.VAR.VAR('VAR', VAR)).VAR( VAR VAR.VAR( VAR.VAR.VAR, 'VAR VAR VAR VAR VAR: {""VAR"":""VAR"",""VAR"":""VAR""}.' ) ); }); VAR('VAR VAR VAR VAR VAR VAR VAR', VAR () => { VAR VAR = VAR('../VAR/VAR'); VAR VAR = VAR.VAR(VAR.VAR); VAR VAR = { VAR: '1234567890', VAR: 'VAR', VAR: 'VAR', VAR: 'VAR', VAR: { VAR: 'VAR', VAR: 'VAR' }, }; VAR VAR( VAR.VAR.VAR('VAR', { VAR: VAR.VAR }, VAR) ).VAR( VAR VAR.VAR( VAR.VAR.VAR, 'VAR VAR VAR VAR VAR: {""VAR"":""VAR"",""VAR"":""VAR""}.' ) ); }); ",0,16
parse-server_886bfd7cac69496e3f73d4bb536f0eec3cba0e4d,spec/vulnerabilities.spec.js,"const request = require('../lib/request');

describe('Vulnerabilities', () => {
  describe('Object prototype pollution', () => {
    it('denies object prototype to be polluted with keyword ""constructor""', async () => {
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-REST-API-Key': 'rest',
      };
      const response = await request({
        headers: headers,
        method: 'POST',
        url: 'http://localhost:8378/1/classes/PP',
        body: JSON.stringify({
          obj: {
            constructor: {
              prototype: {
                dummy: 0,
              },
            },
          },
        }),
      }).catch(e => e);
      expect(response.status).toBe(400);
      const text = JSON.parse(response.text);
      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);
      expect(text.error).toBe('Prohibited keyword in request data: {""key"":""constructor""}.');
      expect(Object.prototype.dummy).toBeUndefined();
    });

    it('denies object prototype to be polluted with keypath string ""constructor""', async () => {
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-REST-API-Key': 'rest',
      };
      const objResponse = await request({
        headers: headers,
        method: 'POST',
        url: 'http://localhost:8378/1/classes/PP',
        body: JSON.stringify({
          obj: {},
        }),
      }).catch(e => e);
      const pollResponse = await request({
        headers: headers,
        method: 'PUT',
        url: `http://localhost:8378/1/classes/PP/${objResponse.data.objectId}`,
        body: JSON.stringify({
          'obj.constructor.prototype.dummy': {
            __op: 'Increment',
            amount: 1,
          },
        }),
      }).catch(e => e);
      expect(Object.prototype.dummy).toBeUndefined();
      expect(pollResponse.status).toBe(400);
      const text = JSON.parse(pollResponse.text);
      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);
      expect(text.error).toBe('Prohibited keyword in request data: {""key"":""constructor""}.');
      expect(Object.prototype.dummy).toBeUndefined();
    });

    it('denies object prototype to be polluted with keyword ""__proto__""', async () => {
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-REST-API-Key': 'rest',
      };
      const response = await request({
        headers: headers,
        method: 'POST',
        url: 'http://localhost:8378/1/classes/PP',
        body: JSON.stringify({ 'obj.__proto__.dummy': 0 }),
      }).catch(e => e);
      expect(response.status).toBe(400);
      const text = JSON.parse(response.text);
      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);
      expect(text.error).toBe('Prohibited keyword in request data: {""key"":""__proto__""}.');
      expect(Object.prototype.dummy).toBeUndefined();
    });
  });

  describe('Request denylist', () => {
    it('denies BSON type code data in write request by default', async () => {
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-REST-API-Key': 'rest',
      };
      const params = {
        headers: headers,
        method: 'POST',
        url: 'http://localhost:8378/1/classes/RCE',
        body: JSON.stringify({
          obj: {
            _bsontype: 'Code',
            code: 'delete Object.prototype.evalFunctions',
          },
        }),
      };
      const response = await request(params).catch(e => e);
      expect(response.status).toBe(400);
      const text = JSON.parse(response.text);
      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);
      expect(text.error).toBe(
        'Prohibited keyword in request data: {""key"":""_bsontype"",""value"":""Code""}.'
      );
    });

    it('allows BSON type code data in write request with custom denylist', async () => {
      await reconfigureServer({
        requestKeywordDenylist: [],
      });
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-REST-API-Key': 'rest',
      };
      const params = {
        headers: headers,
        method: 'POST',
        url: 'http://localhost:8378/1/classes/RCE',
        body: JSON.stringify({
          obj: {
            _bsontype: 'Code',
            code: 'delete Object.prototype.evalFunctions',
          },
        }),
      };
      const response = await request(params).catch(e => e);
      expect(response.status).toBe(201);
      const text = JSON.parse(response.text);
      expect(text.objectId).toBeDefined();
    });

    it('denies write request with custom denylist of key/value', async () => {
      await reconfigureServer({
        requestKeywordDenylist: [{ key: 'a[K]ey', value: 'aValue[123]*' }],
      });
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-REST-API-Key': 'rest',
      };
      const params = {
        headers: headers,
        method: 'POST',
        url: 'http://localhost:8378/1/classes/RCE',
        body: JSON.stringify({
          obj: {
            aKey: 'aValue321',
            code: 'delete Object.prototype.evalFunctions',
          },
        }),
      };
      const response = await request(params).catch(e => e);
      expect(response.status).toBe(400);
      const text = JSON.parse(response.text);
      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);
      expect(text.error).toBe(
        'Prohibited keyword in request data: {""key"":""a[K]ey"",""value"":""aValue[123]*""}.'
      );
    });

    it('denies write request with custom denylist of nested key/value', async () => {
      await reconfigureServer({
        requestKeywordDenylist: [{ key: 'a[K]ey', value: 'aValue[123]*' }],
      });
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-REST-API-Key': 'rest',
      };
      const params = {
        headers: headers,
        method: 'POST',
        url: 'http://localhost:8378/1/classes/RCE',
        body: JSON.stringify({
          obj: {
            nested: {
              aKey: 'aValue321',
              code: 'delete Object.prototype.evalFunctions',
            },
          },
        }),
      };
      const response = await request(params).catch(e => e);
      expect(response.status).toBe(400);
      const text = JSON.parse(response.text);
      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);
      expect(text.error).toBe(
        'Prohibited keyword in request data: {""key"":""a[K]ey"",""value"":""aValue[123]*""}.'
      );
    });

    it('denies write request with custom denylist of key/value in array', async () => {
      await reconfigureServer({
        requestKeywordDenylist: [{ key: 'a[K]ey', value: 'aValue[123]*' }],
      });
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-REST-API-Key': 'rest',
      };
      const params = {
        headers: headers,
        method: 'POST',
        url: 'http://localhost:8378/1/classes/RCE',
        body: JSON.stringify({
          obj: [
            {
              aKey: 'aValue321',
              code: 'delete Object.prototype.evalFunctions',
            },
          ],
        }),
      };
      const response = await request(params).catch(e => e);
      expect(response.status).toBe(400);
      const text = JSON.parse(response.text);
      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);
      expect(text.error).toBe(
        'Prohibited keyword in request data: {""key"":""a[K]ey"",""value"":""aValue[123]*""}.'
      );
    });

    it('denies write request with custom denylist of key', async () => {
      await reconfigureServer({
        requestKeywordDenylist: [{ key: 'a[K]ey' }],
      });
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-REST-API-Key': 'rest',
      };
      const params = {
        headers: headers,
        method: 'POST',
        url: 'http://localhost:8378/1/classes/RCE',
        body: JSON.stringify({
          obj: {
            aKey: 'aValue321',
            code: 'delete Object.prototype.evalFunctions',
          },
        }),
      };
      const response = await request(params).catch(e => e);
      expect(response.status).toBe(400);
      const text = JSON.parse(response.text);
      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);
      expect(text.error).toBe('Prohibited keyword in request data: {""key"":""a[K]ey""}.');
    });

    it('denies write request with custom denylist of value', async () => {
      await reconfigureServer({
        requestKeywordDenylist: [{ value: 'aValue[123]*' }],
      });
      const headers = {
        'Content-Type': 'application/json',
        'X-Parse-Application-Id': 'test',
        'X-Parse-REST-API-Key': 'rest',
      };
      const params = {
        headers: headers,
        method: 'POST',
        url: 'http://localhost:8378/1/classes/RCE',
        body: JSON.stringify({
          obj: {
            aKey: 'aValue321',
            code: 'delete Object.prototype.evalFunctions',
          },
        }),
      };
      const response = await request(params).catch(e => e);
      expect(response.status).toBe(400);
      const text = JSON.parse(response.text);
      expect(text.code).toBe(Parse.Error.INVALID_KEY_NAME);
      expect(text.error).toBe('Prohibited keyword in request data: {""value"":""aValue[123]*""}.');
    });
  });
});",,886bfd7cac69496e3f73d4bb536f0eec3cba0e4d,CVE-2022-24760,886bfd7cac69496e3f73d4bb536f0eec3cba0e4d,https://github.com/parse-community/parse-server,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = VAR('../VAR/VAR'); VAR('VAR', () => { VAR('VAR VAR VAR', () => { VAR('VAR VAR VAR VAR VAR VAR VAR VAR ""VAR""', VAR () => { VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = VAR VAR({ VAR: VAR, VAR: 'VAR', VAR: 'VAR: VAR: VAR.VAR({ VAR: { VAR: { VAR: { VAR: 0, }, }, }, }), }).VAR(VAR => VAR); VAR(VAR.VAR).VAR(400); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(VAR.VAR.VAR); VAR(VAR.VAR).VAR('VAR VAR VAR VAR VAR: {""VAR"":""VAR""}.'); VAR(VAR.VAR.VAR).VAR(); }); VAR('VAR VAR VAR VAR VAR VAR VAR VAR VAR ""VAR""', VAR () => { VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = VAR VAR({ VAR: VAR, VAR: 'VAR', VAR: 'VAR: VAR: VAR.VAR({ VAR: {}, }), }).VAR(VAR => VAR); VAR VAR = VAR VAR({ VAR: VAR, VAR: 'VAR', VAR: `VAR: VAR: VAR.VAR({ 'VAR.VAR.VAR.VAR': { VAR: 'VAR', VAR: 1, }, }), }).VAR(VAR => VAR); VAR(VAR.VAR.VAR).VAR(); VAR(VAR.VAR).VAR(400); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(VAR.VAR.VAR); VAR(VAR.VAR).VAR('VAR VAR VAR VAR VAR: {""VAR"":""VAR""}.'); VAR(VAR.VAR.VAR).VAR(); }); VAR('VAR VAR VAR VAR VAR VAR VAR VAR ""VAR""', VAR () => { VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = VAR VAR({ VAR: VAR, VAR: 'VAR', VAR: 'VAR: VAR: VAR.VAR({ 'VAR.VAR.VAR': 0 }), }).VAR(VAR => VAR); VAR(VAR.VAR).VAR(400); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(VAR.VAR.VAR); VAR(VAR.VAR).VAR('VAR VAR VAR VAR VAR: {""VAR"":""VAR""}.'); VAR(VAR.VAR.VAR).VAR(); }); }); VAR('VAR VAR', () => { VAR('VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR', VAR () => { VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = { VAR: VAR, VAR: 'VAR', VAR: 'VAR: VAR: VAR.VAR({ VAR: { VAR: 'VAR', VAR: 'VAR VAR.VAR.VAR', }, }), }; VAR VAR = VAR VAR(VAR).VAR(VAR => VAR); VAR(VAR.VAR).VAR(400); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(VAR.VAR.VAR); VAR(VAR.VAR).VAR( 'VAR VAR VAR VAR VAR: {""VAR"":""VAR"",""VAR"":""VAR""}.' ); }); VAR('VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR', VAR () => { VAR VAR({ VAR: [], }); VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = { VAR: VAR, VAR: 'VAR', VAR: 'VAR: VAR: VAR.VAR({ VAR: { VAR: 'VAR', VAR: 'VAR VAR.VAR.VAR', }, }), }; VAR VAR = VAR VAR(VAR).VAR(VAR => VAR); VAR(VAR.VAR).VAR(201); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(); }); VAR('VAR VAR VAR VAR VAR VAR VAR VAR/VAR', VAR () => { VAR VAR({ VAR: [{ VAR: 'VAR[VAR]VAR', VAR: 'VAR[123]*' }], }); VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = { VAR: VAR, VAR: 'VAR', VAR: 'VAR: VAR: VAR.VAR({ VAR: { VAR: 'VAR', VAR: 'VAR VAR.VAR.VAR', }, }), }; VAR VAR = VAR VAR(VAR).VAR(VAR => VAR); VAR(VAR.VAR).VAR(400); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(VAR.VAR.VAR); VAR(VAR.VAR).VAR( 'VAR VAR VAR VAR VAR: {""VAR"":""VAR[VAR]VAR"",""VAR"":""VAR[123]*""}.' ); }); VAR('VAR VAR VAR VAR VAR VAR VAR VAR VAR/VAR', VAR () => { VAR VAR({ VAR: [{ VAR: 'VAR[VAR]VAR', VAR: 'VAR[123]*' }], }); VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = { VAR: VAR, VAR: 'VAR', VAR: 'VAR: VAR: VAR.VAR({ VAR: { VAR: { VAR: 'VAR', VAR: 'VAR VAR.VAR.VAR', }, }, }), }; VAR VAR = VAR VAR(VAR).VAR(VAR => VAR); VAR(VAR.VAR).VAR(400); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(VAR.VAR.VAR); VAR(VAR.VAR).VAR( 'VAR VAR VAR VAR VAR: {""VAR"":""VAR[VAR]VAR"",""VAR"":""VAR[123]*""}.' ); }); VAR('VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR', VAR () => { VAR VAR({ VAR: [{ VAR: 'VAR[VAR]VAR', VAR: 'VAR[123]*' }], }); VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = { VAR: VAR, VAR: 'VAR', VAR: 'VAR: VAR: VAR.VAR({ VAR: [ { VAR: 'VAR', VAR: 'VAR VAR.VAR.VAR', }, ], }), }; VAR VAR = VAR VAR(VAR).VAR(VAR => VAR); VAR(VAR.VAR).VAR(400); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(VAR.VAR.VAR); VAR(VAR.VAR).VAR( 'VAR VAR VAR VAR VAR: {""VAR"":""VAR[VAR]VAR"",""VAR"":""VAR[123]*""}.' ); }); VAR('VAR VAR VAR VAR VAR VAR VAR VAR', VAR () => { VAR VAR({ VAR: [{ VAR: 'VAR[VAR]VAR' }], }); VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = { VAR: VAR, VAR: 'VAR', VAR: 'VAR: VAR: VAR.VAR({ VAR: { VAR: 'VAR', VAR: 'VAR VAR.VAR.VAR', }, }), }; VAR VAR = VAR VAR(VAR).VAR(VAR => VAR); VAR(VAR.VAR).VAR(400); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(VAR.VAR.VAR); VAR(VAR.VAR).VAR('VAR VAR VAR VAR VAR: {""VAR"":""VAR[VAR]VAR""}.'); }); VAR('VAR VAR VAR VAR VAR VAR VAR VAR', VAR () => { VAR VAR({ VAR: [{ VAR: 'VAR[123]*' }], }); VAR VAR = { 'VAR-VAR': 'VAR/VAR', 'VAR-VAR-VAR-VAR': 'VAR', 'VAR-VAR-VAR-VAR-VAR': 'VAR', }; VAR VAR = { VAR: VAR, VAR: 'VAR', VAR: 'VAR: VAR: VAR.VAR({ VAR: { VAR: 'VAR', VAR: 'VAR VAR.VAR.VAR', }, }), }; VAR VAR = VAR VAR(VAR).VAR(VAR => VAR); VAR(VAR.VAR).VAR(400); VAR VAR = VAR.VAR(VAR.VAR); VAR(VAR.VAR).VAR(VAR.VAR.VAR); VAR(VAR.VAR).VAR('VAR VAR VAR VAR VAR: {""VAR"":""VAR[123]*""}.'); }); }); }); ",0,16
server_d1203e9b5d082798c2ffd1c8ae8a927626f6090a,build/integration/features/webdav-related.feature,"
	Scenario: Creating a folder with invalid characters
		Given using new dav path
		And As an ""admin""
		And user ""user0"" exists
		And user ""user1"" exists
		And As an ""user1""
		And user ""user1"" created a folder ""/testshare	""
		Then the HTTP status code should be ""400""",,d1203e9b5d082798c2ffd1c8ae8a927626f6090a,CVE-2022-24888,d1203e9b5d082798c2ffd1c8ae8a927626f6090a,https://github.com/nextcloud/server,NVD_GIT_REPOBASED,66,COMPLETED,"VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ""VAR"" VAR VAR ""VAR"" VAR VAR VAR ""VAR"" VAR VAR VAR VAR ""VAR"" VAR VAR ""VAR"" VAR VAR VAR ""/VAR "" VAR VAR VAR VAR VAR VAR VAR ""400"" ",0,16
trafficserver_c4e6661a5a205b1f60279f0e66aa496023185967,tests/gold_tests/headers/gold/bad_good_request.gold,"``HTTP/1.1 400 Invalid HTTP Request
``Connection: close
``Server: ATS/``
``Content-Length: 219
``
<TITLE>Bad Request</TITLE>
``<H1>Bad Request</H1>
``Description: Could not process this request.
``",,c4e6661a5a205b1f60279f0e66aa496023185967,CVE-2021-44040,c4e6661a5a205b1f60279f0e66aa496023185967,https://github.com/apache/trafficserver,CPE_GIT_REPOBASED,70,COMPLETED,``VAR/1.1 400 VAR VAR VAR ``VAR: VAR ``VAR: VAR/`` ``VAR-VAR: 219 `` <VAR>VAR VAR</VAR> ``<VAR>VAR VAR</VAR> ``VAR: VAR VAR VAR VAR VAR. `` ,0,16
trafficserver_c4e6661a5a205b1f60279f0e66aa496023185967,tests/gold_tests/headers/gold/bad_good_request_header.gold,"``HTTP/1.1 400 Invalid HTTP Request
``Connection: close
``Server: ATS/``
``Content-Length: 219
``",,c4e6661a5a205b1f60279f0e66aa496023185967,CVE-2021-44040,c4e6661a5a205b1f60279f0e66aa496023185967,https://github.com/apache/trafficserver,CPE_GIT_REPOBASED,70,COMPLETED,``VAR/1.1 400 VAR VAR VAR ``VAR: VAR ``VAR: VAR/`` ``VAR-VAR: 219 `` ,0,16
trafficserver_c4e6661a5a205b1f60279f0e66aa496023185967,tests/gold_tests/headers/gold/bad_good_request_http1.gold,"``HTTP/1.0 400 Invalid HTTP Request
``Server: ATS/``
``Content-Length: 219
``
<TITLE>Bad Request</TITLE>
``<H1>Bad Request</H1>
``Description: Could not process this request.
``",,c4e6661a5a205b1f60279f0e66aa496023185967,CVE-2021-44040,c4e6661a5a205b1f60279f0e66aa496023185967,https://github.com/apache/trafficserver,CPE_GIT_REPOBASED,70,COMPLETED,``VAR/1.0 400 VAR VAR VAR ``VAR: VAR/`` ``VAR-VAR: 219 `` <VAR>VAR VAR</VAR> ``<VAR>VAR VAR</VAR> ``VAR: VAR VAR VAR VAR VAR. `` ,0,16
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,dummyserver/handlers.py,"from __future__ import print_function

import collections
import contextlib
import gzip
import json
import logging
import sys
import time
import zlib

from io import BytesIO
from tornado.web import RequestHandler
from tornado import httputil
from datetime import datetime
from datetime import timedelta

from urllib3.packages.six.moves.http_client import responses
from urllib3.packages.six.moves.urllib.parse import urlsplit

log = logging.getLogger(__name__)


class Response(object):
    def __init__(self, body='', status='200 OK', headers=None):
        self.body = body
        self.status = status
        self.headers = headers or [(""Content-type"", ""text/plain"")]

    def __call__(self, request_handler):
        status, reason = self.status.split(' ', 1)
        request_handler.set_status(int(status), reason)
        for header, value in self.headers:
            request_handler.add_header(header, value)

        # chunked
        if isinstance(self.body, list):
            for item in self.body:
                if not isinstance(item, bytes):
                    item = item.encode('utf8')
                request_handler.write(item)
                request_handler.flush()
        else:
            body = self.body
            if not isinstance(body, bytes):
                body = body.encode('utf8')

            request_handler.write(body)


RETRY_TEST_NAMES = collections.defaultdict(int)


class TestingApp(RequestHandler):
    """"""
    Simple app that performs various operations, useful for testing an HTTP
    library.

    Given any path, it will attempt to load a corresponding local method if
    it exists. Status code 200 indicates success, 400 indicates failure. Each
    method has its own conditions for success/failure.
    """"""
    def get(self):
        """""" Handle GET requests """"""
        self._call_method()

    def post(self):
        """""" Handle POST requests """"""
        self._call_method()

    def put(self):
        """""" Handle PUT requests """"""
        self._call_method()

    def options(self):
        """""" Handle OPTIONS requests """"""
        self._call_method()

    def head(self):
        """""" Handle HEAD requests """"""
        self._call_method()

    def _call_method(self):
        """""" Call the correct method in this class based on the incoming URI """"""
        req = self.request
        req.params = {}
        for k, v in req.arguments.items():
            req.params[k] = next(iter(v))

        path = req.path[:]
        if not path.startswith('/'):
            path = urlsplit(path).path

        target = path[1:].replace('/', '_')
        method = getattr(self, target, self.index)

        resp = method(req)

        if dict(resp.headers).get('Connection') == 'close':
            # FIXME: Can we kill the connection somehow?
            pass

        resp(self)

    def index(self, _request):
        ""Render simple message""
        return Response(""Dummy server!"")

    def certificate(self, request):
        """"""Return the requester's certificate.""""""
        cert = request.get_ssl_certificate()
        subject = dict()
        if cert is not None:
            subject = dict((k, v) for (k, v) in [y for z in cert['subject']
                                                 for y in z])
        return Response(json.dumps(subject))

    def source_address(self, request):
        """"""Return the requester's IP address.""""""
        return Response(request.remote_ip)

    def set_up(self, request):
        test_type = request.params.get('test_type')
        test_id = request.params.get('test_id')
        if test_id:
            print('\nNew test %s: %s' % (test_type, test_id))
        else:
            print('\nNew test %s' % test_type)
        return Response(""Dummy server is ready!"")

    def specific_method(self, request):
        ""Confirm that the request matches the desired method type""
        method = request.params.get('method')
        if method and not isinstance(method, str):
            method = method.decode('utf8')

        if request.method != method:
            return Response(""Wrong method: %s != %s"" %
                            (method, request.method), status='400 Bad Request')
        return Response()

    def upload(self, request):
        ""Confirm that the uploaded file conforms to specification""
        # FIXME: This is a huge broken mess
        param = request.params.get('upload_param', b'myfile').decode('ascii')
        filename = request.params.get('upload_filename', b'').decode('utf-8')
        size = int(request.params.get('upload_size', '0'))
        files_ = request.files.get(param)

        if len(files_) != 1:
            return Response(""Expected 1 file for '%s', not %d"" % (param, len(files_)),
                            status='400 Bad Request')
        file_ = files_[0]

        data = file_['body']
        if int(size) != len(data):
            return Response(""Wrong size: %d != %d"" %
                            (size, len(data)), status='400 Bad Request')

        if filename != file_['filename']:
            return Response(""Wrong filename: %s != %s"" %
                            (filename, file_.filename),
                            status='400 Bad Request')

        return Response()

    def redirect(self, request):
        ""Perform a redirect to ``target``""
        target = request.params.get('target', '/')
        status = request.params.get('status', '303 See Other')
        if len(status) == 3:
            status = '%s Redirect' % status.decode('latin-1')

        headers = [('Location', target)]
        return Response(status=status, headers=headers)

    def not_found(self, request):
        return Response('Not found', status='404 Not Found')

    def multi_redirect(self, request):
        ""Performs a redirect chain based on ``redirect_codes``""
        codes = request.params.get('redirect_codes', b'200').decode('utf-8')
        head, tail = codes.split(',', 1) if "","" in codes else (codes, None)
        status = ""{0} {1}"".format(head, responses[int(head)])
        if not tail:
            return Response(""Done redirecting"", status=status)

        headers = [('Location', '/multi_redirect?redirect_codes=%s' % tail)]
        return Response(status=status, headers=headers)

    def keepalive(self, request):
        if request.params.get('close', b'0') == b'1':
            headers = [('Connection', 'close')]
            return Response('Closing', headers=headers)

        headers = [('Connection', 'keep-alive')]
        return Response('Keeping alive', headers=headers)

    def sleep(self, request):
        ""Sleep for a specified amount of ``seconds``""
        # DO NOT USE THIS, IT'S DEPRECATED.
        # FIXME: Delete this once appengine tests are fixed to not use this handler.
        seconds = float(request.params.get('seconds', '1'))
        time.sleep(seconds)
        return Response()

    def echo(self, request):
        ""Echo back the params""
        if request.method == 'GET':
            return Response(request.query)

        return Response(request.body)

    def encodingrequest(self, request):
        ""Check for UA accepting gzip/deflate encoding""
        data = b""hello, world!""
        encoding = request.headers.get('Accept-Encoding', '')
        headers = None
        if encoding == 'gzip':
            headers = [('Content-Encoding', 'gzip')]
            file_ = BytesIO()
            with contextlib.closing(gzip.GzipFile('', mode='w', fileobj=file_)) as zipfile:
                zipfile.write(data)
            data = file_.getvalue()
        elif encoding == 'deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = zlib.compress(data)
        elif encoding == 'garbage-gzip':
            headers = [('Content-Encoding', 'gzip')]
            data = 'garbage'
        elif encoding == 'garbage-deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = 'garbage'
        return Response(data, headers=headers)

    def headers(self, request):
        return Response(json.dumps(dict(request.headers)))

    def successful_retry(self, request):
        """""" Handler which will return an error and then success

        It's not currently very flexible as the number of retries is hard-coded.
        """"""
        test_name = request.headers.get('test-name', None)
        if not test_name:
            return Response(""test-name header not set"",
                            status=""400 Bad Request"")

        RETRY_TEST_NAMES[test_name] += 1

        if RETRY_TEST_NAMES[test_name] >= 2:
            return Response(""Retry successful!"")
        else:
            return Response(""need to keep retrying!"", status=""418 I'm A Teapot"")

    def chunked(self, request):
        return Response(['123'] * 4)

    def chunked_gzip(self, request):
        chunks = []
        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)

        for uncompressed in [b'123'] * 4:
            chunks.append(compressor.compress(uncompressed))

        chunks.append(compressor.flush())

        return Response(chunks, headers=[('Content-Encoding', 'gzip')])

    def nbytes(self, request):
        length = int(request.params.get('length'))
        data = b'1' * length
        return Response(
            data,
            headers=[('Content-Type', 'application/octet-stream')])

    def status(self, request):
        status = request.params.get(""status"", ""200 OK"")

        return Response(status=status)

    def retry_after(self, request):
        if datetime.now() - self.application.last_req < timedelta(seconds=1):
            status = request.params.get(""status"", b""429 Too Many Requests"")
            return Response(
                    status=status.decode('utf-8'),
                    headers=[('Retry-After', '1')])

        self.application.last_req = datetime.now()

        return Response(status=""200 OK"")

    def redirect_after(self, request):
        ""Perform a redirect to ``target``""
        date = request.params.get('date')
        if date:
            retry_after = str(httputil.format_timestamp(
                    datetime.fromtimestamp(float(date))))
        else:
            retry_after = '1'
        target = request.params.get('target', '/')
        headers = [('Location', target), ('Retry-After', retry_after)]
        return Response(status='303 See Other', headers=headers)

    def shutdown(self, request):
        sys.exit()


# RFC2231-aware replacement of internal tornado function
def _parse_header(line):
    r""""""Parse a Content-type like header.

    Return the main content-type and a dictionary of options.

    >>> d = _parse_header(""CD: fd; foo=\""bar\""; file*=utf-8''T%C3%A4st"")[1]
    >>> d['file'] == 'T\u00e4st'
    True
    >>> d['foo']
    'bar'
    """"""
    import tornado.httputil
    import email.utils
    from urllib3.packages import six
    if not six.PY3:
        line = line.encode('utf-8')
    parts = tornado.httputil._parseparam(';' + line)
    key = next(parts)
    # decode_params treats first argument special, but we already stripped key
    params = [('Dummy', 'value')]
    for p in parts:
        i = p.find('=')
        if i >= 0:
            name = p[:i].strip().lower()
            value = p[i + 1:].strip()
            params.append((name, value))
    params = email.utils.decode_params(params)
    params.pop(0)  # get rid of the dummy again
    pdict = {}
    for name, value in params:
        value = email.utils.collapse_rfc2231_value(value)
        if len(value) >= 2 and value[0] == '""' and value[-1] == '""':
            value = value[1:-1]
        pdict[name] = value
    return key, pdict


# TODO: make the following conditional as soon as we know a version
#       which does not require this fix.
#       See https://github.com/facebook/tornado/issues/868
if True:
    import tornado.httputil
    tornado.httputil._parse_header = _parse_header",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR, VAR='', VAR='200 VAR', VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR [(""VAR-VAR"", ""VAR/VAR"")] VAR VAR(VAR, VAR): VAR, VAR = VAR.VAR.VAR(' ', 1) VAR.VAR(VAR(VAR), VAR) VAR VAR, VAR VAR VAR.VAR: VAR.VAR(VAR, VAR)  VAR VAR(VAR.VAR, VAR): VAR VAR VAR VAR.VAR: VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR.VAR() VAR: VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR 200 VAR VAR, 400 VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR/VAR. """""" VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR.VAR VAR.VAR = {} VAR VAR, VAR VAR VAR.VAR.VAR(): VAR.VAR[VAR] = VAR(VAR(VAR)) VAR = VAR.VAR[:] VAR VAR VAR.VAR('/'): VAR = VAR(VAR).VAR VAR = VAR[1:].VAR('/', 'VAR') VAR = VAR(VAR, VAR, VAR.VAR) VAR = VAR(VAR) VAR VAR(VAR.VAR).VAR('VAR') == 'VAR':  VAR VAR(VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR"" VAR VAR(""VAR VAR!"") VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR."""""" VAR = VAR.VAR() VAR = VAR() VAR VAR VAR VAR VAR: VAR = VAR((VAR, VAR) VAR (VAR, VAR) VAR [VAR VAR VAR VAR VAR['VAR'] VAR VAR VAR VAR]) VAR VAR(VAR.VAR(VAR)) VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR VAR."""""" VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR('VAR') VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR('\VAR VAR %VAR: %VAR' % (VAR, VAR)) VAR: VAR('\VAR VAR %VAR' % VAR) VAR VAR(""VAR VAR VAR VAR!"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR = VAR.VAR.VAR('VAR') VAR VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR VAR.VAR != VAR: VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR""  VAR = VAR.VAR.VAR('VAR', VAR'VAR').VAR('VAR') VAR = VAR.VAR.VAR('VAR', VAR'').VAR('VAR-8') VAR = VAR(VAR.VAR.VAR('VAR', '0')) VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) != 1: VAR VAR(""VAR 1 VAR VAR '%VAR', VAR %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR = VAR[0] VAR = VAR['VAR'] VAR VAR(VAR) != VAR(VAR): VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR VAR != VAR['VAR']: VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', '/') VAR = VAR.VAR.VAR('VAR', '303 VAR VAR') VAR VAR(VAR) == 3: VAR = '%VAR VAR' % VAR.VAR('VAR-1') VAR = [('VAR', VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR('VAR VAR', VAR='404 VAR VAR') VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', VAR'200').VAR('VAR-8') VAR, VAR = VAR.VAR(',', 1) VAR "","" VAR VAR VAR (VAR, VAR) VAR = ""{0} {1}"".VAR(VAR, VAR[VAR(VAR)]) VAR VAR VAR: VAR VAR(""VAR VAR"", VAR=VAR) VAR = [('VAR', '/VAR?VAR=%VAR' % VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR('VAR', VAR'0') == VAR'1': VAR = [('VAR', 'VAR')] VAR VAR('VAR', VAR=VAR) VAR = [('VAR', 'VAR-VAR')] VAR VAR('VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``""   VAR = VAR(VAR.VAR.VAR('VAR', '1')) VAR.VAR(VAR) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR"" VAR VAR.VAR == 'VAR': VAR VAR(VAR.VAR) VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR/VAR VAR"" VAR = VAR""VAR, VAR!"" VAR = VAR.VAR.VAR('VAR-VAR', '') VAR = VAR VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR() VAR VAR.VAR(VAR.VAR('', VAR='VAR', VAR=VAR)) VAR VAR: VAR.VAR(VAR) VAR = VAR.VAR() VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR.VAR(VAR) VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR(VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR(VAR.VAR(VAR(VAR.VAR))) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR', VAR) VAR VAR VAR: VAR VAR(""VAR-VAR VAR VAR VAR"", VAR=""400 VAR VAR"") VAR[VAR] += 1 VAR VAR[VAR] >= 2: VAR VAR(""VAR VAR!"") VAR: VAR VAR(""VAR VAR VAR VAR!"", VAR=""418 VAR'VAR VAR VAR"") VAR VAR(VAR, VAR): VAR VAR(['123'] * 4) VAR VAR(VAR, VAR): VAR = [] VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR VAR VAR [VAR'123'] * 4: VAR.VAR(VAR.VAR(VAR)) VAR.VAR(VAR.VAR()) VAR VAR(VAR, VAR=[('VAR-VAR', 'VAR')]) VAR VAR(VAR, VAR): VAR = VAR(VAR.VAR.VAR('VAR')) VAR = VAR'1' * VAR VAR VAR( VAR, VAR=[('VAR-VAR', 'VAR/VAR-VAR')]) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(""VAR"", ""200 VAR"") VAR VAR(VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR() - VAR.VAR.VAR < VAR(VAR=1): VAR = VAR.VAR.VAR(""VAR"", VAR""429 VAR VAR VAR"") VAR VAR( VAR=VAR.VAR('VAR-8'), VAR=[('VAR-VAR', '1')]) VAR.VAR.VAR = VAR.VAR() VAR VAR(VAR=""200 VAR"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR = VAR(VAR.VAR( VAR.VAR(VAR(VAR)))) VAR: VAR = '1' VAR = VAR.VAR.VAR('VAR', '/') VAR = [('VAR', VAR), ('VAR-VAR', VAR)] VAR VAR(VAR='303 VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): VAR.VAR()  VAR VAR(VAR): VAR""""""VAR VAR VAR-VAR VAR VAR. VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR. >>> VAR = VAR(""VAR: VAR; VAR=\""VAR\""; VAR*=VAR-8''VAR%VAR%VAR"")[1] >>> VAR['VAR'] == 'VAR\VAR' VAR >>> VAR['VAR'] 'VAR' """""" VAR VAR.VAR VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR VAR.VAR: VAR = VAR.VAR('VAR-8') VAR = VAR.VAR.VAR(';' + VAR) VAR = VAR(VAR)  VAR = [('VAR', 'VAR')] VAR VAR VAR VAR: VAR = VAR.VAR('=') VAR VAR >= 0: VAR = VAR[:VAR].VAR().VAR() VAR = VAR[VAR + 1:].VAR() VAR.VAR((VAR, VAR)) VAR = VAR.VAR.VAR(VAR) VAR.VAR(0)  VAR = {} VAR VAR, VAR VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) >= 2 VAR VAR[0] == '""' VAR VAR[-1] == '""': VAR = VAR[1:-1] VAR[VAR] = VAR VAR VAR, VAR    VAR VAR: VAR VAR.VAR VAR.VAR.VAR = VAR ",8,16
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,docs/images/banner.svg,"<svg viewBox=""0 0 400 119.35"" xmlns=""http://www.w3.org/2000/svg""><path d=""m23.05 31v51.88q0 7.35 1.73 11.05 3.06 6.55 12 6.56 11.48 0 15.71-9.32 2.2-5.06 2.2-13.34v-46.83h22.82v86h-21.86v-12.09c-.21.26-.74 1-1.57 2.36a15.9 15.9 0 0 1 -3 3.48 31.44 31.44 0 0 1 -10.2 6.47 34.57 34.57 0 0 1 -11.52 1.78q-19 0-25.66-13.74-3.7-7.61-3.7-22.38v-51.88z""/><path d=""m140.44 29c.29 0 .93.07 1.93.12v23.06c-1.42-.16-2.68-.27-3.79-.32s-2-.08-2.68-.08q-13.58 0-18.23 8.84-2.61 5-2.61 15.32v41.12h-22.65v-86.06h21.47v15q5.2-8.61 9.08-11.76 6.3-5.24 16.41-5.24z""/><path d=""m177.56 86h-22.81v-86h22.81zm-22.81 10.3h22.81v20.76h-22.81z"" fill=""#cb3b0f""/><path d=""m210.13 86h-22.82v-86h22.82zm-22.82 10.3h22.82v20.76h-22.82z"" fill=""#ea9b1c""/><path d=""m242.69 20.76h-22.81v-20.76h22.81zm-22.81 10.24h22.81v86h-22.81z"" fill=""#577a27""/><path d=""m333.45 41.36q9.66 12.24 9.66 31.58 0 20-9.53 33.23t-26.58 13.18q-10.71 0-17.21-4.26-3.89-2.53-8.41-8.84v10.81h-22.18v-116.19h22.49v41.36a32.94 32.94 0 0 1 9.46-9.16q6.11-3.94 15.57-3.94 17.07 0 26.73 12.23zm-18.8 52.41q4.86-7 4.85-18.47 0-9.15-2.38-15.15-4.55-11.37-16.72-11.37-12.33 0-16.95 11.13-2.38 5.93-2.39 15.32 0 11 4.94 18.31t15 7.26a15.6 15.6 0 0 0 13.65-7.03z""/><path d=""m363 49.73q.31 5.06 1.74 7.42 2.59 4.34 9.47 4.34a11.79 11.79 0 0 0 5.6-1.42q5.06-2.68 5-9.24t-5-8.6q-3.07-1.33-11.6-1.66v-9.57q7-.15 9.87-1.34 5-2.13 5-8.21a7.91 7.91 0 0 0 -2.81-6.45 10.56 10.56 0 0 0 -6.87-2.25 8.91 8.91 0 0 0 -7.3 3.12 12.32 12.32 0 0 0 -2.57 8.09h-13.53a20.75 20.75 0 0 1 7.42-17.37q5.96-4.78 16.58-4.77 10.89 0 17.33 5.17a16.55 16.55 0 0 1 6.43 13.53 14.06 14.06 0 0 1 -2.42 8.48 17.71 17.71 0 0 1 -6.55 5.41 13 13 0 0 1 7.78 4.34q3.43 3.72 3.43 11.45 0 10.59-7.3 16.38a27.25 27.25 0 0 1 -17.49 5.8q-12.07 0-19.37-5.32t-7.31-17.33z""/></svg>",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"<VAR VAR=""0 0 400 119.35"" VAR=""VAR: ",0,16
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,dummyserver/handlers.py,"from __future__ import print_function

import collections
import contextlib
import gzip
import json
import logging
import sys
import time
import zlib
from datetime import datetime, timedelta
from io import BytesIO

from tornado import httputil
from tornado.web import RequestHandler

from urllib3.packages.six import binary_type, ensure_str
from urllib3.packages.six.moves.http_client import responses
from urllib3.packages.six.moves.urllib.parse import urlsplit

log = logging.getLogger(__name__)


class Response(object):
    def __init__(self, body="""", status=""200 OK"", headers=None):
        self.body = body
        self.status = status
        self.headers = headers or [(""Content-type"", ""text/plain"")]

    def __call__(self, request_handler):
        status, reason = self.status.split("" "", 1)
        request_handler.set_status(int(status), reason)
        for header, value in self.headers:
            request_handler.add_header(header, value)

        # chunked
        if isinstance(self.body, list):
            for item in self.body:
                if not isinstance(item, bytes):
                    item = item.encode(""utf8"")
                request_handler.write(item)
                request_handler.flush()
        else:
            body = self.body
            if not isinstance(body, bytes):
                body = body.encode(""utf8"")

            request_handler.write(body)


RETRY_TEST_NAMES = collections.defaultdict(int)


class TestingApp(RequestHandler):
    """"""
    Simple app that performs various operations, useful for testing an HTTP
    library.

    Given any path, it will attempt to load a corresponding local method if
    it exists. Status code 200 indicates success, 400 indicates failure. Each
    method has its own conditions for success/failure.
    """"""

    def get(self):
        """"""Handle GET requests""""""
        self._call_method()

    def post(self):
        """"""Handle POST requests""""""
        self._call_method()

    def put(self):
        """"""Handle PUT requests""""""
        self._call_method()

    def options(self):
        """"""Handle OPTIONS requests""""""
        self._call_method()

    def head(self):
        """"""Handle HEAD requests""""""
        self._call_method()

    def _call_method(self):
        """"""Call the correct method in this class based on the incoming URI""""""
        req = self.request
        req.params = {}
        for k, v in req.arguments.items():
            req.params[k] = next(iter(v))

        path = req.path[:]
        if not path.startswith(""/""):
            path = urlsplit(path).path

        target = path[1:].split(""/"", 1)[0]
        method = getattr(self, target, self.index)

        resp = method(req)

        if dict(resp.headers).get(""Connection"") == ""close"":
            # FIXME: Can we kill the connection somehow?
            pass

        resp(self)

    def index(self, _request):
        ""Render simple message""
        return Response(""Dummy server!"")

    def certificate(self, request):
        """"""Return the requester's certificate.""""""
        cert = request.get_ssl_certificate()
        subject = dict()
        if cert is not None:
            subject = dict((k, v) for (k, v) in [y for z in cert[""subject""] for y in z])
        return Response(json.dumps(subject))

    def alpn_protocol(self, request):
        """"""Return the selected ALPN protocol.""""""
        proto = request.connection.stream.socket.selected_alpn_protocol()
        return Response(proto.encode(""utf8"") if proto is not None else u"""")

    def source_address(self, request):
        """"""Return the requester's IP address.""""""
        return Response(request.remote_ip)

    def set_up(self, request):
        test_type = request.params.get(""test_type"")
        test_id = request.params.get(""test_id"")
        if test_id:
            print(""\nNew test %s: %s"" % (test_type, test_id))
        else:
            print(""\nNew test %s"" % test_type)
        return Response(""Dummy server is ready!"")

    def specific_method(self, request):
        ""Confirm that the request matches the desired method type""
        method = request.params.get(""method"")
        if method and not isinstance(method, str):
            method = method.decode(""utf8"")

        if request.method != method:
            return Response(
                ""Wrong method: %s != %s"" % (method, request.method),
                status=""400 Bad Request"",
            )
        return Response()

    def upload(self, request):
        ""Confirm that the uploaded file conforms to specification""
        # FIXME: This is a huge broken mess
        param = request.params.get(""upload_param"", b""myfile"").decode(""ascii"")
        filename = request.params.get(""upload_filename"", b"""").decode(""utf-8"")
        size = int(request.params.get(""upload_size"", ""0""))
        files_ = request.files.get(param)

        if len(files_) != 1:
            return Response(
                ""Expected 1 file for '%s', not %d"" % (param, len(files_)),
                status=""400 Bad Request"",
            )
        file_ = files_[0]

        data = file_[""body""]
        if int(size) != len(data):
            return Response(
                ""Wrong size: %d != %d"" % (size, len(data)), status=""400 Bad Request""
            )

        got_filename = file_[""filename""]
        if isinstance(got_filename, binary_type):
            got_filename = got_filename.decode(""utf-8"")

        # Tornado can leave the trailing \n in place on the filename.
        if filename != got_filename:
            return Response(
                u""Wrong filename: %s != %s"" % (filename, file_.filename),
                status=""400 Bad Request"",
            )

        return Response()

    def redirect(self, request):
        ""Perform a redirect to ``target``""
        target = request.params.get(""target"", ""/"")
        status = request.params.get(""status"", ""303 See Other"")
        if len(status) == 3:
            status = ""%s Redirect"" % status.decode(""latin-1"")

        headers = [(""Location"", target)]
        return Response(status=status, headers=headers)

    def not_found(self, request):
        return Response(""Not found"", status=""404 Not Found"")

    def multi_redirect(self, request):
        ""Performs a redirect chain based on ``redirect_codes``""
        codes = request.params.get(""redirect_codes"", b""200"").decode(""utf-8"")
        head, tail = codes.split("","", 1) if "","" in codes else (codes, None)
        status = ""{0} {1}"".format(head, responses[int(head)])
        if not tail:
            return Response(""Done redirecting"", status=status)

        headers = [(""Location"", ""/multi_redirect?redirect_codes=%s"" % tail)]
        return Response(status=status, headers=headers)

    def keepalive(self, request):
        if request.params.get(""close"", b""0"") == b""1"":
            headers = [(""Connection"", ""close"")]
            return Response(""Closing"", headers=headers)

        headers = [(""Connection"", ""keep-alive"")]
        return Response(""Keeping alive"", headers=headers)

    def echo_params(self, request):
        params = sorted(
            [(ensure_str(k), ensure_str(v)) for k, v in request.params.items()]
        )
        return Response(repr(params))

    def sleep(self, request):
        ""Sleep for a specified amount of ``seconds``""
        # DO NOT USE THIS, IT'S DEPRECATED.
        # FIXME: Delete this once appengine tests are fixed to not use this handler.
        seconds = float(request.params.get(""seconds"", ""1""))
        time.sleep(seconds)
        return Response()

    def echo(self, request):
        ""Echo back the params""
        if request.method == ""GET"":
            return Response(request.query)

        return Response(request.body)

    def echo_uri(self, request):
        ""Echo back the requested URI""
        return Response(request.uri)

    def encodingrequest(self, request):
        ""Check for UA accepting gzip/deflate encoding""
        data = b""hello, world!""
        encoding = request.headers.get(""Accept-Encoding"", """")
        headers = None
        if encoding == ""gzip"":
            headers = [(""Content-Encoding"", ""gzip"")]
            file_ = BytesIO()
            with contextlib.closing(
                gzip.GzipFile("""", mode=""w"", fileobj=file_)
            ) as zipfile:
                zipfile.write(data)
            data = file_.getvalue()
        elif encoding == ""deflate"":
            headers = [(""Content-Encoding"", ""deflate"")]
            data = zlib.compress(data)
        elif encoding == ""garbage-gzip"":
            headers = [(""Content-Encoding"", ""gzip"")]
            data = ""garbage""
        elif encoding == ""garbage-deflate"":
            headers = [(""Content-Encoding"", ""deflate"")]
            data = ""garbage""
        return Response(data, headers=headers)

    def headers(self, request):
        return Response(json.dumps(dict(request.headers)))

    def successful_retry(self, request):
        """"""Handler which will return an error and then success

        It's not currently very flexible as the number of retries is hard-coded.
        """"""
        test_name = request.headers.get(""test-name"", None)
        if not test_name:
            return Response(""test-name header not set"", status=""400 Bad Request"")

        RETRY_TEST_NAMES[test_name] += 1

        if RETRY_TEST_NAMES[test_name] >= 2:
            return Response(""Retry successful!"")
        else:
            return Response(""need to keep retrying!"", status=""418 I'm A Teapot"")

    def chunked(self, request):
        return Response([""123""] * 4)

    def chunked_gzip(self, request):
        chunks = []
        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)

        for uncompressed in [b""123""] * 4:
            chunks.append(compressor.compress(uncompressed))

        chunks.append(compressor.flush())

        return Response(chunks, headers=[(""Content-Encoding"", ""gzip"")])

    def nbytes(self, request):
        length = int(request.params.get(""length""))
        data = b""1"" * length
        return Response(data, headers=[(""Content-Type"", ""application/octet-stream"")])

    def status(self, request):
        status = request.params.get(""status"", ""200 OK"")

        return Response(status=status)

    def retry_after(self, request):
        if datetime.now() - self.application.last_req < timedelta(seconds=1):
            status = request.params.get(""status"", b""429 Too Many Requests"")
            return Response(
                status=status.decode(""utf-8""), headers=[(""Retry-After"", ""1"")]
            )

        self.application.last_req = datetime.now()

        return Response(status=""200 OK"")

    def redirect_after(self, request):
        ""Perform a redirect to ``target``""
        date = request.params.get(""date"")
        if date:
            retry_after = str(
                httputil.format_timestamp(datetime.utcfromtimestamp(float(date)))
            )
        else:
            retry_after = ""1""
        target = request.params.get(""target"", ""/"")
        headers = [(""Location"", target), (""Retry-After"", retry_after)]
        return Response(status=""303 See Other"", headers=headers)

    def shutdown(self, request):
        sys.exit()",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR, VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR, VAR="""", VAR=""200 VAR"", VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR [(""VAR-VAR"", ""VAR/VAR"")] VAR VAR(VAR, VAR): VAR, VAR = VAR.VAR.VAR("" "", 1) VAR.VAR(VAR(VAR), VAR) VAR VAR, VAR VAR VAR.VAR: VAR.VAR(VAR, VAR)  VAR VAR(VAR.VAR, VAR): VAR VAR VAR VAR.VAR: VAR VAR VAR(VAR, VAR): VAR = VAR.VAR(""VAR"") VAR.VAR(VAR) VAR.VAR() VAR: VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR(""VAR"") VAR.VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR 200 VAR VAR, 400 VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR/VAR. """""" VAR VAR(VAR): """"""VAR VAR VAR"""""" VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR"""""" VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR"""""" VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR"""""" VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR"""""" VAR.VAR() VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR"""""" VAR = VAR.VAR VAR.VAR = {} VAR VAR, VAR VAR VAR.VAR.VAR(): VAR.VAR[VAR] = VAR(VAR(VAR)) VAR = VAR.VAR[:] VAR VAR VAR.VAR(""/""): VAR = VAR(VAR).VAR VAR = VAR[1:].VAR(""/"", 1)[0] VAR = VAR(VAR, VAR, VAR.VAR) VAR = VAR(VAR) VAR VAR(VAR.VAR).VAR(""VAR"") == ""VAR"":  VAR VAR(VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR"" VAR VAR(""VAR VAR!"") VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR."""""" VAR = VAR.VAR() VAR = VAR() VAR VAR VAR VAR VAR: VAR = VAR((VAR, VAR) VAR (VAR, VAR) VAR [VAR VAR VAR VAR VAR[""VAR""] VAR VAR VAR VAR]) VAR VAR(VAR.VAR(VAR)) VAR VAR(VAR, VAR): """"""VAR VAR VAR VAR VAR."""""" VAR = VAR.VAR.VAR.VAR.VAR() VAR VAR(VAR.VAR(""VAR"") VAR VAR VAR VAR VAR VAR VAR"""") VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR VAR."""""" VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(""VAR"") VAR = VAR.VAR.VAR(""VAR"") VAR VAR: VAR(""\VAR VAR %VAR: %VAR"" % (VAR, VAR)) VAR: VAR(""\VAR VAR %VAR"" % VAR) VAR VAR(""VAR VAR VAR VAR!"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR = VAR.VAR.VAR(""VAR"") VAR VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR(""VAR"") VAR VAR.VAR != VAR: VAR VAR( ""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR=""400 VAR VAR"", ) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR""  VAR = VAR.VAR.VAR(""VAR"", VAR""VAR"").VAR(""VAR"") VAR = VAR.VAR.VAR(""VAR"", VAR"""").VAR(""VAR-8"") VAR = VAR(VAR.VAR.VAR(""VAR"", ""0"")) VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) != 1: VAR VAR( ""VAR 1 VAR VAR '%VAR', VAR %VAR"" % (VAR, VAR(VAR)), VAR=""400 VAR VAR"", ) VAR = VAR[0] VAR = VAR[""VAR""] VAR VAR(VAR) != VAR(VAR): VAR VAR( ""VAR VAR: %VAR != %VAR"" % (VAR, VAR(VAR)), VAR=""400 VAR VAR"" ) VAR = VAR[""VAR""] VAR VAR(VAR, VAR): VAR = VAR.VAR(""VAR-8"")  VAR VAR != VAR: VAR VAR( VAR""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR=""400 VAR VAR"", ) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR(""VAR"", ""/"") VAR = VAR.VAR.VAR(""VAR"", ""303 VAR VAR"") VAR VAR(VAR) == 3: VAR = ""%VAR VAR"" % VAR.VAR(""VAR-1"") VAR = [(""VAR"", VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR(""VAR VAR"", VAR=""404 VAR VAR"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR(""VAR"", VAR""200"").VAR(""VAR-8"") VAR, VAR = VAR.VAR("","", 1) VAR "","" VAR VAR VAR (VAR, VAR) VAR = ""{0} {1}"".VAR(VAR, VAR[VAR(VAR)]) VAR VAR VAR: VAR VAR(""VAR VAR"", VAR=VAR) VAR = [(""VAR"", ""/VAR?VAR=%VAR"" % VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR(""VAR"", VAR""0"") == VAR""1"": VAR = [(""VAR"", ""VAR"")] VAR VAR(""VAR"", VAR=VAR) VAR = [(""VAR"", ""VAR-VAR"")] VAR VAR(""VAR VAR"", VAR=VAR) VAR VAR(VAR, VAR): VAR = VAR( [(VAR(VAR), VAR(VAR)) VAR VAR, VAR VAR VAR.VAR.VAR()] ) VAR VAR(VAR(VAR)) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``""   VAR = VAR(VAR.VAR.VAR(""VAR"", ""1"")) VAR.VAR(VAR) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR"" VAR VAR.VAR == ""VAR"": VAR VAR(VAR.VAR) VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR"" VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR/VAR VAR"" VAR = VAR""VAR, VAR!"" VAR = VAR.VAR.VAR(""VAR-VAR"", """") VAR = VAR VAR VAR == ""VAR"": VAR = [(""VAR-VAR"", ""VAR"")] VAR = VAR() VAR VAR.VAR( VAR.VAR("""", VAR=""VAR"", VAR=VAR) ) VAR VAR: VAR.VAR(VAR) VAR = VAR.VAR() VAR VAR == ""VAR"": VAR = [(""VAR-VAR"", ""VAR"")] VAR = VAR.VAR(VAR) VAR VAR == ""VAR-VAR"": VAR = [(""VAR-VAR"", ""VAR"")] VAR = ""VAR"" VAR VAR == ""VAR-VAR"": VAR = [(""VAR-VAR"", ""VAR"")] VAR = ""VAR"" VAR VAR(VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR(VAR.VAR(VAR(VAR.VAR))) VAR VAR(VAR, VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR. """""" VAR = VAR.VAR.VAR(""VAR-VAR"", VAR) VAR VAR VAR: VAR VAR(""VAR-VAR VAR VAR VAR"", VAR=""400 VAR VAR"") VAR[VAR] += 1 VAR VAR[VAR] >= 2: VAR VAR(""VAR VAR!"") VAR: VAR VAR(""VAR VAR VAR VAR!"", VAR=""418 VAR'VAR VAR VAR"") VAR VAR(VAR, VAR): VAR VAR([""123""] * 4) VAR VAR(VAR, VAR): VAR = [] VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR VAR VAR [VAR""123""] * 4: VAR.VAR(VAR.VAR(VAR)) VAR.VAR(VAR.VAR()) VAR VAR(VAR, VAR=[(""VAR-VAR"", ""VAR"")]) VAR VAR(VAR, VAR): VAR = VAR(VAR.VAR.VAR(""VAR"")) VAR = VAR""1"" * VAR VAR VAR(VAR, VAR=[(""VAR-VAR"", ""VAR/VAR-VAR"")]) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(""VAR"", ""200 VAR"") VAR VAR(VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR() - VAR.VAR.VAR < VAR(VAR=1): VAR = VAR.VAR.VAR(""VAR"", VAR""429 VAR VAR VAR"") VAR VAR( VAR=VAR.VAR(""VAR-8""), VAR=[(""VAR-VAR"", ""1"")] ) VAR.VAR.VAR = VAR.VAR() VAR VAR(VAR=""200 VAR"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR(""VAR"") VAR VAR: VAR = VAR( VAR.VAR(VAR.VAR(VAR(VAR))) ) VAR: VAR = ""1"" VAR = VAR.VAR.VAR(""VAR"", ""/"") VAR = [(""VAR"", VAR), (""VAR-VAR"", VAR)] VAR VAR(VAR=""303 VAR VAR"", VAR=VAR) VAR VAR(VAR, VAR): VAR.VAR() ",8,16
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,dummyserver/handlers.py,"from __future__ import print_function

import collections
import contextlib
import gzip
import json
import logging
import sys
import time
import zlib

from io import BytesIO
from tornado.web import RequestHandler
from tornado import httputil
from datetime import datetime
from datetime import timedelta

from urllib3.packages.six.moves.http_client import responses
from urllib3.packages.six.moves.urllib.parse import urlsplit

log = logging.getLogger(__name__)


class Response(object):
    def __init__(self, body='', status='200 OK', headers=None):
        self.body = body
        self.status = status
        self.headers = headers or [(""Content-type"", ""text/plain"")]

    def __call__(self, request_handler):
        status, reason = self.status.split(' ', 1)
        request_handler.set_status(int(status), reason)
        for header, value in self.headers:
            request_handler.add_header(header, value)

        # chunked
        if isinstance(self.body, list):
            for item in self.body:
                if not isinstance(item, bytes):
                    item = item.encode('utf8')
                request_handler.write(item)
                request_handler.flush()
        else:
            body = self.body
            if not isinstance(body, bytes):
                body = body.encode('utf8')

            request_handler.write(body)


RETRY_TEST_NAMES = collections.defaultdict(int)


class TestingApp(RequestHandler):
    """"""
    Simple app that performs various operations, useful for testing an HTTP
    library.

    Given any path, it will attempt to load a corresponding local method if
    it exists. Status code 200 indicates success, 400 indicates failure. Each
    method has its own conditions for success/failure.
    """"""
    def get(self):
        """""" Handle GET requests """"""
        self._call_method()

    def post(self):
        """""" Handle POST requests """"""
        self._call_method()

    def put(self):
        """""" Handle PUT requests """"""
        self._call_method()

    def options(self):
        """""" Handle OPTIONS requests """"""
        self._call_method()

    def head(self):
        """""" Handle HEAD requests """"""
        self._call_method()

    def _call_method(self):
        """""" Call the correct method in this class based on the incoming URI """"""
        req = self.request
        req.params = {}
        for k, v in req.arguments.items():
            req.params[k] = next(iter(v))

        path = req.path[:]
        if not path.startswith('/'):
            path = urlsplit(path).path

        target = path[1:].replace('/', '_')
        method = getattr(self, target, self.index)

        resp = method(req)

        if dict(resp.headers).get('Connection') == 'close':
            # FIXME: Can we kill the connection somehow?
            pass

        resp(self)

    def index(self, _request):
        ""Render simple message""
        return Response(""Dummy server!"")

    def certificate(self, request):
        """"""Return the requester's certificate.""""""
        cert = request.get_ssl_certificate()
        subject = dict()
        if cert is not None:
            subject = dict((k, v) for (k, v) in [y for z in cert['subject']
                                                 for y in z])
        return Response(json.dumps(subject))

    def source_address(self, request):
        """"""Return the requester's IP address.""""""
        return Response(request.remote_ip)

    def set_up(self, request):
        test_type = request.params.get('test_type')
        test_id = request.params.get('test_id')
        if test_id:
            print('\nNew test %s: %s' % (test_type, test_id))
        else:
            print('\nNew test %s' % test_type)
        return Response(""Dummy server is ready!"")

    def specific_method(self, request):
        ""Confirm that the request matches the desired method type""
        method = request.params.get('method')
        if method and not isinstance(method, str):
            method = method.decode('utf8')

        if request.method != method:
            return Response(""Wrong method: %s != %s"" %
                            (method, request.method), status='400 Bad Request')
        return Response()

    def upload(self, request):
        ""Confirm that the uploaded file conforms to specification""
        # FIXME: This is a huge broken mess
        param = request.params.get('upload_param', b'myfile').decode('ascii')
        filename = request.params.get('upload_filename', b'').decode('utf-8')
        size = int(request.params.get('upload_size', '0'))
        files_ = request.files.get(param)

        if len(files_) != 1:
            return Response(""Expected 1 file for '%s', not %d"" % (param, len(files_)),
                            status='400 Bad Request')
        file_ = files_[0]

        data = file_['body']
        if int(size) != len(data):
            return Response(""Wrong size: %d != %d"" %
                            (size, len(data)), status='400 Bad Request')

        if filename != file_['filename']:
            return Response(""Wrong filename: %s != %s"" %
                            (filename, file_.filename),
                            status='400 Bad Request')

        return Response()

    def redirect(self, request):
        ""Perform a redirect to ``target``""
        target = request.params.get('target', '/')
        status = request.params.get('status', '303 See Other')
        if len(status) == 3:
            status = '%s Redirect' % status.decode('latin-1')

        headers = [('Location', target)]
        return Response(status=status, headers=headers)

    def not_found(self, request):
        return Response('Not found', status='404 Not Found')

    def multi_redirect(self, request):
        ""Performs a redirect chain based on ``redirect_codes``""
        codes = request.params.get('redirect_codes', b'200').decode('utf-8')
        head, tail = codes.split(',', 1) if "","" in codes else (codes, None)
        status = ""{0} {1}"".format(head, responses[int(head)])
        if not tail:
            return Response(""Done redirecting"", status=status)

        headers = [('Location', '/multi_redirect?redirect_codes=%s' % tail)]
        return Response(status=status, headers=headers)

    def keepalive(self, request):
        if request.params.get('close', b'0') == b'1':
            headers = [('Connection', 'close')]
            return Response('Closing', headers=headers)

        headers = [('Connection', 'keep-alive')]
        return Response('Keeping alive', headers=headers)

    def sleep(self, request):
        ""Sleep for a specified amount of ``seconds``""
        # DO NOT USE THIS, IT'S DEPRECATED.
        # FIXME: Delete this once appengine tests are fixed to not use this handler.
        seconds = float(request.params.get('seconds', '1'))
        time.sleep(seconds)
        return Response()

    def echo(self, request):
        ""Echo back the params""
        if request.method == 'GET':
            return Response(request.query)

        return Response(request.body)

    def encodingrequest(self, request):
        ""Check for UA accepting gzip/deflate encoding""
        data = b""hello, world!""
        encoding = request.headers.get('Accept-Encoding', '')
        headers = None
        if encoding == 'gzip':
            headers = [('Content-Encoding', 'gzip')]
            file_ = BytesIO()
            with contextlib.closing(gzip.GzipFile('', mode='w', fileobj=file_)) as zipfile:
                zipfile.write(data)
            data = file_.getvalue()
        elif encoding == 'deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = zlib.compress(data)
        elif encoding == 'garbage-gzip':
            headers = [('Content-Encoding', 'gzip')]
            data = 'garbage'
        elif encoding == 'garbage-deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = 'garbage'
        return Response(data, headers=headers)

    def headers(self, request):
        return Response(json.dumps(dict(request.headers)))

    def successful_retry(self, request):
        """""" Handler which will return an error and then success

        It's not currently very flexible as the number of retries is hard-coded.
        """"""
        test_name = request.headers.get('test-name', None)
        if not test_name:
            return Response(""test-name header not set"",
                            status=""400 Bad Request"")

        RETRY_TEST_NAMES[test_name] += 1

        if RETRY_TEST_NAMES[test_name] >= 2:
            return Response(""Retry successful!"")
        else:
            return Response(""need to keep retrying!"", status=""418 I'm A Teapot"")

    def chunked(self, request):
        return Response(['123'] * 4)

    def chunked_gzip(self, request):
        chunks = []
        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)

        for uncompressed in [b'123'] * 4:
            chunks.append(compressor.compress(uncompressed))

        chunks.append(compressor.flush())

        return Response(chunks, headers=[('Content-Encoding', 'gzip')])

    def nbytes(self, request):
        length = int(request.params.get('length'))
        data = b'1' * length
        return Response(
            data,
            headers=[('Content-Type', 'application/octet-stream')])

    def status(self, request):
        status = request.params.get(""status"", ""200 OK"")

        return Response(status=status)

    def retry_after(self, request):
        if datetime.now() - self.application.last_req < timedelta(seconds=1):
            status = request.params.get(""status"", b""429 Too Many Requests"")
            return Response(
                    status=status.decode('utf-8'),
                    headers=[('Retry-After', '1')])

        self.application.last_req = datetime.now()

        return Response(status=""200 OK"")

    def redirect_after(self, request):
        ""Perform a redirect to ``target``""
        date = request.params.get('date')
        if date:
            retry_after = str(httputil.format_timestamp(
                    datetime.fromtimestamp(float(date))))
        else:
            retry_after = '1'
        target = request.params.get('target', '/')
        headers = [('Location', target), ('Retry-After', retry_after)]
        return Response(status='303 See Other', headers=headers)

    def shutdown(self, request):
        sys.exit()


# RFC2231-aware replacement of internal tornado function
def _parse_header(line):
    r""""""Parse a Content-type like header.

    Return the main content-type and a dictionary of options.

    >>> d = _parse_header(""CD: fd; foo=\""bar\""; file*=utf-8''T%C3%A4st"")[1]
    >>> d['file'] == 'T\u00e4st'
    True
    >>> d['foo']
    'bar'
    """"""
    import tornado.httputil
    import email.utils
    from urllib3.packages import six
    if not six.PY3:
        line = line.encode('utf-8')
    parts = tornado.httputil._parseparam(';' + line)
    key = next(parts)
    # decode_params treats first argument special, but we already stripped key
    params = [('Dummy', 'value')]
    for p in parts:
        i = p.find('=')
        if i >= 0:
            name = p[:i].strip().lower()
            value = p[i + 1:].strip()
            params.append((name, value))
    params = email.utils.decode_params(params)
    params.pop(0)  # get rid of the dummy again
    pdict = {}
    for name, value in params:
        value = email.utils.collapse_rfc2231_value(value)
        if len(value) >= 2 and value[0] == '""' and value[-1] == '""':
            value = value[1:-1]
        pdict[name] = value
    return key, pdict


# TODO: make the following conditional as soon as we know a version
#       which does not require this fix.
#       See https://github.com/facebook/tornado/issues/868
if True:
    import tornado.httputil
    tornado.httputil._parse_header = _parse_header",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR, VAR='', VAR='200 VAR', VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR [(""VAR-VAR"", ""VAR/VAR"")] VAR VAR(VAR, VAR): VAR, VAR = VAR.VAR.VAR(' ', 1) VAR.VAR(VAR(VAR), VAR) VAR VAR, VAR VAR VAR.VAR: VAR.VAR(VAR, VAR)  VAR VAR(VAR.VAR, VAR): VAR VAR VAR VAR.VAR: VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR.VAR() VAR: VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR 200 VAR VAR, 400 VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR/VAR. """""" VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR.VAR VAR.VAR = {} VAR VAR, VAR VAR VAR.VAR.VAR(): VAR.VAR[VAR] = VAR(VAR(VAR)) VAR = VAR.VAR[:] VAR VAR VAR.VAR('/'): VAR = VAR(VAR).VAR VAR = VAR[1:].VAR('/', 'VAR') VAR = VAR(VAR, VAR, VAR.VAR) VAR = VAR(VAR) VAR VAR(VAR.VAR).VAR('VAR') == 'VAR':  VAR VAR(VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR"" VAR VAR(""VAR VAR!"") VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR."""""" VAR = VAR.VAR() VAR = VAR() VAR VAR VAR VAR VAR: VAR = VAR((VAR, VAR) VAR (VAR, VAR) VAR [VAR VAR VAR VAR VAR['VAR'] VAR VAR VAR VAR]) VAR VAR(VAR.VAR(VAR)) VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR VAR."""""" VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR('VAR') VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR('\VAR VAR %VAR: %VAR' % (VAR, VAR)) VAR: VAR('\VAR VAR %VAR' % VAR) VAR VAR(""VAR VAR VAR VAR!"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR = VAR.VAR.VAR('VAR') VAR VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR VAR.VAR != VAR: VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR""  VAR = VAR.VAR.VAR('VAR', VAR'VAR').VAR('VAR') VAR = VAR.VAR.VAR('VAR', VAR'').VAR('VAR-8') VAR = VAR(VAR.VAR.VAR('VAR', '0')) VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) != 1: VAR VAR(""VAR 1 VAR VAR '%VAR', VAR %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR = VAR[0] VAR = VAR['VAR'] VAR VAR(VAR) != VAR(VAR): VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR VAR != VAR['VAR']: VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', '/') VAR = VAR.VAR.VAR('VAR', '303 VAR VAR') VAR VAR(VAR) == 3: VAR = '%VAR VAR' % VAR.VAR('VAR-1') VAR = [('VAR', VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR('VAR VAR', VAR='404 VAR VAR') VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', VAR'200').VAR('VAR-8') VAR, VAR = VAR.VAR(',', 1) VAR "","" VAR VAR VAR (VAR, VAR) VAR = ""{0} {1}"".VAR(VAR, VAR[VAR(VAR)]) VAR VAR VAR: VAR VAR(""VAR VAR"", VAR=VAR) VAR = [('VAR', '/VAR?VAR=%VAR' % VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR('VAR', VAR'0') == VAR'1': VAR = [('VAR', 'VAR')] VAR VAR('VAR', VAR=VAR) VAR = [('VAR', 'VAR-VAR')] VAR VAR('VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``""   VAR = VAR(VAR.VAR.VAR('VAR', '1')) VAR.VAR(VAR) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR"" VAR VAR.VAR == 'VAR': VAR VAR(VAR.VAR) VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR/VAR VAR"" VAR = VAR""VAR, VAR!"" VAR = VAR.VAR.VAR('VAR-VAR', '') VAR = VAR VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR() VAR VAR.VAR(VAR.VAR('', VAR='VAR', VAR=VAR)) VAR VAR: VAR.VAR(VAR) VAR = VAR.VAR() VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR.VAR(VAR) VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR(VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR(VAR.VAR(VAR(VAR.VAR))) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR', VAR) VAR VAR VAR: VAR VAR(""VAR-VAR VAR VAR VAR"", VAR=""400 VAR VAR"") VAR[VAR] += 1 VAR VAR[VAR] >= 2: VAR VAR(""VAR VAR!"") VAR: VAR VAR(""VAR VAR VAR VAR!"", VAR=""418 VAR'VAR VAR VAR"") VAR VAR(VAR, VAR): VAR VAR(['123'] * 4) VAR VAR(VAR, VAR): VAR = [] VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR VAR VAR [VAR'123'] * 4: VAR.VAR(VAR.VAR(VAR)) VAR.VAR(VAR.VAR()) VAR VAR(VAR, VAR=[('VAR-VAR', 'VAR')]) VAR VAR(VAR, VAR): VAR = VAR(VAR.VAR.VAR('VAR')) VAR = VAR'1' * VAR VAR VAR( VAR, VAR=[('VAR-VAR', 'VAR/VAR-VAR')]) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(""VAR"", ""200 VAR"") VAR VAR(VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR() - VAR.VAR.VAR < VAR(VAR=1): VAR = VAR.VAR.VAR(""VAR"", VAR""429 VAR VAR VAR"") VAR VAR( VAR=VAR.VAR('VAR-8'), VAR=[('VAR-VAR', '1')]) VAR.VAR.VAR = VAR.VAR() VAR VAR(VAR=""200 VAR"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR = VAR(VAR.VAR( VAR.VAR(VAR(VAR)))) VAR: VAR = '1' VAR = VAR.VAR.VAR('VAR', '/') VAR = [('VAR', VAR), ('VAR-VAR', VAR)] VAR VAR(VAR='303 VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): VAR.VAR()  VAR VAR(VAR): VAR""""""VAR VAR VAR-VAR VAR VAR. VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR. >>> VAR = VAR(""VAR: VAR; VAR=\""VAR\""; VAR*=VAR-8''VAR%VAR%VAR"")[1] >>> VAR['VAR'] == 'VAR\VAR' VAR >>> VAR['VAR'] 'VAR' """""" VAR VAR.VAR VAR VAR.VAR VAR VAR.VAR VAR VAR VAR VAR VAR.VAR: VAR = VAR.VAR('VAR-8') VAR = VAR.VAR.VAR(';' + VAR) VAR = VAR(VAR)  VAR = [('VAR', 'VAR')] VAR VAR VAR VAR: VAR = VAR.VAR('=') VAR VAR >= 0: VAR = VAR[:VAR].VAR().VAR() VAR = VAR[VAR + 1:].VAR() VAR.VAR((VAR, VAR)) VAR = VAR.VAR.VAR(VAR) VAR.VAR(0)  VAR = {} VAR VAR, VAR VAR VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) >= 2 VAR VAR[0] == '""' VAR VAR[-1] == '""': VAR = VAR[1:-1] VAR[VAR] = VAR VAR VAR, VAR    VAR VAR: VAR VAR.VAR VAR.VAR.VAR = VAR ",8,16
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,dummyserver/handlers.py,"from __future__ import print_function

import collections
import contextlib
import gzip
import json
import logging
import sys
import time
import zlib

from io import BytesIO
from tornado.web import RequestHandler
from tornado import httputil
from datetime import datetime
from datetime import timedelta

from urllib3.packages.six.moves.http_client import responses
from urllib3.packages.six.moves.urllib.parse import urlsplit
from urllib3.packages.six import binary_type

log = logging.getLogger(__name__)


class Response(object):
    def __init__(self, body='', status='200 OK', headers=None):
        self.body = body
        self.status = status
        self.headers = headers or [(""Content-type"", ""text/plain"")]

    def __call__(self, request_handler):
        status, reason = self.status.split(' ', 1)
        request_handler.set_status(int(status), reason)
        for header, value in self.headers:
            request_handler.add_header(header, value)

        # chunked
        if isinstance(self.body, list):
            for item in self.body:
                if not isinstance(item, bytes):
                    item = item.encode('utf8')
                request_handler.write(item)
                request_handler.flush()
        else:
            body = self.body
            if not isinstance(body, bytes):
                body = body.encode('utf8')

            request_handler.write(body)


RETRY_TEST_NAMES = collections.defaultdict(int)


class TestingApp(RequestHandler):
    """"""
    Simple app that performs various operations, useful for testing an HTTP
    library.

    Given any path, it will attempt to load a corresponding local method if
    it exists. Status code 200 indicates success, 400 indicates failure. Each
    method has its own conditions for success/failure.
    """"""
    def get(self):
        """""" Handle GET requests """"""
        self._call_method()

    def post(self):
        """""" Handle POST requests """"""
        self._call_method()

    def put(self):
        """""" Handle PUT requests """"""
        self._call_method()

    def options(self):
        """""" Handle OPTIONS requests """"""
        self._call_method()

    def head(self):
        """""" Handle HEAD requests """"""
        self._call_method()

    def _call_method(self):
        """""" Call the correct method in this class based on the incoming URI """"""
        req = self.request
        req.params = {}
        for k, v in req.arguments.items():
            req.params[k] = next(iter(v))

        path = req.path[:]
        if not path.startswith('/'):
            path = urlsplit(path).path

        target = path[1:].replace('/', '_')
        method = getattr(self, target, self.index)

        resp = method(req)

        if dict(resp.headers).get('Connection') == 'close':
            # FIXME: Can we kill the connection somehow?
            pass

        resp(self)

    def index(self, _request):
        ""Render simple message""
        return Response(""Dummy server!"")

    def certificate(self, request):
        """"""Return the requester's certificate.""""""
        cert = request.get_ssl_certificate()
        subject = dict()
        if cert is not None:
            subject = dict((k, v) for (k, v) in [y for z in cert['subject']
                                                 for y in z])
        return Response(json.dumps(subject))

    def source_address(self, request):
        """"""Return the requester's IP address.""""""
        return Response(request.remote_ip)

    def set_up(self, request):
        test_type = request.params.get('test_type')
        test_id = request.params.get('test_id')
        if test_id:
            print('\nNew test %s: %s' % (test_type, test_id))
        else:
            print('\nNew test %s' % test_type)
        return Response(""Dummy server is ready!"")

    def specific_method(self, request):
        ""Confirm that the request matches the desired method type""
        method = request.params.get('method')
        if method and not isinstance(method, str):
            method = method.decode('utf8')

        if request.method != method:
            return Response(""Wrong method: %s != %s"" %
                            (method, request.method), status='400 Bad Request')
        return Response()

    def upload(self, request):
        ""Confirm that the uploaded file conforms to specification""
        # FIXME: This is a huge broken mess
        param = request.params.get('upload_param', b'myfile').decode('ascii')
        filename = request.params.get('upload_filename', b'').decode('utf-8')
        size = int(request.params.get('upload_size', '0'))
        files_ = request.files.get(param)

        if len(files_) != 1:
            return Response(""Expected 1 file for '%s', not %d"" % (param, len(files_)),
                            status='400 Bad Request')
        file_ = files_[0]

        data = file_['body']
        if int(size) != len(data):
            return Response(""Wrong size: %d != %d"" %
                            (size, len(data)), status='400 Bad Request')

        got_filename = file_['filename']
        if(isinstance(got_filename, binary_type)):
            got_filename = got_filename.decode('utf-8')

        # Tornado can leave the trailing \n in place on the filename.
        if filename != got_filename:
            return Response(
                u""Wrong filename: %s != %s"" % (filename, file_.filename),
                status='400 Bad Request')

        return Response()

    def redirect(self, request):
        ""Perform a redirect to ``target``""
        target = request.params.get('target', '/')
        status = request.params.get('status', '303 See Other')
        if len(status) == 3:
            status = '%s Redirect' % status.decode('latin-1')

        headers = [('Location', target)]
        return Response(status=status, headers=headers)

    def not_found(self, request):
        return Response('Not found', status='404 Not Found')

    def multi_redirect(self, request):
        ""Performs a redirect chain based on ``redirect_codes``""
        codes = request.params.get('redirect_codes', b'200').decode('utf-8')
        head, tail = codes.split(',', 1) if "","" in codes else (codes, None)
        status = ""{0} {1}"".format(head, responses[int(head)])
        if not tail:
            return Response(""Done redirecting"", status=status)

        headers = [('Location', '/multi_redirect?redirect_codes=%s' % tail)]
        return Response(status=status, headers=headers)

    def keepalive(self, request):
        if request.params.get('close', b'0') == b'1':
            headers = [('Connection', 'close')]
            return Response('Closing', headers=headers)

        headers = [('Connection', 'keep-alive')]
        return Response('Keeping alive', headers=headers)

    def sleep(self, request):
        ""Sleep for a specified amount of ``seconds``""
        # DO NOT USE THIS, IT'S DEPRECATED.
        # FIXME: Delete this once appengine tests are fixed to not use this handler.
        seconds = float(request.params.get('seconds', '1'))
        time.sleep(seconds)
        return Response()

    def echo(self, request):
        ""Echo back the params""
        if request.method == 'GET':
            return Response(request.query)

        return Response(request.body)

    def encodingrequest(self, request):
        ""Check for UA accepting gzip/deflate encoding""
        data = b""hello, world!""
        encoding = request.headers.get('Accept-Encoding', '')
        headers = None
        if encoding == 'gzip':
            headers = [('Content-Encoding', 'gzip')]
            file_ = BytesIO()
            with contextlib.closing(gzip.GzipFile('', mode='w', fileobj=file_)) as zipfile:
                zipfile.write(data)
            data = file_.getvalue()
        elif encoding == 'deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = zlib.compress(data)
        elif encoding == 'garbage-gzip':
            headers = [('Content-Encoding', 'gzip')]
            data = 'garbage'
        elif encoding == 'garbage-deflate':
            headers = [('Content-Encoding', 'deflate')]
            data = 'garbage'
        return Response(data, headers=headers)

    def headers(self, request):
        return Response(json.dumps(dict(request.headers)))

    def successful_retry(self, request):
        """""" Handler which will return an error and then success

        It's not currently very flexible as the number of retries is hard-coded.
        """"""
        test_name = request.headers.get('test-name', None)
        if not test_name:
            return Response(""test-name header not set"",
                            status=""400 Bad Request"")

        RETRY_TEST_NAMES[test_name] += 1

        if RETRY_TEST_NAMES[test_name] >= 2:
            return Response(""Retry successful!"")
        else:
            return Response(""need to keep retrying!"", status=""418 I'm A Teapot"")

    def chunked(self, request):
        return Response(['123'] * 4)

    def chunked_gzip(self, request):
        chunks = []
        compressor = zlib.compressobj(6, zlib.DEFLATED, 16 + zlib.MAX_WBITS)

        for uncompressed in [b'123'] * 4:
            chunks.append(compressor.compress(uncompressed))

        chunks.append(compressor.flush())

        return Response(chunks, headers=[('Content-Encoding', 'gzip')])

    def nbytes(self, request):
        length = int(request.params.get('length'))
        data = b'1' * length
        return Response(
            data,
            headers=[('Content-Type', 'application/octet-stream')])

    def status(self, request):
        status = request.params.get(""status"", ""200 OK"")

        return Response(status=status)

    def retry_after(self, request):
        if datetime.now() - self.application.last_req < timedelta(seconds=1):
            status = request.params.get(""status"", b""429 Too Many Requests"")
            return Response(
                    status=status.decode('utf-8'),
                    headers=[('Retry-After', '1')])

        self.application.last_req = datetime.now()

        return Response(status=""200 OK"")

    def redirect_after(self, request):
        ""Perform a redirect to ``target``""
        date = request.params.get('date')
        if date:
            retry_after = str(httputil.format_timestamp(
                    datetime.fromtimestamp(float(date))))
        else:
            retry_after = '1'
        target = request.params.get('target', '/')
        headers = [('Location', target), ('Retry-After', retry_after)]
        return Response(status='303 See Other', headers=headers)

    def shutdown(self, request):
        sys.exit()",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR.VAR.VAR.VAR VAR VAR VAR VAR.VAR.VAR VAR VAR VAR = VAR.VAR(VAR) VAR VAR(VAR): VAR VAR(VAR, VAR='', VAR='200 VAR', VAR=VAR): VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR [(""VAR-VAR"", ""VAR/VAR"")] VAR VAR(VAR, VAR): VAR, VAR = VAR.VAR.VAR(' ', 1) VAR.VAR(VAR(VAR), VAR) VAR VAR, VAR VAR VAR.VAR: VAR.VAR(VAR, VAR)  VAR VAR(VAR.VAR, VAR): VAR VAR VAR VAR.VAR: VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR.VAR() VAR: VAR = VAR.VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR.VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR 200 VAR VAR, 400 VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR/VAR. """""" VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR """""" VAR.VAR() VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR = VAR.VAR VAR.VAR = {} VAR VAR, VAR VAR VAR.VAR.VAR(): VAR.VAR[VAR] = VAR(VAR(VAR)) VAR = VAR.VAR[:] VAR VAR VAR.VAR('/'): VAR = VAR(VAR).VAR VAR = VAR[1:].VAR('/', 'VAR') VAR = VAR(VAR, VAR, VAR.VAR) VAR = VAR(VAR) VAR VAR(VAR.VAR).VAR('VAR') == 'VAR':  VAR VAR(VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR"" VAR VAR(""VAR VAR!"") VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR."""""" VAR = VAR.VAR() VAR = VAR() VAR VAR VAR VAR VAR: VAR = VAR((VAR, VAR) VAR (VAR, VAR) VAR [VAR VAR VAR VAR VAR['VAR'] VAR VAR VAR VAR]) VAR VAR(VAR.VAR(VAR)) VAR VAR(VAR, VAR): """"""VAR VAR VAR'VAR VAR VAR."""""" VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR('VAR') VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR('\VAR VAR %VAR: %VAR' % (VAR, VAR)) VAR: VAR('\VAR VAR %VAR' % VAR) VAR VAR(""VAR VAR VAR VAR!"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR VAR"" VAR = VAR.VAR.VAR('VAR') VAR VAR VAR VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR VAR.VAR != VAR: VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR VAR VAR""  VAR = VAR.VAR.VAR('VAR', VAR'VAR').VAR('VAR') VAR = VAR.VAR.VAR('VAR', VAR'').VAR('VAR-8') VAR = VAR(VAR.VAR.VAR('VAR', '0')) VAR = VAR.VAR.VAR(VAR) VAR VAR(VAR) != 1: VAR VAR(""VAR 1 VAR VAR '%VAR', VAR %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR = VAR[0] VAR = VAR['VAR'] VAR VAR(VAR) != VAR(VAR): VAR VAR(""VAR VAR: %VAR != %VAR"" % (VAR, VAR(VAR)), VAR='400 VAR VAR') VAR = VAR['VAR'] VAR(VAR(VAR, VAR)): VAR = VAR.VAR('VAR-8')  VAR VAR != VAR: VAR VAR( VAR""VAR VAR: %VAR != %VAR"" % (VAR, VAR.VAR), VAR='400 VAR VAR') VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', '/') VAR = VAR.VAR.VAR('VAR', '303 VAR VAR') VAR VAR(VAR) == 3: VAR = '%VAR VAR' % VAR.VAR('VAR-1') VAR = [('VAR', VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR('VAR VAR', VAR='404 VAR VAR') VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR', VAR'200').VAR('VAR-8') VAR, VAR = VAR.VAR(',', 1) VAR "","" VAR VAR VAR (VAR, VAR) VAR = ""{0} {1}"".VAR(VAR, VAR[VAR(VAR)]) VAR VAR VAR: VAR VAR(""VAR VAR"", VAR=VAR) VAR = [('VAR', '/VAR?VAR=%VAR' % VAR)] VAR VAR(VAR=VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR.VAR('VAR', VAR'0') == VAR'1': VAR = [('VAR', 'VAR')] VAR VAR('VAR', VAR=VAR) VAR = [('VAR', 'VAR-VAR')] VAR VAR('VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR VAR ``VAR``""   VAR = VAR(VAR.VAR.VAR('VAR', '1')) VAR.VAR(VAR) VAR VAR() VAR VAR(VAR, VAR): ""VAR VAR VAR VAR"" VAR VAR.VAR == 'VAR': VAR VAR(VAR.VAR) VAR VAR(VAR.VAR) VAR VAR(VAR, VAR): ""VAR VAR VAR VAR VAR/VAR VAR"" VAR = VAR""VAR, VAR!"" VAR = VAR.VAR.VAR('VAR-VAR', '') VAR = VAR VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR() VAR VAR.VAR(VAR.VAR('', VAR='VAR', VAR=VAR)) VAR VAR: VAR.VAR(VAR) VAR = VAR.VAR() VAR VAR == 'VAR': VAR = [('VAR-VAR', 'VAR')] VAR = VAR.VAR(VAR) VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR == 'VAR-VAR': VAR = [('VAR-VAR', 'VAR')] VAR = 'VAR' VAR VAR(VAR, VAR=VAR) VAR VAR(VAR, VAR): VAR VAR(VAR.VAR(VAR(VAR.VAR))) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR. """""" VAR = VAR.VAR.VAR('VAR-VAR', VAR) VAR VAR VAR: VAR VAR(""VAR-VAR VAR VAR VAR"", VAR=""400 VAR VAR"") VAR[VAR] += 1 VAR VAR[VAR] >= 2: VAR VAR(""VAR VAR!"") VAR: VAR VAR(""VAR VAR VAR VAR!"", VAR=""418 VAR'VAR VAR VAR"") VAR VAR(VAR, VAR): VAR VAR(['123'] * 4) VAR VAR(VAR, VAR): VAR = [] VAR = VAR.VAR(6, VAR.VAR, 16 + VAR.VAR) VAR VAR VAR [VAR'123'] * 4: VAR.VAR(VAR.VAR(VAR)) VAR.VAR(VAR.VAR()) VAR VAR(VAR, VAR=[('VAR-VAR', 'VAR')]) VAR VAR(VAR, VAR): VAR = VAR(VAR.VAR.VAR('VAR')) VAR = VAR'1' * VAR VAR VAR( VAR, VAR=[('VAR-VAR', 'VAR/VAR-VAR')]) VAR VAR(VAR, VAR): VAR = VAR.VAR.VAR(""VAR"", ""200 VAR"") VAR VAR(VAR=VAR) VAR VAR(VAR, VAR): VAR VAR.VAR() - VAR.VAR.VAR < VAR(VAR=1): VAR = VAR.VAR.VAR(""VAR"", VAR""429 VAR VAR VAR"") VAR VAR( VAR=VAR.VAR('VAR-8'), VAR=[('VAR-VAR', '1')]) VAR.VAR.VAR = VAR.VAR() VAR VAR(VAR=""200 VAR"") VAR VAR(VAR, VAR): ""VAR VAR VAR VAR ``VAR``"" VAR = VAR.VAR.VAR('VAR') VAR VAR: VAR = VAR(VAR.VAR( VAR.VAR(VAR(VAR)))) VAR: VAR = '1' VAR = VAR.VAR.VAR('VAR', '/') VAR = [('VAR', VAR), ('VAR-VAR', VAR)] VAR VAR(VAR='303 VAR VAR', VAR=VAR) VAR VAR(VAR, VAR): VAR.VAR() ",8,16

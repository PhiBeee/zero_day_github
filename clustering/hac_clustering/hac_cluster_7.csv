commit,file,added_code,deleted_code,hash_clean,cve_id,hash,repo_url,rel_type,score,extraction_status,text_norm,cluster_kmeans,cluster_hac
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,frontend/src/pages/404.jsx,"import Header from ""../components/Header"";
import Footer from ""../components/Footer"";

export default function Contact() {
  return (
    <div className=""text-black"">
      <Header />
      <div className=""flex flex-col justify-center mx-auto mt-52 text-center max-w-2x1"">
        <h1 className=""text-3xl font-bold tracking-tight text-black md:text-5xl"">
          404 – Unavailable
        </h1>
        <br />
        <a
          className=""w-64 p-1 mx-auto font-bold text-center text-black border border-gray-500 rounded-lg sm:p-4""
          href=""/""
        >
          Return Home
        </a>
      </div>
      <div className=""mt-64""></div>
      <Footer />
    </div>
  );
}",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-VAR""> <VAR /> <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-52 VAR-VAR VAR-VAR-2x1""> <VAR VAR=""VAR-3xl VAR-VAR VAR-VAR VAR-VAR VAR:VAR-5xl""> 404 – VAR </VAR> <VAR /> <VAR VAR=""VAR-64 VAR-1 VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR VAR-VAR-500 VAR-VAR VAR:VAR-4"" VAR=""/"" > VAR VAR </VAR> </VAR> <VAR VAR=""VAR-64""></VAR> <VAR /> </VAR> ); } ",10,7
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/pages/404.jsx,"import Header from ""../components/Header"";
import Footer from ""../components/Footer"";

export default function Contact() {
  return (
    <div className=""text-black"">
      <Header />
      <div className=""flex flex-col justify-center mx-auto mt-52 text-center max-w-2x1"">
        <h1 className=""text-3xl font-bold tracking-tight text-black md:text-5xl"">
          404 – Unavailable
        </h1>
        <br />
        <a
          className=""w-64 p-1 mx-auto font-bold text-center text-black border border-gray-500 rounded-lg sm:p-4""
          href=""/""
        >
          Return Home
        </a>
      </div>
      <div className=""mt-64""></div>
      <Footer />
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-VAR""> <VAR /> <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-52 VAR-VAR VAR-VAR-2x1""> <VAR VAR=""VAR-3xl VAR-VAR VAR-VAR VAR-VAR VAR:VAR-5xl""> 404 – VAR </VAR> <VAR /> <VAR VAR=""VAR-64 VAR-1 VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR VAR-VAR-500 VAR-VAR VAR:VAR-4"" VAR=""/"" > VAR VAR </VAR> </VAR> <VAR VAR=""VAR-64""></VAR> <VAR /> </VAR> ); } ",10,7
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,frontend/src/pages/404.jsx,"import Header from ""../components/Header"";
import Footer from ""../components/Footer"";

export default function Contact() {
  return (
    <div className=""text-black"">
      <Header />
      <div className=""flex flex-col justify-center mx-auto mt-52 text-center max-w-2x1"">
        <h1 className=""text-3xl font-bold tracking-tight text-black md:text-5xl"">
          404 – Unavailable
        </h1>
        <br />
        <a
          className=""w-64 p-1 mx-auto font-bold text-center text-black border border-gray-500 rounded-lg sm:p-4""
          href=""/""
        >
          Return Home
        </a>
      </div>
      <div className=""mt-64""></div>
      <Footer />
    </div>
  );
}",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR ""../VAR/VAR""; VAR VAR VAR VAR() { VAR ( <VAR VAR=""VAR-VAR""> <VAR /> <VAR VAR=""VAR VAR-VAR VAR-VAR VAR-VAR VAR-52 VAR-VAR VAR-VAR-2x1""> <VAR VAR=""VAR-3xl VAR-VAR VAR-VAR VAR-VAR VAR:VAR-5xl""> 404 – VAR </VAR> <VAR /> <VAR VAR=""VAR-64 VAR-1 VAR-VAR VAR-VAR VAR-VAR VAR-VAR VAR VAR-VAR-500 VAR-VAR VAR:VAR-4"" VAR=""/"" > VAR VAR </VAR> </VAR> <VAR VAR=""VAR-64""></VAR> <VAR /> </VAR> ); } ",10,7
envoy_2d69e30c51f2418faf267aaa6c1126fce9948c62,bazel/external/icuuc.BUILD,"load(""@rules_cc//cc:defs.bzl"", ""cc_library"")

licenses([""notice""])  # Apache 2

exports_files([
    ""icu4c/LICENSE"",
    ""icu4j/main/shared/licenses/LICENSE"",
])

icuuc_copts = [
    ""-DU_STATIC_IMPLEMENTATION"",
    ""-DU_COMMON_IMPLEMENTATION"",
    ""-DU_HAVE_STD_ATOMICS"",
] + select({
    ""@envoy//bazel:apple"": [
        ""-Wno-shorten-64-to-32"",
        ""-Wno-unused-variable"",
    ],
    ""@envoy//bazel:windows_x86_64"": [
        ""/utf-8"",
        ""/DLOCALE_ALLOW_NEUTRAL_NAMES=0"",
    ],
    # TODO(dio): Add ""@envoy//bazel:android"" when we have it.
    # ""@envoy//bazel:android"": [
    #     ""-fdata-sections"",
    #     ""-DU_HAVE_NL_LANGINFO_CODESET=0"",
    #     ""-Wno-deprecated-declarations"",
    # ],
    ""//conditions:default"": [],
})

cc_library(
    name = ""headers"",
    hdrs = glob([""icu4c/source/common/unicode/*.h""]),
    includes = [""icu4c/source/common""],
    visibility = [""//visibility:public""],
)

cc_library(
    name = ""common"",
    hdrs = glob([""icu4c/source/common/unicode/*.h""]),
    includes = [""icu4c/source/common""],
    visibility = [""//visibility:public""],
    deps = ["":icuuc""],
)

cc_library(
    name = ""icuuc"",
    srcs = glob([
        ""icu4c/source/common/*.c"",
        ""icu4c/source/common/*.cpp"",
        ""icu4c/source/stubdata/*.cpp"",
    ]),
    hdrs = glob([""icu4c/source/common/*.h""]),
    copts = icuuc_copts,
    tags = [""requires-rtti""],
    visibility = [""//visibility:private""],
    deps = ["":headers""],
)",,2d69e30c51f2418faf267aaa6c1126fce9948c62,CVE-2020-25018,2d69e30c51f2418faf267aaa6c1126fce9948c62,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED,"VAR(""@VAR VAR([""VAR""])  VAR([ ""VAR/VAR"", ""VAR/VAR/VAR/VAR/VAR"", ]) VAR = [ ""-VAR"", ""-VAR"", ""-VAR"", ] + VAR({ ""@VAR ""-VAR-VAR-64-VAR-32"", ""-VAR-VAR-VAR"", ], ""@VAR ""/VAR-8"", ""/VAR=0"", ],       "" }) VAR( VAR = ""VAR"", VAR = VAR([""VAR/VAR/VAR/VAR/*.VAR""]), VAR = [""VAR/VAR/VAR""], VAR = ["" ) VAR( VAR = ""VAR"", VAR = VAR([""VAR/VAR/VAR/VAR/*.VAR""]), VAR = [""VAR/VAR/VAR""], VAR = ["" VAR = ["":VAR""], ) VAR( VAR = ""VAR"", VAR = VAR([ ""VAR/VAR/VAR/*.VAR"", ""VAR/VAR/VAR/*.VAR"", ""VAR/VAR/VAR/*.VAR"", ]), VAR = VAR([""VAR/VAR/VAR/*.VAR""]), VAR = VAR, VAR = [""VAR-VAR""], VAR = ["" VAR = ["":VAR""], ) ",10,7
envoy_2d69e30c51f2418faf267aaa6c1126fce9948c62,bazel/repository_locations.bzl,"    org_unicode_icuuc = dict(
        strip_prefix = ""icu-release-64-2"",
        sha256 = ""524960ac99d086cdb6988d2a92fc163436fd3c6ec0a84c475c6382fbf989be05"",
        urls = [""https://github.com/unicode-org/icu/archive/release-64-2.tar.gz""],
        use_category = [""dataplane""],
        cpe = ""cpe:2.3:a:icu-project:international_components_for_unicode"",
    ),",,2d69e30c51f2418faf267aaa6c1126fce9948c62,CVE-2020-25018,2d69e30c51f2418faf267aaa6c1126fce9948c62,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED,"VAR = VAR( VAR = ""VAR-VAR-64-2"", VAR = ""524960ac99d086cdb6988d2a92fc163436fd3c6ec0a84c475c6382fbf989be05"", VAR = [""VAR: VAR = [""VAR""], VAR = ""VAR:2.3:VAR:VAR-VAR:VAR"", ), ",10,7
envoy_3b5acb2f43548862dadb243de7cf3994986a8e04,bazel/external/icuuc.BUILD,,"load(""@rules_cc//cc:defs.bzl"", ""cc_library"")

licenses([""notice""])  # Apache 2

exports_files([""LICENSE""])

icuuc_copts = [
    ""-DU_STATIC_IMPLEMENTATION"",
    ""-DU_COMMON_IMPLEMENTATION"",
    ""-DU_HAVE_STD_ATOMICS"",
] + select({
    ""@envoy//bazel:apple"": [
        ""-Wno-shorten-64-to-32"",
        ""-Wno-unused-variable"",
    ],
    ""@envoy//bazel:windows_x86_64"": [
        ""/utf-8"",
        ""/DLOCALE_ALLOW_NEUTRAL_NAMES=0"",
    ],
    # TODO(dio): Add ""@envoy//bazel:android"" when we have it.
    # ""@envoy//bazel:android"": [
    #     ""-fdata-sections"",
    #     ""-DU_HAVE_NL_LANGINFO_CODESET=0"",
    #     ""-Wno-deprecated-declarations"",
    # ],
    ""//conditions:default"": [],
})

cc_library(
    name = ""headers"",
    hdrs = glob([""source/common/unicode/*.h""]),
    includes = [""source/common""],
    visibility = [""//visibility:public""],
)

cc_library(
    name = ""common"",
    hdrs = glob([""source/common/unicode/*.h""]),
    includes = [""source/common""],
    visibility = [""//visibility:public""],
    deps = ["":icuuc""],
)

cc_library(
    name = ""icuuc"",
    srcs = glob([
        ""source/common/*.c"",
        ""source/common/*.cpp"",
        ""source/stubdata/*.cpp"",
    ]),
    hdrs = glob([""source/common/*.h""]),
    copts = icuuc_copts,
    visibility = [""//visibility:private""],
    deps = ["":headers""],
)",3b5acb2f43548862dadb243de7cf3994986a8e04,CVE-2020-25018,3b5acb2f43548862dadb243de7cf3994986a8e04,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,90,COMPLETED," VAR(""@VAR VAR([""VAR""])  VAR([""VAR""]) VAR = [ ""-VAR"", ""-VAR"", ""-VAR"", ] + VAR({ ""@VAR ""-VAR-VAR-64-VAR-32"", ""-VAR-VAR-VAR"", ], ""@VAR ""/VAR-8"", ""/VAR=0"", ],       "" }) VAR( VAR = ""VAR"", VAR = VAR([""VAR/VAR/VAR/*.VAR""]), VAR = [""VAR/VAR""], VAR = ["" ) VAR( VAR = ""VAR"", VAR = VAR([""VAR/VAR/VAR/*.VAR""]), VAR = [""VAR/VAR""], VAR = ["" VAR = ["":VAR""], ) VAR( VAR = ""VAR"", VAR = VAR([ ""VAR/VAR/*.VAR"", ""VAR/VAR/*.VAR"", ""VAR/VAR/*.VAR"", ]), VAR = VAR([""VAR/VAR/*.VAR""]), VAR = VAR, VAR = ["" VAR = ["":VAR""], )",10,7
FFmpeg_5aba5b89d0b1d73164d3b81764828bb8b20ff32a,libavcodec/mpeg4videodec.c,"static int read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
        if (get_bits_left(gb) < 64*8)
            return AVERROR_INVALIDDATA;
    return 0;","static void read_quant_matrix_ext(MpegEncContext *s, GetBitContext *gb)",5aba5b89d0b1d73164d3b81764828bb8b20ff32a,CVE-2018-1999015,5aba5b89d0b1d73164d3b81764828bb8b20ff32a,https://github.com/FFmpeg/FFmpeg,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR *VAR, VAR *VAR) VAR (VAR(VAR) < 64*8) VAR VAR; VAR (VAR(VAR) < 64*8) VAR VAR; VAR (VAR(VAR) < 64*8) VAR VAR; VAR (VAR(VAR) < 64*8) VAR VAR; VAR 0; VAR VAR VAR(VAR *VAR, VAR *VAR)",10,7
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/mpegvideo.c,"#include ""libavutil/avassert.h""
    pic->tf.f = &pic->f;
        r = ff_thread_get_buffer(s->avctx, &pic->tf,
                                 pic->reference ? AV_GET_BUFFER_FLAG_REF : 0);
    else {
        pic->f.width  = s->avctx->width;
        pic->f.height = s->avctx->height;
        pic->f.format = s->avctx->pix_fmt;
        r = avcodec_default_get_buffer2(s->avctx, &pic->f, 0);
    }

    if (r < 0 || !pic->f.data[0]) {
        av_log(s->avctx, AV_LOG_ERROR, ""get_buffer() failed (%d %p)\n"",
               r, pic->f.data[0]);
        ff_mpeg_unref_picture(s, pic);
        ff_mpeg_unref_picture(s, pic);
        ff_mpeg_unref_picture(s, pic);
static void free_picture_tables(Picture *pic)
    int i;
    av_buffer_unref(&pic->mb_var_buf);
    av_buffer_unref(&pic->mc_mb_var_buf);
    av_buffer_unref(&pic->mb_mean_buf);
    av_buffer_unref(&pic->mbskip_table_buf);
    av_buffer_unref(&pic->qscale_table_buf);
    av_buffer_unref(&pic->mb_type_buf);
    for (i = 0; i < 2; i++) {
        av_buffer_unref(&pic->motion_val_buf[i]);
        av_buffer_unref(&pic->ref_index_buf[i]);
    }
}

static int alloc_picture_tables(MpegEncContext *s, Picture *pic)
{
    const int big_mb_num    = s->mb_stride * (s->mb_height + 1) + 1;


    pic->mbskip_table_buf = av_buffer_allocz(mb_array_size + 2);
    pic->qscale_table_buf = av_buffer_allocz(big_mb_num + s->mb_stride);
    pic->mb_type_buf      = av_buffer_allocz((big_mb_num + s->mb_stride) *
                                             sizeof(uint32_t));
    if (!pic->mbskip_table_buf || !pic->qscale_table_buf || !pic->mb_type_buf)
        return AVERROR(ENOMEM);

    if (s->encoding) {
        pic->mb_var_buf    = av_buffer_allocz(mb_array_size * sizeof(int16_t));
        pic->mc_mb_var_buf = av_buffer_allocz(mb_array_size * sizeof(int16_t));
        pic->mb_mean_buf   = av_buffer_allocz(mb_array_size);
        if (!pic->mb_var_buf || !pic->mc_mb_var_buf || !pic->mb_mean_buf)
            return AVERROR(ENOMEM);
    }

    if (s->out_format == FMT_H263 || s->encoding ||
               (s->avctx->debug & FF_DEBUG_MV) || s->avctx->debug_mv) {
        int mv_size        = 2 * (b8_array_size + 4) * sizeof(int16_t);
        int ref_index_size = 4 * mb_array_size;

        for (i = 0; mv_size && i < 2; i++) {
            pic->motion_val_buf[i] = av_buffer_allocz(mv_size);
            pic->ref_index_buf[i]  = av_buffer_allocz(ref_index_size);
            if (!pic->motion_val_buf[i] || !pic->ref_index_buf[i])
                return AVERROR(ENOMEM);
        }
    }

    return 0;
}

static int make_tables_writable(Picture *pic)
{
    int ret, i;
#define MAKE_WRITABLE(table) \
do {\
    if (pic->table &&\
       (ret = av_buffer_make_writable(&pic->table)) < 0)\
    return ret;\
} while (0)

    MAKE_WRITABLE(mb_var_buf);
    MAKE_WRITABLE(mc_mb_var_buf);
    MAKE_WRITABLE(mb_mean_buf);
    MAKE_WRITABLE(mbskip_table_buf);
    MAKE_WRITABLE(qscale_table_buf);
    MAKE_WRITABLE(mb_type_buf);

    for (i = 0; i < 2; i++) {
        MAKE_WRITABLE(motion_val_buf[i]);
        MAKE_WRITABLE(ref_index_buf[i]);
    }

    return 0;
}

/**
 * Allocate a Picture.
 * The pixels are allocated/set by calling get_buffer() if shared = 0
 */
int ff_alloc_picture(MpegEncContext *s, Picture *pic, int shared)
{
    int i, ret;
        pic->shared = 1;
    if (!pic->qscale_table_buf)
        ret = alloc_picture_tables(s, pic);
    else
        ret = make_tables_writable(pic);
    if (ret < 0)
        goto fail;
    if (s->encoding) {
        pic->mb_var    = (uint16_t*)pic->mb_var_buf->data;
        pic->mc_mb_var = (uint16_t*)pic->mc_mb_var_buf->data;
        pic->mb_mean   = pic->mb_mean_buf->data;
    pic->mbskip_table = pic->mbskip_table_buf->data;
    pic->qscale_table = pic->qscale_table_buf->data + 2 * s->mb_stride + 1;
    pic->mb_type      = (uint32_t*)pic->mb_type_buf->data + 2 * s->mb_stride + 1;

    if (pic->motion_val_buf[0]) {
        for (i = 0; i < 2; i++) {
            pic->motion_val[i] = (int16_t (*)[2])pic->motion_val_buf[i]->data + 4;
            pic->ref_index[i]  = pic->ref_index_buf[i]->data;
        }
    }
fail:
    av_log(s->avctx, AV_LOG_ERROR, ""Error allocating a picture.\n"");
    ff_mpeg_unref_picture(s, pic);
    free_picture_tables(pic);
    return AVERROR(ENOMEM);
void ff_mpeg_unref_picture(MpegEncContext *s, Picture *pic)
    int off = offsetof(Picture, mb_mean) + sizeof(pic->mb_mean);

    pic->tf.f = &pic->f;
    /* WM Image / Screen codecs allocate internal buffers with different
     * dimensions / colorspaces; ignore user-defined callbacks for these. */
    if (s->codec_id != AV_CODEC_ID_WMV3IMAGE &&
        s->codec_id != AV_CODEC_ID_VC1IMAGE  &&
        s->codec_id != AV_CODEC_ID_MSS2)
        ff_thread_release_buffer(s->avctx, &pic->tf);
    else
        av_frame_unref(&pic->f);

    av_buffer_unref(&pic->hwaccel_priv_buf);
    memset((uint8_t*)pic + off, 0, sizeof(*pic) - off);
}

static int update_picture_tables(Picture *dst, Picture *src)
{
     int i;

#define UPDATE_TABLE(table)\
do {\
    if (src->table &&\
        (!dst->table || dst->table->buffer != src->table->buffer)) {\
        av_buffer_unref(&dst->table);\
        dst->table = av_buffer_ref(src->table);\
        if (!dst->table) {\
            free_picture_tables(dst);\
            return AVERROR(ENOMEM);\
        }\
    }\
} while (0)

    UPDATE_TABLE(mb_var_buf);
    UPDATE_TABLE(mc_mb_var_buf);
    UPDATE_TABLE(mb_mean_buf);
    UPDATE_TABLE(mbskip_table_buf);
    UPDATE_TABLE(qscale_table_buf);
    UPDATE_TABLE(mb_type_buf);
        UPDATE_TABLE(motion_val_buf[i]);
        UPDATE_TABLE(ref_index_buf[i]);
    dst->mb_var        = src->mb_var;
    dst->mc_mb_var     = src->mc_mb_var;
    dst->mb_mean       = src->mb_mean;
    dst->mbskip_table  = src->mbskip_table;
    dst->qscale_table  = src->qscale_table;
    dst->mb_type       = src->mb_type;
    for (i = 0; i < 2; i++) {
        dst->motion_val[i] = src->motion_val[i];
        dst->ref_index[i]  = src->ref_index[i];

    return 0;
}

int ff_mpeg_ref_picture(MpegEncContext *s, Picture *dst, Picture *src)
{
    int ret;

    av_assert0(!dst->f.buf[0]);
    av_assert0(src->f.buf[0]);

    src->tf.f = &src->f;
    dst->tf.f = &dst->f;
    ret = ff_thread_ref_frame(&dst->tf, &src->tf);
    if (ret < 0)
        goto fail;

    ret = update_picture_tables(dst, src);
    if (ret < 0)
        goto fail;

    if (src->hwaccel_picture_private) {
        dst->hwaccel_priv_buf = av_buffer_ref(src->hwaccel_priv_buf);
        if (!dst->hwaccel_priv_buf)
            goto fail;
        dst->hwaccel_picture_private = dst->hwaccel_priv_buf->data;
    }

    dst->field_picture           = src->field_picture;
    dst->mb_var_sum              = src->mb_var_sum;
    dst->mc_mb_var_sum           = src->mc_mb_var_sum;
    dst->b_frame_score           = src->b_frame_score;
    dst->needs_realloc           = src->needs_realloc;
    dst->reference               = src->reference;
    dst->shared                  = src->shared;

    return 0;
fail:
    ff_mpeg_unref_picture(s, dst);
    return ret;
    int i, ret;
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        ff_mpeg_unref_picture(s, &s->picture[i]);
        if (s1->picture[i].f.data[0] &&
            (ret = ff_mpeg_ref_picture(s, &s->picture[i], &s1->picture[i])) < 0)
            return ret;
    }

#define UPDATE_PICTURE(pic)\
do {\
    ff_mpeg_unref_picture(s, &s->pic);\
    if (s1->pic.f.data[0])\
        ret = ff_mpeg_ref_picture(s, &s->pic, &s1->pic);\
    else\
        ret = update_picture_tables(&s->pic, &s1->pic);\
    if (ret < 0)\
        return ret;\
} while (0)

    UPDATE_PICTURE(current_picture);
    UPDATE_PICTURE(last_picture);
    UPDATE_PICTURE(next_picture);
                      MAX_PICTURE_COUNT * sizeof(Picture), fail);
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
    memset(&s->next_picture, 0, sizeof(s->next_picture));
    memset(&s->last_picture, 0, sizeof(s->last_picture));
    memset(&s->current_picture, 0, sizeof(s->current_picture));
    avcodec_get_frame_defaults(&s->next_picture.f);
    avcodec_get_frame_defaults(&s->last_picture.f);
    avcodec_get_frame_defaults(&s->current_picture.f);
    if ((err = free_context_frame(s)) < 0)
        return err;
        for (i = 0; i < MAX_PICTURE_COUNT; i++) {
    if (s->picture) {
        for (i = 0; i < MAX_PICTURE_COUNT; i++) {
            free_picture_tables(&s->picture[i]);
            ff_mpeg_unref_picture(s, &s->picture[i]);
    free_picture_tables(&s->last_picture);
    ff_mpeg_unref_picture(s, &s->last_picture);
    free_picture_tables(&s->current_picture);
    ff_mpeg_unref_picture(s, &s->current_picture);
    free_picture_tables(&s->next_picture);
    ff_mpeg_unref_picture(s, &s->next_picture);
    free_picture_tables(&s->new_picture);
    ff_mpeg_unref_picture(s, &s->new_picture);
    for (i = 0; i < MAX_PICTURE_COUNT; i++) {
        if (!s->picture[i].reference &&
            (remove_current || &s->picture[i] !=  s->current_picture_ptr)) {
            ff_mpeg_unref_picture(s, &s->picture[i]);
    if (pic->needs_realloc && !(pic->reference & DELAYED_PIC_REF))
        return 1;
        for (i = 0; i < MAX_PICTURE_COUNT; i++) {
            if (s->picture[i].f.data[0] == NULL)
        for (i = 0; i < MAX_PICTURE_COUNT; i++) {
    if (ret >= 0 && ret < MAX_PICTURE_COUNT) {
            free_picture_tables(&s->picture[ret]);
            ff_mpeg_unref_picture(s, &s->picture[ret]);
    int i, ret;
            ff_mpeg_unref_picture(s, s->last_picture_ptr);
            for (i = 0; i < MAX_PICTURE_COUNT; i++) {
                if (&s->picture[i] != s->last_picture_ptr &&
                    s->picture[i].reference && !s->picture[i].needs_realloc) {
                    ff_mpeg_unref_picture(s, &s->picture[i]);
        pic->reference = 0;
                pic->reference = s->picture_structure;
                pic->reference = 3;
    ff_mpeg_unref_picture(s, &s->current_picture);
    if ((ret = ff_mpeg_ref_picture(s, &s->current_picture,
                                   s->current_picture_ptr)) < 0)
        return ret;
    if (s->codec_id != AV_CODEC_ID_H264 && s->pict_type != AV_PICTURE_TYPE_B) {
            ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 0);
            ff_thread_report_progress(&s->last_picture_ptr->tf, INT_MAX, 1);
            ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 0);
            ff_thread_report_progress(&s->next_picture_ptr->tf, INT_MAX, 1);
    if (s->codec_id != AV_CODEC_ID_H264) {
        if (s->last_picture_ptr) {
            ff_mpeg_unref_picture(s, &s->last_picture);
            if (s->last_picture_ptr->f.data[0] &&
                (ret = ff_mpeg_ref_picture(s, &s->last_picture,
                                           s->last_picture_ptr)) < 0)
                return ret;
        }
        if (s->next_picture_ptr) {
            ff_mpeg_unref_picture(s, &s->next_picture);
            if (s->next_picture_ptr->f.data[0] &&
                (ret = ff_mpeg_ref_picture(s, &s->next_picture,
                                           s->next_picture_ptr)) < 0)
                return ret;
        }
        assert(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&
                                                     s->last_picture_ptr->f.data[0]));
              s->current_picture.reference &&
        for (i = 0; i < MAX_PICTURE_COUNT; i++) {
            if (!s->picture[i].reference)
                ff_mpeg_unref_picture(s, &s->picture[i]);
    if (s->codec_id != AV_CODEC_ID_H264 && s->current_picture.reference)
        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);
void ff_print_debug_info(MpegEncContext *s, Picture *p)
    AVFrame *pict;
    if (s->avctx->hwaccel || !p || !p->mb_type)
    pict = &p->f;
                           p->qscale_table[x + y * s->mb_stride]);
                    int mb_type = p->mb_type[x + y * s->mb_stride];
                if ((s->avctx->debug_mv) && p->motion_val) {
                        if (!USES_LIST(p->mb_type[mb_index], direction))
                        if (IS_8X8(p->mb_type[mb_index])) {
                                int mx = (p->motion_val[direction][xy][0] >> shift) + sx;
                                int my = (p->motion_val[direction][xy][1] >> shift) + sy;
                        } else if (IS_16X8(p->mb_type[mb_index])) {
                                int mx = (p->motion_val[direction][xy][0] >> shift);
                                int my = (p->motion_val[direction][xy][1] >> shift);
                                if (IS_INTERLACED(p->mb_type[mb_index]))
                        } else if (IS_8X16(p->mb_type[mb_index])) {
                                int mx = p->motion_val[direction][xy][0] >> shift;
                                int my = p->motion_val[direction][xy][1] >> shift;
                                if (IS_INTERLACED(p->mb_type[mb_index]))
                              int mx = p->motion_val[direction][xy][0] >> shift + sx;
                              int my = p->motion_val[direction][xy][1] >> shift + sy;
                if ((s->avctx->debug & FF_DEBUG_VIS_QP) && p->motion_val) {
                    uint64_t c = (p->qscale_table[mb_index] * 128 / 31) *
                    p->motion_val) {
                    int mb_type = p->mb_type[mb_index];
                            int32_t *mv = (int32_t *) &p->motion_val[0][xy];
       /* print DCT coefficients */
               av_log(s->avctx, AV_LOG_DEBUG, ""%5d"", block[i][s->dsp.idct_permutation[j]]);
    s->current_picture.qscale_table[mb_xy] = s->qscale;
            } else if(!s->current_picture.reference) {
                        ff_thread_await_progress(&s->last_picture_ptr->tf,
                        ff_thread_await_progress(&s->next_picture_ptr->tf,
        cur->reference &&
    for (i = 0; i < MAX_PICTURE_COUNT; i++)
        ff_mpeg_unref_picture(s, &s->picture[i]);
        ff_thread_report_progress(&s->current_picture_ptr->tf, s->mb_y, 0);","void ff_copy_picture(Picture *dst, Picture *src)
{
    *dst = *src;
    dst->f.type = FF_BUFFER_TYPE_COPY;
}

/**
 * Release a frame buffer
 */
static void free_frame_buffer(MpegEncContext *s, Picture *pic)
{
    /* WM Image / Screen codecs allocate internal buffers with different
     * dimensions / colorspaces; ignore user-defined callbacks for these. */
    if (s->codec_id != AV_CODEC_ID_WMV3IMAGE &&
        s->codec_id != AV_CODEC_ID_VC1IMAGE  &&
        s->codec_id != AV_CODEC_ID_MSS2)
        ff_thread_release_buffer(s->avctx, &pic->f);
    else
        avcodec_default_release_buffer(s->avctx, &pic->f);
    av_freep(&pic->hwaccel_picture_private);
}

        r = ff_thread_get_buffer(s->avctx, &pic->f);
    else
        r = avcodec_default_get_buffer(s->avctx, &pic->f);

    if (r < 0 || !pic->f.type || !pic->f.data[0]) {
        av_log(s->avctx, AV_LOG_ERROR, ""get_buffer() failed (%d %d %p)\n"",
               r, pic->f.type, pic->f.data[0]);
        free_frame_buffer(s, pic);
        free_frame_buffer(s, pic);
        free_frame_buffer(s, pic);
/**
 * Allocate a Picture.
 * The pixels are allocated/set by calling get_buffer() if shared = 0
 */
int ff_alloc_picture(MpegEncContext *s, Picture *pic, int shared)
    const int big_mb_num = s->mb_stride * (s->mb_height + 1) + 1;
    // the + 1 is needed so memset(,,stride*height) does not sig11
    const int b4_array_size = s->b4_stride * s->mb_height * 4;
    int r = -1;
        assert(pic->f.type == 0 || pic->f.type == FF_BUFFER_TYPE_SHARED);
        pic->f.type = FF_BUFFER_TYPE_SHARED;
    if (pic->f.qscale_table == NULL) {
        if (s->encoding) {
            FF_ALLOCZ_OR_GOTO(s->avctx, pic->mb_var,
                              mb_array_size * sizeof(int16_t), fail)
            FF_ALLOCZ_OR_GOTO(s->avctx, pic->mc_mb_var,
                              mb_array_size * sizeof(int16_t), fail)
            FF_ALLOCZ_OR_GOTO(s->avctx, pic->mb_mean,
                              mb_array_size * sizeof(int8_t ), fail)
        }
        FF_ALLOCZ_OR_GOTO(s->avctx, pic->f.mbskip_table,
                          mb_array_size * sizeof(uint8_t) + 2, fail)// the + 2 is for the slice end check
        FF_ALLOCZ_OR_GOTO(s->avctx, pic->qscale_table_base,
                          (big_mb_num + s->mb_stride) * sizeof(uint8_t),
                          fail)
        FF_ALLOCZ_OR_GOTO(s->avctx, pic->mb_type_base,
                          (big_mb_num + s->mb_stride) * sizeof(uint32_t),
                          fail)
        pic->f.mb_type = pic->mb_type_base + 2 * s->mb_stride + 1;
        pic->f.qscale_table = pic->qscale_table_base + 2 * s->mb_stride + 1;
        if (s->out_format == FMT_H264) {
            for (i = 0; i < 2; i++) {
                FF_ALLOCZ_OR_GOTO(s->avctx, pic->motion_val_base[i],
                                  2 * (b4_array_size + 4) * sizeof(int16_t),
                                  fail)
                pic->f.motion_val[i] = pic->motion_val_base[i] + 4;
                FF_ALLOCZ_OR_GOTO(s->avctx, pic->f.ref_index[i],
                                  4 * mb_array_size * sizeof(uint8_t), fail)
            }
            pic->f.motion_subsample_log2 = 2;
        } else if (s->out_format == FMT_H263 || s->encoding ||
                   (s->avctx->debug & FF_DEBUG_MV) || s->avctx->debug_mv) {
            for (i = 0; i < 2; i++) {
                FF_ALLOCZ_OR_GOTO(s->avctx, pic->motion_val_base[i],
                                  2 * (b8_array_size + 4) * sizeof(int16_t),
                                  fail)
                pic->f.motion_val[i] = pic->motion_val_base[i] + 4;
                FF_ALLOCZ_OR_GOTO(s->avctx, pic->f.ref_index[i],
                                  4 * mb_array_size * sizeof(uint8_t), fail)
            }
            pic->f.motion_subsample_log2 = 3;
        }
        if (s->avctx->debug&FF_DEBUG_DCT_COEFF) {
            FF_ALLOCZ_OR_GOTO(s->avctx, pic->f.dct_coeff,
                              64 * mb_array_size * sizeof(int16_t) * 6, fail)
        }
        pic->f.qstride = s->mb_stride;
        FF_ALLOCZ_OR_GOTO(s->avctx, pic->f.pan_scan,
                          1 * sizeof(AVPanScan), fail)
    pic->owner2 = s;
fail: // for  the FF_ALLOCZ_OR_GOTO macro
    if (r >= 0)
        free_frame_buffer(s, pic);
    return -1;
static void free_picture(MpegEncContext *s, Picture *pic)
    int i;
    if (pic->f.data[0] && pic->f.type != FF_BUFFER_TYPE_SHARED) {
        free_frame_buffer(s, pic);
    }

    av_freep(&pic->mb_var);
    av_freep(&pic->mc_mb_var);
    av_freep(&pic->mb_mean);
    av_freep(&pic->f.mbskip_table);
    av_freep(&pic->qscale_table_base);
    pic->f.qscale_table = NULL;
    av_freep(&pic->mb_type_base);
    pic->f.mb_type = NULL;
    av_freep(&pic->f.dct_coeff);
    av_freep(&pic->f.pan_scan);
    pic->f.mb_type = NULL;
        av_freep(&pic->motion_val_base[i]);
        av_freep(&pic->f.ref_index[i]);
        pic->f.motion_val[i] = NULL;
    if (pic->f.type == FF_BUFFER_TYPE_SHARED) {
        for (i = 0; i < 4; i++) {
            pic->f.base[i] =
            pic->f.data[i] = NULL;
        }
        pic->f.type = 0;
    int i;
        s->picture_range_start  += MAX_PICTURE_COUNT;
        s->picture_range_end    += MAX_PICTURE_COUNT;
    memcpy(s->picture, s1->picture, s1->picture_count * sizeof(Picture));
    memcpy(&s->last_picture, &s1->last_picture,
           (char *) &s1->last_picture_ptr - (char *) &s1->last_picture);

    // reset s->picture[].f.extended_data to s->picture[].f.data
    for (i = 0; i < s->picture_count; i++)
        s->picture[i].f.extended_data = s->picture[i].f.data;
    s->picture_range_start   = 0;
    s->picture_range_end     = MAX_PICTURE_COUNT;

    s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count);
                      s->picture_count * sizeof(Picture), fail);
    for (i = 0; i < s->picture_count; i++) {
    free_context_frame(s);
        for (i = 0; i < s->picture_count; i++) {
    if (s->picture && !s->avctx->internal->is_copy) {
        for (i = 0; i < s->picture_count; i++) {
            free_picture(s, &s->picture[i]);
    if (!(s->avctx->active_thread_type & FF_THREAD_FRAME))
        avcodec_default_free_buffers(s->avctx);

    for (i = 0; i < s->picture_count; i++) {
        if (s->picture[i].f.data[0] && !s->picture[i].f.reference &&
            (!s->picture[i].owner2 || s->picture[i].owner2 == s) &&
            (remove_current || &s->picture[i] !=  s->current_picture_ptr)
            /* && s->picture[i].type!= FF_BUFFER_TYPE_SHARED */) {
            free_frame_buffer(s, &s->picture[i]);
    if (pic->needs_realloc && !(pic->f.reference & DELAYED_PIC_REF))
        if (!pic->owner2 || pic->owner2 == s)
            return 1;
        for (i = s->picture_range_start; i < s->picture_range_end; i++) {
            if (s->picture[i].f.data[0] == NULL && s->picture[i].f.type == 0)
        for (i = s->picture_range_start; i < s->picture_range_end; i++) {
            if (pic_is_unused(s, &s->picture[i]) && s->picture[i].f.type != 0)
                return i; // FIXME
        }
        for (i = s->picture_range_start; i < s->picture_range_end; i++) {
    if (ret >= 0 && ret < s->picture_range_end) {
            free_picture(s, &s->picture[ret]);
    int i;
            if (s->last_picture_ptr->owner2 == s)
                free_frame_buffer(s, s->last_picture_ptr);
            for (i = 0; i < s->picture_count; i++) {
                if (s->picture[i].owner2 == s && s->picture[i].f.data[0] &&
                    &s->picture[i] != s->last_picture_ptr &&
                    s->picture[i].f.reference && !s->picture[i].needs_realloc) {
                    free_frame_buffer(s, &s->picture[i]);
        pic->f.reference = 0;
                pic->f.reference = s->picture_structure;
                pic->f.reference = 3;
    ff_copy_picture(&s->current_picture, s->current_picture_ptr);
    if (s->pict_type != AV_PICTURE_TYPE_B) {
            ff_thread_report_progress(&s->last_picture_ptr->f, INT_MAX, 0);
            ff_thread_report_progress(&s->last_picture_ptr->f, INT_MAX, 1);
            s->last_picture_ptr->f.reference = 3;
            ff_thread_report_progress(&s->next_picture_ptr->f, INT_MAX, 0);
            ff_thread_report_progress(&s->next_picture_ptr->f, INT_MAX, 1);
            s->next_picture_ptr->f.reference = 3;
    if (s->last_picture_ptr)
        ff_copy_picture(&s->last_picture, s->last_picture_ptr);
    if (s->next_picture_ptr)
        ff_copy_picture(&s->next_picture, s->next_picture_ptr);
    if (HAVE_THREADS && (avctx->active_thread_type & FF_THREAD_FRAME)) {
        if (s->next_picture_ptr)
            s->next_picture_ptr->owner2 = s;
        if (s->last_picture_ptr)
            s->last_picture_ptr->owner2 = s;
    assert(s->pict_type == AV_PICTURE_TYPE_I || (s->last_picture_ptr &&
                                                 s->last_picture_ptr->f.data[0]));

              s->current_picture.f.reference &&
        for (i = 0; i < s->picture_count; i++) {
            if (s->picture[i].f.data[0] && !s->picture[i].f.reference
                /* && s->picture[i].type != FF_BUFFER_TYPE_SHARED */) {
                free_frame_buffer(s, &s->picture[i]);
            }
    if (s->codec_id != AV_CODEC_ID_H264 && s->current_picture.f.reference) {
        ff_thread_report_progress(&s->current_picture_ptr->f, INT_MAX, 0);
    }
void ff_print_debug_info(MpegEncContext *s, AVFrame *pict)
    if (s->avctx->hwaccel || !pict || !pict->mb_type)
                           pict->qscale_table[x + y * s->mb_stride]);
                    int mb_type = pict->mb_type[x + y * s->mb_stride];
        pict->type   = FF_BUFFER_TYPE_COPY;
                if ((s->avctx->debug_mv) && pict->motion_val) {
                        if (!USES_LIST(pict->mb_type[mb_index], direction))
                        if (IS_8X8(pict->mb_type[mb_index])) {
                                int mx = (pict->motion_val[direction][xy][0] >> shift) + sx;
                                int my = (pict->motion_val[direction][xy][1] >> shift) + sy;
                        } else if (IS_16X8(pict->mb_type[mb_index])) {
                                int mx = (pict->motion_val[direction][xy][0] >> shift);
                                int my = (pict->motion_val[direction][xy][1] >> shift);
                                if (IS_INTERLACED(pict->mb_type[mb_index]))
                        } else if (IS_8X16(pict->mb_type[mb_index])) {
                                int mx = pict->motion_val[direction][xy][0] >> shift;
                                int my = pict->motion_val[direction][xy][1] >> shift;
                                if (IS_INTERLACED(pict->mb_type[mb_index]))
                              int mx = pict->motion_val[direction][xy][0] >> shift + sx;
                              int my = pict->motion_val[direction][xy][1] >> shift + sy;
                if ((s->avctx->debug & FF_DEBUG_VIS_QP) && pict->motion_val) {
                    uint64_t c = (pict->qscale_table[mb_index] * 128 / 31) *
                    pict->motion_val) {
                    int mb_type = pict->mb_type[mb_index];
                            int32_t *mv = (int32_t *) &pict->motion_val[0][xy];
       /* save DCT coefficients */
       int16_t *dct = &s->current_picture.f.dct_coeff[mb_xy * 64 * 6];
               *dct++ = block[i][s->dsp.idct_permutation[j]];
               av_log(s->avctx, AV_LOG_DEBUG, ""%5d"", dct[-1]);
    s->current_picture.f.qscale_table[mb_xy] = s->qscale;
            } else if(!s->current_picture.f.reference) {
                        ff_thread_await_progress(&s->last_picture_ptr->f,
                        ff_thread_await_progress(&s->next_picture_ptr->f,
        cur->f.reference &&
    for(i=0; i<s->picture_count; i++){
       if (s->picture[i].f.data[0] &&
           (s->picture[i].f.type == FF_BUFFER_TYPE_INTERNAL ||
            s->picture[i].f.type == FF_BUFFER_TYPE_USER))
        free_frame_buffer(s, &s->picture[i]);
    }
        ff_thread_report_progress(&s->current_picture_ptr->f, s->mb_y, 0);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED," VAR->VAR.VAR = &VAR->VAR; VAR = VAR(VAR->VAR, &VAR->VAR, VAR->VAR ? VAR : 0); VAR { VAR->VAR.VAR = VAR->VAR->VAR; VAR->VAR.VAR = VAR->VAR->VAR; VAR->VAR.VAR = VAR->VAR->VAR; VAR = VAR(VAR->VAR, &VAR->VAR, 0); } VAR (VAR < 0 || !VAR->VAR.VAR[0]) { VAR(VAR->VAR, VAR, ""VAR() VAR (%VAR %VAR)\VAR"", VAR, VAR->VAR.VAR[0]); VAR(VAR, VAR); VAR(VAR, VAR); VAR(VAR, VAR); VAR VAR VAR(VAR *VAR) VAR VAR; VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR (VAR = 0; VAR < 2; VAR++) { VAR(&VAR->VAR[VAR]); VAR(&VAR->VAR[VAR]); } } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR VAR = VAR->VAR * (VAR->VAR + 1) + 1; VAR->VAR = VAR(VAR + 2); VAR->VAR = VAR(VAR + VAR->VAR); VAR->VAR = VAR((VAR + VAR->VAR) * VAR(VAR)); VAR (!VAR->VAR || !VAR->VAR || !VAR->VAR) VAR VAR(VAR); VAR (VAR->VAR) { VAR->VAR = VAR(VAR * VAR(VAR)); VAR->VAR = VAR(VAR * VAR(VAR)); VAR->VAR = VAR(VAR); VAR (!VAR->VAR || !VAR->VAR || !VAR->VAR) VAR VAR(VAR); } VAR (VAR->VAR == VAR || VAR->VAR || (VAR->VAR->VAR & VAR) || VAR->VAR->VAR) { VAR VAR = 2 * (VAR + 4) * VAR(VAR); VAR VAR = 4 * VAR; VAR (VAR = 0; VAR && VAR < 2; VAR++) { VAR->VAR[VAR] = VAR(VAR); VAR->VAR[VAR] = VAR(VAR); VAR (!VAR->VAR[VAR] || !VAR->VAR[VAR]) VAR VAR(VAR); } } VAR 0; } VAR VAR VAR(VAR *VAR) { VAR VAR, VAR;  VAR {\ VAR (VAR->VAR &&\ (VAR = VAR(&VAR->VAR)) < 0)\ VAR VAR;\ } VAR (0) VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR (VAR = 0; VAR < 2; VAR++) { VAR(VAR[VAR]); VAR(VAR[VAR]); } VAR 0; } /** * VAR VAR VAR. * VAR VAR VAR VAR/VAR VAR VAR VAR() VAR VAR = 0 */ VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) { VAR VAR, VAR; VAR->VAR = 1; VAR (!VAR->VAR) VAR = VAR(VAR, VAR); VAR VAR = VAR(VAR); VAR (VAR < 0) VAR VAR; VAR (VAR->VAR) { VAR->VAR = (VAR*)VAR->VAR->VAR; VAR->VAR = (VAR*)VAR->VAR->VAR; VAR->VAR = VAR->VAR->VAR; VAR->VAR = VAR->VAR->VAR; VAR->VAR = VAR->VAR->VAR + 2 * VAR->VAR + 1; VAR->VAR = (VAR*)VAR->VAR->VAR + 2 * VAR->VAR + 1; VAR (VAR->VAR[0]) { VAR (VAR = 0; VAR < 2; VAR++) { VAR->VAR[VAR] = (VAR (*)[2])VAR->VAR[VAR]->VAR + 4; VAR->VAR[VAR] = VAR->VAR[VAR]->VAR; } } VAR: VAR(VAR->VAR, VAR, ""VAR VAR VAR VAR.\VAR""); VAR(VAR, VAR); VAR(VAR); VAR VAR(VAR); VAR VAR(VAR *VAR, VAR *VAR) VAR VAR = VAR(VAR, VAR) + VAR(VAR->VAR); VAR->VAR.VAR = &VAR->VAR; /* VAR VAR / VAR VAR VAR VAR VAR VAR VAR * VAR / VAR; VAR VAR-VAR VAR VAR VAR. */ VAR (VAR->VAR != VAR && VAR->VAR != VAR && VAR->VAR != VAR) VAR(VAR->VAR, &VAR->VAR); VAR VAR(&VAR->VAR); VAR(&VAR->VAR); VAR((VAR*)VAR + VAR, 0, VAR(*VAR) - VAR); } VAR VAR VAR(VAR *VAR, VAR *VAR) { VAR VAR;  VAR {\ VAR (VAR->VAR &&\ (!VAR->VAR || VAR->VAR->VAR != VAR->VAR->VAR)) {\ VAR(&VAR->VAR);\ VAR->VAR = VAR(VAR->VAR);\ VAR (!VAR->VAR) {\ VAR(VAR);\ VAR VAR(VAR);\ }\ }\ } VAR (0) VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR[VAR]); VAR(VAR[VAR]); VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR (VAR = 0; VAR < 2; VAR++) { VAR->VAR[VAR] = VAR->VAR[VAR]; VAR->VAR[VAR] = VAR->VAR[VAR]; VAR 0; } VAR VAR(VAR *VAR, VAR *VAR, VAR *VAR) { VAR VAR; VAR(!VAR->VAR.VAR[0]); VAR(VAR->VAR.VAR[0]); VAR->VAR.VAR = &VAR->VAR; VAR->VAR.VAR = &VAR->VAR; VAR = VAR(&VAR->VAR, &VAR->VAR); VAR (VAR < 0) VAR VAR; VAR = VAR(VAR, VAR); VAR (VAR < 0) VAR VAR; VAR (VAR->VAR) { VAR->VAR = VAR(VAR->VAR); VAR (!VAR->VAR) VAR VAR; VAR->VAR = VAR->VAR->VAR; } VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR 0; VAR: VAR(VAR, VAR); VAR VAR; VAR VAR, VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR[VAR].VAR.VAR[0] && (VAR = VAR(VAR, &VAR->VAR[VAR], &VAR->VAR[VAR])) < 0) VAR VAR; }  VAR {\ VAR(VAR, &VAR->VAR);\ VAR (VAR->VAR.VAR.VAR[0])\ VAR = VAR(VAR, &VAR->VAR, &VAR->VAR);\ VAR\ VAR = VAR(&VAR->VAR, &VAR->VAR);\ VAR (VAR < 0)\ VAR VAR;\ } VAR (0) VAR(VAR); VAR(VAR); VAR(VAR); VAR * VAR(VAR), VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR(&VAR->VAR, 0, VAR(VAR->VAR)); VAR(&VAR->VAR, 0, VAR(VAR->VAR)); VAR(&VAR->VAR, 0, VAR(VAR->VAR)); VAR(&VAR->VAR.VAR); VAR(&VAR->VAR.VAR); VAR(&VAR->VAR.VAR); VAR ((VAR = VAR(VAR)) < 0) VAR VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR (VAR->VAR) { VAR (VAR = 0; VAR < VAR; VAR++) { VAR(&VAR->VAR[VAR]); VAR(VAR, &VAR->VAR[VAR]); VAR(&VAR->VAR); VAR(VAR, &VAR->VAR); VAR(&VAR->VAR); VAR(VAR, &VAR->VAR); VAR(&VAR->VAR); VAR(VAR, &VAR->VAR); VAR(&VAR->VAR); VAR(VAR, &VAR->VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR (!VAR->VAR[VAR].VAR && (VAR || &VAR->VAR[VAR] != VAR->VAR)) { VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR && !(VAR->VAR & VAR)) VAR 1; VAR (VAR = 0; VAR < VAR; VAR++) { VAR (VAR->VAR[VAR].VAR.VAR[0] == VAR) VAR (VAR = 0; VAR < VAR; VAR++) { VAR (VAR >= 0 && VAR < VAR) { VAR(&VAR->VAR[VAR]); VAR(VAR, &VAR->VAR[VAR]); VAR VAR, VAR; VAR(VAR, VAR->VAR); VAR (VAR = 0; VAR < VAR; VAR++) { VAR (&VAR->VAR[VAR] != VAR->VAR && VAR->VAR[VAR].VAR && !VAR->VAR[VAR].VAR) { VAR(VAR, &VAR->VAR[VAR]); VAR->VAR = 0; VAR->VAR = VAR->VAR; VAR->VAR = 3; VAR(VAR, &VAR->VAR); VAR ((VAR = VAR(VAR, &VAR->VAR, VAR->VAR)) < 0) VAR VAR; VAR (VAR->VAR != VAR && VAR->VAR != VAR) { VAR(&VAR->VAR->VAR, VAR, 0); VAR(&VAR->VAR->VAR, VAR, 1); VAR(&VAR->VAR->VAR, VAR, 0); VAR(&VAR->VAR->VAR, VAR, 1); VAR (VAR->VAR != VAR) { VAR (VAR->VAR) { VAR(VAR, &VAR->VAR); VAR (VAR->VAR->VAR.VAR[0] && (VAR = VAR(VAR, &VAR->VAR, VAR->VAR)) < 0) VAR VAR; } VAR (VAR->VAR) { VAR(VAR, &VAR->VAR); VAR (VAR->VAR->VAR.VAR[0] && (VAR = VAR(VAR, &VAR->VAR, VAR->VAR)) < 0) VAR VAR; } VAR(VAR->VAR == VAR || (VAR->VAR && VAR->VAR->VAR.VAR[0])); VAR->VAR.VAR && VAR (VAR = 0; VAR < VAR; VAR++) { VAR (!VAR->VAR[VAR].VAR) VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR != VAR && VAR->VAR.VAR) VAR(&VAR->VAR->VAR, VAR, 0); VAR VAR(VAR *VAR, VAR *VAR) VAR *VAR; VAR (VAR->VAR->VAR || !VAR || !VAR->VAR) VAR = &VAR->VAR; VAR->VAR[VAR + VAR * VAR->VAR]); VAR VAR = VAR->VAR[VAR + VAR * VAR->VAR]; VAR ((VAR->VAR->VAR) && VAR->VAR) { VAR (!VAR(VAR->VAR[VAR], VAR)) VAR (VAR(VAR->VAR[VAR])) { VAR VAR = (VAR->VAR[VAR][VAR][0] >> VAR) + VAR; VAR VAR = (VAR->VAR[VAR][VAR][1] >> VAR) + VAR; } VAR VAR (VAR(VAR->VAR[VAR])) { VAR VAR = (VAR->VAR[VAR][VAR][0] >> VAR); VAR VAR = (VAR->VAR[VAR][VAR][1] >> VAR); VAR (VAR(VAR->VAR[VAR])) } VAR VAR (VAR(VAR->VAR[VAR])) { VAR VAR = VAR->VAR[VAR][VAR][0] >> VAR; VAR VAR = VAR->VAR[VAR][VAR][1] >> VAR; VAR (VAR(VAR->VAR[VAR])) VAR VAR = VAR->VAR[VAR][VAR][0] >> VAR + VAR; VAR VAR = VAR->VAR[VAR][VAR][1] >> VAR + VAR; VAR ((VAR->VAR->VAR & VAR) && VAR->VAR) { VAR VAR = (VAR->VAR[VAR] * 128 / 31) * VAR->VAR) { VAR VAR = VAR->VAR[VAR]; VAR *VAR = (VAR *) &VAR->VAR[0][VAR];  VAR(VAR->VAR, VAR, ""%5d"", VAR[VAR][VAR->VAR.VAR[VAR]]); VAR->VAR.VAR[VAR] = VAR->VAR; } VAR VAR(!VAR->VAR.VAR) { VAR(&VAR->VAR->VAR, VAR(&VAR->VAR->VAR, VAR->VAR && VAR (VAR = 0; VAR < VAR; VAR++) VAR(VAR, &VAR->VAR[VAR]); VAR(&VAR->VAR->VAR, VAR->VAR, 0); VAR VAR(VAR *VAR, VAR *VAR) { *VAR = *VAR; VAR->VAR.VAR = VAR; } /** * VAR VAR VAR VAR */ VAR VAR VAR(VAR *VAR, VAR *VAR) { /* VAR VAR / VAR VAR VAR VAR VAR VAR VAR * VAR / VAR; VAR VAR-VAR VAR VAR VAR. */ VAR (VAR->VAR != VAR && VAR->VAR != VAR && VAR->VAR != VAR) VAR(VAR->VAR, &VAR->VAR); VAR VAR(VAR->VAR, &VAR->VAR); VAR(&VAR->VAR); } VAR = VAR(VAR->VAR, &VAR->VAR); VAR VAR = VAR(VAR->VAR, &VAR->VAR); VAR (VAR < 0 || !VAR->VAR.VAR || !VAR->VAR.VAR[0]) { VAR(VAR->VAR, VAR, ""VAR() VAR (%VAR %VAR %VAR)\VAR"", VAR, VAR->VAR.VAR, VAR->VAR.VAR[0]); VAR(VAR, VAR); VAR(VAR, VAR); VAR(VAR, VAR); /** * VAR VAR VAR. * VAR VAR VAR VAR/VAR VAR VAR VAR() VAR VAR = 0 */ VAR VAR(VAR *VAR, VAR *VAR, VAR VAR) VAR VAR VAR = VAR->VAR * (VAR->VAR + 1) + 1;  VAR VAR VAR = VAR->VAR * VAR->VAR * 4; VAR VAR = -1; VAR(VAR->VAR.VAR == 0 || VAR->VAR.VAR == VAR); VAR->VAR.VAR = VAR; VAR (VAR->VAR.VAR == VAR) { VAR (VAR->VAR) { VAR(VAR->VAR, VAR->VAR, VAR * VAR(VAR), VAR) VAR(VAR->VAR, VAR->VAR, VAR * VAR(VAR), VAR) VAR(VAR->VAR, VAR->VAR, VAR * VAR(VAR ), VAR) } VAR(VAR->VAR, VAR->VAR.VAR, VAR * VAR(VAR) + 2, VAR) VAR(VAR->VAR, VAR->VAR, (VAR + VAR->VAR) * VAR(VAR), VAR) VAR(VAR->VAR, VAR->VAR, (VAR + VAR->VAR) * VAR(VAR), VAR) VAR->VAR.VAR = VAR->VAR + 2 * VAR->VAR + 1; VAR->VAR.VAR = VAR->VAR + 2 * VAR->VAR + 1; VAR (VAR->VAR == VAR) { VAR (VAR = 0; VAR < 2; VAR++) { VAR(VAR->VAR, VAR->VAR[VAR], 2 * (VAR + 4) * VAR(VAR), VAR) VAR->VAR.VAR[VAR] = VAR->VAR[VAR] + 4; VAR(VAR->VAR, VAR->VAR.VAR[VAR], 4 * VAR * VAR(VAR), VAR) } VAR->VAR.VAR = 2; } VAR VAR (VAR->VAR == VAR || VAR->VAR || (VAR->VAR->VAR & VAR) || VAR->VAR->VAR) { VAR (VAR = 0; VAR < 2; VAR++) { VAR(VAR->VAR, VAR->VAR[VAR], 2 * (VAR + 4) * VAR(VAR), VAR) VAR->VAR.VAR[VAR] = VAR->VAR[VAR] + 4; VAR(VAR->VAR, VAR->VAR.VAR[VAR], 4 * VAR * VAR(VAR), VAR) } VAR->VAR.VAR = 3; } VAR (VAR->VAR->VAR&VAR) { VAR(VAR->VAR, VAR->VAR.VAR, 64 * VAR * VAR(VAR) * 6, VAR) } VAR->VAR.VAR = VAR->VAR; VAR(VAR->VAR, VAR->VAR.VAR, 1 * VAR(VAR), VAR) VAR->VAR = VAR; VAR:  VAR (VAR >= 0) VAR(VAR, VAR); VAR -1; VAR VAR VAR(VAR *VAR, VAR *VAR) VAR VAR; VAR (VAR->VAR.VAR[0] && VAR->VAR.VAR != VAR) { VAR(VAR, VAR); } VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR); VAR(&VAR->VAR.VAR); VAR(&VAR->VAR); VAR->VAR.VAR = VAR; VAR(&VAR->VAR); VAR->VAR.VAR = VAR; VAR(&VAR->VAR.VAR); VAR(&VAR->VAR.VAR); VAR->VAR.VAR = VAR; VAR(&VAR->VAR[VAR]); VAR(&VAR->VAR.VAR[VAR]); VAR->VAR.VAR[VAR] = VAR; VAR (VAR->VAR.VAR == VAR) { VAR (VAR = 0; VAR < 4; VAR++) { VAR->VAR.VAR[VAR] = VAR->VAR.VAR[VAR] = VAR; } VAR->VAR.VAR = 0; VAR VAR; VAR->VAR += VAR; VAR->VAR += VAR; VAR(VAR->VAR, VAR->VAR, VAR->VAR * VAR(VAR)); VAR(&VAR->VAR, &VAR->VAR, (VAR *) &VAR->VAR - (VAR *) &VAR->VAR);  VAR (VAR = 0; VAR < VAR->VAR; VAR++) VAR->VAR[VAR].VAR.VAR = VAR->VAR[VAR].VAR.VAR; VAR->VAR = 0; VAR->VAR = VAR; VAR->VAR = VAR * VAR(1, VAR->VAR->VAR); VAR->VAR * VAR(VAR), VAR); VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR(VAR); VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR->VAR && !VAR->VAR->VAR->VAR) { VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR(VAR, &VAR->VAR[VAR]); VAR (!(VAR->VAR->VAR & VAR)) VAR(VAR->VAR); VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR->VAR[VAR].VAR.VAR[0] && !VAR->VAR[VAR].VAR.VAR && (!VAR->VAR[VAR].VAR || VAR->VAR[VAR].VAR == VAR) && (VAR || &VAR->VAR[VAR] != VAR->VAR) ) { VAR(VAR, &VAR->VAR[VAR]); VAR (VAR->VAR && !(VAR->VAR.VAR & VAR)) VAR (!VAR->VAR || VAR->VAR == VAR) VAR 1; VAR (VAR = VAR->VAR; VAR < VAR->VAR; VAR++) { VAR (VAR->VAR[VAR].VAR.VAR[0] == VAR && VAR->VAR[VAR].VAR.VAR == 0) VAR (VAR = VAR->VAR; VAR < VAR->VAR; VAR++) { VAR (VAR(VAR, &VAR->VAR[VAR]) && VAR->VAR[VAR].VAR.VAR != 0) VAR VAR;  } VAR (VAR = VAR->VAR; VAR < VAR->VAR; VAR++) { VAR (VAR >= 0 && VAR < VAR->VAR) { VAR(VAR, &VAR->VAR[VAR]); VAR VAR; VAR (VAR->VAR->VAR == VAR) VAR(VAR, VAR->VAR); VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR->VAR[VAR].VAR == VAR && VAR->VAR[VAR].VAR.VAR[0] && &VAR->VAR[VAR] != VAR->VAR && VAR->VAR[VAR].VAR.VAR && !VAR->VAR[VAR].VAR) { VAR(VAR, &VAR->VAR[VAR]); VAR->VAR.VAR = 0; VAR->VAR.VAR = VAR->VAR; VAR->VAR.VAR = 3; VAR(&VAR->VAR, VAR->VAR); VAR (VAR->VAR != VAR) { VAR(&VAR->VAR->VAR, VAR, 0); VAR(&VAR->VAR->VAR, VAR, 1); VAR->VAR->VAR.VAR = 3; VAR(&VAR->VAR->VAR, VAR, 0); VAR(&VAR->VAR->VAR, VAR, 1); VAR->VAR->VAR.VAR = 3; VAR (VAR->VAR) VAR(&VAR->VAR, VAR->VAR); VAR (VAR->VAR) VAR(&VAR->VAR, VAR->VAR); VAR (VAR && (VAR->VAR & VAR)) { VAR (VAR->VAR) VAR->VAR->VAR = VAR; VAR (VAR->VAR) VAR->VAR->VAR = VAR; VAR(VAR->VAR == VAR || (VAR->VAR && VAR->VAR->VAR.VAR[0])); VAR->VAR.VAR.VAR && VAR (VAR = 0; VAR < VAR->VAR; VAR++) { VAR (VAR->VAR[VAR].VAR.VAR[0] && !VAR->VAR[VAR].VAR.VAR ) { VAR(VAR, &VAR->VAR[VAR]); } VAR (VAR->VAR != VAR && VAR->VAR.VAR.VAR) { VAR(&VAR->VAR->VAR, VAR, 0); } VAR VAR(VAR *VAR, VAR *VAR) VAR (VAR->VAR->VAR || !VAR || !VAR->VAR) VAR->VAR[VAR + VAR * VAR->VAR]); VAR VAR = VAR->VAR[VAR + VAR * VAR->VAR]; VAR->VAR = VAR; VAR ((VAR->VAR->VAR) && VAR->VAR) { VAR (!VAR(VAR->VAR[VAR], VAR)) VAR (VAR(VAR->VAR[VAR])) { VAR VAR = (VAR->VAR[VAR][VAR][0] >> VAR) + VAR; VAR VAR = (VAR->VAR[VAR][VAR][1] >> VAR) + VAR; } VAR VAR (VAR(VAR->VAR[VAR])) { VAR VAR = (VAR->VAR[VAR][VAR][0] >> VAR); VAR VAR = (VAR->VAR[VAR][VAR][1] >> VAR); VAR (VAR(VAR->VAR[VAR])) } VAR VAR (VAR(VAR->VAR[VAR])) { VAR VAR = VAR->VAR[VAR][VAR][0] >> VAR; VAR VAR = VAR->VAR[VAR][VAR][1] >> VAR; VAR (VAR(VAR->VAR[VAR])) VAR VAR = VAR->VAR[VAR][VAR][0] >> VAR + VAR; VAR VAR = VAR->VAR[VAR][VAR][1] >> VAR + VAR; VAR ((VAR->VAR->VAR & VAR) && VAR->VAR) { VAR VAR = (VAR->VAR[VAR] * 128 / 31) * VAR->VAR) { VAR VAR = VAR->VAR[VAR]; VAR *VAR = (VAR *) &VAR->VAR[0][VAR];  VAR *VAR = &VAR->VAR.VAR.VAR[VAR * 64 * 6]; *VAR++ = VAR[VAR][VAR->VAR.VAR[VAR]]; VAR(VAR->VAR, VAR, ""%5d"", VAR[-1]); VAR->VAR.VAR.VAR[VAR] = VAR->VAR; } VAR VAR(!VAR->VAR.VAR.VAR) { VAR(&VAR->VAR->VAR, VAR(&VAR->VAR->VAR, VAR->VAR.VAR && VAR(VAR=0; VAR<VAR->VAR; VAR++){ VAR (VAR->VAR[VAR].VAR.VAR[0] && (VAR->VAR[VAR].VAR.VAR == VAR || VAR->VAR[VAR].VAR.VAR == VAR)) VAR(VAR, &VAR->VAR[VAR]); } VAR(&VAR->VAR->VAR, VAR->VAR, 0);",10,7
FFmpeg_9a271a9368eaabf99e6c2046103acb33957e63b7,libavcodec/jpeg2000dec.c,"    if (c->log2_cblk_width > 6 || c->log2_cblk_height > 6) {
        avpriv_request_sample(s->avctx, ""cblk size > 64"");
        return AVERROR_PATCHWELCOME;
    }

    av_assert0(width  <= JPEG2000_MAX_CBLKW);
    av_assert0(height <= JPEG2000_MAX_CBLKH);
",,9a271a9368eaabf99e6c2046103acb33957e63b7,CVE-2013-7018,9a271a9368eaabf99e6c2046103acb33957e63b7,https://github.com/FFmpeg/FFmpeg,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR (VAR->VAR > 6 || VAR->VAR > 6) { VAR(VAR->VAR, ""VAR VAR > 64""); VAR VAR; } VAR(VAR <= VAR); VAR(VAR <= VAR); ",10,7
FFmpeg_c509f4f74713b035a06f79cb4d00e708f5226bc5,libavcodec/atrac3.c,"                if (component_count >= 64)
                    return AVERROR_INVALIDDATA;",,c509f4f74713b035a06f79cb4d00e708f5226bc5,CVE-2012-0853,c509f4f74713b035a06f79cb4d00e708f5226bc5,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,154,COMPLETED,VAR (VAR >= 64) VAR VAR; ,10,7
glpi_e0d6a24d16f11505663928cc47292aec77ca2612,tests/functionnal/Session.php,"

   protected function idorProvider() {
      return [
         ['itemtype' => 'Computer'],
         ['itemtype' => 'Ticket'],
         ['itemtype' => 'Glpi\\Dashboard\\Item'],
         ['itemtype' => 'User', 'add_params' => ['right' => 'all']],
      ];
   }

   /**
    * @dataProvider idorProvider
    */
   function testIDORToken(string $itemtype = """", array $add_params = []) {
      // generate token
      $token = \Session::getNewIDORToken($itemtype, $add_params);
      $this->string($token)->hasLength(64);

      // token exists in session and is valid
      $this->array($_SESSION['glpiidortokens'][$token])
         ->string['itemtype']->isEqualTo($itemtype)
         ->string['expires'];

      if (count($add_params) > 0) {
         $this->array($_SESSION['glpiidortokens'][$token])->size->isEqualTo(2 + count($add_params));
      }

      // validate token with dedicated method
      $result = \Session::validateIDOR([
         '_idor_token' => $token,
         'itemtype'    => $itemtype,
      ] + $add_params);
      $this->boolean($result)->isTrue();
   }


   function testDORInvalid() {
      //  random token
      $result = \Session::validateIDOR([
         '_idor_token' => bin2hex(random_bytes(32)),
         'itemtype'    => 'Computer',
      ]);
      $this->boolean($result)->isFalse();

      // bad itemtype
      $token_bad_itt = \Session::getNewIDORToken('Ticket');
      $result = \Session::validateIDOR([
         '_idor_token' => $token_bad_itt,
         'itemtype'    => 'Computer',
      ]);
      $this->boolean($result)->isFalse();

      // missing add params
      $token_miss_param = \Session::getNewIDORToken('User', ['right' => 'all']);
      $result = \Session::validateIDOR([
         '_idor_token' => $token_miss_param,
         'itemtype'    => 'User',
      ]);
      $this->boolean($result)->isFalse();
      $result = \Session::validateIDOR([
         '_idor_token' => $token_miss_param,
         'itemtype'    => 'User',
         'right'       => 'all'
      ]);
      $this->boolean($result)->isTrue();
   }",,e0d6a24d16f11505663928cc47292aec77ca2612,CVE-2020-27663,e0d6a24d16f11505663928cc47292aec77ca2612,https://github.com/glpi-project/glpi,NVD_GIT_REPOBASED,88,COMPLETED,"VAR VAR VAR() { VAR [ ['VAR' => 'VAR'], ['VAR' => 'VAR'], ['VAR' => 'VAR\\VAR\\VAR'], ['VAR' => 'VAR', 'VAR' => ['VAR' => 'VAR']], ]; } /** * @VAR VAR */ VAR VAR(VAR $VAR = """", VAR $VAR = []) {  $VAR = \VAR::VAR($VAR, $VAR); $VAR->VAR($VAR)->VAR(64);  $VAR->VAR($VAR['VAR'][$VAR]) ->VAR['VAR']->VAR($VAR) ->VAR['VAR']; VAR (VAR($VAR) > 0) { $VAR->VAR($VAR['VAR'][$VAR])->VAR->VAR(2 + VAR($VAR)); }  $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => $VAR, ] + $VAR); $VAR->VAR($VAR)->VAR(); } VAR VAR() {  $VAR = \VAR::VAR([ 'VAR' => VAR(VAR(32)), 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR();  $VAR = \VAR::VAR('VAR'); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR();  $VAR = \VAR::VAR('VAR', ['VAR' => 'VAR']); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR(); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', 'VAR' => 'VAR' ]); $VAR->VAR($VAR)->VAR(); } ",10,7
glpi_e0d6a24d16f11505663928cc47292aec77ca2612,tests/functionnal/Session.php,"

   protected function idorProvider() {
      return [
         ['itemtype' => 'Computer'],
         ['itemtype' => 'Ticket'],
         ['itemtype' => 'Glpi\\Dashboard\\Item'],
         ['itemtype' => 'User', 'add_params' => ['right' => 'all']],
      ];
   }

   /**
    * @dataProvider idorProvider
    */
   function testIDORToken(string $itemtype = """", array $add_params = []) {
      // generate token
      $token = \Session::getNewIDORToken($itemtype, $add_params);
      $this->string($token)->hasLength(64);

      // token exists in session and is valid
      $this->array($_SESSION['glpiidortokens'][$token])
         ->string['itemtype']->isEqualTo($itemtype)
         ->string['expires'];

      if (count($add_params) > 0) {
         $this->array($_SESSION['glpiidortokens'][$token])->size->isEqualTo(2 + count($add_params));
      }

      // validate token with dedicated method
      $result = \Session::validateIDOR([
         '_idor_token' => $token,
         'itemtype'    => $itemtype,
      ] + $add_params);
      $this->boolean($result)->isTrue();
   }


   function testDORInvalid() {
      //  random token
      $result = \Session::validateIDOR([
         '_idor_token' => bin2hex(random_bytes(32)),
         'itemtype'    => 'Computer',
      ]);
      $this->boolean($result)->isFalse();

      // bad itemtype
      $token_bad_itt = \Session::getNewIDORToken('Ticket');
      $result = \Session::validateIDOR([
         '_idor_token' => $token_bad_itt,
         'itemtype'    => 'Computer',
      ]);
      $this->boolean($result)->isFalse();

      // missing add params
      $token_miss_param = \Session::getNewIDORToken('User', ['right' => 'all']);
      $result = \Session::validateIDOR([
         '_idor_token' => $token_miss_param,
         'itemtype'    => 'User',
      ]);
      $this->boolean($result)->isFalse();
      $result = \Session::validateIDOR([
         '_idor_token' => $token_miss_param,
         'itemtype'    => 'User',
         'right'       => 'all'
      ]);
      $this->boolean($result)->isTrue();
   }",,e0d6a24d16f11505663928cc47292aec77ca2612,CVE-2020-27662,e0d6a24d16f11505663928cc47292aec77ca2612,https://github.com/glpi-project/glpi,NVD_GIT_REPOBASED,96,COMPLETED,"VAR VAR VAR() { VAR [ ['VAR' => 'VAR'], ['VAR' => 'VAR'], ['VAR' => 'VAR\\VAR\\VAR'], ['VAR' => 'VAR', 'VAR' => ['VAR' => 'VAR']], ]; } /** * @VAR VAR */ VAR VAR(VAR $VAR = """", VAR $VAR = []) {  $VAR = \VAR::VAR($VAR, $VAR); $VAR->VAR($VAR)->VAR(64);  $VAR->VAR($VAR['VAR'][$VAR]) ->VAR['VAR']->VAR($VAR) ->VAR['VAR']; VAR (VAR($VAR) > 0) { $VAR->VAR($VAR['VAR'][$VAR])->VAR->VAR(2 + VAR($VAR)); }  $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => $VAR, ] + $VAR); $VAR->VAR($VAR)->VAR(); } VAR VAR() {  $VAR = \VAR::VAR([ 'VAR' => VAR(VAR(32)), 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR();  $VAR = \VAR::VAR('VAR'); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR();  $VAR = \VAR::VAR('VAR', ['VAR' => 'VAR']); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', ]); $VAR->VAR($VAR)->VAR(); $VAR = \VAR::VAR([ 'VAR' => $VAR, 'VAR' => 'VAR', 'VAR' => 'VAR' ]); $VAR->VAR($VAR)->VAR(); } ",10,7
gpac_3d17f9524b48e8564bba50055c3502e660c41a64,src/media_tools/media_import.c,"
typedef struct
{
	u32 layer_id_plus_one;
	u32 min_temporal_id, max_temporal_id;
} LHVCLayerInfo;

static void gf_lhevc_set_layer_information(GF_ISOFile *file, u32 track, LHVCLayerInfo *linf)
{
	u32 i, nb_layers=0, di=0;
	char *data;
	u32 data_size;

	GF_BitStream *bs = gf_bs_new(NULL, 0, GF_BITSTREAM_WRITE);

	for (i=0; i<64; i++) {
		if (linf[i].layer_id_plus_one) nb_layers++;
	}
	gf_bs_write_int(bs, 0, 2);
	gf_bs_write_int(bs, nb_layers, 6);
	for (i=0; i<nb_layers; i++) {
		if (! linf[i].layer_id_plus_one) continue;
		gf_bs_write_int(bs, 0, 4);
		gf_bs_write_int(bs, linf[i].layer_id_plus_one - 1, 6);
		gf_bs_write_int(bs, linf[i].min_temporal_id, 3);
		gf_bs_write_int(bs, linf[i].max_temporal_id, 3);
		gf_bs_write_int(bs, 0, 1);
		gf_bs_write_int(bs, 0xFF, 7);

	}
	gf_bs_get_content(bs, &data, &data_size);
	gf_bs_del(bs);
	gf_isom_add_sample_group_info(file, track, GF_4CC( 'l', 'i', 'n', 'f'), data, data_size, GF_TRUE, &di);
	gf_free(data);
}

	LHVCLayerInfo linf[64];
	memset(linf, 0, sizeof(linf));

		if (copy_size) {
			linf[layer_id].layer_id_plus_one = layer_id + 1;
			if (! linf[layer_id].max_temporal_id ) linf[layer_id].max_temporal_id = temporal_id;
			else if (linf[layer_id].max_temporal_id < temporal_id) linf[layer_id].max_temporal_id = temporal_id;

			if (! linf[layer_id].min_temporal_id ) linf[layer_id].min_temporal_id = temporal_id;
			else if (linf[layer_id].min_temporal_id > temporal_id) linf[layer_id].min_temporal_id = temporal_id;
		}
		gf_lhevc_set_layer_information(import->dest, track, &linf[0]);",,3d17f9524b48e8564bba50055c3502e660c41a64,CVE-2018-1000100,3d17f9524b48e8564bba50055c3502e660c41a64,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,76,COMPLETED,"VAR VAR { VAR VAR; VAR VAR, VAR; } VAR; VAR VAR VAR(VAR *VAR, VAR VAR, VAR *VAR) { VAR VAR, VAR=0, VAR=0; VAR *VAR; VAR VAR; VAR *VAR = VAR(VAR, 0, VAR); VAR (VAR=0; VAR<64; VAR++) { VAR (VAR[VAR].VAR) VAR++; } VAR(VAR, 0, 2); VAR(VAR, VAR, 6); VAR (VAR=0; VAR<VAR; VAR++) { VAR (! VAR[VAR].VAR) VAR; VAR(VAR, 0, 4); VAR(VAR, VAR[VAR].VAR - 1, 6); VAR(VAR, VAR[VAR].VAR, 3); VAR(VAR, VAR[VAR].VAR, 3); VAR(VAR, 0, 1); VAR(VAR, 0xFF, 7); } VAR(VAR, &VAR, &VAR); VAR(VAR); VAR(VAR, VAR, VAR( 'VAR', 'VAR', 'VAR', 'VAR'), VAR, VAR, VAR, &VAR); VAR(VAR); } VAR VAR[64]; VAR(VAR, 0, VAR(VAR)); VAR (VAR) { VAR[VAR].VAR = VAR + 1; VAR (! VAR[VAR].VAR ) VAR[VAR].VAR = VAR; VAR VAR (VAR[VAR].VAR < VAR) VAR[VAR].VAR = VAR; VAR (! VAR[VAR].VAR ) VAR[VAR].VAR = VAR; VAR VAR (VAR[VAR].VAR > VAR) VAR[VAR].VAR = VAR; } VAR(VAR->VAR, VAR, &VAR[0]); ",10,7
gpac_524e2bbdb294d5aa4c84bf83db4d328a588b55f7,include/gpac/internal/isomedia_dev.h,"	/*the default size is 64, cause we need to handle large boxes...
	the other_boxes container is by default NOT created. When parsing a box and adding
	a sub-box with gf_isom_box_add_default, the list is created.
	This list is destroyed befaore calling the final box destructor
	This list is automatically taken into account during size() and write() functions
	*/
	Bool is_unknown;","/*the default size is 64, cause we need to handle large boxes...
the other_boxes container is by default NOT created. When parsing a box and adding
a sub-box with gf_isom_box_add_default, the list is created.
This list is destroyed befaore calling the final box destructor
This list is automatically taken into account during size() and write() functions
*/",524e2bbdb294d5aa4c84bf83db4d328a588b55f7,CVE-2020-22678,524e2bbdb294d5aa4c84bf83db4d328a588b55f7,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,68,COMPLETED,"/*VAR VAR VAR VAR 64, VAR VAR VAR VAR VAR VAR VAR... VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR() VAR VAR() VAR */ VAR VAR; /*VAR VAR VAR VAR 64, VAR VAR VAR VAR VAR VAR VAR... VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR() VAR VAR() VAR */",10,7
linux_1202cdd665315c525b5237e96e0bedc76d7e754f,net/decnet/dn_nsp_out.c,,"// SPDX-License-Identifier: GPL-2.0-or-later
/*
 * DECnet       An implementation of the DECnet protocol suite for the LINUX
 *              operating system.  DECnet is implemented using the  BSD Socket
 *              interface as the means of communication with the user level.
 *
 *              DECnet Network Services Protocol (Output)
 *
 * Author:      Eduardo Marcelo Serrat <emserrat@geocities.com>
 *
 * Changes:
 *
 *    Steve Whitehouse:  Split into dn_nsp_in.c and dn_nsp_out.c from
 *                       original dn_nsp.c.
 *    Steve Whitehouse:  Updated to work with my new routing architecture.
 *    Steve Whitehouse:  Added changes from Eduardo Serrat's patches.
 *    Steve Whitehouse:  Now conninits have the ""return"" bit set.
 *    Steve Whitehouse:  Fixes to check alloc'd skbs are non NULL!
 *                       Moved output state machine into one function
 *    Steve Whitehouse:  New output state machine
 *         Paul Koning:  Connect Confirm message fix.
 *      Eduardo Serrat:  Fix to stop dn_nsp_do_disc() sending malformed packets.
 *    Steve Whitehouse:  dn_nsp_output() and friends needed a spring clean
 *    Steve Whitehouse:  Moved dn_nsp_send() in here from route.h
 */

/******************************************************************************
    (c) 1995-1998 E.M. Serrat		emserrat@geocities.com

*******************************************************************************/

#include <linux/errno.h>
#include <linux/types.h>
#include <linux/socket.h>
#include <linux/in.h>
#include <linux/kernel.h>
#include <linux/timer.h>
#include <linux/string.h>
#include <linux/sockios.h>
#include <linux/net.h>
#include <linux/netdevice.h>
#include <linux/inet.h>
#include <linux/route.h>
#include <linux/slab.h>
#include <net/sock.h>
#include <linux/fcntl.h>
#include <linux/mm.h>
#include <linux/termios.h>
#include <linux/interrupt.h>
#include <linux/proc_fs.h>
#include <linux/stat.h>
#include <linux/init.h>
#include <linux/poll.h>
#include <linux/if_packet.h>
#include <linux/jiffies.h>
#include <net/neighbour.h>
#include <net/dst.h>
#include <net/flow.h>
#include <net/dn.h>
#include <net/dn_nsp.h>
#include <net/dn_dev.h>
#include <net/dn_route.h>


static int nsp_backoff[NSP_MAXRXTSHIFT + 1] = { 1, 2, 4, 8, 16, 32, 64, 64, 64, 64, 64, 64, 64 };

static void dn_nsp_send(struct sk_buff *skb)
{
	struct sock *sk = skb->sk;
	struct dn_scp *scp = DN_SK(sk);
	struct dst_entry *dst;
	struct flowidn fld;

	skb_reset_transport_header(skb);
	scp->stamp = jiffies;

	dst = sk_dst_check(sk, 0);
	if (dst) {
try_again:
		skb_dst_set(skb, dst);
		dst_output(&init_net, skb->sk, skb);
		return;
	}

	memset(&fld, 0, sizeof(fld));
	fld.flowidn_oif = sk->sk_bound_dev_if;
	fld.saddr = dn_saddr2dn(&scp->addr);
	fld.daddr = dn_saddr2dn(&scp->peer);
	dn_sk_ports_copy(&fld, scp);
	fld.flowidn_proto = DNPROTO_NSP;
	if (dn_route_output_sock(&sk->sk_dst_cache, &fld, sk, 0) == 0) {
		dst = sk_dst_get(sk);
		sk->sk_route_caps = dst->dev->features;
		goto try_again;
	}

	sk->sk_err = EHOSTUNREACH;
	if (!sock_flag(sk, SOCK_DEAD))
		sk->sk_state_change(sk);
}


/*
 * If sk == NULL, then we assume that we are supposed to be making
 * a routing layer skb. If sk != NULL, then we are supposed to be
 * creating an skb for the NSP layer.
 *
 * The eventual aim is for each socket to have a cached header size
 * for its outgoing packets, and to set hdr from this when sk != NULL.
 */
struct sk_buff *dn_alloc_skb(struct sock *sk, int size, gfp_t pri)
{
	struct sk_buff *skb;
	int hdr = 64;

	if ((skb = alloc_skb(size + hdr, pri)) == NULL)
		return NULL;

	skb->protocol = htons(ETH_P_DNA_RT);
	skb->pkt_type = PACKET_OUTGOING;

	if (sk)
		skb_set_owner_w(skb, sk);

	skb_reserve(skb, hdr);

	return skb;
}

/*
 * Calculate persist timer based upon the smoothed round
 * trip time and the variance. Backoff according to the
 * nsp_backoff[] array.
 */
unsigned long dn_nsp_persist(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);

	unsigned long t = ((scp->nsp_srtt >> 2) + scp->nsp_rttvar) >> 1;

	t *= nsp_backoff[scp->nsp_rxtshift];

	if (t < HZ) t = HZ;
	if (t > (600*HZ)) t = (600*HZ);

	if (scp->nsp_rxtshift < NSP_MAXRXTSHIFT)
		scp->nsp_rxtshift++;

	/* printk(KERN_DEBUG ""rxtshift %lu, t=%lu\n"", scp->nsp_rxtshift, t); */

	return t;
}

/*
 * This is called each time we get an estimate for the rtt
 * on the link.
 */
static void dn_nsp_rtt(struct sock *sk, long rtt)
{
	struct dn_scp *scp = DN_SK(sk);
	long srtt = (long)scp->nsp_srtt;
	long rttvar = (long)scp->nsp_rttvar;
	long delta;

	/*
	 * If the jiffies clock flips over in the middle of timestamp
	 * gathering this value might turn out negative, so we make sure
	 * that is it always positive here.
	 */
	if (rtt < 0)
		rtt = -rtt;
	/*
	 * Add new rtt to smoothed average
	 */
	delta = ((rtt << 3) - srtt);
	srtt += (delta >> 3);
	if (srtt >= 1)
		scp->nsp_srtt = (unsigned long)srtt;
	else
		scp->nsp_srtt = 1;

	/*
	 * Add new rtt variance to smoothed varience
	 */
	delta >>= 1;
	rttvar += ((((delta>0)?(delta):(-delta)) - rttvar) >> 2);
	if (rttvar >= 1)
		scp->nsp_rttvar = (unsigned long)rttvar;
	else
		scp->nsp_rttvar = 1;

	/* printk(KERN_DEBUG ""srtt=%lu rttvar=%lu\n"", scp->nsp_srtt, scp->nsp_rttvar); */
}

/**
 * dn_nsp_clone_and_send - Send a data packet by cloning it
 * @skb: The packet to clone and transmit
 * @gfp: memory allocation flag
 *
 * Clone a queued data or other data packet and transmit it.
 *
 * Returns: The number of times the packet has been sent previously
 */
static inline unsigned int dn_nsp_clone_and_send(struct sk_buff *skb,
					     gfp_t gfp)
{
	struct dn_skb_cb *cb = DN_SKB_CB(skb);
	struct sk_buff *skb2;
	int ret = 0;

	if ((skb2 = skb_clone(skb, gfp)) != NULL) {
		ret = cb->xmit_count;
		cb->xmit_count++;
		cb->stamp = jiffies;
		skb2->sk = skb->sk;
		dn_nsp_send(skb2);
	}

	return ret;
}

/**
 * dn_nsp_output - Try and send something from socket queues
 * @sk: The socket whose queues are to be investigated
 *
 * Try and send the packet on the end of the data and other data queues.
 * Other data gets priority over data, and if we retransmit a packet we
 * reduce the window by dividing it in two.
 *
 */
void dn_nsp_output(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);
	struct sk_buff *skb;
	unsigned int reduce_win = 0;

	/*
	 * First we check for otherdata/linkservice messages
	 */
	if ((skb = skb_peek(&scp->other_xmit_queue)) != NULL)
		reduce_win = dn_nsp_clone_and_send(skb, GFP_ATOMIC);

	/*
	 * If we may not send any data, we don't.
	 * If we are still trying to get some other data down the
	 * channel, we don't try and send any data.
	 */
	if (reduce_win || (scp->flowrem_sw != DN_SEND))
		goto recalc_window;

	if ((skb = skb_peek(&scp->data_xmit_queue)) != NULL)
		reduce_win = dn_nsp_clone_and_send(skb, GFP_ATOMIC);

	/*
	 * If we've sent any frame more than once, we cut the
	 * send window size in half. There is always a minimum
	 * window size of one available.
	 */
recalc_window:
	if (reduce_win) {
		scp->snd_window >>= 1;
		if (scp->snd_window < NSP_MIN_WINDOW)
			scp->snd_window = NSP_MIN_WINDOW;
	}
}

int dn_nsp_xmit_timeout(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);

	dn_nsp_output(sk);

	if (!skb_queue_empty(&scp->data_xmit_queue) ||
	    !skb_queue_empty(&scp->other_xmit_queue))
		scp->persist = dn_nsp_persist(sk);

	return 0;
}

static inline __le16 *dn_mk_common_header(struct dn_scp *scp, struct sk_buff *skb, unsigned char msgflag, int len)
{
	unsigned char *ptr = skb_push(skb, len);

	BUG_ON(len < 5);

	*ptr++ = msgflag;
	*((__le16 *)ptr) = scp->addrrem;
	ptr += 2;
	*((__le16 *)ptr) = scp->addrloc;
	ptr += 2;
	return (__le16 __force *)ptr;
}

static __le16 *dn_mk_ack_header(struct sock *sk, struct sk_buff *skb, unsigned char msgflag, int hlen, int other)
{
	struct dn_scp *scp = DN_SK(sk);
	unsigned short acknum = scp->numdat_rcv & 0x0FFF;
	unsigned short ackcrs = scp->numoth_rcv & 0x0FFF;
	__le16 *ptr;

	BUG_ON(hlen < 9);

	scp->ackxmt_dat = acknum;
	scp->ackxmt_oth = ackcrs;
	acknum |= 0x8000;
	ackcrs |= 0x8000;

	/* If this is an ""other data/ack"" message, swap acknum and ackcrs */
	if (other)
		swap(acknum, ackcrs);

	/* Set ""cross subchannel"" bit in ackcrs */
	ackcrs |= 0x2000;

	ptr = dn_mk_common_header(scp, skb, msgflag, hlen);

	*ptr++ = cpu_to_le16(acknum);
	*ptr++ = cpu_to_le16(ackcrs);

	return ptr;
}

static __le16 *dn_nsp_mk_data_header(struct sock *sk, struct sk_buff *skb, int oth)
{
	struct dn_scp *scp = DN_SK(sk);
	struct dn_skb_cb *cb = DN_SKB_CB(skb);
	__le16 *ptr = dn_mk_ack_header(sk, skb, cb->nsp_flags, 11, oth);

	if (unlikely(oth)) {
		cb->segnum = scp->numoth;
		seq_add(&scp->numoth, 1);
	} else {
		cb->segnum = scp->numdat;
		seq_add(&scp->numdat, 1);
	}
	*(ptr++) = cpu_to_le16(cb->segnum);

	return ptr;
}

void dn_nsp_queue_xmit(struct sock *sk, struct sk_buff *skb,
			gfp_t gfp, int oth)
{
	struct dn_scp *scp = DN_SK(sk);
	struct dn_skb_cb *cb = DN_SKB_CB(skb);
	unsigned long t = ((scp->nsp_srtt >> 2) + scp->nsp_rttvar) >> 1;

	cb->xmit_count = 0;
	dn_nsp_mk_data_header(sk, skb, oth);

	/*
	 * Slow start: If we have been idle for more than
	 * one RTT, then reset window to min size.
	 */
	if (time_is_before_jiffies(scp->stamp + t))
		scp->snd_window = NSP_MIN_WINDOW;

	if (oth)
		skb_queue_tail(&scp->other_xmit_queue, skb);
	else
		skb_queue_tail(&scp->data_xmit_queue, skb);

	if (scp->flowrem_sw != DN_SEND)
		return;

	dn_nsp_clone_and_send(skb, gfp);
}


int dn_nsp_check_xmit_queue(struct sock *sk, struct sk_buff *skb, struct sk_buff_head *q, unsigned short acknum)
{
	struct dn_skb_cb *cb = DN_SKB_CB(skb);
	struct dn_scp *scp = DN_SK(sk);
	struct sk_buff *skb2, *n, *ack = NULL;
	int wakeup = 0;
	int try_retrans = 0;
	unsigned long reftime = cb->stamp;
	unsigned long pkttime;
	unsigned short xmit_count;
	unsigned short segnum;

	skb_queue_walk_safe(q, skb2, n) {
		struct dn_skb_cb *cb2 = DN_SKB_CB(skb2);

		if (dn_before_or_equal(cb2->segnum, acknum))
			ack = skb2;

		/* printk(KERN_DEBUG ""ack: %s %04x %04x\n"", ack ? ""ACK"" : ""SKIP"", (int)cb2->segnum, (int)acknum); */

		if (ack == NULL)
			continue;

		/* printk(KERN_DEBUG ""check_xmit_queue: %04x, %d\n"", acknum, cb2->xmit_count); */

		/* Does _last_ packet acked have xmit_count > 1 */
		try_retrans = 0;
		/* Remember to wake up the sending process */
		wakeup = 1;
		/* Keep various statistics */
		pkttime = cb2->stamp;
		xmit_count = cb2->xmit_count;
		segnum = cb2->segnum;
		/* Remove and drop ack'ed packet */
		skb_unlink(ack, q);
		kfree_skb(ack);
		ack = NULL;

		/*
		 * We don't expect to see acknowledgements for packets we
		 * haven't sent yet.
		 */
		WARN_ON(xmit_count == 0);

		/*
		 * If the packet has only been sent once, we can use it
		 * to calculate the RTT and also open the window a little
		 * further.
		 */
		if (xmit_count == 1) {
			if (dn_equal(segnum, acknum))
				dn_nsp_rtt(sk, (long)(pkttime - reftime));

			if (scp->snd_window < scp->max_window)
				scp->snd_window++;
		}

		/*
		 * Packet has been sent more than once. If this is the last
		 * packet to be acknowledged then we want to send the next
		 * packet in the send queue again (assumes the remote host does
		 * go-back-N error control).
		 */
		if (xmit_count > 1)
			try_retrans = 1;
	}

	if (try_retrans)
		dn_nsp_output(sk);

	return wakeup;
}

void dn_nsp_send_data_ack(struct sock *sk)
{
	struct sk_buff *skb = NULL;

	if ((skb = dn_alloc_skb(sk, 9, GFP_ATOMIC)) == NULL)
		return;

	skb_reserve(skb, 9);
	dn_mk_ack_header(sk, skb, 0x04, 9, 0);
	dn_nsp_send(skb);
}

void dn_nsp_send_oth_ack(struct sock *sk)
{
	struct sk_buff *skb = NULL;

	if ((skb = dn_alloc_skb(sk, 9, GFP_ATOMIC)) == NULL)
		return;

	skb_reserve(skb, 9);
	dn_mk_ack_header(sk, skb, 0x14, 9, 1);
	dn_nsp_send(skb);
}


void dn_send_conn_ack (struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);
	struct sk_buff *skb = NULL;
	struct nsp_conn_ack_msg *msg;

	if ((skb = dn_alloc_skb(sk, 3, sk->sk_allocation)) == NULL)
		return;

	msg = skb_put(skb, 3);
	msg->msgflg = 0x24;
	msg->dstaddr = scp->addrrem;

	dn_nsp_send(skb);
}

static int dn_nsp_retrans_conn_conf(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);

	if (scp->state == DN_CC)
		dn_send_conn_conf(sk, GFP_ATOMIC);

	return 0;
}

void dn_send_conn_conf(struct sock *sk, gfp_t gfp)
{
	struct dn_scp *scp = DN_SK(sk);
	struct sk_buff *skb = NULL;
	struct nsp_conn_init_msg *msg;
	__u8 len = (__u8)le16_to_cpu(scp->conndata_out.opt_optl);

	if ((skb = dn_alloc_skb(sk, 50 + len, gfp)) == NULL)
		return;

	msg = skb_put(skb, sizeof(*msg));
	msg->msgflg = 0x28;
	msg->dstaddr = scp->addrrem;
	msg->srcaddr = scp->addrloc;
	msg->services = scp->services_loc;
	msg->info = scp->info_loc;
	msg->segsize = cpu_to_le16(scp->segsize_loc);

	skb_put_u8(skb, len);

	if (len > 0)
		skb_put_data(skb, scp->conndata_out.opt_data, len);


	dn_nsp_send(skb);

	scp->persist = dn_nsp_persist(sk);
	scp->persist_fxn = dn_nsp_retrans_conn_conf;
}


static __inline__ void dn_nsp_do_disc(struct sock *sk, unsigned char msgflg,
			unsigned short reason, gfp_t gfp,
			struct dst_entry *dst,
			int ddl, unsigned char *dd, __le16 rem, __le16 loc)
{
	struct sk_buff *skb = NULL;
	int size = 7 + ddl + ((msgflg == NSP_DISCINIT) ? 1 : 0);
	unsigned char *msg;

	if ((dst == NULL) || (rem == 0)) {
		net_dbg_ratelimited(""DECnet: dn_nsp_do_disc: BUG! Please report this to SteveW@ACM.org rem=%u dst=%p\n"",
				    le16_to_cpu(rem), dst);
		return;
	}

	if ((skb = dn_alloc_skb(sk, size, gfp)) == NULL)
		return;

	msg = skb_put(skb, size);
	*msg++ = msgflg;
	*(__le16 *)msg = rem;
	msg += 2;
	*(__le16 *)msg = loc;
	msg += 2;
	*(__le16 *)msg = cpu_to_le16(reason);
	msg += 2;
	if (msgflg == NSP_DISCINIT)
		*msg++ = ddl;

	if (ddl) {
		memcpy(msg, dd, ddl);
	}

	/*
	 * This doesn't go via the dn_nsp_send() function since we need
	 * to be able to send disc packets out which have no socket
	 * associations.
	 */
	skb_dst_set(skb, dst_clone(dst));
	dst_output(&init_net, skb->sk, skb);
}


void dn_nsp_send_disc(struct sock *sk, unsigned char msgflg,
			unsigned short reason, gfp_t gfp)
{
	struct dn_scp *scp = DN_SK(sk);
	int ddl = 0;

	if (msgflg == NSP_DISCINIT)
		ddl = le16_to_cpu(scp->discdata_out.opt_optl);

	if (reason == 0)
		reason = le16_to_cpu(scp->discdata_out.opt_status);

	dn_nsp_do_disc(sk, msgflg, reason, gfp, __sk_dst_get(sk), ddl,
		scp->discdata_out.opt_data, scp->addrrem, scp->addrloc);
}


void dn_nsp_return_disc(struct sk_buff *skb, unsigned char msgflg,
			unsigned short reason)
{
	struct dn_skb_cb *cb = DN_SKB_CB(skb);
	int ddl = 0;
	gfp_t gfp = GFP_ATOMIC;

	dn_nsp_do_disc(NULL, msgflg, reason, gfp, skb_dst(skb), ddl,
			NULL, cb->src_port, cb->dst_port);
}


void dn_nsp_send_link(struct sock *sk, unsigned char lsflags, char fcval)
{
	struct dn_scp *scp = DN_SK(sk);
	struct sk_buff *skb;
	unsigned char *ptr;
	gfp_t gfp = GFP_ATOMIC;

	if ((skb = dn_alloc_skb(sk, DN_MAX_NSP_DATA_HEADER + 2, gfp)) == NULL)
		return;

	skb_reserve(skb, DN_MAX_NSP_DATA_HEADER);
	ptr = skb_put(skb, 2);
	DN_SKB_CB(skb)->nsp_flags = 0x10;
	*ptr++ = lsflags;
	*ptr = fcval;

	dn_nsp_queue_xmit(sk, skb, gfp, 1);

	scp->persist = dn_nsp_persist(sk);
	scp->persist_fxn = dn_nsp_xmit_timeout;
}

static int dn_nsp_retrans_conninit(struct sock *sk)
{
	struct dn_scp *scp = DN_SK(sk);

	if (scp->state == DN_CI)
		dn_nsp_send_conninit(sk, NSP_RCI);

	return 0;
}

void dn_nsp_send_conninit(struct sock *sk, unsigned char msgflg)
{
	struct dn_scp *scp = DN_SK(sk);
	struct nsp_conn_init_msg *msg;
	unsigned char aux;
	unsigned char menuver;
	struct dn_skb_cb *cb;
	unsigned char type = 1;
	gfp_t allocation = (msgflg == NSP_CI) ? sk->sk_allocation : GFP_ATOMIC;
	struct sk_buff *skb = dn_alloc_skb(sk, 200, allocation);

	if (!skb)
		return;

	cb  = DN_SKB_CB(skb);
	msg = skb_put(skb, sizeof(*msg));

	msg->msgflg	= msgflg;
	msg->dstaddr	= 0x0000;		/* Remote Node will assign it*/

	msg->srcaddr	= scp->addrloc;
	msg->services	= scp->services_loc;	/* Requested flow control    */
	msg->info	= scp->info_loc;	/* Version Number            */
	msg->segsize	= cpu_to_le16(scp->segsize_loc);	/* Max segment size  */

	if (scp->peer.sdn_objnum)
		type = 0;

	skb_put(skb, dn_sockaddr2username(&scp->peer,
					  skb_tail_pointer(skb), type));
	skb_put(skb, dn_sockaddr2username(&scp->addr,
					  skb_tail_pointer(skb), 2));

	menuver = DN_MENUVER_ACC | DN_MENUVER_USR;
	if (scp->peer.sdn_flags & SDF_PROXY)
		menuver |= DN_MENUVER_PRX;
	if (scp->peer.sdn_flags & SDF_UICPROXY)
		menuver |= DN_MENUVER_UIC;

	skb_put_u8(skb, menuver);	/* Menu Version		*/

	aux = scp->accessdata.acc_userl;
	skb_put_u8(skb, aux);
	if (aux > 0)
		skb_put_data(skb, scp->accessdata.acc_user, aux);

	aux = scp->accessdata.acc_passl;
	skb_put_u8(skb, aux);
	if (aux > 0)
		skb_put_data(skb, scp->accessdata.acc_pass, aux);

	aux = scp->accessdata.acc_accl;
	skb_put_u8(skb, aux);
	if (aux > 0)
		skb_put_data(skb, scp->accessdata.acc_acc, aux);

	aux = (__u8)le16_to_cpu(scp->conndata_out.opt_optl);
	skb_put_u8(skb, aux);
	if (aux > 0)
		skb_put_data(skb, scp->conndata_out.opt_data, aux);

	scp->persist = dn_nsp_persist(sk);
	scp->persist_fxn = dn_nsp_retrans_conninit;

	cb->rt_flags = DN_RT_F_RQR;

	dn_nsp_send(skb);
}",1202cdd665315c525b5237e96e0bedc76d7e754f,CVE-2023-3338,1202cdd665315c525b5237e96e0bedc76d7e754f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,"  /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR (VAR) * * VAR: VAR VAR VAR <VAR@VAR.VAR> * * VAR: * * VAR VAR: VAR VAR VAR.VAR VAR VAR.VAR VAR * VAR VAR.VAR. * VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR: VAR VAR VAR VAR VAR'VAR VAR. * VAR VAR: VAR VAR VAR VAR ""VAR"" VAR VAR. * VAR VAR: VAR VAR VAR VAR'VAR VAR VAR VAR VAR! * VAR VAR VAR VAR VAR VAR VAR * VAR VAR: VAR VAR VAR VAR * VAR VAR: VAR VAR VAR VAR. * VAR VAR: VAR VAR VAR VAR() VAR VAR VAR. * VAR VAR: VAR() VAR VAR VAR VAR VAR VAR * VAR VAR: VAR VAR() VAR VAR VAR VAR.VAR */ /****************************************************************************** (VAR) 1995-1998 VAR.VAR. VAR VAR@VAR.VAR *******************************************************************************/                                VAR VAR VAR[VAR + 1] = { 1, 2, 4, 8, 16, 32, 64, 64, 64, 64, 64, 64, 64 }; VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR->VAR; VAR VAR *VAR = VAR(VAR); VAR VAR *VAR; VAR VAR VAR; VAR(VAR); VAR->VAR = VAR; VAR = VAR(VAR, 0); VAR (VAR) { VAR: VAR(VAR, VAR); VAR(&VAR, VAR->VAR, VAR); VAR; } VAR(&VAR, 0, VAR(VAR)); VAR.VAR = VAR->VAR; VAR.VAR = VAR(&VAR->VAR); VAR.VAR = VAR(&VAR->VAR); VAR(&VAR, VAR); VAR.VAR = VAR; VAR (VAR(&VAR->VAR, &VAR, VAR, 0) == 0) { VAR = VAR(VAR); VAR->VAR = VAR->VAR->VAR; VAR VAR; } VAR->VAR = VAR; VAR (!VAR(VAR, VAR)) VAR->VAR(VAR); } /* * VAR VAR == VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR. VAR VAR != VAR, VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR != VAR. */ VAR VAR *VAR(VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR *VAR; VAR VAR = 64; VAR ((VAR = VAR(VAR + VAR, VAR)) == VAR) VAR VAR; VAR->VAR = VAR(VAR); VAR->VAR = VAR; VAR (VAR) VAR(VAR, VAR); VAR(VAR, VAR); VAR VAR; } /* * VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR VAR VAR VAR * VAR[] VAR. */ VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR VAR = ((VAR->VAR >> 2) + VAR->VAR) >> 1; VAR *= VAR[VAR->VAR]; VAR (VAR < VAR) VAR = VAR; VAR (VAR > (600*VAR)) VAR = (600*VAR); VAR (VAR->VAR < VAR) VAR->VAR++;  VAR VAR; } /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR. */ VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR = (VAR)VAR->VAR; VAR VAR = (VAR)VAR->VAR; VAR VAR; /* * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR. */ VAR (VAR < 0) VAR = -VAR; /* * VAR VAR VAR VAR VAR VAR */ VAR = ((VAR << 3) - VAR); VAR += (VAR >> 3); VAR (VAR >= 1) VAR->VAR = (VAR VAR)VAR; VAR VAR->VAR = 1; /* * VAR VAR VAR VAR VAR VAR VAR */ VAR >>= 1; VAR += ((((VAR>0)?(VAR):(-VAR)) - VAR) >> 2); VAR (VAR >= 1) VAR->VAR = (VAR VAR)VAR; VAR VAR->VAR = 1;  } /** * VAR - VAR VAR VAR VAR VAR VAR VAR * @VAR: VAR VAR VAR VAR VAR VAR * @VAR: VAR VAR VAR * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR; VAR VAR = 0; VAR ((VAR = VAR(VAR, VAR)) != VAR) { VAR = VAR->VAR; VAR->VAR++; VAR->VAR = VAR; VAR->VAR = VAR->VAR; VAR(VAR); } VAR VAR; } /** * VAR - VAR VAR VAR VAR VAR VAR VAR * @VAR: VAR VAR VAR VAR VAR VAR VAR VAR * * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR. * */ VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR; VAR VAR VAR = 0; /* * VAR VAR VAR VAR VAR/VAR VAR */ VAR ((VAR = VAR(&VAR->VAR)) != VAR) VAR = VAR(VAR, VAR); /* * VAR VAR VAR VAR VAR VAR VAR, VAR VAR'VAR. * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR, VAR VAR'VAR VAR VAR VAR VAR VAR. */ VAR (VAR || (VAR->VAR != VAR)) VAR VAR; VAR ((VAR = VAR(&VAR->VAR)) != VAR) VAR = VAR(VAR, VAR); /* * VAR VAR'VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR * VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. */ VAR: VAR (VAR) { VAR->VAR >>= 1; VAR (VAR->VAR < VAR) VAR->VAR = VAR; } } VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR(VAR); VAR (!VAR(&VAR->VAR) || !VAR(&VAR->VAR)) VAR->VAR = VAR(VAR); VAR 0; } VAR VAR VAR *VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR, VAR); VAR(VAR < 5); *VAR++ = VAR; *((VAR *)VAR) = VAR->VAR; VAR += 2; *((VAR *)VAR) = VAR->VAR; VAR += 2; VAR (VAR VAR *)VAR; } VAR VAR *VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR VAR, VAR VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR VAR = VAR->VAR & 0x0FFF; VAR VAR VAR = VAR->VAR & 0x0FFF; VAR *VAR; VAR(VAR < 9); VAR->VAR = VAR; VAR->VAR = VAR; VAR |= 0x8000; VAR |= 0x8000;  VAR (VAR) VAR(VAR, VAR);  VAR |= 0x2000; VAR = VAR(VAR, VAR, VAR, VAR); *VAR++ = VAR(VAR); *VAR++ = VAR(VAR); VAR VAR; } VAR VAR *VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR = VAR(VAR); VAR *VAR = VAR(VAR, VAR, VAR->VAR, 11, VAR); VAR (VAR(VAR)) { VAR->VAR = VAR->VAR; VAR(&VAR->VAR, 1); } VAR { VAR->VAR = VAR->VAR; VAR(&VAR->VAR, 1); } *(VAR++) = VAR(VAR->VAR); VAR VAR; } VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR = VAR(VAR); VAR VAR VAR = ((VAR->VAR >> 2) + VAR->VAR) >> 1; VAR->VAR = 0; VAR(VAR, VAR, VAR); /* * VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR, VAR VAR VAR VAR VAR VAR. */ VAR (VAR(VAR->VAR + VAR)) VAR->VAR = VAR; VAR (VAR) VAR(&VAR->VAR, VAR); VAR VAR(&VAR->VAR, VAR); VAR (VAR->VAR != VAR) VAR; VAR(VAR, VAR); } VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR = VAR(VAR); VAR VAR *VAR, *VAR, *VAR = VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR VAR = VAR->VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR(VAR, VAR, VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR(VAR->VAR, VAR)) VAR = VAR;  VAR (VAR == VAR) VAR;   VAR = 0;  VAR = 1;  VAR = VAR->VAR; VAR = VAR->VAR; VAR = VAR->VAR;  VAR(VAR, VAR); VAR(VAR); VAR = VAR; /* * VAR VAR'VAR VAR VAR VAR VAR VAR VAR VAR * VAR'VAR VAR VAR. */ VAR(VAR == 0); /* * VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. */ VAR (VAR == 1) { VAR (VAR(VAR, VAR)) VAR(VAR, (VAR)(VAR - VAR)); VAR (VAR->VAR < VAR->VAR) VAR->VAR++; } /* * VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR (VAR VAR VAR VAR VAR * VAR-VAR-VAR VAR VAR). */ VAR (VAR > 1) VAR = 1; } VAR (VAR) VAR(VAR); VAR VAR; } VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR; VAR ((VAR = VAR(VAR, 9, VAR)) == VAR) VAR; VAR(VAR, 9); VAR(VAR, VAR, 0x04, 9, 0); VAR(VAR); } VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR; VAR ((VAR = VAR(VAR, 9, VAR)) == VAR) VAR; VAR(VAR, 9); VAR(VAR, VAR, 0x14, 9, 1); VAR(VAR); } VAR VAR (VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR = VAR; VAR VAR *VAR; VAR ((VAR = VAR(VAR, 3, VAR->VAR)) == VAR) VAR; VAR = VAR(VAR, 3); VAR->VAR = 0x24; VAR->VAR = VAR->VAR; VAR(VAR); } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR->VAR == VAR) VAR(VAR, VAR); VAR 0; } VAR VAR(VAR VAR *VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR = VAR; VAR VAR *VAR; VAR VAR = (VAR)VAR(VAR->VAR.VAR); VAR ((VAR = VAR(VAR, 50 + VAR, VAR)) == VAR) VAR; VAR = VAR(VAR, VAR(*VAR)); VAR->VAR = 0x28; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; VAR->VAR = VAR(VAR->VAR); VAR(VAR, VAR); VAR (VAR > 0) VAR(VAR, VAR->VAR.VAR, VAR); VAR(VAR); VAR->VAR = VAR(VAR); VAR->VAR = VAR; } VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR VAR, VAR VAR, VAR VAR *VAR, VAR VAR, VAR VAR *VAR, VAR VAR, VAR VAR) { VAR VAR *VAR = VAR; VAR VAR = 7 + VAR + ((VAR == VAR) ? 1 : 0); VAR VAR *VAR; VAR ((VAR == VAR) || (VAR == 0)) { VAR(""VAR: VAR: VAR! VAR VAR VAR VAR VAR@VAR.VAR VAR=%VAR VAR=%VAR\VAR"", VAR(VAR), VAR); VAR; } VAR ((VAR = VAR(VAR, VAR, VAR)) == VAR) VAR; VAR = VAR(VAR, VAR); *VAR++ = VAR; *(VAR *)VAR = VAR; VAR += 2; *(VAR *)VAR = VAR; VAR += 2; *(VAR *)VAR = VAR(VAR); VAR += 2; VAR (VAR == VAR) *VAR++ = VAR; VAR (VAR) { VAR(VAR, VAR, VAR); } /* * VAR VAR'VAR VAR VAR VAR VAR() VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. */ VAR(VAR, VAR(VAR)); VAR(&VAR, VAR->VAR, VAR); } VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR = 0; VAR (VAR == VAR) VAR = VAR(VAR->VAR.VAR); VAR (VAR == 0) VAR = VAR(VAR->VAR.VAR); VAR(VAR, VAR, VAR, VAR, VAR(VAR), VAR, VAR->VAR.VAR, VAR->VAR, VAR->VAR); } VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR = 0; VAR VAR = VAR; VAR(VAR, VAR, VAR, VAR, VAR(VAR), VAR, VAR, VAR->VAR, VAR->VAR); } VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR; VAR VAR *VAR; VAR VAR = VAR; VAR ((VAR = VAR(VAR, VAR + 2, VAR)) == VAR) VAR; VAR(VAR, VAR); VAR = VAR(VAR, 2); VAR(VAR)->VAR = 0x10; *VAR++ = VAR; *VAR = VAR; VAR(VAR, VAR, VAR, 1); VAR->VAR = VAR(VAR); VAR->VAR = VAR; } VAR VAR VAR(VAR VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR (VAR->VAR == VAR) VAR(VAR, VAR); VAR 0; } VAR VAR(VAR VAR *VAR, VAR VAR VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR *VAR; VAR VAR VAR = 1; VAR VAR = (VAR == VAR) ? VAR->VAR : VAR; VAR VAR *VAR = VAR(VAR, 200, VAR); VAR (!VAR) VAR; VAR = VAR(VAR); VAR = VAR(VAR, VAR(*VAR)); VAR->VAR = VAR; VAR->VAR = 0x0000;  VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR;  VAR->VAR = VAR->VAR;  VAR->VAR = VAR(VAR->VAR);  VAR (VAR->VAR.VAR) VAR = 0; VAR(VAR, VAR(&VAR->VAR, VAR(VAR), VAR)); VAR(VAR, VAR(&VAR->VAR, VAR(VAR), 2)); VAR = VAR | VAR; VAR (VAR->VAR.VAR & VAR) VAR |= VAR; VAR (VAR->VAR.VAR & VAR) VAR |= VAR; VAR(VAR, VAR);  VAR = VAR->VAR.VAR; VAR(VAR, VAR); VAR (VAR > 0) VAR(VAR, VAR->VAR.VAR, VAR); VAR = VAR->VAR.VAR; VAR(VAR, VAR); VAR (VAR > 0) VAR(VAR, VAR->VAR.VAR, VAR); VAR = VAR->VAR.VAR; VAR(VAR, VAR); VAR (VAR > 0) VAR(VAR, VAR->VAR.VAR, VAR); VAR = (VAR)VAR(VAR->VAR.VAR); VAR(VAR, VAR); VAR (VAR > 0) VAR(VAR, VAR->VAR.VAR, VAR); VAR->VAR = VAR(VAR); VAR->VAR = VAR; VAR->VAR = VAR; VAR(VAR); }",0,7
linux_176df2457ef6207156ca1a40991c54ca01fef567,arch/x86_64/ia32/ia32entry.S,"	.macro LOAD_ARGS32 offset
	movl \offset(%rsp),%r11d
	movl \offset+8(%rsp),%r10d
	movl \offset+16(%rsp),%r9d
	movl \offset+24(%rsp),%r8d
	movl \offset+40(%rsp),%ecx
	movl \offset+48(%rsp),%edx
	movl \offset+56(%rsp),%esi
	movl \offset+64(%rsp),%edi
	movl \offset+72(%rsp),%eax
	.endm

	LOAD_ARGS32 ARGOFFSET  /* reload args from stack in case ptrace changed it */
	LOAD_ARGS32 ARGOFFSET  /* reload args from stack in case ptrace changed it */
	LOAD_ARGS32 ARGOFFSET  /* reload args from stack in case ptrace changed it */","	LOAD_ARGS ARGOFFSET  /* reload args from stack in case ptrace changed it */
	LOAD_ARGS ARGOFFSET  /* reload args from stack in case ptrace changed it */
	LOAD_ARGS ARGOFFSET  /* reload args from stack in case ptrace changed it */",176df2457ef6207156ca1a40991c54ca01fef567,CVE-2007-4573,176df2457ef6207156ca1a40991c54ca01fef567,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,136,COMPLETED,".VAR VAR VAR VAR \VAR(%VAR),%VAR VAR \VAR+8(%VAR),%VAR VAR \VAR+16(%VAR),%VAR VAR \VAR+24(%VAR),%VAR VAR \VAR+40(%VAR),%VAR VAR \VAR+48(%VAR),%VAR VAR \VAR+56(%VAR),%VAR VAR \VAR+64(%VAR),%VAR VAR \VAR+72(%VAR),%VAR .VAR VAR VAR  VAR VAR  VAR VAR  VAR VAR  VAR VAR  VAR VAR ",0,7
linux_20418acd6874792359b42c12d159f42f17593f34,fs/cifs/connect.c,"

	rc = CIFS_SessSetup(xid, pSesInfo, first_time, nls_info);
		spin_lock(&GlobalMid_Lock);
		pSesInfo->status = CifsGood;
		pSesInfo->need_reconnect = false;
		spin_unlock(&GlobalMid_Lock);","static int
CIFSSessSetup(unsigned int xid, struct cifsSesInfo *ses,
	      char session_key[CIFS_SESS_KEY_SIZE],
	      const struct nls_table *nls_codepage)
{
	struct smb_hdr *smb_buffer;
	struct smb_hdr *smb_buffer_response;
	SESSION_SETUP_ANDX *pSMB;
	SESSION_SETUP_ANDX *pSMBr;
	char *bcc_ptr;
	char *user;
	char *domain;
	int rc = 0;
	int remaining_words = 0;
	int bytes_returned = 0;
	int len;
	__u32 capabilities;
	__u16 count;

	cFYI(1, (""In sesssetup""));
	if (ses == NULL)
		return -EINVAL;
	user = ses->userName;
	domain = ses->domainName;
	smb_buffer = cifs_buf_get();

	if (smb_buffer == NULL)
		return -ENOMEM;

	smb_buffer_response = smb_buffer;
	pSMBr = pSMB = (SESSION_SETUP_ANDX *) smb_buffer;

	/* send SMBsessionSetup here */
	header_assemble(smb_buffer, SMB_COM_SESSION_SETUP_ANDX,
			NULL /* no tCon exists yet */ , 13 /* wct */ );

	smb_buffer->Mid = GetNextMid(ses->server);
	pSMB->req_no_secext.AndXCommand = 0xFF;
	pSMB->req_no_secext.MaxBufferSize = cpu_to_le16(ses->server->maxBuf);
	pSMB->req_no_secext.MaxMpxCount = cpu_to_le16(ses->server->maxReq);

	if (ses->server->secMode &
			(SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))
		smb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;

	capabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |
		CAP_LARGE_WRITE_X | CAP_LARGE_READ_X;
	if (ses->capabilities & CAP_UNICODE) {
		smb_buffer->Flags2 |= SMBFLG2_UNICODE;
		capabilities |= CAP_UNICODE;
	}
	if (ses->capabilities & CAP_STATUS32) {
		smb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;
		capabilities |= CAP_STATUS32;
	}
	if (ses->capabilities & CAP_DFS) {
		smb_buffer->Flags2 |= SMBFLG2_DFS;
		capabilities |= CAP_DFS;
	}
	pSMB->req_no_secext.Capabilities = cpu_to_le32(capabilities);

	pSMB->req_no_secext.CaseInsensitivePasswordLength =
		cpu_to_le16(CIFS_SESS_KEY_SIZE);

	pSMB->req_no_secext.CaseSensitivePasswordLength =
	    cpu_to_le16(CIFS_SESS_KEY_SIZE);
	bcc_ptr = pByteArea(smb_buffer);
	memcpy(bcc_ptr, (char *) session_key, CIFS_SESS_KEY_SIZE);
	bcc_ptr += CIFS_SESS_KEY_SIZE;
	memcpy(bcc_ptr, (char *) session_key, CIFS_SESS_KEY_SIZE);
	bcc_ptr += CIFS_SESS_KEY_SIZE;

	if (ses->capabilities & CAP_UNICODE) {
		if ((long) bcc_ptr % 2) { /* must be word aligned for Unicode */
			*bcc_ptr = 0;
			bcc_ptr++;
		}
		if (user == NULL)
			bytes_returned = 0; /* skip null user */
		else
			bytes_returned =
				cifs_strtoUCS((__le16 *) bcc_ptr, user, 100,
					nls_codepage);
		/* convert number of 16 bit words to bytes */
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;	/* trailing null */
		if (domain == NULL)
			bytes_returned =
			    cifs_strtoUCS((__le16 *) bcc_ptr,
					  ""CIFS_LINUX_DOM"", 32, nls_codepage);
		else
			bytes_returned =
			    cifs_strtoUCS((__le16 *) bcc_ptr, domain, 64,
					  nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, ""Linux version "",
				  32, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, utsname()->release,
				  32, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,
				  64, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;
	} else {
		if (user != NULL) {
		    strncpy(bcc_ptr, user, 200);
		    bcc_ptr += strnlen(user, 200);
		}
		*bcc_ptr = 0;
		bcc_ptr++;
		if (domain == NULL) {
			strcpy(bcc_ptr, ""CIFS_LINUX_DOM"");
			bcc_ptr += strlen(""CIFS_LINUX_DOM"") + 1;
		} else {
			strncpy(bcc_ptr, domain, 64);
			bcc_ptr += strnlen(domain, 64);
			*bcc_ptr = 0;
			bcc_ptr++;
		}
		strcpy(bcc_ptr, ""Linux version "");
		bcc_ptr += strlen(""Linux version "");
		strcpy(bcc_ptr, utsname()->release);
		bcc_ptr += strlen(utsname()->release) + 1;
		strcpy(bcc_ptr, CIFS_NETWORK_OPSYS);
		bcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;
	}
	count = (long) bcc_ptr - (long) pByteArea(smb_buffer);
	smb_buffer->smb_buf_length += count;
	pSMB->req_no_secext.ByteCount = cpu_to_le16(count);

	rc = SendReceive(xid, ses, smb_buffer, smb_buffer_response,
			 &bytes_returned, CIFS_LONG_OP);
	if (rc) {
/* rc = map_smb_to_linux_error(smb_buffer_response); now done in SendReceive */
	} else if ((smb_buffer_response->WordCount == 3)
		   || (smb_buffer_response->WordCount == 4)) {
		__u16 action = le16_to_cpu(pSMBr->resp.Action);
		__u16 blob_len = le16_to_cpu(pSMBr->resp.SecurityBlobLength);
		if (action & GUEST_LOGIN)
			cFYI(1, (""Guest login"")); /* BB mark SesInfo struct? */
		ses->Suid = smb_buffer_response->Uid; /* UID left in wire format
							 (little endian) */
		cFYI(1, (""UID = %d "", ses->Suid));
	/* response can have either 3 or 4 word count - Samba sends 3 */
		bcc_ptr = pByteArea(smb_buffer_response);
		if ((pSMBr->resp.hdr.WordCount == 3)
		    || ((pSMBr->resp.hdr.WordCount == 4)
			&& (blob_len < pSMBr->resp.ByteCount))) {
			if (pSMBr->resp.hdr.WordCount == 4)
				bcc_ptr += blob_len;

			if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
				if ((long) (bcc_ptr) % 2) {
					remaining_words =
					    (BCC(smb_buffer_response) - 1) / 2;
					/* Unicode strings must be word
					   aligned */
					bcc_ptr++;
				} else {
					remaining_words =
						BCC(smb_buffer_response) / 2;
				}
				len =
				    UniStrnlen((wchar_t *) bcc_ptr,
					       remaining_words - 1);
/* We look for obvious messed up bcc or strings in response so we do not go off
   the end since (at least) WIN2K and Windows XP have a major bug in not null
   terminating last Unicode string in response  */
				kfree(ses->serverOS);
				ses->serverOS = kzalloc(2 * (len + 1),
							GFP_KERNEL);
				if (ses->serverOS == NULL)
					goto sesssetup_nomem;
				cifs_strfromUCS_le(ses->serverOS,
						   (__le16 *)bcc_ptr,
						   len, nls_codepage);
				bcc_ptr += 2 * (len + 1);
				remaining_words -= len + 1;
				ses->serverOS[2 * len] = 0;
				ses->serverOS[1 + (2 * len)] = 0;
				if (remaining_words > 0) {
					len = UniStrnlen((wchar_t *)bcc_ptr,
							 remaining_words-1);
					kfree(ses->serverNOS);
					ses->serverNOS = kzalloc(2 * (len + 1),
								 GFP_KERNEL);
					if (ses->serverNOS == NULL)
						goto sesssetup_nomem;
					cifs_strfromUCS_le(ses->serverNOS,
							   (__le16 *)bcc_ptr,
							   len, nls_codepage);
					bcc_ptr += 2 * (len + 1);
					ses->serverNOS[2 * len] = 0;
					ses->serverNOS[1 + (2 * len)] = 0;
					if (strncmp(ses->serverNOS,
						""NT LAN Manager 4"", 16) == 0) {
						cFYI(1, (""NT4 server""));
						ses->flags |= CIFS_SES_NT4;
					}
					remaining_words -= len + 1;
					if (remaining_words > 0) {
						len = UniStrnlen((wchar_t *) bcc_ptr, remaining_words);
				/* last string is not always null terminated
				   (for e.g. for Windows XP & 2000) */
						kfree(ses->serverDomain);
						ses->serverDomain =
						    kzalloc(2*(len+1),
							    GFP_KERNEL);
						if (ses->serverDomain == NULL)
							goto sesssetup_nomem;
						cifs_strfromUCS_le(ses->serverDomain,
							(__le16 *)bcc_ptr,
							len, nls_codepage);
						bcc_ptr += 2 * (len + 1);
						ses->serverDomain[2*len] = 0;
						ses->serverDomain[1+(2*len)] = 0;
					} else { /* else no more room so create
						  dummy domain string */
						kfree(ses->serverDomain);
						ses->serverDomain =
							kzalloc(2, GFP_KERNEL);
					}
				} else { /* no room so create dummy domain
					    and NOS string */

					/* if these kcallocs fail not much we
					   can do, but better to not fail the
					   sesssetup itself */
					kfree(ses->serverDomain);
					ses->serverDomain =
					    kzalloc(2, GFP_KERNEL);
					kfree(ses->serverNOS);
					ses->serverNOS =
					    kzalloc(2, GFP_KERNEL);
				}
			} else {	/* ASCII */
				len = strnlen(bcc_ptr, 1024);
				if (((long) bcc_ptr + len) - (long)
				    pByteArea(smb_buffer_response)
					    <= BCC(smb_buffer_response)) {
					kfree(ses->serverOS);
					ses->serverOS = kzalloc(len + 1,
								GFP_KERNEL);
					if (ses->serverOS == NULL)
						goto sesssetup_nomem;
					strncpy(ses->serverOS, bcc_ptr, len);

					bcc_ptr += len;
					/* null terminate the string */
					bcc_ptr[0] = 0;
					bcc_ptr++;

					len = strnlen(bcc_ptr, 1024);
					kfree(ses->serverNOS);
					ses->serverNOS = kzalloc(len + 1,
								 GFP_KERNEL);
					if (ses->serverNOS == NULL)
						goto sesssetup_nomem;
					strncpy(ses->serverNOS, bcc_ptr, len);
					bcc_ptr += len;
					bcc_ptr[0] = 0;
					bcc_ptr++;

					len = strnlen(bcc_ptr, 1024);
					kfree(ses->serverDomain);
					ses->serverDomain = kzalloc(len + 1,
								    GFP_KERNEL);
					if (ses->serverDomain == NULL)
						goto sesssetup_nomem;
					strncpy(ses->serverDomain, bcc_ptr,
						len);
					bcc_ptr += len;
					bcc_ptr[0] = 0;
					bcc_ptr++;
				} else
					cFYI(1,
					     (""Variable field of length %d ""
						""extends beyond end of smb "",
					      len));
			}
		} else {
			cERROR(1, (""Security Blob Length extends beyond ""
				""end of SMB""));
		}
	} else {
		cERROR(1, (""Invalid Word count %d: "",
			smb_buffer_response->WordCount));
		rc = -EIO;
	}
sesssetup_nomem:	/* do not return an error on nomem for the info strings,
			   since that could make reconnection harder, and
			   reconnection might be needed to free memory */
	cifs_buf_release(smb_buffer);

	return rc;
}

	/*	pSesInfo->sequence_number = 0;*/
	if (experimEnabled < 2)
		rc = CIFS_SessSetup(xid, pSesInfo, first_time, nls_info);
	else if (extended_security
			&& (pSesInfo->capabilities & CAP_EXTENDED_SECURITY)
			&& (server->secType == NTLMSSP)) {
		rc = -EOPNOTSUPP;
	} else if (extended_security
			&& (pSesInfo->capabilities & CAP_EXTENDED_SECURITY)
			&& (server->secType == RawNTLMSSP)) {
		cFYI(1, (""NTLMSSP sesssetup""));
		rc = CIFSNTLMSSPNegotiateSessSetup(xid, pSesInfo, &ntlmv2_flag,
						   nls_info);
		if (!rc) {
			if (ntlmv2_flag) {
				char *v2_response;
				cFYI(1, (""more secure NTLM ver2 hash""));
				if (CalcNTLMv2_partial_mac_key(pSesInfo,
								nls_info)) {
					rc = -ENOMEM;
					goto ss_err_exit;
				} else
					v2_response = kmalloc(16 + 64 /* blob*/,
								GFP_KERNEL);
				if (v2_response) {
					CalcNTLMv2_response(pSesInfo,
								v2_response);
				/*	if (first_time)
						cifs_calculate_ntlmv2_mac_key */
					kfree(v2_response);
					/* BB Put dummy sig in SessSetup PDU? */
				} else {
					rc = -ENOMEM;
					goto ss_err_exit;
				}

			} else {
				SMBNTencrypt(pSesInfo->password,
					     server->cryptKey,
					     ntlm_session_key);

				if (first_time)
					cifs_calculate_mac_key(
					     &server->mac_signing_key,
					     ntlm_session_key,
					     pSesInfo->password);
			}
			/* for better security the weaker lanman hash not sent
			   in AuthSessSetup so we no longer calculate it */

			rc = CIFSNTLMSSPAuthSessSetup(xid, pSesInfo,
						      ntlm_session_key,
						      ntlmv2_flag,
						      nls_info);
		}
	} else { /* old style NTLM 0.12 session setup */
		SMBNTencrypt(pSesInfo->password, server->cryptKey,
			     ntlm_session_key);

		if (first_time)
			cifs_calculate_mac_key(&server->mac_signing_key,
						ntlm_session_key,
						pSesInfo->password);

		rc = CIFSSessSetup(xid, pSesInfo, ntlm_session_key, nls_info);
	}
			spin_lock(&GlobalMid_Lock);
			pSesInfo->status = CifsGood;
			pSesInfo->need_reconnect = false;
			spin_unlock(&GlobalMid_Lock);",20418acd6874792359b42c12d159f42f17593f34,CVE-2009-1633,20418acd6874792359b42c12d159f42f17593f34,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,84,COMPLETED,"VAR = VAR(VAR, VAR, VAR, VAR); VAR(&VAR); VAR->VAR = VAR; VAR->VAR = VAR; VAR(&VAR); VAR VAR VAR(VAR VAR VAR, VAR VAR *VAR, VAR VAR[VAR], VAR VAR VAR *VAR) { VAR VAR *VAR; VAR VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR VAR; VAR VAR; VAR VAR; VAR(1, (""VAR VAR"")); VAR (VAR == VAR) VAR -VAR; VAR = VAR->VAR; VAR = VAR->VAR; VAR = VAR(); VAR (VAR == VAR) VAR -VAR; VAR = VAR; VAR = VAR = (VAR *) VAR;  VAR(VAR, VAR, VAR , 13 ); VAR->VAR = VAR(VAR->VAR); VAR->VAR.VAR = 0xFF; VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR (VAR->VAR->VAR & (VAR | VAR)) VAR->VAR |= VAR; VAR = VAR | VAR | VAR | VAR | VAR; VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR = VAR(VAR); VAR(VAR, (VAR *) VAR, VAR); VAR += VAR; VAR(VAR, (VAR *) VAR, VAR); VAR += VAR; VAR (VAR->VAR & VAR) { VAR ((VAR) VAR % 2) {  *VAR = 0; VAR++; } VAR (VAR == VAR) VAR = 0;  VAR VAR = VAR((VAR *) VAR, VAR, 100, VAR);  VAR += 2 * VAR; VAR += 2;  VAR (VAR == VAR) VAR = VAR((VAR *) VAR, ""VAR"", 32, VAR); VAR VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR += 2 * VAR; VAR += 2; VAR = VAR((VAR *) VAR, ""VAR VAR "", 32, VAR); VAR += 2 * VAR; VAR = VAR((VAR *) VAR, VAR()->VAR, 32, VAR); VAR += 2 * VAR; VAR += 2; VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR += 2 * VAR; VAR += 2; } VAR { VAR (VAR != VAR) { VAR(VAR, VAR, 200); VAR += VAR(VAR, 200); } *VAR = 0; VAR++; VAR (VAR == VAR) { VAR(VAR, ""VAR""); VAR += VAR(""VAR"") + 1; } VAR { VAR(VAR, VAR, 64); VAR += VAR(VAR, 64); *VAR = 0; VAR++; } VAR(VAR, ""VAR VAR ""); VAR += VAR(""VAR VAR ""); VAR(VAR, VAR()->VAR); VAR += VAR(VAR()->VAR) + 1; VAR(VAR, VAR); VAR += VAR(VAR) + 1; } VAR = (VAR) VAR - (VAR) VAR(VAR); VAR->VAR += VAR; VAR->VAR.VAR = VAR(VAR); VAR = VAR(VAR, VAR, VAR, VAR, &VAR, VAR); VAR (VAR) {  } VAR VAR ((VAR->VAR == 3) || (VAR->VAR == 4)) { VAR VAR = VAR(VAR->VAR.VAR); VAR VAR = VAR(VAR->VAR.VAR); VAR (VAR & VAR) VAR(1, (""VAR VAR""));  VAR->VAR = VAR->VAR; /* VAR VAR VAR VAR VAR (VAR VAR) */ VAR(1, (""VAR = %VAR "", VAR->VAR));  VAR = VAR(VAR); VAR ((VAR->VAR.VAR.VAR == 3) || ((VAR->VAR.VAR.VAR == 4) && (VAR < VAR->VAR.VAR))) { VAR (VAR->VAR.VAR.VAR == 4) VAR += VAR; VAR (VAR->VAR & VAR) { VAR ((VAR) (VAR) % 2) { VAR = (VAR(VAR) - 1) / 2; /* VAR VAR VAR VAR VAR VAR */ VAR++; } VAR { VAR = VAR(VAR) / 2; } VAR = VAR((VAR *) VAR, VAR - 1); /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR -= VAR + 1; VAR->VAR[2 * VAR] = 0; VAR->VAR[1 + (2 * VAR)] = 0; VAR (VAR > 0) { VAR = VAR((VAR *)VAR, VAR-1); VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR->VAR[2 * VAR] = 0; VAR->VAR[1 + (2 * VAR)] = 0; VAR (VAR(VAR->VAR, ""VAR VAR VAR 4"", 16) == 0) { VAR(1, (""VAR VAR"")); VAR->VAR |= VAR; } VAR -= VAR + 1; VAR (VAR > 0) { VAR = VAR((VAR *) VAR, VAR); /* VAR VAR VAR VAR VAR VAR VAR (VAR VAR.VAR. VAR VAR VAR & 2000) */ VAR(VAR->VAR); VAR->VAR = VAR(2*(VAR+1), VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, (VAR *)VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR->VAR[2*VAR] = 0; VAR->VAR[1+(2*VAR)] = 0; } VAR { /* VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); } } VAR { /* VAR VAR VAR VAR VAR VAR VAR VAR VAR */ /* VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); } } VAR {  VAR = VAR(VAR, 1024); VAR (((VAR) VAR + VAR) - (VAR) VAR(VAR) <= VAR(VAR)) { VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, VAR, VAR); VAR += VAR;  VAR[0] = 0; VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR (VAR->VAR == VAR) VAR VAR; VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; } VAR VAR(1, (""VAR VAR VAR VAR %VAR "" ""VAR VAR VAR VAR VAR "", VAR)); } } VAR { VAR(1, (""VAR VAR VAR VAR VAR "" ""VAR VAR VAR"")); } } VAR { VAR(1, (""VAR VAR VAR %VAR: "", VAR->VAR)); VAR = -VAR; } VAR: /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR); VAR VAR; }  VAR (VAR < 2) VAR = VAR(VAR, VAR, VAR, VAR); VAR VAR (VAR && (VAR->VAR & VAR) && (VAR->VAR == VAR)) { VAR = -VAR; } VAR VAR (VAR && (VAR->VAR & VAR) && (VAR->VAR == VAR)) { VAR(1, (""VAR VAR"")); VAR = VAR(VAR, VAR, &VAR, VAR); VAR (!VAR) { VAR (VAR) { VAR *VAR; VAR(1, (""VAR VAR VAR VAR VAR"")); VAR (VAR(VAR, VAR)) { VAR = -VAR; VAR VAR; } VAR VAR = VAR(16 + 64 , VAR); VAR (VAR) { VAR(VAR, VAR); /* VAR (VAR) VAR */ VAR(VAR);  } VAR { VAR = -VAR; VAR VAR; } } VAR { VAR(VAR->VAR, VAR->VAR, VAR); VAR (VAR) VAR( &VAR->VAR, VAR, VAR->VAR); } /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR = VAR(VAR, VAR, VAR, VAR, VAR); } } VAR {  VAR(VAR->VAR, VAR->VAR, VAR); VAR (VAR) VAR(&VAR->VAR, VAR, VAR->VAR); VAR = VAR(VAR, VAR, VAR, VAR); } VAR(&VAR); VAR->VAR = VAR; VAR->VAR = VAR; VAR(&VAR);",10,7
linux_2edd6c5b0517b9131ede9e74cb121898ccd73042,fs/cifs/connect.c,,"static int
CIFSNTLMSSPNegotiateSessSetup(unsigned int xid,
			      struct cifsSesInfo *ses, bool *pNTLMv2_flag,
			      const struct nls_table *nls_codepage)
{
	struct smb_hdr *smb_buffer;
	struct smb_hdr *smb_buffer_response;
	SESSION_SETUP_ANDX *pSMB;
	SESSION_SETUP_ANDX *pSMBr;
	char *bcc_ptr;
	char *domain;
	int rc = 0;
	int remaining_words = 0;
	int bytes_returned = 0;
	int len;
	int SecurityBlobLength = sizeof(NEGOTIATE_MESSAGE);
	PNEGOTIATE_MESSAGE SecurityBlob;
	PCHALLENGE_MESSAGE SecurityBlob2;
	__u32 negotiate_flags, capabilities;
	__u16 count;

	cFYI(1, (""In NTLMSSP sesssetup (negotiate)""));
	if (ses == NULL)
		return -EINVAL;
	domain = ses->domainName;
	*pNTLMv2_flag = false;
	smb_buffer = cifs_buf_get();
	if (smb_buffer == NULL) {
		return -ENOMEM;
	}
	smb_buffer_response = smb_buffer;
	pSMB = (SESSION_SETUP_ANDX *) smb_buffer;
	pSMBr = (SESSION_SETUP_ANDX *) smb_buffer_response;

	/* send SMBsessionSetup here */
	header_assemble(smb_buffer, SMB_COM_SESSION_SETUP_ANDX,
			NULL /* no tCon exists yet */ , 12 /* wct */ );

	smb_buffer->Mid = GetNextMid(ses->server);
	pSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;
	pSMB->req.hdr.Flags |= (SMBFLG_CASELESS | SMBFLG_CANONICAL_PATH_FORMAT);

	pSMB->req.AndXCommand = 0xFF;
	pSMB->req.MaxBufferSize = cpu_to_le16(ses->server->maxBuf);
	pSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);

	if (ses->server->secMode & (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))
		smb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;

	capabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |
	    CAP_EXTENDED_SECURITY;
	if (ses->capabilities & CAP_UNICODE) {
		smb_buffer->Flags2 |= SMBFLG2_UNICODE;
		capabilities |= CAP_UNICODE;
	}
	if (ses->capabilities & CAP_STATUS32) {
		smb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;
		capabilities |= CAP_STATUS32;
	}
	if (ses->capabilities & CAP_DFS) {
		smb_buffer->Flags2 |= SMBFLG2_DFS;
		capabilities |= CAP_DFS;
	}
	pSMB->req.Capabilities = cpu_to_le32(capabilities);

	bcc_ptr = (char *) &pSMB->req.SecurityBlob;
	SecurityBlob = (PNEGOTIATE_MESSAGE) bcc_ptr;
	strncpy(SecurityBlob->Signature, NTLMSSP_SIGNATURE, 8);
	SecurityBlob->MessageType = NtLmNegotiate;
	negotiate_flags =
	    NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_NEGOTIATE_OEM |
	    NTLMSSP_REQUEST_TARGET | NTLMSSP_NEGOTIATE_NTLM |
	    NTLMSSP_NEGOTIATE_56 |
	    /* NTLMSSP_NEGOTIATE_ALWAYS_SIGN | */ NTLMSSP_NEGOTIATE_128;
	if (sign_CIFS_PDUs)
		negotiate_flags |= NTLMSSP_NEGOTIATE_SIGN;
	/* setup pointers to domain name and workstation name */
	bcc_ptr += SecurityBlobLength;

	SecurityBlob->WorkstationName.BufferOffset = 0;
	SecurityBlob->WorkstationName.Length = 0;
	SecurityBlob->WorkstationName.MaximumLength = 0;

	/* Domain not sent on first Sesssetup in NTLMSSP, instead it is sent
	along with username on auth request (ie the response to challenge) */
	SecurityBlob->DomainName.BufferOffset = 0;
	SecurityBlob->DomainName.Length = 0;
	SecurityBlob->DomainName.MaximumLength = 0;
	if (ses->capabilities & CAP_UNICODE) {
		if ((long) bcc_ptr % 2) {
			*bcc_ptr = 0;
			bcc_ptr++;
		}

		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, ""Linux version "",
				  32, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, utsname()->release, 32,
				  nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;	/* null terminate Linux version */
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,
				  64, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		*(bcc_ptr + 1) = 0;
		*(bcc_ptr + 2) = 0;
		bcc_ptr += 2;	/* null terminate network opsys string */
		*(bcc_ptr + 1) = 0;
		*(bcc_ptr + 2) = 0;
		bcc_ptr += 2;	/* null domain */
	} else {		/* ASCII */
		strcpy(bcc_ptr, ""Linux version "");
		bcc_ptr += strlen(""Linux version "");
		strcpy(bcc_ptr, utsname()->release);
		bcc_ptr += strlen(utsname()->release) + 1;
		strcpy(bcc_ptr, CIFS_NETWORK_OPSYS);
		bcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;
		bcc_ptr++;	/* empty domain field */
		*bcc_ptr = 0;
	}
	SecurityBlob->NegotiateFlags = cpu_to_le32(negotiate_flags);
	pSMB->req.SecurityBlobLength = cpu_to_le16(SecurityBlobLength);
	count = (long) bcc_ptr - (long) pByteArea(smb_buffer);
	smb_buffer->smb_buf_length += count;
	pSMB->req.ByteCount = cpu_to_le16(count);

	rc = SendReceive(xid, ses, smb_buffer, smb_buffer_response,
			 &bytes_returned, CIFS_LONG_OP);

	if (smb_buffer_response->Status.CifsError ==
	    cpu_to_le32(NT_STATUS_MORE_PROCESSING_REQUIRED))
		rc = 0;

	if (rc) {
/*    rc = map_smb_to_linux_error(smb_buffer_response);  *//* done in SendReceive now */
	} else if ((smb_buffer_response->WordCount == 3)
		   || (smb_buffer_response->WordCount == 4)) {
		__u16 action = le16_to_cpu(pSMBr->resp.Action);
		__u16 blob_len = le16_to_cpu(pSMBr->resp.SecurityBlobLength);

		if (action & GUEST_LOGIN)
			cFYI(1, (""Guest login""));
	/* Do we want to set anything in SesInfo struct when guest login? */

		bcc_ptr = pByteArea(smb_buffer_response);
	/* response can have either 3 or 4 word count - Samba sends 3 */

		SecurityBlob2 = (PCHALLENGE_MESSAGE) bcc_ptr;
		if (SecurityBlob2->MessageType != NtLmChallenge) {
			cFYI(1, (""Unexpected NTLMSSP message type received %d"",
			      SecurityBlob2->MessageType));
		} else if (ses) {
			ses->Suid = smb_buffer_response->Uid; /* UID left in le format */
			cFYI(1, (""UID = %d"", ses->Suid));
			if ((pSMBr->resp.hdr.WordCount == 3)
			    || ((pSMBr->resp.hdr.WordCount == 4)
				&& (blob_len <
				    pSMBr->resp.ByteCount))) {

				if (pSMBr->resp.hdr.WordCount == 4) {
					bcc_ptr += blob_len;
					cFYI(1, (""Security Blob Length %d"",
					      blob_len));
				}

				cFYI(1, (""NTLMSSP Challenge rcvd""));

				memcpy(ses->server->cryptKey,
				       SecurityBlob2->Challenge,
				       CIFS_CRYPTO_KEY_SIZE);
/* NTLMV2 flag is not for NTLMv2 password hash */
/*				if (SecurityBlob2->NegotiateFlags &
					cpu_to_le32(NTLMSSP_NEGOTIATE_NTLMV2))
					*pNTLMv2_flag = true; */ /* BB wrong */

				if ((SecurityBlob2->NegotiateFlags &
					cpu_to_le32(NTLMSSP_NEGOTIATE_ALWAYS_SIGN))
					|| (sign_CIFS_PDUs > 1))
						ses->server->secMode |=
							SECMODE_SIGN_REQUIRED;
				if ((SecurityBlob2->NegotiateFlags &
					cpu_to_le32(NTLMSSP_NEGOTIATE_SIGN)) && (sign_CIFS_PDUs))
						ses->server->secMode |=
							SECMODE_SIGN_ENABLED;

				if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
					if ((long) (bcc_ptr) % 2) {
						remaining_words =
						    (BCC(smb_buffer_response)
						     - 1) / 2;
					 /* Must word align unicode strings */
						bcc_ptr++;
					} else {
						remaining_words =
						    BCC
						    (smb_buffer_response) / 2;
					}
					len =
					    UniStrnlen((wchar_t *) bcc_ptr,
						       remaining_words - 1);
/* We look for obvious messed up bcc or strings in response so we do not go off
   the end since (at least) WIN2K and Windows XP have a major bug in not null
   terminating last Unicode string in response  */
					kfree(ses->serverOS);
					ses->serverOS =
					    kzalloc(2 * (len + 1), GFP_KERNEL);
					cifs_strfromUCS_le(ses->serverOS,
							   (__le16 *)
							   bcc_ptr, len,
							   nls_codepage);
					bcc_ptr += 2 * (len + 1);
					remaining_words -= len + 1;
					ses->serverOS[2 * len] = 0;
					ses->serverOS[1 + (2 * len)] = 0;
					if (remaining_words > 0) {
						len = UniStrnlen((wchar_t *)
								 bcc_ptr,
								 remaining_words
								 - 1);
						kfree(ses->serverNOS);
						ses->serverNOS =
						    kzalloc(2 * (len + 1),
							    GFP_KERNEL);
						cifs_strfromUCS_le(ses->
								   serverNOS,
								   (__le16 *)
								   bcc_ptr,
								   len,
								   nls_codepage);
						bcc_ptr += 2 * (len + 1);
						ses->serverNOS[2 * len] = 0;
						ses->serverNOS[1 +
							       (2 * len)] = 0;
						remaining_words -= len + 1;
						if (remaining_words > 0) {
							len = UniStrnlen((wchar_t *) bcc_ptr, remaining_words);
				/* last string not always null terminated
				   (for e.g. for Windows XP & 2000) */
							kfree(ses->serverDomain);
							ses->serverDomain =
							    kzalloc(2 *
								    (len +
								     1),
								    GFP_KERNEL);
							cifs_strfromUCS_le
							    (ses->serverDomain,
							     (__le16 *)bcc_ptr,
							     len, nls_codepage);
							bcc_ptr +=
							    2 * (len + 1);
							ses->serverDomain[2*len]
							    = 0;
							ses->serverDomain
								[1 + (2 * len)]
							    = 0;
						} /* else no more room so create dummy domain string */
						else {
							kfree(ses->serverDomain);
							ses->serverDomain =
							    kzalloc(2,
								    GFP_KERNEL);
						}
					} else {	/* no room so create dummy domain and NOS string */
						kfree(ses->serverDomain);
						ses->serverDomain =
						    kzalloc(2, GFP_KERNEL);
						kfree(ses->serverNOS);
						ses->serverNOS =
						    kzalloc(2, GFP_KERNEL);
					}
				} else {	/* ASCII */
					len = strnlen(bcc_ptr, 1024);
					if (((long) bcc_ptr + len) - (long)
					    pByteArea(smb_buffer_response)
					    <= BCC(smb_buffer_response)) {
						kfree(ses->serverOS);
						ses->serverOS =
						    kzalloc(len + 1,
							    GFP_KERNEL);
						strncpy(ses->serverOS,
							bcc_ptr, len);

						bcc_ptr += len;
						bcc_ptr[0] = 0;	/* null terminate string */
						bcc_ptr++;

						len = strnlen(bcc_ptr, 1024);
						kfree(ses->serverNOS);
						ses->serverNOS =
						    kzalloc(len + 1,
							    GFP_KERNEL);
						strncpy(ses->serverNOS, bcc_ptr, len);
						bcc_ptr += len;
						bcc_ptr[0] = 0;
						bcc_ptr++;

						len = strnlen(bcc_ptr, 1024);
						kfree(ses->serverDomain);
						ses->serverDomain =
						    kzalloc(len + 1,
							    GFP_KERNEL);
						strncpy(ses->serverDomain,
							bcc_ptr, len);
						bcc_ptr += len;
						bcc_ptr[0] = 0;
						bcc_ptr++;
					} else
						cFYI(1,
						     (""field of length %d ""
						    ""extends beyond end of smb"",
						      len));
				}
			} else {
				cERROR(1, (""Security Blob Length extends beyond""
					   "" end of SMB""));
			}
		} else {
			cERROR(1, (""No session structure passed in.""));
		}
	} else {
		cERROR(1, (""Invalid Word count %d:"",
			smb_buffer_response->WordCount));
		rc = -EIO;
	}

	cifs_buf_release(smb_buffer);

	return rc;
}

static int
CIFSNTLMSSPAuthSessSetup(unsigned int xid, struct cifsSesInfo *ses,
			char *ntlm_session_key, bool ntlmv2_flag,
			const struct nls_table *nls_codepage)
{
	struct smb_hdr *smb_buffer;
	struct smb_hdr *smb_buffer_response;
	SESSION_SETUP_ANDX *pSMB;
	SESSION_SETUP_ANDX *pSMBr;
	char *bcc_ptr;
	char *user;
	char *domain;
	int rc = 0;
	int remaining_words = 0;
	int bytes_returned = 0;
	int len;
	int SecurityBlobLength = sizeof(AUTHENTICATE_MESSAGE);
	PAUTHENTICATE_MESSAGE SecurityBlob;
	__u32 negotiate_flags, capabilities;
	__u16 count;

	cFYI(1, (""In NTLMSSPSessSetup (Authenticate)""));
	if (ses == NULL)
		return -EINVAL;
	user = ses->userName;
	domain = ses->domainName;
	smb_buffer = cifs_buf_get();
	if (smb_buffer == NULL) {
		return -ENOMEM;
	}
	smb_buffer_response = smb_buffer;
	pSMB = (SESSION_SETUP_ANDX *)smb_buffer;
	pSMBr = (SESSION_SETUP_ANDX *)smb_buffer_response;

	/* send SMBsessionSetup here */
	header_assemble(smb_buffer, SMB_COM_SESSION_SETUP_ANDX,
			NULL /* no tCon exists yet */ , 12 /* wct */ );

	smb_buffer->Mid = GetNextMid(ses->server);
	pSMB->req.hdr.Flags |= (SMBFLG_CASELESS | SMBFLG_CANONICAL_PATH_FORMAT);
	pSMB->req.hdr.Flags2 |= SMBFLG2_EXT_SEC;
	pSMB->req.AndXCommand = 0xFF;
	pSMB->req.MaxBufferSize = cpu_to_le16(ses->server->maxBuf);
	pSMB->req.MaxMpxCount = cpu_to_le16(ses->server->maxReq);

	pSMB->req.hdr.Uid = ses->Suid;

	if (ses->server->secMode & (SECMODE_SIGN_REQUIRED | SECMODE_SIGN_ENABLED))
		smb_buffer->Flags2 |= SMBFLG2_SECURITY_SIGNATURE;

	capabilities = CAP_LARGE_FILES | CAP_NT_SMBS | CAP_LEVEL_II_OPLOCKS |
			CAP_EXTENDED_SECURITY;
	if (ses->capabilities & CAP_UNICODE) {
		smb_buffer->Flags2 |= SMBFLG2_UNICODE;
		capabilities |= CAP_UNICODE;
	}
	if (ses->capabilities & CAP_STATUS32) {
		smb_buffer->Flags2 |= SMBFLG2_ERR_STATUS;
		capabilities |= CAP_STATUS32;
	}
	if (ses->capabilities & CAP_DFS) {
		smb_buffer->Flags2 |= SMBFLG2_DFS;
		capabilities |= CAP_DFS;
	}
	pSMB->req.Capabilities = cpu_to_le32(capabilities);

	bcc_ptr = (char *)&pSMB->req.SecurityBlob;
	SecurityBlob = (PAUTHENTICATE_MESSAGE)bcc_ptr;
	strncpy(SecurityBlob->Signature, NTLMSSP_SIGNATURE, 8);
	SecurityBlob->MessageType = NtLmAuthenticate;
	bcc_ptr += SecurityBlobLength;
	negotiate_flags = NTLMSSP_NEGOTIATE_UNICODE | NTLMSSP_REQUEST_TARGET |
			NTLMSSP_NEGOTIATE_NTLM | NTLMSSP_NEGOTIATE_TARGET_INFO |
			NTLMSSP_NEGOTIATE_56 | NTLMSSP_NEGOTIATE_128 |
			NTLMSSP_NEGOTIATE_EXTENDED_SEC;
	if (sign_CIFS_PDUs)
		negotiate_flags |= /* NTLMSSP_NEGOTIATE_ALWAYS_SIGN |*/ NTLMSSP_NEGOTIATE_SIGN;

/* setup pointers to domain name and workstation name */

	SecurityBlob->WorkstationName.BufferOffset = 0;
	SecurityBlob->WorkstationName.Length = 0;
	SecurityBlob->WorkstationName.MaximumLength = 0;
	SecurityBlob->SessionKey.Length = 0;
	SecurityBlob->SessionKey.MaximumLength = 0;
	SecurityBlob->SessionKey.BufferOffset = 0;

	SecurityBlob->LmChallengeResponse.Length = 0;
	SecurityBlob->LmChallengeResponse.MaximumLength = 0;
	SecurityBlob->LmChallengeResponse.BufferOffset = 0;

	SecurityBlob->NtChallengeResponse.Length =
	    cpu_to_le16(CIFS_SESS_KEY_SIZE);
	SecurityBlob->NtChallengeResponse.MaximumLength =
	    cpu_to_le16(CIFS_SESS_KEY_SIZE);
	memcpy(bcc_ptr, ntlm_session_key, CIFS_SESS_KEY_SIZE);
	SecurityBlob->NtChallengeResponse.BufferOffset =
	    cpu_to_le32(SecurityBlobLength);
	SecurityBlobLength += CIFS_SESS_KEY_SIZE;
	bcc_ptr += CIFS_SESS_KEY_SIZE;

	if (ses->capabilities & CAP_UNICODE) {
		if (domain == NULL) {
			SecurityBlob->DomainName.BufferOffset = 0;
			SecurityBlob->DomainName.Length = 0;
			SecurityBlob->DomainName.MaximumLength = 0;
		} else {
			__u16 ln = cifs_strtoUCS((__le16 *) bcc_ptr, domain, 64,
					  nls_codepage);
			ln *= 2;
			SecurityBlob->DomainName.MaximumLength =
			    cpu_to_le16(ln);
			SecurityBlob->DomainName.BufferOffset =
			    cpu_to_le32(SecurityBlobLength);
			bcc_ptr += ln;
			SecurityBlobLength += ln;
			SecurityBlob->DomainName.Length = cpu_to_le16(ln);
		}
		if (user == NULL) {
			SecurityBlob->UserName.BufferOffset = 0;
			SecurityBlob->UserName.Length = 0;
			SecurityBlob->UserName.MaximumLength = 0;
		} else {
			__u16 ln = cifs_strtoUCS((__le16 *) bcc_ptr, user, 64,
					  nls_codepage);
			ln *= 2;
			SecurityBlob->UserName.MaximumLength =
			    cpu_to_le16(ln);
			SecurityBlob->UserName.BufferOffset =
			    cpu_to_le32(SecurityBlobLength);
			bcc_ptr += ln;
			SecurityBlobLength += ln;
			SecurityBlob->UserName.Length = cpu_to_le16(ln);
		}

		/* SecurityBlob->WorkstationName.Length =
		 cifs_strtoUCS((__le16 *) bcc_ptr, ""AMACHINE"",64, nls_codepage);
		   SecurityBlob->WorkstationName.Length *= 2;
		   SecurityBlob->WorkstationName.MaximumLength =
			cpu_to_le16(SecurityBlob->WorkstationName.Length);
		   SecurityBlob->WorkstationName.BufferOffset =
				 cpu_to_le32(SecurityBlobLength);
		   bcc_ptr += SecurityBlob->WorkstationName.Length;
		   SecurityBlobLength += SecurityBlob->WorkstationName.Length;
		   SecurityBlob->WorkstationName.Length =
			cpu_to_le16(SecurityBlob->WorkstationName.Length);  */

		if ((long) bcc_ptr % 2) {
			*bcc_ptr = 0;
			bcc_ptr++;
		}
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, ""Linux version "",
				  32, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, utsname()->release, 32,
				  nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		bcc_ptr += 2;	/* null term version string */
		bytes_returned =
		    cifs_strtoUCS((__le16 *) bcc_ptr, CIFS_NETWORK_OPSYS,
				  64, nls_codepage);
		bcc_ptr += 2 * bytes_returned;
		*(bcc_ptr + 1) = 0;
		*(bcc_ptr + 2) = 0;
		bcc_ptr += 2;	/* null terminate network opsys string */
		*(bcc_ptr + 1) = 0;
		*(bcc_ptr + 2) = 0;
		bcc_ptr += 2;	/* null domain */
	} else {		/* ASCII */
		if (domain == NULL) {
			SecurityBlob->DomainName.BufferOffset = 0;
			SecurityBlob->DomainName.Length = 0;
			SecurityBlob->DomainName.MaximumLength = 0;
		} else {
			__u16 ln;
			negotiate_flags |= NTLMSSP_NEGOTIATE_DOMAIN_SUPPLIED;
			strncpy(bcc_ptr, domain, 63);
			ln = strnlen(domain, 64);
			SecurityBlob->DomainName.MaximumLength =
			    cpu_to_le16(ln);
			SecurityBlob->DomainName.BufferOffset =
			    cpu_to_le32(SecurityBlobLength);
			bcc_ptr += ln;
			SecurityBlobLength += ln;
			SecurityBlob->DomainName.Length = cpu_to_le16(ln);
		}
		if (user == NULL) {
			SecurityBlob->UserName.BufferOffset = 0;
			SecurityBlob->UserName.Length = 0;
			SecurityBlob->UserName.MaximumLength = 0;
		} else {
			__u16 ln;
			strncpy(bcc_ptr, user, 63);
			ln = strnlen(user, 64);
			SecurityBlob->UserName.MaximumLength = cpu_to_le16(ln);
			SecurityBlob->UserName.BufferOffset =
						cpu_to_le32(SecurityBlobLength);
			bcc_ptr += ln;
			SecurityBlobLength += ln;
			SecurityBlob->UserName.Length = cpu_to_le16(ln);
		}
		/* BB fill in our workstation name if known BB */

		strcpy(bcc_ptr, ""Linux version "");
		bcc_ptr += strlen(""Linux version "");
		strcpy(bcc_ptr, utsname()->release);
		bcc_ptr += strlen(utsname()->release) + 1;
		strcpy(bcc_ptr, CIFS_NETWORK_OPSYS);
		bcc_ptr += strlen(CIFS_NETWORK_OPSYS) + 1;
		bcc_ptr++;	/* null domain */
		*bcc_ptr = 0;
	}
	SecurityBlob->NegotiateFlags = cpu_to_le32(negotiate_flags);
	pSMB->req.SecurityBlobLength = cpu_to_le16(SecurityBlobLength);
	count = (long) bcc_ptr - (long) pByteArea(smb_buffer);
	smb_buffer->smb_buf_length += count;
	pSMB->req.ByteCount = cpu_to_le16(count);

	rc = SendReceive(xid, ses, smb_buffer, smb_buffer_response,
			 &bytes_returned, CIFS_LONG_OP);
	if (rc) {
/*   rc = map_smb_to_linux_error(smb_buffer_response) done in SendReceive now */
	} else if ((smb_buffer_response->WordCount == 3) ||
		   (smb_buffer_response->WordCount == 4)) {
		__u16 action = le16_to_cpu(pSMBr->resp.Action);
		__u16 blob_len = le16_to_cpu(pSMBr->resp.SecurityBlobLength);
		if (action & GUEST_LOGIN)
			cFYI(1, (""Guest login"")); /* BB Should we set anything
							 in SesInfo struct ? */
/*		if (SecurityBlob2->MessageType != NtLm??) {
			cFYI(""Unexpected message type on auth response is %d""));
		} */

		if (ses) {
			cFYI(1,
			     (""Check challenge UID %d vs auth response UID %d"",
			      ses->Suid, smb_buffer_response->Uid));
			/* UID left in wire format */
			ses->Suid = smb_buffer_response->Uid;
			bcc_ptr = pByteArea(smb_buffer_response);
		/* response can have either 3 or 4 word count - Samba sends 3 */
			if ((pSMBr->resp.hdr.WordCount == 3)
			    || ((pSMBr->resp.hdr.WordCount == 4)
				&& (blob_len <
				    pSMBr->resp.ByteCount))) {
				if (pSMBr->resp.hdr.WordCount == 4) {
					bcc_ptr +=
					    blob_len;
					cFYI(1,
					     (""Security Blob Length %d "",
					      blob_len));
				}

				cFYI(1,
				     (""NTLMSSP response to Authenticate ""));

				if (smb_buffer->Flags2 & SMBFLG2_UNICODE) {
					if ((long) (bcc_ptr) % 2) {
						remaining_words =
						    (BCC(smb_buffer_response)
						     - 1) / 2;
						bcc_ptr++;	/* Unicode strings must be word aligned */
					} else {
						remaining_words = BCC(smb_buffer_response) / 2;
					}
					len = UniStrnlen((wchar_t *) bcc_ptr,
							remaining_words - 1);
/* We look for obvious messed up bcc or strings in response so we do not go off
  the end since (at least) WIN2K and Windows XP have a major bug in not null
  terminating last Unicode string in response  */
					kfree(ses->serverOS);
					ses->serverOS =
					    kzalloc(2 * (len + 1), GFP_KERNEL);
					cifs_strfromUCS_le(ses->serverOS,
							   (__le16 *)
							   bcc_ptr, len,
							   nls_codepage);
					bcc_ptr += 2 * (len + 1);
					remaining_words -= len + 1;
					ses->serverOS[2 * len] = 0;
					ses->serverOS[1 + (2 * len)] = 0;
					if (remaining_words > 0) {
						len = UniStrnlen((wchar_t *)
								 bcc_ptr,
								 remaining_words
								 - 1);
						kfree(ses->serverNOS);
						ses->serverNOS =
						    kzalloc(2 * (len + 1),
							    GFP_KERNEL);
						cifs_strfromUCS_le(ses->
								   serverNOS,
								   (__le16 *)
								   bcc_ptr,
								   len,
								   nls_codepage);
						bcc_ptr += 2 * (len + 1);
						ses->serverNOS[2 * len] = 0;
						ses->serverNOS[1+(2*len)] = 0;
						remaining_words -= len + 1;
						if (remaining_words > 0) {
							len = UniStrnlen((wchar_t *) bcc_ptr, remaining_words);
     /* last string not always null terminated (e.g. for Windows XP & 2000) */
							kfree(ses->serverDomain);
							ses->serverDomain =
							    kzalloc(2 *
								    (len +
								     1),
								    GFP_KERNEL);
							cifs_strfromUCS_le
							    (ses->
							     serverDomain,
							     (__le16 *)
							     bcc_ptr, len,
							     nls_codepage);
							bcc_ptr +=
							    2 * (len + 1);
							ses->
							    serverDomain[2
									 * len]
							    = 0;
							ses->
							    serverDomain[1
									 +
									 (2
									  *
									  len)]
							    = 0;
						} /* else no more room so create dummy domain string */
						else {
							kfree(ses->serverDomain);
							ses->serverDomain = kzalloc(2,GFP_KERNEL);
						}
					} else {  /* no room so create dummy domain and NOS string */
						kfree(ses->serverDomain);
						ses->serverDomain = kzalloc(2, GFP_KERNEL);
						kfree(ses->serverNOS);
						ses->serverNOS = kzalloc(2, GFP_KERNEL);
					}
				} else {	/* ASCII */
					len = strnlen(bcc_ptr, 1024);
					if (((long) bcc_ptr + len) -
					   (long) pByteArea(smb_buffer_response)
						<= BCC(smb_buffer_response)) {
						kfree(ses->serverOS);
						ses->serverOS = kzalloc(len + 1, GFP_KERNEL);
						strncpy(ses->serverOS,bcc_ptr, len);

						bcc_ptr += len;
						bcc_ptr[0] = 0;	/* null terminate the string */
						bcc_ptr++;

						len = strnlen(bcc_ptr, 1024);
						kfree(ses->serverNOS);
						ses->serverNOS = kzalloc(len+1,
								    GFP_KERNEL);
						strncpy(ses->serverNOS,
							bcc_ptr, len);
						bcc_ptr += len;
						bcc_ptr[0] = 0;
						bcc_ptr++;

						len = strnlen(bcc_ptr, 1024);
						kfree(ses->serverDomain);
						ses->serverDomain =
								kzalloc(len+1,
								    GFP_KERNEL);
						strncpy(ses->serverDomain,
							bcc_ptr, len);
						bcc_ptr += len;
						bcc_ptr[0] = 0;
						bcc_ptr++;
					} else
						cFYI(1, (""field of length %d ""
						   ""extends beyond end of smb "",
						      len));
				}
			} else {
				cERROR(1, (""Security Blob extends beyond end ""
					""of SMB""));
			}
		} else {
			cERROR(1, (""No session structure passed in.""));
		}
	} else {
		cERROR(1, (""Invalid Word count %d: "",
			smb_buffer_response->WordCount));
		rc = -EIO;
	}

	cifs_buf_release(smb_buffer);

	return rc;
}
",2edd6c5b0517b9131ede9e74cb121898ccd73042,CVE-2009-1633,2edd6c5b0517b9131ede9e74cb121898ccd73042,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,80,COMPLETED," VAR VAR VAR(VAR VAR VAR, VAR VAR *VAR, VAR *VAR, VAR VAR VAR *VAR) { VAR VAR *VAR; VAR VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR VAR; VAR VAR = VAR(VAR); VAR VAR; VAR VAR; VAR VAR, VAR; VAR VAR; VAR(1, (""VAR VAR VAR (VAR)"")); VAR (VAR == VAR) VAR -VAR; VAR = VAR->VAR; *VAR = VAR; VAR = VAR(); VAR (VAR == VAR) { VAR -VAR; } VAR = VAR; VAR = (VAR *) VAR; VAR = (VAR *) VAR;  VAR(VAR, VAR, VAR , 12 ); VAR->VAR = VAR(VAR->VAR); VAR->VAR.VAR.VAR |= VAR; VAR->VAR.VAR.VAR |= (VAR | VAR); VAR->VAR.VAR = 0xFF; VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR (VAR->VAR->VAR & (VAR | VAR)) VAR->VAR |= VAR; VAR = VAR | VAR | VAR | VAR; VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR->VAR.VAR = VAR(VAR); VAR = (VAR *) &VAR->VAR.VAR; VAR = (VAR) VAR; VAR(VAR->VAR, VAR, 8); VAR->VAR = VAR; VAR = VAR | VAR | VAR | VAR | VAR |  VAR; VAR (VAR) VAR |= VAR;  VAR += VAR; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; /* VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR VAR VAR VAR VAR) */ VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR (VAR->VAR & VAR) { VAR ((VAR) VAR % 2) { *VAR = 0; VAR++; } VAR = VAR((VAR *) VAR, ""VAR VAR "", 32, VAR); VAR += 2 * VAR; VAR = VAR((VAR *) VAR, VAR()->VAR, 32, VAR); VAR += 2 * VAR; VAR += 2;  VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR += 2 * VAR; *(VAR + 1) = 0; *(VAR + 2) = 0; VAR += 2;  *(VAR + 1) = 0; *(VAR + 2) = 0; VAR += 2;  } VAR {  VAR(VAR, ""VAR VAR ""); VAR += VAR(""VAR VAR ""); VAR(VAR, VAR()->VAR); VAR += VAR(VAR()->VAR) + 1; VAR(VAR, VAR); VAR += VAR(VAR) + 1; VAR++;  *VAR = 0; } VAR->VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR = (VAR) VAR - (VAR) VAR(VAR); VAR->VAR += VAR; VAR->VAR.VAR = VAR(VAR); VAR = VAR(VAR, VAR, VAR, VAR, &VAR, VAR); VAR (VAR->VAR.VAR == VAR(VAR)) VAR = 0; VAR (VAR) { /* VAR = VAR(VAR); * } VAR VAR ((VAR->VAR == 3) || (VAR->VAR == 4)) { VAR VAR = VAR(VAR->VAR.VAR); VAR VAR = VAR(VAR->VAR.VAR); VAR (VAR & VAR) VAR(1, (""VAR VAR""));  VAR = VAR(VAR);  VAR = (VAR) VAR; VAR (VAR->VAR != VAR) { VAR(1, (""VAR VAR VAR VAR VAR %VAR"", VAR->VAR)); } VAR VAR (VAR) { VAR->VAR = VAR->VAR;  VAR(1, (""VAR = %VAR"", VAR->VAR)); VAR ((VAR->VAR.VAR.VAR == 3) || ((VAR->VAR.VAR.VAR == 4) && (VAR < VAR->VAR.VAR))) { VAR (VAR->VAR.VAR.VAR == 4) { VAR += VAR; VAR(1, (""VAR VAR VAR %VAR"", VAR)); } VAR(1, (""VAR VAR VAR"")); VAR(VAR->VAR->VAR, VAR->VAR, VAR);  /* VAR (VAR->VAR & VAR(VAR)) *VAR = VAR; */  VAR ((VAR->VAR & VAR(VAR)) || (VAR > 1)) VAR->VAR->VAR |= VAR; VAR ((VAR->VAR & VAR(VAR)) && (VAR)) VAR->VAR->VAR |= VAR; VAR (VAR->VAR & VAR) { VAR ((VAR) (VAR) % 2) { VAR = (VAR(VAR) - 1) / 2;  VAR++; } VAR { VAR = VAR (VAR) / 2; } VAR = VAR((VAR *) VAR, VAR - 1); /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR(VAR->VAR, (VAR *) VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR -= VAR + 1; VAR->VAR[2 * VAR] = 0; VAR->VAR[1 + (2 * VAR)] = 0; VAR (VAR > 0) { VAR = VAR((VAR *) VAR, VAR - 1); VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR(VAR-> VAR, (VAR *) VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR->VAR[2 * VAR] = 0; VAR->VAR[1 + (2 * VAR)] = 0; VAR -= VAR + 1; VAR (VAR > 0) { VAR = VAR((VAR *) VAR, VAR); /* VAR VAR VAR VAR VAR VAR (VAR VAR.VAR. VAR VAR VAR & 2000) */ VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR (VAR->VAR, (VAR *)VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR->VAR[2*VAR] = 0; VAR->VAR [1 + (2 * VAR)] = 0; }  VAR { VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); } } VAR {  VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); } } VAR {  VAR = VAR(VAR, 1024); VAR (((VAR) VAR + VAR) - (VAR) VAR(VAR) <= VAR(VAR)) { VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0;  VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; } VAR VAR(1, (""VAR VAR VAR %VAR "" ""VAR VAR VAR VAR VAR"", VAR)); } } VAR { VAR(1, (""VAR VAR VAR VAR VAR"" "" VAR VAR VAR"")); } } VAR { VAR(1, (""VAR VAR VAR VAR VAR."")); } } VAR { VAR(1, (""VAR VAR VAR %VAR:"", VAR->VAR)); VAR = -VAR; } VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR VAR, VAR VAR *VAR, VAR *VAR, VAR VAR, VAR VAR VAR *VAR) { VAR VAR *VAR; VAR VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR *VAR; VAR VAR = 0; VAR VAR = 0; VAR VAR = 0; VAR VAR; VAR VAR = VAR(VAR); VAR VAR; VAR VAR, VAR; VAR VAR; VAR(1, (""VAR VAR (VAR)"")); VAR (VAR == VAR) VAR -VAR; VAR = VAR->VAR; VAR = VAR->VAR; VAR = VAR(); VAR (VAR == VAR) { VAR -VAR; } VAR = VAR; VAR = (VAR *)VAR; VAR = (VAR *)VAR;  VAR(VAR, VAR, VAR , 12 ); VAR->VAR = VAR(VAR->VAR); VAR->VAR.VAR.VAR |= (VAR | VAR); VAR->VAR.VAR.VAR |= VAR; VAR->VAR.VAR = 0xFF; VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR->VAR.VAR = VAR(VAR->VAR->VAR); VAR->VAR.VAR.VAR = VAR->VAR; VAR (VAR->VAR->VAR & (VAR | VAR)) VAR->VAR |= VAR; VAR = VAR | VAR | VAR | VAR; VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR (VAR->VAR & VAR) { VAR->VAR |= VAR; VAR |= VAR; } VAR->VAR.VAR = VAR(VAR); VAR = (VAR *)&VAR->VAR.VAR; VAR = (VAR)VAR; VAR(VAR->VAR, VAR, 8); VAR->VAR = VAR; VAR += VAR; VAR = VAR | VAR | VAR | VAR | VAR | VAR | VAR; VAR (VAR) VAR |= VAR;  VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR(VAR, VAR, VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR; VAR += VAR; VAR (VAR->VAR & VAR) { VAR (VAR == VAR) { VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; } VAR { VAR VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR *= 2; VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR; VAR += VAR; VAR->VAR.VAR = VAR(VAR); } VAR (VAR == VAR) { VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; } VAR { VAR VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR *= 2; VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR; VAR += VAR; VAR->VAR.VAR = VAR(VAR); } /* VAR->VAR.VAR = VAR((VAR *) VAR, ""VAR"",64, VAR); VAR->VAR.VAR *= 2; VAR->VAR.VAR = VAR(VAR->VAR.VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR->VAR.VAR; VAR += VAR->VAR.VAR; VAR->VAR.VAR = VAR(VAR->VAR.VAR); */ VAR ((VAR) VAR % 2) { *VAR = 0; VAR++; } VAR = VAR((VAR *) VAR, ""VAR VAR "", 32, VAR); VAR += 2 * VAR; VAR = VAR((VAR *) VAR, VAR()->VAR, 32, VAR); VAR += 2 * VAR; VAR += 2;  VAR = VAR((VAR *) VAR, VAR, 64, VAR); VAR += 2 * VAR; *(VAR + 1) = 0; *(VAR + 2) = 0; VAR += 2;  *(VAR + 1) = 0; *(VAR + 2) = 0; VAR += 2;  } VAR {  VAR (VAR == VAR) { VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; } VAR { VAR VAR; VAR |= VAR; VAR(VAR, VAR, 63); VAR = VAR(VAR, 64); VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR; VAR += VAR; VAR->VAR.VAR = VAR(VAR); } VAR (VAR == VAR) { VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; VAR->VAR.VAR = 0; } VAR { VAR VAR; VAR(VAR, VAR, 63); VAR = VAR(VAR, 64); VAR->VAR.VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR += VAR; VAR += VAR; VAR->VAR.VAR = VAR(VAR); }  VAR(VAR, ""VAR VAR ""); VAR += VAR(""VAR VAR ""); VAR(VAR, VAR()->VAR); VAR += VAR(VAR()->VAR) + 1; VAR(VAR, VAR); VAR += VAR(VAR) + 1; VAR++;  *VAR = 0; } VAR->VAR = VAR(VAR); VAR->VAR.VAR = VAR(VAR); VAR = (VAR) VAR - (VAR) VAR(VAR); VAR->VAR += VAR; VAR->VAR.VAR = VAR(VAR); VAR = VAR(VAR, VAR, VAR, VAR, &VAR, VAR); VAR (VAR) {  } VAR VAR ((VAR->VAR == 3) || (VAR->VAR == 4)) { VAR VAR = VAR(VAR->VAR.VAR); VAR VAR = VAR(VAR->VAR.VAR); VAR (VAR & VAR) VAR(1, (""VAR VAR"")); /* VAR VAR VAR VAR VAR VAR VAR VAR ? */ /* VAR (VAR->VAR != VAR??) { VAR(""VAR VAR VAR VAR VAR VAR VAR %VAR"")); } */ VAR (VAR) { VAR(1, (""VAR VAR VAR %VAR VAR VAR VAR VAR %VAR"", VAR->VAR, VAR->VAR));  VAR->VAR = VAR->VAR; VAR = VAR(VAR);  VAR ((VAR->VAR.VAR.VAR == 3) || ((VAR->VAR.VAR.VAR == 4) && (VAR < VAR->VAR.VAR))) { VAR (VAR->VAR.VAR.VAR == 4) { VAR += VAR; VAR(1, (""VAR VAR VAR %VAR "", VAR)); } VAR(1, (""VAR VAR VAR VAR "")); VAR (VAR->VAR & VAR) { VAR ((VAR) (VAR) % 2) { VAR = (VAR(VAR) - 1) / 2; VAR++;  } VAR { VAR = VAR(VAR) / 2; } VAR = VAR((VAR *) VAR, VAR - 1); /* VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR */ VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR(VAR->VAR, (VAR *) VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR -= VAR + 1; VAR->VAR[2 * VAR] = 0; VAR->VAR[1 + (2 * VAR)] = 0; VAR (VAR > 0) { VAR = VAR((VAR *) VAR, VAR - 1); VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR(VAR-> VAR, (VAR *) VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR->VAR[2 * VAR] = 0; VAR->VAR[1+(2*VAR)] = 0; VAR -= VAR + 1; VAR (VAR > 0) { VAR = VAR((VAR *) VAR, VAR);  VAR(VAR->VAR); VAR->VAR = VAR(2 * (VAR + 1), VAR); VAR (VAR-> VAR, (VAR *) VAR, VAR, VAR); VAR += 2 * (VAR + 1); VAR-> VAR[2 * VAR] = 0; VAR-> VAR[1 + (2 * VAR)] = 0; }  VAR { VAR(VAR->VAR); VAR->VAR = VAR(2,VAR); } } VAR {  VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); VAR(VAR->VAR); VAR->VAR = VAR(2, VAR); } } VAR {  VAR = VAR(VAR, 1024); VAR (((VAR) VAR + VAR) - (VAR) VAR(VAR) <= VAR(VAR)) { VAR(VAR->VAR); VAR->VAR = VAR(VAR + 1, VAR); VAR(VAR->VAR,VAR, VAR); VAR += VAR; VAR[0] = 0;  VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR+1, VAR); VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; VAR = VAR(VAR, 1024); VAR(VAR->VAR); VAR->VAR = VAR(VAR+1, VAR); VAR(VAR->VAR, VAR, VAR); VAR += VAR; VAR[0] = 0; VAR++; } VAR VAR(1, (""VAR VAR VAR %VAR "" ""VAR VAR VAR VAR VAR "", VAR)); } } VAR { VAR(1, (""VAR VAR VAR VAR VAR "" ""VAR VAR"")); } } VAR { VAR(1, (""VAR VAR VAR VAR VAR."")); } } VAR { VAR(1, (""VAR VAR VAR %VAR: "", VAR->VAR)); VAR = -VAR; } VAR(VAR); VAR VAR; }",10,7
linux_394f56fe480140877304d342dec46d50dc823d46,arch/x86/vdso/vma.c,"/*
 * Put the vdso above the (randomized) stack with another randomized
 * offset.  This way there is no hole in the middle of address space.
 * To save memory make sure it is still in the same PTE as the stack
 * top.  This doesn't give that many random bits.
 *
 * Note that this algorithm is imperfect: the distribution of the vdso
 * start address within a PMD is biased toward the end.
 *
 * Only used for the 64-bit and x32 vdsos.
 */

	/*
	 * Round up the start address.  It can start out unaligned as a result
	 * of stack start randomization.
	 */
	start = PAGE_ALIGN(start);

	/* Round the lowest possible end address up to a PMD boundary. */
	end = (start + len + PMD_SIZE - 1) & PMD_MASK;

	if (end > start) {
		offset = get_random_int() % (((end - start) >> PAGE_SHIFT) + 1);
		addr = start + (offset << PAGE_SHIFT);
	} else {
		addr = start;
	}
	 * Forcibly align the final address in case we have a hardware
	 * issue that requires alignment for performance reasons.","/* Put the vdso above the (randomized) stack with another randomized offset.
   This way there is no hole in the middle of address space.
   To save memory make sure it is still in the same PTE as the stack top.
   This doesn't give that many random bits.

   Only used for the 64-bit and x32 vdsos. */
	end = (start + PMD_SIZE - 1) & PMD_MASK;
	/* This loses some more bits than a modulo, but is cheaper */
	offset = get_random_int() & (PTRS_PER_PTE - 1);
	addr = start + (offset << PAGE_SHIFT);
	if (addr >= end)
		addr = end;
	 * page-align it here so that get_unmapped_area doesn't
	 * align it wrongfully again to the next page. addr can come in 4K
	 * unaligned here as a result of stack start randomization.
	addr = PAGE_ALIGN(addr);",394f56fe480140877304d342dec46d50dc823d46,CVE-2014-9585,394f56fe480140877304d342dec46d50dc823d46,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,96,COMPLETED,/* * VAR VAR VAR VAR VAR (VAR) VAR VAR VAR VAR * VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR. VAR VAR'VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * VAR VAR VAR VAR 64-VAR VAR VAR VAR. */ /* * VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR. */ VAR = VAR(VAR);  VAR = (VAR + VAR + VAR - 1) & VAR; VAR (VAR > VAR) { VAR = VAR() % (((VAR - VAR) >> VAR) + 1); VAR = VAR + (VAR << VAR); } VAR { VAR = VAR; } * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR. /* VAR VAR VAR VAR VAR (VAR) VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR'VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR 64-VAR VAR VAR VAR. */ VAR = (VAR + VAR - 1) & VAR;  VAR = VAR() & (VAR - 1); VAR = VAR + (VAR << VAR); VAR (VAR >= VAR) VAR = VAR; * VAR-VAR VAR VAR VAR VAR VAR VAR'VAR * VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR 4K * VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR = VAR(VAR);,10,7
linux_4180bf1b655a791a0a6ef93a2ffffc762722c782,Documentation/virtual/kvm/hypercalls.txt,"
6. KVM_HC_SEND_IPI
------------------------
Architecture: x86
Status: active
Purpose: Send IPIs to multiple vCPUs.

a0: lower part of the bitmap of destination APIC IDs
a1: higher part of the bitmap of destination APIC IDs
a2: the lowest APIC ID in bitmap
a3: APIC ICR

The hypercall lets a guest send multicast IPIs, with at most 128
128 destinations per hypercall in 64-bit mode and 64 vCPUs per
hypercall in 32-bit mode.  The destinations are represented by a
bitmap contained in the first two arguments (a0 and a1). Bit 0 of
a0 corresponds to the APIC ID in the third argument (a2), bit 1
corresponds to the APIC ID a2+1, and so on.

Returns the number of CPUs to which the IPIs were delivered successfully.",,4180bf1b655a791a0a6ef93a2ffffc762722c782,CVE-2018-19406,4180bf1b655a791a0a6ef93a2ffffc762722c782,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,"6. VAR ------------------------ VAR: VAR VAR: VAR VAR: VAR VAR VAR VAR VAR. VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR 128 128 VAR VAR VAR VAR 64-VAR VAR VAR 64 VAR VAR VAR VAR 32-VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR VAR VAR). VAR 0 VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR), VAR 1 VAR VAR VAR VAR VAR VAR+1, VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. ",10,7
linux_4180bf1b655a791a0a6ef93a2ffffc762722c782,arch/x86/kvm/lapic.c,"int kvm_pv_send_ipi(struct kvm *kvm, unsigned long ipi_bitmap_low,
    		    unsigned long ipi_bitmap_high, int min,
		    unsigned long icr, int op_64_bit)
{
	int i;
	struct kvm_apic_map *map;
	struct kvm_vcpu *vcpu;
	struct kvm_lapic_irq irq = {0};
	int cluster_size = op_64_bit ? 64 : 32;
	int count = 0;

	irq.vector = icr & APIC_VECTOR_MASK;
	irq.delivery_mode = icr & APIC_MODE_MASK;
	irq.level = (icr & APIC_INT_ASSERT) != 0;
	irq.trig_mode = icr & APIC_INT_LEVELTRIG;

	if (icr & APIC_DEST_MASK)
		return -KVM_EINVAL;
	if (icr & APIC_SHORT_MASK)
		return -KVM_EINVAL;

	rcu_read_lock();
	map = rcu_dereference(kvm->arch.apic_map);

	/* Bits above cluster_size are masked in the caller.  */
	for_each_set_bit(i, &ipi_bitmap_low, BITS_PER_LONG) {
		vcpu = map->phys_map[min + i]->vcpu;
		count += kvm_apic_set_irq(vcpu, &irq, NULL);
	}

	min += cluster_size;
	for_each_set_bit(i, &ipi_bitmap_high, BITS_PER_LONG) {
		vcpu = map->phys_map[min + i]->vcpu;
		count += kvm_apic_set_irq(vcpu, &irq, NULL);
	}

	rcu_read_unlock();
	return count;
}
",,4180bf1b655a791a0a6ef93a2ffffc762722c782,CVE-2018-19406,4180bf1b655a791a0a6ef93a2ffffc762722c782,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,"VAR VAR(VAR VAR *VAR, VAR VAR VAR, VAR VAR VAR, VAR VAR, VAR VAR VAR, VAR VAR) { VAR VAR; VAR VAR *VAR; VAR VAR *VAR; VAR VAR VAR = {0}; VAR VAR = VAR ? 64 : 32; VAR VAR = 0; VAR.VAR = VAR & VAR; VAR.VAR = VAR & VAR; VAR.VAR = (VAR & VAR) != 0; VAR.VAR = VAR & VAR; VAR (VAR & VAR) VAR -VAR; VAR (VAR & VAR) VAR -VAR; VAR(); VAR = VAR(VAR->VAR.VAR);  VAR(VAR, &VAR, VAR) { VAR = VAR->VAR[VAR + VAR]->VAR; VAR += VAR(VAR, &VAR, VAR); } VAR += VAR; VAR(VAR, &VAR, VAR) { VAR = VAR->VAR[VAR + VAR]->VAR; VAR += VAR(VAR, &VAR, VAR); } VAR(); VAR VAR; } ",10,7
linux_4cf949c7fafe21e085a4ee386bb2dade9067316e,drivers/gpu/drm/vmwgfx/vmwgfx_kms.c,"	    box->d != 1    || box_count != 1 ||
	    box->w > 64 || box->h > 64) {",	    box->d != 1    || box_count != 1) {,4cf949c7fafe21e085a4ee386bb2dade9067316e,CVE-2022-36280,4cf949c7fafe21e085a4ee386bb2dade9067316e,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,72,COMPLETED,VAR->VAR != 1 || VAR != 1 || VAR->VAR > 64 || VAR->VAR > 64) { VAR->VAR != 1 || VAR != 1) {,10,7
linux_59089d8d162ddcb5c434672e915331964d38a754,include/linux/ethtool.h," * Portions Copyright (C) Sun Microsystems 2008
/* The following structures are for supporting RX network flow
 * classification configuration. Note, all multibyte fields, e.g.,
 * ip4src, ip4dst, psrc, pdst, spi, etc. are expected to be in network
 * byte order.
 */
struct ethtool_tcpip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__be16	psrc;
	__be16	pdst;
	__u8    tos;
};

struct ethtool_ah_espip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__be32	spi;
	__u8    tos;
};

struct ethtool_rawip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__u8	hdata[64];
};

struct ethtool_ether_spec {
	__be16	ether_type;
	__u8	frame_size;
	__u8	eframe[16];
};

#define	ETH_RX_NFC_IP4	1
#define	ETH_RX_NFC_IP6	2

struct ethtool_usrip4_spec {
	__be32	ip4src;
	__be32	ip4dst;
	__be32	l4_4_bytes;
	__u8    tos;
	__u8    ip_ver;
	__u8    proto;
};

struct ethtool_rx_flow_spec {
	union {
		struct ethtool_tcpip4_spec		tcp_ip4_spec;
		struct ethtool_tcpip4_spec		udp_ip4_spec;
		struct ethtool_tcpip4_spec		sctp_ip4_spec;
		struct ethtool_ah_espip4_spec		ah_ip4_spec;
		struct ethtool_ah_espip4_spec		esp_ip4_spec;
		struct ethtool_rawip4_spec		raw_ip4_spec;
		struct ethtool_ether_spec		ether_spec;
		struct ethtool_usrip4_spec		usr_ip4_spec;
		__u8					hdata[64];
	} h_u, m_u; /* entry, mask */
	__u64		ring_cookie;
	__u32		location;
};

struct ethtool_rxnfc {
	__u32				cmd;
	__u32				flow_type;
	/* The rx flow hash value or the rule DB size */
	__u64				data;
	struct ethtool_rx_flow_spec	fs;
	__u32				rule_cnt;
	__u32				rule_locs[0];
	int	(*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, void *);
	int	(*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
#define	ETHTOOL_GRXRINGS	0x0000002d /* Get RX rings available for LB */
#define	ETHTOOL_GRXCLSRLCNT	0x0000002e /* Get RX class rule count */
#define	ETHTOOL_GRXCLSRULE	0x0000002f /* Get RX classification rule */
#define	ETHTOOL_GRXCLSRLALL	0x00000030 /* Get all RX classification rule */
#define	ETHTOOL_SRXCLSRLDEL	0x00000031 /* Delete RX classification rule */
#define	ETHTOOL_SRXCLSRLINS	0x00000032 /* Insert RX classification rule */
#define	AH_V4_FLOW	0x09
#define	ESP_V4_FLOW	0x0a
#define	AH_V6_FLOW	0x0b
#define	ESP_V6_FLOW	0x0c
#define	IP_USER_FLOW	0x0d
#define	RX_CLS_FLOW_DISC	0xffffffffffffffffULL","struct ethtool_rxnfc {
	__u32		cmd;
	__u64		data;
	int	(*get_rxhash)(struct net_device *, struct ethtool_rxnfc *);
	int	(*set_rxhash)(struct net_device *, struct ethtool_rxnfc *);
#define	RXH_DEV_PORT	(1 << 0)",59089d8d162ddcb5c434672e915331964d38a754,CVE-2010-2478,59089d8d162ddcb5c434672e915331964d38a754,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,"* VAR VAR (VAR) VAR VAR 2008 /* VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. VAR, VAR VAR VAR, VAR.VAR., * VAR, VAR, VAR, VAR, VAR, VAR. VAR VAR VAR VAR VAR VAR * VAR VAR. */ VAR VAR { VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR { VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR { VAR VAR; VAR VAR; VAR VAR[64]; }; VAR VAR { VAR VAR; VAR VAR; VAR VAR[16]; };   VAR VAR { VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR { VAR { VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR VAR; VAR VAR[64]; } VAR, VAR;  VAR VAR; VAR VAR; }; VAR VAR { VAR VAR; VAR VAR;  VAR VAR; VAR VAR VAR; VAR VAR; VAR VAR[0]; VAR (*VAR)(VAR VAR *, VAR VAR *, VAR *); VAR (*VAR)(VAR VAR *, VAR VAR *);             VAR VAR { VAR VAR; VAR VAR; VAR (*VAR)(VAR VAR *, VAR VAR *); VAR (*VAR)(VAR VAR *, VAR VAR *); ",10,7
linux_5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,fs/9p/v9fs_vfs.h,"/* flags for v9fs_stat2inode() & v9fs_stat2inode_dotl() */
#define V9FS_STAT2INODE_KEEP_ISIZE 1

void v9fs_stat2inode(struct p9_wstat *stat, struct inode *inode,
		      struct super_block *sb, unsigned int flags);
void v9fs_stat2inode_dotl(struct p9_stat_dotl *stat, struct inode *inode,
			   unsigned int flags);

static inline void v9fs_i_size_write(struct inode *inode, loff_t i_size)
{
	/*
	 * 32-bit need the lock, concurrent updates could break the
	 * sequences and make i_size_read() loop forever.
	 * 64-bit updates are atomic and can skip the locking.
	 */
	if (sizeof(i_size) > sizeof(long))
		spin_lock(&inode->i_lock);
	i_size_write(inode, i_size);
	if (sizeof(i_size) > sizeof(long))
		spin_unlock(&inode->i_lock);
}","void v9fs_stat2inode(struct p9_wstat *, struct inode *, struct super_block *);
void v9fs_stat2inode_dotl(struct p9_stat_dotl *, struct inode *);",5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,CVE-2019-16413,5e3cc1ee1405a7eb3487ed24f786dec01b4cbe1f,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,86,COMPLETED,"  VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR VAR VAR); VAR VAR(VAR VAR *VAR, VAR VAR *VAR, VAR VAR VAR); VAR VAR VAR VAR(VAR VAR *VAR, VAR VAR) { /* * 32-VAR VAR VAR VAR, VAR VAR VAR VAR VAR * VAR VAR VAR VAR() VAR VAR. * 64-VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR (VAR(VAR) > VAR(VAR)) VAR(&VAR->VAR); VAR(VAR, VAR); VAR (VAR(VAR) > VAR(VAR)) VAR(&VAR->VAR); } VAR VAR(VAR VAR *, VAR VAR *, VAR VAR *); VAR VAR(VAR VAR *, VAR VAR *);",10,7
linux_721151d004dcf01a71b12bb6b893f9160284cf6e,arch/powerpc/mm/hash_low_64.S,"	andis.	r0,r31,_PAGE_4K_PFN@h
	srdi	r5,r31,PTE_RPN_SHIFT
	bne-	htab_special_pfn
htab_special_pfn:","	rldicl	r5,r31,64-PTE_RPN_SHIFT,PTE_RPN_SHIFT",721151d004dcf01a71b12bb6b893f9160284cf6e,CVE-2007-3850,721151d004dcf01a71b12bb6b893f9160284cf6e,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,84,COMPLETED,"VAR. VAR,VAR,VAR@VAR VAR VAR,VAR,VAR VAR- VAR VAR: VAR VAR,VAR,64-VAR,VAR",10,7
linux_7a1abd08d52fdeddb3e9a5a33f2f15cc6a5674d2,net/ipv4/tcp.c,		if (val < 64 || val > MAX_TCP_WINDOW) {,		if (val < 8 || val > MAX_TCP_WINDOW) {,7a1abd08d52fdeddb3e9a5a33f2f15cc6a5674d2,CVE-2010-4165,7a1abd08d52fdeddb3e9a5a33f2f15cc6a5674d2,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,88,COMPLETED,VAR (VAR < 64 || VAR > VAR) { VAR (VAR < 8 || VAR > VAR) {,10,7
linux_844817e47eef14141cf59b8d5ac08dd11c0a9189,drivers/hid/hid-picolcd_core.c,"	if (size > 64) {
		hid_warn(hdev, ""invalid size value (%d) for picolcd raw event\n"",
				size);
		return 0;
	}
",,844817e47eef14141cf59b8d5ac08dd11c0a9189,CVE-2014-3186,844817e47eef14141cf59b8d5ac08dd11c0a9189,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR (VAR > 64) { VAR(VAR, ""VAR VAR VAR (%VAR) VAR VAR VAR VAR\VAR"", VAR); VAR 0; } ",10,7
linux_854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,arch/x86/kvm/x86.c,"	switch (msr->index) {
	case MSR_FS_BASE:
	case MSR_GS_BASE:
	case MSR_KERNEL_GS_BASE:
	case MSR_CSTAR:
	case MSR_LSTAR:
		if (is_noncanonical_address(msr->data))
			return 1;
		break;
	case MSR_IA32_SYSENTER_EIP:
	case MSR_IA32_SYSENTER_ESP:
		/*
		 * IA32_SYSENTER_ESP and IA32_SYSENTER_EIP cause #GP if
		 * non-canonical address is written on Intel but not on
		 * AMD (which ignores the top 32-bits, because it does
		 * not implement 64-bit SYSENTER).
		 *
		 * 64-bit code should hence be able to write a non-canonical
		 * value on AMD.  Making the address canonical ensures that
		 * vmentry does not fail on Intel after writing a non-canonical
		 * value, and that something deterministic happens if the guest
		 * invokes 64-bit SYSENTER.
		 */
		msr->data = get_canonical(msr->data);
	}
EXPORT_SYMBOL_GPL(kvm_set_msr);",,854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,CVE-2014-3610,854e8bb1aa06c578c2c9145fa6bfe3680ef63b23,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR (VAR->VAR) { VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR VAR: VAR (VAR(VAR->VAR)) VAR 1; VAR; VAR VAR: VAR VAR: /* * VAR VAR VAR VAR  * VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR (VAR VAR VAR VAR 32-VAR, VAR VAR VAR * VAR VAR 64-VAR VAR). * * 64-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR * VAR VAR VAR. VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR * VAR, VAR VAR VAR VAR VAR VAR VAR VAR * VAR 64-VAR VAR. */ VAR->VAR = VAR(VAR->VAR); } VAR(VAR); ",10,7
linux_973c096f6a85e5b5f2a295126ba6928d9a6afd45,drivers/video/console/Kconfig,,"config VGACON_SOFT_SCROLLBACK
       bool ""Enable Scrollback Buffer in System RAM""
       depends on VGA_CONSOLE
       default n
       help
	 The scrollback buffer of the standard VGA console is located in
	 the VGA RAM.  The size of this RAM is fixed and is quite small.
	 If you require a larger scrollback buffer, this can be placed in
	 System RAM which is dynamically allocated during initialization.
	 Placing the scrollback buffer in System RAM will slightly slow
	 down the console.

	 If you want this feature, say 'Y' here and enter the amount of
	 RAM to allocate for this buffer.  If unsure, say 'N'.

config VGACON_SOFT_SCROLLBACK_SIZE
       int ""Scrollback Buffer Size (in KB)""
       depends on VGACON_SOFT_SCROLLBACK
       range 1 1024
       default ""64""
       help
	  Enter the amount of System RAM to allocate for scrollback
	  buffers of VGA consoles. Each 64KB will give you approximately
	  16 80x25 screenfuls of scrollback buffer.

config VGACON_SOFT_SCROLLBACK_PERSISTENT_ENABLE_BY_DEFAULT
	bool ""Persistent Scrollback History for each console by default""
	depends on VGACON_SOFT_SCROLLBACK
	default n
	help
	  Say Y here if the scrollback history should persist by default when
	  switching between consoles. Otherwise, the scrollback history will be
	  flushed each time the console is switched. This feature can also be
	  enabled using the boot command line parameter
	  'vgacon.scrollback_persistent=1'.

	  This feature might break your tool of choice to flush the scrollback
	  buffer, e.g. clear(1) will work fine but Debian's clear_console(1)
	  will be broken, which might cause security issues.
	  You can use the escape sequence \e[3J instead if this feature is
	  activated.

	  Note that a buffer of VGACON_SOFT_SCROLLBACK_SIZE is taken for each
	  created tty device.
	  So if you use a RAM-constrained system, say N here.
",973c096f6a85e5b5f2a295126ba6928d9a6afd45,CVE-2020-28097,973c096f6a85e5b5f2a295126ba6928d9a6afd45,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED," VAR VAR VAR ""VAR VAR VAR VAR VAR VAR"" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR, VAR 'VAR' VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR, VAR 'VAR'. VAR VAR VAR ""VAR VAR VAR (VAR VAR)"" VAR VAR VAR VAR 1 1024 VAR ""64"" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR 64KB VAR VAR VAR VAR 16 80x25 VAR VAR VAR VAR. VAR VAR VAR ""VAR VAR VAR VAR VAR VAR VAR VAR"" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR.VAR=1'. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR.VAR. VAR(1) VAR VAR VAR VAR VAR'VAR VAR(1) VAR VAR VAR, VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR \VAR[3J VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR-VAR VAR, VAR VAR VAR.",0,7
linux_ad67b74d2469d9b82aaa572d76474c95bc484d57,Documentation/printk-formats.txt,"Pointer Types
=============

Pointers printed without a specifier extension (i.e unadorned %p) are
hashed to give a unique identifier without leaking kernel addresses to user
space. On 64 bit machines the first 32 bits are zeroed.

::

	%p	abcdef12 or 00000000abcdef12
",,ad67b74d2469d9b82aaa572d76474c95bc484d57,CVE-2018-5995,ad67b74d2469d9b82aaa572d76474c95bc484d57,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,76,COMPLETED,VAR VAR ============= VAR VAR VAR VAR VAR VAR (VAR.VAR VAR %VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR 64 VAR VAR VAR VAR 32 VAR VAR VAR. :: %VAR VAR VAR 00000000abcdef12 ,10,7
linux_ad67b74d2469d9b82aaa572d76474c95bc484d57,Documentation/printk-formats.txt,"Pointer Types
=============

Pointers printed without a specifier extension (i.e unadorned %p) are
hashed to give a unique identifier without leaking kernel addresses to user
space. On 64 bit machines the first 32 bits are zeroed.

::

	%p	abcdef12 or 00000000abcdef12
",,ad67b74d2469d9b82aaa572d76474c95bc484d57,CVE-2018-5953,ad67b74d2469d9b82aaa572d76474c95bc484d57,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,76,COMPLETED,VAR VAR ============= VAR VAR VAR VAR VAR VAR (VAR.VAR VAR %VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR 64 VAR VAR VAR VAR 32 VAR VAR VAR. :: %VAR VAR VAR 00000000abcdef12 ,10,7
linux_ad67b74d2469d9b82aaa572d76474c95bc484d57,Documentation/printk-formats.txt,"Pointer Types
=============

Pointers printed without a specifier extension (i.e unadorned %p) are
hashed to give a unique identifier without leaking kernel addresses to user
space. On 64 bit machines the first 32 bits are zeroed.

::

	%p	abcdef12 or 00000000abcdef12
",,ad67b74d2469d9b82aaa572d76474c95bc484d57,CVE-2018-7754,ad67b74d2469d9b82aaa572d76474c95bc484d57,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,72,COMPLETED,VAR VAR ============= VAR VAR VAR VAR VAR VAR (VAR.VAR VAR %VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR 64 VAR VAR VAR VAR 32 VAR VAR VAR. :: %VAR VAR VAR 00000000abcdef12 ,10,7
linux_cea4dcfdad926a27a18e188720efe0f2c9403456,drivers/target/iscsi/iscsi_target_parameters.h,"#include <scsi/iscsi_proto.h>

	char key[KEY_MAXLEN];",	char key[64];,cea4dcfdad926a27a18e188720efe0f2c9403456,CVE-2013-2850,cea4dcfdad926a27a18e188720efe0f2c9403456,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED, VAR VAR[VAR]; VAR VAR[64];,10,7
linux_e572ff80f05c33cd0cb4860f864f5c9c044280b6,kernel/bpf/verifier.c,"static bool __reg32_bound_s64(s32 a)
{
	return a >= 0 && a <= S32_MAX;
}


	/* Attempt to pull 32-bit signed bounds into 64-bit bounds but must
	 * be positive otherwise set to worse case bounds and refine later
	 * from tnum.
	if (__reg32_bound_s64(reg->s32_min_value) &&
	    __reg32_bound_s64(reg->s32_max_value)) {
		reg->smax_value = reg->s32_max_value;
	} else {
		reg->smax_value = U32_MAX;
	}","	/* Attempt to pull 32-bit signed bounds into 64-bit bounds
	 * but must be positive otherwise set to worse case bounds
	 * and refine later from tnum.
	if (reg->s32_min_value >= 0 && reg->s32_max_value >= 0)
		reg->smax_value = reg->s32_max_value;
	else
		reg->smax_value = U32_MAX;
	if (reg->s32_min_value >= 0)
	else",e572ff80f05c33cd0cb4860f864f5c9c044280b6,CVE-2021-45402,e572ff80f05c33cd0cb4860f864f5c9c044280b6,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,80,COMPLETED,VAR VAR VAR(VAR VAR) { VAR VAR >= 0 && VAR <= VAR; } /* VAR VAR VAR 32-VAR VAR VAR VAR 64-VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR. VAR (VAR(VAR->VAR) && VAR(VAR->VAR)) { VAR->VAR = VAR->VAR; } VAR { VAR->VAR = VAR; } /* VAR VAR VAR 32-VAR VAR VAR VAR 64-VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. VAR (VAR->VAR >= 0 && VAR->VAR >= 0) VAR->VAR = VAR->VAR; VAR VAR->VAR = VAR; VAR (VAR->VAR >= 0) VAR,10,7
linux_ea8c66fe8d8f4f93df941e52120a3512d7bf5128,arch/x86/kvm/hyperv.c,"	u64 valid_bank_mask;
		if (hc->var_cnt != bitmap_weight((unsigned long *)&valid_bank_mask, 64))","	unsigned long valid_bank_mask;
		if (hc->var_cnt != bitmap_weight(&valid_bank_mask, 64))",ea8c66fe8d8f4f93df941e52120a3512d7bf5128,CVE-2022-1789,ea8c66fe8d8f4f93df941e52120a3512d7bf5128,https://github.com/torvalds/linux,CPE_DIRECT_COMMIT,70,COMPLETED,"VAR VAR; VAR (VAR->VAR != VAR((VAR VAR *)&VAR, 64)) VAR VAR VAR; VAR (VAR->VAR != VAR(&VAR, 64))",10,7
linux_f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,net/bluetooth/l2cap.c,"	case L2CAP_MODE_STREAMING:
	case L2CAP_MODE_STREAMING:
static int l2cap_mode_supported(__u8 mode, __u32 feat_mask)
{
	u32 local_feat_mask = l2cap_feat_mask;
	if (enable_ertm)
		local_feat_mask |= L2CAP_FEAT_ERTM;

	switch (mode) {
	case L2CAP_MODE_ERTM:
		return L2CAP_FEAT_ERTM & feat_mask & local_feat_mask;
	case L2CAP_MODE_STREAMING:
		return L2CAP_FEAT_STREAMING & feat_mask & local_feat_mask;
	default:
		return 0x00;
	}
}

static inline __u8 l2cap_select_mode(__u8 mode, __u16 remote_feat_mask)
{
	switch (mode) {
	case L2CAP_MODE_STREAMING:
	case L2CAP_MODE_ERTM:
		if (l2cap_mode_supported(mode, remote_feat_mask))
			return mode;
		/* fall through */
	default:
		return L2CAP_MODE_BASIC;
	}
}

	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_ERTM };
	if (pi->num_conf_req || pi->num_conf_rsp)
		goto done;

	switch (pi->mode) {
	case L2CAP_MODE_STREAMING:
	case L2CAP_MODE_ERTM:
		pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;
		if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask)) {
			struct l2cap_disconn_req req;
			req.dcid = cpu_to_le16(pi->dcid);
			req.scid = cpu_to_le16(pi->scid);
			l2cap_send_cmd(pi->conn, l2cap_get_ident(pi->conn),
					L2CAP_DISCONN_REQ, sizeof(req), &req);
		}
		break;
	default:
		pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);
		break;
	}

done:
		rfc.txwin_size      = L2CAP_DEFAULT_TX_WINDOW;
		rfc.retrans_timeout = 0;
		rfc.monitor_timeout = 0;
		rfc.max_pdu_size    = cpu_to_le16(L2CAP_DEFAULT_MAX_RX_APDU);

		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
					sizeof(rfc), (unsigned long) &rfc);
		break;

	case L2CAP_MODE_STREAMING:
		rfc.mode            = L2CAP_MODE_STREAMING;
		rfc.txwin_size      = 0;
		rfc.max_transmit    = 0;
		rfc.retrans_timeout = 0;
		rfc.monitor_timeout = 0;
	if (pi->num_conf_rsp || pi->num_conf_req)
		goto done;

	switch (pi->mode) {
	case L2CAP_MODE_STREAMING:
	case L2CAP_MODE_ERTM:
		pi->conf_state |= L2CAP_CONF_STATE2_DEVICE;
		if (!l2cap_mode_supported(pi->mode, pi->conn->feat_mask))
			return -ECONNREFUSED;
		break;
	default:
		pi->mode = l2cap_select_mode(rfc.mode, pi->conn->feat_mask);
		break;
	}

done:
	if (pi->mode != rfc.mode) {
		result = L2CAP_CONF_UNACCEPT;
		rfc.mode = pi->mode;

		if (pi->num_conf_rsp == 1)
			return -ECONNREFUSED;

		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
					sizeof(rfc), (unsigned long) &rfc);
	}


		if (mtu < L2CAP_DEFAULT_MIN_MTU)
			result = L2CAP_CONF_UNACCEPT;
		else {
			pi->omtu = mtu;
			pi->conf_state |= L2CAP_CONF_MTU_DONE;
		}
		l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
		switch (rfc.mode) {
		case L2CAP_MODE_BASIC:
			pi->fcs = L2CAP_FCS_NONE;
			pi->conf_state |= L2CAP_CONF_MODE_DONE;
			break;

		case L2CAP_MODE_ERTM:
			pi->remote_tx_win = rfc.txwin_size;
			pi->remote_max_tx = rfc.max_transmit;
			pi->max_pdu_size = rfc.max_pdu_size;

			rfc.retrans_timeout = L2CAP_DEFAULT_RETRANS_TO;
			rfc.monitor_timeout = L2CAP_DEFAULT_MONITOR_TO;

			pi->conf_state |= L2CAP_CONF_MODE_DONE;
			break;

		case L2CAP_MODE_STREAMING:
			pi->remote_tx_win = rfc.txwin_size;
			pi->max_pdu_size = rfc.max_pdu_size;

			pi->conf_state |= L2CAP_CONF_MODE_DONE;
			break;

		default:
			rfc.mode = pi->mode;
		}
		l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
		if (result == L2CAP_CONF_SUCCESS)
			pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;
	}
static int l2cap_parse_conf_rsp(struct sock *sk, void *rsp, int len, void *data, u16 *result)
{
	struct l2cap_pinfo *pi = l2cap_pi(sk);
	struct l2cap_conf_req *req = data;
	void *ptr = req->data;
	int type, olen;
	unsigned long val;
	struct l2cap_conf_rfc rfc;

	BT_DBG(""sk %p, rsp %p, len %d, req %p"", sk, rsp, len, data);

	while (len >= L2CAP_CONF_OPT_SIZE) {
		len -= l2cap_get_conf_opt(&rsp, &type, &olen, &val);

		switch (type) {
		case L2CAP_CONF_MTU:
			if (val < L2CAP_DEFAULT_MIN_MTU) {
				*result = L2CAP_CONF_UNACCEPT;
				pi->omtu = L2CAP_DEFAULT_MIN_MTU;
			} else
				pi->omtu = val;
			l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
			break;

		case L2CAP_CONF_FLUSH_TO:
			pi->flush_to = val;
			l2cap_add_conf_opt(&ptr, L2CAP_CONF_FLUSH_TO,
							2, pi->flush_to);
			break;

		case L2CAP_CONF_RFC:
			if (olen == sizeof(rfc))
				memcpy(&rfc, (void *)val, olen);

			if ((pi->conf_state & L2CAP_CONF_STATE2_DEVICE) &&
							rfc.mode != pi->mode)
				return -ECONNREFUSED;

			pi->mode = rfc.mode;
			pi->fcs = 0;

			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
					sizeof(rfc), (unsigned long) &rfc);
			break;
		}
	}

	if (*result == L2CAP_CONF_SUCCESS) {
		switch (rfc.mode) {
		case L2CAP_MODE_ERTM:
			pi->remote_tx_win   = rfc.txwin_size;
			pi->retrans_timeout = rfc.retrans_timeout;
			pi->monitor_timeout = rfc.monitor_timeout;
			pi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);
			break;
		case L2CAP_MODE_STREAMING:
			pi->max_pdu_size    = le16_to_cpu(rfc.max_pdu_size);
			break;
		}
	}

	req->dcid   = cpu_to_le16(pi->dcid);
	req->flags  = cpu_to_le16(0x0000);

	return ptr - data;
}

		l2cap_pi(sk)->num_conf_req++;
	if (len < 0) {
		struct l2cap_disconn_req req;
		req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);
		req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
		l2cap_send_cmd(conn, l2cap_get_ident(conn),
					L2CAP_DISCONN_REQ, sizeof(req), &req);
	}
	l2cap_pi(sk)->num_conf_rsp++;
		l2cap_pi(sk)->num_conf_req++;
		if (l2cap_pi(sk)->num_conf_rsp <= L2CAP_CONF_MAX_CONF_RSP) {
			int len = cmd->len - sizeof(*rsp);
			char req[64];

			/* throw out any old stored conf requests */
			result = L2CAP_CONF_SUCCESS;
			len = l2cap_parse_conf_rsp(sk, rsp->data,
							len, req, &result);
			if (len < 0) {
				struct l2cap_disconn_req req;
				req.dcid = cpu_to_le16(l2cap_pi(sk)->dcid);
				req.scid = cpu_to_le16(l2cap_pi(sk)->scid);
				l2cap_send_cmd(conn, l2cap_get_ident(conn),
					L2CAP_DISCONN_REQ, sizeof(req), &req);
				goto done;
			}

			l2cap_send_cmd(conn, l2cap_get_ident(conn),
						L2CAP_CONF_REQ, len, req);
			l2cap_pi(sk)->num_conf_req++;
			if (result != L2CAP_CONF_SUCCESS)
				goto done;
			break;","	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
		rfc.txwin_size      = L2CAP_DEFAULT_RX_WINDOW;
		rfc.retrans_timeout = cpu_to_le16(L2CAP_DEFAULT_RETRANS_TO);
		rfc.monitor_timeout = cpu_to_le16(L2CAP_DEFAULT_MONITOR_TO);
		if (rfc.mode == L2CAP_MODE_BASIC) {
			if (mtu < pi->omtu)
				result = L2CAP_CONF_UNACCEPT;
			else {
				pi->omtu = mtu;
				pi->conf_state |= L2CAP_CONF_OUTPUT_DONE;
			}
			l2cap_add_conf_opt(&ptr, L2CAP_CONF_MTU, 2, pi->omtu);
		} else {
			rfc.mode = L2CAP_MODE_BASIC;
			l2cap_add_conf_opt(&ptr, L2CAP_CONF_RFC,
		}
	}
	if (len < 0)
		if (++l2cap_pi(sk)->conf_retry < L2CAP_CONF_MAX_RETRIES) {
			char req[128];
			/* It does not make sense to adjust L2CAP parameters
			 * that are currently defined in the spec. We simply
			 * resend config request that we sent earlier. It is
			 * stupid, but it helps qualification testing which
			 * expects at least some response from us. */
			l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
						l2cap_build_conf_req(sk, req), req);
			goto done;",f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,CVE-2017-1000251,f2fcfcd670257236ebf2088bbdf26f6a8ef459fe,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR: VAR VAR: VAR VAR VAR(VAR VAR, VAR VAR) { VAR VAR = VAR; VAR (VAR) VAR |= VAR; VAR (VAR) { VAR VAR: VAR VAR & VAR & VAR; VAR VAR: VAR VAR & VAR & VAR; VAR: VAR 0x00; } } VAR VAR VAR VAR(VAR VAR, VAR VAR) { VAR (VAR) { VAR VAR: VAR VAR: VAR (VAR(VAR, VAR)) VAR VAR;  VAR: VAR VAR; } } VAR VAR VAR = { .VAR = VAR }; VAR (VAR->VAR || VAR->VAR) VAR VAR; VAR (VAR->VAR) { VAR VAR: VAR VAR: VAR->VAR |= VAR; VAR (!VAR(VAR->VAR, VAR->VAR->VAR)) { VAR VAR VAR; VAR.VAR = VAR(VAR->VAR); VAR.VAR = VAR(VAR->VAR); VAR(VAR->VAR, VAR(VAR->VAR), VAR, VAR(VAR), &VAR); } VAR; VAR: VAR->VAR = VAR(VAR.VAR, VAR->VAR->VAR); VAR; } VAR: VAR.VAR = VAR; VAR.VAR = 0; VAR.VAR = 0; VAR.VAR = VAR(VAR); VAR(&VAR, VAR, VAR(VAR), (VAR VAR) &VAR); VAR; VAR VAR: VAR.VAR = VAR; VAR.VAR = 0; VAR.VAR = 0; VAR.VAR = 0; VAR.VAR = 0; VAR (VAR->VAR || VAR->VAR) VAR VAR; VAR (VAR->VAR) { VAR VAR: VAR VAR: VAR->VAR |= VAR; VAR (!VAR(VAR->VAR, VAR->VAR->VAR)) VAR -VAR; VAR; VAR: VAR->VAR = VAR(VAR.VAR, VAR->VAR->VAR); VAR; } VAR: VAR (VAR->VAR != VAR.VAR) { VAR = VAR; VAR.VAR = VAR->VAR; VAR (VAR->VAR == 1) VAR -VAR; VAR(&VAR, VAR, VAR(VAR), (VAR VAR) &VAR); } VAR (VAR < VAR) VAR = VAR; VAR { VAR->VAR = VAR; VAR->VAR |= VAR; } VAR(&VAR, VAR, 2, VAR->VAR); VAR (VAR.VAR) { VAR VAR: VAR->VAR = VAR; VAR->VAR |= VAR; VAR; VAR VAR: VAR->VAR = VAR.VAR; VAR->VAR = VAR.VAR; VAR->VAR = VAR.VAR; VAR.VAR = VAR; VAR.VAR = VAR; VAR->VAR |= VAR; VAR; VAR VAR: VAR->VAR = VAR.VAR; VAR->VAR = VAR.VAR; VAR->VAR |= VAR; VAR; VAR: VAR.VAR = VAR->VAR; } VAR(&VAR, VAR, VAR (VAR == VAR) VAR->VAR |= VAR; } VAR VAR VAR(VAR VAR *VAR, VAR *VAR, VAR VAR, VAR *VAR, VAR *VAR) { VAR VAR *VAR = VAR(VAR); VAR VAR *VAR = VAR; VAR *VAR = VAR->VAR; VAR VAR, VAR; VAR VAR VAR; VAR VAR VAR; VAR(""VAR %VAR, VAR %VAR, VAR %VAR, VAR %VAR"", VAR, VAR, VAR, VAR); VAR (VAR >= VAR) { VAR -= VAR(&VAR, &VAR, &VAR, &VAR); VAR (VAR) { VAR VAR: VAR (VAR < VAR) { *VAR = VAR; VAR->VAR = VAR; } VAR VAR->VAR = VAR; VAR(&VAR, VAR, 2, VAR->VAR); VAR; VAR VAR: VAR->VAR = VAR; VAR(&VAR, VAR, 2, VAR->VAR); VAR; VAR VAR: VAR (VAR == VAR(VAR)) VAR(&VAR, (VAR *)VAR, VAR); VAR ((VAR->VAR & VAR) && VAR.VAR != VAR->VAR) VAR -VAR; VAR->VAR = VAR.VAR; VAR->VAR = 0; VAR(&VAR, VAR, VAR(VAR), (VAR VAR) &VAR); VAR; } } VAR (*VAR == VAR) { VAR (VAR.VAR) { VAR VAR: VAR->VAR = VAR.VAR; VAR->VAR = VAR.VAR; VAR->VAR = VAR.VAR; VAR->VAR = VAR(VAR.VAR); VAR; VAR VAR: VAR->VAR = VAR(VAR.VAR); VAR; } } VAR->VAR = VAR(VAR->VAR); VAR->VAR = VAR(0x0000); VAR VAR - VAR; } VAR(VAR)->VAR++; VAR (VAR < 0) { VAR VAR VAR; VAR.VAR = VAR(VAR(VAR)->VAR); VAR.VAR = VAR(VAR(VAR)->VAR); VAR(VAR, VAR(VAR), VAR, VAR(VAR), &VAR); } VAR(VAR)->VAR++; VAR(VAR)->VAR++; VAR (VAR(VAR)->VAR <= VAR) { VAR VAR = VAR->VAR - VAR(*VAR); VAR VAR[64];  VAR = VAR; VAR = VAR(VAR, VAR->VAR, VAR, VAR, &VAR); VAR (VAR < 0) { VAR VAR VAR; VAR.VAR = VAR(VAR(VAR)->VAR); VAR.VAR = VAR(VAR(VAR)->VAR); VAR(VAR, VAR(VAR), VAR, VAR(VAR), &VAR); VAR VAR; } VAR(VAR, VAR(VAR), VAR, VAR, VAR); VAR(VAR)->VAR++; VAR (VAR != VAR) VAR VAR; VAR; VAR VAR VAR = { .VAR = VAR }; VAR.VAR = VAR; VAR.VAR = VAR(VAR); VAR.VAR = VAR(VAR); VAR (VAR.VAR == VAR) { VAR (VAR < VAR->VAR) VAR = VAR; VAR { VAR->VAR = VAR; VAR->VAR |= VAR; } VAR(&VAR, VAR, 2, VAR->VAR); } VAR { VAR.VAR = VAR; VAR(&VAR, VAR, } } VAR (VAR < 0) VAR (++VAR(VAR)->VAR < VAR) { VAR VAR[128]; /* VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR. VAR VAR * VAR VAR VAR VAR VAR VAR VAR. VAR VAR * VAR, VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR. */ VAR(VAR, VAR(VAR), VAR, VAR(VAR, VAR), VAR); VAR VAR;",0,7
openssl_8aed2a7548362e88e84a7feb795a3a97e8395008,crypto/ec/ec_lcl.h,"
	BN_MONT_CTX *mont_data;    /* data for ECDSA inverse */
int ec_precompute_mont_data(EC_GROUP *);

#ifdef ECP_NISTZ256_ASM
/** Returns GFp methods using montgomery multiplication, with x86-64 optimized
 * P256. See http://eprint.iacr.org/2013/816.
 *  \return  EC_METHOD object
 */
const EC_METHOD *EC_GFp_nistz256_method(void);
#endif",,8aed2a7548362e88e84a7feb795a3a97e8395008,CVE-2016-7056,8aed2a7548362e88e84a7feb795a3a97e8395008,https://github.com/openssl/openssl,CPE_GIT_REPOBASED,90,COMPLETED,"VAR *VAR;  VAR VAR(VAR *);  /** VAR VAR VAR VAR VAR VAR, VAR VAR-64 VAR * VAR. VAR VAR: * \VAR VAR VAR */ VAR VAR *VAR(VAR);  ",10,7
openssl_b15a19c148384e73338aa7c5b12652138e35ed28,Makefile.shared,"    LIBDEPS=$${LIBDEPS:-'$(LIBDEPS)'}; \
    LDCMD=$${LDCMD:-'$(CC)'}; LDFLAGS=$${LDFLAGS:-'$(CFLAGS) $(LDFLAGS)'}; \
    eval ""$${LDCMD} $${LDFLAGS} -o $${APPNAME:=$(APPNAME)} $(OBJECTS) $${LIBDEPS}"" )
    LIBDEPS=$${LIBDEPS:-'$(LIBDEPS)'}; \
    SHAREDCMD=$${SHAREDCMD:-'$(CC)'}; \
    SHAREDFLAGS=$${SHAREDFLAGS:-'$(CFLAGS) $(SHARED_LDFLAGS)'}; \
    eval ""$${SHAREDCMD} $${SHAREDFLAGS} \
	$$ALLSYMSFLAGS $$SHOBJECTS $$NOALLSYMSFLAGS $$LIBDEPS"" \
		if [ -n '$(SHLIBNAME_FULL)' -a -n '$(SHLIBNAME)' -a \
		     '$(SHLIBNAME_FULL)' != '$(SHLIBNAME)' ]; then \
LINK_SO_SHLIB=	SHOBJECTS='$(STLIBNAME) $(LIBEXTRAS)'; $(LINK_SO)
LINK_SO_DSO=	INHIBIT_SYMLINKS=yes; SHOBJECTS='$(LIBEXTRAS)'; $(LINK_SO)
  ([ -z '$(LIBEXTRAS)' ] || cp $(LIBEXTRAS) $$UNPACKDIR) && \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-Bsymbolic -Wl,-soname=$(SHLIBNAME_FULL)'
DO_GNU_APP=LDFLAGS='$(CFLAGS) $(LDFLAGS)'
	LIBDEPS=' '; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -nostdlib'; \
	LIBDEPS=' '; \
	ALLSYMSFLAGS='-Wl,-Bforcearchive'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -nostdlib'; \
	LDFLAGS='$(CFLAGS) $(LDFLAGS)'; \
	SHAREDFLAGS='$(CFLAGS) '""`echo '$(SHARED_LDFLAGS)' | sed s/dynamiclib/bundle/`""; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -current_version $(SHLIBVERSION) -compatibility_version $(SHLIBVERSION) -install_name $(INSTALLTOP)/$(LIBDIR)/$(SHLIBNAME_FULL)'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS)'"" -shared $$base -Wl,-Bsymbolic""; \
	echo '$(PERL) $(SRCDIR)/util/mkrc.pl $(SHLIBNAME_FULL) |' \
		     '$(RC) $(SHARED_RCFLAGS) -o rc.o'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,--enable-auto-image-base -Wl,-Bsymbolic -Wl,--out-implib,$(SHLIBNAME) rc.o'; \
	base=; [ '$(LIBNAME)' = 'crypto' -a -n '$(FIPSCANLIB)' ] && base=-Wl,--image-base,0x63000000; \
	echo '$(PERL) $(SRCDIR)/util/mkrc.pl $(SHLIBNAME_FULL) |' \
		'$(RC) $(SHARED_RCFLAGS) -o rc.o'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared '""$$base""' -Wl,-Bsymbolic -Wl,--out-implib,$(SHLIBNAME) $(LIBNAME).def rc.o'; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-B,symbolic'; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-B,symbolic -set_version $(SHLIBVERSION)'; \
		LDFLAGS='$(CFLAGS) $(LDFLAGS)'; \
		ALLSYMSFLAGS=''; \
		NOALLSYMSFLAGS=''; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -h $(SHLIBNAME_FULL) -Wl,-Bsymbolic'; \
		ALLSYMSFLAGS='-Wl,-z,allextract,-M,$(LIBNAME).map'; \
		NOALLSYMSFLAGS='-Wl,-z,defaultextract'; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -h $(SHLIBNAME_FULL) -Wl,-Bsymbolic'; \
		LDFLAGS='$(CFLAGS) $(LDFLAGS)'; \
		SHAREDFLAGS='$(CFLAGS) -G -h $(SHLIBNAME_FULL)'; \
		SHAREDFLAGS='$(CFLAGS) -G -h $(SHLIBNAME_FULL)'; \
		SHAREDFLAGS='$(CFLAGS) '""$${SHARE_FLAG}""' -h $(SHLIBNAME_FULL)'; \
		SHAREDFLAGS='$(CFLAGS) '""$${SHARE_FLAG}""' -h $(SHLIBNAME_FULL)'; \
		ALLSYMSFLAGS=''; \
		NOALLSYMSFLAGS=''; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname,$(SHLIBNAME_FULL),-B,symbolic'; \
		MINUSWL=''; \
		($(CC) -v 2>&1 | grep gcc) > /dev/null && MINUSWL='-Wl,'; \
		SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname,$(SHLIBNAME_FULL),-B,symbolic'; \
	@LDFLAGS='$(CFLAGS) $(LDFLAGS)'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-B,symbolic,+vnocompatwarnings,-z,+s,+h,$(SHLIBNAME_FULL),+cdp,../:,+cdp,./:'; \
	SHAREDFLAGS='$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-B,symbolic,+vnocompatwarnings,-z,+s,+h,$(SHLIBNAME_FULL),+cdp,../:,+cdp,./:'; \
	LDFLAGS='$(CFLAGS) $(LDFLAGS) -Wl,+s,+cdp,../:,+cdp,./:'; \
	@OBJECT_MODE=`expr 'x$(SHARED_LDFLAGS)' : 'x\-[a-z]*\(64\)'` || :; \
	@ OBJECT_MODE=`expr 'x$(SHARED_LDFLAGS)' : 'x\-[a-z]*\(64\)'` || : ; \
	LDFLAGS='$(CFLAGS) -Wl,-bsvr4 $(LDFLAGS)'; \","    LIBDEPS=""$${LIBDEPS:-$(LIBDEPS)}""; \
    LDCMD=""$${LDCMD:-$(CC)}""; LDFLAGS=""$${LDFLAGS:-$(CFLAGS) $(LDFLAGS)}""; \
    $${LDCMD} $${LDFLAGS} -o $${APPNAME:=$(APPNAME)} $(OBJECTS) $${LIBDEPS} )
    LIBDEPS=""$${LIBDEPS:-$(LIBDEPS)}""; \
    SHAREDCMD=""$${SHAREDCMD:-$(CC)}""; \
    SHAREDFLAGS=""$${SHAREDFLAGS:-$(CFLAGS) $(SHARED_LDFLAGS)}""; \
    $${SHAREDCMD} $${SHAREDFLAGS} \
	$$ALLSYMSFLAGS $$SHOBJECTS $$NOALLSYMSFLAGS $$LIBDEPS \
		if [ -n ""$(SHLIBNAME_FULL)"" -a -n ""$(SHLIBNAME)"" -a \
		     ""$(SHLIBNAME_FULL)"" != ""$(SHLIBNAME)"" ]; then \
LINK_SO_SHLIB=	SHOBJECTS=""$(STLIBNAME) $(LIBEXTRAS)""; $(LINK_SO)
LINK_SO_DSO=	INHIBIT_SYMLINKS=yes; SHOBJECTS=""$(LIBEXTRAS)""; $(LINK_SO)
  ([ -z ""$(LIBEXTRAS)"" ] || cp $(LIBEXTRAS) $$UNPACKDIR) && \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-Bsymbolic -Wl,-soname=$(SHLIBNAME_FULL)""
DO_GNU_APP=LDFLAGS=""$(CFLAGS) $(LDFLAGS)""
	LIBDEPS="" ""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -nostdlib""; \
	LIBDEPS="" ""; \
	ALLSYMSFLAGS=""-Wl,-Bforcearchive""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -nostdlib""; \
	LDFLAGS=""$(CFLAGS) $(LDFLAGS)""; \
	SHAREDFLAGS=""$(CFLAGS) `echo $(SHARED_LDFLAGS) | sed s/dynamiclib/bundle/`""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -current_version $(SHLIBVERSION) -compatibility_version $(SHLIBVERSION) -install_name $(INSTALLTOP)/$(LIBDIR)/$(SHLIBNAME_FULL)""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared $$base -Wl,-Bsymbolic""; \
	echo ""$(PERL) $(SRCDIR)/util/mkrc.pl $(SHLIBNAME_FULL) |"" \
		     ""$(RC) $(SHARED_RCFLAGS) -o rc.o""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,--enable-auto-image-base -Wl,-Bsymbolic -Wl,--out-implib,$(SHLIBNAME) rc.o""; \
	base=; [ $(LIBNAME) = ""crypto"" -a -n ""$(FIPSCANLIB)"" ] && base=-Wl,--image-base,0x63000000; \
	echo ""$(PERL) $(SRCDIR)/util/mkrc.pl $(SHLIBNAME_FULL) |"" \
		""$(RC) $(SHARED_RCFLAGS) -o rc.o""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared $$base -Wl,-Bsymbolic -Wl,--out-implib,$(SHLIBNAME) $(LIBNAME).def rc.o""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-B,symbolic""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-B,symbolic -set_version $(SHLIBVERSION)""; \
		LDFLAGS=""$(CFLAGS) $(LDFLAGS)""; \
		ALLSYMSFLAGS=""""; \
		NOALLSYMSFLAGS=""""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -h $(SHLIBNAME_FULL) -Wl,-Bsymbolic""; \
		ALLSYMSFLAGS=""-Wl,-z,allextract,-M,$(LIBNAME).map""; \
		NOALLSYMSFLAGS=""-Wl,-z,defaultextract""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -h $(SHLIBNAME_FULL) -Wl,-Bsymbolic""; \
		LDFLAGS=""$(CFLAGS) $(LDFLAGS)""; \
		SHAREDFLAGS=""$(CFLAGS) -G -h $(SHLIBNAME_FULL)""; \
		SHAREDFLAGS=""$(CFLAGS) -G -h $(SHLIBNAME_FULL)""; \
		SHAREDFLAGS=""$(CFLAGS) $${SHARE_FLAG} -h $(SHLIBNAME_FULL)""; \
		SHAREDFLAGS=""$(CFLAGS) $${SHARE_FLAG} -h $(SHLIBNAME_FULL)""; \
		ALLSYMSFLAGS=""""; \
		NOALLSYMSFLAGS=""""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname,$(SHLIBNAME_FULL),-B,symbolic""; \
		MINUSWL=""""; \
		($(CC) -v 2>&1 | grep gcc) > /dev/null && MINUSWL=""-Wl,""; \
		SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -shared -Wl,-soname,$(SHLIBNAME_FULL),-B,symbolic""; \
	@LDFLAGS=""$(CFLAGS) $(LDFLAGS)""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-B,symbolic,+vnocompatwarnings,-z,+s,+h,$(SHLIBNAME_FULL),+cdp,../:,+cdp,./:""; \
	SHAREDFLAGS=""$(CFLAGS) $(SHARED_LDFLAGS) -Wl,-B,symbolic,+vnocompatwarnings,-z,+s,+h,$(SHLIBNAME_FULL),+cdp,../:,+cdp,./:""; \
	LDFLAGS=""$(CFLAGS) $(LDFLAGS) -Wl,+s,+cdp,../:,+cdp,./:""; \
	@OBJECT_MODE=`expr ""x$(SHARED_LDFLAGS)"" : 'x\-[a-z]*\(64\)'` || :; \
	@ OBJECT_MODE=`expr ""x$(SHARED_LDFLAGS)"" : 'x\-[a-z]*\(64\)'` || : ; \
	LDFLAGS=""$(CFLAGS) -Wl,-bsvr4 $(LDFLAGS)""; \",b15a19c148384e73338aa7c5b12652138e35ed28,CVE-2019-1552,b15a19c148384e73338aa7c5b12652138e35ed28,https://github.com/openssl/openssl,CPE_GIT_REPOBASED,144,COMPLETED,"VAR=$${VAR:-'$(VAR)'}; \ VAR=$${VAR:-'$(VAR)'}; VAR=$${VAR:-'$(VAR) $(VAR)'}; \ VAR ""$${VAR} $${VAR} -VAR $${VAR:=$(VAR)} $(VAR) $${VAR}"" ) VAR=$${VAR:-'$(VAR)'}; \ VAR=$${VAR:-'$(VAR)'}; \ VAR=$${VAR:-'$(VAR) $(VAR)'}; \ VAR ""$${VAR} $${VAR} \ $$VAR $$VAR $$VAR $$VAR"" \ VAR [ -VAR '$(VAR)' -VAR -VAR '$(VAR)' -VAR \ '$(VAR)' != '$(VAR)' ]; VAR \ VAR= VAR='$(VAR) $(VAR)'; $(VAR) VAR= VAR=VAR; VAR='$(VAR)'; $(VAR) ([ -VAR '$(VAR)' ] || VAR $(VAR) $$VAR) && \ VAR='$(VAR) $(VAR) -VAR -VAR,-VAR -VAR,-VAR=$(VAR)' VAR=VAR='$(VAR) $(VAR)' VAR=' '; \ VAR='$(VAR) $(VAR) -VAR -VAR'; \ VAR=' '; \ VAR='-VAR,-VAR'; \ VAR='$(VAR) $(VAR) -VAR -VAR'; \ VAR='$(VAR) $(VAR)'; \ VAR='$(VAR) '""`VAR '$(VAR)' | VAR VAR/VAR/VAR/`""; \ VAR='$(VAR) $(VAR) -VAR $(VAR) -VAR $(VAR) -VAR $(VAR)/$(VAR)/$(VAR)'; \ VAR='$(VAR) $(VAR)'"" -VAR $$VAR -VAR,-VAR""; \ VAR '$(VAR) $(VAR)/VAR/VAR.VAR $(VAR) |' \ '$(VAR) $(VAR) -VAR VAR.VAR'; \ VAR='$(VAR) $(VAR) -VAR -VAR,--VAR-VAR-VAR-VAR -VAR,-VAR -VAR,--VAR-VAR,$(VAR) VAR.VAR'; \ VAR=; [ '$(VAR)' = 'VAR' -VAR -VAR '$(VAR)' ] && VAR=-VAR,--VAR-VAR,0x63000000; \ VAR '$(VAR) $(VAR)/VAR/VAR.VAR $(VAR) |' \ '$(VAR) $(VAR) -VAR VAR.VAR'; \ VAR='$(VAR) $(VAR) -VAR '""$$VAR""' -VAR,-VAR -VAR,--VAR-VAR,$(VAR) $(VAR).VAR VAR.VAR'; \ VAR='$(VAR) $(VAR) -VAR -VAR,-VAR,VAR'; \ VAR='$(VAR) $(VAR) -VAR -VAR,-VAR,VAR -VAR $(VAR)'; \ VAR='$(VAR) $(VAR)'; \ VAR=''; \ VAR=''; \ VAR='$(VAR) $(VAR) -VAR $(VAR) -VAR,-VAR'; \ VAR='-VAR,-VAR,VAR,-VAR,$(VAR).VAR'; \ VAR='-VAR,-VAR,VAR'; \ VAR='$(VAR) $(VAR) -VAR $(VAR) -VAR,-VAR'; \ VAR='$(VAR) $(VAR)'; \ VAR='$(VAR) -VAR -VAR $(VAR)'; \ VAR='$(VAR) -VAR -VAR $(VAR)'; \ VAR='$(VAR) '""$${VAR}""' -VAR $(VAR)'; \ VAR='$(VAR) '""$${VAR}""' -VAR $(VAR)'; \ VAR=''; \ VAR=''; \ VAR='$(VAR) $(VAR) -VAR -VAR,-VAR,$(VAR),-VAR,VAR'; \ VAR=''; \ ($(VAR) -VAR 2>&1 | VAR VAR) > /VAR/VAR && VAR='-VAR,'; \ VAR='$(VAR) $(VAR) -VAR -VAR,-VAR,$(VAR),-VAR,VAR'; \ @VAR='$(VAR) $(VAR)'; \ VAR='$(VAR) $(VAR) -VAR,-VAR,VAR,+VAR,-VAR,+VAR,+VAR,$(VAR),+VAR,../:,+VAR,./:'; \ VAR='$(VAR) $(VAR) -VAR,-VAR,VAR,+VAR,-VAR,+VAR,+VAR,$(VAR),+VAR,../:,+VAR,./:'; \ VAR='$(VAR) $(VAR) -VAR,+VAR,+VAR,../:,+VAR,./:'; \ @VAR=`VAR 'VAR$(VAR)' : 'VAR\-[VAR-VAR]*\(64\)'` || :; \ @ VAR=`VAR 'VAR$(VAR)' : 'VAR\-[VAR-VAR]*\(64\)'` || : ; \ VAR='$(VAR) -VAR,-VAR $(VAR)'; \ VAR=""$${VAR:-$(VAR)}""; \ VAR=""$${VAR:-$(VAR)}""; VAR=""$${VAR:-$(VAR) $(VAR)}""; \ $${VAR} $${VAR} -VAR $${VAR:=$(VAR)} $(VAR) $${VAR} ) VAR=""$${VAR:-$(VAR)}""; \ VAR=""$${VAR:-$(VAR)}""; \ VAR=""$${VAR:-$(VAR) $(VAR)}""; \ $${VAR} $${VAR} \ $$VAR $$VAR $$VAR $$VAR \ VAR [ -VAR ""$(VAR)"" -VAR -VAR ""$(VAR)"" -VAR \ ""$(VAR)"" != ""$(VAR)"" ]; VAR \ VAR= VAR=""$(VAR) $(VAR)""; $(VAR) VAR= VAR=VAR; VAR=""$(VAR)""; $(VAR) ([ -VAR ""$(VAR)"" ] || VAR $(VAR) $$VAR) && \ VAR=""$(VAR) $(VAR) -VAR -VAR,-VAR -VAR,-VAR=$(VAR)"" VAR=VAR=""$(VAR) $(VAR)"" VAR="" ""; \ VAR=""$(VAR) $(VAR) -VAR -VAR""; \ VAR="" ""; \ VAR=""-VAR,-VAR""; \ VAR=""$(VAR) $(VAR) -VAR -VAR""; \ VAR=""$(VAR) $(VAR)""; \ VAR=""$(VAR) `VAR $(VAR) | VAR VAR/VAR/VAR/`""; \ VAR=""$(VAR) $(VAR) -VAR $(VAR) -VAR $(VAR) -VAR $(VAR)/$(VAR)/$(VAR)""; \ VAR=""$(VAR) $(VAR) -VAR $$VAR -VAR,-VAR""; \ VAR ""$(VAR) $(VAR)/VAR/VAR.VAR $(VAR) |"" \ ""$(VAR) $(VAR) -VAR VAR.VAR""; \ VAR=""$(VAR) $(VAR) -VAR -VAR,--VAR-VAR-VAR-VAR -VAR,-VAR -VAR,--VAR-VAR,$(VAR) VAR.VAR""; \ VAR=; [ $(VAR) = ""VAR"" -VAR -VAR ""$(VAR)"" ] && VAR=-VAR,--VAR-VAR,0x63000000; \ VAR ""$(VAR) $(VAR)/VAR/VAR.VAR $(VAR) |"" \ ""$(VAR) $(VAR) -VAR VAR.VAR""; \ VAR=""$(VAR) $(VAR) -VAR $$VAR -VAR,-VAR -VAR,--VAR-VAR,$(VAR) $(VAR).VAR VAR.VAR""; \ VAR=""$(VAR) $(VAR) -VAR -VAR,-VAR,VAR""; \ VAR=""$(VAR) $(VAR) -VAR -VAR,-VAR,VAR -VAR $(VAR)""; \ VAR=""$(VAR) $(VAR)""; \ VAR=""""; \ VAR=""""; \ VAR=""$(VAR) $(VAR) -VAR $(VAR) -VAR,-VAR""; \ VAR=""-VAR,-VAR,VAR,-VAR,$(VAR).VAR""; \ VAR=""-VAR,-VAR,VAR""; \ VAR=""$(VAR) $(VAR) -VAR $(VAR) -VAR,-VAR""; \ VAR=""$(VAR) $(VAR)""; \ VAR=""$(VAR) -VAR -VAR $(VAR)""; \ VAR=""$(VAR) -VAR -VAR $(VAR)""; \ VAR=""$(VAR) $${VAR} -VAR $(VAR)""; \ VAR=""$(VAR) $${VAR} -VAR $(VAR)""; \ VAR=""""; \ VAR=""""; \ VAR=""$(VAR) $(VAR) -VAR -VAR,-VAR,$(VAR),-VAR,VAR""; \ VAR=""""; \ ($(VAR) -VAR 2>&1 | VAR VAR) > /VAR/VAR && VAR=""-VAR,""; \ VAR=""$(VAR) $(VAR) -VAR -VAR,-VAR,$(VAR),-VAR,VAR""; \ @VAR=""$(VAR) $(VAR)""; \ VAR=""$(VAR) $(VAR) -VAR,-VAR,VAR,+VAR,-VAR,+VAR,+VAR,$(VAR),+VAR,../:,+VAR,./:""; \ VAR=""$(VAR) $(VAR) -VAR,-VAR,VAR,+VAR,-VAR,+VAR,+VAR,$(VAR),+VAR,../:,+VAR,./:""; \ VAR=""$(VAR) $(VAR) -VAR,+VAR,+VAR,../:,+VAR,./:""; \ @VAR=`VAR ""VAR$(VAR)"" : 'VAR\-[VAR-VAR]*\(64\)'` || :; \ @ VAR=`VAR ""VAR$(VAR)"" : 'VAR\-[VAR-VAR]*\(64\)'` || : ; \ VAR=""$(VAR) -VAR,-VAR $(VAR)""; \",10,7
server_c0868f93f1175c32379f6e64b245b724c40478be,liprivate/User/Database.php,"		if (mb_strlen($displayName) > 64) {
			return false;
		}
",,c0868f93f1175c32379f6e64b245b724c40478be,CVE-2022-39346,c0868f93f1175c32379f6e64b245b724c40478be,https://github.com/nextcloud/server,NVD_GIT_REPOBASED,74,COMPLETED,VAR (VAR($VAR) > 64) { VAR VAR; } ,10,7
squid_7a5af8db8e0377c06ed9ffbdcb1334389c7cd8ab,src/ipc/mem/PageStack.cc,"#include <cmath>
#include <algorithm>
/*

Ipc::Mem::IdSet and related code maintains a perfect full binary tree structure:

         (l,r)
           /\
    (ll,lr)  (rl,rr)
       /\      /\
      L1 L2   L3 L4

where

    * (l,r) is an always-present root node;
    * inner nodes, including the root one, count the total number of available
      IDs in the leaf nodes of the left and right subtrees (e.g., r = rl + rr);
    * leaf nodes are bitsets of available IDs (e.g., rl = number of 1s in L3);
      all leaf nodes are always present.

The above sample tree would be stored as seven 64-bit atomic integers:
    (l,r), (ll,lr), (rl,rr), L1, L2, L3, L4

*/

namespace Ipc
{

namespace Mem
{

/// the maximum number of pages that a leaf node can store
static const IdSet::size_type BitsPerLeaf = 64;

class IdSetPosition
{
public:
    using size_type = IdSet::size_type;

    IdSetPosition() = default; ///< root node position
    IdSetPosition(size_type aLevel, size_type anOffset);

    /// whether we are at the top of the tree
    bool atRoot() const { return !level && !offset; }

    /// which direction is this position from our parent node
    IdSetNavigationDirection ascendDirection() const;

    /// the number of levels above us (e.g., zero for the root node)
    IdSet::size_type level = 0;
    /// the number of nodes (at our level) to the left of us
    IdSet::size_type offset = 0;
};

/// a helper class to perform inner node manipulation for IdSet
class IdSetInnerNode
{
public:
    using size_type = IdSet::size_type;
    typedef uint64_t Packed; ///< (atomically) stored serialized value

    /// de-serializes a given value
    static IdSetInnerNode Unpack(Packed packed);

    IdSetInnerNode() = default;
    IdSetInnerNode(size_type left, size_type right);

    /// returns a serializes value suitable for shared memory storage
    Packed pack() const { return (static_cast<Packed>(left) << 32) | right; }

    size_type left = 0; ///< the number of available IDs in the left subtree
    size_type right = 0; ///< the number of available IDs in the right subtree
};

} // namespace Mem

} // namespace Ipc

/* Ipc::Mem::IdSetPosition */

Ipc::Mem::IdSetPosition::IdSetPosition(size_type aLevel, size_type anOffset):
    level(aLevel),
    offset(anOffset)
{
}

Ipc::Mem::IdSetNavigationDirection
Ipc::Mem::IdSetPosition::ascendDirection() const
{
    return (offset % 2 == 0) ? dirLeft : dirRight;
}

/* Ipc::Mem::IdSetMeasurements */

Ipc::Mem::IdSetMeasurements::IdSetMeasurements(const size_type aCapacity)
{
    capacity = aCapacity;

    // For simplicity, we want a perfect full binary tree with root and leaves.
    // We could compute all this with log2() calls, but rounding and honoring
    // root+leaves minimums make that approach more complex than this fast loop.
    requestedLeafNodeCount = (capacity + (BitsPerLeaf-1))/BitsPerLeaf;
    treeHeight = 1+1; // the root level plus the leaf nodes level
    leafNodeCount = 2; // the root node can have only two leaf nodes
    while (leafNodeCount < requestedLeafNodeCount) {
        leafNodeCount *= 2;
        ++treeHeight;
    }
    innerLevelCount = treeHeight - 1;

    debugs(54, 5, ""rounded capacity up from "" << capacity << "" to "" << (leafNodeCount*BitsPerLeaf));

    // we do (1 << level) when computing 32-bit IdSetInnerNode::left
    assert(treeHeight < 32);
}

/* Ipc::Mem::IdSetInnerNode */

Ipc::Mem::IdSetInnerNode::IdSetInnerNode(size_type aLeft, size_type aRight):
    left(aLeft),
    right(aRight)
{
}

Ipc::Mem::IdSetInnerNode
Ipc::Mem::IdSetInnerNode::Unpack(Packed packed)
{
    // truncation during the cast is intentional here
    return IdSetInnerNode(packed >> 32, static_cast<uint32_t>(packed));
}

/* Ipc::Mem::IdSet */

Ipc::Mem::IdSet::IdSet(const size_type capacity):
    measurements(capacity),
    nodes_(capacity)
{
    // For valueAddress() to be able to return a raw uint64_t pointer, the
    // atomic wrappers in nodes_ must be zero-size. Check the best we can. Once.
    static_assert(sizeof(StoredNode) == sizeof(Node), ""atomic locks use no storage"");
    assert(StoredNode().is_lock_free());

    makeFullBeforeSharing();
}

void
Ipc::Mem::IdSet::makeFullBeforeSharing()
{
    // initially, all IDs are marked as available
    fillAllNodes();

    // ... but IDs beyond the requested capacity should not be available
    if (measurements.capacity != measurements.leafNodeCount*BitsPerLeaf)
        truncateExtras();
}

/// populates the entire allocated tree with available IDs
/// may exceed the requested capacity; \see truncateExtras()
void
Ipc::Mem::IdSet::fillAllNodes()
{
    // leaf nodes
    auto pos = Position(measurements.treeHeight-1, 0);
    const auto allOnes = ~uint64_t(0);
    std::fill_n(valueAddress(pos), measurements.leafNodeCount, allOnes);

    // inner nodes, starting from the bottom of the tree
    auto nodesAtLevel = measurements.leafNodeCount/2;
    auto pagesBelow = BitsPerLeaf;
    do {
        pos = ascend(pos);
        const auto value = IdSetInnerNode(pagesBelow, pagesBelow).pack();
        std::fill_n(valueAddress(pos), nodesAtLevel, value);
        nodesAtLevel /= 2;
        pagesBelow *= 2;
    } while (!pos.atRoot());
}

/// effectively removes IDs that exceed the requested capacity after makeFull()
void
Ipc::Mem::IdSet::truncateExtras()
{
    // leaf nodes
    // start with the left-most leaf that should have some 0s; it may even have
    // no 1s at all (i.e. be completely unused)
    auto pos = Position(measurements.treeHeight-1, measurements.capacity/BitsPerLeaf);
    leafTruncate(pos, measurements.capacity % BitsPerLeaf);
    const auto rightLeaves = measurements.leafNodeCount - measurements.requestedLeafNodeCount;
    // this zeroing of the leaf nodes to the right from pos is only necessary to
    // trigger asserts if the code dealing with the inner node counters is buggy
    if (rightLeaves > 1)
        std::fill_n(valueAddress(pos) + 1, rightLeaves-1, 0);
    // inner nodes, starting from the bottom of the tree; optimization: only
    // adjusting nodes on the way up from the first leaf-with-0s position
    auto toSubtract = BitsPerLeaf - (measurements.capacity % BitsPerLeaf);
    do {
        const auto direction = pos.ascendDirection();
        pos = ascend(pos);
        toSubtract = innerTruncate(pos, direction, toSubtract);
    } while (!pos.atRoot());
}

/// fill the leaf node at a given position with 0s, leaving only idsToKeep IDs
Ipc::Mem::IdSet::leafTruncate(const Position pos, const size_type idsToKeep)
    Node &node = *valueAddress(pos); // no auto to simplify the asserts() below
    assert(node == std::numeric_limits<Node>::max()); // all 1s
    static_assert(std::is_unsigned<Node>::value, ""right shift prepends 0s"");
    node >>= BitsPerLeaf - idsToKeep;
    // node can be anything here, including all 0s and all 1s
}

/// accounts for toSubtract IDs removal from a subtree in the given direction of
/// the given position
/// \returns the number of IDs to subtract from the parent node
Ipc::Mem::IdSet::size_type
Ipc::Mem::IdSet::innerTruncate(const Position pos, const NavigationDirection dir, const size_type toSubtract)
{
    auto *valuePtr = valueAddress(pos);
    auto value = IdSetInnerNode::Unpack(*valuePtr);
    size_type toSubtractNext = 0;
    if (dir == dirLeft) {
        toSubtractNext = toSubtract + value.right;
        assert(value.left >= toSubtract);
        value.left -= toSubtract;
        value.right = 0;
    } else {
        assert(dir == dirRight);
        toSubtractNext = toSubtract;
        assert(value.right >= toSubtract);
        // value.left is unchanged; we have only adjusted the right branch
        value.right -= toSubtract;
    }
    *valuePtr = value.pack();
    return toSubtractNext;
}

/// accounts for an ID added to subtree in the given dir from the given position
void
Ipc::Mem::IdSet::innerPush(const Position pos, const NavigationDirection dir)
{
    // either left or right component will be true/1; the other will be false/0
    const auto increment = IdSetInnerNode(dir == dirLeft, dir == dirRight).pack();
    const auto previousValue = nodeAt(pos).fetch_add(increment);
    // no overflows
    assert(previousValue <= std::numeric_limits<Node>::max() - increment);
}

/// accounts for future ID removal from a subtree of the given position
/// \returns the direction of the subtree chosen to relinquish the ID
Ipc::Mem::IdSet::NavigationDirection
Ipc::Mem::IdSet::innerPop(const Position pos)
{
    NavigationDirection direction = dirNone;

    auto &node = nodeAt(pos);
    auto oldValue = node.load();
    IdSetInnerNode newValue;
    do {
        newValue = IdSetInnerNode::Unpack(oldValue);
        if (newValue.left) {
            --newValue.left;
            direction = dirLeft;
        } else if (newValue.right) {
            --newValue.right;
            direction = dirRight;
        } else {
            return dirEnd;
        }
    } while (!node.compare_exchange_weak(oldValue, newValue.pack()));

    assert(direction == dirLeft || direction == dirRight);
    return direction;
/// adds the given ID to the leaf node at the given position
Ipc::Mem::IdSet::leafPush(const Position pos, const size_type id)
    const auto mask = Node(1) << (id % BitsPerLeaf);
    const auto oldValue = nodeAt(pos).fetch_or(mask);
    // this was a new entry
    assert((oldValue & mask) == 0);
}

// TODO: After switching to C++20, use countr_zero() which may compile to a
// single TZCNT assembly instruction on modern CPUs.
/// a temporary C++20 countr_zero() replacement
static inline
int trailingZeros(uint64_t x)
{
    if (!x)
        return 64;
    int count = 0;
    for (uint64_t mask = 1; !(x & mask); mask <<= 1)
        ++count;
    return count;
}

/// extracts and returns an ID from the leaf node at the given position
Ipc::Mem::IdSet::size_type
Ipc::Mem::IdSet::leafPop(const Position pos)
{
    auto &node = nodeAt(pos);
    auto oldValue = node.load();
    Node newValue;
    do {
        assert(oldValue > 0);
        const auto mask = oldValue - 1; // flips the rightmost 1 and trailing 0s
        newValue = oldValue & mask; // clears the rightmost 1
    } while (!node.compare_exchange_weak(oldValue, newValue));

    return pos.offset*BitsPerLeaf + trailingZeros(oldValue);
}

/// \returns the position of a parent node of the node at the given position
Ipc::Mem::IdSet::Position
Ipc::Mem::IdSet::ascend(Position pos)
{
    assert(pos.level > 0);
    --pos.level;
    pos.offset /= 2;
    return pos;
}

/// \returns the position of a child node in the given direction of the parent
/// node at the given position
Ipc::Mem::IdSet::Position
Ipc::Mem::IdSet::descend(Position pos, const NavigationDirection direction)
{
    assert(pos.level < measurements.treeHeight);
    ++pos.level;

    pos.offset *= 2;
    if (direction == dirRight)
        ++pos.offset;
    else
        assert(direction == dirLeft);

    return pos;
}

/// \returns the atomic node (either inner or leaf) at the given position
Ipc::Mem::IdSet::StoredNode &
Ipc::Mem::IdSet::nodeAt(const Position pos)
{
    assert(pos.level < measurements.treeHeight);
    // n = 2^(h+1) - 1 with h = level-1
    const auto nodesAbove = (1U << pos.level) - 1;

    // the second clause is for the special case of a root node
    assert(pos.offset < nodesAbove*2 || (pos.atRoot() && nodesAbove == 0));
    const auto nodesToTheLeft = pos.offset;

    const size_t nodesBefore = nodesAbove + nodesToTheLeft;
    assert(nodesBefore < measurements.nodeCount());
    return nodes_[nodesBefore];
}

/// \returns the location of the raw (inner or leaf) node at the given position
Ipc::Mem::IdSet::Node *
Ipc::Mem::IdSet::valueAddress(const Position pos)
{
    // IdSet() constructor asserts that this frequent reinterpret_cast is safe
    return &reinterpret_cast<Node&>(nodeAt(pos));
}

bool
Ipc::Mem::IdSet::pop(size_type &id)
{
    Position rootPos;
    const auto directionFromRoot = innerPop(rootPos);
    if (directionFromRoot == dirEnd)
        return false; // an empty tree

    auto pos = descend(rootPos, directionFromRoot);
    for (size_t level = 1; level < measurements.innerLevelCount; ++level) {
        const auto direction = innerPop(pos);
        pos = descend(pos, direction);
    }

    id = leafPop(pos);
    return true;
}

void
Ipc::Mem::IdSet::push(const size_type id)
{
    const auto offsetAtLeafLevel = id/BitsPerLeaf;
    auto pos = Position(measurements.innerLevelCount, offsetAtLeafLevel);
    leafPush(pos, id);

    do {
        const auto direction = pos.ascendDirection();
        pos = ascend(pos);
        innerPush(pos, direction);
    } while (!pos.atRoot());
}

size_t
Ipc::Mem::IdSet::MemorySize(const size_type capacity)
{
    const IdSetMeasurements measurements(capacity);
    // Adding sizeof(IdSet) double-counts the first node but it is better to
    // overestimate (a little) than to underestimate our memory needs due to
    // padding, new data members, etc.
    return sizeof(IdSet) + measurements.nodeCount() * sizeof(StoredNode);
    ids_(capacity_)
{
    size_ = capacity_;
    if (!capacity_)
        return false;
    IdSet::size_type pageIndex = 0;
    if (!ids_.pop(pageIndex))
        return false;
    page.number = pageIndex + 1;
    assert(pageIdIsValid(page));
    const auto pageIndex = page.number - 1;
    ids_.push(pageIndex);
    // Adding sizeof(PageStack) double-counts the fixed portion of the ids_ data
    // member but it is better to overestimate (a little) than to underestimate
    // our memory needs due to padding, new data members, etc.
    return sizeof(PageStack) + IdSet::MemorySize(capacity);","#include ""base/TextException.h""
/* Ipc::Mem::PageStackStorageSlot */
static_assert(sizeof(Ipc::Mem::PageStackStorageSlot::Pointer) ==
              sizeof(decltype(Ipc::Mem::PageId::number)), ""page indexing types are consistent"");
Ipc::Mem::PageStackStorageSlot::take()
    const auto nxt = nextOrMarker.exchange(TakenPage);
    assert(nxt != TakenPage);
Ipc::Mem::PageStackStorageSlot::put(const PointerOrMarker expected, const Pointer nxt)
    assert(nxt != TakenPage);
    const auto old = nextOrMarker.exchange(nxt);
    assert(old == expected);
    head_(Slot::NilPtr),
    slots_(aCapacity)
{
    assert(thePoolId);

    assert(capacity_ < Slot::TakenPage);
    assert(capacity_ < Slot::NilPtr);

    // initially, all pages are free
    if (capacity_) {
        const auto lastIndex = capacity_-1;
        // FlexibleArray cannot construct its phantom elements so, technically,
        // all slots (except the very first one) are uninitialized until now.
        for (Slot::Pointer i = 0; i < lastIndex; ++i)
            (void)new(&slots_[i])Slot(i+1);
        (void)new(&slots_[lastIndex])Slot(Slot::NilPtr);
        size_ = capacity_;
        head_ = 0;
    }
    Slot::Pointer current = head_.load();
    auto nextFree = Slot::NilPtr;
    do {
        if (current == Slot::NilPtr)
            return false;
        nextFree = slots_[current].next();
    } while (!head_.compare_exchange_weak(current, nextFree));
    slots_[current].take();
    page.number = current + 1;
    const auto pageIndex = page.number - 1;
    auto &slot = slots_[pageIndex];

    auto current = head_.load();
    auto expected = Slot::TakenPage;
    do {
        slot.put(expected, current);
        expected = current;
    } while (!head_.compare_exchange_weak(current, pageIndex));
    return sizeof(PageStack) + capacity * sizeof(Slot);",7a5af8db8e0377c06ed9ffbdcb1334389c7cd8ab,CVE-2020-14059,7a5af8db8e0377c06ed9ffbdcb1334389c7cd8ab,https://github.com/squid-cache/squid,CPE_GIT_REPOBASED,92,COMPLETED,"  /* VAR::VAR::VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: (VAR,VAR) /\ (VAR,VAR) (VAR,VAR) /\ /\ VAR VAR VAR VAR VAR * (VAR,VAR) VAR VAR VAR-VAR VAR VAR; * VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR.VAR., VAR = VAR + VAR); * VAR VAR VAR VAR VAR VAR VAR (VAR.VAR., VAR = VAR VAR 1s VAR VAR); VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR 64-VAR VAR VAR: (VAR,VAR), (VAR,VAR), (VAR,VAR), VAR, VAR, VAR, VAR */ VAR VAR { VAR VAR {  VAR VAR VAR::VAR VAR = 64; VAR VAR { VAR: VAR VAR = VAR::VAR; VAR() = VAR;  VAR(VAR VAR, VAR VAR);  VAR VAR() VAR { VAR !VAR && !VAR; }  VAR VAR() VAR;  VAR::VAR VAR = 0;  VAR::VAR VAR = 0; };  VAR VAR { VAR: VAR VAR = VAR::VAR; VAR VAR VAR;   VAR VAR VAR(VAR VAR); VAR() = VAR; VAR(VAR VAR, VAR VAR);  VAR VAR() VAR { VAR (VAR<VAR>(VAR) << 32) | VAR; } VAR VAR = 0;  VAR VAR = 0;  }; }  }   VAR::VAR::VAR::VAR(VAR VAR, VAR VAR): VAR(VAR), VAR(VAR) { } VAR::VAR::VAR VAR::VAR::VAR::VAR() VAR { VAR (VAR % 2 == 0) ? VAR : VAR; }  VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR = VAR;    VAR = (VAR + (VAR-1))/VAR; VAR = 1+1;  VAR = 2;  VAR (VAR < VAR) { VAR *= 2; ++VAR; } VAR = VAR - 1; VAR(54, 5, ""VAR VAR VAR VAR "" << VAR << "" VAR "" << (VAR*VAR));  VAR(VAR < 32); }  VAR::VAR::VAR::VAR(VAR VAR, VAR VAR): VAR(VAR), VAR(VAR) { } VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR) {  VAR VAR(VAR >> 32, VAR<VAR>(VAR)); }  VAR::VAR::VAR::VAR(VAR VAR VAR): VAR(VAR), VAR(VAR) {   VAR(VAR(VAR) == VAR(VAR), ""VAR VAR VAR VAR VAR""); VAR(VAR().VAR()); VAR(); } VAR VAR::VAR::VAR::VAR() {  VAR();  VAR (VAR.VAR != VAR.VAR*VAR) VAR(); }   VAR VAR::VAR::VAR::VAR() {  VAR VAR = VAR(VAR.VAR-1, 0); VAR VAR VAR = ~VAR(0); VAR::VAR(VAR(VAR), VAR.VAR, VAR);  VAR VAR = VAR.VAR/2; VAR VAR = VAR; VAR { VAR = VAR(VAR); VAR VAR VAR = VAR(VAR, VAR).VAR(); VAR::VAR(VAR(VAR), VAR, VAR); VAR /= 2; VAR *= 2; } VAR (!VAR.VAR()); }  VAR VAR::VAR::VAR::VAR() {    VAR VAR = VAR(VAR.VAR-1, VAR.VAR/VAR); VAR(VAR, VAR.VAR % VAR); VAR VAR VAR = VAR.VAR - VAR.VAR;   VAR (VAR > 1) VAR::VAR(VAR(VAR) + 1, VAR-1, 0);   VAR VAR = VAR - (VAR.VAR % VAR); VAR { VAR VAR VAR = VAR.VAR(); VAR = VAR(VAR); VAR = VAR(VAR, VAR, VAR); } VAR (!VAR.VAR()); }  VAR::VAR::VAR::VAR(VAR VAR VAR, VAR VAR VAR) VAR &VAR = *VAR(VAR);  VAR(VAR == VAR::VAR<VAR>::VAR());  VAR(VAR::VAR<VAR>::VAR, ""VAR VAR VAR 0s""); VAR >>= VAR - VAR;  }    VAR::VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR VAR, VAR VAR VAR, VAR VAR VAR) { VAR *VAR = VAR(VAR); VAR VAR = VAR::VAR(*VAR); VAR VAR = 0; VAR (VAR == VAR) { VAR = VAR + VAR.VAR; VAR(VAR.VAR >= VAR); VAR.VAR -= VAR; VAR.VAR = 0; } VAR { VAR(VAR == VAR); VAR = VAR; VAR(VAR.VAR >= VAR);  VAR.VAR -= VAR; } *VAR = VAR.VAR(); VAR VAR; }  VAR VAR::VAR::VAR::VAR(VAR VAR VAR, VAR VAR VAR) {  VAR VAR VAR = VAR(VAR == VAR, VAR == VAR).VAR(); VAR VAR VAR = VAR(VAR).VAR(VAR);  VAR(VAR <= VAR::VAR<VAR>::VAR() - VAR); }   VAR::VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR VAR = VAR; VAR &VAR = VAR(VAR); VAR VAR = VAR.VAR(); VAR VAR; VAR { VAR = VAR::VAR(VAR); VAR (VAR.VAR) { --VAR.VAR; VAR = VAR; } VAR VAR (VAR.VAR) { --VAR.VAR; VAR = VAR; } VAR { VAR VAR; } } VAR (!VAR.VAR(VAR, VAR.VAR())); VAR(VAR == VAR || VAR == VAR); VAR VAR;  VAR::VAR::VAR::VAR(VAR VAR VAR, VAR VAR VAR) VAR VAR VAR = VAR(1) << (VAR % VAR); VAR VAR VAR = VAR(VAR).VAR(VAR);  VAR((VAR & VAR) == 0); }    VAR VAR VAR VAR(VAR VAR) { VAR (!VAR) VAR 64; VAR VAR = 0; VAR (VAR VAR = 1; !(VAR & VAR); VAR <<= 1) ++VAR; VAR VAR; }  VAR::VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR &VAR = VAR(VAR); VAR VAR = VAR.VAR(); VAR VAR; VAR { VAR(VAR > 0); VAR VAR VAR = VAR - 1;  VAR = VAR & VAR;  } VAR (!VAR.VAR(VAR, VAR)); VAR VAR.VAR*VAR + VAR(VAR); }  VAR::VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR) { VAR(VAR.VAR > 0); --VAR.VAR; VAR.VAR /= 2; VAR VAR; }   VAR::VAR::VAR::VAR VAR::VAR::VAR::VAR(VAR VAR, VAR VAR VAR) { VAR(VAR.VAR < VAR.VAR); ++VAR.VAR; VAR.VAR *= 2; VAR (VAR == VAR) ++VAR.VAR; VAR VAR(VAR == VAR); VAR VAR; }  VAR::VAR::VAR::VAR & VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR(VAR.VAR < VAR.VAR);  VAR VAR VAR = (1U << VAR.VAR) - 1;  VAR(VAR.VAR < VAR*2 || (VAR.VAR() && VAR == 0)); VAR VAR VAR = VAR.VAR; VAR VAR VAR = VAR + VAR; VAR(VAR < VAR.VAR()); VAR VAR[VAR]; }  VAR::VAR::VAR::VAR * VAR::VAR::VAR::VAR(VAR VAR VAR) {  VAR &VAR<VAR&>(VAR(VAR)); } VAR VAR::VAR::VAR::VAR(VAR &VAR) { VAR VAR; VAR VAR VAR = VAR(VAR); VAR (VAR == VAR) VAR VAR;  VAR VAR = VAR(VAR, VAR); VAR (VAR VAR = 1; VAR < VAR.VAR; ++VAR) { VAR VAR VAR = VAR(VAR); VAR = VAR(VAR, VAR); } VAR = VAR(VAR); VAR VAR; } VAR VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR VAR VAR = VAR/VAR; VAR VAR = VAR(VAR.VAR, VAR); VAR(VAR, VAR); VAR { VAR VAR VAR = VAR.VAR(); VAR = VAR(VAR); VAR(VAR, VAR); } VAR (!VAR.VAR()); } VAR VAR::VAR::VAR::VAR(VAR VAR VAR) { VAR VAR VAR(VAR);    VAR VAR(VAR) + VAR.VAR() * VAR(VAR); VAR(VAR) { VAR = VAR; VAR (!VAR) VAR VAR; VAR::VAR VAR = 0; VAR (!VAR.VAR(VAR)) VAR VAR; VAR.VAR = VAR + 1; VAR(VAR(VAR)); VAR VAR VAR = VAR.VAR - 1; VAR.VAR(VAR);    VAR VAR(VAR) + VAR::VAR(VAR);   VAR(VAR(VAR::VAR::VAR::VAR) == VAR(VAR(VAR::VAR::VAR::VAR)), ""VAR VAR VAR VAR VAR""); VAR::VAR::VAR::VAR() VAR VAR VAR = VAR.VAR(VAR); VAR(VAR != VAR); VAR::VAR::VAR::VAR(VAR VAR VAR, VAR VAR VAR) VAR(VAR != VAR); VAR VAR VAR = VAR.VAR(VAR); VAR(VAR == VAR); VAR(VAR::VAR), VAR(VAR) { VAR(VAR); VAR(VAR < VAR::VAR); VAR(VAR < VAR::VAR);  VAR (VAR) { VAR VAR VAR = VAR-1;   VAR (VAR::VAR VAR = 0; VAR < VAR; ++VAR) (VAR)VAR(&VAR[VAR])VAR(VAR+1); (VAR)VAR(&VAR[VAR])VAR(VAR::VAR); VAR = VAR; VAR = 0; } VAR::VAR VAR = VAR.VAR(); VAR VAR = VAR::VAR; VAR { VAR (VAR == VAR::VAR) VAR VAR; VAR = VAR[VAR].VAR(); } VAR (!VAR.VAR(VAR, VAR)); VAR[VAR].VAR(); VAR.VAR = VAR + 1; VAR VAR VAR = VAR.VAR - 1; VAR &VAR = VAR[VAR]; VAR VAR = VAR.VAR(); VAR VAR = VAR::VAR; VAR { VAR.VAR(VAR, VAR); VAR = VAR; } VAR (!VAR.VAR(VAR, VAR)); VAR VAR(VAR) + VAR * VAR(VAR);",10,7
squid_93f5fda134a2a010b84ffedbe833d670e63ba4be,src/ssl/ErrorDetail.cc,"    {   X509_V_ERR_APPLICATION_VERIFICATION, //50
        ""X509_V_ERR_APPLICATION_VERIFICATION""
    },
#if defined(X509_V_ERR_PATH_LOOP)
    {
        X509_V_ERR_PATH_LOOP, //55
        ""X509_V_ERR_PATH_LOOP""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_INVALID_VERSION)
    {
        X509_V_ERR_SUITE_B_INVALID_VERSION, //56
        ""X509_V_ERR_SUITE_B_INVALID_VERSION""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_INVALID_ALGORITHM)
    {
        X509_V_ERR_SUITE_B_INVALID_ALGORITHM, //57
        ""X509_V_ERR_SUITE_B_INVALID_ALGORITHM""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_INVALID_CURVE)
    {
        X509_V_ERR_SUITE_B_INVALID_CURVE, //58
        ""X509_V_ERR_SUITE_B_INVALID_CURVE""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM)
    {
        X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM, //59
        ""X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED)
    {
        X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED, //60
        ""X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED""
    },
#endif
#if defined(X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256)
    {
        X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256, //61
        ""X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256""
    },
#endif
#if defined(X509_V_ERR_HOSTNAME_MISMATCH)
    {
        X509_V_ERR_HOSTNAME_MISMATCH, //62
        ""X509_V_ERR_HOSTNAME_MISMATCH""
    },
#endif
#if defined(X509_V_ERR_EMAIL_MISMATCH)
    {
        X509_V_ERR_EMAIL_MISMATCH, //63
        ""X509_V_ERR_EMAIL_MISMATCH""
    },
#endif
#if defined(X509_V_ERR_IP_ADDRESS_MISMATCH)
    {
        X509_V_ERR_IP_ADDRESS_MISMATCH, //64
        ""X509_V_ERR_IP_ADDRESS_MISMATCH""
    },
#endif
#if defined(X509_V_ERR_DANE_NO_MATCH)
    {
        X509_V_ERR_DANE_NO_MATCH, //65
        ""X509_V_ERR_DANE_NO_MATCH""
#endif
#if defined(X509_V_ERR_EE_KEY_TOO_SMALL)
    {
        X509_V_ERR_EE_KEY_TOO_SMALL, //66
        ""X509_V_ERR_EE_KEY_TOO_SMALL""
    },
#endif
#if defined(X509_V_ERR_CA_KEY_TOO_SMALL)
    {
        X509_V_ERR_CA_KEY_TOO_SMALL, //67
        ""X509_V_ERR_CA_KEY_TOO_SMALL""
    },
#endif
#if defined(X509_V_ERR_CA_MD_TOO_WEAK)
    {
        X509_V_ERR_CA_MD_TOO_WEAK, //68
        ""X509_V_ERR_CA_MD_TOO_WEAK""
    },
#endif
#if defined(X509_V_ERR_INVALID_CALL)
    {
        X509_V_ERR_INVALID_CALL, //69
        ""X509_V_ERR_INVALID_CALL""
    },
#endif
#if defined(X509_V_ERR_STORE_LOOKUP)
    {
        X509_V_ERR_STORE_LOOKUP, //70
        ""X509_V_ERR_STORE_LOOKUP""
    },
#endif
#if defined(X509_V_ERR_NO_VALID_SCTS)
    {
        X509_V_ERR_NO_VALID_SCTS, //71
        ""X509_V_ERR_NO_VALID_SCTS""
    },
#endif
#if defined(X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION)
    {
        X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION, //72
        ""X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION""
    },
#endif
#if defined(X509_V_ERR_OCSP_VERIFY_NEEDED)
    {
        X509_V_ERR_OCSP_VERIFY_NEEDED, //73
        ""X509_V_ERR_OCSP_VERIFY_NEEDED""
    },
#endif
#if defined(X509_V_ERR_OCSP_VERIFY_FAILED)
    {
        X509_V_ERR_OCSP_VERIFY_FAILED, //74
        ""X509_V_ERR_OCSP_VERIFY_FAILED""
    },
#endif
#if defined(X509_V_ERR_OCSP_CERT_UNKNOWN)
    {
        X509_V_ERR_OCSP_CERT_UNKNOWN, //75
        ""X509_V_ERR_OCSP_CERT_UNKNOWN""
    },
#endif
    ""X509_V_ERR_PATH_LOOP"",
    ""X509_V_ERR_SUITE_B_INVALID_VERSION"",
    ""X509_V_ERR_SUITE_B_INVALID_ALGORITHM"",
    ""X509_V_ERR_SUITE_B_INVALID_CURVE"",
    ""X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM"",
    ""X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED"",
    ""X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256"",
    ""X509_V_ERR_HOSTNAME_MISMATCH"",
    ""X509_V_ERR_EMAIL_MISMATCH"",
    ""X509_V_ERR_IP_ADDRESS_MISMATCH"",
    ""X509_V_ERR_DANE_NO_MATCH"",
    ""X509_V_ERR_EE_KEY_TOO_SMALL"",
    ""X509_V_ERR_CA_KEY_TOO_SMALL"",
    ""X509_V_ERR_CA_MD_TOO_WEAK"",
    ""X509_V_ERR_INVALID_CALL"",
    ""X509_V_ERR_STORE_LOOKUP"",
    ""X509_V_ERR_NO_VALID_SCTS"",
    ""X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION"",
    ""X509_V_ERR_OCSP_VERIFY_NEEDED"",
    ""X509_V_ERR_OCSP_VERIFY_FAILED"",
    ""X509_V_ERR_OCSP_CERT_UNKNOWN"",
const char *Ssl::GetErrorName(Security::ErrorCode value, const bool prefixRawCode)
    static char tmpBuffer[128];
    snprintf(tmpBuffer, sizeof(tmpBuffer), ""%s%d"", prefixRawCode ? ""SSL_ERR="" : """", (int)value);
    return tmpBuffer;
    if (const char *err = detailEntry.name.termedBuf())
        return err;
    return GetErrorName(error_no);","    {   X509_V_ERR_APPLICATION_VERIFICATION,
        ""X509_V_ERR_APPLICATION_VERIFICATION""
const char *Ssl::GetErrorName(Security::ErrorCode value)
    return NULL;
    static char tmpBuffer[64];
    const char *err = detailEntry.name.termedBuf();
    if (!err)
        err = GetErrorName(error_no);

    if (!err) {
        snprintf(tmpBuffer, 64, ""%d"", (int)error_no);
        err = tmpBuffer;
    }
    return err;",93f5fda134a2a010b84ffedbe833d670e63ba4be,CVE-2020-14058,93f5fda134a2a010b84ffedbe833d670e63ba4be,https://github.com/squid-cache/squid,CPE_GIT_REPOBASED,84,COMPLETED,"{ VAR,  ""VAR"" },  { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR""   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },   { VAR,  ""VAR"" },  ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", VAR VAR *VAR::VAR(VAR::VAR VAR, VAR VAR VAR) VAR VAR VAR[128]; VAR(VAR, VAR(VAR), ""%VAR%VAR"", VAR ? ""VAR="" : """", (VAR)VAR); VAR VAR; VAR (VAR VAR *VAR = VAR.VAR.VAR()) VAR VAR; VAR VAR(VAR); { VAR, ""VAR"" VAR VAR *VAR::VAR(VAR::VAR VAR) VAR VAR; VAR VAR VAR[64]; VAR VAR *VAR = VAR.VAR.VAR(); VAR (!VAR) VAR = VAR(VAR); VAR (!VAR) { VAR(VAR, 64, ""%VAR"", (VAR)VAR); VAR = VAR; } VAR VAR;",10,7
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,appveyor.yml,"# AppVeyor.yml from https://github.com/ogrisel/python-appveyor-demo
# License: CC0 1.0 Universal: http://creativecommons.org/publicdomain/zero/1.0/

skip_branch_with_pr: true
build: off

environment:

  matrix:
    - PYTHON: ""C:\\Python27-x64""
      PYTHON_VERSION: ""2.7.x""
      PYTHON_ARCH: ""64""
      TOXENV: ""py27""
      TOXPY27: ""%PYTHON%\\python.exe""

    - PYTHON: ""C:\\Python34-x64""
      PYTHON_VERSION: ""3.4.x""
      PYTHON_ARCH: ""64""
      TOXENV: ""py34""
      TOXPY34: ""%PYTHON%\\python.exe""

    - PYTHON: ""C:\\Python35-x64""
      PYTHON_VERSION: ""3.5.x""
      PYTHON_ARCH: ""64""
      TOXENV: ""py35""
      TOXPY35: ""%PYTHON%\\python.exe""

    - PYTHON: ""C:\\Python36-x64""
      PYTHON_VERSION: ""3.6.x""
      PYTHON_ARCH: ""64""
      TOXENV: ""py36""
      TOXPY36: ""%PYTHON%\\python.exe""

    - PYTHON: ""C:\\Python37-x64""
      PYTHON_VERSION: ""3.7.x""
      PYTHON_ARCH: ""64""
      TOXENV: ""py37""
      TOXPY37: ""%PYTHON%\\python.exe""

cache:
  - C:\Users\appveyor\AppData\Local\pip\Cache

install:
  # Install Python (from the official .msi of http://python.org) and pip when
  # not already installed.
  - ps: if (-not(Test-Path($env:PYTHON))) { & _appveyor\install.ps1 }

  # Prepend newly installed Python to the PATH of this build (this cannot be
  # done from inside the powershell script as it would require to restart
  # the parent CMD process).
  - SET PATH=%PYTHON%;%PYTHON%\\Scripts;%PATH%

  # Check that we have the expected version and architecture for Python
  - python --version
  - python -c ""import struct; print(struct.calcsize('P') * 8)""

  # Upgrade to the latest version of pip to avoid it displaying warnings
  # about it being out of date.
  - python -m pip install --upgrade pip wheel
  - pip install tox virtualenv

test_script:
  - tox

on_success:
  - .tox/%TOXENV%/Scripts/activate.bat
  - pip install codecov
  - codecov --env PLATFORM,TOXENV",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"  VAR: VAR VAR: VAR VAR: VAR: - VAR: ""VAR:\\VAR-VAR"" VAR: ""2.7.VAR"" VAR: ""64"" VAR: ""VAR"" VAR: ""%VAR%\\VAR.VAR"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.4.VAR"" VAR: ""64"" VAR: ""VAR"" VAR: ""%VAR%\\VAR.VAR"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.5.VAR"" VAR: ""64"" VAR: ""VAR"" VAR: ""%VAR%\\VAR.VAR"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.6.VAR"" VAR: ""64"" VAR: ""VAR"" VAR: ""%VAR%\\VAR.VAR"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.7.VAR"" VAR: ""64"" VAR: ""VAR"" VAR: ""%VAR%\\VAR.VAR"" VAR: - VAR:\VAR\VAR\VAR\VAR\VAR\VAR VAR:   - VAR: VAR (-VAR(VAR-VAR($VAR:VAR))) { & VAR\VAR.VAR }    - VAR VAR=%VAR%;%VAR%\\VAR;%VAR%  - VAR --VAR - VAR -VAR ""VAR VAR; VAR(VAR.VAR('VAR') * 8)""   - VAR -VAR VAR VAR --VAR VAR VAR - VAR VAR VAR VAR VAR: - VAR VAR: - .VAR/%VAR%/VAR/VAR.VAR - VAR VAR VAR - VAR --VAR VAR,VAR ",10,7
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,src/urllib3/util/ssl_.py,"from __future__ import absolute_import
import errno
import warnings
import hmac
import re

from binascii import hexlify, unhexlify
from hashlib import md5, sha1, sha256

from ..exceptions import SSLError, InsecurePlatformWarning, SNIMissingWarning
from ..packages import six
from ..packages.rfc3986 import abnf_regexp


SSLContext = None
HAS_SNI = False
IS_PYOPENSSL = False
IS_SECURETRANSPORT = False

# Maps the length of a digest to a possible hash function producing this digest
HASHFUNC_MAP = {
    32: md5,
    40: sha1,
    64: sha256,
}


def _const_compare_digest_backport(a, b):
    """"""
    Compare two digests of equal length in constant time.

    The digests must be of type str/bytes.
    Returns True if the digests match, and False otherwise.
    """"""
    result = abs(len(a) - len(b))
    for l, r in zip(bytearray(a), bytearray(b)):
        result |= l ^ r
    return result == 0


_const_compare_digest = getattr(hmac, 'compare_digest',
                                _const_compare_digest_backport)

# Borrow rfc3986's regular expressions for IPv4
# and IPv6 addresses for use in is_ipaddress()
_IP_ADDRESS_REGEX = re.compile(
    r'^(?:%s|%s|%s|%s)$' % (
        abnf_regexp.IPv4_RE,
        abnf_regexp.IPv6_RE,
        abnf_regexp.IPv6_ADDRZ_RE,
        abnf_regexp.IPv_FUTURE_RE
    )
)

try:  # Test for SSL features
    import ssl
    from ssl import wrap_socket, CERT_NONE, PROTOCOL_SSLv23
    from ssl import HAS_SNI  # Has SNI?
except ImportError:
    pass


try:
    from ssl import OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION
except ImportError:
    OP_NO_SSLv2, OP_NO_SSLv3 = 0x1000000, 0x2000000
    OP_NO_COMPRESSION = 0x20000


# A secure default.
# Sources for more information on TLS ciphers:
#
# - https://wiki.mozilla.org/Security/Server_Side_TLS
# - https://www.ssllabs.com/projects/best-practices/index.html
# - https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
#
# The general intent is:
# - Prefer TLS 1.3 cipher suites
# - prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),
# - prefer ECDHE over DHE for better performance,
# - prefer any AES-GCM and ChaCha20 over any AES-CBC for better performance and
#   security,
# - prefer AES-GCM over ChaCha20 because hardware-accelerated AES is common,
# - disable NULL authentication, MD5 MACs and DSS for security reasons.
DEFAULT_CIPHERS = ':'.join([
    'TLS13-AES-256-GCM-SHA384',
    'TLS13-CHACHA20-POLY1305-SHA256',
    'TLS13-AES-128-GCM-SHA256',
    'ECDH+AESGCM',
    'ECDH+CHACHA20',
    'DH+AESGCM',
    'DH+CHACHA20',
    'ECDH+AES256',
    'DH+AES256',
    'ECDH+AES128',
    'DH+AES',
    'RSA+AESGCM',
    'RSA+AES',
    '!aNULL',
    '!eNULL',
    '!MD5',
])

try:
    from ssl import SSLContext  # Modern SSL?
except ImportError:
    class SSLContext(object):  # Platform-specific: Python 2
        def __init__(self, protocol_version):
            self.protocol = protocol_version
            # Use default values from a real SSLContext
            self.check_hostname = False
            self.verify_mode = ssl.CERT_NONE
            self.ca_certs = None
            self.options = 0
            self.certfile = None
            self.keyfile = None
            self.ciphers = None

        def load_cert_chain(self, certfile, keyfile):
            self.certfile = certfile
            self.keyfile = keyfile

        def load_verify_locations(self, cafile=None, capath=None):
            self.ca_certs = cafile

            if capath is not None:
                raise SSLError(""CA directories not supported in older Pythons"")

        def set_ciphers(self, cipher_suite):
            self.ciphers = cipher_suite

        def wrap_socket(self, socket, server_hostname=None, server_side=False):
            warnings.warn(
                'A true SSLContext object is not available. This prevents '
                'urllib3 from configuring SSL appropriately and may cause '
                'certain SSL connections to fail. You can upgrade to a newer '
                'version of Python to solve this. For more information, see '
                'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
                '#ssl-warnings',
                InsecurePlatformWarning
            )
            kwargs = {
                'keyfile': self.keyfile,
                'certfile': self.certfile,
                'ca_certs': self.ca_certs,
                'cert_reqs': self.verify_mode,
                'ssl_version': self.protocol,
                'server_side': server_side,
            }
            return wrap_socket(socket, ciphers=self.ciphers, **kwargs)


def assert_fingerprint(cert, fingerprint):
    """"""
    Checks if given fingerprint matches the supplied certificate.

    :param cert:
        Certificate as bytes object.
    :param fingerprint:
        Fingerprint as string of hexdigits, can be interspersed by colons.
    """"""

    fingerprint = fingerprint.replace(':', '').lower()
    digest_length = len(fingerprint)
    hashfunc = HASHFUNC_MAP.get(digest_length)
    if not hashfunc:
        raise SSLError(
            'Fingerprint of invalid length: {0}'.format(fingerprint))

    # We need encode() here for py32; works on py2 and p33.
    fingerprint_bytes = unhexlify(fingerprint.encode())

    cert_digest = hashfunc(cert).digest()

    if not _const_compare_digest(cert_digest, fingerprint_bytes):
        raise SSLError('Fingerprints did not match. Expected ""{0}"", got ""{1}"".'
                       .format(fingerprint, hexlify(cert_digest)))


def resolve_cert_reqs(candidate):
    """"""
    Resolves the argument to a numeric constant, which can be passed to
    the wrap_socket function/method from the ssl module.
    Defaults to :data:`ssl.CERT_NONE`.
    If given a string it is assumed to be the name of the constant in the
    :mod:`ssl` module or its abbreviation.
    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.
    If it's neither `None` nor a string we assume it is already the numeric
    constant which can directly be passed to wrap_socket.
    """"""
    if candidate is None:
        return CERT_NONE

    if isinstance(candidate, str):
        res = getattr(ssl, candidate, None)
        if res is None:
            res = getattr(ssl, 'CERT_' + candidate)
        return res

    return candidate


def resolve_ssl_version(candidate):
    """"""
    like resolve_cert_reqs
    """"""
    if candidate is None:
        return PROTOCOL_SSLv23

    if isinstance(candidate, str):
        res = getattr(ssl, candidate, None)
        if res is None:
            res = getattr(ssl, 'PROTOCOL_' + candidate)
        return res

    return candidate


def create_urllib3_context(ssl_version=None, cert_reqs=None,
                           options=None, ciphers=None):
    """"""All arguments have the same meaning as ``ssl_wrap_socket``.

    By default, this function does a lot of the same work that
    ``ssl.create_default_context`` does on Python 3.4+. It:

    - Disables SSLv2, SSLv3, and compression
    - Sets a restricted set of server ciphers

    If you wish to enable SSLv3, you can do::

        from urllib3.util import ssl_
        context = ssl_.create_urllib3_context()
        context.options &= ~ssl_.OP_NO_SSLv3

    You can do the same to enable compression (substituting ``COMPRESSION``
    for ``SSLv3`` in the last line above).

    :param ssl_version:
        The desired protocol version to use. This will default to
        PROTOCOL_SSLv23 which will negotiate the highest protocol that both
        the server and your installation of OpenSSL support.
    :param cert_reqs:
        Whether to require the certificate verification. This defaults to
        ``ssl.CERT_REQUIRED``.
    :param options:
        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,
        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``.
    :param ciphers:
        Which cipher suites to allow the server to select.
    :returns:
        Constructed SSLContext object with specified options
    :rtype: SSLContext
    """"""
    context = SSLContext(ssl_version or ssl.PROTOCOL_SSLv23)

    context.set_ciphers(ciphers or DEFAULT_CIPHERS)

    # Setting the default here, as we may have no ssl module on import
    cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs

    if options is None:
        options = 0
        # SSLv2 is easily broken and is considered harmful and dangerous
        options |= OP_NO_SSLv2
        # SSLv3 has several problems and is now dangerous
        options |= OP_NO_SSLv3
        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+
        # (issue #309)
        options |= OP_NO_COMPRESSION

    context.options |= options

    context.verify_mode = cert_reqs
    if getattr(context, 'check_hostname', None) is not None:  # Platform-specific: Python 3.2
        # We do our own verification, including fingerprints and alternative
        # hostnames. So disable it here
        context.check_hostname = False
    return context


def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,
                    ca_certs=None, server_hostname=None,
                    ssl_version=None, ciphers=None, ssl_context=None,
                    ca_cert_dir=None):
    """"""
    All arguments except for server_hostname, ssl_context, and ca_cert_dir have
    the same meaning as they do when using :func:`ssl.wrap_socket`.

    :param server_hostname:
        When SNI is supported, the expected hostname of the certificate
    :param ssl_context:
        A pre-made :class:`SSLContext` object. If none is provided, one will
        be created using :func:`create_urllib3_context`.
    :param ciphers:
        A string of ciphers we wish the client to support.
    :param ca_cert_dir:
        A directory containing CA certificates in multiple separate files, as
        supported by OpenSSL's -CApath flag or the capath argument to
        SSLContext.load_verify_locations().
    """"""
    context = ssl_context
    if context is None:
        # Note: This branch of code and all the variables in it are no longer
        # used by urllib3 itself. We should consider deprecating and removing
        # this code.
        context = create_urllib3_context(ssl_version, cert_reqs,
                                         ciphers=ciphers)

    if ca_certs or ca_cert_dir:
        try:
            context.load_verify_locations(ca_certs, ca_cert_dir)
        except IOError as e:  # Platform-specific: Python 2.7
            raise SSLError(e)
        # Py33 raises FileNotFoundError which subclasses OSError
        # These are not equivalent unless we check the errno attribute
        except OSError as e:  # Platform-specific: Python 3.3 and beyond
            if e.errno == errno.ENOENT:
                raise SSLError(e)
            raise
    elif getattr(context, 'load_default_certs', None) is not None:
        # try to load OS default certs; works well on Windows (require Python3.4+)
        context.load_default_certs()

    if certfile:
        context.load_cert_chain(certfile, keyfile)

    # If we detect server_hostname is an IP address then the SNI
    # extension should not be used according to RFC3546 Section 3.1
    # We shouldn't warn the user if SNI isn't available but we would
    # not be using SNI anyways due to IP address for server_hostname.
    if ((server_hostname is not None and not is_ipaddress(server_hostname))
            or IS_SECURETRANSPORT):
        if HAS_SNI and server_hostname is not None:
            return context.wrap_socket(sock, server_hostname=server_hostname)

        warnings.warn(
            'An HTTPS request has been made, but the SNI (Server Name '
            'Indication) extension to TLS is not available on this platform. '
            'This may cause the server to present an incorrect TLS '
            'certificate, which can cause validation failures. You can upgrade to '
            'a newer version of Python to solve this. For more information, see '
            'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
            '#ssl-warnings',
            SNIMissingWarning
        )

    return context.wrap_socket(sock)


def is_ipaddress(hostname):
    """"""Detects whether the hostname given is an IP address.

    :param str hostname: Hostname to examine.
    :return: True if the hostname is an IP address, False otherwise.
    """"""
    if six.PY3 and isinstance(hostname, bytes):
        # IDN A-label bytes are ASCII compatible.
        hostname = hostname.decode('ascii')

    return _IP_ADDRESS_REGEX.match(hostname) is not None",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR, VAR VAR ..VAR VAR VAR, VAR, VAR VAR ..VAR VAR VAR VAR ..VAR.VAR VAR VAR VAR = VAR VAR = VAR VAR = VAR VAR = VAR  VAR = { 32: VAR, 40: VAR, 64: VAR, } VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR/VAR. VAR VAR VAR VAR VAR VAR, VAR VAR VAR. """""" VAR = VAR(VAR(VAR) - VAR(VAR)) VAR VAR, VAR VAR VAR(VAR(VAR), VAR(VAR)): VAR |= VAR ^ VAR VAR VAR == 0 VAR = VAR(VAR, 'VAR', VAR)   VAR = VAR.VAR( VAR'^(?:%VAR|%VAR|%VAR|%VAR)$' % ( VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR ) ) VAR:  VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR  VAR VAR: VAR VAR: VAR VAR VAR VAR, VAR, VAR VAR VAR: VAR, VAR = 0x1000000, 0x2000000 VAR = 0x20000                VAR = ':'.VAR([ 'VAR-VAR-256-VAR-VAR', 'VAR-VAR-VAR-VAR', 'VAR-VAR-128-VAR-VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', '!VAR', '!VAR', '!VAR', ]) VAR: VAR VAR VAR VAR  VAR VAR: VAR VAR(VAR):  VAR VAR(VAR, VAR): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR.VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): VAR.VAR = VAR VAR VAR VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR, VAR): VAR.VAR = VAR VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): VAR.VAR( 'VAR VAR VAR VAR VAR VAR VAR. VAR VAR ' 'VAR VAR VAR VAR VAR VAR VAR VAR ' 'VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR ' 'VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR ' 'VAR: ' VAR ) VAR = { 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR, } VAR VAR(VAR, VAR=VAR.VAR, **VAR) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(':', '').VAR() VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR VAR: VAR VAR( 'VAR VAR VAR VAR: {0}'.VAR(VAR))  VAR = VAR(VAR.VAR()) VAR = VAR(VAR).VAR() VAR VAR VAR(VAR, VAR): VAR VAR('VAR VAR VAR VAR. VAR ""{0}"", VAR ""{1}"".' .VAR(VAR, VAR(VAR))) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR VAR VAR. VAR VAR :VAR:`VAR.VAR`. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR. (VAR VAR VAR VAR `VAR` VAR VAR `VAR`. VAR VAR'VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR VAR VAR: VAR VAR VAR VAR(VAR, VAR): VAR = VAR(VAR, VAR, VAR) VAR VAR VAR VAR: VAR = VAR(VAR, 'VAR' + VAR) VAR VAR VAR VAR VAR VAR(VAR): """""" VAR VAR """""" VAR VAR VAR VAR: VAR VAR VAR VAR(VAR, VAR): VAR = VAR(VAR, VAR, VAR) VAR VAR VAR VAR: VAR = VAR(VAR, 'VAR' + VAR) VAR VAR VAR VAR VAR VAR(VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): """"""VAR VAR VAR VAR VAR VAR VAR ``VAR``. VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR.VAR`` VAR VAR VAR 3.4+. VAR: - VAR VAR, VAR, VAR VAR - VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR:: VAR VAR.VAR VAR VAR VAR = VAR.VAR() VAR.VAR &= ~VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR ``VAR`` VAR ``VAR`` VAR VAR VAR VAR VAR). :VAR VAR: VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR. VAR VAR VAR ``VAR.VAR``. :VAR VAR: VAR VAR VAR. VAR VAR VAR ``VAR.VAR``, ``VAR.VAR``, ``VAR.VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR :VAR: VAR """""" VAR = VAR(VAR VAR VAR.VAR) VAR.VAR(VAR VAR VAR)  VAR = VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR = 0  VAR |= VAR  VAR |= VAR   VAR |= VAR VAR.VAR |= VAR VAR.VAR = VAR VAR VAR(VAR, 'VAR', VAR) VAR VAR VAR:    VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR`. :VAR VAR: VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR :VAR VAR: VAR VAR-VAR :VAR:`VAR` VAR. VAR VAR VAR VAR, VAR VAR VAR VAR VAR :VAR:`VAR`. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR'VAR -VAR VAR VAR VAR VAR VAR VAR VAR.VAR(). """""" VAR = VAR VAR VAR VAR VAR:    VAR = VAR(VAR, VAR, VAR=VAR) VAR VAR VAR VAR: VAR: VAR.VAR(VAR, VAR) VAR VAR VAR VAR:  VAR VAR(VAR)   VAR VAR VAR VAR:  VAR VAR.VAR == VAR.VAR: VAR VAR(VAR) VAR VAR VAR(VAR, 'VAR', VAR) VAR VAR VAR:  VAR.VAR() VAR VAR: VAR.VAR(VAR, VAR)     VAR ((VAR VAR VAR VAR VAR VAR VAR(VAR)) VAR VAR): VAR VAR VAR VAR VAR VAR VAR: VAR VAR.VAR(VAR, VAR=VAR) VAR.VAR( 'VAR VAR VAR VAR VAR VAR, VAR VAR VAR (VAR VAR ' 'VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR. ' 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ' 'VAR, VAR VAR VAR VAR VAR. VAR VAR VAR VAR ' 'VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR ' 'VAR: ' VAR ) VAR VAR.VAR(VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR VAR: VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR. """""" VAR VAR.VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR('VAR') VAR VAR.VAR(VAR) VAR VAR VAR ",0,7
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,src/urllib3/util/ssl_.py,"from __future__ import absolute_import

import hmac
import os
import sys
import warnings
from binascii import hexlify, unhexlify
from hashlib import md5, sha1, sha256

from ..exceptions import (
    InsecurePlatformWarning,
    ProxySchemeUnsupported,
    SNIMissingWarning,
    SSLError,
)
from ..packages import six
from .url import BRACELESS_IPV6_ADDRZ_RE, IPV4_RE

SSLContext = None
SSLTransport = None
HAS_SNI = False
IS_PYOPENSSL = False
IS_SECURETRANSPORT = False
ALPN_PROTOCOLS = [""http/1.1""]

# Maps the length of a digest to a possible hash function producing this digest
HASHFUNC_MAP = {32: md5, 40: sha1, 64: sha256}


def _const_compare_digest_backport(a, b):
    """"""
    Compare two digests of equal length in constant time.

    The digests must be of type str/bytes.
    Returns True if the digests match, and False otherwise.
    """"""
    result = abs(len(a) - len(b))
    for left, right in zip(bytearray(a), bytearray(b)):
        result |= left ^ right
    return result == 0


_const_compare_digest = getattr(hmac, ""compare_digest"", _const_compare_digest_backport)

try:  # Test for SSL features
    import ssl
    from ssl import CERT_REQUIRED, wrap_socket
except ImportError:
    pass

try:
    from ssl import HAS_SNI  # Has SNI?
except ImportError:
    pass

try:
    from .ssltransport import SSLTransport
except ImportError:
    pass


try:  # Platform-specific: Python 3.6
    from ssl import PROTOCOL_TLS

    PROTOCOL_SSLv23 = PROTOCOL_TLS
except ImportError:
    try:
        from ssl import PROTOCOL_SSLv23 as PROTOCOL_TLS

        PROTOCOL_SSLv23 = PROTOCOL_TLS
    except ImportError:
        PROTOCOL_SSLv23 = PROTOCOL_TLS = 2

try:
    from ssl import PROTOCOL_TLS_CLIENT
except ImportError:
    PROTOCOL_TLS_CLIENT = PROTOCOL_TLS


try:
    from ssl import OP_NO_COMPRESSION, OP_NO_SSLv2, OP_NO_SSLv3
except ImportError:
    OP_NO_SSLv2, OP_NO_SSLv3 = 0x1000000, 0x2000000
    OP_NO_COMPRESSION = 0x20000


try:  # OP_NO_TICKET was added in Python 3.6
    from ssl import OP_NO_TICKET
except ImportError:
    OP_NO_TICKET = 0x4000


# A secure default.
# Sources for more information on TLS ciphers:
#
# - https://wiki.mozilla.org/Security/Server_Side_TLS
# - https://www.ssllabs.com/projects/best-practices/index.html
# - https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
#
# The general intent is:
# - prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),
# - prefer ECDHE over DHE for better performance,
# - prefer any AES-GCM and ChaCha20 over any AES-CBC for better performance and
#   security,
# - prefer AES-GCM over ChaCha20 because hardware-accelerated AES is common,
# - disable NULL authentication, MD5 MACs, DSS, and other
#   insecure ciphers for security reasons.
# - NOTE: TLS 1.3 cipher suites are managed through a different interface
#   not exposed by CPython (yet!) and are enabled by default if they're available.
DEFAULT_CIPHERS = "":"".join(
    [
        ""ECDHE+AESGCM"",
        ""ECDHE+CHACHA20"",
        ""DHE+AESGCM"",
        ""DHE+CHACHA20"",
        ""ECDH+AESGCM"",
        ""DH+AESGCM"",
        ""ECDH+AES"",
        ""DH+AES"",
        ""RSA+AESGCM"",
        ""RSA+AES"",
        ""!aNULL"",
        ""!eNULL"",
        ""!MD5"",
        ""!DSS"",
    ]
)

try:
    from ssl import SSLContext  # Modern SSL?
except ImportError:

    class SSLContext(object):  # Platform-specific: Python 2
        def __init__(self, protocol_version):
            self.protocol = protocol_version
            # Use default values from a real SSLContext
            self.check_hostname = False
            self.verify_mode = ssl.CERT_NONE
            self.ca_certs = None
            self.options = 0
            self.certfile = None
            self.keyfile = None
            self.ciphers = None

        def load_cert_chain(self, certfile, keyfile):
            self.certfile = certfile
            self.keyfile = keyfile

        def load_verify_locations(self, cafile=None, capath=None, cadata=None):
            self.ca_certs = cafile

            if capath is not None:
                raise SSLError(""CA directories not supported in older Pythons"")

            if cadata is not None:
                raise SSLError(""CA data not supported in older Pythons"")

        def set_ciphers(self, cipher_suite):
            self.ciphers = cipher_suite

        def wrap_socket(self, socket, server_hostname=None, server_side=False):
            warnings.warn(
                ""A true SSLContext object is not available. This prevents ""
                ""urllib3 from configuring SSL appropriately and may cause ""
                ""certain SSL connections to fail. You can upgrade to a newer ""
                ""version of Python to solve this. For more information, see ""
                ""https://urllib3.readthedocs.io/en/latest/advanced-usage.html""
                ""#ssl-warnings"",
                InsecurePlatformWarning,
            )
            kwargs = {
                ""keyfile"": self.keyfile,
                ""certfile"": self.certfile,
                ""ca_certs"": self.ca_certs,
                ""cert_reqs"": self.verify_mode,
                ""ssl_version"": self.protocol,
                ""server_side"": server_side,
            }
            return wrap_socket(socket, ciphers=self.ciphers, **kwargs)


def assert_fingerprint(cert, fingerprint):
    """"""
    Checks if given fingerprint matches the supplied certificate.

    :param cert:
        Certificate as bytes object.
    :param fingerprint:
        Fingerprint as string of hexdigits, can be interspersed by colons.
    """"""

    fingerprint = fingerprint.replace("":"", """").lower()
    digest_length = len(fingerprint)
    hashfunc = HASHFUNC_MAP.get(digest_length)
    if not hashfunc:
        raise SSLError(""Fingerprint of invalid length: {0}"".format(fingerprint))

    # We need encode() here for py32; works on py2 and p33.
    fingerprint_bytes = unhexlify(fingerprint.encode())

    cert_digest = hashfunc(cert).digest()

    if not _const_compare_digest(cert_digest, fingerprint_bytes):
        raise SSLError(
            'Fingerprints did not match. Expected ""{0}"", got ""{1}"".'.format(
                fingerprint, hexlify(cert_digest)
            )
        )


def resolve_cert_reqs(candidate):
    """"""
    Resolves the argument to a numeric constant, which can be passed to
    the wrap_socket function/method from the ssl module.
    Defaults to :data:`ssl.CERT_REQUIRED`.
    If given a string it is assumed to be the name of the constant in the
    :mod:`ssl` module or its abbreviation.
    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.
    If it's neither `None` nor a string we assume it is already the numeric
    constant which can directly be passed to wrap_socket.
    """"""
    if candidate is None:
        return CERT_REQUIRED

    if isinstance(candidate, str):
        res = getattr(ssl, candidate, None)
        if res is None:
            res = getattr(ssl, ""CERT_"" + candidate)
        return res

    return candidate


def resolve_ssl_version(candidate):
    """"""
    like resolve_cert_reqs
    """"""
    if candidate is None:
        return PROTOCOL_TLS

    if isinstance(candidate, str):
        res = getattr(ssl, candidate, None)
        if res is None:
            res = getattr(ssl, ""PROTOCOL_"" + candidate)
        return res

    return candidate


def create_urllib3_context(
    ssl_version=None, cert_reqs=None, options=None, ciphers=None
):
    """"""All arguments have the same meaning as ``ssl_wrap_socket``.

    By default, this function does a lot of the same work that
    ``ssl.create_default_context`` does on Python 3.4+. It:

    - Disables SSLv2, SSLv3, and compression
    - Sets a restricted set of server ciphers

    If you wish to enable SSLv3, you can do::

        from urllib3.util import ssl_
        context = ssl_.create_urllib3_context()
        context.options &= ~ssl_.OP_NO_SSLv3

    You can do the same to enable compression (substituting ``COMPRESSION``
    for ``SSLv3`` in the last line above).

    :param ssl_version:
        The desired protocol version to use. This will default to
        PROTOCOL_SSLv23 which will negotiate the highest protocol that both
        the server and your installation of OpenSSL support.
    :param cert_reqs:
        Whether to require the certificate verification. This defaults to
        ``ssl.CERT_REQUIRED``.
    :param options:
        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,
        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``, and ``ssl.OP_NO_TICKET``.
    :param ciphers:
        Which cipher suites to allow the server to select.
    :returns:
        Constructed SSLContext object with specified options
    :rtype: SSLContext
    """"""
    # PROTOCOL_TLS is deprecated in Python 3.10
    if not ssl_version or ssl_version == PROTOCOL_TLS:
        ssl_version = PROTOCOL_TLS_CLIENT

    context = SSLContext(ssl_version)

    context.set_ciphers(ciphers or DEFAULT_CIPHERS)

    # Setting the default here, as we may have no ssl module on import
    cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs

    if options is None:
        options = 0
        # SSLv2 is easily broken and is considered harmful and dangerous
        options |= OP_NO_SSLv2
        # SSLv3 has several problems and is now dangerous
        options |= OP_NO_SSLv3
        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+
        # (issue #309)
        options |= OP_NO_COMPRESSION
        # TLSv1.2 only. Unless set explicitly, do not request tickets.
        # This may save some bandwidth on wire, and although the ticket is encrypted,
        # there is a risk associated with it being on wire,
        # if the server is not rotating its ticketing keys properly.
        options |= OP_NO_TICKET

    context.options |= options

    # Enable post-handshake authentication for TLS 1.3, see GH #1634. PHA is
    # necessary for conditional client cert authentication with TLS 1.3.
    # The attribute is None for OpenSSL <= 1.1.0 or does not exist in older
    # versions of Python.  We only enable on Python 3.7.4+ or if certificate
    # verification is enabled to work around Python issue #37428
    # See: https://bugs.python.org/issue37428
    if (cert_reqs == ssl.CERT_REQUIRED or sys.version_info >= (3, 7, 4)) and getattr(
        context, ""post_handshake_auth"", None
    ) is not None:
        context.post_handshake_auth = True

    def disable_check_hostname():
        if (
            getattr(context, ""check_hostname"", None) is not None
        ):  # Platform-specific: Python 3.2
            # We do our own verification, including fingerprints and alternative
            # hostnames. So disable it here
            context.check_hostname = False

    # The order of the below lines setting verify_mode and check_hostname
    # matter due to safe-guards SSLContext has to prevent an SSLContext with
    # check_hostname=True, verify_mode=NONE/OPTIONAL. This is made even more
    # complex because we don't know whether PROTOCOL_TLS_CLIENT will be used
    # or not so we don't know the initial state of the freshly created SSLContext.
    if cert_reqs == ssl.CERT_REQUIRED:
        context.verify_mode = cert_reqs
        disable_check_hostname()
    else:
        disable_check_hostname()
        context.verify_mode = cert_reqs

    # Enable logging of TLS session keys via defacto standard environment variable
    # 'SSLKEYLOGFILE', if the feature is available (Python 3.8+). Skip empty values.
    if hasattr(context, ""keylog_filename""):
        sslkeylogfile = os.environ.get(""SSLKEYLOGFILE"")
        if sslkeylogfile:
            context.keylog_filename = sslkeylogfile

    return context


def ssl_wrap_socket(
    sock,
    keyfile=None,
    certfile=None,
    cert_reqs=None,
    ca_certs=None,
    server_hostname=None,
    ssl_version=None,
    ciphers=None,
    ssl_context=None,
    ca_cert_dir=None,
    key_password=None,
    ca_cert_data=None,
    tls_in_tls=False,
):
    """"""
    All arguments except for server_hostname, ssl_context, and ca_cert_dir have
    the same meaning as they do when using :func:`ssl.wrap_socket`.

    :param server_hostname:
        When SNI is supported, the expected hostname of the certificate
    :param ssl_context:
        A pre-made :class:`SSLContext` object. If none is provided, one will
        be created using :func:`create_urllib3_context`.
    :param ciphers:
        A string of ciphers we wish the client to support.
    :param ca_cert_dir:
        A directory containing CA certificates in multiple separate files, as
        supported by OpenSSL's -CApath flag or the capath argument to
        SSLContext.load_verify_locations().
    :param key_password:
        Optional password if the keyfile is encrypted.
    :param ca_cert_data:
        Optional string containing CA certificates in PEM format suitable for
        passing as the cadata parameter to SSLContext.load_verify_locations()
    :param tls_in_tls:
        Use SSLTransport to wrap the existing socket.
    """"""
    context = ssl_context
    if context is None:
        # Note: This branch of code and all the variables in it are no longer
        # used by urllib3 itself. We should consider deprecating and removing
        # this code.
        context = create_urllib3_context(ssl_version, cert_reqs, ciphers=ciphers)

    if ca_certs or ca_cert_dir or ca_cert_data:
        try:
            context.load_verify_locations(ca_certs, ca_cert_dir, ca_cert_data)
        except (IOError, OSError) as e:
            raise SSLError(e)

    elif ssl_context is None and hasattr(context, ""load_default_certs""):
        # try to load OS default certs; works well on Windows (require Python3.4+)
        context.load_default_certs()

    # Attempt to detect if we get the goofy behavior of the
    # keyfile being encrypted and OpenSSL asking for the
    # passphrase via the terminal and instead error out.
    if keyfile and key_password is None and _is_key_file_encrypted(keyfile):
        raise SSLError(""Client private key is encrypted, password is required"")

    if certfile:
        if key_password is None:
            context.load_cert_chain(certfile, keyfile)
        else:
            context.load_cert_chain(certfile, keyfile, key_password)

    try:
        if hasattr(context, ""set_alpn_protocols""):
            context.set_alpn_protocols(ALPN_PROTOCOLS)
    except NotImplementedError:
        pass

    # If we detect server_hostname is an IP address then the SNI
    # extension should not be used according to RFC3546 Section 3.1
    use_sni_hostname = server_hostname and not is_ipaddress(server_hostname)
    # SecureTransport uses server_hostname in certificate verification.
    send_sni = (use_sni_hostname and HAS_SNI) or (
        IS_SECURETRANSPORT and server_hostname
    )
    # Do not warn the user if server_hostname is an invalid SNI hostname.
    if not HAS_SNI and use_sni_hostname:
        warnings.warn(
            ""An HTTPS request has been made, but the SNI (Server Name ""
            ""Indication) extension to TLS is not available on this platform. ""
            ""This may cause the server to present an incorrect TLS ""
            ""certificate, which can cause validation failures. You can upgrade to ""
            ""a newer version of Python to solve this. For more information, see ""
            ""https://urllib3.readthedocs.io/en/latest/advanced-usage.html""
            ""#ssl-warnings"",
            SNIMissingWarning,
        )

    if send_sni:
        ssl_sock = _ssl_wrap_socket_impl(
            sock, context, tls_in_tls, server_hostname=server_hostname
        )
    else:
        ssl_sock = _ssl_wrap_socket_impl(sock, context, tls_in_tls)
    return ssl_sock


def is_ipaddress(hostname):
    """"""Detects whether the hostname given is an IPv4 or IPv6 address.
    Also detects IPv6 addresses with Zone IDs.

    :param str hostname: Hostname to examine.
    :return: True if the hostname is an IP address, False otherwise.
    """"""
    if not six.PY2 and isinstance(hostname, bytes):
        # IDN A-label bytes are ASCII compatible.
        hostname = hostname.decode(""ascii"")
    return bool(IPV4_RE.match(hostname) or BRACELESS_IPV6_ADDRZ_RE.match(hostname))


def _is_key_file_encrypted(key_file):
    """"""Detects if a key file is encrypted or not.""""""
    with open(key_file, ""r"") as f:
        for line in f:
            # Look for Proc-Type: 4,ENCRYPTED
            if ""ENCRYPTED"" in line:
                return True

    return False


def _ssl_wrap_socket_impl(sock, ssl_context, tls_in_tls, server_hostname=None):
    if tls_in_tls:
        if not SSLTransport:
            # Import error, ssl is not available.
            raise ProxySchemeUnsupported(
                ""TLS in TLS requires support for the 'ssl' module""
            )

        SSLTransport._validate_ssl_context_for_tls_in_tls(ssl_context)
        return SSLTransport(sock, ssl_context, server_hostname)

    if server_hostname:
        return ssl_context.wrap_socket(sock, server_hostname=server_hostname)
    else:
        return ssl_context.wrap_socket(sock)",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR, VAR VAR ..VAR VAR ( VAR, VAR, VAR, VAR, ) VAR ..VAR VAR VAR VAR .VAR VAR VAR, VAR VAR = VAR VAR = VAR VAR = VAR VAR = VAR VAR = VAR VAR = [""VAR/1.1""]  VAR = {32: VAR, 40: VAR, 64: VAR} VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR/VAR. VAR VAR VAR VAR VAR VAR, VAR VAR VAR. """""" VAR = VAR(VAR(VAR) - VAR(VAR)) VAR VAR, VAR VAR VAR(VAR(VAR), VAR(VAR)): VAR |= VAR ^ VAR VAR VAR == 0 VAR = VAR(VAR, ""VAR"", VAR) VAR:  VAR VAR VAR VAR VAR VAR, VAR VAR VAR: VAR VAR: VAR VAR VAR VAR  VAR VAR: VAR VAR: VAR .VAR VAR VAR VAR VAR: VAR VAR:  VAR VAR VAR VAR VAR = VAR VAR VAR: VAR: VAR VAR VAR VAR VAR VAR VAR = VAR VAR VAR: VAR = VAR = 2 VAR: VAR VAR VAR VAR VAR VAR: VAR = VAR VAR: VAR VAR VAR VAR, VAR, VAR VAR VAR: VAR, VAR = 0x1000000, 0x2000000 VAR = 0x20000 VAR:  VAR VAR VAR VAR VAR VAR: VAR = 0x4000                  VAR = "":"".VAR( [ ""VAR+VAR"", ""VAR+VAR"", ""VAR+VAR"", ""VAR+VAR"", ""VAR+VAR"", ""VAR+VAR"", ""VAR+VAR"", ""VAR+VAR"", ""VAR+VAR"", ""VAR+VAR"", ""!VAR"", ""!VAR"", ""!VAR"", ""!VAR"", ] ) VAR: VAR VAR VAR VAR  VAR VAR: VAR VAR(VAR):  VAR VAR(VAR, VAR): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR.VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR): VAR.VAR = VAR VAR VAR VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR"") VAR VAR VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR, VAR): VAR.VAR = VAR VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): VAR.VAR( ""VAR VAR VAR VAR VAR VAR VAR. VAR VAR "" ""VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR "" ""VAR: "" VAR, ) VAR = { ""VAR"": VAR.VAR, ""VAR"": VAR.VAR, ""VAR"": VAR.VAR, ""VAR"": VAR.VAR, ""VAR"": VAR.VAR, ""VAR"": VAR, } VAR VAR(VAR, VAR=VAR.VAR, **VAR) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR("":"", """").VAR() VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR: {0}"".VAR(VAR))  VAR = VAR(VAR.VAR()) VAR = VAR(VAR).VAR() VAR VAR VAR(VAR, VAR): VAR VAR( 'VAR VAR VAR VAR. VAR ""{0}"", VAR ""{1}"".'.VAR( VAR, VAR(VAR) ) ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR VAR VAR. VAR VAR :VAR:`VAR.VAR`. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR. (VAR VAR VAR VAR `VAR` VAR VAR `VAR`. VAR VAR'VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR VAR VAR: VAR VAR VAR VAR(VAR, VAR): VAR = VAR(VAR, VAR, VAR) VAR VAR VAR VAR: VAR = VAR(VAR, ""VAR"" + VAR) VAR VAR VAR VAR VAR VAR(VAR): """""" VAR VAR """""" VAR VAR VAR VAR: VAR VAR VAR VAR(VAR, VAR): VAR = VAR(VAR, VAR, VAR) VAR VAR VAR VAR: VAR = VAR(VAR, ""VAR"" + VAR) VAR VAR VAR VAR VAR VAR( VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR ): """"""VAR VAR VAR VAR VAR VAR VAR ``VAR``. VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR.VAR`` VAR VAR VAR 3.4+. VAR: - VAR VAR, VAR, VAR VAR - VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR:: VAR VAR.VAR VAR VAR VAR = VAR.VAR() VAR.VAR &= ~VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR ``VAR`` VAR ``VAR`` VAR VAR VAR VAR VAR). :VAR VAR: VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR. VAR VAR VAR ``VAR.VAR``. :VAR VAR: VAR VAR VAR. VAR VAR VAR ``VAR.VAR``, ``VAR.VAR``, ``VAR.VAR``, VAR ``VAR.VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR :VAR: VAR """"""  VAR VAR VAR VAR VAR == VAR: VAR = VAR VAR = VAR(VAR) VAR.VAR(VAR VAR VAR)  VAR = VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR = 0  VAR |= VAR  VAR |= VAR   VAR |= VAR     VAR |= VAR VAR.VAR |= VAR       VAR (VAR == VAR.VAR VAR VAR.VAR >= (3, 7, 4)) VAR VAR( VAR, ""VAR"", VAR ) VAR VAR VAR: VAR.VAR = VAR VAR VAR(): VAR ( VAR(VAR, ""VAR"", VAR) VAR VAR VAR ):    VAR.VAR = VAR      VAR VAR == VAR.VAR: VAR.VAR = VAR VAR() VAR: VAR() VAR.VAR = VAR   VAR VAR(VAR, ""VAR""): VAR = VAR.VAR.VAR(""VAR"") VAR VAR: VAR.VAR = VAR VAR VAR VAR VAR( VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, ): """""" VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR`. :VAR VAR: VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR :VAR VAR: VAR VAR-VAR :VAR:`VAR` VAR. VAR VAR VAR VAR, VAR VAR VAR VAR VAR :VAR:`VAR`. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR'VAR -VAR VAR VAR VAR VAR VAR VAR VAR.VAR(). :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR() :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR VAR VAR VAR VAR:    VAR = VAR(VAR, VAR, VAR=VAR) VAR VAR VAR VAR VAR VAR: VAR: VAR.VAR(VAR, VAR, VAR) VAR (VAR, VAR) VAR VAR: VAR VAR(VAR) VAR VAR VAR VAR VAR VAR(VAR, ""VAR""):  VAR.VAR()    VAR VAR VAR VAR VAR VAR VAR VAR(VAR): VAR VAR(""VAR VAR VAR VAR VAR, VAR VAR VAR"") VAR VAR: VAR VAR VAR VAR: VAR.VAR(VAR, VAR) VAR: VAR.VAR(VAR, VAR, VAR) VAR: VAR VAR(VAR, ""VAR""): VAR.VAR(VAR) VAR VAR: VAR   VAR = VAR VAR VAR VAR(VAR)  VAR = (VAR VAR VAR) VAR ( VAR VAR VAR )  VAR VAR VAR VAR VAR: VAR.VAR( ""VAR VAR VAR VAR VAR VAR, VAR VAR VAR (VAR VAR "" ""VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR. "" ""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR "" ""VAR, VAR VAR VAR VAR VAR. VAR VAR VAR VAR "" ""VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR "" ""VAR: "" VAR, ) VAR VAR: VAR = VAR( VAR, VAR, VAR, VAR=VAR ) VAR: VAR = VAR(VAR, VAR, VAR) VAR VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR. :VAR VAR VAR: VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR. """""" VAR VAR VAR.VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR(""VAR"") VAR VAR(VAR.VAR(VAR) VAR VAR.VAR(VAR)) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR(VAR, ""VAR"") VAR VAR: VAR VAR VAR VAR:  VAR ""VAR"" VAR VAR: VAR VAR VAR VAR VAR VAR(VAR, VAR, VAR, VAR=VAR): VAR VAR: VAR VAR VAR:  VAR VAR( ""VAR VAR VAR VAR VAR VAR VAR 'VAR' VAR"" ) VAR.VAR(VAR) VAR VAR(VAR, VAR, VAR) VAR VAR: VAR VAR.VAR(VAR, VAR=VAR) VAR: VAR VAR.VAR(VAR) ",0,7
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,appveyor.yml,"# AppVeyor.yml from https://github.com/ogrisel/python-appveyor-demo
# License: CC0 1.0 Universal: http://creativecommons.org/publicdomain/zero/1.0/

skip_branch_with_pr: true
build: off

environment:

  matrix:
    - PYTHON: ""C:\\Python27-x64""
      PYTHON_VERSION: ""2.7.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-2.7""

    - PYTHON: ""C:\\Python34-x64""
      PYTHON_VERSION: ""3.4.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.4""

    - PYTHON: ""C:\\Python35-x64""
      PYTHON_VERSION: ""3.5.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.5""

    - PYTHON: ""C:\\Python36-x64""
      PYTHON_VERSION: ""3.6.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.6""

    - PYTHON: ""C:\\Python37-x64""
      PYTHON_VERSION: ""3.7.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.7""

cache:
  - C:\Users\appveyor\AppData\Local\pip\Cache

install:
  # Install Python (from the official .msi of http://python.org) and pip when
  # not already installed.
  - ps: if (-not(Test-Path($env:PYTHON))) { & _appveyor\install.ps1 }

  # Prepend newly installed Python to the PATH of this build (this cannot be
  # done from inside the powershell script as it would require to restart
  # the parent CMD process).
  - SET PATH=%PYTHON%;%PYTHON%\\Scripts;%PATH%

  # Upgrade to the latest version of pip to avoid it displaying warnings
  # about it being out of date.
  - C:\Python36-x64\python.exe -m pip install --upgrade pip wheel
  - C:\Python36-x64\python.exe -m pip install nox

test_script:
  - C:\Python36-x64\python.exe -m nox -s ""%NOX_SESSION%""

on_success:
  - pip install codecov
  - codecov --env PLATFORM,TOXENV",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"  VAR: VAR VAR: VAR VAR: VAR: - VAR: ""VAR:\\VAR-VAR"" VAR: ""2.7.VAR"" VAR: ""64"" VAR: ""VAR-2.7"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.4.VAR"" VAR: ""64"" VAR: ""VAR-3.4"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.5.VAR"" VAR: ""64"" VAR: ""VAR-3.5"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.6.VAR"" VAR: ""64"" VAR: ""VAR-3.6"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.7.VAR"" VAR: ""64"" VAR: ""VAR-3.7"" VAR: - VAR:\VAR\VAR\VAR\VAR\VAR\VAR VAR:   - VAR: VAR (-VAR(VAR-VAR($VAR:VAR))) { & VAR\VAR.VAR }    - VAR VAR=%VAR%;%VAR%\\VAR;%VAR%   - VAR:\VAR-VAR\VAR.VAR -VAR VAR VAR --VAR VAR VAR - VAR:\VAR-VAR\VAR.VAR -VAR VAR VAR VAR VAR: - VAR:\VAR-VAR\VAR.VAR -VAR VAR -VAR ""%VAR%"" VAR: - VAR VAR VAR - VAR --VAR VAR,VAR ",10,7
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,src/urllib3/util/ssl_.py,"from __future__ import absolute_import
import errno
import warnings
import hmac
import socket

from binascii import hexlify, unhexlify
from hashlib import md5, sha1, sha256

from ..exceptions import SSLError, InsecurePlatformWarning, SNIMissingWarning
from ..packages import six


SSLContext = None
HAS_SNI = False
IS_PYOPENSSL = False
IS_SECURETRANSPORT = False

# Maps the length of a digest to a possible hash function producing this digest
HASHFUNC_MAP = {
    32: md5,
    40: sha1,
    64: sha256,
}


def _const_compare_digest_backport(a, b):
    """"""
    Compare two digests of equal length in constant time.

    The digests must be of type str/bytes.
    Returns True if the digests match, and False otherwise.
    """"""
    result = abs(len(a) - len(b))
    for l, r in zip(bytearray(a), bytearray(b)):
        result |= l ^ r
    return result == 0


_const_compare_digest = getattr(hmac, 'compare_digest',
                                _const_compare_digest_backport)


try:  # Test for SSL features
    import ssl
    from ssl import wrap_socket, CERT_NONE, PROTOCOL_SSLv23
    from ssl import HAS_SNI  # Has SNI?
except ImportError:
    pass


try:
    from ssl import OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION
except ImportError:
    OP_NO_SSLv2, OP_NO_SSLv3 = 0x1000000, 0x2000000
    OP_NO_COMPRESSION = 0x20000


# Python 2.7 doesn't have inet_pton on non-Linux so we fallback on inet_aton in
# those cases. This means that we can only detect IPv4 addresses in this case.
if hasattr(socket, 'inet_pton'):
    inet_pton = socket.inet_pton
else:
    # Maybe we can use ipaddress if the user has urllib3[secure]?
    try:
        import ipaddress

        def inet_pton(_, host):
            if isinstance(host, bytes):
                host = host.decode('ascii')
            return ipaddress.ip_address(host)

    except ImportError:  # Platform-specific: Non-Linux
        def inet_pton(_, host):
            return socket.inet_aton(host)


# A secure default.
# Sources for more information on TLS ciphers:
#
# - https://wiki.mozilla.org/Security/Server_Side_TLS
# - https://www.ssllabs.com/projects/best-practices/index.html
# - https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
#
# The general intent is:
# - Prefer TLS 1.3 cipher suites
# - prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),
# - prefer ECDHE over DHE for better performance,
# - prefer any AES-GCM and ChaCha20 over any AES-CBC for better performance and
#   security,
# - prefer AES-GCM over ChaCha20 because hardware-accelerated AES is common,
# - disable NULL authentication, MD5 MACs and DSS for security reasons.
DEFAULT_CIPHERS = ':'.join([
    'TLS13-AES-256-GCM-SHA384',
    'TLS13-CHACHA20-POLY1305-SHA256',
    'TLS13-AES-128-GCM-SHA256',
    'ECDH+AESGCM',
    'ECDH+CHACHA20',
    'DH+AESGCM',
    'DH+CHACHA20',
    'ECDH+AES256',
    'DH+AES256',
    'ECDH+AES128',
    'DH+AES',
    'RSA+AESGCM',
    'RSA+AES',
    '!aNULL',
    '!eNULL',
    '!MD5',
])

try:
    from ssl import SSLContext  # Modern SSL?
except ImportError:
    class SSLContext(object):  # Platform-specific: Python 2
        def __init__(self, protocol_version):
            self.protocol = protocol_version
            # Use default values from a real SSLContext
            self.check_hostname = False
            self.verify_mode = ssl.CERT_NONE
            self.ca_certs = None
            self.options = 0
            self.certfile = None
            self.keyfile = None
            self.ciphers = None

        def load_cert_chain(self, certfile, keyfile):
            self.certfile = certfile
            self.keyfile = keyfile

        def load_verify_locations(self, cafile=None, capath=None):
            self.ca_certs = cafile

            if capath is not None:
                raise SSLError(""CA directories not supported in older Pythons"")

        def set_ciphers(self, cipher_suite):
            self.ciphers = cipher_suite

        def wrap_socket(self, socket, server_hostname=None, server_side=False):
            warnings.warn(
                'A true SSLContext object is not available. This prevents '
                'urllib3 from configuring SSL appropriately and may cause '
                'certain SSL connections to fail. You can upgrade to a newer '
                'version of Python to solve this. For more information, see '
                'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
                '#ssl-warnings',
                InsecurePlatformWarning
            )
            kwargs = {
                'keyfile': self.keyfile,
                'certfile': self.certfile,
                'ca_certs': self.ca_certs,
                'cert_reqs': self.verify_mode,
                'ssl_version': self.protocol,
                'server_side': server_side,
            }
            return wrap_socket(socket, ciphers=self.ciphers, **kwargs)


def assert_fingerprint(cert, fingerprint):
    """"""
    Checks if given fingerprint matches the supplied certificate.

    :param cert:
        Certificate as bytes object.
    :param fingerprint:
        Fingerprint as string of hexdigits, can be interspersed by colons.
    """"""

    fingerprint = fingerprint.replace(':', '').lower()
    digest_length = len(fingerprint)
    hashfunc = HASHFUNC_MAP.get(digest_length)
    if not hashfunc:
        raise SSLError(
            'Fingerprint of invalid length: {0}'.format(fingerprint))

    # We need encode() here for py32; works on py2 and p33.
    fingerprint_bytes = unhexlify(fingerprint.encode())

    cert_digest = hashfunc(cert).digest()

    if not _const_compare_digest(cert_digest, fingerprint_bytes):
        raise SSLError('Fingerprints did not match. Expected ""{0}"", got ""{1}"".'
                       .format(fingerprint, hexlify(cert_digest)))


def resolve_cert_reqs(candidate):
    """"""
    Resolves the argument to a numeric constant, which can be passed to
    the wrap_socket function/method from the ssl module.
    Defaults to :data:`ssl.CERT_NONE`.
    If given a string it is assumed to be the name of the constant in the
    :mod:`ssl` module or its abbreviation.
    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.
    If it's neither `None` nor a string we assume it is already the numeric
    constant which can directly be passed to wrap_socket.
    """"""
    if candidate is None:
        return CERT_NONE

    if isinstance(candidate, str):
        res = getattr(ssl, candidate, None)
        if res is None:
            res = getattr(ssl, 'CERT_' + candidate)
        return res

    return candidate


def resolve_ssl_version(candidate):
    """"""
    like resolve_cert_reqs
    """"""
    if candidate is None:
        return PROTOCOL_SSLv23

    if isinstance(candidate, str):
        res = getattr(ssl, candidate, None)
        if res is None:
            res = getattr(ssl, 'PROTOCOL_' + candidate)
        return res

    return candidate


def create_urllib3_context(ssl_version=None, cert_reqs=None,
                           options=None, ciphers=None):
    """"""All arguments have the same meaning as ``ssl_wrap_socket``.

    By default, this function does a lot of the same work that
    ``ssl.create_default_context`` does on Python 3.4+. It:

    - Disables SSLv2, SSLv3, and compression
    - Sets a restricted set of server ciphers

    If you wish to enable SSLv3, you can do::

        from urllib3.util import ssl_
        context = ssl_.create_urllib3_context()
        context.options &= ~ssl_.OP_NO_SSLv3

    You can do the same to enable compression (substituting ``COMPRESSION``
    for ``SSLv3`` in the last line above).

    :param ssl_version:
        The desired protocol version to use. This will default to
        PROTOCOL_SSLv23 which will negotiate the highest protocol that both
        the server and your installation of OpenSSL support.
    :param cert_reqs:
        Whether to require the certificate verification. This defaults to
        ``ssl.CERT_REQUIRED``.
    :param options:
        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,
        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``.
    :param ciphers:
        Which cipher suites to allow the server to select.
    :returns:
        Constructed SSLContext object with specified options
    :rtype: SSLContext
    """"""
    context = SSLContext(ssl_version or ssl.PROTOCOL_SSLv23)

    context.set_ciphers(ciphers or DEFAULT_CIPHERS)

    # Setting the default here, as we may have no ssl module on import
    cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs

    if options is None:
        options = 0
        # SSLv2 is easily broken and is considered harmful and dangerous
        options |= OP_NO_SSLv2
        # SSLv3 has several problems and is now dangerous
        options |= OP_NO_SSLv3
        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+
        # (issue #309)
        options |= OP_NO_COMPRESSION

    context.options |= options

    context.verify_mode = cert_reqs
    if getattr(context, 'check_hostname', None) is not None:  # Platform-specific: Python 3.2
        # We do our own verification, including fingerprints and alternative
        # hostnames. So disable it here
        context.check_hostname = False
    return context


def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,
                    ca_certs=None, server_hostname=None,
                    ssl_version=None, ciphers=None, ssl_context=None,
                    ca_cert_dir=None):
    """"""
    All arguments except for server_hostname, ssl_context, and ca_cert_dir have
    the same meaning as they do when using :func:`ssl.wrap_socket`.

    :param server_hostname:
        When SNI is supported, the expected hostname of the certificate
    :param ssl_context:
        A pre-made :class:`SSLContext` object. If none is provided, one will
        be created using :func:`create_urllib3_context`.
    :param ciphers:
        A string of ciphers we wish the client to support.
    :param ca_cert_dir:
        A directory containing CA certificates in multiple separate files, as
        supported by OpenSSL's -CApath flag or the capath argument to
        SSLContext.load_verify_locations().
    """"""
    context = ssl_context
    if context is None:
        # Note: This branch of code and all the variables in it are no longer
        # used by urllib3 itself. We should consider deprecating and removing
        # this code.
        context = create_urllib3_context(ssl_version, cert_reqs,
                                         ciphers=ciphers)

    if ca_certs or ca_cert_dir:
        try:
            context.load_verify_locations(ca_certs, ca_cert_dir)
        except IOError as e:  # Platform-specific: Python 2.7
            raise SSLError(e)
        # Py33 raises FileNotFoundError which subclasses OSError
        # These are not equivalent unless we check the errno attribute
        except OSError as e:  # Platform-specific: Python 3.3 and beyond
            if e.errno == errno.ENOENT:
                raise SSLError(e)
            raise

    # Don't load system certs unless there were no CA certs or
    # SSLContext object specified manually.
    elif ssl_context is None and hasattr(context, 'load_default_certs'):
        # try to load OS default certs; works well on Windows (require Python3.4+)
        context.load_default_certs()

    if certfile:
        context.load_cert_chain(certfile, keyfile)

    # If we detect server_hostname is an IP address then the SNI
    # extension should not be used according to RFC3546 Section 3.1
    # We shouldn't warn the user if SNI isn't available but we would
    # not be using SNI anyways due to IP address for server_hostname.
    if ((server_hostname is not None and not is_ipaddress(server_hostname))
            or IS_SECURETRANSPORT):
        if HAS_SNI and server_hostname is not None:
            return context.wrap_socket(sock, server_hostname=server_hostname)

        warnings.warn(
            'An HTTPS request has been made, but the SNI (Server Name '
            'Indication) extension to TLS is not available on this platform. '
            'This may cause the server to present an incorrect TLS '
            'certificate, which can cause validation failures. You can upgrade to '
            'a newer version of Python to solve this. For more information, see '
            'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
            '#ssl-warnings',
            SNIMissingWarning
        )

    return context.wrap_socket(sock)


def is_ipaddress(hostname):
    """"""Detects whether the hostname given is an IP address.

    :param str hostname: Hostname to examine.
    :return: True if the hostname is an IP address, False otherwise.
    """"""
    if six.PY3 and isinstance(hostname, bytes):
        # IDN A-label bytes are ASCII compatible.
        hostname = hostname.decode('ascii')

    families = [socket.AF_INET]
    if hasattr(socket, 'AF_INET6'):
        families.append(socket.AF_INET6)

    for af in families:
        try:
            inet_pton(af, hostname)
        except (socket.error, ValueError, OSError):
            pass
        else:
            return True
    return False",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR, VAR VAR ..VAR VAR VAR, VAR, VAR VAR ..VAR VAR VAR VAR = VAR VAR = VAR VAR = VAR VAR = VAR  VAR = { 32: VAR, 40: VAR, 64: VAR, } VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR/VAR. VAR VAR VAR VAR VAR VAR, VAR VAR VAR. """""" VAR = VAR(VAR(VAR) - VAR(VAR)) VAR VAR, VAR VAR VAR(VAR(VAR), VAR(VAR)): VAR |= VAR ^ VAR VAR VAR == 0 VAR = VAR(VAR, 'VAR', VAR) VAR:  VAR VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR  VAR VAR: VAR VAR: VAR VAR VAR VAR, VAR, VAR VAR VAR: VAR, VAR = 0x1000000, 0x2000000 VAR = 0x20000   VAR VAR(VAR, 'VAR'): VAR = VAR.VAR VAR:  VAR: VAR VAR VAR VAR(VAR, VAR): VAR VAR(VAR, VAR): VAR = VAR.VAR('VAR') VAR VAR.VAR(VAR) VAR VAR:  VAR VAR(VAR, VAR): VAR VAR.VAR(VAR)                VAR = ':'.VAR([ 'VAR-VAR-256-VAR-VAR', 'VAR-VAR-VAR-VAR', 'VAR-VAR-128-VAR-VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', '!VAR', '!VAR', '!VAR', ]) VAR: VAR VAR VAR VAR  VAR VAR: VAR VAR(VAR):  VAR VAR(VAR, VAR): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR.VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): VAR.VAR = VAR VAR VAR VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR, VAR): VAR.VAR = VAR VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): VAR.VAR( 'VAR VAR VAR VAR VAR VAR VAR. VAR VAR ' 'VAR VAR VAR VAR VAR VAR VAR VAR ' 'VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR ' 'VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR ' 'VAR: ' VAR ) VAR = { 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR, } VAR VAR(VAR, VAR=VAR.VAR, **VAR) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(':', '').VAR() VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR VAR: VAR VAR( 'VAR VAR VAR VAR: {0}'.VAR(VAR))  VAR = VAR(VAR.VAR()) VAR = VAR(VAR).VAR() VAR VAR VAR(VAR, VAR): VAR VAR('VAR VAR VAR VAR. VAR ""{0}"", VAR ""{1}"".' .VAR(VAR, VAR(VAR))) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR VAR VAR. VAR VAR :VAR:`VAR.VAR`. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR. (VAR VAR VAR VAR `VAR` VAR VAR `VAR`. VAR VAR'VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR VAR VAR: VAR VAR VAR VAR(VAR, VAR): VAR = VAR(VAR, VAR, VAR) VAR VAR VAR VAR: VAR = VAR(VAR, 'VAR' + VAR) VAR VAR VAR VAR VAR VAR(VAR): """""" VAR VAR """""" VAR VAR VAR VAR: VAR VAR VAR VAR(VAR, VAR): VAR = VAR(VAR, VAR, VAR) VAR VAR VAR VAR: VAR = VAR(VAR, 'VAR' + VAR) VAR VAR VAR VAR VAR VAR(VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): """"""VAR VAR VAR VAR VAR VAR VAR ``VAR``. VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR.VAR`` VAR VAR VAR 3.4+. VAR: - VAR VAR, VAR, VAR VAR - VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR:: VAR VAR.VAR VAR VAR VAR = VAR.VAR() VAR.VAR &= ~VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR ``VAR`` VAR ``VAR`` VAR VAR VAR VAR VAR). :VAR VAR: VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR. VAR VAR VAR ``VAR.VAR``. :VAR VAR: VAR VAR VAR. VAR VAR VAR ``VAR.VAR``, ``VAR.VAR``, ``VAR.VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR :VAR: VAR """""" VAR = VAR(VAR VAR VAR.VAR) VAR.VAR(VAR VAR VAR)  VAR = VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR = 0  VAR |= VAR  VAR |= VAR   VAR |= VAR VAR.VAR |= VAR VAR.VAR = VAR VAR VAR(VAR, 'VAR', VAR) VAR VAR VAR:    VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR`. :VAR VAR: VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR :VAR VAR: VAR VAR-VAR :VAR:`VAR` VAR. VAR VAR VAR VAR, VAR VAR VAR VAR VAR :VAR:`VAR`. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR'VAR -VAR VAR VAR VAR VAR VAR VAR VAR.VAR(). """""" VAR = VAR VAR VAR VAR VAR:    VAR = VAR(VAR, VAR, VAR=VAR) VAR VAR VAR VAR: VAR: VAR.VAR(VAR, VAR) VAR VAR VAR VAR:  VAR VAR(VAR)   VAR VAR VAR VAR:  VAR VAR.VAR == VAR.VAR: VAR VAR(VAR) VAR   VAR VAR VAR VAR VAR VAR(VAR, 'VAR'):  VAR.VAR() VAR VAR: VAR.VAR(VAR, VAR)     VAR ((VAR VAR VAR VAR VAR VAR VAR(VAR)) VAR VAR): VAR VAR VAR VAR VAR VAR VAR: VAR VAR.VAR(VAR, VAR=VAR) VAR.VAR( 'VAR VAR VAR VAR VAR VAR, VAR VAR VAR (VAR VAR ' 'VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR. ' 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ' 'VAR, VAR VAR VAR VAR VAR. VAR VAR VAR VAR ' 'VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR ' 'VAR: ' VAR ) VAR VAR.VAR(VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR VAR: VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR. """""" VAR VAR.VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR('VAR') VAR = [VAR.VAR] VAR VAR(VAR, 'VAR'): VAR.VAR(VAR.VAR) VAR VAR VAR VAR: VAR: VAR(VAR, VAR) VAR (VAR.VAR, VAR, VAR): VAR VAR: VAR VAR VAR VAR ",0,7
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,appveyor.yml,"# AppVeyor.yml from https://github.com/ogrisel/python-appveyor-demo
# License: CC0 1.0 Universal: http://creativecommons.org/publicdomain/zero/1.0/

skip_branch_with_pr: true
build: off

environment:

  matrix:
    - PYTHON: ""C:\\Python27-x64""
      PYTHON_VERSION: ""2.7.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-2.7""

    - PYTHON: ""C:\\Python34-x64""
      PYTHON_VERSION: ""3.4.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.4""

    - PYTHON: ""C:\\Python35-x64""
      PYTHON_VERSION: ""3.5.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.5""

    - PYTHON: ""C:\\Python36-x64""
      PYTHON_VERSION: ""3.6.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.6""

    - PYTHON: ""C:\\Python37-x64""
      PYTHON_VERSION: ""3.7.x""
      PYTHON_ARCH: ""64""
      NOX_SESSION: ""test-3.7""

cache:
  - C:\Users\appveyor\AppData\Local\pip\Cache

install:
  # Install Python (from the official .msi of http://python.org) and pip when
  # not already installed.
  - ps: if (-not(Test-Path($env:PYTHON))) { & _appveyor\install.ps1 }

  # Prepend newly installed Python to the PATH of this build (this cannot be
  # done from inside the powershell script as it would require to restart
  # the parent CMD process).
  - SET PATH=%PYTHON%;%PYTHON%\\Scripts;%PATH%

  # Upgrade to the latest version of pip to avoid it displaying warnings
  # about it being out of date.
  - C:\Python36-x64\python.exe -m pip install --upgrade pip wheel
  - C:\Python36-x64\python.exe -m pip install nox

test_script:
  - C:\Python36-x64\python.exe -m nox -s ""%NOX_SESSION%""

on_success:
  - pip install codecov
  - codecov --env PLATFORM,TOXENV",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"  VAR: VAR VAR: VAR VAR: VAR: - VAR: ""VAR:\\VAR-VAR"" VAR: ""2.7.VAR"" VAR: ""64"" VAR: ""VAR-2.7"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.4.VAR"" VAR: ""64"" VAR: ""VAR-3.4"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.5.VAR"" VAR: ""64"" VAR: ""VAR-3.5"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.6.VAR"" VAR: ""64"" VAR: ""VAR-3.6"" - VAR: ""VAR:\\VAR-VAR"" VAR: ""3.7.VAR"" VAR: ""64"" VAR: ""VAR-3.7"" VAR: - VAR:\VAR\VAR\VAR\VAR\VAR\VAR VAR:   - VAR: VAR (-VAR(VAR-VAR($VAR:VAR))) { & VAR\VAR.VAR }    - VAR VAR=%VAR%;%VAR%\\VAR;%VAR%   - VAR:\VAR-VAR\VAR.VAR -VAR VAR VAR --VAR VAR VAR - VAR:\VAR-VAR\VAR.VAR -VAR VAR VAR VAR VAR: - VAR:\VAR-VAR\VAR.VAR -VAR VAR -VAR ""%VAR%"" VAR: - VAR VAR VAR - VAR --VAR VAR,VAR ",10,7
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,src/urllib3/util/ssl_.py,"from __future__ import absolute_import
import errno
import warnings
import hmac
import re

from binascii import hexlify, unhexlify
from hashlib import md5, sha1, sha256

from ..exceptions import SSLError, InsecurePlatformWarning, SNIMissingWarning
from ..packages import six
from ..packages.rfc3986 import abnf_regexp


SSLContext = None
HAS_SNI = False
IS_PYOPENSSL = False
IS_SECURETRANSPORT = False

# Maps the length of a digest to a possible hash function producing this digest
HASHFUNC_MAP = {
    32: md5,
    40: sha1,
    64: sha256,
}


def _const_compare_digest_backport(a, b):
    """"""
    Compare two digests of equal length in constant time.

    The digests must be of type str/bytes.
    Returns True if the digests match, and False otherwise.
    """"""
    result = abs(len(a) - len(b))
    for l, r in zip(bytearray(a), bytearray(b)):
        result |= l ^ r
    return result == 0


_const_compare_digest = getattr(hmac, 'compare_digest',
                                _const_compare_digest_backport)

# Borrow rfc3986's regular expressions for IPv4
# and IPv6 addresses for use in is_ipaddress()
_IP_ADDRESS_REGEX = re.compile(
    r'^(?:%s|%s|%s)$' % (
        abnf_regexp.IPv4_RE,
        abnf_regexp.IPv6_RE,
        abnf_regexp.IPv6_ADDRZ_RFC4007_RE
    )
)

try:  # Test for SSL features
    import ssl
    from ssl import wrap_socket, CERT_REQUIRED
    from ssl import HAS_SNI  # Has SNI?
except ImportError:
    pass

try:  # Platform-specific: Python 3.6
    from ssl import PROTOCOL_TLS
    PROTOCOL_SSLv23 = PROTOCOL_TLS
except ImportError:
    try:
        from ssl import PROTOCOL_SSLv23 as PROTOCOL_TLS
        PROTOCOL_SSLv23 = PROTOCOL_TLS
    except ImportError:
        PROTOCOL_SSLv23 = PROTOCOL_TLS = 2


try:
    from ssl import OP_NO_SSLv2, OP_NO_SSLv3, OP_NO_COMPRESSION
except ImportError:
    OP_NO_SSLv2, OP_NO_SSLv3 = 0x1000000, 0x2000000
    OP_NO_COMPRESSION = 0x20000


# A secure default.
# Sources for more information on TLS ciphers:
#
# - https://wiki.mozilla.org/Security/Server_Side_TLS
# - https://www.ssllabs.com/projects/best-practices/index.html
# - https://hynek.me/articles/hardening-your-web-servers-ssl-ciphers/
#
# The general intent is:
# - prefer cipher suites that offer perfect forward secrecy (DHE/ECDHE),
# - prefer ECDHE over DHE for better performance,
# - prefer any AES-GCM and ChaCha20 over any AES-CBC for better performance and
#   security,
# - prefer AES-GCM over ChaCha20 because hardware-accelerated AES is common,
# - disable NULL authentication, MD5 MACs, DSS, and other
#   insecure ciphers for security reasons.
# - NOTE: TLS 1.3 cipher suites are managed through a different interface
#   not exposed by CPython (yet!) and are enabled by default if they're available.
DEFAULT_CIPHERS = ':'.join([
    'ECDHE+AESGCM',
    'ECDHE+CHACHA20',
    'DHE+AESGCM',
    'DHE+CHACHA20',
    'ECDH+AESGCM',
    'DH+AESGCM',
    'ECDH+AES',
    'DH+AES',
    'RSA+AESGCM',
    'RSA+AES',
    '!aNULL',
    '!eNULL',
    '!MD5',
    '!DSS',
])

try:
    from ssl import SSLContext  # Modern SSL?
except ImportError:
    class SSLContext(object):  # Platform-specific: Python 2
        def __init__(self, protocol_version):
            self.protocol = protocol_version
            # Use default values from a real SSLContext
            self.check_hostname = False
            self.verify_mode = ssl.CERT_NONE
            self.ca_certs = None
            self.options = 0
            self.certfile = None
            self.keyfile = None
            self.ciphers = None

        def load_cert_chain(self, certfile, keyfile):
            self.certfile = certfile
            self.keyfile = keyfile

        def load_verify_locations(self, cafile=None, capath=None):
            self.ca_certs = cafile

            if capath is not None:
                raise SSLError(""CA directories not supported in older Pythons"")

        def set_ciphers(self, cipher_suite):
            self.ciphers = cipher_suite

        def wrap_socket(self, socket, server_hostname=None, server_side=False):
            warnings.warn(
                'A true SSLContext object is not available. This prevents '
                'urllib3 from configuring SSL appropriately and may cause '
                'certain SSL connections to fail. You can upgrade to a newer '
                'version of Python to solve this. For more information, see '
                'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
                '#ssl-warnings',
                InsecurePlatformWarning
            )
            kwargs = {
                'keyfile': self.keyfile,
                'certfile': self.certfile,
                'ca_certs': self.ca_certs,
                'cert_reqs': self.verify_mode,
                'ssl_version': self.protocol,
                'server_side': server_side,
            }
            return wrap_socket(socket, ciphers=self.ciphers, **kwargs)


def assert_fingerprint(cert, fingerprint):
    """"""
    Checks if given fingerprint matches the supplied certificate.

    :param cert:
        Certificate as bytes object.
    :param fingerprint:
        Fingerprint as string of hexdigits, can be interspersed by colons.
    """"""

    fingerprint = fingerprint.replace(':', '').lower()
    digest_length = len(fingerprint)
    hashfunc = HASHFUNC_MAP.get(digest_length)
    if not hashfunc:
        raise SSLError(
            'Fingerprint of invalid length: {0}'.format(fingerprint))

    # We need encode() here for py32; works on py2 and p33.
    fingerprint_bytes = unhexlify(fingerprint.encode())

    cert_digest = hashfunc(cert).digest()

    if not _const_compare_digest(cert_digest, fingerprint_bytes):
        raise SSLError('Fingerprints did not match. Expected ""{0}"", got ""{1}"".'
                       .format(fingerprint, hexlify(cert_digest)))


def resolve_cert_reqs(candidate):
    """"""
    Resolves the argument to a numeric constant, which can be passed to
    the wrap_socket function/method from the ssl module.
    Defaults to :data:`ssl.CERT_NONE`.
    If given a string it is assumed to be the name of the constant in the
    :mod:`ssl` module or its abbreviation.
    (So you can specify `REQUIRED` instead of `CERT_REQUIRED`.
    If it's neither `None` nor a string we assume it is already the numeric
    constant which can directly be passed to wrap_socket.
    """"""
    if candidate is None:
        return CERT_REQUIRED

    if isinstance(candidate, str):
        res = getattr(ssl, candidate, None)
        if res is None:
            res = getattr(ssl, 'CERT_' + candidate)
        return res

    return candidate


def resolve_ssl_version(candidate):
    """"""
    like resolve_cert_reqs
    """"""
    if candidate is None:
        return PROTOCOL_TLS

    if isinstance(candidate, str):
        res = getattr(ssl, candidate, None)
        if res is None:
            res = getattr(ssl, 'PROTOCOL_' + candidate)
        return res

    return candidate


def create_urllib3_context(ssl_version=None, cert_reqs=None,
                           options=None, ciphers=None):
    """"""All arguments have the same meaning as ``ssl_wrap_socket``.

    By default, this function does a lot of the same work that
    ``ssl.create_default_context`` does on Python 3.4+. It:

    - Disables SSLv2, SSLv3, and compression
    - Sets a restricted set of server ciphers

    If you wish to enable SSLv3, you can do::

        from urllib3.util import ssl_
        context = ssl_.create_urllib3_context()
        context.options &= ~ssl_.OP_NO_SSLv3

    You can do the same to enable compression (substituting ``COMPRESSION``
    for ``SSLv3`` in the last line above).

    :param ssl_version:
        The desired protocol version to use. This will default to
        PROTOCOL_SSLv23 which will negotiate the highest protocol that both
        the server and your installation of OpenSSL support.
    :param cert_reqs:
        Whether to require the certificate verification. This defaults to
        ``ssl.CERT_REQUIRED``.
    :param options:
        Specific OpenSSL options. These default to ``ssl.OP_NO_SSLv2``,
        ``ssl.OP_NO_SSLv3``, ``ssl.OP_NO_COMPRESSION``.
    :param ciphers:
        Which cipher suites to allow the server to select.
    :returns:
        Constructed SSLContext object with specified options
    :rtype: SSLContext
    """"""
    context = SSLContext(ssl_version or PROTOCOL_TLS)

    context.set_ciphers(ciphers or DEFAULT_CIPHERS)

    # Setting the default here, as we may have no ssl module on import
    cert_reqs = ssl.CERT_REQUIRED if cert_reqs is None else cert_reqs

    if options is None:
        options = 0
        # SSLv2 is easily broken and is considered harmful and dangerous
        options |= OP_NO_SSLv2
        # SSLv3 has several problems and is now dangerous
        options |= OP_NO_SSLv3
        # Disable compression to prevent CRIME attacks for OpenSSL 1.0+
        # (issue #309)
        options |= OP_NO_COMPRESSION

    context.options |= options

    context.verify_mode = cert_reqs
    if getattr(context, 'check_hostname', None) is not None:  # Platform-specific: Python 3.2
        # We do our own verification, including fingerprints and alternative
        # hostnames. So disable it here
        context.check_hostname = False
    return context


def ssl_wrap_socket(sock, keyfile=None, certfile=None, cert_reqs=None,
                    ca_certs=None, server_hostname=None,
                    ssl_version=None, ciphers=None, ssl_context=None,
                    ca_cert_dir=None, key_password=None):
    """"""
    All arguments except for server_hostname, ssl_context, and ca_cert_dir have
    the same meaning as they do when using :func:`ssl.wrap_socket`.

    :param server_hostname:
        When SNI is supported, the expected hostname of the certificate
    :param ssl_context:
        A pre-made :class:`SSLContext` object. If none is provided, one will
        be created using :func:`create_urllib3_context`.
    :param ciphers:
        A string of ciphers we wish the client to support.
    :param ca_cert_dir:
        A directory containing CA certificates in multiple separate files, as
        supported by OpenSSL's -CApath flag or the capath argument to
        SSLContext.load_verify_locations().
    :param key_password:
        Optional password if the keyfile is encrypted.
    """"""
    context = ssl_context
    if context is None:
        # Note: This branch of code and all the variables in it are no longer
        # used by urllib3 itself. We should consider deprecating and removing
        # this code.
        context = create_urllib3_context(ssl_version, cert_reqs,
                                         ciphers=ciphers)

    if ca_certs or ca_cert_dir:
        try:
            context.load_verify_locations(ca_certs, ca_cert_dir)
        except IOError as e:  # Platform-specific: Python 2.7
            raise SSLError(e)
        # Py33 raises FileNotFoundError which subclasses OSError
        # These are not equivalent unless we check the errno attribute
        except OSError as e:  # Platform-specific: Python 3.3 and beyond
            if e.errno == errno.ENOENT:
                raise SSLError(e)
            raise

    elif ssl_context is None and hasattr(context, 'load_default_certs'):
        # try to load OS default certs; works well on Windows (require Python3.4+)
        context.load_default_certs()

    # Attempt to detect if we get the goofy behavior of the
    # keyfile being encrypted and OpenSSL asking for the
    # passphrase via the terminal and instead error out.
    if keyfile and key_password is None and _is_key_file_encrypted(keyfile):
        raise SSLError(""Client private key is encrypted, password is required"")

    if certfile:
        if key_password is None:
            context.load_cert_chain(certfile, keyfile)
        else:
            context.load_cert_chain(certfile, keyfile, key_password)

    # If we detect server_hostname is an IP address then the SNI
    # extension should not be used according to RFC3546 Section 3.1
    # We shouldn't warn the user if SNI isn't available but we would
    # not be using SNI anyways due to IP address for server_hostname.
    if ((server_hostname is not None and not is_ipaddress(server_hostname))
            or IS_SECURETRANSPORT):
        if HAS_SNI and server_hostname is not None:
            return context.wrap_socket(sock, server_hostname=server_hostname)

        warnings.warn(
            'An HTTPS request has been made, but the SNI (Server Name '
            'Indication) extension to TLS is not available on this platform. '
            'This may cause the server to present an incorrect TLS '
            'certificate, which can cause validation failures. You can upgrade to '
            'a newer version of Python to solve this. For more information, see '
            'https://urllib3.readthedocs.io/en/latest/advanced-usage.html'
            '#ssl-warnings',
            SNIMissingWarning
        )

    return context.wrap_socket(sock)


def is_ipaddress(hostname):
    """"""Detects whether the hostname given is an IPv4 or IPv6 address.
    Also detects IPv6 addresses with Zone IDs.

    :param str hostname: Hostname to examine.
    :return: True if the hostname is an IP address, False otherwise.
    """"""
    if six.PY3 and isinstance(hostname, bytes):
        # IDN A-label bytes are ASCII compatible.
        hostname = hostname.decode('ascii')
    return _IP_ADDRESS_REGEX.match(hostname) is not None


def _is_key_file_encrypted(key_file):
    """"""Detects if a key file is encrypted or not.""""""
    with open(key_file, 'r') as f:
        for line in f:
            # Look for Proc-Type: 4,ENCRYPTED
            if 'ENCRYPTED' in line:
                return True

    return False",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR, VAR VAR ..VAR VAR VAR, VAR, VAR VAR ..VAR VAR VAR VAR ..VAR.VAR VAR VAR VAR = VAR VAR = VAR VAR = VAR VAR = VAR  VAR = { 32: VAR, 40: VAR, 64: VAR, } VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR/VAR. VAR VAR VAR VAR VAR VAR, VAR VAR VAR. """""" VAR = VAR(VAR(VAR) - VAR(VAR)) VAR VAR, VAR VAR VAR(VAR(VAR), VAR(VAR)): VAR |= VAR ^ VAR VAR VAR == 0 VAR = VAR(VAR, 'VAR', VAR)   VAR = VAR.VAR( VAR'^(?:%VAR|%VAR|%VAR)$' % ( VAR.VAR, VAR.VAR, VAR.VAR ) ) VAR:  VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR  VAR VAR: VAR VAR:  VAR VAR VAR VAR VAR = VAR VAR VAR: VAR: VAR VAR VAR VAR VAR VAR VAR = VAR VAR VAR: VAR = VAR = 2 VAR: VAR VAR VAR VAR, VAR, VAR VAR VAR: VAR, VAR = 0x1000000, 0x2000000 VAR = 0x20000                  VAR = ':'.VAR([ 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', 'VAR+VAR', '!VAR', '!VAR', '!VAR', '!VAR', ]) VAR: VAR VAR VAR VAR  VAR VAR: VAR VAR(VAR):  VAR VAR(VAR, VAR): VAR.VAR = VAR  VAR.VAR = VAR VAR.VAR = VAR.VAR VAR.VAR = VAR VAR.VAR = 0 VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, VAR, VAR): VAR.VAR = VAR VAR.VAR = VAR VAR VAR(VAR, VAR=VAR, VAR=VAR): VAR.VAR = VAR VAR VAR VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR VAR"") VAR VAR(VAR, VAR): VAR.VAR = VAR VAR VAR(VAR, VAR, VAR=VAR, VAR=VAR): VAR.VAR( 'VAR VAR VAR VAR VAR VAR VAR. VAR VAR ' 'VAR VAR VAR VAR VAR VAR VAR VAR ' 'VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR ' 'VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR ' 'VAR: ' VAR ) VAR = { 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR.VAR, 'VAR': VAR, } VAR VAR(VAR, VAR=VAR.VAR, **VAR) VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(':', '').VAR() VAR = VAR(VAR) VAR = VAR.VAR(VAR) VAR VAR VAR: VAR VAR( 'VAR VAR VAR VAR: {0}'.VAR(VAR))  VAR = VAR(VAR.VAR()) VAR = VAR(VAR).VAR() VAR VAR VAR(VAR, VAR): VAR VAR('VAR VAR VAR VAR. VAR ""{0}"", VAR ""{1}"".' .VAR(VAR, VAR(VAR))) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR/VAR VAR VAR VAR VAR. VAR VAR :VAR:`VAR.VAR`. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR` VAR VAR VAR VAR. (VAR VAR VAR VAR `VAR` VAR VAR `VAR`. VAR VAR'VAR VAR `VAR` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR VAR VAR: VAR VAR VAR VAR(VAR, VAR): VAR = VAR(VAR, VAR, VAR) VAR VAR VAR VAR: VAR = VAR(VAR, 'VAR' + VAR) VAR VAR VAR VAR VAR VAR(VAR): """""" VAR VAR """""" VAR VAR VAR VAR: VAR VAR VAR VAR(VAR, VAR): VAR = VAR(VAR, VAR, VAR) VAR VAR VAR VAR: VAR = VAR(VAR, 'VAR' + VAR) VAR VAR VAR VAR VAR VAR(VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): """"""VAR VAR VAR VAR VAR VAR VAR ``VAR``. VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ``VAR.VAR`` VAR VAR VAR 3.4+. VAR: - VAR VAR, VAR, VAR VAR - VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR:: VAR VAR.VAR VAR VAR VAR = VAR.VAR() VAR.VAR &= ~VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR (VAR ``VAR`` VAR ``VAR`` VAR VAR VAR VAR VAR). :VAR VAR: VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR. VAR VAR VAR ``VAR.VAR``. :VAR VAR: VAR VAR VAR. VAR VAR VAR ``VAR.VAR``, ``VAR.VAR``, ``VAR.VAR``. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR :VAR: VAR """""" VAR = VAR(VAR VAR VAR) VAR.VAR(VAR VAR VAR)  VAR = VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR: VAR = 0  VAR |= VAR  VAR |= VAR   VAR |= VAR VAR.VAR |= VAR VAR.VAR = VAR VAR VAR(VAR, 'VAR', VAR) VAR VAR VAR:    VAR.VAR = VAR VAR VAR VAR VAR(VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR): """""" VAR VAR VAR VAR VAR, VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR.VAR`. :VAR VAR: VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR :VAR VAR: VAR VAR-VAR :VAR:`VAR` VAR. VAR VAR VAR VAR, VAR VAR VAR VAR VAR :VAR:`VAR`. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. :VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR'VAR -VAR VAR VAR VAR VAR VAR VAR VAR.VAR(). :VAR VAR: VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR VAR VAR VAR VAR:    VAR = VAR(VAR, VAR, VAR=VAR) VAR VAR VAR VAR: VAR: VAR.VAR(VAR, VAR) VAR VAR VAR VAR:  VAR VAR(VAR)   VAR VAR VAR VAR:  VAR VAR.VAR == VAR.VAR: VAR VAR(VAR) VAR VAR VAR VAR VAR VAR VAR(VAR, 'VAR'):  VAR.VAR()    VAR VAR VAR VAR VAR VAR VAR VAR(VAR): VAR VAR(""VAR VAR VAR VAR VAR, VAR VAR VAR"") VAR VAR: VAR VAR VAR VAR: VAR.VAR(VAR, VAR) VAR: VAR.VAR(VAR, VAR, VAR)     VAR ((VAR VAR VAR VAR VAR VAR VAR(VAR)) VAR VAR): VAR VAR VAR VAR VAR VAR VAR: VAR VAR.VAR(VAR, VAR=VAR) VAR.VAR( 'VAR VAR VAR VAR VAR VAR, VAR VAR VAR (VAR VAR ' 'VAR) VAR VAR VAR VAR VAR VAR VAR VAR VAR. ' 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR ' 'VAR, VAR VAR VAR VAR VAR. VAR VAR VAR VAR ' 'VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR, VAR ' 'VAR: ' VAR ) VAR VAR.VAR(VAR) VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR. :VAR VAR VAR: VAR VAR VAR. :VAR: VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR. """""" VAR VAR.VAR VAR VAR(VAR, VAR):  VAR = VAR.VAR('VAR') VAR VAR.VAR(VAR) VAR VAR VAR VAR VAR(VAR): """"""VAR VAR VAR VAR VAR VAR VAR VAR VAR."""""" VAR VAR(VAR, 'VAR') VAR VAR: VAR VAR VAR VAR:  VAR 'VAR' VAR VAR: VAR VAR VAR VAR ",0,7
xrdp_1e42426db59120c6596d673f1bb2dc8b0312e692,libxrdp/xrdp_sec.c,"#define CS_CORE_MIN_LENGTH \
    (\
     4 +            /* Version */ \
     2 + 2 +        /* desktopWidth + desktopHeight */ \
     2 + 2 +        /* colorDepth + SASSequence */ \
     4 +            /* keyboardLayout */ \
     4 + 32 +       /* clientBuild + clientName */ \
     4 + 4 + 4 +    /* keyboardType + keyboardSubType + keyboardFunctionKey */ \
     64 +           /* imeFileName */ \
     0)

    if (!s_check_rem_and_log(s, CS_CORE_MIN_LENGTH,
                             ""Parsing [MS-RDPBCGR] TS_UD_CS_CORE""))
    {
        return 1;
    }
    if (!s_check_rem(s, 2))
    {
        return 0;
    }
#undef CS_CORE_MIN_LENGTH",,1e42426db59120c6596d673f1bb2dc8b0312e692,CVE-2022-23482,1e42426db59120c6596d673f1bb2dc8b0312e692,https://github.com/neutrinolabs/xrdp,NVD_GIT_REPOBASED,138,COMPLETED," (\ 4 + \ 2 + 2 + \ 2 + 2 + \ 4 + \ 4 + 32 + \ 4 + 4 + 4 + \ 64 + \ 0) VAR (!VAR(VAR, VAR, ""VAR [VAR-VAR] VAR"")) { VAR 1; } VAR (!VAR(VAR, 2)) { VAR 0; }  ",10,7
xrdp_96afae1ec559f9befa1c222f92f0d982e410c864,sesman/chansrv/audin.c,"    struct xr_wave_format_ex *wf = g_client_formats[g_current_format];
    /* wf->cbSize was checked when the format was received */
    init_stream(s, wf->cbSize + 64);
","    struct xr_wave_format_ex *wf;
    init_stream(s, 8192);
    wf = g_client_formats[g_current_format];",96afae1ec559f9befa1c222f92f0d982e410c864,CVE-2022-23477,96afae1ec559f9befa1c222f92f0d982e410c864,https://github.com/neutrinolabs/xrdp,NVD_GIT_REPOBASED,142,COMPLETED,"VAR VAR *VAR = VAR[VAR];  VAR(VAR, VAR->VAR + 64); VAR VAR *VAR; VAR(VAR, 8192); VAR = VAR[VAR];",10,7

commit,file,added_code,deleted_code,hash_clean,cve_id,hash,repo_url,rel_type,score,extraction_status,text_norm,cluster_kmeans,cluster_hac
cpython_d315722564927c7202dd6e111dc79eaf14240b0d,Liencodings/idna.py,"    if any(RandAL):
        # There is a RandAL char in the string. Must perform further
        # tests:
        # 1) The characters in section 5.8 MUST be prohibited.
        # This is table C.8, which was already checked
        # 2) If a string contains any RandALCat character, the string
        # MUST NOT contain any LCat character.
        if any(stringprep.in_table_d2(x) for x in label):
            raise UnicodeError(""Violation of BIDI requirement 2"")
        # 3) If a string contains any RandALCat character, a
        # RandALCat character MUST be the first character of the
        # string, and a RandALCat character MUST be the last
        # character of the string.
        if not RandAL[0] or not RandAL[-1]:
            raise UnicodeError(""Violation of BIDI requirement 3"")
    if len(label) > 1024:
        # Protection from https://github.com/python/cpython/issues/98433.
        # https://datatracker.ietf.org/doc/html/rfc5894#section-6
        # doesn't specify a label size limit prior to NAMEPREP. But having
        # one makes practical sense.
        # This leaves ample room for nameprep() to remove Nothing characters
        # per https://www.rfc-editor.org/rfc/rfc3454#section-3.1 while still
        # preventing us from wasting time decoding a big thing that'll just
        # hit the actual <= 63 length limit in Step 6.
        raise UnicodeError(""label way too long"")","    for c in RandAL:
        if c:
            # There is a RandAL char in the string. Must perform further
            # tests:
            # 1) The characters in section 5.8 MUST be prohibited.
            # This is table C.8, which was already checked
            # 2) If a string contains any RandALCat character, the string
            # MUST NOT contain any LCat character.
            if any(stringprep.in_table_d2(x) for x in label):
                raise UnicodeError(""Violation of BIDI requirement 2"")

            # 3) If a string contains any RandALCat character, a
            # RandALCat character MUST be the first character of the
            # string, and a RandALCat character MUST be the last
            # character of the string.
            if not RandAL[0] or not RandAL[-1]:
                raise UnicodeError(""Violation of BIDI requirement 3"")",d315722564927c7202dd6e111dc79eaf14240b0d,CVE-2022-45061,d315722564927c7202dd6e111dc79eaf14240b0d,https://github.com/python/cpython,NVD_GIT_REPOBASED,156,COMPLETED,"VAR VAR(VAR):       VAR VAR(VAR.VAR(VAR) VAR VAR VAR VAR): VAR VAR(""VAR VAR VAR VAR 2"")     VAR VAR VAR[0] VAR VAR VAR[-1]: VAR VAR(""VAR VAR VAR VAR 3"") VAR VAR(VAR) > 1024:         VAR VAR(""VAR VAR VAR VAR"") VAR VAR VAR VAR: VAR VAR:       VAR VAR(VAR.VAR(VAR) VAR VAR VAR VAR): VAR VAR(""VAR VAR VAR VAR 2"")     VAR VAR VAR[0] VAR VAR VAR[-1]: VAR VAR(""VAR VAR VAR VAR 3"")",0,5
cpython_d315722564927c7202dd6e111dc79eaf14240b0d,Misc/NEWS.d/next/Security/2022-11-04-09-29-36.gh-issue-98433.l76c5G.rst,"The IDNA codec decoder used on DNS hostnames by :mod:`socket` or :mod:`asyncio`
related name resolution functions no longer involves a quadratic algorithm.
This prevents a potential CPU denial of service if an out-of-spec excessive
length hostname involving bidirectional characters were decoded. Some protocols
such as :mod:`urllib` http ``3xx`` redirects potentially allow for an attacker
to supply such a name.

Individual labels within an IDNA encoded DNS name will now raise an error early
during IDNA decoding if they are longer than 1024 unicode characters given that
each decoded DNS label must be 63 or fewer characters and the entire decoded
DNS name is limited to 255. Only an application presenting a hostname or label
consisting primarily of :rfc:`3454` section 3.1 ""Nothing"" characters to be
removed would run into of this new limit. See also :rfc:`5894` section 6 and
:rfc:`3491`.",,d315722564927c7202dd6e111dc79eaf14240b0d,CVE-2022-45061,d315722564927c7202dd6e111dc79eaf14240b0d,https://github.com/python/cpython,NVD_GIT_REPOBASED,156,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`VAR` VAR :VAR:`VAR` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR :VAR:`VAR` VAR ``3xx`` VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 1024 VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 63 VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR 255. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR :VAR:`3454` VAR 3.1 ""VAR"" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR :VAR:`5894` VAR 6 VAR :VAR:`3491`. ",0,5
envoy_0e49a495826ea9e29134c1bd54fdeb31a034f40c,test/common/http/http2/codec_impl_test.cc,"      : client_settings_(client_settings), server_settings_(server_settings) {
    // Make sure we explicitly test for stream flush timer creation.
    EXPECT_CALL(client_connection_.dispatcher_, createTimer_(_)).Times(0);
    EXPECT_CALL(server_connection_.dispatcher_, createTimer_(_)).Times(0);
  }
  virtual ~Http2CodecImplTestFixture() {
    client_connection_.dispatcher_.clearDeferredDeleteList();
    if (client_ != nullptr) {
      client_.reset();
      EXPECT_EQ(0, TestUtility::findGauge(client_stats_store_, ""http2.streams_active"")->value());
      EXPECT_EQ(0,
                TestUtility::findGauge(client_stats_store_, ""http2.pending_send_bytes"")->value());
    }
    server_connection_.dispatcher_.clearDeferredDeleteList();
    if (server_ != nullptr) {
      server_.reset();
      EXPECT_EQ(0, TestUtility::findGauge(server_stats_store_, ""http2.streams_active"")->value());
      EXPECT_EQ(0,
                TestUtility::findGauge(server_stats_store_, ""http2.pending_send_bytes"")->value());
    }
  }
        client_connection_, client_callbacks_, client_stats_store_, client_http2_options_,
        server_connection_, server_callbacks_, server_stats_store_, server_http2_options_,
          encoder.getStream().setFlushTimeout(std::chrono::milliseconds(30000));
  Stats::TestUtil::TestStore client_stats_store_;
  Stats::TestUtil::TestStore server_stats_store_;
  EXPECT_EQ(1, client_stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, client_stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, client_stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, client_stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, client_stats_store_.counter(""http2.too_many_header_frames"").value());
  EXPECT_EQ(1, client_stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, client_stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, server_stats_store_.counter(""http2.rx_messaging_error"").value());
TEST_P(Http2CodecImplTest, TrailingHeadersLargeClientBody) {
  EXPECT_CALL(request_decoder_, decodeTrailers_(_));
  auto flush_timer = new Event::MockTimer(&server_connection_.dispatcher_);
  EXPECT_CALL(*flush_timer, enableTimer(std::chrono::milliseconds(30000), _));
  EXPECT_CALL(*flush_timer, disableTimer());
  EXPECT_EQ(1, TestUtility::findGauge(client_stats_store_, ""http2.streams_active"")->value());
  EXPECT_EQ(1, TestUtility::findGauge(server_stats_store_, ""http2.streams_active"")->value());
  EXPECT_EQ(initial_stream_window,
            TestUtility::findGauge(client_stats_store_, ""http2.pending_send_bytes"")->value());
  EXPECT_EQ(initial_stream_window + 1,
            TestUtility::findGauge(client_stats_store_, ""http2.pending_send_bytes"")->value());
  EXPECT_EQ(0, TestUtility::findGauge(client_stats_store_, ""http2.pending_send_bytes"")->value());
// Verify that we create and disable the stream flush timer when trailers follow a stream that
// does not have enough window.
TEST_P(Http2CodecImplFlowControlTest, TrailingHeadersLargeServerBody) {
  initialize();

  InSequence s;
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));
  request_encoder_->encodeHeaders(request_headers, true);

  ON_CALL(client_connection_, write(_, _))
      .WillByDefault(
          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));
  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));
  response_encoder_->encodeHeaders(response_headers, false);
  EXPECT_CALL(server_stream_callbacks_, onAboveWriteBufferHighWatermark());
  EXPECT_CALL(response_decoder_, decodeData(_, false)).Times(AtLeast(1));
  auto flush_timer = new Event::MockTimer(&server_connection_.dispatcher_);
  EXPECT_CALL(*flush_timer, enableTimer(std::chrono::milliseconds(30000), _));
  Buffer::OwnedImpl body(std::string(1024 * 1024, 'a'));
  response_encoder_->encodeData(body, false);
  response_encoder_->encodeTrailers(TestResponseTrailerMapImpl{{""trailing"", ""header""}});

  // Send window updates from the client.
  setupDefaultConnectionMocks();
  EXPECT_CALL(response_decoder_, decodeData(_, false)).Times(AtLeast(1));
  EXPECT_CALL(response_decoder_, decodeTrailers_(_));
  EXPECT_CALL(*flush_timer, disableTimer());
  auto status = server_wrapper_.dispatch(Buffer::OwnedImpl(), *server_);
  EXPECT_TRUE(status.ok());
  EXPECT_EQ(0, server_stats_store_.counter(""http2.tx_flush_timeout"").value());
}

// Verify that we create and handle the stream flush timeout when trailers follow a stream that
// does not have enough window.
TEST_P(Http2CodecImplFlowControlTest, TrailingHeadersLargeServerBodyFlushTimeout) {
  initialize();

  InSequence s;
  MockStreamCallbacks client_stream_callbacks;
  request_encoder_->getStream().addCallbacks(client_stream_callbacks);
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));
  request_encoder_->encodeHeaders(request_headers, true);

  ON_CALL(client_connection_, write(_, _))
      .WillByDefault(
          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));
  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));
  response_encoder_->encodeHeaders(response_headers, false);
  EXPECT_CALL(server_stream_callbacks_, onAboveWriteBufferHighWatermark());
  EXPECT_CALL(response_decoder_, decodeData(_, false)).Times(AtLeast(1));
  auto flush_timer = new Event::MockTimer(&server_connection_.dispatcher_);
  EXPECT_CALL(*flush_timer, enableTimer(std::chrono::milliseconds(30000), _));
  Buffer::OwnedImpl body(std::string(1024 * 1024, 'a'));
  response_encoder_->encodeData(body, false);
  response_encoder_->encodeTrailers(TestResponseTrailerMapImpl{{""trailing"", ""header""}});

  // Invoke a stream flush timeout. Make sure we don't get a reset locally for higher layers but
  // we do get a reset on the client.
  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);
  EXPECT_CALL(client_stream_callbacks, onResetStream(StreamResetReason::RemoteReset, _));
  flush_timer->invokeCallback();
  EXPECT_EQ(1, server_stats_store_.counter(""http2.tx_flush_timeout"").value());
}

// Verify that we create and handle the stream flush timeout when there is a large body that
// does not have enough window.
TEST_P(Http2CodecImplFlowControlTest, LargeServerBodyFlushTimeout) {
  initialize();

  InSequence s;
  MockStreamCallbacks client_stream_callbacks;
  request_encoder_->getStream().addCallbacks(client_stream_callbacks);
  TestRequestHeaderMapImpl request_headers;
  HttpTestUtility::addDefaultHeaders(request_headers);
  EXPECT_CALL(request_decoder_, decodeHeaders_(_, true));
  request_encoder_->encodeHeaders(request_headers, true);

  ON_CALL(client_connection_, write(_, _))
      .WillByDefault(
          Invoke([&](Buffer::Instance& data, bool) -> void { server_wrapper_.buffer_.add(data); }));
  TestResponseHeaderMapImpl response_headers{{"":status"", ""200""}};
  EXPECT_CALL(response_decoder_, decodeHeaders_(_, false));
  response_encoder_->encodeHeaders(response_headers, false);
  EXPECT_CALL(response_decoder_, decodeData(_, false)).Times(AtLeast(1));
  auto flush_timer = new Event::MockTimer(&server_connection_.dispatcher_);
  EXPECT_CALL(*flush_timer, enableTimer(std::chrono::milliseconds(30000), _));
  Buffer::OwnedImpl body(std::string(1024 * 1024, 'a'));
  response_encoder_->encodeData(body, true);

  // Invoke a stream flush timeout. Make sure we don't get a reset locally for higher layers but
  // we do get a reset on the client.
  EXPECT_CALL(server_stream_callbacks_, onResetStream(_, _)).Times(0);
  EXPECT_CALL(client_stream_callbacks, onResetStream(StreamResetReason::RemoteReset, _));
  flush_timer->invokeCallback();
  EXPECT_EQ(1, server_stats_store_.counter(""http2.tx_flush_timeout"").value());
}

      client_connection_, client_callbacks_, client_stats_store_, client_http2_options_,
      server_connection_, server_callbacks_, server_stats_store_, server_http2_options_,
  EXPECT_EQ(1, server_stats_store_.counter(""http2.dropped_headers_with_underscores"").value());
  EXPECT_EQ(
      1,
      server_stats_store_.counter(""http2.requests_rejected_with_underscores_in_headers"").value());
  EXPECT_EQ(0, server_stats_store_.counter(""http2.dropped_headers_with_underscores"").value());
  EXPECT_EQ(1, server_stats_store_.counter(""http2.outbound_control_flood"").value());
  EXPECT_EQ(1, server_stats_store_.counter(""http2.outbound_flood"").value());
  EXPECT_EQ(1, server_stats_store_.counter(""http2.outbound_flood"").value());
  EXPECT_EQ(1, server_stats_store_.counter(""http2.outbound_flood"").value());
        client_connection_, client_callbacks_, client_stats_store_, client_http2_options_,
        server_connection_, server_callbacks_, server_stats_store_, server_http2_options_,","      : client_settings_(client_settings), server_settings_(server_settings) {}
  virtual ~Http2CodecImplTestFixture() = default;
        client_connection_, client_callbacks_, stats_store_, client_http2_options_,
        server_connection_, server_callbacks_, stats_store_, server_http2_options_,
  Stats::TestUtil::TestStore stats_store_;
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.too_many_header_frames"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.rx_messaging_error"").value());
TEST_P(Http2CodecImplTest, TrailingHeadersLargeBody) {
  EXPECT_CALL(request_decoder_, decodeTrailers_(_));
      client_connection_, client_callbacks_, stats_store_, client_http2_options_,
      server_connection_, server_callbacks_, stats_store_, server_http2_options_,
  EXPECT_EQ(1, stats_store_.counter(""http2.dropped_headers_with_underscores"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.requests_rejected_with_underscores_in_headers"").value());
  EXPECT_EQ(0, stats_store_.counter(""http2.dropped_headers_with_underscores"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_control_flood"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
  EXPECT_EQ(1, stats_store_.counter(""http2.outbound_flood"").value());
        client_connection_, client_callbacks_, stats_store_, client_http2_options_,
        server_connection_, server_callbacks_, stats_store_, server_http2_options_,",0e49a495826ea9e29134c1bd54fdeb31a034f40c,CVE-2020-12603,0e49a495826ea9e29134c1bd54fdeb31a034f40c,https://github.com/envoyproxy/envoy,CPE_GIT_REPOBASED,72,COMPLETED,": VAR(VAR), VAR(VAR) {  VAR(VAR.VAR, VAR(VAR)).VAR(0); VAR(VAR.VAR, VAR(VAR)).VAR(0); } VAR ~VAR() { VAR.VAR.VAR(); VAR (VAR != VAR) { VAR.VAR(); VAR(0, VAR::VAR(VAR, ""VAR.VAR"")->VAR()); VAR(0, VAR::VAR(VAR, ""VAR.VAR"")->VAR()); } VAR.VAR.VAR(); VAR (VAR != VAR) { VAR.VAR(); VAR(0, VAR::VAR(VAR, ""VAR.VAR"")->VAR()); VAR(0, VAR::VAR(VAR, ""VAR.VAR"")->VAR()); } } VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR.VAR().VAR(VAR::VAR::VAR(30000)); VAR::VAR::VAR VAR; VAR::VAR::VAR VAR; VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(VAR, VAR) { VAR(VAR, VAR(VAR)); VAR VAR = VAR VAR::VAR(&VAR.VAR); VAR(*VAR, VAR(VAR::VAR::VAR(30000), VAR)); VAR(*VAR, VAR()); VAR(1, VAR::VAR(VAR, ""VAR.VAR"")->VAR()); VAR(1, VAR::VAR(VAR, ""VAR.VAR"")->VAR()); VAR(VAR, VAR::VAR(VAR, ""VAR.VAR"")->VAR()); VAR(VAR + 1, VAR::VAR(VAR, ""VAR.VAR"")->VAR()); VAR(0, VAR::VAR(VAR, ""VAR.VAR"")->VAR());   VAR(VAR, VAR) { VAR(); VAR VAR; VAR VAR; VAR::VAR(VAR); VAR(VAR, VAR(VAR, VAR)); VAR->VAR(VAR, VAR); VAR(VAR, VAR(VAR, VAR)) .VAR( VAR([&](VAR::VAR& VAR, VAR) -> VAR { VAR.VAR.VAR(VAR); })); VAR VAR{{"":VAR"", ""200""}}; VAR(VAR, VAR(VAR, VAR)); VAR->VAR(VAR, VAR); VAR(VAR, VAR()); VAR(VAR, VAR(VAR, VAR)).VAR(VAR(1)); VAR VAR = VAR VAR::VAR(&VAR.VAR); VAR(*VAR, VAR(VAR::VAR::VAR(30000), VAR)); VAR::VAR VAR(VAR::VAR(1024 * 1024, 'VAR')); VAR->VAR(VAR, VAR); VAR->VAR(VAR{{""VAR"", ""VAR""}});  VAR(); VAR(VAR, VAR(VAR, VAR)).VAR(VAR(1)); VAR(VAR, VAR(VAR)); VAR(*VAR, VAR()); VAR VAR = VAR.VAR(VAR::VAR(), *VAR); VAR(VAR.VAR()); VAR(0, VAR.VAR(""VAR.VAR"").VAR()); }   VAR(VAR, VAR) { VAR(); VAR VAR; VAR VAR; VAR->VAR().VAR(VAR); VAR VAR; VAR::VAR(VAR); VAR(VAR, VAR(VAR, VAR)); VAR->VAR(VAR, VAR); VAR(VAR, VAR(VAR, VAR)) .VAR( VAR([&](VAR::VAR& VAR, VAR) -> VAR { VAR.VAR.VAR(VAR); })); VAR VAR{{"":VAR"", ""200""}}; VAR(VAR, VAR(VAR, VAR)); VAR->VAR(VAR, VAR); VAR(VAR, VAR()); VAR(VAR, VAR(VAR, VAR)).VAR(VAR(1)); VAR VAR = VAR VAR::VAR(&VAR.VAR); VAR(*VAR, VAR(VAR::VAR::VAR(30000), VAR)); VAR::VAR VAR(VAR::VAR(1024 * 1024, 'VAR')); VAR->VAR(VAR, VAR); VAR->VAR(VAR{{""VAR"", ""VAR""}});   VAR(VAR, VAR(VAR, VAR)).VAR(0); VAR(VAR, VAR(VAR::VAR, VAR)); VAR->VAR(); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); }   VAR(VAR, VAR) { VAR(); VAR VAR; VAR VAR; VAR->VAR().VAR(VAR); VAR VAR; VAR::VAR(VAR); VAR(VAR, VAR(VAR, VAR)); VAR->VAR(VAR, VAR); VAR(VAR, VAR(VAR, VAR)) .VAR( VAR([&](VAR::VAR& VAR, VAR) -> VAR { VAR.VAR.VAR(VAR); })); VAR VAR{{"":VAR"", ""200""}}; VAR(VAR, VAR(VAR, VAR)); VAR->VAR(VAR, VAR); VAR(VAR, VAR(VAR, VAR)).VAR(VAR(1)); VAR VAR = VAR VAR::VAR(&VAR.VAR); VAR(*VAR, VAR(VAR::VAR::VAR(30000), VAR)); VAR::VAR VAR(VAR::VAR(1024 * 1024, 'VAR')); VAR->VAR(VAR, VAR);   VAR(VAR, VAR(VAR, VAR)).VAR(0); VAR(VAR, VAR(VAR::VAR, VAR)); VAR->VAR(); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); } VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR( 1, VAR.VAR(""VAR.VAR"").VAR()); VAR(0, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, : VAR(VAR), VAR(VAR) {} VAR ~VAR() = VAR; VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR::VAR::VAR VAR; VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(VAR, VAR) { VAR(VAR, VAR(VAR)); VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(0, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR(1, VAR.VAR(""VAR.VAR"").VAR()); VAR, VAR, VAR, VAR, VAR, VAR, VAR, VAR,",0,5
envoy_0e49a495826ea9e29134c1bd54fdeb31a034f40c,test/integration/http2_integration_test.cc,"// Verify downstream codec stream flush timeout.
TEST_P(Http2IntegrationTest, CodecStreamIdleTimeout) {
  config_helper_.setBufferLimits(1024, 1024);
  config_helper_.addConfigModifier(
      [&](envoy::extensions::filters::network::http_connection_manager::v3::HttpConnectionManager&
              hcm) -> void {
        hcm.mutable_stream_idle_timeout()->set_seconds(0);
        constexpr uint64_t IdleTimeoutMs = 400;
        hcm.mutable_stream_idle_timeout()->set_nanos(IdleTimeoutMs * 1000 * 1000);
      });
  initialize();
  envoy::config::core::v3::Http2ProtocolOptions http2_options;
  http2_options.mutable_initial_stream_window_size()->set_value(65535);
  codec_client_ = makeRawHttpConnection(makeClientConnection(lookupPort(""http"")), http2_options);
  auto response = codec_client_->makeHeaderOnlyRequest(default_request_headers_);
  waitForNextUpstreamRequest();
  upstream_request_->encodeHeaders(default_response_headers_, false);
  upstream_request_->encodeData(70000, true);
  test_server_->waitForCounterEq(""http2.tx_flush_timeout"", 1);
  response->waitForReset();
}
",,0e49a495826ea9e29134c1bd54fdeb31a034f40c,CVE-2020-12603,0e49a495826ea9e29134c1bd54fdeb31a034f40c,https://github.com/envoyproxy/envoy,CPE_GIT_REPOBASED,72,COMPLETED," VAR(VAR, VAR) { VAR.VAR(1024, 1024); VAR.VAR( [&](VAR::VAR::VAR::VAR::VAR::VAR::VAR& VAR) -> VAR { VAR.VAR()->VAR(0); VAR VAR VAR = 400; VAR.VAR()->VAR(VAR * 1000 * 1000); }); VAR(); VAR::VAR::VAR::VAR::VAR VAR; VAR.VAR()->VAR(65535); VAR = VAR(VAR(VAR(""VAR"")), VAR); VAR VAR = VAR->VAR(VAR); VAR(); VAR->VAR(VAR, VAR); VAR->VAR(70000, VAR); VAR->VAR(""VAR.VAR"", 1); VAR->VAR(); } ",0,5
envoy_afc39bea36fd436e54262f150c009e8d72db5014,source/common/http/conn_manager_impl.cc,"  // Refresh byte sizes of the HeaderMaps before logging.
  // TODO(asraa): Remove this when entries in HeaderMap can no longer be modified by reference and
  // HeaderMap holds an accurate internal byte size count.
  if (request_headers_ != nullptr) {
    request_headers_->refreshByteSize();
  }
  if (response_headers_ != nullptr) {
    response_headers_->refreshByteSize();
  }
  if (response_trailers_ != nullptr) {
    response_trailers_->refreshByteSize();
  }","  ASSERT(connection_manager_.config_.maxRequestHeadersKb() > 0);
  if (request_headers_->byteSize() > (connection_manager_.config_.maxRequestHeadersKb() * 1024)) {
    sendLocalReply(Grpc::Common::hasGrpcContentType(*request_headers_),
                   Code::RequestHeaderFieldsTooLarge, """", nullptr, is_head_request_, absl::nullopt,
                   StreamInfo::ResponseCodeDetails::get().RequestHeadersTooLarge);
    return;
  }
",afc39bea36fd436e54262f150c009e8d72db5014,CVE-2019-15226,afc39bea36fd436e54262f150c009e8d72db5014,https://github.com/envoyproxy/envoy,NVD_DIRECT_COMMIT,1337,COMPLETED,"   VAR (VAR != VAR) { VAR->VAR(); } VAR (VAR != VAR) { VAR->VAR(); } VAR (VAR != VAR) { VAR->VAR(); } VAR(VAR.VAR.VAR() > 0); VAR (VAR->VAR() > (VAR.VAR.VAR() * 1024)) { VAR(VAR::VAR::VAR(*VAR), VAR::VAR, """", VAR, VAR, VAR::VAR, VAR::VAR::VAR().VAR); VAR; }",0,5
envoy_afc39bea36fd436e54262f150c009e8d72db5014,source/common/http/http2/codec_impl.cc,"    // Verify that the final HeaderMap's byte size is under the limit before decoding headers.
    // This assert iterates over the HeaderMap.
    ASSERT(stream->headers_->byteSize().has_value() &&
           stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());
    if (stream->headers_) {
      // Verify that the final HeaderMap's byte size is under the limit before sending frames.
      // This assert iterates over the HeaderMap.
      ASSERT(stream->headers_->byteSize().has_value() &&
             stream->headers_->byteSize().value() == stream->headers_->byteSizeInternal());
    }
  // Verify that the cached value in byte size exists.
  ASSERT(stream->headers_->byteSize().has_value());
  if (stream->headers_->byteSize().value() > max_request_headers_kb_ * 1024) {","
  if (stream->headers_->byteSize() > max_request_headers_kb_ * 1024) {",afc39bea36fd436e54262f150c009e8d72db5014,CVE-2019-15226,afc39bea36fd436e54262f150c009e8d72db5014,https://github.com/envoyproxy/envoy,NVD_DIRECT_COMMIT,1337,COMPLETED,  VAR(VAR->VAR->VAR().VAR() && VAR->VAR->VAR().VAR() == VAR->VAR->VAR()); VAR (VAR->VAR) {   VAR(VAR->VAR->VAR().VAR() && VAR->VAR->VAR().VAR() == VAR->VAR->VAR()); }  VAR(VAR->VAR->VAR().VAR()); VAR (VAR->VAR->VAR().VAR() > VAR * 1024) { VAR (VAR->VAR->VAR() > VAR * 1024) {,0,5
envoy_afc39bea36fd436e54262f150c009e8d72db5014,test/common/http/http2/codec_impl_test.cc,"  // Refresh byte size after adding default inline headers by reference.
  request_headers.refreshByteSize();
      codec_limit_kb * 1024 - request_headers.byteSize().value() - key.length() - head_room;
  ASSERT_EQ(request_headers.byteSize().value() + head_room, codec_limit_kb * 1024);","      codec_limit_kb * 1024 - request_headers.byteSize() - key.length() - head_room;
  ASSERT_EQ(request_headers.byteSize() + head_room, codec_limit_kb * 1024);",afc39bea36fd436e54262f150c009e8d72db5014,CVE-2019-15226,afc39bea36fd436e54262f150c009e8d72db5014,https://github.com/envoyproxy/envoy,NVD_DIRECT_COMMIT,1337,COMPLETED," VAR.VAR(); VAR * 1024 - VAR.VAR().VAR() - VAR.VAR() - VAR; VAR(VAR.VAR().VAR() + VAR, VAR * 1024); VAR * 1024 - VAR.VAR() - VAR.VAR() - VAR; VAR(VAR.VAR() + VAR, VAR * 1024);",0,5
envoy_afc39bea36fd436e54262f150c009e8d72db5014,test/integration/http_integration.cc,"    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index,
    std::chrono::milliseconds time) {
  waitForNextUpstreamRequest(upstream_index, time);
HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices,
                                                std::chrono::milliseconds connection_wait_timeout) {
          *dispatcher_, fake_upstream_connection_, connection_wait_timeout,
void HttpIntegrationTest::waitForNextUpstreamRequest(
    uint64_t upstream_index, std::chrono::milliseconds connection_wait_timeout) {
  waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}), connection_wait_timeout);
void HttpIntegrationTest::testLargeRequestTrailers(uint32_t size, uint32_t max_size) {
  // `size` parameter is the size of the trailer that will be added to the
  // request. The actual request byte size will exceed `size` due to keys
  // and other headers.

  config_helper_.addConfigModifier(
      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
          -> void { hcm.mutable_max_request_headers_kb()->set_value(max_size); });
  max_request_headers_kb_ = max_size;
  Http::TestHeaderMapImpl request_trailers{{""trailer"", ""trailer""}};
  request_trailers.addCopy(""big"", std::string(size * 1024, 'a'));

  initialize();

  codec_client_ = makeHttpConnection(lookupPort(""http""));
  fake_upstreams_[0]->set_allow_unexpected_disconnects(true);

  auto encoder_decoder = codec_client_->startRequest(default_request_headers_);
  request_encoder_ = &encoder_decoder.first;
  auto response = std::move(encoder_decoder.second);
  codec_client_->sendData(*request_encoder_, 10, false);
  codec_client_->sendTrailers(*request_encoder_, request_trailers);

  if (size >= max_size && downstream_protocol_ == Http::CodecClient::Type::HTTP2) {
    // For HTTP/2, expect a stream reset when the size of the trailers is larger than the maximum
    // limit.
    response->waitForReset();
    codec_client_->close();
    EXPECT_FALSE(response->complete());

  } else {
    waitForNextUpstreamRequest();
    upstream_request_->encodeHeaders(default_response_headers_, true);
    response->waitForEndStream();
    EXPECT_TRUE(response->complete());
  }
}

void HttpIntegrationTest::testManyRequestHeaders(std::chrono::milliseconds time) {
  config_helper_.addConfigModifier(
      [&](envoy::config::filter::network::http_connection_manager::v2::HttpConnectionManager& hcm)
          -> void { hcm.mutable_max_request_headers_kb()->set_value(96); });
  max_request_headers_kb_ = 96;

  Http::TestHeaderMapImpl big_headers{
      {"":method"", ""GET""}, {"":path"", ""/test/long/url""}, {"":scheme"", ""http""}, {"":authority"", ""host""}};

  for (int i = 0; i < 20000; i++) {
    big_headers.addCopy(std::to_string(i), std::string(0, 'a'));
  }
  initialize();

  codec_client_ = makeHttpConnection(lookupPort(""http""));

  auto response =
      sendRequestAndWaitForResponse(big_headers, 0, default_response_headers_, 0, 0, time);

  EXPECT_TRUE(response->complete());
  EXPECT_EQ(""200"", response->headers().Status()->value().getStringView());
}
","    const Http::TestHeaderMapImpl& response_headers, uint32_t response_size, int upstream_index) {
  waitForNextUpstreamRequest(upstream_index);
HttpIntegrationTest::waitForNextUpstreamRequest(const std::vector<uint64_t>& upstream_indices) {
          *dispatcher_, fake_upstream_connection_, TestUtility::DefaultTimeout,
void HttpIntegrationTest::waitForNextUpstreamRequest(uint64_t upstream_index) {
  waitForNextUpstreamRequest(std::vector<uint64_t>({upstream_index}));",afc39bea36fd436e54262f150c009e8d72db5014,CVE-2019-15226,afc39bea36fd436e54262f150c009e8d72db5014,https://github.com/envoyproxy/envoy,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR::VAR& VAR, VAR VAR, VAR VAR, VAR::VAR::VAR VAR) { VAR(VAR, VAR); VAR::VAR(VAR VAR::VAR<VAR>& VAR, VAR::VAR::VAR VAR) { *VAR, VAR, VAR, VAR VAR::VAR( VAR VAR, VAR::VAR::VAR VAR) { VAR(VAR::VAR<VAR>({VAR}), VAR); VAR VAR::VAR(VAR VAR, VAR VAR) {    VAR.VAR( [&](VAR::VAR::VAR::VAR::VAR::VAR::VAR& VAR) -> VAR { VAR.VAR()->VAR(VAR); }); VAR = VAR; VAR::VAR VAR{{""VAR"", ""VAR""}}; VAR.VAR(""VAR"", VAR::VAR(VAR * 1024, 'VAR')); VAR(); VAR = VAR(VAR(""VAR"")); VAR[0]->VAR(VAR); VAR VAR = VAR->VAR(VAR); VAR = &VAR.VAR; VAR VAR = VAR::VAR(VAR.VAR); VAR->VAR(*VAR, 10, VAR); VAR->VAR(*VAR, VAR); VAR (VAR >= VAR && VAR == VAR::VAR::VAR::VAR) {   VAR->VAR(); VAR->VAR(); VAR(VAR->VAR()); } VAR { VAR(); VAR->VAR(VAR, VAR); VAR->VAR(); VAR(VAR->VAR()); } } VAR VAR::VAR(VAR::VAR::VAR VAR) { VAR.VAR( [&](VAR::VAR::VAR::VAR::VAR::VAR::VAR& VAR) -> VAR { VAR.VAR()->VAR(96); }); VAR = 96; VAR::VAR VAR{ {"":VAR"", ""VAR""}, {"":VAR"", ""/VAR/VAR/VAR""}, {"":VAR"", ""VAR""}, {"":VAR"", ""VAR""}}; VAR (VAR VAR = 0; VAR < 20000; VAR++) { VAR.VAR(VAR::VAR(VAR), VAR::VAR(0, 'VAR')); } VAR(); VAR = VAR(VAR(""VAR"")); VAR VAR = VAR(VAR, 0, VAR, 0, 0, VAR); VAR(VAR->VAR()); VAR(""200"", VAR->VAR().VAR()->VAR().VAR()); } VAR VAR::VAR& VAR, VAR VAR, VAR VAR) { VAR(VAR); VAR::VAR(VAR VAR::VAR<VAR>& VAR) { *VAR, VAR, VAR::VAR, VAR VAR::VAR(VAR VAR) { VAR(VAR::VAR<VAR>({VAR}));",0,5
envoy_b3f42a4ebbd51e816cfde63ee672ce31e420602a,test/common/http/http1/codec_impl_test.cc,"// This behavior was observed during CVE-2019-18801 and helped to limit the
// scope of affected Envoy configurations.
TEST_F(Http1ServerConnectionImplTest, RejectInvalidMethod) {
  initialize();

  Http::MockStreamDecoder decoder;
  EXPECT_CALL(callbacks_, newStream(_, _)).WillOnce(ReturnRef(decoder));

  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));

  Buffer::OwnedImpl buffer(""BAD / HTTP/1.1\r\nHost: foo\r\n"");
  EXPECT_THROW(codec_->dispatch(buffer), CodecProtocolException);
  EXPECT_EQ(""HTTP/1.1 400 Bad Request\r\ncontent-length: 0\r\nconnection: close\r\n\r\n"", output);
}

// As with Http1ClientConnectionImplTest.LargeHeaderRequestEncode but validate
// the response encoder instead of request encoder.
TEST_F(Http1ServerConnectionImplTest, LargeHeaderResponseEncode) {
  initialize();

  NiceMock<Http::MockStreamDecoder> decoder;
  Http::StreamEncoder* response_encoder = nullptr;
  EXPECT_CALL(callbacks_, newStream(_, _))
      .WillOnce(Invoke([&](Http::StreamEncoder& encoder, bool) -> Http::StreamDecoder& {
        response_encoder = &encoder;
        return decoder;
      }));

  Buffer::OwnedImpl buffer(""GET / HTTP/1.1\r\n\r\n"");
  codec_->dispatch(buffer);
  EXPECT_EQ(0U, buffer.length());

  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));

  const std::string long_header_value = std::string(79 * 1024, 'a');
  TestHeaderMapImpl headers{{"":status"", ""200""}, {""foo"", long_header_value}};
  response_encoder->encodeHeaders(headers, true);
  EXPECT_EQ(""HTTP/1.1 200 OK\r\nfoo: "" + long_header_value + ""\r\ncontent-length: 0\r\n\r\n"",
            output);
}

// Regression test for CVE-2019-18801. Large method headers should not trigger
// ASSERTs or ASAN, which they previously did.
TEST_F(Http1ClientConnectionImplTest, LargeMethodRequestEncode) {
  initialize();

  NiceMock<Http::MockStreamDecoder> response_decoder;
  const std::string long_method = std::string(79 * 1024, 'a');
  Http::StreamEncoder& request_encoder = codec_->newStream(response_decoder);
  TestHeaderMapImpl headers{{"":method"", long_method}, {"":path"", ""/""}, {"":authority"", ""host""}};
  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(long_method + "" / HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}

// As with LargeMethodEncode, but for the path header. This was not an issue
// in CVE-2019-18801, but the related code does explicit size calculations on
// both path and method (these are the two distinguished headers). So,
// belt-and-braces.
TEST_F(Http1ClientConnectionImplTest, LargePathRequestEncode) {
  initialize();

  NiceMock<Http::MockStreamDecoder> response_decoder;
  const std::string long_path = std::string(79 * 1024, '/');
  Http::StreamEncoder& request_encoder = codec_->newStream(response_decoder);
  TestHeaderMapImpl headers{{"":method"", ""GET""}, {"":path"", long_path}, {"":authority"", ""host""}};
  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET "" + long_path + "" HTTP/1.1\r\nhost: host\r\ncontent-length: 0\r\n\r\n"", output);
}

// As with LargeMethodEncode, but for an arbitrary header. This was not an issue
// in CVE-2019-18801.
TEST_F(Http1ClientConnectionImplTest, LargeHeaderRequestEncode) {
  initialize();

  NiceMock<Http::MockStreamDecoder> response_decoder;
  Http::StreamEncoder& request_encoder = codec_->newStream(response_decoder);
  const std::string long_header_value = std::string(79 * 1024, 'a');
  TestHeaderMapImpl headers{
      {"":method"", ""GET""}, {""foo"", long_header_value}, {"":path"", ""/""}, {"":authority"", ""host""}};
  std::string output;
  ON_CALL(connection_, write(_, _)).WillByDefault(AddBufferToString(&output));
  request_encoder.encodeHeaders(headers, true);
  EXPECT_EQ(""GET / HTTP/1.1\r\nhost: host\r\nfoo: "" + long_header_value +
                ""\r\ncontent-length: 0\r\n\r\n"",
            output);
}
",,b3f42a4ebbd51e816cfde63ee672ce31e420602a,CVE-2019-18801,b3f42a4ebbd51e816cfde63ee672ce31e420602a,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,80,COMPLETED,"  VAR(VAR, VAR) { VAR(); VAR::VAR VAR; VAR(VAR, VAR(VAR, VAR)).VAR(VAR(VAR)); VAR::VAR VAR; VAR(VAR, VAR(VAR, VAR)).VAR(VAR(&VAR)); VAR::VAR VAR(""VAR / VAR/1.1\VAR\VAR: VAR\VAR\VAR""); VAR(VAR->VAR(VAR), VAR); VAR(""VAR/1.1 400 VAR VAR\VAR\VAR-VAR: 0\VAR\VAR: VAR\VAR\VAR\VAR\VAR"", VAR); }   VAR(VAR, VAR) { VAR(); VAR<VAR::VAR> VAR; VAR::VAR* VAR = VAR; VAR(VAR, VAR(VAR, VAR)) .VAR(VAR([&](VAR::VAR& VAR, VAR) -> VAR::VAR& { VAR = &VAR; VAR VAR; })); VAR::VAR VAR(""VAR / VAR/1.1\VAR\VAR\VAR\VAR""); VAR->VAR(VAR); VAR(0U, VAR.VAR()); VAR::VAR VAR; VAR(VAR, VAR(VAR, VAR)).VAR(VAR(&VAR)); VAR VAR::VAR VAR = VAR::VAR(79 * 1024, 'VAR'); VAR VAR{{"":VAR"", ""200""}, {""VAR"", VAR}}; VAR->VAR(VAR, VAR); VAR(""VAR/1.1 200 VAR\VAR\VAR: "" + VAR + ""\VAR\VAR-VAR: 0\VAR\VAR\VAR\VAR"", VAR); }   VAR(VAR, VAR) { VAR(); VAR<VAR::VAR> VAR; VAR VAR::VAR VAR = VAR::VAR(79 * 1024, 'VAR'); VAR::VAR& VAR = VAR->VAR(VAR); VAR VAR{{"":VAR"", VAR}, {"":VAR"", ""/""}, {"":VAR"", ""VAR""}}; VAR::VAR VAR; VAR(VAR, VAR(VAR, VAR)).VAR(VAR(&VAR)); VAR.VAR(VAR, VAR); VAR(VAR + "" / VAR/1.1\VAR\VAR: VAR\VAR\VAR-VAR: 0\VAR\VAR\VAR\VAR"", VAR); }     VAR(VAR, VAR) { VAR(); VAR<VAR::VAR> VAR; VAR VAR::VAR VAR = VAR::VAR(79 * 1024, '/'); VAR::VAR& VAR = VAR->VAR(VAR); VAR VAR{{"":VAR"", ""VAR""}, {"":VAR"", VAR}, {"":VAR"", ""VAR""}}; VAR::VAR VAR; VAR(VAR, VAR(VAR, VAR)).VAR(VAR(&VAR)); VAR.VAR(VAR, VAR); VAR(""VAR "" + VAR + "" VAR/1.1\VAR\VAR: VAR\VAR\VAR-VAR: 0\VAR\VAR\VAR\VAR"", VAR); }   VAR(VAR, VAR) { VAR(); VAR<VAR::VAR> VAR; VAR::VAR& VAR = VAR->VAR(VAR); VAR VAR::VAR VAR = VAR::VAR(79 * 1024, 'VAR'); VAR VAR{ {"":VAR"", ""VAR""}, {""VAR"", VAR}, {"":VAR"", ""/""}, {"":VAR"", ""VAR""}}; VAR::VAR VAR; VAR(VAR, VAR(VAR, VAR)).VAR(VAR(&VAR)); VAR.VAR(VAR, VAR); VAR(""VAR / VAR/1.1\VAR\VAR: VAR\VAR\VAR: "" + VAR + ""\VAR\VAR-VAR: 0\VAR\VAR\VAR\VAR"", VAR); } ",0,5
envoy_eff020170c6267e6c8dc235473f7fc85c5b1e07d,api/envoy/api/v2/route/route.proto,"import ""envoy/type/matcher/regex.proto"";
import ""envoy/type/matcher/string.proto"";
    //
    // .. attention::
    //   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
    //   untrusted input in all cases.
    string regex = 3 [(validate.rules).string.max_bytes = 1024, deprecated = true];

    // If specified, the route is a regular expression rule meaning that the
    // regex must match the *:path* header once the query string is removed. The entire path
    // (without the query string) must match the regex. The rule will not match if only a
    // subsequence of the *:path* header matches the regex.
    //
    // [#next-major-version: In the v3 API we should redo how path specification works such
    // that we utilize StringMatcher, and additionally have consistent options around whether we
    // strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
    // to deprecate the existing options. We should even consider whether we want to do away with
    // path_specifier entirely and just rely on a set of header matchers which can already match
    // on :path, etc. The issue with that is it is unclear how to generically deal with query string
    // stripping. This needs more thought.]
    type.matcher.RegexMatcher safe_regex = 10 [(validate.rules).message.required = true];
  //
  // .. attention::
  //  This field has been deprecated in favor of `allow_origin_string_match`.
  repeated string allow_origin = 1 [deprecated = true];
  //
  // .. attention::
  //   This field has been deprecated in favor of `allow_origin_string_match` as it is not safe for
  //   use with untrusted input in all cases.
  repeated string allow_origin_regex = 8
      [(validate.rules).repeated .items.string.max_bytes = 1024, deprecated = true];

  // Specifies string patterns that match allowed origins. An origin is allowed if any of the
  // string matchers match.
  repeated type.matcher.StringMatcher allow_origin_string_match = 11;
  //
  // .. attention::
  //   This field has been deprecated in favor of `headers` as it is not safe for use with
  //   untrusted input in all cases.
  string pattern = 1 [(validate.rules).string.max_bytes = 1024, deprecated = true];

  // Specifies a list of header matchers to use for matching requests. Each specified header must
  // match. The pseudo-headers `:path` and `:method` can be used to match the request path and
  // method, respectively.
  repeated HeaderMatcher headers = 4;
  // Specifies the name of the virtual cluster. The virtual cluster name as well
  //
  // .. attention::
  //   This field has been deprecated in favor of `headers`.
  core.RequestMethod method = 3 [deprecated = true];
//  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
    //
    // .. attention::
    //   This field has been deprecated in favor of `safe_regex_match` as it is not safe for use
    //   with untrusted input in all cases.
    string regex_match = 5 [(validate.rules).string.max_bytes = 1024, deprecated = true];

    // If specified, this regex string is a regular expression rule which implies the entire request
    // header value must match the regex. The rule will not match if only a subsequence of the
    // request header value matches the regex.
    type.matcher.RegexMatcher safe_regex_match = 11;
  //
  // ..attention::
  //   This field is deprecated. Use an `exact` match inside the `string_match` field.
  string value = 3 [deprecated = true];
  //
  // ..attention::
  //   This field is deprecated. Use a `safe_regex` match inside the `string_match` field.
  google.protobuf.BoolValue regex = 4 [deprecated = true];

  oneof query_parameter_match_specifier {
    // Specifies whether a query parameter value should match against a string.
    type.matcher.StringMatcher string_match = 5 [(validate.rules).message.required = true];

    // Specifies whether a query parameter should be present.
    bool present_match = 6;
  }","    string regex = 3 [(validate.rules).string.max_bytes = 1024];
  repeated string allow_origin = 1;
  repeated string allow_origin_regex = 8 [(validate.rules).repeated .items.string.max_bytes = 1024];
  string pattern = 1 [(validate.rules).string = {min_bytes: 1, max_bytes: 1024}];
  //  Specifies the name of the virtual cluster. The virtual cluster name as well
  // [#comment:TODO(htuch): add (validate.rules).enum.defined_only = true once
  // https://github.com/lyft/protoc-gen-validate/issues/42 is resolved.]
  core.RequestMethod method = 3;
    string regex_match = 5 [(validate.rules).string.max_bytes = 1024];
  string value = 3;
  google.protobuf.BoolValue regex = 4;",eff020170c6267e6c8dc235473f7fc85c5b1e07d,CVE-2019-14993,eff020170c6267e6c8dc235473f7fc85c5b1e07d,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,106,COMPLETED,"VAR ""VAR/VAR/VAR/VAR.VAR""; VAR ""VAR/VAR/VAR/VAR.VAR"";     VAR VAR = 3 [(VAR.VAR).VAR.VAR = 1024, VAR = VAR];             VAR.VAR.VAR VAR = 10 [(VAR.VAR).VAR.VAR = VAR];    VAR VAR VAR = 1 [VAR = VAR];     VAR VAR VAR = 8 [(VAR.VAR).VAR .VAR.VAR.VAR = 1024, VAR = VAR];   VAR VAR.VAR.VAR VAR = 11;     VAR VAR = 1 [(VAR.VAR).VAR.VAR = 1024, VAR = VAR];    VAR VAR VAR = 4;     VAR.VAR VAR = 3 [VAR = VAR];      VAR VAR = 5 [(VAR.VAR).VAR.VAR = 1024, VAR = VAR];    VAR.VAR.VAR VAR = 11;    VAR VAR = 3 [VAR = VAR];    VAR.VAR.VAR VAR = 4 [VAR = VAR]; VAR VAR {  VAR.VAR.VAR VAR = 5 [(VAR.VAR).VAR.VAR = VAR];  VAR VAR = 6; } VAR VAR = 3 [(VAR.VAR).VAR.VAR = 1024]; VAR VAR VAR = 1; VAR VAR VAR = 8 [(VAR.VAR).VAR .VAR.VAR.VAR = 1024]; VAR VAR = 1 [(VAR.VAR).VAR = {VAR: 1, VAR: 1024}];    VAR.VAR VAR = 3; VAR VAR = 5 [(VAR.VAR).VAR.VAR = 1024]; VAR VAR = 3; VAR.VAR.VAR VAR = 4;",0,5
envoy_eff020170c6267e6c8dc235473f7fc85c5b1e07d,api/envoy/api/v2/route/route.proto,"import ""envoy/type/matcher/regex.proto"";
import ""envoy/type/matcher/string.proto"";
    //
    // .. attention::
    //   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
    //   untrusted input in all cases.
    string regex = 3 [(validate.rules).string.max_bytes = 1024, deprecated = true];

    // If specified, the route is a regular expression rule meaning that the
    // regex must match the *:path* header once the query string is removed. The entire path
    // (without the query string) must match the regex. The rule will not match if only a
    // subsequence of the *:path* header matches the regex.
    //
    // [#next-major-version: In the v3 API we should redo how path specification works such
    // that we utilize StringMatcher, and additionally have consistent options around whether we
    // strip query strings, do a case sensitive match, etc. In the interim it will be too disruptive
    // to deprecate the existing options. We should even consider whether we want to do away with
    // path_specifier entirely and just rely on a set of header matchers which can already match
    // on :path, etc. The issue with that is it is unclear how to generically deal with query string
    // stripping. This needs more thought.]
    type.matcher.RegexMatcher safe_regex = 10 [(validate.rules).message.required = true];
  //
  // .. attention::
  //  This field has been deprecated in favor of `allow_origin_string_match`.
  repeated string allow_origin = 1 [deprecated = true];
  //
  // .. attention::
  //   This field has been deprecated in favor of `allow_origin_string_match` as it is not safe for
  //   use with untrusted input in all cases.
  repeated string allow_origin_regex = 8
      [(validate.rules).repeated .items.string.max_bytes = 1024, deprecated = true];

  // Specifies string patterns that match allowed origins. An origin is allowed if any of the
  // string matchers match.
  repeated type.matcher.StringMatcher allow_origin_string_match = 11;
  //
  // .. attention::
  //   This field has been deprecated in favor of `headers` as it is not safe for use with
  //   untrusted input in all cases.
  string pattern = 1 [(validate.rules).string.max_bytes = 1024, deprecated = true];

  // Specifies a list of header matchers to use for matching requests. Each specified header must
  // match. The pseudo-headers `:path` and `:method` can be used to match the request path and
  // method, respectively.
  repeated HeaderMatcher headers = 4;
  // Specifies the name of the virtual cluster. The virtual cluster name as well
  //
  // .. attention::
  //   This field has been deprecated in favor of `headers`.
  core.RequestMethod method = 3 [deprecated = true];
//  [#next-major-version: HeaderMatcher should be refactored to use StringMatcher.]
    //
    // .. attention::
    //   This field has been deprecated in favor of `safe_regex_match` as it is not safe for use
    //   with untrusted input in all cases.
    string regex_match = 5 [(validate.rules).string.max_bytes = 1024, deprecated = true];

    // If specified, this regex string is a regular expression rule which implies the entire request
    // header value must match the regex. The rule will not match if only a subsequence of the
    // request header value matches the regex.
    type.matcher.RegexMatcher safe_regex_match = 11;
  //
  // ..attention::
  //   This field is deprecated. Use an `exact` match inside the `string_match` field.
  string value = 3 [deprecated = true];
  //
  // ..attention::
  //   This field is deprecated. Use a `safe_regex` match inside the `string_match` field.
  google.protobuf.BoolValue regex = 4 [deprecated = true];

  oneof query_parameter_match_specifier {
    // Specifies whether a query parameter value should match against a string.
    type.matcher.StringMatcher string_match = 5 [(validate.rules).message.required = true];

    // Specifies whether a query parameter should be present.
    bool present_match = 6;
  }","    string regex = 3 [(validate.rules).string.max_bytes = 1024];
  repeated string allow_origin = 1;
  repeated string allow_origin_regex = 8 [(validate.rules).repeated .items.string.max_bytes = 1024];
  string pattern = 1 [(validate.rules).string = {min_bytes: 1, max_bytes: 1024}];
  //  Specifies the name of the virtual cluster. The virtual cluster name as well
  // [#comment:TODO(htuch): add (validate.rules).enum.defined_only = true once
  // https://github.com/lyft/protoc-gen-validate/issues/42 is resolved.]
  core.RequestMethod method = 3;
    string regex_match = 5 [(validate.rules).string.max_bytes = 1024];
  string value = 3;
  google.protobuf.BoolValue regex = 4;",eff020170c6267e6c8dc235473f7fc85c5b1e07d,CVE-2019-15225,eff020170c6267e6c8dc235473f7fc85c5b1e07d,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,106,COMPLETED,"VAR ""VAR/VAR/VAR/VAR.VAR""; VAR ""VAR/VAR/VAR/VAR.VAR"";     VAR VAR = 3 [(VAR.VAR).VAR.VAR = 1024, VAR = VAR];             VAR.VAR.VAR VAR = 10 [(VAR.VAR).VAR.VAR = VAR];    VAR VAR VAR = 1 [VAR = VAR];     VAR VAR VAR = 8 [(VAR.VAR).VAR .VAR.VAR.VAR = 1024, VAR = VAR];   VAR VAR.VAR.VAR VAR = 11;     VAR VAR = 1 [(VAR.VAR).VAR.VAR = 1024, VAR = VAR];    VAR VAR VAR = 4;     VAR.VAR VAR = 3 [VAR = VAR];      VAR VAR = 5 [(VAR.VAR).VAR.VAR = 1024, VAR = VAR];    VAR.VAR.VAR VAR = 11;    VAR VAR = 3 [VAR = VAR];    VAR.VAR.VAR VAR = 4 [VAR = VAR]; VAR VAR {  VAR.VAR.VAR VAR = 5 [(VAR.VAR).VAR.VAR = VAR];  VAR VAR = 6; } VAR VAR = 3 [(VAR.VAR).VAR.VAR = 1024]; VAR VAR VAR = 1; VAR VAR VAR = 8 [(VAR.VAR).VAR .VAR.VAR.VAR = 1024]; VAR VAR = 1 [(VAR.VAR).VAR = {VAR: 1, VAR: 1024}];    VAR.VAR VAR = 3; VAR VAR = 5 [(VAR.VAR).VAR.VAR = 1024]; VAR VAR = 3; VAR.VAR.VAR VAR = 4;",0,5
envoy_eff020170c6267e6c8dc235473f7fc85c5b1e07d,api/envoy/type/matcher/string.proto,"import ""envoy/type/matcher/regex.proto"";

    //
    // .. attention::
    //   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
    //   untrusted input in all cases.
    string regex = 4 [(validate.rules).string.max_bytes = 1024, deprecated = true];

    // The input string must match the regular expression specified here.
    RegexMatcher safe_regex = 5 [(validate.rules).message.required = true];",    string regex = 4 [(validate.rules).string.max_bytes = 1024];,eff020170c6267e6c8dc235473f7fc85c5b1e07d,CVE-2019-14993,eff020170c6267e6c8dc235473f7fc85c5b1e07d,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,106,COMPLETED,"VAR ""VAR/VAR/VAR/VAR.VAR"";     VAR VAR = 4 [(VAR.VAR).VAR.VAR = 1024, VAR = VAR];  VAR VAR = 5 [(VAR.VAR).VAR.VAR = VAR]; VAR VAR = 4 [(VAR.VAR).VAR.VAR = 1024];",0,5
envoy_eff020170c6267e6c8dc235473f7fc85c5b1e07d,api/envoy/type/matcher/string.proto,"import ""envoy/type/matcher/regex.proto"";

    //
    // .. attention::
    //   This field has been deprecated in favor of `safe_regex` as it is not safe for use with
    //   untrusted input in all cases.
    string regex = 4 [(validate.rules).string.max_bytes = 1024, deprecated = true];

    // The input string must match the regular expression specified here.
    RegexMatcher safe_regex = 5 [(validate.rules).message.required = true];",    string regex = 4 [(validate.rules).string.max_bytes = 1024];,eff020170c6267e6c8dc235473f7fc85c5b1e07d,CVE-2019-15225,eff020170c6267e6c8dc235473f7fc85c5b1e07d,https://github.com/envoyproxy/envoy,NVD_GIT_REPOBASED,106,COMPLETED,"VAR ""VAR/VAR/VAR/VAR.VAR"";     VAR VAR = 4 [(VAR.VAR).VAR.VAR = 1024, VAR = VAR];  VAR VAR = 5 [(VAR.VAR).VAR.VAR = VAR]; VAR VAR = 4 [(VAR.VAR).VAR.VAR = 1024];",0,5
FFmpeg_759001c534287a96dc96d1e274665feb7059145d,libavcodec/kmvc.c,"    AVFrame *frame = data;
    if ((ret = ff_get_buffer(avctx, frame, 0)) < 0) {
        frame->key_frame = 1;
        frame->pict_type = AV_PICTURE_TYPE_I;
        frame->key_frame = 0;
        frame->pict_type = AV_PICTURE_TYPE_P;
        frame->palette_has_changed = 1;
        frame->palette_has_changed = 1;
        frame->palette_has_changed = 1;
    memcpy(frame->data[1], ctx->pal, 1024);
    out = frame->data[0];
        out += frame->linesize[0];","    AVFrame pic;
    if (ctx->pic.data[0])
        avctx->release_buffer(avctx, &ctx->pic);
    ctx->pic.reference = 1;
    ctx->pic.buffer_hints = FF_BUFFER_HINTS_VALID;
    if ((ret = ff_get_buffer(avctx, &ctx->pic)) < 0) {
        ctx->pic.key_frame = 1;
        ctx->pic.pict_type = AV_PICTURE_TYPE_I;
        ctx->pic.key_frame = 0;
        ctx->pic.pict_type = AV_PICTURE_TYPE_P;
        ctx->pic.palette_has_changed = 1;
        ctx->pic.palette_has_changed = 1;
        ctx->pic.palette_has_changed = 1;
    memcpy(ctx->pic.data[1], ctx->pal, 1024);
    out = ctx->pic.data[0];
        out += ctx->pic.linesize[0];
    *(AVFrame *) data = ctx->pic;
    if (c->pic.data[0])
        avctx->release_buffer(avctx, &c->pic);",759001c534287a96dc96d1e274665feb7059145d,CVE-2011-3934,759001c534287a96dc96d1e274665feb7059145d,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,76,COMPLETED,"VAR *VAR = VAR; VAR ((VAR = VAR(VAR, VAR, 0)) < 0) { VAR->VAR = 1; VAR->VAR = VAR; VAR->VAR = 0; VAR->VAR = VAR; VAR->VAR = 1; VAR->VAR = 1; VAR->VAR = 1; VAR(VAR->VAR[1], VAR->VAR, 1024); VAR = VAR->VAR[0]; VAR += VAR->VAR[0]; VAR VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR); VAR->VAR.VAR = 1; VAR->VAR.VAR = VAR; VAR ((VAR = VAR(VAR, &VAR->VAR)) < 0) { VAR->VAR.VAR = 1; VAR->VAR.VAR = VAR; VAR->VAR.VAR = 0; VAR->VAR.VAR = VAR; VAR->VAR.VAR = 1; VAR->VAR.VAR = 1; VAR->VAR.VAR = 1; VAR(VAR->VAR.VAR[1], VAR->VAR, 1024); VAR = VAR->VAR.VAR[0]; VAR += VAR->VAR.VAR[0]; *(VAR *) VAR = VAR->VAR; VAR (VAR->VAR.VAR[0]) VAR->VAR(VAR, &VAR->VAR);",0,5
FFmpeg_a31ccacb1a9b2abc0e140a812fb0ffca6f7c2591,libavcodec/qdm2.c,"#define QDM2_MAX_FRAME_SIZE 512
    float output_buffer[QDM2_MAX_FRAME_SIZE * 2];
    if (s->channels > MPA_MAX_CHANNELS)
        return AVERROR_INVALIDDATA;
    if (s->frame_size > QDM2_MAX_FRAME_SIZE)
        return AVERROR_INVALIDDATA;",    float output_buffer[1024];,a31ccacb1a9b2abc0e140a812fb0ffca6f7c2591,CVE-2011-4351,a31ccacb1a9b2abc0e140a812fb0ffca6f7c2591,https://github.com/FFmpeg/FFmpeg,CPE_GIT_REPOBASED,74,COMPLETED, VAR VAR[VAR * 2]; VAR (VAR->VAR > VAR) VAR VAR; VAR (VAR->VAR > VAR) VAR VAR; VAR VAR[1024];,0,5
glpi_ad748d59c94da177a3ed25111c453902396f320c,install/update_084_085.php,"                 SET `rights` = `rights` | "" . 1024 /*Backup::CHECKUPDATE*/ .""","                 SET `rights` = `rights` | "" . Backup::CHECKUPDATE .""",ad748d59c94da177a3ed25111c453902396f320c,CVE-2020-11060,ad748d59c94da177a3ed25111c453902396f320c,https://github.com/glpi-project/glpi,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR `VAR` = `VAR` | "" . 1024 ."" VAR `VAR` = `VAR` | "" . VAR::VAR .""",0,5
go_4f5cd0c0331943c7ec72df3b827d972584f77833,src/net/http/cgi/child_test.go,"	""bufio""
	""bytes""
	""net/http""
	""net/http/httptest""
	""strings""

func TestResponse(t *testing.T) {
	var tests = []struct {
		name   string
		body   string
		wantCT string
	}{
		{
			name:   ""no body"",
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""html"",
			body:   ""<html><head><title>test page</title></head><body>This is a body</body></html>"",
			wantCT: ""text/html; charset=utf-8"",
		},
		{
			name:   ""text"",
			body:   strings.Repeat(""gopher"", 86),
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""jpg"",
			body:   ""\xFF\xD8\xFF"" + strings.Repeat(""B"", 1024),
			wantCT: ""image/jpeg"",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer
			resp := response{
				req:    httptest.NewRequest(""GET"", ""/"", nil),
				header: http.Header{},
				bufw:   bufio.NewWriter(&buf),
			}
			n, err := resp.Write([]byte(tt.body))
			if err != nil {
				t.Errorf(""Write: unexpected %v"", err)
			}
			if want := len(tt.body); n != want {
				t.Errorf(""reported short Write: got %v want %v"", n, want)
			}
			resp.writeCGIHeader(nil)
			resp.Flush()
			if got := resp.Header().Get(""Content-Type""); got != tt.wantCT {
				t.Errorf(""wrong content-type: got %q, want %q"", got, tt.wantCT)
			}
			if !bytes.HasSuffix(buf.Bytes(), []byte(tt.body)) {
				t.Errorf(""body was not correctly written"")
			}
		})
	}
}",,4f5cd0c0331943c7ec72df3b827d972584f77833,CVE-2020-24553,4f5cd0c0331943c7ec72df3b827d972584f77833,https://github.com/golang/go,CPE_GIT_REPOBASED,202,COMPLETED,"""VAR"" ""VAR"" ""VAR/VAR"" ""VAR/VAR/VAR"" ""VAR"" VAR VAR(VAR *VAR.VAR) { VAR VAR = []VAR { VAR VAR VAR VAR VAR VAR }{ { VAR: ""VAR VAR"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""<VAR><VAR><VAR>VAR VAR</VAR></VAR><VAR>VAR VAR VAR VAR</VAR></VAR>"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: VAR.VAR(""VAR"", 86), VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""\VAR\VAR\VAR"" + VAR.VAR(""VAR"", 1024), VAR: ""VAR/VAR"", }, } VAR VAR, VAR := VAR VAR { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR VAR VAR.VAR VAR := VAR{ VAR: VAR.VAR(""VAR"", ""/"", VAR), VAR: VAR.VAR{}, VAR: VAR.VAR(&VAR), } VAR, VAR := VAR.VAR([]VAR(VAR.VAR)) VAR VAR != VAR { VAR.VAR(""VAR: VAR %VAR"", VAR) } VAR VAR := VAR(VAR.VAR); VAR != VAR { VAR.VAR(""VAR VAR VAR: VAR %VAR VAR %VAR"", VAR, VAR) } VAR.VAR(VAR) VAR.VAR() VAR VAR := VAR.VAR().VAR(""VAR-VAR""); VAR != VAR.VAR { VAR.VAR(""VAR VAR-VAR: VAR %VAR, VAR %VAR"", VAR, VAR.VAR) } VAR !VAR.VAR(VAR.VAR(), []VAR(VAR.VAR)) { VAR.VAR(""VAR VAR VAR VAR VAR"") } }) } } ",0,5
go_4f5cd0c0331943c7ec72df3b827d972584f77833,src/net/http/cgi/integration_test.go,"	""net/url""
	""strings""
	if expected, got := ""text/plain; charset=utf-8"", replay.Header().Get(""Content-Type""); got != expected {
func TestChildContentType(t *testing.T) {
	testenv.MustHaveExec(t)

	h := &Handler{
		Path: os.Args[0],
		Root: ""/test.go"",
		Args: []string{""-test.run=TestBeChildCGIProcess""},
	}
	var tests = []struct {
		name   string
		body   string
		wantCT string
	}{
		{
			name:   ""no body"",
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""html"",
			body:   ""<html><head><title>test page</title></head><body>This is a body</body></html>"",
			wantCT: ""text/html; charset=utf-8"",
		},
		{
			name:   ""text"",
			body:   strings.Repeat(""gopher"", 86),
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""jpg"",
			body:   ""\xFF\xD8\xFF"" + strings.Repeat(""B"", 1024),
			wantCT: ""image/jpeg"",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			expectedMap := map[string]string{""_body"": tt.body}
			req := fmt.Sprintf(""GET /test.go?exact-body=%s HTTP/1.0\nHost: example.com\n\n"", url.QueryEscape(tt.body))
			replay := runCgiTest(t, h, req, expectedMap)
			if got := replay.Header().Get(""Content-Type""); got != tt.wantCT {
				t.Errorf(""got a Content-Type of %q; expected it to start with %q"", got, tt.wantCT)
			}
		})
	}
}

		if eb, ok := req.Form[""exact-body""]; ok {
			io.WriteString(rw, eb[0])
			return
		}","	if expected, got := ""text/html; charset=utf-8"", replay.Header().Get(""Content-Type""); got != expected {",4f5cd0c0331943c7ec72df3b827d972584f77833,CVE-2020-24553,4f5cd0c0331943c7ec72df3b827d972584f77833,https://github.com/golang/go,CPE_GIT_REPOBASED,202,COMPLETED,"""VAR/VAR"" ""VAR"" VAR VAR, VAR := ""VAR/VAR; VAR=VAR-8"", VAR.VAR().VAR(""VAR-VAR""); VAR != VAR { VAR VAR(VAR *VAR.VAR) { VAR.VAR(VAR) VAR := &VAR{ VAR: VAR.VAR[0], VAR: ""/VAR.VAR"", VAR: []VAR{""-VAR.VAR=VAR""}, } VAR VAR = []VAR { VAR VAR VAR VAR VAR VAR }{ { VAR: ""VAR VAR"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""<VAR><VAR><VAR>VAR VAR</VAR></VAR><VAR>VAR VAR VAR VAR</VAR></VAR>"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: VAR.VAR(""VAR"", 86), VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""\VAR\VAR\VAR"" + VAR.VAR(""VAR"", 1024), VAR: ""VAR/VAR"", }, } VAR VAR, VAR := VAR VAR { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR := VAR[VAR]VAR{""VAR"": VAR.VAR} VAR := VAR.VAR(""VAR /VAR.VAR?VAR-VAR=%VAR VAR/1.0\VAR: VAR.VAR\VAR\VAR"", VAR.VAR(VAR.VAR)) VAR := VAR(VAR, VAR, VAR, VAR) VAR VAR := VAR.VAR().VAR(""VAR-VAR""); VAR != VAR.VAR { VAR.VAR(""VAR VAR VAR-VAR VAR %VAR; VAR VAR VAR VAR VAR %VAR"", VAR, VAR.VAR) } }) } } VAR VAR, VAR := VAR.VAR[""VAR-VAR""]; VAR { VAR.VAR(VAR, VAR[0]) VAR } VAR VAR, VAR := ""VAR/VAR; VAR=VAR-8"", VAR.VAR().VAR(""VAR-VAR""); VAR != VAR {",0,5
go_4f5cd0c0331943c7ec72df3b827d972584f77833,src/net/http/fcgi/fcgi_test.go,"	""strings""

func TestResponseWriterSniffsContentType(t *testing.T) {
	var tests = []struct {
		name   string
		body   string
		wantCT string
	}{
		{
			name:   ""no body"",
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""html"",
			body:   ""<html><head><title>test page</title></head><body>This is a body</body></html>"",
			wantCT: ""text/html; charset=utf-8"",
		},
		{
			name:   ""text"",
			body:   strings.Repeat(""gopher"", 86),
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""jpg"",
			body:   ""\xFF\xD8\xFF"" + strings.Repeat(""B"", 1024),
			wantCT: ""image/jpeg"",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			input := make([]byte, len(streamFullRequestStdin))
			copy(input, streamFullRequestStdin)
			rc := nopWriteCloser{bytes.NewBuffer(input)}
			done := make(chan bool)
			var resp *response
			c := newChild(rc, http.HandlerFunc(func(
				w http.ResponseWriter,
				r *http.Request,
			) {
				io.WriteString(w, tt.body)
				resp = w.(*response)
				done <- true
			}))
			defer c.cleanUp()
			go c.serve()
			<-done
			if got := resp.Header().Get(""Content-Type""); got != tt.wantCT {
				t.Errorf(""got a Content-Type of %q; expected it to start with %q"", got, tt.wantCT)
			}
		})
	}
}",,4f5cd0c0331943c7ec72df3b827d972584f77833,CVE-2020-24553,4f5cd0c0331943c7ec72df3b827d972584f77833,https://github.com/golang/go,CPE_GIT_REPOBASED,202,COMPLETED,"""VAR"" VAR VAR(VAR *VAR.VAR) { VAR VAR = []VAR { VAR VAR VAR VAR VAR VAR }{ { VAR: ""VAR VAR"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""<VAR><VAR><VAR>VAR VAR</VAR></VAR><VAR>VAR VAR VAR VAR</VAR></VAR>"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: VAR.VAR(""VAR"", 86), VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""\VAR\VAR\VAR"" + VAR.VAR(""VAR"", 1024), VAR: ""VAR/VAR"", }, } VAR VAR, VAR := VAR VAR { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR := VAR([]VAR, VAR(VAR)) VAR(VAR, VAR) VAR := VAR{VAR.VAR(VAR)} VAR := VAR(VAR VAR) VAR VAR *VAR VAR := VAR(VAR, VAR.VAR(VAR( VAR VAR.VAR, VAR *VAR.VAR, ) { VAR.VAR(VAR, VAR.VAR) VAR = VAR.(*VAR) VAR <- VAR })) VAR VAR.VAR() VAR VAR.VAR() <-VAR VAR VAR := VAR.VAR().VAR(""VAR-VAR""); VAR != VAR.VAR { VAR.VAR(""VAR VAR VAR-VAR VAR %VAR; VAR VAR VAR VAR VAR %VAR"", VAR, VAR.VAR) } }) } } ",0,5
go_8fcee8abbea1bb959c63a6944f9ddf490a97f802,src/net/http/cgi/child_test.go,"	""bufio""
	""bytes""
	""net/http""
	""net/http/httptest""
	""strings""

type countingWriter int

func (c *countingWriter) Write(p []byte) (int, error) {
	*c += countingWriter(len(p))
	return len(p), nil
}
func (c *countingWriter) WriteString(p string) (int, error) {
	*c += countingWriter(len(p))
	return len(p), nil
}

func TestResponse(t *testing.T) {
	var tests = []struct {
		name   string
		body   string
		wantCT string
	}{
		{
			name:   ""no body"",
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""html"",
			body:   ""<html><head><title>test page</title></head><body>This is a body</body></html>"",
			wantCT: ""text/html; charset=utf-8"",
		},
		{
			name:   ""text"",
			body:   strings.Repeat(""gopher"", 86),
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""jpg"",
			body:   ""\xFF\xD8\xFF"" + strings.Repeat(""B"", 1024),
			wantCT: ""image/jpeg"",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer
			resp := response{
				req:    httptest.NewRequest(""GET"", ""/"", nil),
				header: http.Header{},
				bufw:   bufio.NewWriter(&buf),
			}
			n, err := resp.Write([]byte(tt.body))
			if err != nil {
				t.Errorf(""Write: unexpected %v"", err)
			}
			if want := len(tt.body); n != want {
				t.Errorf(""reported short Write: got %v want %v"", n, want)
			}
			resp.writeCGIHeader(nil)
			resp.Flush()
			if got := resp.Header().Get(""Content-Type""); got != tt.wantCT {
				t.Errorf(""wrong content-type: got %q, want %q"", got, tt.wantCT)
			}
			if !bytes.HasSuffix(buf.Bytes(), []byte(tt.body)) {
				t.Errorf(""body was not correctly written"")
			}
		})
	}
}",,8fcee8abbea1bb959c63a6944f9ddf490a97f802,CVE-2020-24553,8fcee8abbea1bb959c63a6944f9ddf490a97f802,https://github.com/golang/go,CPE_GIT_REPOBASED,100,COMPLETED,"""VAR"" ""VAR"" ""VAR/VAR"" ""VAR/VAR/VAR"" ""VAR"" VAR VAR VAR VAR (VAR *VAR) VAR(VAR []VAR) (VAR, VAR) { *VAR += VAR(VAR(VAR)) VAR VAR(VAR), VAR } VAR (VAR *VAR) VAR(VAR VAR) (VAR, VAR) { *VAR += VAR(VAR(VAR)) VAR VAR(VAR), VAR } VAR VAR(VAR *VAR.VAR) { VAR VAR = []VAR { VAR VAR VAR VAR VAR VAR }{ { VAR: ""VAR VAR"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""<VAR><VAR><VAR>VAR VAR</VAR></VAR><VAR>VAR VAR VAR VAR</VAR></VAR>"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: VAR.VAR(""VAR"", 86), VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""\VAR\VAR\VAR"" + VAR.VAR(""VAR"", 1024), VAR: ""VAR/VAR"", }, } VAR VAR, VAR := VAR VAR { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR VAR VAR.VAR VAR := VAR{ VAR: VAR.VAR(""VAR"", ""/"", VAR), VAR: VAR.VAR{}, VAR: VAR.VAR(&VAR), } VAR, VAR := VAR.VAR([]VAR(VAR.VAR)) VAR VAR != VAR { VAR.VAR(""VAR: VAR %VAR"", VAR) } VAR VAR := VAR(VAR.VAR); VAR != VAR { VAR.VAR(""VAR VAR VAR: VAR %VAR VAR %VAR"", VAR, VAR) } VAR.VAR(VAR) VAR.VAR() VAR VAR := VAR.VAR().VAR(""VAR-VAR""); VAR != VAR.VAR { VAR.VAR(""VAR VAR-VAR: VAR %VAR, VAR %VAR"", VAR, VAR.VAR) } VAR !VAR.VAR(VAR.VAR(), []VAR(VAR.VAR)) { VAR.VAR(""VAR VAR VAR VAR VAR"") } }) } } ",0,5
go_8fcee8abbea1bb959c63a6944f9ddf490a97f802,src/net/http/cgi/integration_test.go,"	""net/url""
	""strings""
	if expected, got := ""text/plain; charset=utf-8"", replay.Header().Get(""Content-Type""); got != expected {
func TestChildContentType(t *testing.T) {
	testenv.MustHaveExec(t)

	h := &Handler{
		Path: os.Args[0],
		Root: ""/test.go"",
		Args: []string{""-test.run=TestBeChildCGIProcess""},
	}
	var tests = []struct {
		name   string
		body   string
		wantCT string
	}{
		{
			name:   ""no body"",
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""html"",
			body:   ""<html><head><title>test page</title></head><body>This is a body</body></html>"",
			wantCT: ""text/html; charset=utf-8"",
		},
		{
			name:   ""text"",
			body:   strings.Repeat(""gopher"", 86),
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""jpg"",
			body:   ""\xFF\xD8\xFF"" + strings.Repeat(""B"", 1024),
			wantCT: ""image/jpeg"",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			expectedMap := map[string]string{""_body"": tt.body}
			req := fmt.Sprintf(""GET /test.go?exact-body=%s HTTP/1.0\nHost: example.com\n\n"", url.QueryEscape(tt.body))
			replay := runCgiTest(t, h, req, expectedMap)
			if got := replay.Header().Get(""Content-Type""); got != tt.wantCT {
				t.Errorf(""got a Content-Type of %q; expected it to start with %q"", got, tt.wantCT)
			}
		})
	}
}

		if eb, ok := req.Form[""exact-body""]; ok {
			io.WriteString(rw, eb[0])
			return
		}","	if expected, got := ""text/html; charset=utf-8"", replay.Header().Get(""Content-Type""); got != expected {",8fcee8abbea1bb959c63a6944f9ddf490a97f802,CVE-2020-24553,8fcee8abbea1bb959c63a6944f9ddf490a97f802,https://github.com/golang/go,CPE_GIT_REPOBASED,100,COMPLETED,"""VAR/VAR"" ""VAR"" VAR VAR, VAR := ""VAR/VAR; VAR=VAR-8"", VAR.VAR().VAR(""VAR-VAR""); VAR != VAR { VAR VAR(VAR *VAR.VAR) { VAR.VAR(VAR) VAR := &VAR{ VAR: VAR.VAR[0], VAR: ""/VAR.VAR"", VAR: []VAR{""-VAR.VAR=VAR""}, } VAR VAR = []VAR { VAR VAR VAR VAR VAR VAR }{ { VAR: ""VAR VAR"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""<VAR><VAR><VAR>VAR VAR</VAR></VAR><VAR>VAR VAR VAR VAR</VAR></VAR>"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: VAR.VAR(""VAR"", 86), VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""\VAR\VAR\VAR"" + VAR.VAR(""VAR"", 1024), VAR: ""VAR/VAR"", }, } VAR VAR, VAR := VAR VAR { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR := VAR[VAR]VAR{""VAR"": VAR.VAR} VAR := VAR.VAR(""VAR /VAR.VAR?VAR-VAR=%VAR VAR/1.0\VAR: VAR.VAR\VAR\VAR"", VAR.VAR(VAR.VAR)) VAR := VAR(VAR, VAR, VAR, VAR) VAR VAR := VAR.VAR().VAR(""VAR-VAR""); VAR != VAR.VAR { VAR.VAR(""VAR VAR VAR-VAR VAR %VAR; VAR VAR VAR VAR VAR %VAR"", VAR, VAR.VAR) } }) } } VAR VAR, VAR := VAR.VAR[""VAR-VAR""]; VAR { VAR.VAR(VAR, VAR[0]) VAR } VAR VAR, VAR := ""VAR/VAR; VAR=VAR-8"", VAR.VAR().VAR(""VAR-VAR""); VAR != VAR {",0,5
go_8fcee8abbea1bb959c63a6944f9ddf490a97f802,src/net/http/fcgi/fcgi_test.go,"	""strings""

func TestResponseWriterSniffsContentType(t *testing.T) {
	var tests = []struct {
		name   string
		body   string
		wantCT string
	}{
		{
			name:   ""no body"",
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""html"",
			body:   ""<html><head><title>test page</title></head><body>This is a body</body></html>"",
			wantCT: ""text/html; charset=utf-8"",
		},
		{
			name:   ""text"",
			body:   strings.Repeat(""gopher"", 86),
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""jpg"",
			body:   ""\xFF\xD8\xFF"" + strings.Repeat(""B"", 1024),
			wantCT: ""image/jpeg"",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			input := make([]byte, len(streamFullRequestStdin))
			copy(input, streamFullRequestStdin)
			rc := nopWriteCloser{bytes.NewBuffer(input)}
			done := make(chan bool)
			var resp *response
			c := newChild(rc, http.HandlerFunc(func(
				w http.ResponseWriter,
				r *http.Request,
			) {
				io.WriteString(w, tt.body)
				resp = w.(*response)
				done <- true
			}))
			defer c.cleanUp()
			go c.serve()
			<-done
			if got := resp.Header().Get(""Content-Type""); got != tt.wantCT {
				t.Errorf(""got a Content-Type of %q; expected it to start with %q"", got, tt.wantCT)
			}
		})
	}
}",,8fcee8abbea1bb959c63a6944f9ddf490a97f802,CVE-2020-24553,8fcee8abbea1bb959c63a6944f9ddf490a97f802,https://github.com/golang/go,CPE_GIT_REPOBASED,100,COMPLETED,"""VAR"" VAR VAR(VAR *VAR.VAR) { VAR VAR = []VAR { VAR VAR VAR VAR VAR VAR }{ { VAR: ""VAR VAR"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""<VAR><VAR><VAR>VAR VAR</VAR></VAR><VAR>VAR VAR VAR VAR</VAR></VAR>"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: VAR.VAR(""VAR"", 86), VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""\VAR\VAR\VAR"" + VAR.VAR(""VAR"", 1024), VAR: ""VAR/VAR"", }, } VAR VAR, VAR := VAR VAR { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR := VAR([]VAR, VAR(VAR)) VAR(VAR, VAR) VAR := VAR{VAR.VAR(VAR)} VAR := VAR(VAR VAR) VAR VAR *VAR VAR := VAR(VAR, VAR.VAR(VAR( VAR VAR.VAR, VAR *VAR.VAR, ) { VAR.VAR(VAR, VAR.VAR) VAR = VAR.(*VAR) VAR <- VAR })) VAR VAR.VAR() VAR VAR.VAR() <-VAR VAR VAR := VAR.VAR().VAR(""VAR-VAR""); VAR != VAR.VAR { VAR.VAR(""VAR VAR VAR-VAR VAR %VAR; VAR VAR VAR VAR VAR %VAR"", VAR, VAR.VAR) } }) } } ",0,5
go_accf363d5da864521c90b152fb734f3f15e00521,src/net/http/httputil/reverseproxy_test.go,"// Issue #46866: panic without closing incoming request body causes a panic
func TestReverseProxy_PanicClosesIncomingBody(t *testing.T) {
	backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		out := ""this call was relayed by the reverse proxy""
		// Coerce a wrong content length to induce io.ErrUnexpectedEOF
		w.Header().Set(""Content-Length"", fmt.Sprintf(""%d"", len(out)*2))
		fmt.Fprintln(w, out)
	}))
	defer backend.Close()
	backendURL, err := url.Parse(backend.URL)
	if err != nil {
		t.Fatal(err)
	}
	proxyHandler := NewSingleHostReverseProxy(backendURL)
	proxyHandler.ErrorLog = log.New(io.Discard, """", 0) // quiet for tests
	frontend := httptest.NewServer(proxyHandler)
	defer frontend.Close()
	frontendClient := frontend.Client()

	var wg sync.WaitGroup
	for i := 0; i < 2; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < 10; j++ {
				const reqLen = 6 * 1024 * 1024
				req, _ := http.NewRequest(""POST"", frontend.URL, &io.LimitedReader{R: neverEnding('x'), N: reqLen})
				req.ContentLength = reqLen
				resp, _ := frontendClient.Transport.RoundTrip(req)
				if resp != nil {
					io.Copy(io.Discard, resp.Body)
					resp.Body.Close()
				}
			}
		}()
	}
	wg.Wait()
}
",,accf363d5da864521c90b152fb734f3f15e00521,CVE-2021-36221,accf363d5da864521c90b152fb734f3f15e00521,https://github.com/golang/go,CPE_GIT_REPOBASED,194,COMPLETED," VAR VAR(VAR *VAR.VAR) { VAR := VAR.VAR(VAR.VAR(VAR(VAR VAR.VAR, VAR *VAR.VAR) { VAR := ""VAR VAR VAR VAR VAR VAR VAR VAR""  VAR.VAR().VAR(""VAR-VAR"", VAR.VAR(""%VAR"", VAR(VAR)*2)) VAR.VAR(VAR, VAR) })) VAR VAR.VAR() VAR, VAR := VAR.VAR(VAR.VAR) VAR VAR != VAR { VAR.VAR(VAR) } VAR := VAR(VAR) VAR.VAR = VAR.VAR(VAR.VAR, """", 0)  VAR := VAR.VAR(VAR) VAR VAR.VAR() VAR := VAR.VAR() VAR VAR VAR.VAR VAR VAR := 0; VAR < 2; VAR++ { VAR.VAR(1) VAR VAR() { VAR VAR.VAR() VAR VAR := 0; VAR < 10; VAR++ { VAR VAR = 6 * 1024 * 1024 VAR, VAR := VAR.VAR(""VAR"", VAR.VAR, &VAR.VAR{VAR: VAR('VAR'), VAR: VAR}) VAR.VAR = VAR VAR, VAR := VAR.VAR.VAR(VAR) VAR VAR != VAR { VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR.VAR() } } }() } VAR.VAR() } ",4,5
go_b7a85e0003cedb1b48a1fd3ae5b746ec6330102e,src/net/http/httputil/reverseproxy_test.go,"// Issue #46866: panic without closing incoming request body causes a panic
func TestReverseProxy_PanicClosesIncomingBody(t *testing.T) {
	backend := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		out := ""this call was relayed by the reverse proxy""
		// Coerce a wrong content length to induce io.ErrUnexpectedEOF
		w.Header().Set(""Content-Length"", fmt.Sprintf(""%d"", len(out)*2))
		fmt.Fprintln(w, out)
	}))
	defer backend.Close()
	backendURL, err := url.Parse(backend.URL)
	if err != nil {
		t.Fatal(err)
	}
	proxyHandler := NewSingleHostReverseProxy(backendURL)
	proxyHandler.ErrorLog = log.New(io.Discard, """", 0) // quiet for tests
	frontend := httptest.NewServer(proxyHandler)
	defer frontend.Close()
	frontendClient := frontend.Client()

	var wg sync.WaitGroup
	for i := 0; i < 2; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for j := 0; j < 10; j++ {
				const reqLen = 6 * 1024 * 1024
				req, _ := http.NewRequest(""POST"", frontend.URL, &io.LimitedReader{R: neverEnding('x'), N: reqLen})
				req.ContentLength = reqLen
				resp, _ := frontendClient.Transport.RoundTrip(req)
				if resp != nil {
					io.Copy(io.Discard, resp.Body)
					resp.Body.Close()
				}
			}
		}()
	}
	wg.Wait()
}
",,b7a85e0003cedb1b48a1fd3ae5b746ec6330102e,CVE-2021-36221,b7a85e0003cedb1b48a1fd3ae5b746ec6330102e,https://github.com/golang/go,CPE_GIT_REPOBASED,194,COMPLETED," VAR VAR(VAR *VAR.VAR) { VAR := VAR.VAR(VAR.VAR(VAR(VAR VAR.VAR, VAR *VAR.VAR) { VAR := ""VAR VAR VAR VAR VAR VAR VAR VAR""  VAR.VAR().VAR(""VAR-VAR"", VAR.VAR(""%VAR"", VAR(VAR)*2)) VAR.VAR(VAR, VAR) })) VAR VAR.VAR() VAR, VAR := VAR.VAR(VAR.VAR) VAR VAR != VAR { VAR.VAR(VAR) } VAR := VAR(VAR) VAR.VAR = VAR.VAR(VAR.VAR, """", 0)  VAR := VAR.VAR(VAR) VAR VAR.VAR() VAR := VAR.VAR() VAR VAR VAR.VAR VAR VAR := 0; VAR < 2; VAR++ { VAR.VAR(1) VAR VAR() { VAR VAR.VAR() VAR VAR := 0; VAR < 10; VAR++ { VAR VAR = 6 * 1024 * 1024 VAR, VAR := VAR.VAR(""VAR"", VAR.VAR, &VAR.VAR{VAR: VAR('VAR'), VAR: VAR}) VAR.VAR = VAR VAR, VAR := VAR.VAR.VAR(VAR) VAR VAR != VAR { VAR.VAR(VAR.VAR, VAR.VAR) VAR.VAR.VAR() } } }() } VAR.VAR() } ",4,5
go_ea6b5a64dd5bf68b33286436ffbe06f68a1fdbfd,src/mime/multipart/formdata.go,"	var copyBuf []byte
			if _, err := file.Write(b.Bytes()); err != nil {
				return nil, err
			}
			if copyBuf == nil {
				copyBuf = make([]byte, 32*1024) // same buffer size as io.Copy uses
			}
			// os.File.ReadFrom will allocate its own copy buffer if we let io.Copy use it.
			type writerOnly struct{ io.Writer }
			remainingSize, err := io.CopyBuffer(writerOnly{file}, p, copyBuf)
			fh.Size = int64(b.Len()) + remainingSize
			fileOff += fh.Size","			size, err := io.Copy(file, io.MultiReader(&b, p))
			fh.Size = size
			fileOff += size",ea6b5a64dd5bf68b33286436ffbe06f68a1fdbfd,CVE-2023-24536,ea6b5a64dd5bf68b33286436ffbe06f68a1fdbfd,https://github.com/golang/go,CPE_GIT_REPOBASED,226,COMPLETED,"VAR VAR []VAR VAR VAR, VAR := VAR.VAR(VAR.VAR()); VAR != VAR { VAR VAR, VAR } VAR VAR == VAR { VAR = VAR([]VAR, 32*1024)  }  VAR VAR VAR{ VAR.VAR } VAR, VAR := VAR.VAR(VAR{VAR}, VAR, VAR) VAR.VAR = VAR(VAR.VAR()) + VAR VAR += VAR.VAR VAR, VAR := VAR.VAR(VAR, VAR.VAR(&VAR, VAR)) VAR.VAR = VAR VAR += VAR",0,5
go_eb07103a083237414145a45f029c873d57037e06,src/net/http/cgi/child_test.go,"	""bufio""
	""bytes""
	""net/http""
	""net/http/httptest""
	""strings""

type countingWriter int

func (c *countingWriter) Write(p []byte) (int, error) {
	*c += countingWriter(len(p))
	return len(p), nil
}
func (c *countingWriter) WriteString(p string) (int, error) {
	*c += countingWriter(len(p))
	return len(p), nil
}

func TestResponse(t *testing.T) {
	var tests = []struct {
		name   string
		body   string
		wantCT string
	}{
		{
			name:   ""no body"",
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""html"",
			body:   ""<html><head><title>test page</title></head><body>This is a body</body></html>"",
			wantCT: ""text/html; charset=utf-8"",
		},
		{
			name:   ""text"",
			body:   strings.Repeat(""gopher"", 86),
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""jpg"",
			body:   ""\xFF\xD8\xFF"" + strings.Repeat(""B"", 1024),
			wantCT: ""image/jpeg"",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var buf bytes.Buffer
			resp := response{
				req:    httptest.NewRequest(""GET"", ""/"", nil),
				header: http.Header{},
				bufw:   bufio.NewWriter(&buf),
			}
			n, err := resp.Write([]byte(tt.body))
			if err != nil {
				t.Errorf(""Write: unexpected %v"", err)
			}
			if want := len(tt.body); n != want {
				t.Errorf(""reported short Write: got %v want %v"", n, want)
			}
			resp.writeCGIHeader(nil)
			resp.Flush()
			if got := resp.Header().Get(""Content-Type""); got != tt.wantCT {
				t.Errorf(""wrong content-type: got %q, want %q"", got, tt.wantCT)
			}
			if !bytes.HasSuffix(buf.Bytes(), []byte(tt.body)) {
				t.Errorf(""body was not correctly written"")
			}
		})
	}
}",,eb07103a083237414145a45f029c873d57037e06,CVE-2020-24553,eb07103a083237414145a45f029c873d57037e06,https://github.com/golang/go,CPE_GIT_REPOBASED,100,COMPLETED,"""VAR"" ""VAR"" ""VAR/VAR"" ""VAR/VAR/VAR"" ""VAR"" VAR VAR VAR VAR (VAR *VAR) VAR(VAR []VAR) (VAR, VAR) { *VAR += VAR(VAR(VAR)) VAR VAR(VAR), VAR } VAR (VAR *VAR) VAR(VAR VAR) (VAR, VAR) { *VAR += VAR(VAR(VAR)) VAR VAR(VAR), VAR } VAR VAR(VAR *VAR.VAR) { VAR VAR = []VAR { VAR VAR VAR VAR VAR VAR }{ { VAR: ""VAR VAR"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""<VAR><VAR><VAR>VAR VAR</VAR></VAR><VAR>VAR VAR VAR VAR</VAR></VAR>"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: VAR.VAR(""VAR"", 86), VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""\VAR\VAR\VAR"" + VAR.VAR(""VAR"", 1024), VAR: ""VAR/VAR"", }, } VAR VAR, VAR := VAR VAR { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR VAR VAR.VAR VAR := VAR{ VAR: VAR.VAR(""VAR"", ""/"", VAR), VAR: VAR.VAR{}, VAR: VAR.VAR(&VAR), } VAR, VAR := VAR.VAR([]VAR(VAR.VAR)) VAR VAR != VAR { VAR.VAR(""VAR: VAR %VAR"", VAR) } VAR VAR := VAR(VAR.VAR); VAR != VAR { VAR.VAR(""VAR VAR VAR: VAR %VAR VAR %VAR"", VAR, VAR) } VAR.VAR(VAR) VAR.VAR() VAR VAR := VAR.VAR().VAR(""VAR-VAR""); VAR != VAR.VAR { VAR.VAR(""VAR VAR-VAR: VAR %VAR, VAR %VAR"", VAR, VAR.VAR) } VAR !VAR.VAR(VAR.VAR(), []VAR(VAR.VAR)) { VAR.VAR(""VAR VAR VAR VAR VAR"") } }) } } ",0,5
go_eb07103a083237414145a45f029c873d57037e06,src/net/http/cgi/integration_test.go,"	""net/url""
	""strings""
	if expected, got := ""text/plain; charset=utf-8"", replay.Header().Get(""Content-Type""); got != expected {
func TestChildContentType(t *testing.T) {
	testenv.MustHaveExec(t)

	h := &Handler{
		Path: os.Args[0],
		Root: ""/test.go"",
		Args: []string{""-test.run=TestBeChildCGIProcess""},
	}
	var tests = []struct {
		name   string
		body   string
		wantCT string
	}{
		{
			name:   ""no body"",
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""html"",
			body:   ""<html><head><title>test page</title></head><body>This is a body</body></html>"",
			wantCT: ""text/html; charset=utf-8"",
		},
		{
			name:   ""text"",
			body:   strings.Repeat(""gopher"", 86),
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""jpg"",
			body:   ""\xFF\xD8\xFF"" + strings.Repeat(""B"", 1024),
			wantCT: ""image/jpeg"",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			expectedMap := map[string]string{""_body"": tt.body}
			req := fmt.Sprintf(""GET /test.go?exact-body=%s HTTP/1.0\nHost: example.com\n\n"", url.QueryEscape(tt.body))
			replay := runCgiTest(t, h, req, expectedMap)
			if got := replay.Header().Get(""Content-Type""); got != tt.wantCT {
				t.Errorf(""got a Content-Type of %q; expected it to start with %q"", got, tt.wantCT)
			}
		})
	}
}

		if eb, ok := req.Form[""exact-body""]; ok {
			io.WriteString(rw, eb[0])
			return
		}","	if expected, got := ""text/html; charset=utf-8"", replay.Header().Get(""Content-Type""); got != expected {",eb07103a083237414145a45f029c873d57037e06,CVE-2020-24553,eb07103a083237414145a45f029c873d57037e06,https://github.com/golang/go,CPE_GIT_REPOBASED,100,COMPLETED,"""VAR/VAR"" ""VAR"" VAR VAR, VAR := ""VAR/VAR; VAR=VAR-8"", VAR.VAR().VAR(""VAR-VAR""); VAR != VAR { VAR VAR(VAR *VAR.VAR) { VAR.VAR(VAR) VAR := &VAR{ VAR: VAR.VAR[0], VAR: ""/VAR.VAR"", VAR: []VAR{""-VAR.VAR=VAR""}, } VAR VAR = []VAR { VAR VAR VAR VAR VAR VAR }{ { VAR: ""VAR VAR"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""<VAR><VAR><VAR>VAR VAR</VAR></VAR><VAR>VAR VAR VAR VAR</VAR></VAR>"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: VAR.VAR(""VAR"", 86), VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""\VAR\VAR\VAR"" + VAR.VAR(""VAR"", 1024), VAR: ""VAR/VAR"", }, } VAR VAR, VAR := VAR VAR { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR := VAR[VAR]VAR{""VAR"": VAR.VAR} VAR := VAR.VAR(""VAR /VAR.VAR?VAR-VAR=%VAR VAR/1.0\VAR: VAR.VAR\VAR\VAR"", VAR.VAR(VAR.VAR)) VAR := VAR(VAR, VAR, VAR, VAR) VAR VAR := VAR.VAR().VAR(""VAR-VAR""); VAR != VAR.VAR { VAR.VAR(""VAR VAR VAR-VAR VAR %VAR; VAR VAR VAR VAR VAR %VAR"", VAR, VAR.VAR) } }) } } VAR VAR, VAR := VAR.VAR[""VAR-VAR""]; VAR { VAR.VAR(VAR, VAR[0]) VAR } VAR VAR, VAR := ""VAR/VAR; VAR=VAR-8"", VAR.VAR().VAR(""VAR-VAR""); VAR != VAR {",0,5
go_eb07103a083237414145a45f029c873d57037e06,src/net/http/fcgi/fcgi_test.go,"	""strings""

func TestResponseWriterSniffsContentType(t *testing.T) {
	var tests = []struct {
		name   string
		body   string
		wantCT string
	}{
		{
			name:   ""no body"",
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""html"",
			body:   ""<html><head><title>test page</title></head><body>This is a body</body></html>"",
			wantCT: ""text/html; charset=utf-8"",
		},
		{
			name:   ""text"",
			body:   strings.Repeat(""gopher"", 86),
			wantCT: ""text/plain; charset=utf-8"",
		},
		{
			name:   ""jpg"",
			body:   ""\xFF\xD8\xFF"" + strings.Repeat(""B"", 1024),
			wantCT: ""image/jpeg"",
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			input := make([]byte, len(streamFullRequestStdin))
			copy(input, streamFullRequestStdin)
			rc := nopWriteCloser{bytes.NewBuffer(input)}
			done := make(chan bool)
			var resp *response
			c := newChild(rc, http.HandlerFunc(func(
				w http.ResponseWriter,
				r *http.Request,
			) {
				io.WriteString(w, tt.body)
				resp = w.(*response)
				done <- true
			}))
			defer c.cleanUp()
			go c.serve()
			<-done
			if got := resp.Header().Get(""Content-Type""); got != tt.wantCT {
				t.Errorf(""got a Content-Type of %q; expected it to start with %q"", got, tt.wantCT)
			}
		})
	}
}",,eb07103a083237414145a45f029c873d57037e06,CVE-2020-24553,eb07103a083237414145a45f029c873d57037e06,https://github.com/golang/go,CPE_GIT_REPOBASED,100,COMPLETED,"""VAR"" VAR VAR(VAR *VAR.VAR) { VAR VAR = []VAR { VAR VAR VAR VAR VAR VAR }{ { VAR: ""VAR VAR"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""<VAR><VAR><VAR>VAR VAR</VAR></VAR><VAR>VAR VAR VAR VAR</VAR></VAR>"", VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: VAR.VAR(""VAR"", 86), VAR: ""VAR/VAR; VAR=VAR-8"", }, { VAR: ""VAR"", VAR: ""\VAR\VAR\VAR"" + VAR.VAR(""VAR"", 1024), VAR: ""VAR/VAR"", }, } VAR VAR, VAR := VAR VAR { VAR.VAR(VAR.VAR, VAR(VAR *VAR.VAR) { VAR := VAR([]VAR, VAR(VAR)) VAR(VAR, VAR) VAR := VAR{VAR.VAR(VAR)} VAR := VAR(VAR VAR) VAR VAR *VAR VAR := VAR(VAR, VAR.VAR(VAR( VAR VAR.VAR, VAR *VAR.VAR, ) { VAR.VAR(VAR, VAR.VAR) VAR = VAR.(*VAR) VAR <- VAR })) VAR VAR.VAR() VAR VAR.VAR() <-VAR VAR VAR := VAR.VAR().VAR(""VAR-VAR""); VAR != VAR.VAR { VAR.VAR(""VAR VAR VAR-VAR VAR %VAR; VAR VAR VAR VAR VAR %VAR"", VAR, VAR.VAR) } }) } } ",0,5
go_ef41a4e2face45e580c5836eaebd51629fc23f15,src/mime/multipart/formdata.go,"	var copyBuf []byte
			if _, err := file.Write(b.Bytes()); err != nil {
				return nil, err
			}
			if copyBuf == nil {
				copyBuf = make([]byte, 32*1024) // same buffer size as io.Copy uses
			}
			// os.File.ReadFrom will allocate its own copy buffer if we let io.Copy use it.
			type writerOnly struct{ io.Writer }
			remainingSize, err := io.CopyBuffer(writerOnly{file}, p, copyBuf)
			fh.Size = int64(b.Len()) + remainingSize
			fileOff += fh.Size","			size, err := io.Copy(file, io.MultiReader(&b, p))
			fh.Size = size
			fileOff += size",ef41a4e2face45e580c5836eaebd51629fc23f15,CVE-2023-24536,ef41a4e2face45e580c5836eaebd51629fc23f15,https://github.com/golang/go,CPE_GIT_REPOBASED,162,COMPLETED,"VAR VAR []VAR VAR VAR, VAR := VAR.VAR(VAR.VAR()); VAR != VAR { VAR VAR, VAR } VAR VAR == VAR { VAR = VAR([]VAR, 32*1024)  }  VAR VAR VAR{ VAR.VAR } VAR, VAR := VAR.VAR(VAR{VAR}, VAR, VAR) VAR.VAR = VAR(VAR.VAR()) + VAR VAR += VAR.VAR VAR, VAR := VAR.VAR(VAR, VAR.VAR(&VAR, VAR)) VAR.VAR = VAR VAR += VAR",0,5
gpac_3dbe11b37d65c8472faf0654410068e5500b3adb,src/isomedia/box_code_3gpp.c,"	p->content_script_types = gf_malloc(sizeof(char) * (s->size+1));
	if (!p->content_script_types) return GF_OUT_OF_MEM;
	gf_bs_read_data(bs, p->content_script_types, s->size);
	p->content_script_types[s->size] = 0;","	u32 i;
	char str[1024];
	i=0;
	str[0]=0;
	while (1) {
		str[i] = gf_bs_read_u8(bs);
		if (!str[i]) break;
		i++;
	}
	ISOM_DECREASE_SIZE(p, i);

	p->content_script_types = gf_strdup(str);",3dbe11b37d65c8472faf0654410068e5500b3adb,CVE-2022-1441,3dbe11b37d65c8472faf0654410068e5500b3adb,https://github.com/gpac/gpac,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR->VAR = VAR(VAR(VAR) * (VAR->VAR+1)); VAR (!VAR->VAR) VAR VAR; VAR(VAR, VAR->VAR, VAR->VAR); VAR->VAR[VAR->VAR] = 0; VAR VAR; VAR VAR[1024]; VAR=0; VAR[0]=0; VAR (1) { VAR[VAR] = VAR(VAR); VAR (!VAR[VAR]) VAR; VAR++; } VAR(VAR, VAR); VAR->VAR = VAR(VAR);",0,5
gpac_74e53280dad7b29f85386c6a1286fb92643465da,src/isomedia/box_code_3gpp.c,"	u32 i, msize;
	char *str = gf_malloc(sizeof(char)*(p->size+1));
	if (!str) return GF_OUT_OF_MEM;
	msize = p->size;
	str[msize] = 0;
	while (i < msize) {
	if (i == msize) {
		gf_free(str);
		return GF_ISOM_INVALID_FILE;
	}
	while (i < msize) {
	if (i == msize) {
		gf_free(str);
		return GF_ISOM_INVALID_FILE;
	}
	gf_free(str);
	if (p->textEncoding || !p->contentEncoding)
		return GF_OUT_OF_MEM;","	char str[1024];
	u32 i;
	while (i < GF_ARRAY_LENGTH(str)) {
	while (i < GF_ARRAY_LENGTH(str)) {",74e53280dad7b29f85386c6a1286fb92643465da,CVE-2022-45204,74e53280dad7b29f85386c6a1286fb92643465da,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,118,COMPLETED,"VAR VAR, VAR; VAR *VAR = VAR(VAR(VAR)*(VAR->VAR+1)); VAR (!VAR) VAR VAR; VAR = VAR->VAR; VAR[VAR] = 0; VAR (VAR < VAR) { VAR (VAR == VAR) { VAR(VAR); VAR VAR; } VAR (VAR < VAR) { VAR (VAR == VAR) { VAR(VAR); VAR VAR; } VAR(VAR); VAR (VAR->VAR || !VAR->VAR) VAR VAR; VAR VAR[1024]; VAR VAR; VAR (VAR < VAR(VAR)) { VAR (VAR < VAR(VAR)) {",0,5
gpac_74e53280dad7b29f85386c6a1286fb92643465da,src/isomedia/box_code_3gpp.c,"	u32 i, msize;
	char *str = gf_malloc(sizeof(char)*(p->size+1));
	if (!str) return GF_OUT_OF_MEM;
	msize = p->size;
	str[msize] = 0;
	while (i < msize) {
	if (i == msize) {
		gf_free(str);
		return GF_ISOM_INVALID_FILE;
	}
	while (i < msize) {
	if (i == msize) {
		gf_free(str);
		return GF_ISOM_INVALID_FILE;
	}
	gf_free(str);
	if (p->textEncoding || !p->contentEncoding)
		return GF_OUT_OF_MEM;","	char str[1024];
	u32 i;
	while (i < GF_ARRAY_LENGTH(str)) {
	while (i < GF_ARRAY_LENGTH(str)) {",74e53280dad7b29f85386c6a1286fb92643465da,CVE-2022-45202,74e53280dad7b29f85386c6a1286fb92643465da,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,118,COMPLETED,"VAR VAR, VAR; VAR *VAR = VAR(VAR(VAR)*(VAR->VAR+1)); VAR (!VAR) VAR VAR; VAR = VAR->VAR; VAR[VAR] = 0; VAR (VAR < VAR) { VAR (VAR == VAR) { VAR(VAR); VAR VAR; } VAR (VAR < VAR) { VAR (VAR == VAR) { VAR(VAR); VAR VAR; } VAR(VAR); VAR (VAR->VAR || !VAR->VAR) VAR VAR; VAR VAR[1024]; VAR VAR; VAR (VAR < VAR(VAR)) { VAR (VAR < VAR(VAR)) {",0,5
gpac_da37ec8582266983d0ec4b7550ec907401ec441e,applications/gpac/main.c,"	char *alias_arg=NULL;

	gf_dynstrcat(&alias_arg, prefix, NULL);
					gf_free(alias_arg);
							gf_free(alias_arg);
			gf_free(alias_arg);
			gf_free(alias_arg);
				gf_free(alias_arg);
				alias_arg = NULL;
				gf_dynstrcat(&alias_arg, prefix, NULL);
				gf_dynstrcat(&alias_arg, an_arg, NULL);
				gf_dynstrcat(&alias_arg, suffix, NULL);
				Bool ok = check_param_extension(alias_arg, arg_idx, argc, argv);
					gf_free(alias_arg);
				gf_dynstrcat(&alias_arg, an_arg, NULL);
					gf_dynstrcat(&alias_arg, szSepList, NULL);
			gf_dynstrcat(&alias_arg, szSepList, NULL);
	if (is_expand) {
		gf_free(alias_arg);
	}
	gf_dynstrcat(&alias_arg, suffix, NULL);
	Bool res = check_param_extension(alias_arg, arg_idx, argc, argv);
	gf_free(alias_arg);
	return res;","	char szArg[1024];
	strcpy(szArg, prefix);
				strcpy(szArg, prefix);
				strcat(szArg, an_arg);
				strcat(szArg, suffix);
				Bool ok = check_param_extension(szArg, arg_idx, argc, argv);
				strcat(szArg, an_arg);
					strcat(szArg, szSepList);
			strcat(szArg, szSepList);
	if (is_expand)
	strcat(szArg, suffix);
	return check_param_extension(szArg, arg_idx, argc, argv);",da37ec8582266983d0ec4b7550ec907401ec441e,CVE-2021-40942,da37ec8582266983d0ec4b7550ec907401ec441e,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,118,COMPLETED,"VAR *VAR=VAR; VAR(&VAR, VAR, VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR(VAR); VAR = VAR; VAR(&VAR, VAR, VAR); VAR(&VAR, VAR, VAR); VAR(&VAR, VAR, VAR); VAR VAR = VAR(VAR, VAR, VAR, VAR); VAR(VAR); VAR(&VAR, VAR, VAR); VAR(&VAR, VAR, VAR); VAR(&VAR, VAR, VAR); VAR (VAR) { VAR(VAR); } VAR(&VAR, VAR, VAR); VAR VAR = VAR(VAR, VAR, VAR, VAR); VAR(VAR); VAR VAR; VAR VAR[1024]; VAR(VAR, VAR); VAR(VAR, VAR); VAR(VAR, VAR); VAR(VAR, VAR); VAR VAR = VAR(VAR, VAR, VAR, VAR); VAR(VAR, VAR); VAR(VAR, VAR); VAR(VAR, VAR); VAR (VAR) VAR(VAR, VAR); VAR VAR(VAR, VAR, VAR, VAR);",0,5
gpac_f4616202e5578e65746cf7e7ceeba63bee1b094b,src/media_tools/media_export.c,"		vsnprintf(szMsg, 1024, format, args);","		vsprintf(szMsg, format, args);",f4616202e5578e65746cf7e7ceeba63bee1b094b,CVE-2019-11221,f4616202e5578e65746cf7e7ceeba63bee1b094b,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,114,COMPLETED,"VAR(VAR, 1024, VAR, VAR); VAR(VAR, VAR, VAR);",0,5
gpac_f4616202e5578e65746cf7e7ceeba63bee1b094b,src/media_tools/media_import.c,"		vsnprintf(szMsg, 1024, format, args);","		vsprintf(szMsg, format, args);",f4616202e5578e65746cf7e7ceeba63bee1b094b,CVE-2019-11221,f4616202e5578e65746cf7e7ceeba63bee1b094b,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,114,COMPLETED,"VAR(VAR, 1024, VAR, VAR); VAR(VAR, VAR, VAR);",0,5
gpac_f4616202e5578e65746cf7e7ceeba63bee1b094b,src/scene_manager/loader_isom.c,"		vsnprintf(szMsg, 1024, format, args);","		vsprintf(szMsg, format, args);",f4616202e5578e65746cf7e7ceeba63bee1b094b,CVE-2019-11221,f4616202e5578e65746cf7e7ceeba63bee1b094b,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,114,COMPLETED,"VAR(VAR, 1024, VAR, VAR); VAR(VAR, VAR, VAR);",0,5
gpac_f4616202e5578e65746cf7e7ceeba63bee1b094b,src/scene_manager/loader_qt.c,"		vsnprintf(szMsg, 1024, format, args);","		vsprintf(szMsg, format, args);",f4616202e5578e65746cf7e7ceeba63bee1b094b,CVE-2019-11221,f4616202e5578e65746cf7e7ceeba63bee1b094b,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,114,COMPLETED,"VAR(VAR, 1024, VAR, VAR); VAR(VAR, VAR, VAR);",0,5
gpac_f4616202e5578e65746cf7e7ceeba63bee1b094b,src/utils/alloc.c,"	vsnprintf(msg, 1024, fmt, vl);","	vsprintf(msg, fmt, vl);",f4616202e5578e65746cf7e7ceeba63bee1b094b,CVE-2019-11221,f4616202e5578e65746cf7e7ceeba63bee1b094b,https://github.com/gpac/gpac,NVD_GIT_REPOBASED,114,COMPLETED,"VAR(VAR, 1024, VAR, VAR); VAR(VAR, VAR, VAR);",0,5
httpd_db47781128e42bd49f55076665b3f6ca4e2bc5e2,modules/filters/sed1.c,"#define MAX_BUF_SIZE 1024*8192
static apr_status_t grow_buffer(apr_pool_t *pool, char **buffer,
    if (*cursize >= newsize) {
        return APR_SUCCESS;
    }
    if (newsize > MAX_BUF_SIZE) {
        return APR_ENOMEM;
    }
    return APR_SUCCESS;
static apr_status_t grow_line_buffer(sed_eval_t *eval, apr_size_t newsize)
    return grow_buffer(eval->pool, &eval->linebuf, &eval->lspend,
static apr_status_t grow_hold_buffer(sed_eval_t *eval, apr_size_t newsize)
    return grow_buffer(eval->pool, &eval->holdbuf, &eval->hspend,
static apr_status_t grow_gen_buffer(sed_eval_t *eval, apr_size_t newsize,
    apr_status_t rc = 0;
    rc = grow_buffer(eval->pool, &eval->genbuf, gspend,
                     &eval->gsize, newsize);
    if (rc == APR_SUCCESS) {
        eval->lcomend = &eval->genbuf[71];
    }
    return rc;
static apr_status_t appendmem_to_linebuf(sed_eval_t *eval, const char* sz, apr_size_t len)
    apr_status_t rc = 0;
        rc = grow_line_buffer(eval, reqsize);
        if (rc != APR_SUCCESS) {
            return rc;
        }
    return APR_SUCCESS;
static apr_status_t append_to_linebuf(sed_eval_t *eval, const char* sz,
    apr_status_t rc = 0;
    rc = appendmem_to_linebuf(eval, sz, len + 1);
    if (rc != APR_SUCCESS) {
        return rc;
    }
    return APR_SUCCESS;
static apr_status_t copy_to_linebuf(sed_eval_t *eval, const char* sz,
    return append_to_linebuf(eval, sz, step_vars);
static apr_status_t append_to_holdbuf(sed_eval_t *eval, const char* sz)
    apr_status_t rc = 0;
        rc = grow_hold_buffer(eval, reqsize);
        if (rc != APR_SUCCESS) {
            return rc;
        }
    return APR_SUCCESS;
static apr_status_t copy_to_holdbuf(sed_eval_t *eval, const char* sz)
    return append_to_holdbuf(eval, sz);
static apr_status_t append_to_genbuf(sed_eval_t *eval, const char* sz, char **gspend)
    apr_status_t rc = 0;
        rc = grow_gen_buffer(eval, reqsize, gspend);
        if (rc != APR_SUCCESS) {
            return rc;
        }
    return APR_SUCCESS;
static apr_status_t copy_to_genbuf(sed_eval_t *eval, const char* sz)
    apr_status_t rc = APR_SUCCESS;;
        rc = grow_gen_buffer(eval, reqsize, NULL);
        if (rc != APR_SUCCESS) {
            return rc;
        }
    return rc;
        apr_status_t rc = 0;
        rc = appendmem_to_linebuf(eval, buf, llen + 1);
        if (rc != APR_SUCCESS) {
            return rc;
        }
        apr_status_t rc = appendmem_to_linebuf(eval, buf, bufsz);
        if (rc != APR_SUCCESS) {
            return rc;
        }
        apr_status_t rc = 0;
            rc = append_to_linebuf(eval, """", NULL);
            if (rc != APR_SUCCESS) {
                return rc;
            }
    if (sp == NULL) {
        return APR_EGENERAL;
    }
            if (sp == NULL) {
            }
            rv = grow_gen_buffer(eval, eval->gsize + 1024, &sp);
            if (rv != APR_SUCCESS) {
                return rv;
            }
    rv = append_to_genbuf(eval, lp, &sp);
    if (rv != APR_SUCCESS) {
        return rv;
    }
    rv = copy_to_linebuf(eval, eval->genbuf, step_vars);
        apr_status_t rc = grow_gen_buffer(eval, reqsize, &sp);
        if (rc != APR_SUCCESS) {
            return NULL;
        }
            rv = copy_to_linebuf(eval, p1, step_vars);
            if (rv != APR_SUCCESS) return rv;
            rv = copy_to_linebuf(eval, eval->holdbuf, step_vars);
            if (rv != APR_SUCCESS) return rv;
            rv = append_to_linebuf(eval, ""\n"", step_vars);
            if (rv != APR_SUCCESS) return rv;
            rv = append_to_linebuf(eval, eval->holdbuf, step_vars);
            if (rv != APR_SUCCESS) return rv;
            rv = copy_to_holdbuf(eval, eval->linebuf);
            if (rv != APR_SUCCESS) return rv;
            rv = append_to_holdbuf(eval, ""\n"");
            if (rv != APR_SUCCESS) return rv;
            rv = append_to_holdbuf(eval, eval->linebuf);
            if (rv != APR_SUCCESS) return rv;
            rv = append_to_linebuf(eval, ""\n"", step_vars);
            if (rv != APR_SUCCESS) return rv;
            rv = copy_to_genbuf(eval, eval->linebuf);
            if (rv != APR_SUCCESS) return rv;
            rv = copy_to_linebuf(eval, eval->holdbuf, step_vars);
            if (rv != APR_SUCCESS) return rv;
            rv = copy_to_holdbuf(eval, eval->genbuf);
            if (rv != APR_SUCCESS) return rv;","static void grow_buffer(apr_pool_t *pool, char **buffer,
    if (*cursize >= newsize)
        return;
static void grow_line_buffer(sed_eval_t *eval, apr_size_t newsize)
    grow_buffer(eval->pool, &eval->linebuf, &eval->lspend,
static void grow_hold_buffer(sed_eval_t *eval, apr_size_t newsize)
    grow_buffer(eval->pool, &eval->holdbuf, &eval->hspend,
static void grow_gen_buffer(sed_eval_t *eval, apr_size_t newsize,
    grow_buffer(eval->pool, &eval->genbuf, gspend,
                &eval->gsize, newsize);
    eval->lcomend = &eval->genbuf[71];
static void appendmem_to_linebuf(sed_eval_t *eval, const char* sz, apr_size_t len)
        grow_line_buffer(eval, reqsize);
static void append_to_linebuf(sed_eval_t *eval, const char* sz,
    appendmem_to_linebuf(eval, sz, len + 1);
static void copy_to_linebuf(sed_eval_t *eval, const char* sz,
    append_to_linebuf(eval, sz, step_vars);
static void append_to_holdbuf(sed_eval_t *eval, const char* sz)
        grow_hold_buffer(eval, reqsize);
static void copy_to_holdbuf(sed_eval_t *eval, const char* sz)
    append_to_holdbuf(eval, sz);
static void append_to_genbuf(sed_eval_t *eval, const char* sz, char **gspend)
        grow_gen_buffer(eval, reqsize, gspend);
static void copy_to_genbuf(sed_eval_t *eval, const char* sz)
        grow_gen_buffer(eval, reqsize, NULL);
        appendmem_to_linebuf(eval, buf, llen + 1);
        appendmem_to_linebuf(eval, buf, bufsz);
            append_to_linebuf(eval, """", NULL);
            if (sp == NULL)
            grow_gen_buffer(eval, eval->gsize + 1024, &sp);
    append_to_genbuf(eval, lp, &sp);
    copy_to_linebuf(eval, eval->genbuf, step_vars);
        grow_gen_buffer(eval, reqsize, &sp);
            copy_to_linebuf(eval, p1, step_vars);
            copy_to_linebuf(eval, eval->holdbuf, step_vars);
            append_to_linebuf(eval, ""\n"", step_vars);
            append_to_linebuf(eval, eval->holdbuf, step_vars);
            copy_to_holdbuf(eval, eval->linebuf);
            append_to_holdbuf(eval, ""\n"");
            append_to_holdbuf(eval, eval->linebuf);
            append_to_linebuf(eval, ""\n"", step_vars);
            copy_to_genbuf(eval, eval->linebuf);
            copy_to_linebuf(eval, eval->holdbuf, step_vars);
            copy_to_holdbuf(eval, eval->genbuf);",db47781128e42bd49f55076665b3f6ca4e2bc5e2,CVE-2022-30522,db47781128e42bd49f55076665b3f6ca4e2bc5e2,https://github.com/apache/httpd,CPE_GIT_REPOBASED,84,COMPLETED," VAR VAR VAR(VAR *VAR, VAR **VAR, VAR (*VAR >= VAR) { VAR VAR; } VAR (VAR > VAR) { VAR VAR; } VAR VAR; VAR VAR VAR(VAR *VAR, VAR VAR) VAR VAR(VAR->VAR, &VAR->VAR, &VAR->VAR, VAR VAR VAR(VAR *VAR, VAR VAR) VAR VAR(VAR->VAR, &VAR->VAR, &VAR->VAR, VAR VAR VAR(VAR *VAR, VAR VAR, VAR VAR = 0; VAR = VAR(VAR->VAR, &VAR->VAR, VAR, &VAR->VAR, VAR); VAR (VAR == VAR) { VAR->VAR = &VAR->VAR[71]; } VAR VAR; VAR VAR VAR(VAR *VAR, VAR VAR* VAR, VAR VAR) VAR VAR = 0; VAR = VAR(VAR, VAR); VAR (VAR != VAR) { VAR VAR; } VAR VAR; VAR VAR VAR(VAR *VAR, VAR VAR* VAR, VAR VAR = 0; VAR = VAR(VAR, VAR, VAR + 1); VAR (VAR != VAR) { VAR VAR; } VAR VAR; VAR VAR VAR(VAR *VAR, VAR VAR* VAR, VAR VAR(VAR, VAR, VAR); VAR VAR VAR(VAR *VAR, VAR VAR* VAR) VAR VAR = 0; VAR = VAR(VAR, VAR); VAR (VAR != VAR) { VAR VAR; } VAR VAR; VAR VAR VAR(VAR *VAR, VAR VAR* VAR) VAR VAR(VAR, VAR); VAR VAR VAR(VAR *VAR, VAR VAR* VAR, VAR **VAR) VAR VAR = 0; VAR = VAR(VAR, VAR, VAR); VAR (VAR != VAR) { VAR VAR; } VAR VAR; VAR VAR VAR(VAR *VAR, VAR VAR* VAR) VAR VAR = VAR;; VAR = VAR(VAR, VAR, VAR); VAR (VAR != VAR) { VAR VAR; } VAR VAR; VAR VAR = 0; VAR = VAR(VAR, VAR, VAR + 1); VAR (VAR != VAR) { VAR VAR; } VAR VAR = VAR(VAR, VAR, VAR); VAR (VAR != VAR) { VAR VAR; } VAR VAR = 0; VAR = VAR(VAR, """", VAR); VAR (VAR != VAR) { VAR VAR; } VAR (VAR == VAR) { VAR VAR; } VAR (VAR == VAR) { } VAR = VAR(VAR, VAR->VAR + 1024, &VAR); VAR (VAR != VAR) { VAR VAR; } VAR = VAR(VAR, VAR, &VAR); VAR (VAR != VAR) { VAR VAR; } VAR = VAR(VAR, VAR->VAR, VAR); VAR VAR = VAR(VAR, VAR, &VAR); VAR (VAR != VAR) { VAR VAR; } VAR = VAR(VAR, VAR, VAR); VAR (VAR != VAR) VAR VAR; VAR = VAR(VAR, VAR->VAR, VAR); VAR (VAR != VAR) VAR VAR; VAR = VAR(VAR, ""\VAR"", VAR); VAR (VAR != VAR) VAR VAR; VAR = VAR(VAR, VAR->VAR, VAR); VAR (VAR != VAR) VAR VAR; VAR = VAR(VAR, VAR->VAR); VAR (VAR != VAR) VAR VAR; VAR = VAR(VAR, ""\VAR""); VAR (VAR != VAR) VAR VAR; VAR = VAR(VAR, VAR->VAR); VAR (VAR != VAR) VAR VAR; VAR = VAR(VAR, ""\VAR"", VAR); VAR (VAR != VAR) VAR VAR; VAR = VAR(VAR, VAR->VAR); VAR (VAR != VAR) VAR VAR; VAR = VAR(VAR, VAR->VAR, VAR); VAR (VAR != VAR) VAR VAR; VAR = VAR(VAR, VAR->VAR); VAR (VAR != VAR) VAR VAR; VAR VAR VAR(VAR *VAR, VAR **VAR, VAR (*VAR >= VAR) VAR; VAR VAR VAR(VAR *VAR, VAR VAR) VAR(VAR->VAR, &VAR->VAR, &VAR->VAR, VAR VAR VAR(VAR *VAR, VAR VAR) VAR(VAR->VAR, &VAR->VAR, &VAR->VAR, VAR VAR VAR(VAR *VAR, VAR VAR, VAR(VAR->VAR, &VAR->VAR, VAR, &VAR->VAR, VAR); VAR->VAR = &VAR->VAR[71]; VAR VAR VAR(VAR *VAR, VAR VAR* VAR, VAR VAR) VAR(VAR, VAR); VAR VAR VAR(VAR *VAR, VAR VAR* VAR, VAR(VAR, VAR, VAR + 1); VAR VAR VAR(VAR *VAR, VAR VAR* VAR, VAR(VAR, VAR, VAR); VAR VAR VAR(VAR *VAR, VAR VAR* VAR) VAR(VAR, VAR); VAR VAR VAR(VAR *VAR, VAR VAR* VAR) VAR(VAR, VAR); VAR VAR VAR(VAR *VAR, VAR VAR* VAR, VAR **VAR) VAR(VAR, VAR, VAR); VAR VAR VAR(VAR *VAR, VAR VAR* VAR) VAR(VAR, VAR, VAR); VAR(VAR, VAR, VAR + 1); VAR(VAR, VAR, VAR); VAR(VAR, """", VAR); VAR (VAR == VAR) VAR(VAR, VAR->VAR + 1024, &VAR); VAR(VAR, VAR, &VAR); VAR(VAR, VAR->VAR, VAR); VAR(VAR, VAR, &VAR); VAR(VAR, VAR, VAR); VAR(VAR, VAR->VAR, VAR); VAR(VAR, ""\VAR"", VAR); VAR(VAR, VAR->VAR, VAR); VAR(VAR, VAR->VAR); VAR(VAR, ""\VAR""); VAR(VAR, VAR->VAR); VAR(VAR, ""\VAR"", VAR); VAR(VAR, VAR->VAR); VAR(VAR, VAR->VAR, VAR); VAR(VAR, VAR->VAR);",0,5
krb5_e1caf6fb74981da62039846931ebdffed71309d1,src/plugins/kdldap/libkdb_ldap/ldap_principal2.c,"static krb5_error_code
check_dn_in_container(krb5_context context, const char *dn,
                      char *const *subtrees, unsigned int ntrees)
{
    unsigned int i;
    size_t dnlen = strlen(dn), stlen;

    for (i = 0; i < ntrees; i++) {
        if (subtrees[i] == NULL || *subtrees[i] == '\0')
            return 0;
        stlen = strlen(subtrees[i]);
        if (dnlen >= stlen &&
            strcasecmp(dn + dnlen - stlen, subtrees[i]) == 0 &&
            (dnlen == stlen || dn[dnlen - stlen - 1] == ','))
            return 0;
    }

    k5_setmsg(context, EINVAL, _(""DN is out of the realm subtree""));
    return EINVAL;
}

static krb5_error_code
check_dn_exists(krb5_context context,
                krb5_ldap_server_handle *ldap_server_handle,
                const char *dn, krb5_boolean nonkrb_only)
{
    krb5_error_code st = 0, tempst;
    krb5_ldap_context *ldap_context = context->dal_handle->db_context;
    LDAP *ld = ldap_server_handle->ldap_handle;
    LDAPMessage *result = NULL, *ent;
    char *attrs[] = { ""krbticketpolicyreference"", ""krbprincipalname"", NULL };
    char **values;

    LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attrs, IGNORE_STATUS);
    if (st != LDAP_SUCCESS)
        return set_ldap_error(context, st, OP_SEARCH);

    ent = ldap_first_entry(ld, result);
    CHECK_NULL(ent);

    values = ldap_get_values(ld, ent, ""krbticketpolicyreference"");
    if (values != NULL)
        ldap_value_free(values);

    values = ldap_get_values(ld, ent, ""krbprincipalname"");
    if (values != NULL) {
        ldap_value_free(values);
        if (nonkrb_only) {
            st = EINVAL;
            k5_setmsg(context, st, _(""ldap object is already kerberized""));
            goto cleanup;
        }
    }

cleanup:
    ldap_msgfree(result);
    return st;
}

static krb5_error_code
validate_xargs(krb5_context context,
               krb5_ldap_server_handle *ldap_server_handle,
               const xargs_t *xargs, const char *standalone_dn,
               char *const *subtrees, unsigned int ntrees)
{
    krb5_error_code st;

    if (xargs->dn != NULL) {
        /* The supplied dn must be within a realm container. */
        st = check_dn_in_container(context, xargs->dn, subtrees, ntrees);
        if (st)
            return st;
        /* The supplied dn must exist without Kerberos attributes. */
        st = check_dn_exists(context, ldap_server_handle, xargs->dn, TRUE);
        if (st)
            return st;
    }

    if (xargs->linkdn != NULL) {
        /* The supplied linkdn must be within a realm container. */
        st = check_dn_in_container(context, xargs->linkdn, subtrees, ntrees);
        if (st)
            return st;
        /* The supplied linkdn must exist. */
        st = check_dn_exists(context, ldap_server_handle, xargs->linkdn,
                             FALSE);
        if (st)
            return st;
    }

    if (xargs->containerdn != NULL && standalone_dn != NULL) {
        /* standalone_dn (likely composed using containerdn) must be within a
         * container. */
        st = check_dn_in_container(context, standalone_dn, subtrees, ntrees);
        if (st)
            return st;
    }

    return 0;
}

    char                        *strval[10]={NULL}, errbuf[1024];
    krb5_boolean                establish_links=FALSE;
        st = validate_xargs(context, ldap_server_handle, &xargs,
                            standalone_principal_dn, subtreelist, ntrees);
        if (st)","    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];
    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;
        /* make sure the DN falls in the subtree */
        int              dnlen=0, subtreelen=0;
        char             *dn=NULL;
        krb5_boolean     outofsubtree=TRUE;

        if (xargs.dn != NULL) {
            dn = xargs.dn;
        } else if (xargs.linkdn != NULL) {
            dn = xargs.linkdn;
        } else if (standalone_principal_dn != NULL) {
            /*
             * Even though the standalone_principal_dn is constructed
             * within this function, there is the containerdn input
             * from the user that can become part of the it.
             */
            dn = standalone_principal_dn;
        }

        for (tre=0; tre<ntrees; ++tre) {
            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {
                outofsubtree = FALSE;
                break;
            } else {
                dnlen = strlen (dn);
                subtreelen = strlen(subtreelist[tre]);
                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {
                    outofsubtree = FALSE;
                    break;
                }
            }
        }

        if (outofsubtree == TRUE) {
            st = EINVAL;
            k5_setmsg(context, st, _(""DN is out of the realm subtree""));
        }

        /*
         * dn value will be set either by dn, linkdn or the standalone_principal_dn
         * In the first 2 cases, the dn should be existing and in the last case we
         * are supposed to create the ldap object. so the below should not be
         * executed for the last case.
         */

        if (standalone_principal_dn == NULL) {
            /*
             * If the ldap object is missing, this results in an error.
             */

            /*
             * Search for krbprincipalname attribute here.
             * This is to find if a kerberos identity is already present
             * on the ldap object, in which case adding a kerberos identity
             * on the ldap object should result in an error.
             */
            char  *attributes[]={""krbticketpolicyreference"", ""krbprincipalname"", NULL};

            ldap_msgfree(result);
            result = NULL;
            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);
            if (st == LDAP_SUCCESS) {
                ent = ldap_first_entry(ld, result);
                if (ent != NULL) {
                    if ((values=ldap_get_values(ld, ent, ""krbticketpolicyreference"")) != NULL) {
                        ldap_value_free(values);
                    }

                    if ((values=ldap_get_values(ld, ent, ""krbprincipalname"")) != NULL) {
                        krb_identity_exists = TRUE;
                        ldap_value_free(values);
                    }
                }
            } else {
                st = set_ldap_error(context, st, OP_SEARCH);
                goto cleanup;
            }
        }
    }

    /*
     * If xargs.dn is set then the request is to add a
     * kerberos principal on a ldap object, but if
     * there is one already on the ldap object this
     * should result in an error.
     */

    if (xargs.dn != NULL && krb_identity_exists == TRUE) {
        st = EINVAL;
        snprintf(errbuf, sizeof(errbuf),
                 _(""ldap object is already kerberized""));
        k5_setmsg(context, st, ""%s"", errbuf);
        goto cleanup;",e1caf6fb74981da62039846931ebdffed71309d1,CVE-2018-5729,e1caf6fb74981da62039846931ebdffed71309d1,https://github.com/krb5/krb5,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR VAR, VAR VAR *VAR, VAR *VAR *VAR, VAR VAR VAR) { VAR VAR VAR; VAR VAR = VAR(VAR), VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR (VAR[VAR] == VAR || *VAR[VAR] == '\0') VAR 0; VAR = VAR(VAR[VAR]); VAR (VAR >= VAR && VAR(VAR + VAR - VAR, VAR[VAR]) == 0 && (VAR == VAR || VAR[VAR - VAR - 1] == ',')) VAR 0; } VAR(VAR, VAR, VAR(""VAR VAR VAR VAR VAR VAR VAR"")); VAR VAR; } VAR VAR VAR(VAR VAR, VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR = 0, VAR; VAR *VAR = VAR->VAR->VAR; VAR *VAR = VAR->VAR; VAR *VAR = VAR, *VAR; VAR *VAR[] = { ""VAR"", ""VAR"", VAR }; VAR **VAR; VAR(VAR, VAR, 0, VAR, VAR); VAR (VAR != VAR) VAR VAR(VAR, VAR, VAR); VAR = VAR(VAR, VAR); VAR(VAR); VAR = VAR(VAR, VAR, ""VAR""); VAR (VAR != VAR) VAR(VAR); VAR = VAR(VAR, VAR, ""VAR""); VAR (VAR != VAR) { VAR(VAR); VAR (VAR) { VAR = VAR; VAR(VAR, VAR, VAR(""VAR VAR VAR VAR VAR"")); VAR VAR; } } VAR: VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR, VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR *VAR *VAR, VAR VAR VAR) { VAR VAR; VAR (VAR->VAR != VAR) {  VAR = VAR(VAR, VAR->VAR, VAR, VAR); VAR (VAR) VAR VAR;  VAR = VAR(VAR, VAR, VAR->VAR, VAR); VAR (VAR) VAR VAR; } VAR (VAR->VAR != VAR) {  VAR = VAR(VAR, VAR->VAR, VAR, VAR); VAR (VAR) VAR VAR;  VAR = VAR(VAR, VAR, VAR->VAR, VAR); VAR (VAR) VAR VAR; } VAR (VAR->VAR != VAR && VAR != VAR) { /* VAR (VAR VAR VAR VAR) VAR VAR VAR VAR * VAR. */ VAR = VAR(VAR, VAR, VAR, VAR); VAR (VAR) VAR VAR; } VAR 0; } VAR *VAR[10]={VAR}, VAR[1024]; VAR VAR=VAR; VAR = VAR(VAR, VAR, &VAR, VAR, VAR, VAR); VAR (VAR) VAR **VAR=VAR, *VAR[10]={VAR}, VAR[1024]; VAR VAR=VAR, VAR=VAR;  VAR VAR=0, VAR=0; VAR *VAR=VAR; VAR VAR=VAR; VAR (VAR.VAR != VAR) { VAR = VAR.VAR; } VAR VAR (VAR.VAR != VAR) { VAR = VAR.VAR; } VAR VAR (VAR != VAR) { /* * VAR VAR VAR VAR VAR VAR * VAR VAR VAR, VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR = VAR; } VAR (VAR=0; VAR<VAR; ++VAR) { VAR (VAR[VAR] == VAR || VAR(VAR[VAR]) == 0) { VAR = VAR; VAR; } VAR { VAR = VAR (VAR); VAR = VAR(VAR[VAR]); VAR ((VAR >= VAR) && (VAR((VAR + VAR - VAR), VAR[VAR]) == 0)) { VAR = VAR; VAR; } } } VAR (VAR == VAR) { VAR = VAR; VAR(VAR, VAR, VAR(""VAR VAR VAR VAR VAR VAR VAR"")); } /* * VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR * VAR VAR VAR 2 VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. */ VAR (VAR == VAR) { /* * VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR. */ /* * VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR *VAR[]={""VAR"", ""VAR"", VAR}; VAR(VAR); VAR = VAR; VAR(VAR, VAR, 0, VAR, VAR); VAR (VAR == VAR) { VAR = VAR(VAR, VAR); VAR (VAR != VAR) { VAR ((VAR=VAR(VAR, VAR, ""VAR"")) != VAR) { VAR(VAR); } VAR ((VAR=VAR(VAR, VAR, ""VAR"")) != VAR) { VAR = VAR; VAR(VAR); } } } VAR { VAR = VAR(VAR, VAR, VAR); VAR VAR; } } } /* * VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR, VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. */ VAR (VAR.VAR != VAR && VAR == VAR) { VAR = VAR; VAR(VAR, VAR(VAR), VAR(""VAR VAR VAR VAR VAR"")); VAR(VAR, VAR, ""%VAR"", VAR); VAR VAR;",4,5
krb5_e1caf6fb74981da62039846931ebdffed71309d1,src/plugins/kdldap/libkdb_ldap/ldap_principal2.c,"static krb5_error_code
check_dn_in_container(krb5_context context, const char *dn,
                      char *const *subtrees, unsigned int ntrees)
{
    unsigned int i;
    size_t dnlen = strlen(dn), stlen;

    for (i = 0; i < ntrees; i++) {
        if (subtrees[i] == NULL || *subtrees[i] == '\0')
            return 0;
        stlen = strlen(subtrees[i]);
        if (dnlen >= stlen &&
            strcasecmp(dn + dnlen - stlen, subtrees[i]) == 0 &&
            (dnlen == stlen || dn[dnlen - stlen - 1] == ','))
            return 0;
    }

    k5_setmsg(context, EINVAL, _(""DN is out of the realm subtree""));
    return EINVAL;
}

static krb5_error_code
check_dn_exists(krb5_context context,
                krb5_ldap_server_handle *ldap_server_handle,
                const char *dn, krb5_boolean nonkrb_only)
{
    krb5_error_code st = 0, tempst;
    krb5_ldap_context *ldap_context = context->dal_handle->db_context;
    LDAP *ld = ldap_server_handle->ldap_handle;
    LDAPMessage *result = NULL, *ent;
    char *attrs[] = { ""krbticketpolicyreference"", ""krbprincipalname"", NULL };
    char **values;

    LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attrs, IGNORE_STATUS);
    if (st != LDAP_SUCCESS)
        return set_ldap_error(context, st, OP_SEARCH);

    ent = ldap_first_entry(ld, result);
    CHECK_NULL(ent);

    values = ldap_get_values(ld, ent, ""krbticketpolicyreference"");
    if (values != NULL)
        ldap_value_free(values);

    values = ldap_get_values(ld, ent, ""krbprincipalname"");
    if (values != NULL) {
        ldap_value_free(values);
        if (nonkrb_only) {
            st = EINVAL;
            k5_setmsg(context, st, _(""ldap object is already kerberized""));
            goto cleanup;
        }
    }

cleanup:
    ldap_msgfree(result);
    return st;
}

static krb5_error_code
validate_xargs(krb5_context context,
               krb5_ldap_server_handle *ldap_server_handle,
               const xargs_t *xargs, const char *standalone_dn,
               char *const *subtrees, unsigned int ntrees)
{
    krb5_error_code st;

    if (xargs->dn != NULL) {
        /* The supplied dn must be within a realm container. */
        st = check_dn_in_container(context, xargs->dn, subtrees, ntrees);
        if (st)
            return st;
        /* The supplied dn must exist without Kerberos attributes. */
        st = check_dn_exists(context, ldap_server_handle, xargs->dn, TRUE);
        if (st)
            return st;
    }

    if (xargs->linkdn != NULL) {
        /* The supplied linkdn must be within a realm container. */
        st = check_dn_in_container(context, xargs->linkdn, subtrees, ntrees);
        if (st)
            return st;
        /* The supplied linkdn must exist. */
        st = check_dn_exists(context, ldap_server_handle, xargs->linkdn,
                             FALSE);
        if (st)
            return st;
    }

    if (xargs->containerdn != NULL && standalone_dn != NULL) {
        /* standalone_dn (likely composed using containerdn) must be within a
         * container. */
        st = check_dn_in_container(context, standalone_dn, subtrees, ntrees);
        if (st)
            return st;
    }

    return 0;
}

    char                        *strval[10]={NULL}, errbuf[1024];
    krb5_boolean                establish_links=FALSE;
        st = validate_xargs(context, ldap_server_handle, &xargs,
                            standalone_principal_dn, subtreelist, ntrees);
        if (st)","    char                        **values=NULL, *strval[10]={NULL}, errbuf[1024];
    krb5_boolean                krb_identity_exists=FALSE, establish_links=FALSE;
        /* make sure the DN falls in the subtree */
        int              dnlen=0, subtreelen=0;
        char             *dn=NULL;
        krb5_boolean     outofsubtree=TRUE;

        if (xargs.dn != NULL) {
            dn = xargs.dn;
        } else if (xargs.linkdn != NULL) {
            dn = xargs.linkdn;
        } else if (standalone_principal_dn != NULL) {
            /*
             * Even though the standalone_principal_dn is constructed
             * within this function, there is the containerdn input
             * from the user that can become part of the it.
             */
            dn = standalone_principal_dn;
        }

        for (tre=0; tre<ntrees; ++tre) {
            if (subtreelist[tre] == NULL || strlen(subtreelist[tre]) == 0) {
                outofsubtree = FALSE;
                break;
            } else {
                dnlen = strlen (dn);
                subtreelen = strlen(subtreelist[tre]);
                if ((dnlen >= subtreelen) && (strcasecmp((dn + dnlen - subtreelen), subtreelist[tre]) == 0)) {
                    outofsubtree = FALSE;
                    break;
                }
            }
        }

        if (outofsubtree == TRUE) {
            st = EINVAL;
            k5_setmsg(context, st, _(""DN is out of the realm subtree""));
        }

        /*
         * dn value will be set either by dn, linkdn or the standalone_principal_dn
         * In the first 2 cases, the dn should be existing and in the last case we
         * are supposed to create the ldap object. so the below should not be
         * executed for the last case.
         */

        if (standalone_principal_dn == NULL) {
            /*
             * If the ldap object is missing, this results in an error.
             */

            /*
             * Search for krbprincipalname attribute here.
             * This is to find if a kerberos identity is already present
             * on the ldap object, in which case adding a kerberos identity
             * on the ldap object should result in an error.
             */
            char  *attributes[]={""krbticketpolicyreference"", ""krbprincipalname"", NULL};

            ldap_msgfree(result);
            result = NULL;
            LDAP_SEARCH_1(dn, LDAP_SCOPE_BASE, 0, attributes, IGNORE_STATUS);
            if (st == LDAP_SUCCESS) {
                ent = ldap_first_entry(ld, result);
                if (ent != NULL) {
                    if ((values=ldap_get_values(ld, ent, ""krbticketpolicyreference"")) != NULL) {
                        ldap_value_free(values);
                    }

                    if ((values=ldap_get_values(ld, ent, ""krbprincipalname"")) != NULL) {
                        krb_identity_exists = TRUE;
                        ldap_value_free(values);
                    }
                }
            } else {
                st = set_ldap_error(context, st, OP_SEARCH);
                goto cleanup;
            }
        }
    }

    /*
     * If xargs.dn is set then the request is to add a
     * kerberos principal on a ldap object, but if
     * there is one already on the ldap object this
     * should result in an error.
     */

    if (xargs.dn != NULL && krb_identity_exists == TRUE) {
        st = EINVAL;
        snprintf(errbuf, sizeof(errbuf),
                 _(""ldap object is already kerberized""));
        k5_setmsg(context, st, ""%s"", errbuf);
        goto cleanup;",e1caf6fb74981da62039846931ebdffed71309d1,CVE-2018-5730,e1caf6fb74981da62039846931ebdffed71309d1,https://github.com/krb5/krb5,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR(VAR VAR, VAR VAR *VAR, VAR *VAR *VAR, VAR VAR VAR) { VAR VAR VAR; VAR VAR = VAR(VAR), VAR; VAR (VAR = 0; VAR < VAR; VAR++) { VAR (VAR[VAR] == VAR || *VAR[VAR] == '\0') VAR 0; VAR = VAR(VAR[VAR]); VAR (VAR >= VAR && VAR(VAR + VAR - VAR, VAR[VAR]) == 0 && (VAR == VAR || VAR[VAR - VAR - 1] == ',')) VAR 0; } VAR(VAR, VAR, VAR(""VAR VAR VAR VAR VAR VAR VAR"")); VAR VAR; } VAR VAR VAR(VAR VAR, VAR *VAR, VAR VAR *VAR, VAR VAR) { VAR VAR = 0, VAR; VAR *VAR = VAR->VAR->VAR; VAR *VAR = VAR->VAR; VAR *VAR = VAR, *VAR; VAR *VAR[] = { ""VAR"", ""VAR"", VAR }; VAR **VAR; VAR(VAR, VAR, 0, VAR, VAR); VAR (VAR != VAR) VAR VAR(VAR, VAR, VAR); VAR = VAR(VAR, VAR); VAR(VAR); VAR = VAR(VAR, VAR, ""VAR""); VAR (VAR != VAR) VAR(VAR); VAR = VAR(VAR, VAR, ""VAR""); VAR (VAR != VAR) { VAR(VAR); VAR (VAR) { VAR = VAR; VAR(VAR, VAR, VAR(""VAR VAR VAR VAR VAR"")); VAR VAR; } } VAR: VAR(VAR); VAR VAR; } VAR VAR VAR(VAR VAR, VAR *VAR, VAR VAR *VAR, VAR VAR *VAR, VAR *VAR *VAR, VAR VAR VAR) { VAR VAR; VAR (VAR->VAR != VAR) {  VAR = VAR(VAR, VAR->VAR, VAR, VAR); VAR (VAR) VAR VAR;  VAR = VAR(VAR, VAR, VAR->VAR, VAR); VAR (VAR) VAR VAR; } VAR (VAR->VAR != VAR) {  VAR = VAR(VAR, VAR->VAR, VAR, VAR); VAR (VAR) VAR VAR;  VAR = VAR(VAR, VAR, VAR->VAR, VAR); VAR (VAR) VAR VAR; } VAR (VAR->VAR != VAR && VAR != VAR) { /* VAR (VAR VAR VAR VAR) VAR VAR VAR VAR * VAR. */ VAR = VAR(VAR, VAR, VAR, VAR); VAR (VAR) VAR VAR; } VAR 0; } VAR *VAR[10]={VAR}, VAR[1024]; VAR VAR=VAR; VAR = VAR(VAR, VAR, &VAR, VAR, VAR, VAR); VAR (VAR) VAR **VAR=VAR, *VAR[10]={VAR}, VAR[1024]; VAR VAR=VAR, VAR=VAR;  VAR VAR=0, VAR=0; VAR *VAR=VAR; VAR VAR=VAR; VAR (VAR.VAR != VAR) { VAR = VAR.VAR; } VAR VAR (VAR.VAR != VAR) { VAR = VAR.VAR; } VAR VAR (VAR != VAR) { /* * VAR VAR VAR VAR VAR VAR * VAR VAR VAR, VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR = VAR; } VAR (VAR=0; VAR<VAR; ++VAR) { VAR (VAR[VAR] == VAR || VAR(VAR[VAR]) == 0) { VAR = VAR; VAR; } VAR { VAR = VAR (VAR); VAR = VAR(VAR[VAR]); VAR ((VAR >= VAR) && (VAR((VAR + VAR - VAR), VAR[VAR]) == 0)) { VAR = VAR; VAR; } } } VAR (VAR == VAR) { VAR = VAR; VAR(VAR, VAR, VAR(""VAR VAR VAR VAR VAR VAR VAR"")); } /* * VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR * VAR VAR VAR 2 VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. */ VAR (VAR == VAR) { /* * VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR. */ /* * VAR VAR VAR VAR VAR. * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR. */ VAR *VAR[]={""VAR"", ""VAR"", VAR}; VAR(VAR); VAR = VAR; VAR(VAR, VAR, 0, VAR, VAR); VAR (VAR == VAR) { VAR = VAR(VAR, VAR); VAR (VAR != VAR) { VAR ((VAR=VAR(VAR, VAR, ""VAR"")) != VAR) { VAR(VAR); } VAR ((VAR=VAR(VAR, VAR, ""VAR"")) != VAR) { VAR = VAR; VAR(VAR); } } } VAR { VAR = VAR(VAR, VAR, VAR); VAR VAR; } } } /* * VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR VAR, VAR VAR * VAR VAR VAR VAR VAR VAR VAR VAR VAR * VAR VAR VAR VAR VAR. */ VAR (VAR.VAR != VAR && VAR == VAR) { VAR = VAR; VAR(VAR, VAR(VAR), VAR(""VAR VAR VAR VAR VAR"")); VAR(VAR, VAR, ""%VAR"", VAR); VAR VAR;",4,5
libarchive_94821008d6eea81e315c5881cdf739202961040a,libarchive/archive_read_support_format_rar5.c,"	const size_t SMALLEST_RAR5_BLOCK_SIZE = 3;

	hdr_size = raw_hdr_size + hdr_size_len;

	if(hdr_size > (2 * 1024 * 1024)) {
	/* Additional sanity checks to weed out invalid files. */
	if(raw_hdr_size == 0 || hdr_size_len == 0 ||
		hdr_size < SMALLEST_RAR5_BLOCK_SIZE)
	{
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Too small block encountered (%ld bytes)"",
		    raw_hdr_size);

		return ARCHIVE_FATAL;
	}","	if(raw_hdr_size > (2 * 1024 * 1024)) {
	hdr_size = raw_hdr_size + hdr_size_len;",94821008d6eea81e315c5881cdf739202961040a,CVE-2020-9308,94821008d6eea81e315c5881cdf739202961040a,https://github.com/libarchive/libarchive,NVD_GIT_REPOBASED,98,COMPLETED,"VAR VAR VAR = 3; VAR = VAR + VAR; VAR(VAR > (2 * 1024 * 1024)) {  VAR(VAR == 0 || VAR == 0 || VAR < VAR) { VAR(&VAR->VAR, VAR, ""VAR VAR VAR VAR (%VAR VAR)"", VAR); VAR VAR; } VAR(VAR > (2 * 1024 * 1024)) { VAR = VAR + VAR;",0,5
libarchive_d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7,libarchive/archive_read_support_format_zip.c,"		if (rsrc->uncompressed_size != rsrc->compressed_size) {
			archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
			    ""Malformed OS X metadata entry: inconsistent size"");
			return (ARCHIVE_FATAL);
		}
	if (rsrc->compressed_size > (4 * 1024 * 1024)) {
		archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,
		    ""Mac metadata is too large: %jd > 4M bytes"",
		    (intmax_t)rsrc->compressed_size);
		return (ARCHIVE_WARN);
	}
			if ((size_t)bytes_avail > metadata_bytes)
				bytes_avail = metadata_bytes;",,d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7,CVE-2016-1541,d0331e8e5b05b475f20b1f3101fe1ad772d7e7e7,https://github.com/libarchive/libarchive,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR (VAR->VAR != VAR->VAR) { VAR(&VAR->VAR, VAR, ""VAR VAR VAR VAR VAR: VAR VAR""); VAR (VAR); } VAR (VAR->VAR > (4 * 1024 * 1024)) { VAR(&VAR->VAR, VAR, ""VAR VAR VAR VAR VAR: %VAR > 4M VAR"", (VAR)VAR->VAR); VAR (VAR); } VAR ((VAR)VAR > VAR) VAR = VAR; ",0,5
libarchive_fd7e0c02e272913a0a8b6d492c7260dfca0b1408,libarchive/archive_read_support_format_cpio.c,"		if (cpio->entry_bytes_remaining > 1024 * 1024) {
			archive_set_error(&a->archive, ENOMEM,
			    ""Rejecting malformed cpio archive: symlink contents exceed 1 megabyte"");
			return (ARCHIVE_FATAL);
		}",,fd7e0c02e272913a0a8b6d492c7260dfca0b1408,CVE-2016-4809,fd7e0c02e272913a0a8b6d492c7260dfca0b1408,https://github.com/libarchive/libarchive,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR (VAR->VAR > 1024 * 1024) { VAR(&VAR->VAR, VAR, ""VAR VAR VAR VAR: VAR VAR VAR 1 VAR""); VAR (VAR); } ",0,5
linux_759c01142a5d0f364a462346168a56de28a80f52,Documentation/sysctl/fs.txt,"- pipe-user-pages-hard
- pipe-user-pages-soft
pipe-user-pages-hard:

Maximum total number of pages a non-privileged user may allocate for pipes.
Once this limit is reached, no new pipes may be allocated until usage goes
below the limit again. When set to 0, no limit is applied, which is the default
setting.

==============================================================

pipe-user-pages-soft:

Maximum total number of pages a non-privileged user may allocate for pipes
before the pipe size gets limited to a single page. Once this limit is reached,
new pipes will be limited to a single page in size for this user in order to
limit total memory usage, and trying to increase them using fcntl() will be
denied until usage goes below the limit again. The default value allows to
allocate up to 1024 pipes at their default size. When set to 0, no limit is
applied.

==============================================================
",,759c01142a5d0f364a462346168a56de28a80f52,CVE-2016-2847,759c01142a5d0f364a462346168a56de28a80f52,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"- VAR-VAR-VAR-VAR - VAR-VAR-VAR-VAR VAR-VAR-VAR-VAR: VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR 0, VAR VAR VAR VAR, VAR VAR VAR VAR VAR. ============================================================== VAR-VAR-VAR-VAR: VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR() VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR 1024 VAR VAR VAR VAR VAR. VAR VAR VAR 0, VAR VAR VAR VAR. ============================================================== ",0,5
linux_973c096f6a85e5b5f2a295126ba6928d9a6afd45,drivers/video/console/vgacon.c,	vga_init_done = true;,"#ifdef CONFIG_VGACON_SOFT_SCROLLBACK
/* software scrollback */
struct vgacon_scrollback_info {
	void *data;
	int tail;
	int size;
	int rows;
	int cnt;
	int cur;
	int save;
	int restore;
};

static struct vgacon_scrollback_info *vgacon_scrollback_cur;
static struct vgacon_scrollback_info vgacon_scrollbacks[MAX_NR_CONSOLES];
static bool scrollback_persistent = \
	IS_ENABLED(CONFIG_VGACON_SOFT_SCROLLBACK_PERSISTENT_ENABLE_BY_DEFAULT);
module_param_named(scrollback_persistent, scrollback_persistent, bool, 0000);
MODULE_PARM_DESC(scrollback_persistent, ""Enable persistent scrollback for all vga consoles"");

static void vgacon_scrollback_reset(int vc_num, size_t reset_size)
{
	struct vgacon_scrollback_info *scrollback = &vgacon_scrollbacks[vc_num];

	if (scrollback->data && reset_size > 0)
		memset(scrollback->data, 0, reset_size);

	scrollback->cnt  = 0;
	scrollback->tail = 0;
	scrollback->cur  = 0;
}

static void vgacon_scrollback_init(int vc_num)
{
	int pitch = vga_video_num_columns * 2;
	size_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;
	int rows = size / pitch;
	void *data;

	data = kmalloc_array(CONFIG_VGACON_SOFT_SCROLLBACK_SIZE, 1024,
			     GFP_NOWAIT);

	vgacon_scrollbacks[vc_num].data = data;
	vgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];

	vgacon_scrollback_cur->rows = rows - 1;
	vgacon_scrollback_cur->size = rows * pitch;

	vgacon_scrollback_reset(vc_num, size);
}

static void vgacon_scrollback_switch(int vc_num)
{
	if (!scrollback_persistent)
		vc_num = 0;

	if (!vgacon_scrollbacks[vc_num].data) {
		vgacon_scrollback_init(vc_num);
	} else {
		if (scrollback_persistent) {
			vgacon_scrollback_cur = &vgacon_scrollbacks[vc_num];
		} else {
			size_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;

			vgacon_scrollback_reset(vc_num, size);
		}
	}
}

static void vgacon_scrollback_startup(void)
{
	vgacon_scrollback_cur = &vgacon_scrollbacks[0];
	vgacon_scrollback_init(0);
}

static void vgacon_scrollback_update(struct vc_data *c, int t, int count)
{
	void *p;

	if (!vgacon_scrollback_cur->data || !vgacon_scrollback_cur->size ||
	    c->vc_num != fg_console)
		return;

	p = (void *) (c->vc_origin + t * c->vc_size_row);

	while (count--) {
		if ((vgacon_scrollback_cur->tail + c->vc_size_row) >
		    vgacon_scrollback_cur->size)
			vgacon_scrollback_cur->tail = 0;

		scr_memcpyw(vgacon_scrollback_cur->data +
			    vgacon_scrollback_cur->tail,
			    p, c->vc_size_row);

		vgacon_scrollback_cur->cnt++;
		p += c->vc_size_row;
		vgacon_scrollback_cur->tail += c->vc_size_row;

		if (vgacon_scrollback_cur->tail >= vgacon_scrollback_cur->size)
			vgacon_scrollback_cur->tail = 0;

		if (vgacon_scrollback_cur->cnt > vgacon_scrollback_cur->rows)
			vgacon_scrollback_cur->cnt = vgacon_scrollback_cur->rows;

		vgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;
	}
}

static void vgacon_restore_screen(struct vc_data *c)
{
	c->vc_origin = c->vc_visible_origin;
	vgacon_scrollback_cur->save = 0;

	if (!vga_is_gfx && !vgacon_scrollback_cur->restore) {
		scr_memcpyw((u16 *) c->vc_origin, (u16 *) c->vc_screenbuf,
			    c->vc_screenbuf_size > vga_vram_size ?
			    vga_vram_size : c->vc_screenbuf_size);
		vgacon_scrollback_cur->restore = 1;
		vgacon_scrollback_cur->cur = vgacon_scrollback_cur->cnt;
	}
}

static void vgacon_scrolldelta(struct vc_data *c, int lines)
{
	int start, end, count, soff;

	if (!lines) {
		vgacon_restore_screen(c);
		return;
	}

	if (!vgacon_scrollback_cur->data)
		return;

	if (!vgacon_scrollback_cur->save) {
		vgacon_cursor(c, CM_ERASE);
		vgacon_save_screen(c);
		c->vc_origin = (unsigned long)c->vc_screenbuf;
		vgacon_scrollback_cur->save = 1;
	}

	vgacon_scrollback_cur->restore = 0;
	start = vgacon_scrollback_cur->cur + lines;
	end = start + abs(lines);

	if (start < 0)
		start = 0;

	if (start > vgacon_scrollback_cur->cnt)
		start = vgacon_scrollback_cur->cnt;

	if (end < 0)
		end = 0;

	if (end > vgacon_scrollback_cur->cnt)
		end = vgacon_scrollback_cur->cnt;

	vgacon_scrollback_cur->cur = start;
	count = end - start;
	soff = vgacon_scrollback_cur->tail -
		((vgacon_scrollback_cur->cnt - end) * c->vc_size_row);
	soff -= count * c->vc_size_row;

	if (soff < 0)
		soff += vgacon_scrollback_cur->size;

	count = vgacon_scrollback_cur->cnt - start;

	if (count > c->vc_rows)
		count = c->vc_rows;

	if (count) {
		int copysize;

		int diff = c->vc_rows - count;
		void *d = (void *) c->vc_visible_origin;
		void *s = (void *) c->vc_screenbuf;

		count *= c->vc_size_row;
		/* how much memory to end of buffer left? */
		copysize = min(count, vgacon_scrollback_cur->size - soff);
		scr_memcpyw(d, vgacon_scrollback_cur->data + soff, copysize);
		d += copysize;
		count -= copysize;

		if (count) {
			scr_memcpyw(d, vgacon_scrollback_cur->data, count);
			d += count;
		}

		if (diff)
			scr_memcpyw(d, s, diff * c->vc_size_row);
	} else
		vgacon_cursor(c, CM_MOVE);
}

static void vgacon_flush_scrollback(struct vc_data *c)
{
	size_t size = CONFIG_VGACON_SOFT_SCROLLBACK_SIZE * 1024;

	vgacon_scrollback_reset(c->vc_num, size);
}
#else
#define vgacon_scrollback_startup(...) do { } while (0)
#define vgacon_scrollback_init(...)    do { } while (0)
#define vgacon_scrollback_update(...)  do { } while (0)
#define vgacon_scrollback_switch(...)  do { } while (0)

static void vgacon_flush_scrollback(struct vc_data *c)
{
}
#endif /* CONFIG_VGACON_SOFT_SCROLLBACK */

	if (!vga_init_done) {
		vgacon_scrollback_startup();
		vga_init_done = true;
	}
	vgacon_scrollback_switch(c->vc_num);
		vgacon_scrollback_update(c, t, lines);
	.con_flush_scrollback = vgacon_flush_scrollback,",973c096f6a85e5b5f2a295126ba6928d9a6afd45,CVE-2020-28097,973c096f6a85e5b5f2a295126ba6928d9a6afd45,https://github.com/torvalds/linux,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR = VAR;   VAR VAR { VAR *VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; VAR VAR; }; VAR VAR VAR *VAR; VAR VAR VAR VAR[VAR]; VAR VAR VAR = \ VAR(VAR); VAR(VAR, VAR, VAR, 0000); VAR(VAR, ""VAR VAR VAR VAR VAR VAR VAR""); VAR VAR VAR(VAR VAR, VAR VAR) { VAR VAR *VAR = &VAR[VAR]; VAR (VAR->VAR && VAR > 0) VAR(VAR->VAR, 0, VAR); VAR->VAR = 0; VAR->VAR = 0; VAR->VAR = 0; } VAR VAR VAR(VAR VAR) { VAR VAR = VAR * 2; VAR VAR = VAR * 1024; VAR VAR = VAR / VAR; VAR *VAR; VAR = VAR(VAR, 1024, VAR); VAR[VAR].VAR = VAR; VAR = &VAR[VAR]; VAR->VAR = VAR - 1; VAR->VAR = VAR * VAR; VAR(VAR, VAR); } VAR VAR VAR(VAR VAR) { VAR (!VAR) VAR = 0; VAR (!VAR[VAR].VAR) { VAR(VAR); } VAR { VAR (VAR) { VAR = &VAR[VAR]; } VAR { VAR VAR = VAR * 1024; VAR(VAR, VAR); } } } VAR VAR VAR(VAR) { VAR = &VAR[0]; VAR(0); } VAR VAR VAR(VAR VAR *VAR, VAR VAR, VAR VAR) { VAR *VAR; VAR (!VAR->VAR || !VAR->VAR || VAR->VAR != VAR) VAR; VAR = (VAR *) (VAR->VAR + VAR * VAR->VAR); VAR (VAR--) { VAR ((VAR->VAR + VAR->VAR) > VAR->VAR) VAR->VAR = 0; VAR(VAR->VAR + VAR->VAR, VAR, VAR->VAR); VAR->VAR++; VAR += VAR->VAR; VAR->VAR += VAR->VAR; VAR (VAR->VAR >= VAR->VAR) VAR->VAR = 0; VAR (VAR->VAR > VAR->VAR) VAR->VAR = VAR->VAR; VAR->VAR = VAR->VAR; } } VAR VAR VAR(VAR VAR *VAR) { VAR->VAR = VAR->VAR; VAR->VAR = 0; VAR (!VAR && !VAR->VAR) { VAR((VAR *) VAR->VAR, (VAR *) VAR->VAR, VAR->VAR > VAR ? VAR : VAR->VAR); VAR->VAR = 1; VAR->VAR = VAR->VAR; } } VAR VAR VAR(VAR VAR *VAR, VAR VAR) { VAR VAR, VAR, VAR, VAR; VAR (!VAR) { VAR(VAR); VAR; } VAR (!VAR->VAR) VAR; VAR (!VAR->VAR) { VAR(VAR, VAR); VAR(VAR); VAR->VAR = (VAR VAR)VAR->VAR; VAR->VAR = 1; } VAR->VAR = 0; VAR = VAR->VAR + VAR; VAR = VAR + VAR(VAR); VAR (VAR < 0) VAR = 0; VAR (VAR > VAR->VAR) VAR = VAR->VAR; VAR (VAR < 0) VAR = 0; VAR (VAR > VAR->VAR) VAR = VAR->VAR; VAR->VAR = VAR; VAR = VAR - VAR; VAR = VAR->VAR - ((VAR->VAR - VAR) * VAR->VAR); VAR -= VAR * VAR->VAR; VAR (VAR < 0) VAR += VAR->VAR; VAR = VAR->VAR - VAR; VAR (VAR > VAR->VAR) VAR = VAR->VAR; VAR (VAR) { VAR VAR; VAR VAR = VAR->VAR - VAR; VAR *VAR = (VAR *) VAR->VAR; VAR *VAR = (VAR *) VAR->VAR; VAR *= VAR->VAR;  VAR = VAR(VAR, VAR->VAR - VAR); VAR(VAR, VAR->VAR + VAR, VAR); VAR += VAR; VAR -= VAR; VAR (VAR) { VAR(VAR, VAR->VAR, VAR); VAR += VAR; } VAR (VAR) VAR(VAR, VAR, VAR * VAR->VAR); } VAR VAR(VAR, VAR); } VAR VAR VAR(VAR VAR *VAR) { VAR VAR = VAR * 1024; VAR(VAR->VAR, VAR); }      VAR VAR VAR(VAR VAR *VAR) { }  VAR (!VAR) { VAR(); VAR = VAR; } VAR(VAR->VAR); VAR(VAR, VAR, VAR); .VAR = VAR,",0,5
rack_f95113402b7239f225282806673e1b6424522b18,test/spec_multipart.rb,"  should ""reject insanely long boundaries"" do
    # using a pipe since a tempfile can use up too much space
    rd, wr = IO.pipe

    # we only call rewind once at start, so make sure it succeeds
    # and doesn't hit ESPIPE
    def rd.rewind; end
    wr.sync = true

    # mock out length to make this pipe look like a Tempfile
    def rd.length
      1024 * 1024 * 8
    end

    # write to a pipe in a background thread, this will write a lot
    # unless Rack (properly) shuts down the read end
    thr = Thread.new do
      begin
        wr.write(""--AaB03x"")

        # make the initial boundary a few gigs long
        longer = ""0123456789"" * 1024 * 1024
        (1024 * 1024).times { wr.write(longer) }

        wr.write(""\r\n"")
        wr.write('Content-Disposition: form-data; name=""a""; filename=""a.txt""')
        wr.write(""\r\n"")
        wr.write(""Content-Type: text/plain\r\n"")
        wr.write(""\r\na"")
        wr.write(""--AaB03x--\r\n"")
        wr.close
      rescue => err # this is EPIPE if Rack shuts us down
        err
      end
    end

    fixture = {
      ""CONTENT_TYPE"" => ""multipart/form-data; boundary=AaB03x"",
      ""CONTENT_LENGTH"" => rd.length.to_s,
      :input => rd,
    }

    env = Rack::MockRequest.env_for '/', fixture
    lambda {
      Rack::Multipart.parse_multipart(env)
    }.should.raise(EOFError)
    rd.close

    err = thr.value
    err.should.be.instance_of Errno::EPIPE
    wr.close
  end
",,f95113402b7239f225282806673e1b6424522b18,CVE-2013-0183,f95113402b7239f225282806673e1b6424522b18,https://github.com/rack/rack,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR ""VAR VAR VAR VAR"" VAR  VAR, VAR = VAR.VAR   VAR VAR.VAR; VAR VAR.VAR = VAR  VAR VAR.VAR 1024 * 1024 * 8 VAR   VAR = VAR.VAR VAR VAR VAR.VAR(""--VAR"")  VAR = ""0123456789"" * 1024 * 1024 (1024 * 1024).VAR { VAR.VAR(VAR) } VAR.VAR(""\VAR\VAR"") VAR.VAR('VAR-VAR: VAR-VAR; VAR=""VAR""; VAR=""VAR.VAR""') VAR.VAR(""\VAR\VAR"") VAR.VAR(""VAR-VAR: VAR/VAR\VAR\VAR"") VAR.VAR(""\VAR\VAR"") VAR.VAR(""--VAR--\VAR\VAR"") VAR.VAR VAR => VAR  VAR VAR VAR VAR = { ""VAR"" => ""VAR/VAR-VAR; VAR=VAR"", ""VAR"" => VAR.VAR.VAR, :VAR => VAR, } VAR = VAR::VAR.VAR '/', VAR VAR { VAR::VAR.VAR(VAR) }.VAR.VAR(VAR) VAR.VAR VAR = VAR.VAR VAR.VAR.VAR.VAR VAR::VAR VAR.VAR VAR ",0,5
server_d3d65e5c889fc3922efc7a8c764027763bc4764f,liprivate/legacy/OC_Image.php,"
	// Default memory limit for images to load (128 MBytes).
	protected const DEFAULT_MEMORY_LIMIT = 128;

	/**
	 * Check if allocating an image with the given size is allowed.
	 *
	 * @param int $width The image width.
	 * @param int $height The image height.
	 * @return bool true if allocating is allowed, false otherwise
	 */
	private function checkImageMemory($width, $height) {
		$memory_limit = $this->config->getSystemValueInt('preview_max_memory', self::DEFAULT_MEMORY_LIMIT);
		if ($memory_limit < 0) {
			// Not limited.
			return true;
		}

		// Assume 32 bits per pixel.
		if ($width * $height * 4 > $memory_limit * 1024 * 1024) {
			$this->logger->debug('Image size of ' . $width . 'x' . $height . ' would exceed allowed memory limit of ' . $memory_limit);
			return false;
		}

		return true;
	}

	/**
	 * Check if loading an image file from the given path is allowed.
	 *
	 * @param string $path The path to a local file.
	 * @return bool true if allocating is allowed, false otherwise
	 */
	private function checkImageSize($path) {
		$size = getimagesize($path);
		if (!$size) {
			return true;
		}

		$width = $size[0];
		$height = $size[1];
		if (!$this->checkImageMemory($width, $height)) {
			return false;
		}

		return true;
	}

	/**
	 * Check if loading an image from the given data is allowed.
	 *
	 * @param string $data A string of image data as read from a file.
	 * @return bool true if allocating is allowed, false otherwise
	 */
	private function checkImageDataSize($data) {
		$size = getimagesizefromstring($data);
		if (!$size) {
			return true;
		}

		$width = $size[0];
		$height = $size[1];
		if (!$this->checkImageMemory($width, $height)) {
			return false;
		}

		return true;
	}

					if (!$this->checkImageSize($imagePath)) {
						return false;
					}
					if (!$this->checkImageSize($imagePath)) {
						return false;
					}
					if (!$this->checkImageSize($imagePath)) {
						return false;
					}
					if (!$this->checkImageSize($imagePath)) {
						return false;
					}
					if (!$this->checkImageSize($imagePath)) {
						return false;
					}
					if (!$this->checkImageSize($imagePath)) {
						return false;
					}
				$data = file_get_contents($imagePath);
				if (!$this->checkImageDataSize($data)) {
					return false;
				}
				$this->resource = imagecreatefromstring($data);
		if (!$this->checkImageDataSize($str)) {
			return false;
		}
			if (!$this->checkImageDataSize($data)) {
				return false;
			}
		if (!$this->checkImageMemory($meta['width'], $meta['height'])) {
			fclose($fh);
			return false;
		}",				$this->resource = imagecreatefromstring(file_get_contents($imagePath));,d3d65e5c889fc3922efc7a8c764027763bc4764f,CVE-2022-24741,d3d65e5c889fc3922efc7a8c764027763bc4764f,https://github.com/nextcloud/server,NVD_GIT_REPOBASED,74,COMPLETED," VAR VAR VAR = 128; /** * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * @VAR VAR $VAR VAR VAR VAR. * @VAR VAR $VAR VAR VAR VAR. * @VAR VAR VAR VAR VAR VAR VAR, VAR VAR */ VAR VAR VAR($VAR, $VAR) { $VAR = $VAR->VAR->VAR('VAR', VAR::VAR); VAR ($VAR < 0) {  VAR VAR; }  VAR ($VAR * $VAR * 4 > $VAR * 1024 * 1024) { $VAR->VAR->VAR('VAR VAR VAR ' . $VAR . 'VAR' . $VAR . ' VAR VAR VAR VAR VAR VAR ' . $VAR); VAR VAR; } VAR VAR; } /** * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * @VAR VAR $VAR VAR VAR VAR VAR VAR VAR. * @VAR VAR VAR VAR VAR VAR VAR, VAR VAR */ VAR VAR VAR($VAR) { $VAR = VAR($VAR); VAR (!$VAR) { VAR VAR; } $VAR = $VAR[0]; $VAR = $VAR[1]; VAR (!$VAR->VAR($VAR, $VAR)) { VAR VAR; } VAR VAR; } /** * VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * * @VAR VAR $VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. * @VAR VAR VAR VAR VAR VAR VAR, VAR VAR */ VAR VAR VAR($VAR) { $VAR = VAR($VAR); VAR (!$VAR) { VAR VAR; } $VAR = $VAR[0]; $VAR = $VAR[1]; VAR (!$VAR->VAR($VAR, $VAR)) { VAR VAR; } VAR VAR; } VAR (!$VAR->VAR($VAR)) { VAR VAR; } VAR (!$VAR->VAR($VAR)) { VAR VAR; } VAR (!$VAR->VAR($VAR)) { VAR VAR; } VAR (!$VAR->VAR($VAR)) { VAR VAR; } VAR (!$VAR->VAR($VAR)) { VAR VAR; } VAR (!$VAR->VAR($VAR)) { VAR VAR; } $VAR = VAR($VAR); VAR (!$VAR->VAR($VAR)) { VAR VAR; } $VAR->VAR = VAR($VAR); VAR (!$VAR->VAR($VAR)) { VAR VAR; } VAR (!$VAR->VAR($VAR)) { VAR VAR; } VAR (!$VAR->VAR($VAR['VAR'], $VAR['VAR'])) { VAR($VAR); VAR VAR; } $VAR->VAR = VAR(VAR($VAR));",0,5
urllib3_0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,src/urllib3/contri_securetransport/low_level.py,"""""""
Low-level helpers for the SecureTransport bindings.

These are Python functions that are not directly related to the high-level APIs
but are necessary to get them to work. They include a whole bunch of low-level
CoreFoundation messing about and memory management. The concerns in this module
are almost entirely about trying to avoid memory leaks and providing
appropriate and useful assistance to the higher-level code.
""""""
import base64
import ctypes
import itertools
import re
import os
import ssl
import tempfile

from .bindings import Security, CoreFoundation, CFConst


# This regular expression is used to grab PEM data out of a PEM bundle.
_PEM_CERTS_RE = re.compile(
    b""-----BEGIN CERTIFICATE-----\n(.*?)\n-----END CERTIFICATE-----"", re.DOTALL
)


def _cf_data_from_bytes(bytestring):
    """"""
    Given a bytestring, create a CFData object from it. This CFData object must
    be CFReleased by the caller.
    """"""
    return CoreFoundation.CFDataCreate(
        CoreFoundation.kCFAllocatorDefault, bytestring, len(bytestring)
    )


def _cf_dictionary_from_tuples(tuples):
    """"""
    Given a list of Python tuples, create an associated CFDictionary.
    """"""
    dictionary_size = len(tuples)

    # We need to get the dictionary keys and values out in the same order.
    keys = (t[0] for t in tuples)
    values = (t[1] for t in tuples)
    cf_keys = (CoreFoundation.CFTypeRef * dictionary_size)(*keys)
    cf_values = (CoreFoundation.CFTypeRef * dictionary_size)(*values)

    return CoreFoundation.CFDictionaryCreate(
        CoreFoundation.kCFAllocatorDefault,
        cf_keys,
        cf_values,
        dictionary_size,
        CoreFoundation.kCFTypeDictionaryKeyCallBacks,
        CoreFoundation.kCFTypeDictionaryValueCallBacks,
    )


def _cf_string_to_unicode(value):
    """"""
    Creates a Unicode string from a CFString object. Used entirely for error
    reporting.

    Yes, it annoys me quite a lot that this function is this complex.
    """"""
    value_as_void_p = ctypes.cast(value, ctypes.POINTER(ctypes.c_void_p))

    string = CoreFoundation.CFStringGetCStringPtr(
        value_as_void_p,
        CFConst.kCFStringEncodingUTF8
    )
    if string is None:
        buffer = ctypes.create_string_buffer(1024)
        result = CoreFoundation.CFStringGetCString(
            value_as_void_p,
            buffer,
            1024,
            CFConst.kCFStringEncodingUTF8
        )
        if not result:
            raise OSError('Error copying C string from CFStringRef')
        string = buffer.value
    if string is not None:
        string = string.decode('utf-8')
    return string


def _assert_no_error(error, exception_class=None):
    """"""
    Checks the return code and throws an exception if there is an error to
    report
    """"""
    if error == 0:
        return

    cf_error_string = Security.SecCopyErrorMessageString(error, None)
    output = _cf_string_to_unicode(cf_error_string)
    CoreFoundation.CFRelease(cf_error_string)

    if output is None or output == u'':
        output = u'OSStatus %s' % error

    if exception_class is None:
        exception_class = ssl.SSLError

    raise exception_class(output)


def _cert_array_from_pem(pem_bundle):
    """"""
    Given a bundle of certs in PEM format, turns them into a CFArray of certs
    that can be used to validate a cert chain.
    """"""
    # Normalize the PEM bundle's line endings.
    pem_bundle = pem_bundle.replace(b""\r\n"", b""\n"")

    der_certs = [
        base64.b64decode(match.group(1))
        for match in _PEM_CERTS_RE.finditer(pem_bundle)
    ]
    if not der_certs:
        raise ssl.SSLError(""No root certificates specified"")

    cert_array = CoreFoundation.CFArrayCreateMutable(
        CoreFoundation.kCFAllocatorDefault,
        0,
        ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks)
    )
    if not cert_array:
        raise ssl.SSLError(""Unable to allocate memory!"")

    try:
        for der_bytes in der_certs:
            certdata = _cf_data_from_bytes(der_bytes)
            if not certdata:
                raise ssl.SSLError(""Unable to allocate memory!"")
            cert = Security.SecCertificateCreateWithData(
                CoreFoundation.kCFAllocatorDefault, certdata
            )
            CoreFoundation.CFRelease(certdata)
            if not cert:
                raise ssl.SSLError(""Unable to build cert object!"")

            CoreFoundation.CFArrayAppendValue(cert_array, cert)
            CoreFoundation.CFRelease(cert)
    except Exception:
        # We need to free the array before the exception bubbles further.
        # We only want to do that if an error occurs: otherwise, the caller
        # should free.
        CoreFoundation.CFRelease(cert_array)

    return cert_array


def _is_cert(item):
    """"""
    Returns True if a given CFTypeRef is a certificate.
    """"""
    expected = Security.SecCertificateGetTypeID()
    return CoreFoundation.CFGetTypeID(item) == expected


def _is_identity(item):
    """"""
    Returns True if a given CFTypeRef is an identity.
    """"""
    expected = Security.SecIdentityGetTypeID()
    return CoreFoundation.CFGetTypeID(item) == expected


def _temporary_keychain():
    """"""
    This function creates a temporary Mac keychain that we can use to work with
    credentials. This keychain uses a one-time password and a temporary file to
    store the data. We expect to have one keychain per socket. The returned
    SecKeychainRef must be freed by the caller, including calling
    SecKeychainDelete.

    Returns a tuple of the SecKeychainRef and the path to the temporary
    directory that contains it.
    """"""
    # Unfortunately, SecKeychainCreate requires a path to a keychain. This
    # means we cannot use mkstemp to use a generic temporary file. Instead,
    # we're going to create a temporary directory and a filename to use there.
    # This filename will be 8 random bytes expanded into base64. We also need
    # some random bytes to password-protect the keychain we're creating, so we
    # ask for 40 random bytes.
    random_bytes = os.urandom(40)
    filename = base64.b16encode(random_bytes[:8]).decode('utf-8')
    password = base64.b16encode(random_bytes[8:])  # Must be valid UTF-8
    tempdirectory = tempfile.mkdtemp()

    keychain_path = os.path.join(tempdirectory, filename).encode('utf-8')

    # We now want to create the keychain itself.
    keychain = Security.SecKeychainRef()
    status = Security.SecKeychainCreate(
        keychain_path,
        len(password),
        password,
        False,
        None,
        ctypes.byref(keychain)
    )
    _assert_no_error(status)

    # Having created the keychain, we want to pass it off to the caller.
    return keychain, tempdirectory


def _load_items_from_file(keychain, path):
    """"""
    Given a single file, loads all the trust objects from it into arrays and
    the keychain.
    Returns a tuple of lists: the first list is a list of identities, the
    second a list of certs.
    """"""
    certificates = []
    identities = []
    result_array = None

    with open(path, 'rb') as f:
        raw_filedata = f.read()

    try:
        filedata = CoreFoundation.CFDataCreate(
            CoreFoundation.kCFAllocatorDefault,
            raw_filedata,
            len(raw_filedata)
        )
        result_array = CoreFoundation.CFArrayRef()
        result = Security.SecItemImport(
            filedata,  # cert data
            None,  # Filename, leaving it out for now
            None,  # What the type of the file is, we don't care
            None,  # what's in the file, we don't care
            0,  # import flags
            None,  # key params, can include passphrase in the future
            keychain,  # The keychain to insert into
            ctypes.byref(result_array)  # Results
        )
        _assert_no_error(result)

        # A CFArray is not very useful to us as an intermediary
        # representation, so we are going to extract the objects we want
        # and then free the array. We don't need to keep hold of keys: the
        # keychain already has them!
        result_count = CoreFoundation.CFArrayGetCount(result_array)
        for index in range(result_count):
            item = CoreFoundation.CFArrayGetValueAtIndex(
                result_array, index
            )
            item = ctypes.cast(item, CoreFoundation.CFTypeRef)

            if _is_cert(item):
                CoreFoundation.CFRetain(item)
                certificates.append(item)
            elif _is_identity(item):
                CoreFoundation.CFRetain(item)
                identities.append(item)
    finally:
        if result_array:
            CoreFoundation.CFRelease(result_array)

        CoreFoundation.CFRelease(filedata)

    return (identities, certificates)


def _load_client_cert_chain(keychain, *paths):
    """"""
    Load certificates and maybe keys from a number of files. Has the end goal
    of returning a CFArray containing one SecIdentityRef, and then zero or more
    SecCertificateRef objects, suitable for use as a client certificate trust
    chain.
    """"""
    # Ok, the strategy.
    #
    # This relies on knowing that macOS will not give you a SecIdentityRef
    # unless you have imported a key into a keychain. This is a somewhat
    # artificial limitation of macOS (for example, it doesn't necessarily
    # affect iOS), but there is nothing inside Security.framework that lets you
    # get a SecIdentityRef without having a key in a keychain.
    #
    # So the policy here is we take all the files and iterate them in order.
    # Each one will use SecItemImport to have one or more objects loaded from
    # it. We will also point at a keychain that macOS can use to work with the
    # private key.
    #
    # Once we have all the objects, we'll check what we actually have. If we
    # already have a SecIdentityRef in hand, fab: we'll use that. Otherwise,
    # we'll take the first certificate (which we assume to be our leaf) and
    # ask the keychain to give us a SecIdentityRef with that cert's associated
    # key.
    #
    # We'll then return a CFArray containing the trust chain: one
    # SecIdentityRef and then zero-or-more SecCertificateRef objects. The
    # responsibility for freeing this CFArray will be with the caller. This
    # CFArray must remain alive for the entire connection, so in practice it
    # will be stored with a single SSLSocket, along with the reference to the
    # keychain.
    certificates = []
    identities = []

    # Filter out bad paths.
    paths = (path for path in paths if path)

    try:
        for file_path in paths:
            new_identities, new_certs = _load_items_from_file(
                keychain, file_path
            )
            identities.extend(new_identities)
            certificates.extend(new_certs)

        # Ok, we have everything. The question is: do we have an identity? If
        # not, we want to grab one from the first cert we have.
        if not identities:
            new_identity = Security.SecIdentityRef()
            status = Security.SecIdentityCreateWithCertificate(
                keychain,
                certificates[0],
                ctypes.byref(new_identity)
            )
            _assert_no_error(status)
            identities.append(new_identity)

            # We now want to release the original certificate, as we no longer
            # need it.
            CoreFoundation.CFRelease(certificates.pop(0))

        # We now need to build a new CFArray that holds the trust chain.
        trust_chain = CoreFoundation.CFArrayCreateMutable(
            CoreFoundation.kCFAllocatorDefault,
            0,
            ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),
        )
        for item in itertools.chain(identities, certificates):
            # ArrayAppendValue does a CFRetain on the item. That's fine,
            # because the finally block will release our other refs to them.
            CoreFoundation.CFArrayAppendValue(trust_chain, item)

        return trust_chain
    finally:
        for obj in itertools.chain(identities, certificates):
            CoreFoundation.CFRelease(obj)",,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,CVE-2019-11236,0aa3e24fcd75f1bb59ab159e9f8adb44055b2271,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,98,COMPLETED,""""""" VAR-VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR, VAR, VAR  VAR = VAR.VAR( VAR""-----VAR VAR-----\VAR(.*?)\VAR-----VAR VAR-----"", VAR.VAR ) VAR VAR(VAR): """""" VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR( VAR.VAR, VAR, VAR(VAR) ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR = VAR(VAR)  VAR = (VAR[0] VAR VAR VAR VAR) VAR = (VAR[1] VAR VAR VAR VAR) VAR = (VAR.VAR * VAR)(*VAR) VAR = (VAR.VAR * VAR)(*VAR) VAR VAR.VAR( VAR.VAR, VAR, VAR, VAR, VAR.VAR, VAR.VAR, ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(VAR, VAR.VAR(VAR.VAR)) VAR = VAR.VAR( VAR, VAR.VAR ) VAR VAR VAR VAR: VAR = VAR.VAR(1024) VAR = VAR.VAR( VAR, VAR, 1024, VAR.VAR ) VAR VAR VAR: VAR VAR('VAR VAR VAR VAR VAR VAR') VAR = VAR.VAR VAR VAR VAR VAR VAR: VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR VAR == 0: VAR VAR = VAR.VAR(VAR, VAR) VAR = VAR(VAR) VAR.VAR(VAR) VAR VAR VAR VAR VAR VAR == VAR'': VAR = VAR'VAR %VAR' % VAR VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""  VAR = VAR.VAR(VAR""\VAR\VAR"", VAR""\VAR"") VAR = [ VAR.VAR(VAR.VAR(1)) VAR VAR VAR VAR.VAR(VAR) ] VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR"") VAR = VAR.VAR( VAR.VAR, 0, VAR.VAR(VAR.VAR) ) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR!"") VAR: VAR VAR VAR VAR: VAR = VAR(VAR) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR!"") VAR = VAR.VAR( VAR.VAR, VAR ) VAR.VAR(VAR) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR VAR!"") VAR.VAR(VAR, VAR) VAR.VAR(VAR) VAR VAR:    VAR.VAR(VAR) VAR VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR VAR.VAR(VAR) == VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR VAR.VAR(VAR) == VAR VAR VAR(): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""       VAR = VAR.VAR(40) VAR = VAR.VAR(VAR[:8]).VAR('VAR-8') VAR = VAR.VAR(VAR[8:])  VAR = VAR.VAR() VAR = VAR.VAR.VAR(VAR, VAR).VAR('VAR-8')  VAR = VAR.VAR() VAR = VAR.VAR( VAR, VAR(VAR), VAR, VAR, VAR, VAR.VAR(VAR) ) VAR(VAR)  VAR VAR, VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. """""" VAR = [] VAR = [] VAR = VAR VAR VAR(VAR, 'VAR') VAR VAR: VAR = VAR.VAR() VAR: VAR = VAR.VAR( VAR.VAR, VAR, VAR(VAR) ) VAR = VAR.VAR() VAR = VAR.VAR( VAR,  VAR,  VAR,  VAR,  0,  VAR,  VAR,  VAR.VAR(VAR)  ) VAR(VAR)     VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR = VAR.VAR( VAR, VAR ) VAR = VAR.VAR(VAR, VAR.VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR.VAR(VAR) VAR: VAR VAR: VAR.VAR(VAR) VAR.VAR(VAR) VAR (VAR, VAR) VAR VAR(VAR, *VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""                          VAR = [] VAR = []  VAR = (VAR VAR VAR VAR VAR VAR VAR) VAR: VAR VAR VAR VAR: VAR, VAR = VAR( VAR, VAR ) VAR.VAR(VAR) VAR.VAR(VAR)   VAR VAR VAR: VAR = VAR.VAR() VAR = VAR.VAR( VAR, VAR[0], VAR.VAR(VAR) ) VAR(VAR) VAR.VAR(VAR)   VAR.VAR(VAR.VAR(0))  VAR = VAR.VAR( VAR.VAR, 0, VAR.VAR(VAR.VAR), ) VAR VAR VAR VAR.VAR(VAR, VAR):   VAR.VAR(VAR, VAR) VAR VAR VAR: VAR VAR VAR VAR.VAR(VAR, VAR): VAR.VAR(VAR) ",0,5
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,src/urllib3/contri_securetransport/low_level.py,"""""""
Low-level helpers for the SecureTransport bindings.

These are Python functions that are not directly related to the high-level APIs
but are necessary to get them to work. They include a whole bunch of low-level
CoreFoundation messing about and memory management. The concerns in this module
are almost entirely about trying to avoid memory leaks and providing
appropriate and useful assistance to the higher-level code.
""""""
import base64
import ctypes
import itertools
import os
import re
import ssl
import struct
import tempfile

from .bindings import CFConst, CoreFoundation, Security

# This regular expression is used to grab PEM data out of a PEM bundle.
_PEM_CERTS_RE = re.compile(
    b""-----BEGIN CERTIFICATE-----\n(.*?)\n-----END CERTIFICATE-----"", re.DOTALL
)


def _cf_data_from_bytes(bytestring):
    """"""
    Given a bytestring, create a CFData object from it. This CFData object must
    be CFReleased by the caller.
    """"""
    return CoreFoundation.CFDataCreate(
        CoreFoundation.kCFAllocatorDefault, bytestring, len(bytestring)
    )


def _cf_dictionary_from_tuples(tuples):
    """"""
    Given a list of Python tuples, create an associated CFDictionary.
    """"""
    dictionary_size = len(tuples)

    # We need to get the dictionary keys and values out in the same order.
    keys = (t[0] for t in tuples)
    values = (t[1] for t in tuples)
    cf_keys = (CoreFoundation.CFTypeRef * dictionary_size)(*keys)
    cf_values = (CoreFoundation.CFTypeRef * dictionary_size)(*values)

    return CoreFoundation.CFDictionaryCreate(
        CoreFoundation.kCFAllocatorDefault,
        cf_keys,
        cf_values,
        dictionary_size,
        CoreFoundation.kCFTypeDictionaryKeyCallBacks,
        CoreFoundation.kCFTypeDictionaryValueCallBacks,
    )


def _cfstr(py_bstr):
    """"""
    Given a Python binary data, create a CFString.
    The string must be CFReleased by the caller.
    """"""
    c_str = ctypes.c_char_p(py_bstr)
    cf_str = CoreFoundation.CFStringCreateWithCString(
        CoreFoundation.kCFAllocatorDefault,
        c_str,
        CFConst.kCFStringEncodingUTF8,
    )
    return cf_str


def _create_cfstring_array(lst):
    """"""
    Given a list of Python binary data, create an associated CFMutableArray.
    The array must be CFReleased by the caller.

    Raises an ssl.SSLError on failure.
    """"""
    cf_arr = None
    try:
        cf_arr = CoreFoundation.CFArrayCreateMutable(
            CoreFoundation.kCFAllocatorDefault,
            0,
            ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),
        )
        if not cf_arr:
            raise MemoryError(""Unable to allocate memory!"")
        for item in lst:
            cf_str = _cfstr(item)
            if not cf_str:
                raise MemoryError(""Unable to allocate memory!"")
            try:
                CoreFoundation.CFArrayAppendValue(cf_arr, cf_str)
            finally:
                CoreFoundation.CFRelease(cf_str)
    except BaseException as e:
        if cf_arr:
            CoreFoundation.CFRelease(cf_arr)
        raise ssl.SSLError(""Unable to allocate array: %s"" % (e,))
    return cf_arr


def _cf_string_to_unicode(value):
    """"""
    Creates a Unicode string from a CFString object. Used entirely for error
    reporting.

    Yes, it annoys me quite a lot that this function is this complex.
    """"""
    value_as_void_p = ctypes.cast(value, ctypes.POINTER(ctypes.c_void_p))

    string = CoreFoundation.CFStringGetCStringPtr(
        value_as_void_p, CFConst.kCFStringEncodingUTF8
    )
    if string is None:
        buffer = ctypes.create_string_buffer(1024)
        result = CoreFoundation.CFStringGetCString(
            value_as_void_p, buffer, 1024, CFConst.kCFStringEncodingUTF8
        )
        if not result:
            raise OSError(""Error copying C string from CFStringRef"")
        string = buffer.value
    if string is not None:
        string = string.decode(""utf-8"")
    return string


def _assert_no_error(error, exception_class=None):
    """"""
    Checks the return code and throws an exception if there is an error to
    report
    """"""
    if error == 0:
        return

    cf_error_string = Security.SecCopyErrorMessageString(error, None)
    output = _cf_string_to_unicode(cf_error_string)
    CoreFoundation.CFRelease(cf_error_string)

    if output is None or output == u"""":
        output = u""OSStatus %s"" % error

    if exception_class is None:
        exception_class = ssl.SSLError

    raise exception_class(output)


def _cert_array_from_pem(pem_bundle):
    """"""
    Given a bundle of certs in PEM format, turns them into a CFArray of certs
    that can be used to validate a cert chain.
    """"""
    # Normalize the PEM bundle's line endings.
    pem_bundle = pem_bundle.replace(b""\r\n"", b""\n"")

    der_certs = [
        base64.b64decode(match.group(1)) for match in _PEM_CERTS_RE.finditer(pem_bundle)
    ]
    if not der_certs:
        raise ssl.SSLError(""No root certificates specified"")

    cert_array = CoreFoundation.CFArrayCreateMutable(
        CoreFoundation.kCFAllocatorDefault,
        0,
        ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),
    )
    if not cert_array:
        raise ssl.SSLError(""Unable to allocate memory!"")

    try:
        for der_bytes in der_certs:
            certdata = _cf_data_from_bytes(der_bytes)
            if not certdata:
                raise ssl.SSLError(""Unable to allocate memory!"")
            cert = Security.SecCertificateCreateWithData(
                CoreFoundation.kCFAllocatorDefault, certdata
            )
            CoreFoundation.CFRelease(certdata)
            if not cert:
                raise ssl.SSLError(""Unable to build cert object!"")

            CoreFoundation.CFArrayAppendValue(cert_array, cert)
            CoreFoundation.CFRelease(cert)
    except Exception:
        # We need to free the array before the exception bubbles further.
        # We only want to do that if an error occurs: otherwise, the caller
        # should free.
        CoreFoundation.CFRelease(cert_array)

    return cert_array


def _is_cert(item):
    """"""
    Returns True if a given CFTypeRef is a certificate.
    """"""
    expected = Security.SecCertificateGetTypeID()
    return CoreFoundation.CFGetTypeID(item) == expected


def _is_identity(item):
    """"""
    Returns True if a given CFTypeRef is an identity.
    """"""
    expected = Security.SecIdentityGetTypeID()
    return CoreFoundation.CFGetTypeID(item) == expected


def _temporary_keychain():
    """"""
    This function creates a temporary Mac keychain that we can use to work with
    credentials. This keychain uses a one-time password and a temporary file to
    store the data. We expect to have one keychain per socket. The returned
    SecKeychainRef must be freed by the caller, including calling
    SecKeychainDelete.

    Returns a tuple of the SecKeychainRef and the path to the temporary
    directory that contains it.
    """"""
    # Unfortunately, SecKeychainCreate requires a path to a keychain. This
    # means we cannot use mkstemp to use a generic temporary file. Instead,
    # we're going to create a temporary directory and a filename to use there.
    # This filename will be 8 random bytes expanded into base64. We also need
    # some random bytes to password-protect the keychain we're creating, so we
    # ask for 40 random bytes.
    random_bytes = os.urandom(40)
    filename = base64.b16encode(random_bytes[:8]).decode(""utf-8"")
    password = base64.b16encode(random_bytes[8:])  # Must be valid UTF-8
    tempdirectory = tempfile.mkdtemp()

    keychain_path = os.path.join(tempdirectory, filename).encode(""utf-8"")

    # We now want to create the keychain itself.
    keychain = Security.SecKeychainRef()
    status = Security.SecKeychainCreate(
        keychain_path, len(password), password, False, None, ctypes.byref(keychain)
    )
    _assert_no_error(status)

    # Having created the keychain, we want to pass it off to the caller.
    return keychain, tempdirectory


def _load_items_from_file(keychain, path):
    """"""
    Given a single file, loads all the trust objects from it into arrays and
    the keychain.
    Returns a tuple of lists: the first list is a list of identities, the
    second a list of certs.
    """"""
    certificates = []
    identities = []
    result_array = None

    with open(path, ""rb"") as f:
        raw_filedata = f.read()

    try:
        filedata = CoreFoundation.CFDataCreate(
            CoreFoundation.kCFAllocatorDefault, raw_filedata, len(raw_filedata)
        )
        result_array = CoreFoundation.CFArrayRef()
        result = Security.SecItemImport(
            filedata,  # cert data
            None,  # Filename, leaving it out for now
            None,  # What the type of the file is, we don't care
            None,  # what's in the file, we don't care
            0,  # import flags
            None,  # key params, can include passphrase in the future
            keychain,  # The keychain to insert into
            ctypes.byref(result_array),  # Results
        )
        _assert_no_error(result)

        # A CFArray is not very useful to us as an intermediary
        # representation, so we are going to extract the objects we want
        # and then free the array. We don't need to keep hold of keys: the
        # keychain already has them!
        result_count = CoreFoundation.CFArrayGetCount(result_array)
        for index in range(result_count):
            item = CoreFoundation.CFArrayGetValueAtIndex(result_array, index)
            item = ctypes.cast(item, CoreFoundation.CFTypeRef)

            if _is_cert(item):
                CoreFoundation.CFRetain(item)
                certificates.append(item)
            elif _is_identity(item):
                CoreFoundation.CFRetain(item)
                identities.append(item)
    finally:
        if result_array:
            CoreFoundation.CFRelease(result_array)

        CoreFoundation.CFRelease(filedata)

    return (identities, certificates)


def _load_client_cert_chain(keychain, *paths):
    """"""
    Load certificates and maybe keys from a number of files. Has the end goal
    of returning a CFArray containing one SecIdentityRef, and then zero or more
    SecCertificateRef objects, suitable for use as a client certificate trust
    chain.
    """"""
    # Ok, the strategy.
    #
    # This relies on knowing that macOS will not give you a SecIdentityRef
    # unless you have imported a key into a keychain. This is a somewhat
    # artificial limitation of macOS (for example, it doesn't necessarily
    # affect iOS), but there is nothing inside Security.framework that lets you
    # get a SecIdentityRef without having a key in a keychain.
    #
    # So the policy here is we take all the files and iterate them in order.
    # Each one will use SecItemImport to have one or more objects loaded from
    # it. We will also point at a keychain that macOS can use to work with the
    # private key.
    #
    # Once we have all the objects, we'll check what we actually have. If we
    # already have a SecIdentityRef in hand, fab: we'll use that. Otherwise,
    # we'll take the first certificate (which we assume to be our leaf) and
    # ask the keychain to give us a SecIdentityRef with that cert's associated
    # key.
    #
    # We'll then return a CFArray containing the trust chain: one
    # SecIdentityRef and then zero-or-more SecCertificateRef objects. The
    # responsibility for freeing this CFArray will be with the caller. This
    # CFArray must remain alive for the entire connection, so in practice it
    # will be stored with a single SSLSocket, along with the reference to the
    # keychain.
    certificates = []
    identities = []

    # Filter out bad paths.
    paths = (path for path in paths if path)

    try:
        for file_path in paths:
            new_identities, new_certs = _load_items_from_file(keychain, file_path)
            identities.extend(new_identities)
            certificates.extend(new_certs)

        # Ok, we have everything. The question is: do we have an identity? If
        # not, we want to grab one from the first cert we have.
        if not identities:
            new_identity = Security.SecIdentityRef()
            status = Security.SecIdentityCreateWithCertificate(
                keychain, certificates[0], ctypes.byref(new_identity)
            )
            _assert_no_error(status)
            identities.append(new_identity)

            # We now want to release the original certificate, as we no longer
            # need it.
            CoreFoundation.CFRelease(certificates.pop(0))

        # We now need to build a new CFArray that holds the trust chain.
        trust_chain = CoreFoundation.CFArrayCreateMutable(
            CoreFoundation.kCFAllocatorDefault,
            0,
            ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),
        )
        for item in itertools.chain(identities, certificates):
            # ArrayAppendValue does a CFRetain on the item. That's fine,
            # because the finally block will release our other refs to them.
            CoreFoundation.CFArrayAppendValue(trust_chain, item)

        return trust_chain
    finally:
        for obj in itertools.chain(identities, certificates):
            CoreFoundation.CFRelease(obj)


TLS_PROTOCOL_VERSIONS = {
    ""SSLv2"": (0, 2),
    ""SSLv3"": (3, 0),
    ""TLSv1"": (3, 1),
    ""TLSv1.1"": (3, 2),
    ""TLSv1.2"": (3, 3),
}


def _build_tls_unknown_ca_alert(version):
    """"""
    Builds a TLS alert record for an unknown CA.
    """"""
    ver_maj, ver_min = TLS_PROTOCOL_VERSIONS[version]
    severity_fatal = 0x02
    description_unknown_ca = 0x30
    msg = struct.pack("">BB"", severity_fatal, description_unknown_ca)
    msg_len = len(msg)
    record_type_alert = 0x15
    record = struct.pack("">BBBH"", record_type_alert, ver_maj, ver_min, msg_len) + msg
    return record",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,""""""" VAR-VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR, VAR, VAR  VAR = VAR.VAR( VAR""-----VAR VAR-----\VAR(.*?)\VAR-----VAR VAR-----"", VAR.VAR ) VAR VAR(VAR): """""" VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR( VAR.VAR, VAR, VAR(VAR) ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR = VAR(VAR)  VAR = (VAR[0] VAR VAR VAR VAR) VAR = (VAR[1] VAR VAR VAR VAR) VAR = (VAR.VAR * VAR)(*VAR) VAR = (VAR.VAR * VAR)(*VAR) VAR VAR.VAR( VAR.VAR, VAR, VAR, VAR, VAR.VAR, VAR.VAR, ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR, VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(VAR) VAR = VAR.VAR( VAR.VAR, VAR, VAR.VAR, ) VAR VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR.VAR VAR VAR. """""" VAR = VAR VAR: VAR = VAR.VAR( VAR.VAR, 0, VAR.VAR(VAR.VAR), ) VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR!"") VAR VAR VAR VAR: VAR = VAR(VAR) VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR!"") VAR: VAR.VAR(VAR, VAR) VAR: VAR.VAR(VAR) VAR VAR VAR VAR: VAR VAR: VAR.VAR(VAR) VAR VAR.VAR(""VAR VAR VAR VAR: %VAR"" % (VAR,)) VAR VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(VAR, VAR.VAR(VAR.VAR)) VAR = VAR.VAR( VAR, VAR.VAR ) VAR VAR VAR VAR: VAR = VAR.VAR(1024) VAR = VAR.VAR( VAR, VAR, 1024, VAR.VAR ) VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR VAR"") VAR = VAR.VAR VAR VAR VAR VAR VAR: VAR = VAR.VAR(""VAR-8"") VAR VAR VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR VAR == 0: VAR VAR = VAR.VAR(VAR, VAR) VAR = VAR(VAR) VAR.VAR(VAR) VAR VAR VAR VAR VAR VAR == VAR"""": VAR = VAR""VAR %VAR"" % VAR VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""  VAR = VAR.VAR(VAR""\VAR\VAR"", VAR""\VAR"") VAR = [ VAR.VAR(VAR.VAR(1)) VAR VAR VAR VAR.VAR(VAR) ] VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR"") VAR = VAR.VAR( VAR.VAR, 0, VAR.VAR(VAR.VAR), ) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR!"") VAR: VAR VAR VAR VAR: VAR = VAR(VAR) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR!"") VAR = VAR.VAR( VAR.VAR, VAR ) VAR.VAR(VAR) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR VAR!"") VAR.VAR(VAR, VAR) VAR.VAR(VAR) VAR VAR:    VAR.VAR(VAR) VAR VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR VAR.VAR(VAR) == VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR VAR.VAR(VAR) == VAR VAR VAR(): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""       VAR = VAR.VAR(40) VAR = VAR.VAR(VAR[:8]).VAR(""VAR-8"") VAR = VAR.VAR(VAR[8:])  VAR = VAR.VAR() VAR = VAR.VAR.VAR(VAR, VAR).VAR(""VAR-8"")  VAR = VAR.VAR() VAR = VAR.VAR( VAR, VAR(VAR), VAR, VAR, VAR, VAR.VAR(VAR) ) VAR(VAR)  VAR VAR, VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. """""" VAR = [] VAR = [] VAR = VAR VAR VAR(VAR, ""VAR"") VAR VAR: VAR = VAR.VAR() VAR: VAR = VAR.VAR( VAR.VAR, VAR, VAR(VAR) ) VAR = VAR.VAR() VAR = VAR.VAR( VAR,  VAR,  VAR,  VAR,  0,  VAR,  VAR,  VAR.VAR(VAR),  ) VAR(VAR)     VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR = VAR.VAR(VAR, VAR) VAR = VAR.VAR(VAR, VAR.VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR.VAR(VAR) VAR: VAR VAR: VAR.VAR(VAR) VAR.VAR(VAR) VAR (VAR, VAR) VAR VAR(VAR, *VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""                          VAR = [] VAR = []  VAR = (VAR VAR VAR VAR VAR VAR VAR) VAR: VAR VAR VAR VAR: VAR, VAR = VAR(VAR, VAR) VAR.VAR(VAR) VAR.VAR(VAR)   VAR VAR VAR: VAR = VAR.VAR() VAR = VAR.VAR( VAR, VAR[0], VAR.VAR(VAR) ) VAR(VAR) VAR.VAR(VAR)   VAR.VAR(VAR.VAR(0))  VAR = VAR.VAR( VAR.VAR, 0, VAR.VAR(VAR.VAR), ) VAR VAR VAR VAR.VAR(VAR, VAR):   VAR.VAR(VAR, VAR) VAR VAR VAR: VAR VAR VAR VAR.VAR(VAR, VAR): VAR.VAR(VAR) VAR = { ""VAR"": (0, 2), ""VAR"": (3, 0), ""VAR"": (3, 1), ""VAR.1"": (3, 2), ""VAR.2"": (3, 3), } VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR, VAR = VAR[VAR] VAR = 0x02 VAR = 0x30 VAR = VAR.VAR("">VAR"", VAR, VAR) VAR = VAR(VAR) VAR = 0x15 VAR = VAR.VAR("">VAR"", VAR, VAR, VAR, VAR) + VAR VAR VAR ",0,5
urllib3_2d4a3fee6de2fa45eb82169361918f759269b4ec,src/urllib3/util/ssltransport.py,"import io
import socket
import ssl

from urllib3.exceptions import ProxySchemeUnsupported
from urllib3.packages import six

SSL_BLOCKSIZE = 16384


class SSLTransport:
    """"""
    The SSLTransport wraps an existing socket and establishes an SSL connection.

    Contrary to Python's implementation of SSLSocket, it allows you to chain
    multiple TLS connections together. It's particularly useful if you need to
    implement TLS within TLS.

    The class supports most of the socket API operations.
    """"""

    @staticmethod
    def _validate_ssl_context_for_tls_in_tls(ssl_context):
        """"""
        Raises a ProxySchemeUnsupported if the provided ssl_context can't be used
        for TLS in TLS.

        The only requirement is that the ssl_context provides the 'wrap_bio'
        methods.
        """"""

        if not hasattr(ssl_context, ""wrap_bio""):
            if six.PY2:
                raise ProxySchemeUnsupported(
                    ""TLS in TLS requires SSLContext.wrap_bio() which isn't ""
                    ""supported on Python 2""
                )
            else:
                raise ProxySchemeUnsupported(
                    ""TLS in TLS requires SSLContext.wrap_bio() which isn't ""
                    ""available on non-native SSLContext""
                )

    def __init__(
        self, socket, ssl_context, server_hostname=None, suppress_ragged_eofs=True
    ):
        """"""
        Create an SSLTransport around socket using the provided ssl_context.
        """"""
        self.incoming = ssl.MemoryBIO()
        self.outgoing = ssl.MemoryBIO()

        self.suppress_ragged_eofs = suppress_ragged_eofs
        self.socket = socket

        self.sslobj = ssl_context.wrap_bio(
            self.incoming, self.outgoing, server_hostname=server_hostname
        )

        # Perform initial handshake.
        self._ssl_io_loop(self.sslobj.do_handshake)

    def __enter__(self):
        return self

    def __exit__(self, *_):
        self.close()

    def fileno(self):
        return self.socket.fileno()

    def read(self, len=1024, buffer=None):
        return self._wrap_ssl_read(len, buffer)

    def recv(self, len=1024, flags=0):
        if flags != 0:
            raise ValueError(""non-zero flags not allowed in calls to recv"")
        return self._wrap_ssl_read(len)

    def recv_into(self, buffer, nbytes=None, flags=0):
        if flags != 0:
            raise ValueError(""non-zero flags not allowed in calls to recv_into"")
        if buffer and (nbytes is None):
            nbytes = len(buffer)
        elif nbytes is None:
            nbytes = 1024
        return self.read(nbytes, buffer)

    def sendall(self, data, flags=0):
        if flags != 0:
            raise ValueError(""non-zero flags not allowed in calls to sendall"")
        count = 0
        with memoryview(data) as view, view.cast(""B"") as byte_view:
            amount = len(byte_view)
            while count < amount:
                v = self.send(byte_view[count:])
                count += v

    def send(self, data, flags=0):
        if flags != 0:
            raise ValueError(""non-zero flags not allowed in calls to send"")
        response = self._ssl_io_loop(self.sslobj.write, data)
        return response

    def makefile(
        self, mode=""r"", buffering=None, encoding=None, errors=None, newline=None
    ):
        """"""
        Python's httpclient uses makefile and buffered io when reading HTTP
        messages and we need to support it.

        This is unfortunately a copy and paste of socket.py makefile with small
        changes to point to the socket directly.
        """"""
        if not set(mode) <= {""r"", ""w"", ""b""}:
            raise ValueError(""invalid mode %r (only r, w, b allowed)"" % (mode,))

        writing = ""w"" in mode
        reading = ""r"" in mode or not writing
        assert reading or writing
        binary = ""b"" in mode
        rawmode = """"
        if reading:
            rawmode += ""r""
        if writing:
            rawmode += ""w""
        raw = socket.SocketIO(self, rawmode)
        self.socket._io_refs += 1
        if buffering is None:
            buffering = -1
        if buffering < 0:
            buffering = io.DEFAULT_BUFFER_SIZE
        if buffering == 0:
            if not binary:
                raise ValueError(""unbuffered streams must be binary"")
            return raw
        if reading and writing:
            buffer = io.BufferedRWPair(raw, raw, buffering)
        elif reading:
            buffer = io.BufferedReader(raw, buffering)
        else:
            assert writing
            buffer = io.BufferedWriter(raw, buffering)
        if binary:
            return buffer
        text = io.TextIOWrapper(buffer, encoding, errors, newline)
        text.mode = mode
        return text

    def unwrap(self):
        self._ssl_io_loop(self.sslobj.unwrap)

    def close(self):
        self.socket.close()

    def getpeercert(self, binary_form=False):
        return self.sslobj.getpeercert(binary_form)

    def version(self):
        return self.sslobj.version()

    def cipher(self):
        return self.sslobj.cipher()

    def selected_alpn_protocol(self):
        return self.sslobj.selected_alpn_protocol()

    def selected_npn_protocol(self):
        return self.sslobj.selected_npn_protocol()

    def shared_ciphers(self):
        return self.sslobj.shared_ciphers()

    def compression(self):
        return self.sslobj.compression()

    def settimeout(self, value):
        self.socket.settimeout(value)

    def gettimeout(self):
        return self.socket.gettimeout()

    def _decref_socketios(self):
        self.socket._decref_socketios()

    def _wrap_ssl_read(self, len, buffer=None):
        try:
            return self._ssl_io_loop(self.sslobj.read, len, buffer)
        except ssl.SSLError as e:
            if e.errno == ssl.SSL_ERROR_EOF and self.suppress_ragged_eofs:
                return 0  # eof, return 0.
            else:
                raise

    def _ssl_io_loop(self, func, *args):
        """"""Performs an I/O loop between incoming/outgoing and the socket.""""""
        should_loop = True
        ret = None

        while should_loop:
            errno = None
            try:
                ret = func(*args)
            except ssl.SSLError as e:
                if e.errno not in (ssl.SSL_ERROR_WANT_READ, ssl.SSL_ERROR_WANT_WRITE):
                    # WANT_READ, and WANT_WRITE are expected, others are not.
                    raise e
                errno = e.errno

            buf = self.outgoing.read()
            self.socket.sendall(buf)

            if errno is None:
                should_loop = False
            elif errno == ssl.SSL_ERROR_WANT_READ:
                buf = self.socket.recv(SSL_BLOCKSIZE)
                if buf:
                    self.incoming.write(buf)
                else:
                    self.incoming.write_eof()
        return ret",,2d4a3fee6de2fa45eb82169361918f759269b4ec,CVE-2021-33503,2d4a3fee6de2fa45eb82169361918f759269b4ec,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR.VAR VAR VAR VAR = 16384 VAR VAR: """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR'VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" @VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR'VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR 'VAR' VAR. """""" VAR VAR VAR(VAR, ""VAR""): VAR VAR.VAR: VAR VAR( ""VAR VAR VAR VAR VAR.VAR() VAR VAR'VAR "" ""VAR VAR VAR 2"" ) VAR: VAR VAR( ""VAR VAR VAR VAR VAR.VAR() VAR VAR'VAR "" ""VAR VAR VAR-VAR VAR"" ) VAR VAR( VAR, VAR, VAR, VAR=VAR, VAR=VAR ): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR.VAR = VAR.VAR() VAR.VAR = VAR.VAR() VAR.VAR = VAR VAR.VAR = VAR VAR.VAR = VAR.VAR( VAR.VAR, VAR.VAR, VAR=VAR )  VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR VAR VAR VAR(VAR, *VAR): VAR.VAR() VAR VAR(VAR): VAR VAR.VAR.VAR() VAR VAR(VAR, VAR=1024, VAR=VAR): VAR VAR.VAR(VAR, VAR) VAR VAR(VAR, VAR=1024, VAR=0): VAR VAR != 0: VAR VAR(""VAR-VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR.VAR(VAR) VAR VAR(VAR, VAR, VAR=VAR, VAR=0): VAR VAR != 0: VAR VAR(""VAR-VAR VAR VAR VAR VAR VAR VAR VAR"") VAR VAR VAR (VAR VAR VAR): VAR = VAR(VAR) VAR VAR VAR VAR: VAR = 1024 VAR VAR.VAR(VAR, VAR) VAR VAR(VAR, VAR, VAR=0): VAR VAR != 0: VAR VAR(""VAR-VAR VAR VAR VAR VAR VAR VAR VAR"") VAR = 0 VAR VAR(VAR) VAR VAR, VAR.VAR(""VAR"") VAR VAR: VAR = VAR(VAR) VAR VAR < VAR: VAR = VAR.VAR(VAR[VAR:]) VAR += VAR VAR VAR(VAR, VAR, VAR=0): VAR VAR != 0: VAR VAR(""VAR-VAR VAR VAR VAR VAR VAR VAR VAR"") VAR = VAR.VAR(VAR.VAR.VAR, VAR) VAR VAR VAR VAR( VAR, VAR=""VAR"", VAR=VAR, VAR=VAR, VAR=VAR, VAR=VAR ): """""" VAR'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR.VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR VAR(VAR) <= {""VAR"", ""VAR"", ""VAR""}: VAR VAR(""VAR VAR %VAR (VAR VAR, VAR, VAR VAR)"" % (VAR,)) VAR = ""VAR"" VAR VAR VAR = ""VAR"" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR = ""VAR"" VAR VAR VAR = """" VAR VAR: VAR += ""VAR"" VAR VAR: VAR += ""VAR"" VAR = VAR.VAR(VAR, VAR) VAR.VAR.VAR += 1 VAR VAR VAR VAR: VAR = -1 VAR VAR < 0: VAR = VAR.VAR VAR VAR == 0: VAR VAR VAR: VAR VAR(""VAR VAR VAR VAR VAR"") VAR VAR VAR VAR VAR VAR: VAR = VAR.VAR(VAR, VAR, VAR) VAR VAR: VAR = VAR.VAR(VAR, VAR) VAR: VAR VAR VAR = VAR.VAR(VAR, VAR) VAR VAR: VAR VAR VAR = VAR.VAR(VAR, VAR, VAR, VAR) VAR.VAR = VAR VAR VAR VAR VAR(VAR): VAR.VAR(VAR.VAR.VAR) VAR VAR(VAR): VAR.VAR.VAR() VAR VAR(VAR, VAR=VAR): VAR VAR.VAR.VAR(VAR) VAR VAR(VAR): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR VAR.VAR.VAR() VAR VAR(VAR, VAR): VAR.VAR.VAR(VAR) VAR VAR(VAR): VAR VAR.VAR.VAR() VAR VAR(VAR): VAR.VAR.VAR() VAR VAR(VAR, VAR, VAR=VAR): VAR: VAR VAR.VAR(VAR.VAR.VAR, VAR, VAR) VAR VAR.VAR VAR VAR: VAR VAR.VAR == VAR.VAR VAR VAR.VAR: VAR 0  VAR: VAR VAR VAR(VAR, VAR, *VAR): """"""VAR VAR VAR/VAR VAR VAR VAR/VAR VAR VAR VAR."""""" VAR = VAR VAR = VAR VAR VAR: VAR = VAR VAR: VAR = VAR(*VAR) VAR VAR.VAR VAR VAR: VAR VAR.VAR VAR VAR (VAR.VAR, VAR.VAR):  VAR VAR VAR = VAR.VAR VAR = VAR.VAR.VAR() VAR.VAR.VAR(VAR) VAR VAR VAR VAR: VAR = VAR VAR VAR == VAR.VAR: VAR = VAR.VAR.VAR(VAR) VAR VAR: VAR.VAR.VAR(VAR) VAR: VAR.VAR.VAR() VAR VAR ",0,5
urllib3_9b76785331243689a9d52cef3db05ef7462cb02d,src/urllib3/contri_securetransport/low_level.py,"""""""
Low-level helpers for the SecureTransport bindings.

These are Python functions that are not directly related to the high-level APIs
but are necessary to get them to work. They include a whole bunch of low-level
CoreFoundation messing about and memory management. The concerns in this module
are almost entirely about trying to avoid memory leaks and providing
appropriate and useful assistance to the higher-level code.
""""""
import base64
import ctypes
import itertools
import re
import os
import ssl
import tempfile

from .bindings import Security, CoreFoundation, CFConst


# This regular expression is used to grab PEM data out of a PEM bundle.
_PEM_CERTS_RE = re.compile(
    b""-----BEGIN CERTIFICATE-----\n(.*?)\n-----END CERTIFICATE-----"", re.DOTALL
)


def _cf_data_from_bytes(bytestring):
    """"""
    Given a bytestring, create a CFData object from it. This CFData object must
    be CFReleased by the caller.
    """"""
    return CoreFoundation.CFDataCreate(
        CoreFoundation.kCFAllocatorDefault, bytestring, len(bytestring)
    )


def _cf_dictionary_from_tuples(tuples):
    """"""
    Given a list of Python tuples, create an associated CFDictionary.
    """"""
    dictionary_size = len(tuples)

    # We need to get the dictionary keys and values out in the same order.
    keys = (t[0] for t in tuples)
    values = (t[1] for t in tuples)
    cf_keys = (CoreFoundation.CFTypeRef * dictionary_size)(*keys)
    cf_values = (CoreFoundation.CFTypeRef * dictionary_size)(*values)

    return CoreFoundation.CFDictionaryCreate(
        CoreFoundation.kCFAllocatorDefault,
        cf_keys,
        cf_values,
        dictionary_size,
        CoreFoundation.kCFTypeDictionaryKeyCallBacks,
        CoreFoundation.kCFTypeDictionaryValueCallBacks,
    )


def _cf_string_to_unicode(value):
    """"""
    Creates a Unicode string from a CFString object. Used entirely for error
    reporting.

    Yes, it annoys me quite a lot that this function is this complex.
    """"""
    value_as_void_p = ctypes.cast(value, ctypes.POINTER(ctypes.c_void_p))

    string = CoreFoundation.CFStringGetCStringPtr(
        value_as_void_p,
        CFConst.kCFStringEncodingUTF8
    )
    if string is None:
        buffer = ctypes.create_string_buffer(1024)
        result = CoreFoundation.CFStringGetCString(
            value_as_void_p,
            buffer,
            1024,
            CFConst.kCFStringEncodingUTF8
        )
        if not result:
            raise OSError('Error copying C string from CFStringRef')
        string = buffer.value
    if string is not None:
        string = string.decode('utf-8')
    return string


def _assert_no_error(error, exception_class=None):
    """"""
    Checks the return code and throws an exception if there is an error to
    report
    """"""
    if error == 0:
        return

    cf_error_string = Security.SecCopyErrorMessageString(error, None)
    output = _cf_string_to_unicode(cf_error_string)
    CoreFoundation.CFRelease(cf_error_string)

    if output is None or output == u'':
        output = u'OSStatus %s' % error

    if exception_class is None:
        exception_class = ssl.SSLError

    raise exception_class(output)


def _cert_array_from_pem(pem_bundle):
    """"""
    Given a bundle of certs in PEM format, turns them into a CFArray of certs
    that can be used to validate a cert chain.
    """"""
    # Normalize the PEM bundle's line endings.
    pem_bundle = pem_bundle.replace(b""\r\n"", b""\n"")

    der_certs = [
        base64.b64decode(match.group(1))
        for match in _PEM_CERTS_RE.finditer(pem_bundle)
    ]
    if not der_certs:
        raise ssl.SSLError(""No root certificates specified"")

    cert_array = CoreFoundation.CFArrayCreateMutable(
        CoreFoundation.kCFAllocatorDefault,
        0,
        ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks)
    )
    if not cert_array:
        raise ssl.SSLError(""Unable to allocate memory!"")

    try:
        for der_bytes in der_certs:
            certdata = _cf_data_from_bytes(der_bytes)
            if not certdata:
                raise ssl.SSLError(""Unable to allocate memory!"")
            cert = Security.SecCertificateCreateWithData(
                CoreFoundation.kCFAllocatorDefault, certdata
            )
            CoreFoundation.CFRelease(certdata)
            if not cert:
                raise ssl.SSLError(""Unable to build cert object!"")

            CoreFoundation.CFArrayAppendValue(cert_array, cert)
            CoreFoundation.CFRelease(cert)
    except Exception:
        # We need to free the array before the exception bubbles further.
        # We only want to do that if an error occurs: otherwise, the caller
        # should free.
        CoreFoundation.CFRelease(cert_array)

    return cert_array


def _is_cert(item):
    """"""
    Returns True if a given CFTypeRef is a certificate.
    """"""
    expected = Security.SecCertificateGetTypeID()
    return CoreFoundation.CFGetTypeID(item) == expected


def _is_identity(item):
    """"""
    Returns True if a given CFTypeRef is an identity.
    """"""
    expected = Security.SecIdentityGetTypeID()
    return CoreFoundation.CFGetTypeID(item) == expected


def _temporary_keychain():
    """"""
    This function creates a temporary Mac keychain that we can use to work with
    credentials. This keychain uses a one-time password and a temporary file to
    store the data. We expect to have one keychain per socket. The returned
    SecKeychainRef must be freed by the caller, including calling
    SecKeychainDelete.

    Returns a tuple of the SecKeychainRef and the path to the temporary
    directory that contains it.
    """"""
    # Unfortunately, SecKeychainCreate requires a path to a keychain. This
    # means we cannot use mkstemp to use a generic temporary file. Instead,
    # we're going to create a temporary directory and a filename to use there.
    # This filename will be 8 random bytes expanded into base64. We also need
    # some random bytes to password-protect the keychain we're creating, so we
    # ask for 40 random bytes.
    random_bytes = os.urandom(40)
    filename = base64.b16encode(random_bytes[:8]).decode('utf-8')
    password = base64.b16encode(random_bytes[8:])  # Must be valid UTF-8
    tempdirectory = tempfile.mkdtemp()

    keychain_path = os.path.join(tempdirectory, filename).encode('utf-8')

    # We now want to create the keychain itself.
    keychain = Security.SecKeychainRef()
    status = Security.SecKeychainCreate(
        keychain_path,
        len(password),
        password,
        False,
        None,
        ctypes.byref(keychain)
    )
    _assert_no_error(status)

    # Having created the keychain, we want to pass it off to the caller.
    return keychain, tempdirectory


def _load_items_from_file(keychain, path):
    """"""
    Given a single file, loads all the trust objects from it into arrays and
    the keychain.
    Returns a tuple of lists: the first list is a list of identities, the
    second a list of certs.
    """"""
    certificates = []
    identities = []
    result_array = None

    with open(path, 'rb') as f:
        raw_filedata = f.read()

    try:
        filedata = CoreFoundation.CFDataCreate(
            CoreFoundation.kCFAllocatorDefault,
            raw_filedata,
            len(raw_filedata)
        )
        result_array = CoreFoundation.CFArrayRef()
        result = Security.SecItemImport(
            filedata,  # cert data
            None,  # Filename, leaving it out for now
            None,  # What the type of the file is, we don't care
            None,  # what's in the file, we don't care
            0,  # import flags
            None,  # key params, can include passphrase in the future
            keychain,  # The keychain to insert into
            ctypes.byref(result_array)  # Results
        )
        _assert_no_error(result)

        # A CFArray is not very useful to us as an intermediary
        # representation, so we are going to extract the objects we want
        # and then free the array. We don't need to keep hold of keys: the
        # keychain already has them!
        result_count = CoreFoundation.CFArrayGetCount(result_array)
        for index in range(result_count):
            item = CoreFoundation.CFArrayGetValueAtIndex(
                result_array, index
            )
            item = ctypes.cast(item, CoreFoundation.CFTypeRef)

            if _is_cert(item):
                CoreFoundation.CFRetain(item)
                certificates.append(item)
            elif _is_identity(item):
                CoreFoundation.CFRetain(item)
                identities.append(item)
    finally:
        if result_array:
            CoreFoundation.CFRelease(result_array)

        CoreFoundation.CFRelease(filedata)

    return (identities, certificates)


def _load_client_cert_chain(keychain, *paths):
    """"""
    Load certificates and maybe keys from a number of files. Has the end goal
    of returning a CFArray containing one SecIdentityRef, and then zero or more
    SecCertificateRef objects, suitable for use as a client certificate trust
    chain.
    """"""
    # Ok, the strategy.
    #
    # This relies on knowing that macOS will not give you a SecIdentityRef
    # unless you have imported a key into a keychain. This is a somewhat
    # artificial limitation of macOS (for example, it doesn't necessarily
    # affect iOS), but there is nothing inside Security.framework that lets you
    # get a SecIdentityRef without having a key in a keychain.
    #
    # So the policy here is we take all the files and iterate them in order.
    # Each one will use SecItemImport to have one or more objects loaded from
    # it. We will also point at a keychain that macOS can use to work with the
    # private key.
    #
    # Once we have all the objects, we'll check what we actually have. If we
    # already have a SecIdentityRef in hand, fab: we'll use that. Otherwise,
    # we'll take the first certificate (which we assume to be our leaf) and
    # ask the keychain to give us a SecIdentityRef with that cert's associated
    # key.
    #
    # We'll then return a CFArray containing the trust chain: one
    # SecIdentityRef and then zero-or-more SecCertificateRef objects. The
    # responsibility for freeing this CFArray will be with the caller. This
    # CFArray must remain alive for the entire connection, so in practice it
    # will be stored with a single SSLSocket, along with the reference to the
    # keychain.
    certificates = []
    identities = []

    # Filter out bad paths.
    paths = (path for path in paths if path)

    try:
        for file_path in paths:
            new_identities, new_certs = _load_items_from_file(
                keychain, file_path
            )
            identities.extend(new_identities)
            certificates.extend(new_certs)

        # Ok, we have everything. The question is: do we have an identity? If
        # not, we want to grab one from the first cert we have.
        if not identities:
            new_identity = Security.SecIdentityRef()
            status = Security.SecIdentityCreateWithCertificate(
                keychain,
                certificates[0],
                ctypes.byref(new_identity)
            )
            _assert_no_error(status)
            identities.append(new_identity)

            # We now want to release the original certificate, as we no longer
            # need it.
            CoreFoundation.CFRelease(certificates.pop(0))

        # We now need to build a new CFArray that holds the trust chain.
        trust_chain = CoreFoundation.CFArrayCreateMutable(
            CoreFoundation.kCFAllocatorDefault,
            0,
            ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),
        )
        for item in itertools.chain(identities, certificates):
            # ArrayAppendValue does a CFRetain on the item. That's fine,
            # because the finally block will release our other refs to them.
            CoreFoundation.CFArrayAppendValue(trust_chain, item)

        return trust_chain
    finally:
        for obj in itertools.chain(identities, certificates):
            CoreFoundation.CFRelease(obj)",,9b76785331243689a9d52cef3db05ef7462cb02d,CVE-2019-11236,9b76785331243689a9d52cef3db05ef7462cb02d,https://github.com/urllib3/urllib3,NVD_GIT_REPOBASED,70,COMPLETED,""""""" VAR-VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR, VAR, VAR  VAR = VAR.VAR( VAR""-----VAR VAR-----\VAR(.*?)\VAR-----VAR VAR-----"", VAR.VAR ) VAR VAR(VAR): """""" VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR( VAR.VAR, VAR, VAR(VAR) ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR = VAR(VAR)  VAR = (VAR[0] VAR VAR VAR VAR) VAR = (VAR[1] VAR VAR VAR VAR) VAR = (VAR.VAR * VAR)(*VAR) VAR = (VAR.VAR * VAR)(*VAR) VAR VAR.VAR( VAR.VAR, VAR, VAR, VAR, VAR.VAR, VAR.VAR, ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(VAR, VAR.VAR(VAR.VAR)) VAR = VAR.VAR( VAR, VAR.VAR ) VAR VAR VAR VAR: VAR = VAR.VAR(1024) VAR = VAR.VAR( VAR, VAR, 1024, VAR.VAR ) VAR VAR VAR: VAR VAR('VAR VAR VAR VAR VAR VAR') VAR = VAR.VAR VAR VAR VAR VAR VAR: VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR VAR == 0: VAR VAR = VAR.VAR(VAR, VAR) VAR = VAR(VAR) VAR.VAR(VAR) VAR VAR VAR VAR VAR VAR == VAR'': VAR = VAR'VAR %VAR' % VAR VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""  VAR = VAR.VAR(VAR""\VAR\VAR"", VAR""\VAR"") VAR = [ VAR.VAR(VAR.VAR(1)) VAR VAR VAR VAR.VAR(VAR) ] VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR"") VAR = VAR.VAR( VAR.VAR, 0, VAR.VAR(VAR.VAR) ) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR!"") VAR: VAR VAR VAR VAR: VAR = VAR(VAR) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR!"") VAR = VAR.VAR( VAR.VAR, VAR ) VAR.VAR(VAR) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR VAR!"") VAR.VAR(VAR, VAR) VAR.VAR(VAR) VAR VAR:    VAR.VAR(VAR) VAR VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR VAR.VAR(VAR) == VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR VAR.VAR(VAR) == VAR VAR VAR(): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""       VAR = VAR.VAR(40) VAR = VAR.VAR(VAR[:8]).VAR('VAR-8') VAR = VAR.VAR(VAR[8:])  VAR = VAR.VAR() VAR = VAR.VAR.VAR(VAR, VAR).VAR('VAR-8')  VAR = VAR.VAR() VAR = VAR.VAR( VAR, VAR(VAR), VAR, VAR, VAR, VAR.VAR(VAR) ) VAR(VAR)  VAR VAR, VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. """""" VAR = [] VAR = [] VAR = VAR VAR VAR(VAR, 'VAR') VAR VAR: VAR = VAR.VAR() VAR: VAR = VAR.VAR( VAR.VAR, VAR, VAR(VAR) ) VAR = VAR.VAR() VAR = VAR.VAR( VAR,  VAR,  VAR,  VAR,  0,  VAR,  VAR,  VAR.VAR(VAR)  ) VAR(VAR)     VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR = VAR.VAR( VAR, VAR ) VAR = VAR.VAR(VAR, VAR.VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR.VAR(VAR) VAR: VAR VAR: VAR.VAR(VAR) VAR.VAR(VAR) VAR (VAR, VAR) VAR VAR(VAR, *VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""                          VAR = [] VAR = []  VAR = (VAR VAR VAR VAR VAR VAR VAR) VAR: VAR VAR VAR VAR: VAR, VAR = VAR( VAR, VAR ) VAR.VAR(VAR) VAR.VAR(VAR)   VAR VAR VAR: VAR = VAR.VAR() VAR = VAR.VAR( VAR, VAR[0], VAR.VAR(VAR) ) VAR(VAR) VAR.VAR(VAR)   VAR.VAR(VAR.VAR(0))  VAR = VAR.VAR( VAR.VAR, 0, VAR.VAR(VAR.VAR), ) VAR VAR VAR VAR.VAR(VAR, VAR):   VAR.VAR(VAR, VAR) VAR VAR VAR: VAR VAR VAR VAR.VAR(VAR, VAR): VAR.VAR(VAR) ",0,5
urllib3_a74c9cfbaed9f811e7563cfc3dce894928e0221a,src/urllib3/contri_securetransport/low_level.py,"""""""
Low-level helpers for the SecureTransport bindings.

These are Python functions that are not directly related to the high-level APIs
but are necessary to get them to work. They include a whole bunch of low-level
CoreFoundation messing about and memory management. The concerns in this module
are almost entirely about trying to avoid memory leaks and providing
appropriate and useful assistance to the higher-level code.
""""""
import base64
import ctypes
import itertools
import re
import os
import ssl
import tempfile

from .bindings import Security, CoreFoundation, CFConst


# This regular expression is used to grab PEM data out of a PEM bundle.
_PEM_CERTS_RE = re.compile(
    b""-----BEGIN CERTIFICATE-----\n(.*?)\n-----END CERTIFICATE-----"", re.DOTALL
)


def _cf_data_from_bytes(bytestring):
    """"""
    Given a bytestring, create a CFData object from it. This CFData object must
    be CFReleased by the caller.
    """"""
    return CoreFoundation.CFDataCreate(
        CoreFoundation.kCFAllocatorDefault, bytestring, len(bytestring)
    )


def _cf_dictionary_from_tuples(tuples):
    """"""
    Given a list of Python tuples, create an associated CFDictionary.
    """"""
    dictionary_size = len(tuples)

    # We need to get the dictionary keys and values out in the same order.
    keys = (t[0] for t in tuples)
    values = (t[1] for t in tuples)
    cf_keys = (CoreFoundation.CFTypeRef * dictionary_size)(*keys)
    cf_values = (CoreFoundation.CFTypeRef * dictionary_size)(*values)

    return CoreFoundation.CFDictionaryCreate(
        CoreFoundation.kCFAllocatorDefault,
        cf_keys,
        cf_values,
        dictionary_size,
        CoreFoundation.kCFTypeDictionaryKeyCallBacks,
        CoreFoundation.kCFTypeDictionaryValueCallBacks,
    )


def _cf_string_to_unicode(value):
    """"""
    Creates a Unicode string from a CFString object. Used entirely for error
    reporting.

    Yes, it annoys me quite a lot that this function is this complex.
    """"""
    value_as_void_p = ctypes.cast(value, ctypes.POINTER(ctypes.c_void_p))

    string = CoreFoundation.CFStringGetCStringPtr(
        value_as_void_p,
        CFConst.kCFStringEncodingUTF8
    )
    if string is None:
        buffer = ctypes.create_string_buffer(1024)
        result = CoreFoundation.CFStringGetCString(
            value_as_void_p,
            buffer,
            1024,
            CFConst.kCFStringEncodingUTF8
        )
        if not result:
            raise OSError('Error copying C string from CFStringRef')
        string = buffer.value
    if string is not None:
        string = string.decode('utf-8')
    return string


def _assert_no_error(error, exception_class=None):
    """"""
    Checks the return code and throws an exception if there is an error to
    report
    """"""
    if error == 0:
        return

    cf_error_string = Security.SecCopyErrorMessageString(error, None)
    output = _cf_string_to_unicode(cf_error_string)
    CoreFoundation.CFRelease(cf_error_string)

    if output is None or output == u'':
        output = u'OSStatus %s' % error

    if exception_class is None:
        exception_class = ssl.SSLError

    raise exception_class(output)


def _cert_array_from_pem(pem_bundle):
    """"""
    Given a bundle of certs in PEM format, turns them into a CFArray of certs
    that can be used to validate a cert chain.
    """"""
    # Normalize the PEM bundle's line endings.
    pem_bundle = pem_bundle.replace(b""\r\n"", b""\n"")

    der_certs = [
        base64.b64decode(match.group(1))
        for match in _PEM_CERTS_RE.finditer(pem_bundle)
    ]
    if not der_certs:
        raise ssl.SSLError(""No root certificates specified"")

    cert_array = CoreFoundation.CFArrayCreateMutable(
        CoreFoundation.kCFAllocatorDefault,
        0,
        ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks)
    )
    if not cert_array:
        raise ssl.SSLError(""Unable to allocate memory!"")

    try:
        for der_bytes in der_certs:
            certdata = _cf_data_from_bytes(der_bytes)
            if not certdata:
                raise ssl.SSLError(""Unable to allocate memory!"")
            cert = Security.SecCertificateCreateWithData(
                CoreFoundation.kCFAllocatorDefault, certdata
            )
            CoreFoundation.CFRelease(certdata)
            if not cert:
                raise ssl.SSLError(""Unable to build cert object!"")

            CoreFoundation.CFArrayAppendValue(cert_array, cert)
            CoreFoundation.CFRelease(cert)
    except Exception:
        # We need to free the array before the exception bubbles further.
        # We only want to do that if an error occurs: otherwise, the caller
        # should free.
        CoreFoundation.CFRelease(cert_array)

    return cert_array


def _is_cert(item):
    """"""
    Returns True if a given CFTypeRef is a certificate.
    """"""
    expected = Security.SecCertificateGetTypeID()
    return CoreFoundation.CFGetTypeID(item) == expected


def _is_identity(item):
    """"""
    Returns True if a given CFTypeRef is an identity.
    """"""
    expected = Security.SecIdentityGetTypeID()
    return CoreFoundation.CFGetTypeID(item) == expected


def _temporary_keychain():
    """"""
    This function creates a temporary Mac keychain that we can use to work with
    credentials. This keychain uses a one-time password and a temporary file to
    store the data. We expect to have one keychain per socket. The returned
    SecKeychainRef must be freed by the caller, including calling
    SecKeychainDelete.

    Returns a tuple of the SecKeychainRef and the path to the temporary
    directory that contains it.
    """"""
    # Unfortunately, SecKeychainCreate requires a path to a keychain. This
    # means we cannot use mkstemp to use a generic temporary file. Instead,
    # we're going to create a temporary directory and a filename to use there.
    # This filename will be 8 random bytes expanded into base64. We also need
    # some random bytes to password-protect the keychain we're creating, so we
    # ask for 40 random bytes.
    random_bytes = os.urandom(40)
    filename = base64.b16encode(random_bytes[:8]).decode('utf-8')
    password = base64.b16encode(random_bytes[8:])  # Must be valid UTF-8
    tempdirectory = tempfile.mkdtemp()

    keychain_path = os.path.join(tempdirectory, filename).encode('utf-8')

    # We now want to create the keychain itself.
    keychain = Security.SecKeychainRef()
    status = Security.SecKeychainCreate(
        keychain_path,
        len(password),
        password,
        False,
        None,
        ctypes.byref(keychain)
    )
    _assert_no_error(status)

    # Having created the keychain, we want to pass it off to the caller.
    return keychain, tempdirectory


def _load_items_from_file(keychain, path):
    """"""
    Given a single file, loads all the trust objects from it into arrays and
    the keychain.
    Returns a tuple of lists: the first list is a list of identities, the
    second a list of certs.
    """"""
    certificates = []
    identities = []
    result_array = None

    with open(path, 'rb') as f:
        raw_filedata = f.read()

    try:
        filedata = CoreFoundation.CFDataCreate(
            CoreFoundation.kCFAllocatorDefault,
            raw_filedata,
            len(raw_filedata)
        )
        result_array = CoreFoundation.CFArrayRef()
        result = Security.SecItemImport(
            filedata,  # cert data
            None,  # Filename, leaving it out for now
            None,  # What the type of the file is, we don't care
            None,  # what's in the file, we don't care
            0,  # import flags
            None,  # key params, can include passphrase in the future
            keychain,  # The keychain to insert into
            ctypes.byref(result_array)  # Results
        )
        _assert_no_error(result)

        # A CFArray is not very useful to us as an intermediary
        # representation, so we are going to extract the objects we want
        # and then free the array. We don't need to keep hold of keys: the
        # keychain already has them!
        result_count = CoreFoundation.CFArrayGetCount(result_array)
        for index in range(result_count):
            item = CoreFoundation.CFArrayGetValueAtIndex(
                result_array, index
            )
            item = ctypes.cast(item, CoreFoundation.CFTypeRef)

            if _is_cert(item):
                CoreFoundation.CFRetain(item)
                certificates.append(item)
            elif _is_identity(item):
                CoreFoundation.CFRetain(item)
                identities.append(item)
    finally:
        if result_array:
            CoreFoundation.CFRelease(result_array)

        CoreFoundation.CFRelease(filedata)

    return (identities, certificates)


def _load_client_cert_chain(keychain, *paths):
    """"""
    Load certificates and maybe keys from a number of files. Has the end goal
    of returning a CFArray containing one SecIdentityRef, and then zero or more
    SecCertificateRef objects, suitable for use as a client certificate trust
    chain.
    """"""
    # Ok, the strategy.
    #
    # This relies on knowing that macOS will not give you a SecIdentityRef
    # unless you have imported a key into a keychain. This is a somewhat
    # artificial limitation of macOS (for example, it doesn't necessarily
    # affect iOS), but there is nothing inside Security.framework that lets you
    # get a SecIdentityRef without having a key in a keychain.
    #
    # So the policy here is we take all the files and iterate them in order.
    # Each one will use SecItemImport to have one or more objects loaded from
    # it. We will also point at a keychain that macOS can use to work with the
    # private key.
    #
    # Once we have all the objects, we'll check what we actually have. If we
    # already have a SecIdentityRef in hand, fab: we'll use that. Otherwise,
    # we'll take the first certificate (which we assume to be our leaf) and
    # ask the keychain to give us a SecIdentityRef with that cert's associated
    # key.
    #
    # We'll then return a CFArray containing the trust chain: one
    # SecIdentityRef and then zero-or-more SecCertificateRef objects. The
    # responsibility for freeing this CFArray will be with the caller. This
    # CFArray must remain alive for the entire connection, so in practice it
    # will be stored with a single SSLSocket, along with the reference to the
    # keychain.
    certificates = []
    identities = []

    # Filter out bad paths.
    paths = (path for path in paths if path)

    try:
        for file_path in paths:
            new_identities, new_certs = _load_items_from_file(
                keychain, file_path
            )
            identities.extend(new_identities)
            certificates.extend(new_certs)

        # Ok, we have everything. The question is: do we have an identity? If
        # not, we want to grab one from the first cert we have.
        if not identities:
            new_identity = Security.SecIdentityRef()
            status = Security.SecIdentityCreateWithCertificate(
                keychain,
                certificates[0],
                ctypes.byref(new_identity)
            )
            _assert_no_error(status)
            identities.append(new_identity)

            # We now want to release the original certificate, as we no longer
            # need it.
            CoreFoundation.CFRelease(certificates.pop(0))

        # We now need to build a new CFArray that holds the trust chain.
        trust_chain = CoreFoundation.CFArrayCreateMutable(
            CoreFoundation.kCFAllocatorDefault,
            0,
            ctypes.byref(CoreFoundation.kCFTypeArrayCallBacks),
        )
        for item in itertools.chain(identities, certificates):
            # ArrayAppendValue does a CFRetain on the item. That's fine,
            # because the finally block will release our other refs to them.
            CoreFoundation.CFArrayAppendValue(trust_chain, item)

        return trust_chain
    finally:
        for obj in itertools.chain(identities, certificates):
            CoreFoundation.CFRelease(obj)",,a74c9cfbaed9f811e7563cfc3dce894928e0221a,CVE-2020-7212,a74c9cfbaed9f811e7563cfc3dce894928e0221a,https://github.com/urllib3/urllib3,NVD_DIRECT_COMMIT,1337,COMPLETED,""""""" VAR-VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR-VAR VAR. """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR .VAR VAR VAR, VAR, VAR  VAR = VAR.VAR( VAR""-----VAR VAR-----\VAR(.*?)\VAR-----VAR VAR-----"", VAR.VAR ) VAR VAR(VAR): """""" VAR VAR VAR, VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR VAR.VAR( VAR.VAR, VAR, VAR(VAR) ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR. """""" VAR = VAR(VAR)  VAR = (VAR[0] VAR VAR VAR VAR) VAR = (VAR[1] VAR VAR VAR VAR) VAR = (VAR.VAR * VAR)(*VAR) VAR = (VAR.VAR * VAR)(*VAR) VAR VAR.VAR( VAR.VAR, VAR, VAR, VAR, VAR.VAR, VAR.VAR, ) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR. VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR(VAR, VAR.VAR(VAR.VAR)) VAR = VAR.VAR( VAR, VAR.VAR ) VAR VAR VAR VAR: VAR = VAR.VAR(1024) VAR = VAR.VAR( VAR, VAR, 1024, VAR.VAR ) VAR VAR VAR: VAR VAR('VAR VAR VAR VAR VAR VAR') VAR = VAR.VAR VAR VAR VAR VAR VAR: VAR = VAR.VAR('VAR-8') VAR VAR VAR VAR(VAR, VAR=VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR """""" VAR VAR == 0: VAR VAR = VAR.VAR(VAR, VAR) VAR = VAR(VAR) VAR.VAR(VAR) VAR VAR VAR VAR VAR VAR == VAR'': VAR = VAR'VAR %VAR' % VAR VAR VAR VAR VAR: VAR = VAR.VAR VAR VAR(VAR) VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""  VAR = VAR.VAR(VAR""\VAR\VAR"", VAR""\VAR"") VAR = [ VAR.VAR(VAR.VAR(1)) VAR VAR VAR VAR.VAR(VAR) ] VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR"") VAR = VAR.VAR( VAR.VAR, 0, VAR.VAR(VAR.VAR) ) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR!"") VAR: VAR VAR VAR VAR: VAR = VAR(VAR) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR!"") VAR = VAR.VAR( VAR.VAR, VAR ) VAR.VAR(VAR) VAR VAR VAR: VAR VAR.VAR(""VAR VAR VAR VAR VAR!"") VAR.VAR(VAR, VAR) VAR.VAR(VAR) VAR VAR:    VAR.VAR(VAR) VAR VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR VAR.VAR(VAR) == VAR VAR VAR(VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR. """""" VAR = VAR.VAR() VAR VAR.VAR(VAR) == VAR VAR VAR(): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR-VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""       VAR = VAR.VAR(40) VAR = VAR.VAR(VAR[:8]).VAR('VAR-8') VAR = VAR.VAR(VAR[8:])  VAR = VAR.VAR() VAR = VAR.VAR.VAR(VAR, VAR).VAR('VAR-8')  VAR = VAR.VAR() VAR = VAR.VAR( VAR, VAR(VAR), VAR, VAR, VAR, VAR.VAR(VAR) ) VAR(VAR)  VAR VAR, VAR VAR VAR(VAR, VAR): """""" VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR: VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR. """""" VAR = [] VAR = [] VAR = VAR VAR VAR(VAR, 'VAR') VAR VAR: VAR = VAR.VAR() VAR: VAR = VAR.VAR( VAR.VAR, VAR, VAR(VAR) ) VAR = VAR.VAR() VAR = VAR.VAR( VAR,  VAR,  VAR,  VAR,  0,  VAR,  VAR,  VAR.VAR(VAR)  ) VAR(VAR)     VAR = VAR.VAR(VAR) VAR VAR VAR VAR(VAR): VAR = VAR.VAR( VAR, VAR ) VAR = VAR.VAR(VAR, VAR.VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR.VAR(VAR) VAR VAR(VAR): VAR.VAR(VAR) VAR.VAR(VAR) VAR: VAR VAR: VAR.VAR(VAR) VAR.VAR(VAR) VAR (VAR, VAR) VAR VAR(VAR, *VAR): """""" VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR VAR VAR VAR VAR. """"""                          VAR = [] VAR = []  VAR = (VAR VAR VAR VAR VAR VAR VAR) VAR: VAR VAR VAR VAR: VAR, VAR = VAR( VAR, VAR ) VAR.VAR(VAR) VAR.VAR(VAR)   VAR VAR VAR: VAR = VAR.VAR() VAR = VAR.VAR( VAR, VAR[0], VAR.VAR(VAR) ) VAR(VAR) VAR.VAR(VAR)   VAR.VAR(VAR.VAR(0))  VAR = VAR.VAR( VAR.VAR, 0, VAR.VAR(VAR.VAR), ) VAR VAR VAR VAR.VAR(VAR, VAR):   VAR.VAR(VAR, VAR) VAR VAR VAR: VAR VAR VAR VAR.VAR(VAR, VAR): VAR.VAR(VAR) ",0,5
xrdp_b5b047458e9aac0f26f794d94537f87b10e1193c,sesman/chansrv/devredir.c,"                /* At present we don't use the full name - see
                 * [MS-RDPEFS] 2.2.3.1 for details of the contents */
                xstream_skip_u8(s, device_data_len);
                          ""device_data_len=%d"", g_device_id,
                          device_data_len);","char g_full_name_for_filesystem[1024];
                /* get device data len */
                if (device_data_len)
                {
                    xstream_rd_string(g_full_name_for_filesystem, s,
                                      device_data_len);
                }
                          ""device_data_len=%d full_name=%s"", g_device_id,
                          device_data_len, g_full_name_for_filesystem);",b5b047458e9aac0f26f794d94537f87b10e1193c,CVE-2022-23480,b5b047458e9aac0f26f794d94537f87b10e1193c,https://github.com/neutrinolabs/xrdp,NVD_GIT_REPOBASED,78,COMPLETED,"/* VAR VAR VAR VAR'VAR VAR VAR VAR VAR - VAR * [VAR-VAR] 2.2.3.1 VAR VAR VAR VAR VAR */ VAR(VAR, VAR); ""VAR=%VAR"", VAR, VAR); VAR VAR[1024];  VAR (VAR) { VAR(VAR, VAR, VAR); } ""VAR=%VAR VAR=%VAR"", VAR, VAR, VAR);",0,5

commit,file,added_code,deleted_code,hash_clean,cve_id,hash,repo_url,rel_type,score,extraction_status,text_norm,cluster_kmeans,cluster_hac
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,cloud-deployments/aws/cloudformation/generate.mjs,"// Note (tcarambat) This script should be executed from root via the `yarn generate::cloudformation` command only.
// This script will copy your current Docker .env settings being used into a slightly custom AWS CloudFormation template
// that you can upload and deploy on AWS in a single click!
// Recommended settings are already defined in the template but you can modify them as needed.
// AnythingLLM can run within the free tier services of AWS (t2.micro w/10GB of storage)
//
// This will deploy a fully public AnythingLLM so if you do not want anyone to access it please set the AUTH_TOKEN & JWT_SECRET envs
// before running this script. You can still run the collector scripts on AWS so no FTP or file uploads are required.
// Your documents and data do not leave your AWS instance when you host in the cloud this way.

import fs from 'fs';
import { fileURLToPath } from 'url';
import path, { dirname } from 'path';
import { exit } from 'process';
const __dirname = dirname(fileURLToPath(import.meta.url));
const REPLACEMENT_KEY = '!SUB::USER::CONTENT!'

const envPath = path.resolve(__dirname, `../../../docker/.env`)
const envFileExists = fs.existsSync(envPath);

const chalk = {
  redBright: function (text) {
    return `\x1b[31m${text}\x1b[0m`
  },
  cyan: function (text) {
    return `\x1b[36m${text}\x1b[0m`
  },
  greenBright: function (text) {
    return `\x1b[32m${text}\x1b[0m`
  },
  blueBright: function (text) {
    return `\x1b[34m${text}\x1b[0m`
  }
}

if (!envFileExists) {
  console.log(chalk.redBright('[ABORT]'), 'You do not have an .env file in your ./docker/ folder. You need to create it first.');
  console.log('You can start by running', chalk.cyan('cp -n ./docker/.env.example ./docker/.env'))
  exit(1);
}

// Remove comments
// Remove UID,GID,etc
// Remove empty strings
// Split into array
const settings = fs.readFileSync(envPath, ""utf8"")
  .replace(/^#.*\n?/gm, '')
  .replace(/^UID.*\n?/gm, '')
  .replace(/^GID.*\n?/gm, '')
  .replace(/^CLOUD_BUILD.*\n?/gm, '')
  .replace(/^\s*\n/gm, """")
  .split('\n')
  .filter((i) => !!i)
  .map((i) => i + '\n')

const templatePath = path.resolve(__dirname, `cf_template.template`);
const templateString = fs.readFileSync(templatePath, ""utf8"");
const template = JSON.parse(templateString);

const cmdIdx = template.Resources.AnythingLLMInstance.Properties.UserData['Fn::Base64']['Fn::Join'][1].findIndex((cmd) => cmd === REPLACEMENT_KEY)
template.Resources.AnythingLLMInstance.Properties.UserData['Fn::Base64']['Fn::Join'][1].splice(cmdIdx, 1, ...settings);

const output = path.resolve(__dirname, `aws_cf_deploy_anything_llm.json`);
fs.writeFileSync(output, JSON.stringify(template, null, 2), ""utf8"");

console.log(chalk.greenBright('[SUCCESS]'), 'Deploy AnythingLLM on AWS CloudFormation using your template document.');
console.log(chalk.greenBright('File Created:'), 'aws_cf_deploy_anything_llm.json in aws/cloudformation directory.');
console.log(chalk.blueBright('[INFO]'), 'Refer to aws/cloudformation/DEPLOY.md for how to use this file.');

exit();",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"         VAR VAR VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR, { VAR } VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR = VAR(VAR(VAR.VAR.VAR)); VAR VAR = '!VAR::VAR::VAR!' VAR VAR = VAR.VAR(VAR, `../../../VAR/.VAR`) VAR VAR = VAR.VAR(VAR); VAR VAR = { VAR: VAR (VAR) { VAR `\VAR[31m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[36m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[32m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[34m${VAR}\VAR[0m` } } VAR (!VAR) { VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR .VAR VAR VAR VAR ./VAR/ VAR. VAR VAR VAR VAR VAR VAR.'); VAR.VAR('VAR VAR VAR VAR VAR', VAR.VAR('VAR -VAR ./VAR/.VAR.VAR ./VAR/.VAR')) VAR(1); }     VAR VAR = VAR.VAR(VAR, ""VAR"") .VAR(/^ .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^\VAR*\VAR/VAR, """") .VAR('\VAR') .VAR((VAR) => !!VAR) .VAR((VAR) => VAR + '\VAR') VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR VAR = VAR.VAR(VAR, ""VAR""); VAR VAR = VAR.VAR(VAR); VAR VAR = VAR.VAR.VAR.VAR.VAR['VAR::VAR']['VAR::VAR'][1].VAR((VAR) => VAR === VAR) VAR.VAR.VAR.VAR.VAR['VAR::VAR']['VAR::VAR'][1].VAR(VAR, 1, ...VAR); VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR.VAR(VAR, VAR.VAR(VAR, VAR, 2), ""VAR""); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR VAR VAR VAR VAR.'); VAR.VAR(VAR.VAR('VAR VAR:'), 'VAR.VAR VAR VAR/VAR VAR.'); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR/VAR/VAR.VAR VAR VAR VAR VAR VAR VAR.'); VAR(); ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,cloud-deployments/gcp/deployment/generate.mjs,"import fs from 'fs';
import { fileURLToPath } from 'url';
import path, { dirname } from 'path';
import { exit } from 'process';
const __dirname = dirname(fileURLToPath(import.meta.url));
const REPLACEMENT_KEY = '!SUB::USER::CONTENT!'

const envPath = path.resolve(__dirname, `../../../docker/.env`)
const envFileExists = fs.existsSync(envPath);

const chalk = {
  redBright: function (text) {
    return `\x1b[31m${text}\x1b[0m`
  },
  cyan: function (text) {
    return `\x1b[36m${text}\x1b[0m`
  },
  greenBright: function (text) {
    return `\x1b[32m${text}\x1b[0m`
  },
  blueBright: function (text) {
    return `\x1b[34m${text}\x1b[0m`
  }
}

if (!envFileExists) {
  console.log(chalk.redBright('[ABORT]'), 'You do not have an .env file in your ./docker/ folder. You need to create it first.');
  console.log('You can start by running', chalk.cyan('cp -n ./docker/.env.example ./docker/.env'))
  exit(1);
}

// Remove comments
// Remove UID,GID,etc
// Remove empty strings
// Split into array
const settings = fs.readFileSync(envPath, ""utf8"")
  .replace(/^#.*\n?/gm, '')
  .replace(/^UID.*\n?/gm, '')
  .replace(/^GID.*\n?/gm, '')
  .replace(/^CLOUD_BUILD.*\n?/gm, '')
  .replace(/^\s*\n/gm, """")
  .split('\n')
  .filter((i) => !!i);
const formattedSettings = settings.map((i, index) => index === 0 ? i + '\n' : '              ' + i).join('\n');

// Read the existing GCP Deployment Manager template
const templatePath = path.resolve(__dirname, `gcp_deploy_anything_llm.yaml`);
const templateString = fs.readFileSync(templatePath, ""utf8"");

// Update the metadata section with the UserData content
const updatedTemplateString = templateString.replace(REPLACEMENT_KEY, formattedSettings);

// Save the updated GCP Deployment Manager template
const output = path.resolve(__dirname, `gcp_deploy_anything_llm_with_env.yaml`);
fs.writeFileSync(output, updatedTemplateString, ""utf8"");

console.log(chalk.greenBright('[SUCCESS]'), 'Deploy AnythingLLM on GCP Deployment Manager using your template document.');
console.log(chalk.greenBright('File Created:'), 'gcp_deploy_anything_llm_with_env.yaml in the output directory.');
console.log(chalk.blueBright('[INFO]'), 'Refer to the GCP Deployment Manager documentation for how to use this file.');

exit();",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR, { VAR } VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR = VAR(VAR(VAR.VAR.VAR)); VAR VAR = '!VAR::VAR::VAR!' VAR VAR = VAR.VAR(VAR, `../../../VAR/.VAR`) VAR VAR = VAR.VAR(VAR); VAR VAR = { VAR: VAR (VAR) { VAR `\VAR[31m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[36m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[32m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[34m${VAR}\VAR[0m` } } VAR (!VAR) { VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR .VAR VAR VAR VAR ./VAR/ VAR. VAR VAR VAR VAR VAR VAR.'); VAR.VAR('VAR VAR VAR VAR VAR', VAR.VAR('VAR -VAR ./VAR/.VAR.VAR ./VAR/.VAR')) VAR(1); }     VAR VAR = VAR.VAR(VAR, ""VAR"") .VAR(/^ .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^\VAR*\VAR/VAR, """") .VAR('\VAR') .VAR((VAR) => !!VAR); VAR VAR = VAR.VAR((VAR, VAR) => VAR === 0 ? VAR + '\VAR' : ' ' + VAR).VAR('\VAR');  VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR VAR = VAR.VAR(VAR, ""VAR"");  VAR VAR = VAR.VAR(VAR, VAR);  VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR.VAR(VAR, VAR, ""VAR""); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.'); VAR.VAR(VAR.VAR('VAR VAR:'), 'VAR.VAR VAR VAR VAR VAR.'); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.'); VAR(); ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/apiKeys.js,"const { Telemetry } = require(""./telemetry"");

const ApiKey = {
  tablename: ""api_keys"",
  writable: [],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  secret TEXT UNIQUE,
  createdBy INTEGER DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for ApiKey migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  makeSecret: () => {
    const uuidAPIKey = require(""uuid-apikey"");
    return uuidAPIKey.create().apiKey;
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  create: async function (createdByUserId = null) {
    const db = await this.db();
    const { id, success, message } = await db
      .run(`INSERT INTO ${this.tablename} (secret, createdBy) VALUES(?, ?)`, [
        this.makeSecret(),
        createdByUserId,
      ])
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE API KEY."", message);
      return { apiKey: null, error: message };
    }

    const apiKey = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id} `
    );
    db.close();
    await Telemetry.sendTelemetry(""api_key_created"");
    return { apiKey, error: null };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();
    return { ...result };
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(
      `DELETE FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"}`
    );
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  whereWithUser: async function (clause = """", limit = null) {
    const { User } = require(""./user"");
    const apiKeys = await this.where(clause, limit);

    for (const apiKey of apiKeys) {
      if (!apiKey.createdBy) continue;
      const user = await User.get(`id = ${apiKey.createdBy}`);
      if (!user) continue;

      apiKey.createdBy = {
        id: user.id,
        username: user.username,
        role: user.role,
      };
    }

    return apiKeys;
  },
};

module.exports = { ApiKey };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""./VAR""); VAR VAR = { VAR: ""VAR"", VAR: [], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: () => { VAR VAR = VAR(""VAR-VAR""); VAR VAR.VAR().VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR(?, ?)`, [ VAR.VAR(), VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR VAR."", VAR); VAR { VAR: VAR, VAR: VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR} ` ); VAR.VAR(); VAR VAR.VAR(""VAR""); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR { ...VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR( `VAR VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"}` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR { VAR } = VAR(""./VAR""); VAR VAR = VAR VAR.VAR(VAR, VAR); VAR (VAR VAR VAR VAR) { VAR (!VAR.VAR) VAR; VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR (!VAR) VAR; VAR.VAR = { VAR: VAR.VAR, VAR: VAR.VAR, VAR: VAR.VAR, }; } VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/documents.js,"const { fileData } = require(""../utils/files"");
const { v4: uuidv4 } = require(""uuid"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { checkForMigrations } = require(""../utils/database"");
const { Telemetry } = require(""./telemetry"");

const Document = {
  tablename: ""workspace_documents"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  docId TEXT NOT NULL UNIQUE,
  filename TEXT NOT NULL,
  docpath TEXT NOT NULL,
  workspaceId INTEGER NOT NULL,
  metadata TEXT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for Document migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  forWorkspace: async function (workspaceId = null) {
    if (!workspaceId) return [];
    return await this.where(`workspaceId = ${workspaceId}`);
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();
    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );

    db.close();
    return results;
  },
  firstWhere: async function (clause = """") {
    const results = await this.where(clause);
    return results.length > 0 ? results[0] : null;
  },
  addDocuments: async function (workspace, additions = []) {
    const VectorDb = getVectorDbClass();
    if (additions.length === 0) return;
    const insertParams = [];

    for (const path of additions) {
      const data = await fileData(path);
      if (!data) continue;

      const docId = uuidv4();
      const { pageContent, ...metadata } = data;
      const newDoc = {
        docId,
        filename: path.split(""/"")[1],
        docpath: path,
        workspaceId: Number(workspace.id),
        metadata: JSON.stringify(metadata),
      };
      const vectorized = await VectorDb.addDocumentToNamespace(
        workspace.slug,
        { ...data, docId },
        path
      );
      if (!vectorized) {
        console.error(""Failed to vectorize"", path);
        continue;
      }

      insertParams.push([
        docId,
        newDoc.filename,
        newDoc.docpath,
        newDoc.workspaceId,
        newDoc.metadata,
      ]);
    }

    const db = await this.db();
    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (docId, filename, docpath, workspaceId, metadata) VALUES (?,?,?,?,?)`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const params of insertParams) {
        await stmt.run(params);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    await Telemetry.sendTelemetry(""documents_embedded_in_workspace"", {
      LLMSelection: process.env.LLM_PROVIDER || ""openai"",
      VectorDbSelection: process.env.VECTOR_DB || ""pinecone"",
    });
    return;
  },
  removeDocuments: async function (workspace, removals = []) {
    const VectorDb = getVectorDbClass();
    const deleteParams = [];
    if (removals.length === 0) return;

    for (const path of removals) {
      const document = await this.firstWhere(
        `docPath = '${path}' AND workspaceId = ${workspace.id}`
      );
      if (!document) continue;
      await VectorDb.deleteDocumentFromNamespace(
        workspace.slug,
        document.docId
      );
      deleteParams.push([path, workspace.id]);
    }

    const db = await this.db();
    const stmt = await db.prepare(
      `DELETE FROM ${this.tablename} WHERE docpath = ? AND workspaceId = ?`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const params of deleteParams) {
        await stmt.run(params);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    await Telemetry.sendTelemetry(""documents_removed_in_workspace"", {
      LLMSelection: process.env.LLM_PROVIDER || ""openai"",
      VectorDbSelection: process.env.VECTOR_DB || ""pinecone"",
    });
    return true;
  },
};

module.exports = { Document };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR: VAR } = VAR(""VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""./VAR""); VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR (!VAR) VAR []; VAR VAR VAR.VAR(`VAR = ${VAR}`); }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(VAR); VAR VAR.VAR > 0 ? VAR[0] : VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR VAR = VAR(); VAR (VAR.VAR === 0) VAR; VAR VAR = []; VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR(VAR); VAR (!VAR) VAR; VAR VAR = VAR(); VAR { VAR, ...VAR } = VAR; VAR VAR = { VAR, VAR: VAR.VAR(""/"")[1], VAR: VAR, VAR: VAR(VAR.VAR), VAR: VAR.VAR(VAR), }; VAR VAR = VAR VAR.VAR( VAR.VAR, { ...VAR, VAR }, VAR ); VAR (!VAR) { VAR.VAR(""VAR VAR VAR"", VAR); VAR; } VAR.VAR([ VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, ]); } VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR, VAR, VAR) VAR (?,?,?,?,?)` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR(VAR); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR VAR.VAR(""VAR"", { VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR.VAR.VAR || ""VAR"", }); VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR VAR = VAR(); VAR VAR = []; VAR (VAR.VAR === 0) VAR; VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR.VAR( `VAR = '${VAR}' VAR VAR = ${VAR.VAR}` ); VAR (!VAR) VAR; VAR VAR.VAR( VAR.VAR, VAR.VAR ); VAR.VAR([VAR, VAR.VAR]); } VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} VAR VAR = ? VAR VAR = ?` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR(VAR); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR VAR.VAR(""VAR"", { VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR.VAR.VAR || ""VAR"", }); VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/invite.js,"const Invite = {
  tablename: ""invites"",
  writable: [],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  code TEXT UNIQUE NOT NULL,
  status TEXT NOT NULL DEFAULT ""pending"",
  claimedBy INTEGER DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  createdBy INTEGER NOT NULL,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for Invites migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  makeCode: () => {
    const uuidAPIKey = require(""uuid-apikey"");
    return uuidAPIKey.create().apiKey;
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  create: async function (createdByUserId = 0) {
    const db = await this.db();
    const { id, success, message } = await db
      .run(`INSERT INTO ${this.tablename} (code, createdBy) VALUES(?, ?)`, [
        this.makeCode(),
        createdByUserId,
      ])
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE USER."", message);
      return { invite: null, error: message };
    }

    const invite = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id} `
    );
    db.close();

    return { invite, error: null };
  },
  deactivate: async function (inviteId = null) {
    const invite = await this.get(`id = ${inviteId}`);
    if (!invite) return { success: false, error: ""Invite does not exist."" };
    if (invite.status !== ""pending"")
      return { success: false, error: ""Invite is not in pending status."" };

    const db = await this.db();
    const { success, message } = await db
      .run(`UPDATE ${this.tablename} SET status=? WHERE id=?`, [
        ""disabled"",
        inviteId,
      ])
      .then(() => {
        return { success: true, message: null };
      })
      .catch((error) => {
        return { success: false, message: error.message };
      });

    db.close();
    if (!success) {
      console.error(message);
      return { success: false, error: message };
    }

    return { success: true, error: null };
  },
  markClaimed: async function (inviteId = null, user) {
    const invite = await this.get(`id = ${inviteId}`);
    if (!invite) return { success: false, error: ""Invite does not exist."" };
    if (invite.status !== ""pending"")
      return { success: false, error: ""Invite is not in pending status."" };

    const db = await this.db();
    const { success, message } = await db
      .run(`UPDATE ${this.tablename} SET status=?,claimedBy=? WHERE id=?`, [
        ""claimed"",
        user.id,
        inviteId,
      ])
      .then(() => {
        return { success: true, message: null };
      })
      .catch((error) => {
        return { success: false, message: error.message };
      });

    db.close();
    if (!success) {
      console.error(message);
      return { success: false, error: message };
    }

    return { success: true, error: null };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();
    return { ...result };
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  whereWithUsers: async function (clause = """", limit = null) {
    const { User } = require(""./user"");
    const results = await this.where(clause, limit);
    for (const invite of results) {
      if (!!invite.claimedBy) {
        const acceptedUser = await User.get(`id = ${invite.claimedBy}`);
        invite.claimedBy = {
          id: acceptedUser?.id,
          username: acceptedUser?.username,
        };
      }

      if (!!invite.createdBy) {
        const createdUser = await User.get(`id = ${invite.createdBy}`);
        invite.createdBy = {
          id: createdUser?.id,
          username: createdUser?.username,
        };
      }
    }
    return results;
  },
};

module.exports.Invite = Invite;",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = { VAR: ""VAR"", VAR: [], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR ""VAR"", VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: () => { VAR VAR = VAR(""VAR-VAR""); VAR VAR.VAR().VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = 0) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR(?, ?)`, [ VAR.VAR(), VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR."", VAR); VAR { VAR: VAR, VAR: VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR} ` ); VAR.VAR(); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR}`); VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR."" }; VAR (VAR.VAR !== ""VAR"") VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."" }; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(`VAR ${VAR.VAR} VAR VAR=? VAR VAR=?`, [ ""VAR"", VAR, ]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR }; } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR, VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR}`); VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR."" }; VAR (VAR.VAR !== ""VAR"") VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."" }; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(`VAR ${VAR.VAR} VAR VAR=?,VAR=? VAR VAR=?`, [ ""VAR"", VAR.VAR, VAR, ]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR }; } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR { ...VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR { VAR } = VAR(""./VAR""); VAR VAR = VAR VAR.VAR(VAR, VAR); VAR (VAR VAR VAR VAR) { VAR (!!VAR.VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = { VAR: VAR?.VAR, VAR: VAR?.VAR, }; } VAR (!!VAR.VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = { VAR: VAR?.VAR, VAR: VAR?.VAR, }; } } VAR VAR; }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/systemSettings.js,"process.env.NODE_ENV === ""development""
  ? require(""dotenv"").config({ path: `.env.${process.env.NODE_ENV}` })
  : require(""dotenv"").config();

const SystemSettings = {
  supportedFields: [
    ""multi_user_mode"",
    ""users_can_delete_workspaces"",
    ""limit_user_messages"",
    ""message_limit"",
    ""logo_filename"",
    ""telemetry_id"",
  ],
  privateField: [],
  tablename: ""system_settings"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  label TEXT UNIQUE NOT NULL,
  value TEXT,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for System Setting migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  currentSettings: async function () {
    const llmProvider = process.env.LLM_PROVIDER || ""openai"";
    const vectorDB = process.env.VECTOR_DB || ""pinecone"";
    return {
      CanDebug: !!!process.env.NO_DEBUG,
      RequiresAuth: !!process.env.AUTH_TOKEN,
      AuthToken: !!process.env.AUTH_TOKEN,
      JWTSecret: !!process.env.JWT_SECRET,
      StorageDir: process.env.STORAGE_DIR,
      MultiUserMode: await this.isMultiUserMode(),
      VectorDB: vectorDB,
      ...(vectorDB === ""pinecone""
        ? {
            PineConeEnvironment: process.env.PINECONE_ENVIRONMENT,
            PineConeKey: !!process.env.PINECONE_API_KEY,
            PineConeIndex: process.env.PINECONE_INDEX,
          }
        : {}),
      ...(vectorDB === ""chroma""
        ? {
            ChromaEndpoint: process.env.CHROMA_ENDPOINT,
          }
        : {}),
      ...(vectorDB === ""weaviate""
        ? {
            WeaviateEndpoint: process.env.WEAVIATE_ENDPOINT,
            WeaviateApiKey: process.env.WEAVIATE_API_KEY,
          }
        : {}),
      ...(vectorDB === ""qdrant""
        ? {
            QdrantEndpoint: process.env.QDRANT_ENDPOINT,
            QdrantApiKey: process.env.QDRANT_API_KEY,
          }
        : {}),
      LLMProvider: llmProvider,
      ...(llmProvider === ""openai""
        ? {
            OpenAiKey: !!process.env.OPEN_AI_KEY,
            OpenAiModelPref: process.env.OPEN_MODEL_PREF || ""gpt-3.5-turbo"",
          }
        : {}),

      ...(llmProvider === ""azure""
        ? {
            AzureOpenAiEndpoint: process.env.AZURE_OPENAI_ENDPOINT,
            AzureOpenAiKey: !!process.env.AZURE_OPENAI_KEY,
            AzureOpenAiModelPref: process.env.OPEN_MODEL_PREF,
            AzureOpenAiEmbeddingModelPref: process.env.EMBEDDING_MODEL_PREF,
          }
        : {}),
    };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    return result;
  },
  where: async function (clause = null, limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  updateSettings: async function (updates = {}) {
    const validConfigKeys = Object.keys(updates).filter((key) =>
      this.supportedFields.includes(key)
    );
    for (const key of validConfigKeys) {
      const existingRecord = await this.get(`label = '${key}'`);
      if (!existingRecord) {
        const db = await this.db();
        const value = updates[key] === null ? null : String(updates[key]);
        const { success, message } = await db
          .run(`INSERT INTO ${this.tablename} (label, value) VALUES (?, ?)`, [
            key,
            value,
          ])
          .then((res) => {
            return { id: res.lastID, success: true, message: null };
          })
          .catch((error) => {
            return { id: null, success: false, message: error.message };
          });
        db.close();
        if (!success) {
          console.error(""FAILED TO ADD SYSTEM CONFIG OPTION"", message);
          return { success: false, error: message };
        }
      } else {
        const db = await this.db();
        const value = updates[key] === null ? null : String(updates[key]);
        const { success, message } = await db
          .run(`UPDATE ${this.tablename} SET label=?,value=? WHERE id = ?`, [
            key,
            value,
            existingRecord.id,
          ])
          .then(() => {
            return { success: true, message: null };
          })
          .catch((error) => {
            return { success: false, message: error.message };
          });

        db.close();
        if (!success) {
          console.error(""FAILED TO UPDATE SYSTEM CONFIG OPTION"", message);
          return { success: false, error: message };
        }
      }
    }
    return { success: true, error: null };
  },
  isMultiUserMode: async function () {
    return (await this.get(`label = 'multi_user_mode'`))?.value === ""true"";
  },
  currentLogoFilename: async function () {
    const result = await this.get(`label = 'logo_filename'`);
    return result ? result.value : null;
  },
  canDeleteWorkspaces: async function () {
    return (
      (await this.get(`label = 'users_can_delete_workspaces'`))?.value ===
      ""true""
    );
  },
};

module.exports.SystemSettings = SystemSettings;",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR.VAR.VAR === ""VAR"" ? VAR(""VAR"").VAR({ VAR: `.VAR.${VAR.VAR.VAR}` }) : VAR(""VAR"").VAR(); VAR VAR = { VAR: [ ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ], VAR: [], VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR () { VAR VAR = VAR.VAR.VAR || ""VAR""; VAR VAR = VAR.VAR.VAR || ""VAR""; VAR { VAR: !!!VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR, VAR: VAR VAR.VAR(), VAR: VAR, ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), VAR: VAR, ...(VAR === ""VAR"" ? { VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR || ""VAR-3.5-VAR"", } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = {}) { VAR VAR = VAR.VAR(VAR).VAR((VAR) => VAR.VAR.VAR(VAR) ); VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR.VAR(`VAR = '${VAR}'`); VAR (!VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR[VAR] === VAR ? VAR : VAR(VAR[VAR]); VAR { VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?, ?)`, [ VAR, VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(""VAR VAR VAR VAR VAR VAR"", VAR); VAR { VAR: VAR, VAR: VAR }; } } VAR { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR[VAR] === VAR ? VAR : VAR(VAR[VAR]); VAR { VAR, VAR } = VAR VAR .VAR(`VAR ${VAR.VAR} VAR VAR=?,VAR=? VAR VAR = ?`, [ VAR, VAR, VAR.VAR, ]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(""VAR VAR VAR VAR VAR VAR"", VAR); VAR { VAR: VAR, VAR: VAR }; } } } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR () { VAR (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR === ""VAR""; }, VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(`VAR = 'VAR'`); VAR VAR ? VAR.VAR : VAR; }, VAR: VAR VAR () { VAR ( (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR === ""VAR"" ); }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/telemetry.js,"const { v4 } = require(""uuid"");
const { SystemSettings } = require(""./systemSettings"");

const Telemetry = {
  // Write-only key. It can't read events or any of your other data, so it's safe to use in public apps.
  pubkey: ""phc_9qu7QLpV8L84P3vFmEiZxL020t2EqIubP7HHHxrSsqS"",
  stubDevelopmentEvents: true, // [DO NOT TOUCH] Core team only.
  label: ""telemetry_id"",
  id: async function () {
    const result = await SystemSettings.get(`label = '${this.label}'`);
    if (!!result?.value) return result.value;
    return result?.value;
  },
  connect: async function () {
    const client = this.client();
    const distinctId = await this.findOrCreateId();
    return { client, distinctId };
  },
  isDev: function () {
    if (process.env.NODE_ENV === ""development"")
      return this.stubDevelopmentEvents;
    return false;
  },
  client: function () {
    if (process.env.DISABLE_TELEMETRY === ""true"" || this.isDev()) return null;
    const { PostHog } = require(""posthog-node"");
    return new PostHog(this.pubkey);
  },
  sendTelemetry: async function (event, properties = {}) {
    try {
      const { client, distinctId } = await this.connect();
      if (!client) return;
      console.log(`\x1b[32m[TELEMETRY SENT]\x1b[0m`, {
        event,
        properties,
      });
      client.capture({
        event,
        distinctId,
        properties,
      });
    } catch {
      return;
    }
  },
  flush: async function () {
    const { client } = this.client();
    if (!client) return;
    await client.shutdownAsync();
    return;
  },
  setUid: async function () {
    const newId = v4();
    await SystemSettings.updateSettings({ [this.label]: newId });
    return newId;
  },
  findOrCreateId: async function () {
    const currentId = await this.id();
    if (!!currentId) return currentId;
    const newId = await this.setUid();
    return newId;
  },
};

module.exports = { Telemetry };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR""); VAR { VAR } = VAR(""./VAR""); VAR VAR = {  VAR: ""VAR"", VAR: VAR,  VAR: ""VAR"", VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(`VAR = '${VAR.VAR}'`); VAR (!!VAR?.VAR) VAR VAR.VAR; VAR VAR?.VAR; }, VAR: VAR VAR () { VAR VAR = VAR.VAR(); VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR }; }, VAR: VAR () { VAR (VAR.VAR.VAR === ""VAR"") VAR VAR.VAR; VAR VAR; }, VAR: VAR () { VAR (VAR.VAR.VAR === ""VAR"" || VAR.VAR()) VAR VAR; VAR { VAR } = VAR(""VAR-VAR""); VAR VAR VAR(VAR.VAR); }, VAR: VAR VAR (VAR, VAR = {}) { VAR { VAR { VAR, VAR } = VAR VAR.VAR(); VAR (!VAR) VAR; VAR.VAR(`\VAR[32m[VAR VAR]\VAR[0m`, { VAR, VAR, }); VAR.VAR({ VAR, VAR, VAR, }); } VAR { VAR; } }, VAR: VAR VAR () { VAR { VAR } = VAR.VAR(); VAR (!VAR) VAR; VAR VAR.VAR(); VAR; }, VAR: VAR VAR () { VAR VAR = VAR(); VAR VAR.VAR({ [VAR.VAR]: VAR }); VAR VAR; }, VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(); VAR (!!VAR) VAR VAR; VAR VAR = VAR VAR.VAR(); VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/user.js,"const User = {
  tablename: ""users"",
  writable: [],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE,
  password TEXT NOT NULL,
  role TEXT NOT NULL DEFAULT ""default"",
  suspended INTEGER NOT NULL DEFAULT 0,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for User migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  create: async function ({ username, password, role = null }) {
    const bcrypt = require(""bcrypt"");
    const db = await this.db();
    const { id, success, message } = await db
      .run(
        `INSERT INTO ${this.tablename} (username, password, role) VALUES(?, ?, ?)`,
        [username, bcrypt.hashSync(password, 10), role ?? ""default""]
      )
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE USER."", message);
      return { user: null, error: message };
    }

    const user = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id} `
    );
    db.close();

    return { user, error: null };
  },
  update: async function (userId, updates = {}) {
    const user = await this.get(`id = ${userId}`);
    if (!user) return { success: false, error: ""User does not exist."" };
    const { username, password, role, suspended = 0 } = updates;
    const toUpdate = { suspended };

    if (user.username !== username && username?.length > 0) {
      const usedUsername = !!(await this.get(`username = '${username}'`));
      if (usedUsername)
        return { success: false, error: `${username} is already in use.` };
      toUpdate.username = username;
    }

    if (!!password) {
      const bcrypt = require(""bcrypt"");
      toUpdate.password = bcrypt.hashSync(password, 10);
    }

    if (user.role !== role && [""admin"", ""default""].includes(role)) {
      // If was existing admin and that has been changed
      // make sure at least one admin exists
      if (user.role === ""admin"") {
        const validAdminCount = (await this.count(`role = 'admin'`)) > 1;
        if (!validAdminCount)
          return {
            success: false,
            error: `There would be no admins if this action was completed. There must be at least one admin.`,
          };
      }

      toUpdate.role = role;
    }

    if (Object.keys(toUpdate).length !== 0) {
      const values = Object.values(toUpdate);
      const template = `UPDATE ${this.tablename} SET ${Object.keys(
        toUpdate
      ).map((key) => {
        return `${key}=?`;
      })} WHERE id = ?`;

      const db = await this.db();
      const { success, message } = await db
        .run(template, [...values, userId])
        .then(() => {
          return { success: true, message: null };
        })
        .catch((error) => {
          return { success: false, message: error.message };
        });

      db.close();
      if (!success) {
        console.error(message);
        return { success: false, error: message };
      }
    }

    return { success: true, error: null };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();
    return { ...result };
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
};

module.exports = { User };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = { VAR: ""VAR"", VAR: [], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR ""VAR"", VAR VAR VAR VAR VAR 0, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR ({ VAR, VAR, VAR = VAR }) { VAR VAR = VAR(""VAR""); VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR) VAR(?, ?, ?)`, [VAR, VAR.VAR(VAR, 10), VAR ?? ""VAR""] ) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR."", VAR); VAR { VAR: VAR, VAR: VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR} ` ); VAR.VAR(); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR, VAR = {}) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR}`); VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR."" }; VAR { VAR, VAR, VAR, VAR = 0 } = VAR; VAR VAR = { VAR }; VAR (VAR.VAR !== VAR && VAR?.VAR > 0) { VAR VAR = !!(VAR VAR.VAR(`VAR = '${VAR}'`)); VAR (VAR) VAR { VAR: VAR, VAR: `${VAR} VAR VAR VAR VAR.` }; VAR.VAR = VAR; } VAR (!!VAR) { VAR VAR = VAR(""VAR""); VAR.VAR = VAR.VAR(VAR, 10); } VAR (VAR.VAR !== VAR && [""VAR"", ""VAR""].VAR(VAR)) {   VAR (VAR.VAR === ""VAR"") { VAR VAR = (VAR VAR.VAR(`VAR = 'VAR'`)) > 1; VAR (!VAR) VAR { VAR: VAR, VAR: `VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR.`, }; } VAR.VAR = VAR; } VAR (VAR.VAR(VAR).VAR !== 0) { VAR VAR = VAR.VAR(VAR); VAR VAR = `VAR ${VAR.VAR} VAR ${VAR.VAR( VAR ).VAR((VAR) => { VAR `${VAR}=?`; })} VAR VAR = ?`; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(VAR, [...VAR, VAR]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR }; } } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR { ...VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, }; VAR.VAR = { VAR }; ",4,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/vectors.js,"const { checkForMigrations } = require(""../utils/database"");
const { Document } = require(""./documents"");

// TODO: Do we want to store entire vectorized chunks in here
// so that we can easily spin up temp-namespace clones for threading
const DocumentVectors = {
  tablename: ""document_vectors"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  docId TEXT NOT NULL,
  vectorId TEXT NOT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for DocumentVector migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  bulkInsert: async function (vectorRecords = []) {
    if (vectorRecords.length === 0) return;

    const db = await this.db();

    // Build a single query string with multiple placeholders for the INSERT operation
    const placeholders = vectorRecords.map(() => ""(?, ?)"").join("", "");

    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (docId, vectorId) VALUES ${placeholders}`
    );

    // Flatten the vectorRecords array to match the order of placeholders
    const values = vectorRecords.reduce(
      (arr, record) => arr.concat([record.docId, record.vectorId]),
      []
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      await stmt.run(values);
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();

    return { documentsInserted: vectorRecords.length };
  },
  deleteForWorkspace: async function (workspaceId) {
    const documents = await Document.forWorkspace(workspaceId);
    const docIds = [...new Set(documents.map((doc) => doc.docId))];
    const ids = (
      await this.where(`docId IN (${docIds.map((id) => `'${id}'`).join("","")})`)
    ).map((doc) => doc.id);
    await this.deleteIds(ids);
    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );

    db.close();
    return results;
  },
  deleteIds: async function (ids = []) {
    const db = await this.db();
    await db.get(
      `DELETE FROM ${this.tablename} WHERE id IN (${ids.join("", "")}) `
    );
    db.close();
    return true;
  },
};

module.exports = { DocumentVectors };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""./VAR"");   VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = []) { VAR (VAR.VAR === 0) VAR; VAR VAR = VAR VAR.VAR();  VAR VAR = VAR.VAR(() => ""(?, ?)"").VAR("", ""); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR ${VAR}` );  VAR VAR = VAR.VAR( (VAR, VAR) => VAR.VAR([VAR.VAR, VAR.VAR]), [] ); VAR VAR.VAR(""VAR VAR""); VAR { VAR VAR.VAR(VAR); VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR { VAR: VAR.VAR }; }, VAR: VAR VAR (VAR) { VAR VAR = VAR VAR.VAR(VAR); VAR VAR = [...VAR VAR(VAR.VAR((VAR) => VAR.VAR))]; VAR VAR = ( VAR VAR.VAR(`VAR VAR (${VAR.VAR((VAR) => `'${VAR}'`).VAR("","")})`) ).VAR((VAR) => VAR.VAR); VAR VAR.VAR(VAR); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = []) { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR( `VAR VAR ${VAR.VAR} VAR VAR VAR (${VAR.VAR("", "")}) ` ); VAR.VAR(); VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/welcomeMessages.js,"const WelcomeMessages = {
  tablename: ""welcome_messages"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user TEXT NOT NULL,
  response TEXT NOT NULL,
  orderIndex INTEGER,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,

  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for Welcome Messages migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
    db.close();
  },

  migrations: function () {
    return [];
  },

  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) {
      db.on(""trace"", (sql) => console.log(sql));
    }

    return db;
  },

  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    db.close();
    return result;
  },

  where: async function (clause = null, limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();
    return results;
  },

  saveAll: async function (messages) {
    const db = await this.db();
    await db.run(`DELETE FROM ${this.tablename}`);
    for (const [index, message] of messages.entries()) {
      await db.run(
        `INSERT INTO ${this.tablename} (user, response, orderIndex) VALUES (?, ?, ?)`,
        [message.user, message.response, index]
      );
    }
    db.close();
  },

  getMessages: async function () {
    const db = await this.db();
    const results = await db.all(
      `SELECT user, response FROM ${this.tablename} ORDER BY orderIndex ASC`
    );
    db.close();
    return results;
  },
};

module.exports.WelcomeMessages = WelcomeMessages;",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); VAR.VAR(); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) { VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); } VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR}`); VAR (VAR [VAR, VAR] VAR VAR.VAR()) { VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR) VAR (?, ?, ?)`, [VAR.VAR, VAR.VAR, VAR] ); } VAR.VAR(); }, VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR, VAR VAR ${VAR.VAR} VAR VAR VAR VAR` ); VAR.VAR(); VAR VAR; }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/workspaceChats.js,"const { checkForMigrations } = require(""../utils/database"");

const WorkspaceChats = {
  tablename: ""workspace_chats"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  workspaceId INTEGER NOT NULL,
  prompt TEXT NOT NULL,
  response TEXT NOT NULL,
  include BOOL DEFAULT true,
  user_id INTEGER DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
  `,
  migrateTable: async function () {
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for WorkspaceChats migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [
      {
        colName: ""user_id"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN user_id INTEGER DEFAULT NULL`,
        doif: false,
      },
    ];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  new: async function ({ workspaceId, prompt, response = {}, user = null }) {
    const db = await this.db();
    const { id, success, message } = await db
      .run(
        `INSERT INTO ${this.tablename} (workspaceId, prompt, response, user_id) VALUES (?, ?, ?, ?)`,
        [workspaceId, prompt, JSON.stringify(response), user?.id || null]
      )
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });
    if (!success) {
      db.close();
      return { chat: null, message };
    }

    const chat = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id}`
    );
    db.close();

    return { chat, message: null };
  },
  forWorkspaceByUser: async function (
    workspaceId = null,
    userId = null,
    limit = null
  ) {
    if (!workspaceId || !userId) return [];
    return await this.where(
      `workspaceId = ${workspaceId} AND include = true AND user_id = ${userId}`,
      limit,
      ""ORDER BY id ASC""
    );
  },
  forWorkspace: async function (workspaceId = null, limit = null) {
    if (!workspaceId) return [];
    return await this.where(
      `workspaceId = ${workspaceId} AND include = true`,
      limit,
      ""ORDER BY id ASC""
    );
  },
  markHistoryInvalid: async function (workspaceId = null, user = null) {
    if (!workspaceId) return;
    const db = await this.db();
    await db.run(
      `UPDATE ${this.tablename} SET include = false WHERE workspaceId = ? ${
        user ? `AND user_id = ${user.id}` : """"
      }`,
      [workspaceId]
    );
    db.close();

    return;
  },
  get: async function (clause = """", limit = null, order = null) {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} WHERE ${clause} ${
          !!order ? order : """"
        } ${!!limit ? `LIMIT ${limit}` : """"}`
      )
      .then((res) => res || null);
    db.close();

    if (!result) return null;
    return result;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null, order = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!order ? order : """"
      } ${!!limit ? `LIMIT ${limit}` : """"}`
    );
    db.close();

    return results;
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  whereWithData: async function (clause = """", limit = null, order = null) {
    const { Workspace } = require(""./workspace"");
    const { User } = require(""./user"");
    const results = await this.where(clause, limit, order);
    for (const res of results) {
      const workspace = await Workspace.get(`id = ${res.workspaceId}`);
      res.workspace = workspace
        ? { name: workspace.name, slug: workspace.slug }
        : { name: ""deleted workspace"", slug: null };

      const user = await User.get(`id = ${res.user_id}`);
      res.user = user
        ? { username: user.username }
        : { username: ""deleted user"" };
    }
    return results;
  },
};

module.exports = { WorkspaceChats };",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR (VAR) VAR VAR (VAR) VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR [ { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR`, VAR: VAR, }, ]; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR ({ VAR, VAR, VAR = {}, VAR = VAR }) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR, VAR) VAR (?, ?, ?, ?)`, [VAR, VAR, VAR.VAR(VAR), VAR?.VAR || VAR] ) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR { VAR: VAR, VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR}` ); VAR.VAR(); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR ( VAR = VAR, VAR = VAR, VAR = VAR ) { VAR (!VAR || !VAR) VAR []; VAR VAR VAR.VAR( `VAR = ${VAR} VAR VAR = VAR VAR VAR = ${VAR}`, VAR, ""VAR VAR VAR VAR"" ); }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR (!VAR) VAR []; VAR VAR VAR.VAR( `VAR = ${VAR} VAR VAR = VAR`, VAR, ""VAR VAR VAR VAR"" ); }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR (!VAR) VAR; VAR VAR = VAR VAR.VAR(); VAR VAR.VAR( `VAR ${VAR.VAR} VAR VAR = VAR VAR VAR = ? ${ VAR ? `VAR VAR = ${VAR.VAR}` : """" }`, [VAR] ); VAR.VAR(); VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} VAR ${VAR} ${ !!VAR ? VAR : """" } ${!!VAR ? `VAR ${VAR}` : """"}` ) .VAR((VAR) => VAR || VAR); VAR.VAR(); VAR (!VAR) VAR VAR; VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? VAR : """" } ${!!VAR ? `VAR ${VAR}` : """"}` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR { VAR } = VAR(""./VAR""); VAR { VAR } = VAR(""./VAR""); VAR VAR = VAR VAR.VAR(VAR, VAR, VAR); VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = VAR ? { VAR: VAR.VAR, VAR: VAR.VAR } : { VAR: ""VAR VAR"", VAR: VAR }; VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = VAR ? { VAR: VAR.VAR } : { VAR: ""VAR VAR"" }; } VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/models/workspaceUsers.js,"const WorkspaceUser = {
  tablename: ""workspace_users"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  workspace_id INTEGER NOT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
  FOREIGN KEY (workspace_id) REFERENCES workspaces (id) ON DELETE CASCADE
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for Workspace User migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  createMany: async function (userId, workspaceIds = []) {
    if (workspaceIds.length === 0) return;
    const db = await this.db();
    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (user_id, workspace_id) VALUES (?,?)`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const workspaceId of workspaceIds) {
        await stmt.run([userId, workspaceId]);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    return;
  },
  createManyUsers: async function (userIds = [], workspaceId) {
    if (userIds.length === 0) return;
    const db = await this.db();
    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (user_id, workspace_id) VALUES (?,?)`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const userId of userIds) {
        await stmt.run([userId, workspaceId]);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    return;
  },
  create: async function (userId = 0, workspaceId = 0) {
    const db = await this.db();
    const { success, message } = await db
      .run(
        `INSERT INTO ${this.tablename} (user_id, workspace_id) VALUES (?, ?)`,
        [userId, workspaceId]
      )
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE WORKSPACE_USER RELATIONSHIP."", message);
      return false;
    }
    return true;
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    return result;
  },
  where: async function (clause = null, limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      }`
    );
    db.close();

    return count;
  },
  delete: async function (clause = null) {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    return;
  },
};

module.exports.WorkspaceUser = WorkspaceUser;",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR (VAR) VAR VAR (VAR) VAR VAR VAR, VAR VAR (VAR) VAR VAR (VAR) VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR (VAR.VAR === 0) VAR; VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?,?)` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR([VAR, VAR]); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR; }, VAR: VAR VAR (VAR = [], VAR) { VAR (VAR.VAR === 0) VAR; VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?,?)` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR([VAR, VAR]); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR; }, VAR: VAR VAR (VAR = 0, VAR = 0) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?, ?)`, [VAR, VAR] ) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR VAR."", VAR); VAR VAR; } VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR; }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/utils/database/index.js,"const { getGitVersion } = require(""../../endpoints/utils"");
const { Telemetry } = require(""../../models/telemetry"");

function checkColumnTemplate(tablename = null, column = null) {
  if (!tablename || !column)
    throw new Error(`Migration Error`, { tablename, column });
  return `SELECT COUNT(*) AS _exists FROM pragma_table_info('${tablename}') WHERE name='${column}'`;
}

// Note (tcarambat): Since there is no good way to track migrations in Node/SQLite we use this simple system
// Each model has a `migrations` method that will return an array like...
// { colName: 'stringColName', execCmd: `SQL Command to run when`, doif: boolean },
// colName = name of column
// execCmd = Command to run when doif matches the state of the DB
// doif = condition to match that determines if execCmd will run.
// eg: Table workspace has slug column.
// execCmd: ALTER TABLE DROP COLUMN slug;
// doif: true
// => Will drop the slug column if the workspace table has a column named 'slug' otherwise nothing happens.
// If you are adding a new table column if needs to exist in the Models `colsInit` and as a migration.
// So both new and existing DBs will get the column when code is pulled in.

async function checkForMigrations(model, db) {
  if (model.migrations().length === 0) return;
  const toMigrate = [];
  for (const { colName, execCmd, doif } of model.migrations()) {
    const { _exists } = await db.get(
      checkColumnTemplate(model.tablename, colName)
    );
    const colExists = _exists !== 0;
    if (colExists !== doif) continue;

    toMigrate.push(execCmd);
  }

  if (toMigrate.length === 0) return;

  console.log(`Running ${toMigrate.length} migrations`, toMigrate);
  await db.exec(toMigrate.join("";\n""));
  return;
}

// Note(tcarambat): When building in production via Docker the SQLite file will not exist
// and if this function tries to run on boot the file will not exist
// and the server will abort and the container will exit.
// This function will run each reload on dev but on production
// it will be stubbed until the /api/migrate endpoint is GET.
async function validateTablePragmas(force = false) {
  try {
    if (process.env.NODE_ENV !== ""development"" && force === false) {
      console.log(
        `\x1b[34m[MIGRATIONS STUBBED]\x1b[0m Please ping /migrate once server starts to run migrations`
      );
      return;
    }
    const { SystemSettings } = require(""../../models/systemSettings"");
    const { User } = require(""../../models/user"");
    const { Workspace } = require(""../../models/workspace"");
    const { WorkspaceUser } = require(""../../models/workspaceUsers"");
    const { Document } = require(""../../models/documents"");
    const { DocumentVectors } = require(""../../models/vectors"");
    const { WorkspaceChats } = require(""../../models/workspaceChats"");
    const { Invite } = require(""../../models/invite"");
    const { WelcomeMessages } = require(""../../models/welcomeMessages"");
    const { ApiKey } = require(""../../models/apiKeys"");

    await SystemSettings.migrateTable();
    await User.migrateTable();
    await Workspace.migrateTable();
    await WorkspaceUser.migrateTable();
    await Document.migrateTable();
    await DocumentVectors.migrateTable();
    await WorkspaceChats.migrateTable();
    await Invite.migrateTable();
    await WelcomeMessages.migrateTable();
    await ApiKey.migrateTable();
  } catch (e) {
    console.error(`validateTablePragmas: Migrations failed`, e);
  }
  return;
}

// Telemetry is anonymized and your data is never read. This can be disabled by setting
// DISABLE_TELEMETRY=true in the `.env` of however you setup. Telemetry helps us determine use
// of how AnythingLLM is used and how to improve this product!
// You can see all Telemetry events by ctrl+f `Telemetry.sendEvent` calls to verify this claim.
async function setupTelemetry() {
  if (process.env.DISABLE_TELEMETRY === ""true"") {
    console.log(
      `\x1b[31m[TELEMETRY DISABLED]\x1b[0m Telemetry is marked as disabled - no events will send. Telemetry helps Mintplex Labs Inc improve AnythingLLM.`
    );
    return true;
  }

  if (Telemetry.isDev()) {
    console.log(
      `\x1b[33m[TELEMETRY STUBBED]\x1b[0m Anonymous Telemetry stubbed in development.`
    );
    return;
  }

  console.log(
    `\x1b[32m[TELEMETRY ENABLED]\x1b[0m Anonymous Telemetry enabled. Telemetry helps Mintplex Labs Inc improve AnythingLLM.`
  );
  await Telemetry.findOrCreateId();
  await Telemetry.sendTelemetry(""server_boot"", {
    commit: getGitVersion(),
  });
  return;
}

module.exports = {
  checkForMigrations,
  validateTablePragmas,
  setupTelemetry,
};",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR VAR(VAR = VAR, VAR = VAR) { VAR (!VAR || !VAR) VAR VAR VAR(`VAR VAR`, { VAR, VAR }); VAR `VAR VAR(*) VAR VAR VAR VAR('${VAR}') VAR VAR='${VAR}'`; }             VAR VAR VAR(VAR, VAR) { VAR (VAR.VAR().VAR === 0) VAR; VAR VAR = []; VAR (VAR { VAR, VAR, VAR } VAR VAR.VAR()) { VAR { VAR } = VAR VAR.VAR( VAR(VAR.VAR, VAR) ); VAR VAR = VAR !== 0; VAR (VAR !== VAR) VAR; VAR.VAR(VAR); } VAR (VAR.VAR === 0) VAR; VAR.VAR(`VAR ${VAR.VAR} VAR`, VAR); VAR VAR.VAR(VAR.VAR("";\VAR"")); VAR; }      VAR VAR VAR(VAR = VAR) { VAR { VAR (VAR.VAR.VAR !== ""VAR"" && VAR === VAR) { VAR.VAR( `\VAR[34m[VAR VAR]\VAR[0m VAR VAR /VAR VAR VAR VAR VAR VAR VAR` ); VAR; } VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); } VAR (VAR) { VAR.VAR(`VAR: VAR VAR`, VAR); } VAR; }     VAR VAR VAR() { VAR (VAR.VAR.VAR === ""VAR"") { VAR.VAR( `\VAR[31m[VAR VAR]\VAR[0m VAR VAR VAR VAR VAR - VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR.` ); VAR VAR; } VAR (VAR.VAR()) { VAR.VAR( `\VAR[33m[VAR VAR]\VAR[0m VAR VAR VAR VAR VAR.` ); VAR; } VAR.VAR( `\VAR[32m[VAR VAR]\VAR[0m VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR.` ); VAR VAR.VAR(); VAR VAR.VAR(""VAR"", { VAR: VAR(), }); VAR; } VAR.VAR = { VAR, VAR, VAR, }; ",0,12
anything-llm_3c88aec034934bcbad30c5ef1cab62cbbdb98e64,server/utils/files/data.js,"const fs = require(""fs"");
const path = require(""path"");
const { v4 } = require(""uuid"");

async function exportData() {
  const uid = `anythingllm-export-${new Date()
    .toJSON()
    .slice(0, 10)}-${new Date().toJSON().slice(11, 19)}`;
  const folder =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage/exports/${uid}`)
      : path.resolve(process.env.STORAGE_DIR, `exports/${uid}`);
  const storageBase =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage`)
      : path.resolve(process.env.STORAGE_DIR);

  try {
    fs.mkdirSync(folder, { recursive: true });
    if (fs.existsSync(path.resolve(storageBase, `documents`))) {
      console.log(""\x1b[34m[EXPORTING DATA]\x1b[0m Copying documents!"");
      fs.cpSync(
        path.resolve(storageBase, `documents`),
        path.resolve(folder, ""documents""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(storageBase, `lancedb`))) {
      console.log(""\x1b[34m[EXPORTING DATA]\x1b[0m Copying LanceDB data!"");
      fs.cpSync(
        path.resolve(storageBase, `lancedb`),
        path.resolve(folder, ""lancedb""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(storageBase, `vector-cache`))) {
      console.log(""\x1b[34m[EXPORTING DATA]\x1b[0m Copying vector cache!"");
      fs.cpSync(
        path.resolve(storageBase, `vector-cache`),
        path.resolve(folder, ""vector-cache""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(storageBase, `anythingllm.db`))) {
      console.log(
        ""\x1b[34m[EXPORTING DATA]\x1b[0m Copying anythingllm database!""
      );
      fs.cpSync(
        path.resolve(storageBase, `anythingllm.db`),
        path.resolve(folder, ""anythingllm.db"")
      );
    }

    await zipDirectory(folder, path.resolve(folder, `../${uid}.zip`));
    fs.rmSync(folder, { recursive: true, force: true });
    return { filename: `${uid}.zip`, error: null };
  } catch (e) {
    // If anything goes wrong - abort and clean up
    console.error(e);
    if (fs.existsSync(folder))
      fs.rmSync(folder, { recursive: true, force: true });
    return { filename: null, error: e.message };
  }
}

async function unpackAndOverwriteImport(importFilename) {
  const importFilepath =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage/imports/${importFilename}`)
      : path.resolve(process.env.STORAGE_DIR, `imports/${importFilename}`);
  if (!fs.existsSync(importFilepath))
    return { success: false, error: ""Import file does not exist."" };

  const uid = v4();
  const outDir =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage/imports/${uid}`)
      : path.resolve(process.env.STORAGE_DIR, `imports/${uid}`);

  const storageBase =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage`)
      : path.resolve(process.env.STORAGE_DIR);

  try {
    console.log(
      ""\x1b[34m[EXTRACTING DATA]\x1b[0m Extracting data from zip into storage!""
    );
    const unzipProc = await unzipDirectory(importFilepath, outDir);
    if (!unzipProc.success) return unzipProc;

    if (fs.existsSync(path.resolve(outDir, `documents`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing documents!""
      );
      if (fs.existsSync(path.resolve(storageBase, `documents`)))
        fs.rmSync(path.resolve(storageBase, `documents`), {
          recursive: true,
          force: true,
        });
      fs.cpSync(
        path.resolve(outDir, `documents`),
        path.resolve(storageBase, ""documents""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(outDir, `lancedb`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing LanceDb!""
      );
      if (fs.existsSync(path.resolve(storageBase, `lancedb`)))
        fs.rmSync(path.resolve(storageBase, `lancedb`), {
          recursive: true,
          force: true,
        });
      fs.cpSync(
        path.resolve(outDir, `lancedb`),
        path.resolve(storageBase, ""lancedb""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(outDir, `vector-cache`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing Vector Cache!""
      );
      if (fs.existsSync(path.resolve(storageBase, `vector-cache`)))
        fs.rmSync(path.resolve(storageBase, `vector-cache`), {
          recursive: true,
          force: true,
        });
      fs.cpSync(
        path.resolve(outDir, `vector-cache`),
        path.resolve(storageBase, ""vector-cache""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(outDir, `anythingllm.db`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing AnythingLLM DB!""
      );
      if (fs.existsSync(path.resolve(storageBase, `anythingllm.db`)))
        fs.rmSync(path.resolve(storageBase, `anythingllm.db`), { force: true });
      fs.cpSync(
        path.resolve(outDir, `anythingllm.db`),
        path.resolve(storageBase, ""anythingllm.db"")
      );
    }

    fs.rmSync(outDir, { recursive: true, force: true });
    fs.rmSync(importFilepath, { force: true });
    return { success: true, error: null };
  } catch (e) {
    console.error(e);
    if (fs.existsSync(outDir))
      fs.rmSync(outDir, { recursive: true, force: true });
    if (fs.existsSync(importFilepath)) fs.rmSync(importFilepath);
    return { success: false, error: e.message };
  }
}

function zipDirectory(sourceDir, outPath) {
  const archiver = require(""archiver"");
  const archive = archiver(""zip"", { zlib: { level: 9 } });
  const stream = fs.createWriteStream(outPath);

  return new Promise((resolve, reject) => {
    archive
      .directory(sourceDir, false)
      .on(""error"", (err) => reject(err))
      .pipe(stream);

    stream.on(""close"", () => resolve());
    archive.finalize();
  });
}

async function unzipDirectory(sourcePath, outDir) {
  const extract = require(""extract-zip"");
  try {
    await extract(sourcePath, { dir: outDir });
    return { success: true, error: null };
  } catch (e) {
    console.error(""unzipToDirectory"", e);
    return { success: false, error: e.message };
  }
}

module.exports = {
  exportData,
  unpackAndOverwriteImport,
};",,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,CVE-2023-4897,3c88aec034934bcbad30c5ef1cab62cbbdb98e64,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = VAR(""VAR""); VAR VAR = VAR(""VAR""); VAR { VAR } = VAR(""VAR""); VAR VAR VAR() { VAR VAR = `VAR-VAR-${VAR VAR() .VAR() .VAR(0, 10)}-${VAR VAR().VAR().VAR(11, 19)}`; VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR/VAR/${VAR}`) : VAR.VAR(VAR.VAR.VAR, `VAR/${VAR}`); VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR`) : VAR.VAR(VAR.VAR.VAR); VAR { VAR.VAR(VAR, { VAR: VAR }); VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR(""\VAR[34m[VAR VAR]\VAR[0m VAR VAR!""); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR(""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR!""); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR-VAR`))) { VAR.VAR(""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR!""); VAR.VAR( VAR.VAR(VAR, `VAR-VAR`), VAR.VAR(VAR, ""VAR-VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR.VAR`))) { VAR.VAR( ""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR!"" ); VAR.VAR( VAR.VAR(VAR, `VAR.VAR`), VAR.VAR(VAR, ""VAR.VAR"") ); } VAR VAR(VAR, VAR.VAR(VAR, `../${VAR}.VAR`)); VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR { VAR: `${VAR}.VAR`, VAR: VAR }; } VAR (VAR) {  VAR.VAR(VAR); VAR (VAR.VAR(VAR)) VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR { VAR: VAR, VAR: VAR.VAR }; } } VAR VAR VAR(VAR) { VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR/VAR/${VAR}`) : VAR.VAR(VAR.VAR.VAR, `VAR/${VAR}`); VAR (!VAR.VAR(VAR)) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR VAR."" }; VAR VAR = VAR(); VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR/VAR/${VAR}`) : VAR.VAR(VAR.VAR.VAR, `VAR/${VAR}`); VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR`) : VAR.VAR(VAR.VAR.VAR); VAR { VAR.VAR( ""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR VAR VAR VAR!"" ); VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR.VAR) VAR VAR; VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR`), { VAR: VAR, VAR: VAR, }); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR`), { VAR: VAR, VAR: VAR, }); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR-VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR-VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR-VAR`), { VAR: VAR, VAR: VAR, }); VAR.VAR( VAR.VAR(VAR, `VAR-VAR`), VAR.VAR(VAR, ""VAR-VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR.VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR.VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR.VAR`), { VAR: VAR }); VAR.VAR( VAR.VAR(VAR, `VAR.VAR`), VAR.VAR(VAR, ""VAR.VAR"") ); } VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR.VAR(VAR, { VAR: VAR }); VAR { VAR: VAR, VAR: VAR }; } VAR (VAR) { VAR.VAR(VAR); VAR (VAR.VAR(VAR)) VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR (VAR.VAR(VAR)) VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR.VAR }; } } VAR VAR(VAR, VAR) { VAR VAR = VAR(""VAR""); VAR VAR = VAR(""VAR"", { VAR: { VAR: 9 } }); VAR VAR = VAR.VAR(VAR); VAR VAR VAR((VAR, VAR) => { VAR .VAR(VAR, VAR) .VAR(""VAR"", (VAR) => VAR(VAR)) .VAR(VAR); VAR.VAR(""VAR"", () => VAR()); VAR.VAR(); }); } VAR VAR VAR(VAR, VAR) { VAR VAR = VAR(""VAR-VAR""); VAR { VAR VAR(VAR, { VAR: VAR }); VAR { VAR: VAR, VAR: VAR }; } VAR (VAR) { VAR.VAR(""VAR"", VAR); VAR { VAR: VAR, VAR: VAR.VAR }; } } VAR.VAR = { VAR, VAR, }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,cloud-deployments/aws/cloudformation/generate.mjs,"// Note (tcarambat) This script should be executed from root via the `yarn generate::cloudformation` command only.
// This script will copy your current Docker .env settings being used into a slightly custom AWS CloudFormation template
// that you can upload and deploy on AWS in a single click!
// Recommended settings are already defined in the template but you can modify them as needed.
// AnythingLLM can run within the free tier services of AWS (t2.micro w/10GB of storage)
//
// This will deploy a fully public AnythingLLM so if you do not want anyone to access it please set the AUTH_TOKEN & JWT_SECRET envs
// before running this script. You can still run the collector scripts on AWS so no FTP or file uploads are required.
// Your documents and data do not leave your AWS instance when you host in the cloud this way.

import fs from 'fs';
import { fileURLToPath } from 'url';
import path, { dirname } from 'path';
import { exit } from 'process';
const __dirname = dirname(fileURLToPath(import.meta.url));
const REPLACEMENT_KEY = '!SUB::USER::CONTENT!'

const envPath = path.resolve(__dirname, `../../../docker/.env`)
const envFileExists = fs.existsSync(envPath);

const chalk = {
  redBright: function (text) {
    return `\x1b[31m${text}\x1b[0m`
  },
  cyan: function (text) {
    return `\x1b[36m${text}\x1b[0m`
  },
  greenBright: function (text) {
    return `\x1b[32m${text}\x1b[0m`
  },
  blueBright: function (text) {
    return `\x1b[34m${text}\x1b[0m`
  }
}

if (!envFileExists) {
  console.log(chalk.redBright('[ABORT]'), 'You do not have an .env file in your ./docker/ folder. You need to create it first.');
  console.log('You can start by running', chalk.cyan('cp -n ./docker/.env.example ./docker/.env'))
  exit(1);
}

// Remove comments
// Remove UID,GID,etc
// Remove empty strings
// Split into array
const settings = fs.readFileSync(envPath, ""utf8"")
  .replace(/^#.*\n?/gm, '')
  .replace(/^UID.*\n?/gm, '')
  .replace(/^GID.*\n?/gm, '')
  .replace(/^CLOUD_BUILD.*\n?/gm, '')
  .replace(/^\s*\n/gm, """")
  .split('\n')
  .filter((i) => !!i)
  .map((i) => i + '\n')

const templatePath = path.resolve(__dirname, `cf_template.template`);
const templateString = fs.readFileSync(templatePath, ""utf8"");
const template = JSON.parse(templateString);

const cmdIdx = template.Resources.AnythingLLMInstance.Properties.UserData['Fn::Base64']['Fn::Join'][1].findIndex((cmd) => cmd === REPLACEMENT_KEY)
template.Resources.AnythingLLMInstance.Properties.UserData['Fn::Base64']['Fn::Join'][1].splice(cmdIdx, 1, ...settings);

const output = path.resolve(__dirname, `aws_cf_deploy_anything_llm.json`);
fs.writeFileSync(output, JSON.stringify(template, null, 2), ""utf8"");

console.log(chalk.greenBright('[SUCCESS]'), 'Deploy AnythingLLM on AWS CloudFormation using your template document.');
console.log(chalk.greenBright('File Created:'), 'aws_cf_deploy_anything_llm.json in aws/cloudformation directory.');
console.log(chalk.blueBright('[INFO]'), 'Refer to aws/cloudformation/DEPLOY.md for how to use this file.');

exit();",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"         VAR VAR VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR, { VAR } VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR = VAR(VAR(VAR.VAR.VAR)); VAR VAR = '!VAR::VAR::VAR!' VAR VAR = VAR.VAR(VAR, `../../../VAR/.VAR`) VAR VAR = VAR.VAR(VAR); VAR VAR = { VAR: VAR (VAR) { VAR `\VAR[31m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[36m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[32m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[34m${VAR}\VAR[0m` } } VAR (!VAR) { VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR .VAR VAR VAR VAR ./VAR/ VAR. VAR VAR VAR VAR VAR VAR.'); VAR.VAR('VAR VAR VAR VAR VAR', VAR.VAR('VAR -VAR ./VAR/.VAR.VAR ./VAR/.VAR')) VAR(1); }     VAR VAR = VAR.VAR(VAR, ""VAR"") .VAR(/^ .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^\VAR*\VAR/VAR, """") .VAR('\VAR') .VAR((VAR) => !!VAR) .VAR((VAR) => VAR + '\VAR') VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR VAR = VAR.VAR(VAR, ""VAR""); VAR VAR = VAR.VAR(VAR); VAR VAR = VAR.VAR.VAR.VAR.VAR['VAR::VAR']['VAR::VAR'][1].VAR((VAR) => VAR === VAR) VAR.VAR.VAR.VAR.VAR['VAR::VAR']['VAR::VAR'][1].VAR(VAR, 1, ...VAR); VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR.VAR(VAR, VAR.VAR(VAR, VAR, 2), ""VAR""); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR VAR VAR VAR VAR.'); VAR.VAR(VAR.VAR('VAR VAR:'), 'VAR.VAR VAR VAR/VAR VAR.'); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR/VAR/VAR.VAR VAR VAR VAR VAR VAR VAR.'); VAR(); ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,cloud-deployments/aws/cloudformation/generate.mjs,"// Note (tcarambat) This script should be executed from root via the `yarn generate::cloudformation` command only.
// This script will copy your current Docker .env settings being used into a slightly custom AWS CloudFormation template
// that you can upload and deploy on AWS in a single click!
// Recommended settings are already defined in the template but you can modify them as needed.
// AnythingLLM can run within the free tier services of AWS (t2.micro w/10GB of storage)
//
// This will deploy a fully public AnythingLLM so if you do not want anyone to access it please set the AUTH_TOKEN & JWT_SECRET envs
// before running this script. You can still run the collector scripts on AWS so no FTP or file uploads are required.
// Your documents and data do not leave your AWS instance when you host in the cloud this way.

import fs from 'fs';
import { fileURLToPath } from 'url';
import path, { dirname } from 'path';
import { exit } from 'process';
const __dirname = dirname(fileURLToPath(import.meta.url));
const REPLACEMENT_KEY = '!SUB::USER::CONTENT!'

const envPath = path.resolve(__dirname, `../../../docker/.env`)
const envFileExists = fs.existsSync(envPath);

const chalk = {
  redBright: function (text) {
    return `\x1b[31m${text}\x1b[0m`
  },
  cyan: function (text) {
    return `\x1b[36m${text}\x1b[0m`
  },
  greenBright: function (text) {
    return `\x1b[32m${text}\x1b[0m`
  },
  blueBright: function (text) {
    return `\x1b[34m${text}\x1b[0m`
  }
}

if (!envFileExists) {
  console.log(chalk.redBright('[ABORT]'), 'You do not have an .env file in your ./docker/ folder. You need to create it first.');
  console.log('You can start by running', chalk.cyan('cp -n ./docker/.env.example ./docker/.env'))
  exit(1);
}

// Remove comments
// Remove UID,GID,etc
// Remove empty strings
// Split into array
const settings = fs.readFileSync(envPath, ""utf8"")
  .replace(/^#.*\n?/gm, '')
  .replace(/^UID.*\n?/gm, '')
  .replace(/^GID.*\n?/gm, '')
  .replace(/^CLOUD_BUILD.*\n?/gm, '')
  .replace(/^\s*\n/gm, """")
  .split('\n')
  .filter((i) => !!i)
  .map((i) => i + '\n')

const templatePath = path.resolve(__dirname, `cf_template.template`);
const templateString = fs.readFileSync(templatePath, ""utf8"");
const template = JSON.parse(templateString);

const cmdIdx = template.Resources.AnythingLLMInstance.Properties.UserData['Fn::Base64']['Fn::Join'][1].findIndex((cmd) => cmd === REPLACEMENT_KEY)
template.Resources.AnythingLLMInstance.Properties.UserData['Fn::Base64']['Fn::Join'][1].splice(cmdIdx, 1, ...settings);

const output = path.resolve(__dirname, `aws_cf_deploy_anything_llm.json`);
fs.writeFileSync(output, JSON.stringify(template, null, 2), ""utf8"");

console.log(chalk.greenBright('[SUCCESS]'), 'Deploy AnythingLLM on AWS CloudFormation using your template document.');
console.log(chalk.greenBright('File Created:'), 'aws_cf_deploy_anything_llm.json in aws/cloudformation directory.');
console.log(chalk.blueBright('[INFO]'), 'Refer to aws/cloudformation/DEPLOY.md for how to use this file.');

exit();",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"         VAR VAR VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR, { VAR } VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR = VAR(VAR(VAR.VAR.VAR)); VAR VAR = '!VAR::VAR::VAR!' VAR VAR = VAR.VAR(VAR, `../../../VAR/.VAR`) VAR VAR = VAR.VAR(VAR); VAR VAR = { VAR: VAR (VAR) { VAR `\VAR[31m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[36m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[32m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[34m${VAR}\VAR[0m` } } VAR (!VAR) { VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR .VAR VAR VAR VAR ./VAR/ VAR. VAR VAR VAR VAR VAR VAR.'); VAR.VAR('VAR VAR VAR VAR VAR', VAR.VAR('VAR -VAR ./VAR/.VAR.VAR ./VAR/.VAR')) VAR(1); }     VAR VAR = VAR.VAR(VAR, ""VAR"") .VAR(/^ .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^\VAR*\VAR/VAR, """") .VAR('\VAR') .VAR((VAR) => !!VAR) .VAR((VAR) => VAR + '\VAR') VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR VAR = VAR.VAR(VAR, ""VAR""); VAR VAR = VAR.VAR(VAR); VAR VAR = VAR.VAR.VAR.VAR.VAR['VAR::VAR']['VAR::VAR'][1].VAR((VAR) => VAR === VAR) VAR.VAR.VAR.VAR.VAR['VAR::VAR']['VAR::VAR'][1].VAR(VAR, 1, ...VAR); VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR.VAR(VAR, VAR.VAR(VAR, VAR, 2), ""VAR""); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR VAR VAR VAR VAR.'); VAR.VAR(VAR.VAR('VAR VAR:'), 'VAR.VAR VAR VAR/VAR VAR.'); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR/VAR/VAR.VAR VAR VAR VAR VAR VAR VAR.'); VAR(); ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,cloud-deployments/gcp/deployment/generate.mjs,"import fs from 'fs';
import { fileURLToPath } from 'url';
import path, { dirname } from 'path';
import { exit } from 'process';
const __dirname = dirname(fileURLToPath(import.meta.url));
const REPLACEMENT_KEY = '!SUB::USER::CONTENT!'

const envPath = path.resolve(__dirname, `../../../docker/.env`)
const envFileExists = fs.existsSync(envPath);

const chalk = {
  redBright: function (text) {
    return `\x1b[31m${text}\x1b[0m`
  },
  cyan: function (text) {
    return `\x1b[36m${text}\x1b[0m`
  },
  greenBright: function (text) {
    return `\x1b[32m${text}\x1b[0m`
  },
  blueBright: function (text) {
    return `\x1b[34m${text}\x1b[0m`
  }
}

if (!envFileExists) {
  console.log(chalk.redBright('[ABORT]'), 'You do not have an .env file in your ./docker/ folder. You need to create it first.');
  console.log('You can start by running', chalk.cyan('cp -n ./docker/.env.example ./docker/.env'))
  exit(1);
}

// Remove comments
// Remove UID,GID,etc
// Remove empty strings
// Split into array
const settings = fs.readFileSync(envPath, ""utf8"")
  .replace(/^#.*\n?/gm, '')
  .replace(/^UID.*\n?/gm, '')
  .replace(/^GID.*\n?/gm, '')
  .replace(/^CLOUD_BUILD.*\n?/gm, '')
  .replace(/^\s*\n/gm, """")
  .split('\n')
  .filter((i) => !!i);
const formattedSettings = settings.map((i, index) => index === 0 ? i + '\n' : '              ' + i).join('\n');

// Read the existing GCP Deployment Manager template
const templatePath = path.resolve(__dirname, `gcp_deploy_anything_llm.yaml`);
const templateString = fs.readFileSync(templatePath, ""utf8"");

// Update the metadata section with the UserData content
const updatedTemplateString = templateString.replace(REPLACEMENT_KEY, formattedSettings);

// Save the updated GCP Deployment Manager template
const output = path.resolve(__dirname, `gcp_deploy_anything_llm_with_env.yaml`);
fs.writeFileSync(output, updatedTemplateString, ""utf8"");

console.log(chalk.greenBright('[SUCCESS]'), 'Deploy AnythingLLM on GCP Deployment Manager using your template document.');
console.log(chalk.greenBright('File Created:'), 'gcp_deploy_anything_llm_with_env.yaml in the output directory.');
console.log(chalk.blueBright('[INFO]'), 'Refer to the GCP Deployment Manager documentation for how to use this file.');

exit();",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR, { VAR } VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR = VAR(VAR(VAR.VAR.VAR)); VAR VAR = '!VAR::VAR::VAR!' VAR VAR = VAR.VAR(VAR, `../../../VAR/.VAR`) VAR VAR = VAR.VAR(VAR); VAR VAR = { VAR: VAR (VAR) { VAR `\VAR[31m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[36m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[32m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[34m${VAR}\VAR[0m` } } VAR (!VAR) { VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR .VAR VAR VAR VAR ./VAR/ VAR. VAR VAR VAR VAR VAR VAR.'); VAR.VAR('VAR VAR VAR VAR VAR', VAR.VAR('VAR -VAR ./VAR/.VAR.VAR ./VAR/.VAR')) VAR(1); }     VAR VAR = VAR.VAR(VAR, ""VAR"") .VAR(/^ .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^\VAR*\VAR/VAR, """") .VAR('\VAR') .VAR((VAR) => !!VAR); VAR VAR = VAR.VAR((VAR, VAR) => VAR === 0 ? VAR + '\VAR' : ' ' + VAR).VAR('\VAR');  VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR VAR = VAR.VAR(VAR, ""VAR"");  VAR VAR = VAR.VAR(VAR, VAR);  VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR.VAR(VAR, VAR, ""VAR""); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.'); VAR.VAR(VAR.VAR('VAR VAR:'), 'VAR.VAR VAR VAR VAR VAR.'); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.'); VAR(); ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,cloud-deployments/gcp/deployment/generate.mjs,"import fs from 'fs';
import { fileURLToPath } from 'url';
import path, { dirname } from 'path';
import { exit } from 'process';
const __dirname = dirname(fileURLToPath(import.meta.url));
const REPLACEMENT_KEY = '!SUB::USER::CONTENT!'

const envPath = path.resolve(__dirname, `../../../docker/.env`)
const envFileExists = fs.existsSync(envPath);

const chalk = {
  redBright: function (text) {
    return `\x1b[31m${text}\x1b[0m`
  },
  cyan: function (text) {
    return `\x1b[36m${text}\x1b[0m`
  },
  greenBright: function (text) {
    return `\x1b[32m${text}\x1b[0m`
  },
  blueBright: function (text) {
    return `\x1b[34m${text}\x1b[0m`
  }
}

if (!envFileExists) {
  console.log(chalk.redBright('[ABORT]'), 'You do not have an .env file in your ./docker/ folder. You need to create it first.');
  console.log('You can start by running', chalk.cyan('cp -n ./docker/.env.example ./docker/.env'))
  exit(1);
}

// Remove comments
// Remove UID,GID,etc
// Remove empty strings
// Split into array
const settings = fs.readFileSync(envPath, ""utf8"")
  .replace(/^#.*\n?/gm, '')
  .replace(/^UID.*\n?/gm, '')
  .replace(/^GID.*\n?/gm, '')
  .replace(/^CLOUD_BUILD.*\n?/gm, '')
  .replace(/^\s*\n/gm, """")
  .split('\n')
  .filter((i) => !!i);
const formattedSettings = settings.map((i, index) => index === 0 ? i + '\n' : '              ' + i).join('\n');

// Read the existing GCP Deployment Manager template
const templatePath = path.resolve(__dirname, `gcp_deploy_anything_llm.yaml`);
const templateString = fs.readFileSync(templatePath, ""utf8"");

// Update the metadata section with the UserData content
const updatedTemplateString = templateString.replace(REPLACEMENT_KEY, formattedSettings);

// Save the updated GCP Deployment Manager template
const output = path.resolve(__dirname, `gcp_deploy_anything_llm_with_env.yaml`);
fs.writeFileSync(output, updatedTemplateString, ""utf8"");

console.log(chalk.greenBright('[SUCCESS]'), 'Deploy AnythingLLM on GCP Deployment Manager using your template document.');
console.log(chalk.greenBright('File Created:'), 'gcp_deploy_anything_llm_with_env.yaml in the output directory.');
console.log(chalk.blueBright('[INFO]'), 'Refer to the GCP Deployment Manager documentation for how to use this file.');

exit();",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR, { VAR } VAR 'VAR'; VAR { VAR } VAR 'VAR'; VAR VAR = VAR(VAR(VAR.VAR.VAR)); VAR VAR = '!VAR::VAR::VAR!' VAR VAR = VAR.VAR(VAR, `../../../VAR/.VAR`) VAR VAR = VAR.VAR(VAR); VAR VAR = { VAR: VAR (VAR) { VAR `\VAR[31m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[36m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[32m${VAR}\VAR[0m` }, VAR: VAR (VAR) { VAR `\VAR[34m${VAR}\VAR[0m` } } VAR (!VAR) { VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR .VAR VAR VAR VAR ./VAR/ VAR. VAR VAR VAR VAR VAR VAR.'); VAR.VAR('VAR VAR VAR VAR VAR', VAR.VAR('VAR -VAR ./VAR/.VAR.VAR ./VAR/.VAR')) VAR(1); }     VAR VAR = VAR.VAR(VAR, ""VAR"") .VAR(/^ .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^VAR.*\VAR?/VAR, '') .VAR(/^\VAR*\VAR/VAR, """") .VAR('\VAR') .VAR((VAR) => !!VAR); VAR VAR = VAR.VAR((VAR, VAR) => VAR === 0 ? VAR + '\VAR' : ' ' + VAR).VAR('\VAR');  VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR VAR = VAR.VAR(VAR, ""VAR"");  VAR VAR = VAR.VAR(VAR, VAR);  VAR VAR = VAR.VAR(VAR, `VAR.VAR`); VAR.VAR(VAR, VAR, ""VAR""); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.'); VAR.VAR(VAR.VAR('VAR VAR:'), 'VAR.VAR VAR VAR VAR VAR.'); VAR.VAR(VAR.VAR('[VAR]'), 'VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR.'); VAR(); ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/apiKeys.js,"const { Telemetry } = require(""./telemetry"");

const ApiKey = {
  tablename: ""api_keys"",
  writable: [],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  secret TEXT UNIQUE,
  createdBy INTEGER DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for ApiKey migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  makeSecret: () => {
    const uuidAPIKey = require(""uuid-apikey"");
    return uuidAPIKey.create().apiKey;
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  create: async function (createdByUserId = null) {
    const db = await this.db();
    const { id, success, message } = await db
      .run(`INSERT INTO ${this.tablename} (secret, createdBy) VALUES(?, ?)`, [
        this.makeSecret(),
        createdByUserId,
      ])
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE API KEY."", message);
      return { apiKey: null, error: message };
    }

    const apiKey = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id} `
    );
    db.close();
    await Telemetry.sendTelemetry(""api_key_created"");
    return { apiKey, error: null };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();
    return { ...result };
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(
      `DELETE FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"}`
    );
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  whereWithUser: async function (clause = """", limit = null) {
    const { User } = require(""./user"");
    const apiKeys = await this.where(clause, limit);

    for (const apiKey of apiKeys) {
      if (!apiKey.createdBy) continue;
      const user = await User.get(`id = ${apiKey.createdBy}`);
      if (!user) continue;

      apiKey.createdBy = {
        id: user.id,
        username: user.username,
        role: user.role,
      };
    }

    return apiKeys;
  },
};

module.exports = { ApiKey };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""./VAR""); VAR VAR = { VAR: ""VAR"", VAR: [], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: () => { VAR VAR = VAR(""VAR-VAR""); VAR VAR.VAR().VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR(?, ?)`, [ VAR.VAR(), VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR VAR."", VAR); VAR { VAR: VAR, VAR: VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR} ` ); VAR.VAR(); VAR VAR.VAR(""VAR""); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR { ...VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR( `VAR VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"}` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR { VAR } = VAR(""./VAR""); VAR VAR = VAR VAR.VAR(VAR, VAR); VAR (VAR VAR VAR VAR) { VAR (!VAR.VAR) VAR; VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR (!VAR) VAR; VAR.VAR = { VAR: VAR.VAR, VAR: VAR.VAR, VAR: VAR.VAR, }; } VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/apiKeys.js,"const { Telemetry } = require(""./telemetry"");

const ApiKey = {
  tablename: ""api_keys"",
  writable: [],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  secret TEXT UNIQUE,
  createdBy INTEGER DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for ApiKey migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  makeSecret: () => {
    const uuidAPIKey = require(""uuid-apikey"");
    return uuidAPIKey.create().apiKey;
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  create: async function (createdByUserId = null) {
    const db = await this.db();
    const { id, success, message } = await db
      .run(`INSERT INTO ${this.tablename} (secret, createdBy) VALUES(?, ?)`, [
        this.makeSecret(),
        createdByUserId,
      ])
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE API KEY."", message);
      return { apiKey: null, error: message };
    }

    const apiKey = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id} `
    );
    db.close();
    await Telemetry.sendTelemetry(""api_key_created"");
    return { apiKey, error: null };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();
    return { ...result };
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(
      `DELETE FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"}`
    );
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  whereWithUser: async function (clause = """", limit = null) {
    const { User } = require(""./user"");
    const apiKeys = await this.where(clause, limit);

    for (const apiKey of apiKeys) {
      if (!apiKey.createdBy) continue;
      const user = await User.get(`id = ${apiKey.createdBy}`);
      if (!user) continue;

      apiKey.createdBy = {
        id: user.id,
        username: user.username,
        role: user.role,
      };
    }

    return apiKeys;
  },
};

module.exports = { ApiKey };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""./VAR""); VAR VAR = { VAR: ""VAR"", VAR: [], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: () => { VAR VAR = VAR(""VAR-VAR""); VAR VAR.VAR().VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR(?, ?)`, [ VAR.VAR(), VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR VAR."", VAR); VAR { VAR: VAR, VAR: VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR} ` ); VAR.VAR(); VAR VAR.VAR(""VAR""); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR { ...VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR( `VAR VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"}` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR { VAR } = VAR(""./VAR""); VAR VAR = VAR VAR.VAR(VAR, VAR); VAR (VAR VAR VAR VAR) { VAR (!VAR.VAR) VAR; VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR (!VAR) VAR; VAR.VAR = { VAR: VAR.VAR, VAR: VAR.VAR, VAR: VAR.VAR, }; } VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/documents.js,"const { fileData } = require(""../utils/files"");
const { v4: uuidv4 } = require(""uuid"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { checkForMigrations } = require(""../utils/database"");
const { Telemetry } = require(""./telemetry"");

const Document = {
  tablename: ""workspace_documents"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  docId TEXT NOT NULL UNIQUE,
  filename TEXT NOT NULL,
  docpath TEXT NOT NULL,
  workspaceId INTEGER NOT NULL,
  metadata TEXT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for Document migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  forWorkspace: async function (workspaceId = null) {
    if (!workspaceId) return [];
    return await this.where(`workspaceId = ${workspaceId}`);
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();
    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );

    db.close();
    return results;
  },
  firstWhere: async function (clause = """") {
    const results = await this.where(clause);
    return results.length > 0 ? results[0] : null;
  },
  addDocuments: async function (workspace, additions = []) {
    const VectorDb = getVectorDbClass();
    if (additions.length === 0) return;
    const insertParams = [];

    for (const path of additions) {
      const data = await fileData(path);
      if (!data) continue;

      const docId = uuidv4();
      const { pageContent, ...metadata } = data;
      const newDoc = {
        docId,
        filename: path.split(""/"")[1],
        docpath: path,
        workspaceId: Number(workspace.id),
        metadata: JSON.stringify(metadata),
      };
      const vectorized = await VectorDb.addDocumentToNamespace(
        workspace.slug,
        { ...data, docId },
        path
      );
      if (!vectorized) {
        console.error(""Failed to vectorize"", path);
        continue;
      }

      insertParams.push([
        docId,
        newDoc.filename,
        newDoc.docpath,
        newDoc.workspaceId,
        newDoc.metadata,
      ]);
    }

    const db = await this.db();
    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (docId, filename, docpath, workspaceId, metadata) VALUES (?,?,?,?,?)`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const params of insertParams) {
        await stmt.run(params);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    await Telemetry.sendTelemetry(""documents_embedded_in_workspace"", {
      LLMSelection: process.env.LLM_PROVIDER || ""openai"",
      VectorDbSelection: process.env.VECTOR_DB || ""pinecone"",
    });
    return;
  },
  removeDocuments: async function (workspace, removals = []) {
    const VectorDb = getVectorDbClass();
    const deleteParams = [];
    if (removals.length === 0) return;

    for (const path of removals) {
      const document = await this.firstWhere(
        `docPath = '${path}' AND workspaceId = ${workspace.id}`
      );
      if (!document) continue;
      await VectorDb.deleteDocumentFromNamespace(
        workspace.slug,
        document.docId
      );
      deleteParams.push([path, workspace.id]);
    }

    const db = await this.db();
    const stmt = await db.prepare(
      `DELETE FROM ${this.tablename} WHERE docpath = ? AND workspaceId = ?`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const params of deleteParams) {
        await stmt.run(params);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    await Telemetry.sendTelemetry(""documents_removed_in_workspace"", {
      LLMSelection: process.env.LLM_PROVIDER || ""openai"",
      VectorDbSelection: process.env.VECTOR_DB || ""pinecone"",
    });
    return true;
  },
};

module.exports = { Document };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR: VAR } = VAR(""VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""./VAR""); VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR (!VAR) VAR []; VAR VAR VAR.VAR(`VAR = ${VAR}`); }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(VAR); VAR VAR.VAR > 0 ? VAR[0] : VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR VAR = VAR(); VAR (VAR.VAR === 0) VAR; VAR VAR = []; VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR(VAR); VAR (!VAR) VAR; VAR VAR = VAR(); VAR { VAR, ...VAR } = VAR; VAR VAR = { VAR, VAR: VAR.VAR(""/"")[1], VAR: VAR, VAR: VAR(VAR.VAR), VAR: VAR.VAR(VAR), }; VAR VAR = VAR VAR.VAR( VAR.VAR, { ...VAR, VAR }, VAR ); VAR (!VAR) { VAR.VAR(""VAR VAR VAR"", VAR); VAR; } VAR.VAR([ VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, ]); } VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR, VAR, VAR) VAR (?,?,?,?,?)` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR(VAR); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR VAR.VAR(""VAR"", { VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR.VAR.VAR || ""VAR"", }); VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR VAR = VAR(); VAR VAR = []; VAR (VAR.VAR === 0) VAR; VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR.VAR( `VAR = '${VAR}' VAR VAR = ${VAR.VAR}` ); VAR (!VAR) VAR; VAR VAR.VAR( VAR.VAR, VAR.VAR ); VAR.VAR([VAR, VAR.VAR]); } VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} VAR VAR = ? VAR VAR = ?` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR(VAR); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR VAR.VAR(""VAR"", { VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR.VAR.VAR || ""VAR"", }); VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/documents.js,"const { fileData } = require(""../utils/files"");
const { v4: uuidv4 } = require(""uuid"");
const { getVectorDbClass } = require(""../utils/helpers"");
const { checkForMigrations } = require(""../utils/database"");
const { Telemetry } = require(""./telemetry"");

const Document = {
  tablename: ""workspace_documents"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  docId TEXT NOT NULL UNIQUE,
  filename TEXT NOT NULL,
  docpath TEXT NOT NULL,
  workspaceId INTEGER NOT NULL,
  metadata TEXT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for Document migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  forWorkspace: async function (workspaceId = null) {
    if (!workspaceId) return [];
    return await this.where(`workspaceId = ${workspaceId}`);
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();
    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );

    db.close();
    return results;
  },
  firstWhere: async function (clause = """") {
    const results = await this.where(clause);
    return results.length > 0 ? results[0] : null;
  },
  addDocuments: async function (workspace, additions = []) {
    const VectorDb = getVectorDbClass();
    if (additions.length === 0) return;
    const insertParams = [];

    for (const path of additions) {
      const data = await fileData(path);
      if (!data) continue;

      const docId = uuidv4();
      const { pageContent, ...metadata } = data;
      const newDoc = {
        docId,
        filename: path.split(""/"")[1],
        docpath: path,
        workspaceId: Number(workspace.id),
        metadata: JSON.stringify(metadata),
      };
      const vectorized = await VectorDb.addDocumentToNamespace(
        workspace.slug,
        { ...data, docId },
        path
      );
      if (!vectorized) {
        console.error(""Failed to vectorize"", path);
        continue;
      }

      insertParams.push([
        docId,
        newDoc.filename,
        newDoc.docpath,
        newDoc.workspaceId,
        newDoc.metadata,
      ]);
    }

    const db = await this.db();
    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (docId, filename, docpath, workspaceId, metadata) VALUES (?,?,?,?,?)`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const params of insertParams) {
        await stmt.run(params);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    await Telemetry.sendTelemetry(""documents_embedded_in_workspace"", {
      LLMSelection: process.env.LLM_PROVIDER || ""openai"",
      VectorDbSelection: process.env.VECTOR_DB || ""pinecone"",
    });
    return;
  },
  removeDocuments: async function (workspace, removals = []) {
    const VectorDb = getVectorDbClass();
    const deleteParams = [];
    if (removals.length === 0) return;

    for (const path of removals) {
      const document = await this.firstWhere(
        `docPath = '${path}' AND workspaceId = ${workspace.id}`
      );
      if (!document) continue;
      await VectorDb.deleteDocumentFromNamespace(
        workspace.slug,
        document.docId
      );
      deleteParams.push([path, workspace.id]);
    }

    const db = await this.db();
    const stmt = await db.prepare(
      `DELETE FROM ${this.tablename} WHERE docpath = ? AND workspaceId = ?`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const params of deleteParams) {
        await stmt.run(params);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    await Telemetry.sendTelemetry(""documents_removed_in_workspace"", {
      LLMSelection: process.env.LLM_PROVIDER || ""openai"",
      VectorDbSelection: process.env.VECTOR_DB || ""pinecone"",
    });
    return true;
  },
};

module.exports = { Document };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR: VAR } = VAR(""VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""./VAR""); VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR (!VAR) VAR []; VAR VAR VAR.VAR(`VAR = ${VAR}`); }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(VAR); VAR VAR.VAR > 0 ? VAR[0] : VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR VAR = VAR(); VAR (VAR.VAR === 0) VAR; VAR VAR = []; VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR(VAR); VAR (!VAR) VAR; VAR VAR = VAR(); VAR { VAR, ...VAR } = VAR; VAR VAR = { VAR, VAR: VAR.VAR(""/"")[1], VAR: VAR, VAR: VAR(VAR.VAR), VAR: VAR.VAR(VAR), }; VAR VAR = VAR VAR.VAR( VAR.VAR, { ...VAR, VAR }, VAR ); VAR (!VAR) { VAR.VAR(""VAR VAR VAR"", VAR); VAR; } VAR.VAR([ VAR, VAR.VAR, VAR.VAR, VAR.VAR, VAR.VAR, ]); } VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR, VAR, VAR) VAR (?,?,?,?,?)` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR(VAR); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR VAR.VAR(""VAR"", { VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR.VAR.VAR || ""VAR"", }); VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR VAR = VAR(); VAR VAR = []; VAR (VAR.VAR === 0) VAR; VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR.VAR( `VAR = '${VAR}' VAR VAR = ${VAR.VAR}` ); VAR (!VAR) VAR; VAR VAR.VAR( VAR.VAR, VAR.VAR ); VAR.VAR([VAR, VAR.VAR]); } VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} VAR VAR = ? VAR VAR = ?` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR(VAR); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR VAR.VAR(""VAR"", { VAR: VAR.VAR.VAR || ""VAR"", VAR: VAR.VAR.VAR || ""VAR"", }); VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/invite.js,"const { escape } = require(""sqlstring-sqlite"");

const Invite = {
  tablename: ""invites"",
  writable: [],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  code TEXT UNIQUE NOT NULL,
  status TEXT NOT NULL DEFAULT ""pending"",
  claimedBy INTEGER DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  createdBy INTEGER NOT NULL,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for Invites migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  makeCode: () => {
    const uuidAPIKey = require(""uuid-apikey"");
    return uuidAPIKey.create().apiKey;
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  create: async function (createdByUserId = 0) {
    const db = await this.db();
    const { id, success, message } = await db
      .run(`INSERT INTO ${this.tablename} (code, createdBy) VALUES(?, ?)`, [
        this.makeCode(),
        createdByUserId,
      ])
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE USER."", message);
      return { invite: null, error: message };
    }

    const invite = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id} `
    );
    db.close();

    return { invite, error: null };
  },
  deactivate: async function (inviteId = null) {
    const invite = await this.get(`id = ${escape(inviteId)}`);
    if (!invite) return { success: false, error: ""Invite does not exist."" };
    if (invite.status !== ""pending"")
      return { success: false, error: ""Invite is not in pending status."" };

    const db = await this.db();
    const { success, message } = await db
      .run(`UPDATE ${this.tablename} SET status=? WHERE id=?`, [
        ""disabled"",
        inviteId,
      ])
      .then(() => {
        return { success: true, message: null };
      })
      .catch((error) => {
        return { success: false, message: error.message };
      });

    db.close();
    if (!success) {
      console.error(message);
      return { success: false, error: message };
    }

    return { success: true, error: null };
  },
  markClaimed: async function (inviteId = null, user) {
    const invite = await this.get(`id = ${escape(inviteId)}`);
    if (!invite) return { success: false, error: ""Invite does not exist."" };
    if (invite.status !== ""pending"")
      return { success: false, error: ""Invite is not in pending status."" };

    const db = await this.db();
    const { success, message } = await db
      .run(`UPDATE ${this.tablename} SET status=?,claimedBy=? WHERE id=?`, [
        ""claimed"",
        user.id,
        inviteId,
      ])
      .then(() => {
        return { success: true, message: null };
      })
      .catch((error) => {
        return { success: false, message: error.message };
      });

    db.close();
    if (!success) {
      console.error(message);
      return { success: false, error: message };
    }

    return { success: true, error: null };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();
    return { ...result };
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  whereWithUsers: async function (clause = """", limit = null) {
    const { User } = require(""./user"");
    const results = await this.where(clause, limit);
    for (const invite of results) {
      if (!!invite.claimedBy) {
        const acceptedUser = await User.get(`id = ${invite.claimedBy}`);
        invite.claimedBy = {
          id: acceptedUser?.id,
          username: acceptedUser?.username,
        };
      }

      if (!!invite.createdBy) {
        const createdUser = await User.get(`id = ${invite.createdBy}`);
        invite.createdBy = {
          id: createdUser?.id,
          username: createdUser?.username,
        };
      }
    }
    return results;
  },
};

module.exports.Invite = Invite;",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR-VAR""); VAR VAR = { VAR: ""VAR"", VAR: [], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR ""VAR"", VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: () => { VAR VAR = VAR(""VAR-VAR""); VAR VAR.VAR().VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = 0) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR(?, ?)`, [ VAR.VAR(), VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR."", VAR); VAR { VAR: VAR, VAR: VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR} ` ); VAR.VAR(); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR."" }; VAR (VAR.VAR !== ""VAR"") VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."" }; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(`VAR ${VAR.VAR} VAR VAR=? VAR VAR=?`, [ ""VAR"", VAR, ]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR }; } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR, VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR."" }; VAR (VAR.VAR !== ""VAR"") VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."" }; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(`VAR ${VAR.VAR} VAR VAR=?,VAR=? VAR VAR=?`, [ ""VAR"", VAR.VAR, VAR, ]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR }; } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR { ...VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR { VAR } = VAR(""./VAR""); VAR VAR = VAR VAR.VAR(VAR, VAR); VAR (VAR VAR VAR VAR) { VAR (!!VAR.VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = { VAR: VAR?.VAR, VAR: VAR?.VAR, }; } VAR (!!VAR.VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = { VAR: VAR?.VAR, VAR: VAR?.VAR, }; } } VAR VAR; }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/invite.js,"const { escape } = require(""sqlstring-sqlite"");

const Invite = {
  tablename: ""invites"",
  writable: [],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  code TEXT UNIQUE NOT NULL,
  status TEXT NOT NULL DEFAULT ""pending"",
  claimedBy INTEGER DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  createdBy INTEGER NOT NULL,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for Invites migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  makeCode: () => {
    const uuidAPIKey = require(""uuid-apikey"");
    return uuidAPIKey.create().apiKey;
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  create: async function (createdByUserId = 0) {
    const db = await this.db();
    const { id, success, message } = await db
      .run(`INSERT INTO ${this.tablename} (code, createdBy) VALUES(?, ?)`, [
        this.makeCode(),
        createdByUserId,
      ])
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE USER."", message);
      return { invite: null, error: message };
    }

    const invite = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id} `
    );
    db.close();

    return { invite, error: null };
  },
  deactivate: async function (inviteId = null) {
    const invite = await this.get(`id = ${escape(inviteId)}`);
    if (!invite) return { success: false, error: ""Invite does not exist."" };
    if (invite.status !== ""pending"")
      return { success: false, error: ""Invite is not in pending status."" };

    const db = await this.db();
    const { success, message } = await db
      .run(`UPDATE ${this.tablename} SET status=? WHERE id=?`, [
        ""disabled"",
        inviteId,
      ])
      .then(() => {
        return { success: true, message: null };
      })
      .catch((error) => {
        return { success: false, message: error.message };
      });

    db.close();
    if (!success) {
      console.error(message);
      return { success: false, error: message };
    }

    return { success: true, error: null };
  },
  markClaimed: async function (inviteId = null, user) {
    const invite = await this.get(`id = ${escape(inviteId)}`);
    if (!invite) return { success: false, error: ""Invite does not exist."" };
    if (invite.status !== ""pending"")
      return { success: false, error: ""Invite is not in pending status."" };

    const db = await this.db();
    const { success, message } = await db
      .run(`UPDATE ${this.tablename} SET status=?,claimedBy=? WHERE id=?`, [
        ""claimed"",
        user.id,
        inviteId,
      ])
      .then(() => {
        return { success: true, message: null };
      })
      .catch((error) => {
        return { success: false, message: error.message };
      });

    db.close();
    if (!success) {
      console.error(message);
      return { success: false, error: message };
    }

    return { success: true, error: null };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();
    return { ...result };
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  whereWithUsers: async function (clause = """", limit = null) {
    const { User } = require(""./user"");
    const results = await this.where(clause, limit);
    for (const invite of results) {
      if (!!invite.claimedBy) {
        const acceptedUser = await User.get(`id = ${invite.claimedBy}`);
        invite.claimedBy = {
          id: acceptedUser?.id,
          username: acceptedUser?.username,
        };
      }

      if (!!invite.createdBy) {
        const createdUser = await User.get(`id = ${invite.createdBy}`);
        invite.createdBy = {
          id: createdUser?.id,
          username: createdUser?.username,
        };
      }
    }
    return results;
  },
};

module.exports.Invite = Invite;",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR-VAR""); VAR VAR = { VAR: ""VAR"", VAR: [], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR ""VAR"", VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: () => { VAR VAR = VAR(""VAR-VAR""); VAR VAR.VAR().VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = 0) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR(?, ?)`, [ VAR.VAR(), VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR."", VAR); VAR { VAR: VAR, VAR: VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR} ` ); VAR.VAR(); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR."" }; VAR (VAR.VAR !== ""VAR"") VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."" }; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(`VAR ${VAR.VAR} VAR VAR=? VAR VAR=?`, [ ""VAR"", VAR, ]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR }; } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = VAR, VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR."" }; VAR (VAR.VAR !== ""VAR"") VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR VAR VAR."" }; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(`VAR ${VAR.VAR} VAR VAR=?,VAR=? VAR VAR=?`, [ ""VAR"", VAR.VAR, VAR, ]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR }; } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR { ...VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR { VAR } = VAR(""./VAR""); VAR VAR = VAR VAR.VAR(VAR, VAR); VAR (VAR VAR VAR VAR) { VAR (!!VAR.VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = { VAR: VAR?.VAR, VAR: VAR?.VAR, }; } VAR (!!VAR.VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = { VAR: VAR?.VAR, VAR: VAR?.VAR, }; } } VAR VAR; }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/systemSettings.js,"process.env.NODE_ENV === ""development""
  ? require(""dotenv"").config({ path: `.env.${process.env.NODE_ENV}` })
  : require(""dotenv"").config();

const SystemSettings = {
  supportedFields: [
    ""multi_user_mode"",
    ""users_can_delete_workspaces"",
    ""limit_user_messages"",
    ""message_limit"",
    ""logo_filename"",
    ""telemetry_id"",
  ],
  privateField: [],
  tablename: ""system_settings"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  label TEXT UNIQUE NOT NULL,
  value TEXT,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for System Setting migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  currentSettings: async function () {
    const llmProvider = process.env.LLM_PROVIDER || ""openai"";
    const vectorDB = process.env.VECTOR_DB || ""pinecone"";
    return {
      CanDebug: !!!process.env.NO_DEBUG,
      RequiresAuth: !!process.env.AUTH_TOKEN,
      AuthToken: !!process.env.AUTH_TOKEN,
      JWTSecret: !!process.env.JWT_SECRET,
      StorageDir: process.env.STORAGE_DIR,
      MultiUserMode: await this.isMultiUserMode(),
      VectorDB: vectorDB,
      ...(vectorDB === ""pinecone""
        ? {
            PineConeEnvironment: process.env.PINECONE_ENVIRONMENT,
            PineConeKey: !!process.env.PINECONE_API_KEY,
            PineConeIndex: process.env.PINECONE_INDEX,
          }
        : {}),
      ...(vectorDB === ""chroma""
        ? {
            ChromaEndpoint: process.env.CHROMA_ENDPOINT,
          }
        : {}),
      ...(vectorDB === ""weaviate""
        ? {
            WeaviateEndpoint: process.env.WEAVIATE_ENDPOINT,
            WeaviateApiKey: process.env.WEAVIATE_API_KEY,
          }
        : {}),
      ...(vectorDB === ""qdrant""
        ? {
            QdrantEndpoint: process.env.QDRANT_ENDPOINT,
            QdrantApiKey: process.env.QDRANT_API_KEY,
          }
        : {}),
      LLMProvider: llmProvider,
      ...(llmProvider === ""openai""
        ? {
            OpenAiKey: !!process.env.OPEN_AI_KEY,
            OpenAiModelPref: process.env.OPEN_MODEL_PREF || ""gpt-3.5-turbo"",
          }
        : {}),

      ...(llmProvider === ""azure""
        ? {
            AzureOpenAiEndpoint: process.env.AZURE_OPENAI_ENDPOINT,
            AzureOpenAiKey: !!process.env.AZURE_OPENAI_KEY,
            AzureOpenAiModelPref: process.env.OPEN_MODEL_PREF,
            AzureOpenAiEmbeddingModelPref: process.env.EMBEDDING_MODEL_PREF,
          }
        : {}),
    };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    return result;
  },
  where: async function (clause = null, limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  updateSettings: async function (updates = {}) {
    const validConfigKeys = Object.keys(updates).filter((key) =>
      this.supportedFields.includes(key)
    );
    for (const key of validConfigKeys) {
      const existingRecord = await this.get(`label = '${key}'`);
      if (!existingRecord) {
        const db = await this.db();
        const value = updates[key] === null ? null : String(updates[key]);
        const { success, message } = await db
          .run(`INSERT INTO ${this.tablename} (label, value) VALUES (?, ?)`, [
            key,
            value,
          ])
          .then((res) => {
            return { id: res.lastID, success: true, message: null };
          })
          .catch((error) => {
            return { id: null, success: false, message: error.message };
          });
        db.close();
        if (!success) {
          console.error(""FAILED TO ADD SYSTEM CONFIG OPTION"", message);
          return { success: false, error: message };
        }
      } else {
        const db = await this.db();
        const value = updates[key] === null ? null : String(updates[key]);
        const { success, message } = await db
          .run(`UPDATE ${this.tablename} SET label=?,value=? WHERE id = ?`, [
            key,
            value,
            existingRecord.id,
          ])
          .then(() => {
            return { success: true, message: null };
          })
          .catch((error) => {
            return { success: false, message: error.message };
          });

        db.close();
        if (!success) {
          console.error(""FAILED TO UPDATE SYSTEM CONFIG OPTION"", message);
          return { success: false, error: message };
        }
      }
    }
    return { success: true, error: null };
  },
  isMultiUserMode: async function () {
    return (await this.get(`label = 'multi_user_mode'`))?.value === ""true"";
  },
  currentLogoFilename: async function () {
    const result = await this.get(`label = 'logo_filename'`);
    return result ? result.value : null;
  },
  canDeleteWorkspaces: async function () {
    return (
      (await this.get(`label = 'users_can_delete_workspaces'`))?.value ===
      ""true""
    );
  },
};

module.exports.SystemSettings = SystemSettings;",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR.VAR.VAR === ""VAR"" ? VAR(""VAR"").VAR({ VAR: `.VAR.${VAR.VAR.VAR}` }) : VAR(""VAR"").VAR(); VAR VAR = { VAR: [ ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ], VAR: [], VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR () { VAR VAR = VAR.VAR.VAR || ""VAR""; VAR VAR = VAR.VAR.VAR || ""VAR""; VAR { VAR: !!!VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR, VAR: VAR VAR.VAR(), VAR: VAR, ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), VAR: VAR, ...(VAR === ""VAR"" ? { VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR || ""VAR-3.5-VAR"", } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = {}) { VAR VAR = VAR.VAR(VAR).VAR((VAR) => VAR.VAR.VAR(VAR) ); VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR.VAR(`VAR = '${VAR}'`); VAR (!VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR[VAR] === VAR ? VAR : VAR(VAR[VAR]); VAR { VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?, ?)`, [ VAR, VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(""VAR VAR VAR VAR VAR VAR"", VAR); VAR { VAR: VAR, VAR: VAR }; } } VAR { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR[VAR] === VAR ? VAR : VAR(VAR[VAR]); VAR { VAR, VAR } = VAR VAR .VAR(`VAR ${VAR.VAR} VAR VAR=?,VAR=? VAR VAR = ?`, [ VAR, VAR, VAR.VAR, ]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(""VAR VAR VAR VAR VAR VAR"", VAR); VAR { VAR: VAR, VAR: VAR }; } } } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR () { VAR (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR === ""VAR""; }, VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(`VAR = 'VAR'`); VAR VAR ? VAR.VAR : VAR; }, VAR: VAR VAR () { VAR ( (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR === ""VAR"" ); }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/systemSettings.js,"process.env.NODE_ENV === ""development""
  ? require(""dotenv"").config({ path: `.env.${process.env.NODE_ENV}` })
  : require(""dotenv"").config();

const SystemSettings = {
  supportedFields: [
    ""multi_user_mode"",
    ""users_can_delete_workspaces"",
    ""limit_user_messages"",
    ""message_limit"",
    ""logo_filename"",
    ""telemetry_id"",
  ],
  privateField: [],
  tablename: ""system_settings"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  label TEXT UNIQUE NOT NULL,
  value TEXT,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for System Setting migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  currentSettings: async function () {
    const llmProvider = process.env.LLM_PROVIDER || ""openai"";
    const vectorDB = process.env.VECTOR_DB || ""pinecone"";
    return {
      CanDebug: !!!process.env.NO_DEBUG,
      RequiresAuth: !!process.env.AUTH_TOKEN,
      AuthToken: !!process.env.AUTH_TOKEN,
      JWTSecret: !!process.env.JWT_SECRET,
      StorageDir: process.env.STORAGE_DIR,
      MultiUserMode: await this.isMultiUserMode(),
      VectorDB: vectorDB,
      ...(vectorDB === ""pinecone""
        ? {
            PineConeEnvironment: process.env.PINECONE_ENVIRONMENT,
            PineConeKey: !!process.env.PINECONE_API_KEY,
            PineConeIndex: process.env.PINECONE_INDEX,
          }
        : {}),
      ...(vectorDB === ""chroma""
        ? {
            ChromaEndpoint: process.env.CHROMA_ENDPOINT,
          }
        : {}),
      ...(vectorDB === ""weaviate""
        ? {
            WeaviateEndpoint: process.env.WEAVIATE_ENDPOINT,
            WeaviateApiKey: process.env.WEAVIATE_API_KEY,
          }
        : {}),
      ...(vectorDB === ""qdrant""
        ? {
            QdrantEndpoint: process.env.QDRANT_ENDPOINT,
            QdrantApiKey: process.env.QDRANT_API_KEY,
          }
        : {}),
      LLMProvider: llmProvider,
      ...(llmProvider === ""openai""
        ? {
            OpenAiKey: !!process.env.OPEN_AI_KEY,
            OpenAiModelPref: process.env.OPEN_MODEL_PREF || ""gpt-3.5-turbo"",
          }
        : {}),

      ...(llmProvider === ""azure""
        ? {
            AzureOpenAiEndpoint: process.env.AZURE_OPENAI_ENDPOINT,
            AzureOpenAiKey: !!process.env.AZURE_OPENAI_KEY,
            AzureOpenAiModelPref: process.env.OPEN_MODEL_PREF,
            AzureOpenAiEmbeddingModelPref: process.env.EMBEDDING_MODEL_PREF,
          }
        : {}),
    };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    return result;
  },
  where: async function (clause = null, limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  updateSettings: async function (updates = {}) {
    const validConfigKeys = Object.keys(updates).filter((key) =>
      this.supportedFields.includes(key)
    );
    for (const key of validConfigKeys) {
      const existingRecord = await this.get(`label = '${key}'`);
      if (!existingRecord) {
        const db = await this.db();
        const value = updates[key] === null ? null : String(updates[key]);
        const { success, message } = await db
          .run(`INSERT INTO ${this.tablename} (label, value) VALUES (?, ?)`, [
            key,
            value,
          ])
          .then((res) => {
            return { id: res.lastID, success: true, message: null };
          })
          .catch((error) => {
            return { id: null, success: false, message: error.message };
          });
        db.close();
        if (!success) {
          console.error(""FAILED TO ADD SYSTEM CONFIG OPTION"", message);
          return { success: false, error: message };
        }
      } else {
        const db = await this.db();
        const value = updates[key] === null ? null : String(updates[key]);
        const { success, message } = await db
          .run(`UPDATE ${this.tablename} SET label=?,value=? WHERE id = ?`, [
            key,
            value,
            existingRecord.id,
          ])
          .then(() => {
            return { success: true, message: null };
          })
          .catch((error) => {
            return { success: false, message: error.message };
          });

        db.close();
        if (!success) {
          console.error(""FAILED TO UPDATE SYSTEM CONFIG OPTION"", message);
          return { success: false, error: message };
        }
      }
    }
    return { success: true, error: null };
  },
  isMultiUserMode: async function () {
    return (await this.get(`label = 'multi_user_mode'`))?.value === ""true"";
  },
  currentLogoFilename: async function () {
    const result = await this.get(`label = 'logo_filename'`);
    return result ? result.value : null;
  },
  canDeleteWorkspaces: async function () {
    return (
      (await this.get(`label = 'users_can_delete_workspaces'`))?.value ===
      ""true""
    );
  },
};

module.exports.SystemSettings = SystemSettings;",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR.VAR.VAR === ""VAR"" ? VAR(""VAR"").VAR({ VAR: `.VAR.${VAR.VAR.VAR}` }) : VAR(""VAR"").VAR(); VAR VAR = { VAR: [ ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ""VAR"", ], VAR: [], VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR () { VAR VAR = VAR.VAR.VAR || ""VAR""; VAR VAR = VAR.VAR.VAR || ""VAR""; VAR { VAR: !!!VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR, VAR: VAR VAR.VAR(), VAR: VAR, ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), VAR: VAR, ...(VAR === ""VAR"" ? { VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR || ""VAR-3.5-VAR"", } : {}), ...(VAR === ""VAR"" ? { VAR: VAR.VAR.VAR, VAR: !!VAR.VAR.VAR, VAR: VAR.VAR.VAR, VAR: VAR.VAR.VAR, } : {}), }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = {}) { VAR VAR = VAR.VAR(VAR).VAR((VAR) => VAR.VAR.VAR(VAR) ); VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR.VAR(`VAR = '${VAR}'`); VAR (!VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR[VAR] === VAR ? VAR : VAR(VAR[VAR]); VAR { VAR, VAR } = VAR VAR .VAR(`VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?, ?)`, [ VAR, VAR, ]) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(""VAR VAR VAR VAR VAR VAR"", VAR); VAR { VAR: VAR, VAR: VAR }; } } VAR { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR[VAR] === VAR ? VAR : VAR(VAR[VAR]); VAR { VAR, VAR } = VAR VAR .VAR(`VAR ${VAR.VAR} VAR VAR=?,VAR=? VAR VAR = ?`, [ VAR, VAR, VAR.VAR, ]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(""VAR VAR VAR VAR VAR VAR"", VAR); VAR { VAR: VAR, VAR: VAR }; } } } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR () { VAR (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR === ""VAR""; }, VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(`VAR = 'VAR'`); VAR VAR ? VAR.VAR : VAR; }, VAR: VAR VAR () { VAR ( (VAR VAR.VAR(`VAR = 'VAR'`))?.VAR === ""VAR"" ); }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/telemetry.js,"const { v4 } = require(""uuid"");
const { SystemSettings } = require(""./systemSettings"");

const Telemetry = {
  // Write-only key. It can't read events or any of your other data, so it's safe to use in public apps.
  pubkey: ""phc_9qu7QLpV8L84P3vFmEiZxL020t2EqIubP7HHHxrSsqS"",
  stubDevelopmentEvents: true, // [DO NOT TOUCH] Core team only.
  label: ""telemetry_id"",
  id: async function () {
    const result = await SystemSettings.get(`label = '${this.label}'`);
    if (!!result?.value) return result.value;
    return result?.value;
  },
  connect: async function () {
    const client = this.client();
    const distinctId = await this.findOrCreateId();
    return { client, distinctId };
  },
  isDev: function () {
    if (process.env.NODE_ENV === ""development"")
      return this.stubDevelopmentEvents;
    return false;
  },
  client: function () {
    if (process.env.DISABLE_TELEMETRY === ""true"" || this.isDev()) return null;
    const { PostHog } = require(""posthog-node"");
    return new PostHog(this.pubkey);
  },
  sendTelemetry: async function (event, properties = {}) {
    try {
      const { client, distinctId } = await this.connect();
      if (!client) return;
      console.log(`\x1b[32m[TELEMETRY SENT]\x1b[0m`, {
        event,
        properties,
      });
      client.capture({
        event,
        distinctId,
        properties,
      });
    } catch {
      return;
    }
  },
  flush: async function () {
    const { client } = this.client();
    if (!client) return;
    await client.shutdownAsync();
    return;
  },
  setUid: async function () {
    const newId = v4();
    await SystemSettings.updateSettings({ [this.label]: newId });
    return newId;
  },
  findOrCreateId: async function () {
    const currentId = await this.id();
    if (!!currentId) return currentId;
    const newId = await this.setUid();
    return newId;
  },
};

module.exports = { Telemetry };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR""); VAR { VAR } = VAR(""./VAR""); VAR VAR = {  VAR: ""VAR"", VAR: VAR,  VAR: ""VAR"", VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(`VAR = '${VAR.VAR}'`); VAR (!!VAR?.VAR) VAR VAR.VAR; VAR VAR?.VAR; }, VAR: VAR VAR () { VAR VAR = VAR.VAR(); VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR }; }, VAR: VAR () { VAR (VAR.VAR.VAR === ""VAR"") VAR VAR.VAR; VAR VAR; }, VAR: VAR () { VAR (VAR.VAR.VAR === ""VAR"" || VAR.VAR()) VAR VAR; VAR { VAR } = VAR(""VAR-VAR""); VAR VAR VAR(VAR.VAR); }, VAR: VAR VAR (VAR, VAR = {}) { VAR { VAR { VAR, VAR } = VAR VAR.VAR(); VAR (!VAR) VAR; VAR.VAR(`\VAR[32m[VAR VAR]\VAR[0m`, { VAR, VAR, }); VAR.VAR({ VAR, VAR, VAR, }); } VAR { VAR; } }, VAR: VAR VAR () { VAR { VAR } = VAR.VAR(); VAR (!VAR) VAR; VAR VAR.VAR(); VAR; }, VAR: VAR VAR () { VAR VAR = VAR(); VAR VAR.VAR({ [VAR.VAR]: VAR }); VAR VAR; }, VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(); VAR (!!VAR) VAR VAR; VAR VAR = VAR VAR.VAR(); VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/telemetry.js,"const { v4 } = require(""uuid"");
const { SystemSettings } = require(""./systemSettings"");

const Telemetry = {
  // Write-only key. It can't read events or any of your other data, so it's safe to use in public apps.
  pubkey: ""phc_9qu7QLpV8L84P3vFmEiZxL020t2EqIubP7HHHxrSsqS"",
  stubDevelopmentEvents: true, // [DO NOT TOUCH] Core team only.
  label: ""telemetry_id"",
  id: async function () {
    const result = await SystemSettings.get(`label = '${this.label}'`);
    if (!!result?.value) return result.value;
    return result?.value;
  },
  connect: async function () {
    const client = this.client();
    const distinctId = await this.findOrCreateId();
    return { client, distinctId };
  },
  isDev: function () {
    if (process.env.NODE_ENV === ""development"")
      return this.stubDevelopmentEvents;
    return false;
  },
  client: function () {
    if (process.env.DISABLE_TELEMETRY === ""true"" || this.isDev()) return null;
    const { PostHog } = require(""posthog-node"");
    return new PostHog(this.pubkey);
  },
  sendTelemetry: async function (event, properties = {}) {
    try {
      const { client, distinctId } = await this.connect();
      if (!client) return;
      console.log(`\x1b[32m[TELEMETRY SENT]\x1b[0m`, {
        event,
        properties,
      });
      client.capture({
        event,
        distinctId,
        properties,
      });
    } catch {
      return;
    }
  },
  flush: async function () {
    const { client } = this.client();
    if (!client) return;
    await client.shutdownAsync();
    return;
  },
  setUid: async function () {
    const newId = v4();
    await SystemSettings.updateSettings({ [this.label]: newId });
    return newId;
  },
  findOrCreateId: async function () {
    const currentId = await this.id();
    if (!!currentId) return currentId;
    const newId = await this.setUid();
    return newId;
  },
};

module.exports = { Telemetry };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR""); VAR { VAR } = VAR(""./VAR""); VAR VAR = {  VAR: ""VAR"", VAR: VAR,  VAR: ""VAR"", VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(`VAR = '${VAR.VAR}'`); VAR (!!VAR?.VAR) VAR VAR.VAR; VAR VAR?.VAR; }, VAR: VAR VAR () { VAR VAR = VAR.VAR(); VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR }; }, VAR: VAR () { VAR (VAR.VAR.VAR === ""VAR"") VAR VAR.VAR; VAR VAR; }, VAR: VAR () { VAR (VAR.VAR.VAR === ""VAR"" || VAR.VAR()) VAR VAR; VAR { VAR } = VAR(""VAR-VAR""); VAR VAR VAR(VAR.VAR); }, VAR: VAR VAR (VAR, VAR = {}) { VAR { VAR { VAR, VAR } = VAR VAR.VAR(); VAR (!VAR) VAR; VAR.VAR(`\VAR[32m[VAR VAR]\VAR[0m`, { VAR, VAR, }); VAR.VAR({ VAR, VAR, VAR, }); } VAR { VAR; } }, VAR: VAR VAR () { VAR { VAR } = VAR.VAR(); VAR (!VAR) VAR; VAR VAR.VAR(); VAR; }, VAR: VAR VAR () { VAR VAR = VAR(); VAR VAR.VAR({ [VAR.VAR]: VAR }); VAR VAR; }, VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(); VAR (!!VAR) VAR VAR; VAR VAR = VAR VAR.VAR(); VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/user.js,"const { escape } = require(""sqlstring-sqlite"");

const User = {
  tablename: ""users"",
  writable: [],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE,
  password TEXT NOT NULL,
  role TEXT NOT NULL DEFAULT ""default"",
  suspended INTEGER NOT NULL DEFAULT 0,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for User migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  create: async function ({ username, password, role = null }) {
    const bcrypt = require(""bcrypt"");
    const db = await this.db();
    const { id, success, message } = await db
      .run(
        `INSERT INTO ${this.tablename} (username, password, role) VALUES(?, ?, ?)`,
        [username, bcrypt.hashSync(password, 10), role ?? ""default""]
      )
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE USER."", message);
      return { user: null, error: message };
    }

    const user = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id} `
    );
    db.close();

    return { user, error: null };
  },
  update: async function (userId, updates = {}) {
    const user = await this.get(`id = ${escape(userId)}`);
    if (!user) return { success: false, error: ""User does not exist."" };
    const { username, password, role, suspended = 0 } = updates;
    const toUpdate = { suspended };

    if (user.username !== username && username?.length > 0) {
      const usedUsername = !!(await this.get(`username = ${escape(username)}`));
      if (usedUsername)
        return { success: false, error: `${username} is already in use.` };
      toUpdate.username = username;
    }

    if (!!password) {
      const bcrypt = require(""bcrypt"");
      toUpdate.password = bcrypt.hashSync(password, 10);
    }

    if (user.role !== role && [""admin"", ""default""].includes(role)) {
      // If was existing admin and that has been changed
      // make sure at least one admin exists
      if (user.role === ""admin"") {
        const validAdminCount = (await this.count(`role = 'admin'`)) > 1;
        if (!validAdminCount)
          return {
            success: false,
            error: `There would be no admins if this action was completed. There must be at least one admin.`,
          };
      }

      toUpdate.role = role;
    }

    if (Object.keys(toUpdate).length !== 0) {
      const values = Object.values(toUpdate);
      const template = `UPDATE ${this.tablename} SET ${Object.keys(
        toUpdate
      ).map((key) => {
        return `${key}=?`;
      })} WHERE id = ?`;

      const db = await this.db();
      const { success, message } = await db
        .run(template, [...values, userId])
        .then(() => {
          return { success: true, message: null };
        })
        .catch((error) => {
          return { success: false, message: error.message };
        });

      db.close();
      if (!success) {
        console.error(message);
        return { success: false, error: message };
      }
    }

    return { success: true, error: null };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();
    return { ...result };
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
};

module.exports = { User };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR-VAR""); VAR VAR = { VAR: ""VAR"", VAR: [], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR ""VAR"", VAR VAR VAR VAR VAR 0, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR ({ VAR, VAR, VAR = VAR }) { VAR VAR = VAR(""VAR""); VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR) VAR(?, ?, ?)`, [VAR, VAR.VAR(VAR, 10), VAR ?? ""VAR""] ) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR."", VAR); VAR { VAR: VAR, VAR: VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR} ` ); VAR.VAR(); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR, VAR = {}) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR."" }; VAR { VAR, VAR, VAR, VAR = 0 } = VAR; VAR VAR = { VAR }; VAR (VAR.VAR !== VAR && VAR?.VAR > 0) { VAR VAR = !!(VAR VAR.VAR(`VAR = ${VAR(VAR)}`)); VAR (VAR) VAR { VAR: VAR, VAR: `${VAR} VAR VAR VAR VAR.` }; VAR.VAR = VAR; } VAR (!!VAR) { VAR VAR = VAR(""VAR""); VAR.VAR = VAR.VAR(VAR, 10); } VAR (VAR.VAR !== VAR && [""VAR"", ""VAR""].VAR(VAR)) {   VAR (VAR.VAR === ""VAR"") { VAR VAR = (VAR VAR.VAR(`VAR = 'VAR'`)) > 1; VAR (!VAR) VAR { VAR: VAR, VAR: `VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR.`, }; } VAR.VAR = VAR; } VAR (VAR.VAR(VAR).VAR !== 0) { VAR VAR = VAR.VAR(VAR); VAR VAR = `VAR ${VAR.VAR} VAR ${VAR.VAR( VAR ).VAR((VAR) => { VAR `${VAR}=?`; })} VAR VAR = ?`; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(VAR, [...VAR, VAR]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR }; } } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR { ...VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, }; VAR.VAR = { VAR }; ",4,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/user.js,"const { escape } = require(""sqlstring-sqlite"");

const User = {
  tablename: ""users"",
  writable: [],
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT UNIQUE,
  password TEXT NOT NULL,
  role TEXT NOT NULL DEFAULT ""default"",
  suspended INTEGER NOT NULL DEFAULT 0,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(`\x1b[34m[MIGRATING]\x1b[0m Checking for User migrations`);
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  create: async function ({ username, password, role = null }) {
    const bcrypt = require(""bcrypt"");
    const db = await this.db();
    const { id, success, message } = await db
      .run(
        `INSERT INTO ${this.tablename} (username, password, role) VALUES(?, ?, ?)`,
        [username, bcrypt.hashSync(password, 10), role ?? ""default""]
      )
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE USER."", message);
      return { user: null, error: message };
    }

    const user = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id} `
    );
    db.close();

    return { user, error: null };
  },
  update: async function (userId, updates = {}) {
    const user = await this.get(`id = ${escape(userId)}`);
    if (!user) return { success: false, error: ""User does not exist."" };
    const { username, password, role, suspended = 0 } = updates;
    const toUpdate = { suspended };

    if (user.username !== username && username?.length > 0) {
      const usedUsername = !!(await this.get(`username = ${escape(username)}`));
      if (usedUsername)
        return { success: false, error: `${username} is already in use.` };
      toUpdate.username = username;
    }

    if (!!password) {
      const bcrypt = require(""bcrypt"");
      toUpdate.password = bcrypt.hashSync(password, 10);
    }

    if (user.role !== role && [""admin"", ""default""].includes(role)) {
      // If was existing admin and that has been changed
      // make sure at least one admin exists
      if (user.role === ""admin"") {
        const validAdminCount = (await this.count(`role = 'admin'`)) > 1;
        if (!validAdminCount)
          return {
            success: false,
            error: `There would be no admins if this action was completed. There must be at least one admin.`,
          };
      }

      toUpdate.role = role;
    }

    if (Object.keys(toUpdate).length !== 0) {
      const values = Object.values(toUpdate);
      const template = `UPDATE ${this.tablename} SET ${Object.keys(
        toUpdate
      ).map((key) => {
        return `${key}=?`;
      })} WHERE id = ?`;

      const db = await this.db();
      const { success, message } = await db
        .run(template, [...values, userId])
        .then(() => {
          return { success: true, message: null };
        })
        .catch((error) => {
          return { success: false, message: error.message };
        });

      db.close();
      if (!success) {
        console.error(message);
        return { success: false, error: message };
      }
    }

    return { success: true, error: null };
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : clause}`
      )
      .then((res) => res || null);
    if (!result) return null;
    db.close();
    return { ...result };
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
};

module.exports = { User };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""VAR-VAR""); VAR VAR = { VAR: ""VAR"", VAR: [], VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR VAR ""VAR"", VAR VAR VAR VAR VAR 0, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR(`\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR`); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR ({ VAR, VAR, VAR = VAR }) { VAR VAR = VAR(""VAR""); VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR) VAR(?, ?, ?)`, [VAR, VAR.VAR(VAR, 10), VAR ?? ""VAR""] ) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR."", VAR); VAR { VAR: VAR, VAR: VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR} ` ); VAR.VAR(); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR (VAR, VAR = {}) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR(VAR)}`); VAR (!VAR) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR."" }; VAR { VAR, VAR, VAR, VAR = 0 } = VAR; VAR VAR = { VAR }; VAR (VAR.VAR !== VAR && VAR?.VAR > 0) { VAR VAR = !!(VAR VAR.VAR(`VAR = ${VAR(VAR)}`)); VAR (VAR) VAR { VAR: VAR, VAR: `${VAR} VAR VAR VAR VAR.` }; VAR.VAR = VAR; } VAR (!!VAR) { VAR VAR = VAR(""VAR""); VAR.VAR = VAR.VAR(VAR, 10); } VAR (VAR.VAR !== VAR && [""VAR"", ""VAR""].VAR(VAR)) {   VAR (VAR.VAR === ""VAR"") { VAR VAR = (VAR VAR.VAR(`VAR = 'VAR'`)) > 1; VAR (!VAR) VAR { VAR: VAR, VAR: `VAR VAR VAR VAR VAR VAR VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR.`, }; } VAR.VAR = VAR; } VAR (VAR.VAR(VAR).VAR !== 0) { VAR VAR = VAR.VAR(VAR); VAR VAR = `VAR ${VAR.VAR} VAR ${VAR.VAR( VAR ).VAR((VAR) => { VAR `${VAR}=?`; })} VAR VAR = ?`; VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR(VAR, [...VAR, VAR]) .VAR(() => { VAR { VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR.VAR }; }); VAR.VAR(); VAR (!VAR) { VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR }; } } VAR { VAR: VAR, VAR: VAR }; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : VAR}` ) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR { ...VAR }; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, }; VAR.VAR = { VAR }; ",4,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/vectors.js,"const { checkForMigrations } = require(""../utils/database"");
const { Document } = require(""./documents"");

// TODO: Do we want to store entire vectorized chunks in here
// so that we can easily spin up temp-namespace clones for threading
const DocumentVectors = {
  tablename: ""document_vectors"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  docId TEXT NOT NULL,
  vectorId TEXT NOT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for DocumentVector migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  bulkInsert: async function (vectorRecords = []) {
    if (vectorRecords.length === 0) return;

    const db = await this.db();

    // Build a single query string with multiple placeholders for the INSERT operation
    const placeholders = vectorRecords.map(() => ""(?, ?)"").join("", "");

    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (docId, vectorId) VALUES ${placeholders}`
    );

    // Flatten the vectorRecords array to match the order of placeholders
    const values = vectorRecords.reduce(
      (arr, record) => arr.concat([record.docId, record.vectorId]),
      []
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      await stmt.run(values);
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();

    return { documentsInserted: vectorRecords.length };
  },
  deleteForWorkspace: async function (workspaceId) {
    const documents = await Document.forWorkspace(workspaceId);
    const docIds = [...new Set(documents.map((doc) => doc.docId))];
    const ids = (
      await this.where(`docId IN (${docIds.map((id) => `'${id}'`).join("","")})`)
    ).map((doc) => doc.id);
    await this.deleteIds(ids);
    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );

    db.close();
    return results;
  },
  deleteIds: async function (ids = []) {
    const db = await this.db();
    await db.get(
      `DELETE FROM ${this.tablename} WHERE id IN (${ids.join("", "")}) `
    );
    db.close();
    return true;
  },
};

module.exports = { DocumentVectors };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""./VAR"");   VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = []) { VAR (VAR.VAR === 0) VAR; VAR VAR = VAR VAR.VAR();  VAR VAR = VAR.VAR(() => ""(?, ?)"").VAR("", ""); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR ${VAR}` );  VAR VAR = VAR.VAR( (VAR, VAR) => VAR.VAR([VAR.VAR, VAR.VAR]), [] ); VAR VAR.VAR(""VAR VAR""); VAR { VAR VAR.VAR(VAR); VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR { VAR: VAR.VAR }; }, VAR: VAR VAR (VAR) { VAR VAR = VAR VAR.VAR(VAR); VAR VAR = [...VAR VAR(VAR.VAR((VAR) => VAR.VAR))]; VAR VAR = ( VAR VAR.VAR(`VAR VAR (${VAR.VAR((VAR) => `'${VAR}'`).VAR("","")})`) ).VAR((VAR) => VAR.VAR); VAR VAR.VAR(VAR); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = []) { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR( `VAR VAR ${VAR.VAR} VAR VAR VAR (${VAR.VAR("", "")}) ` ); VAR.VAR(); VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/vectors.js,"const { checkForMigrations } = require(""../utils/database"");
const { Document } = require(""./documents"");

// TODO: Do we want to store entire vectorized chunks in here
// so that we can easily spin up temp-namespace clones for threading
const DocumentVectors = {
  tablename: ""document_vectors"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  docId TEXT NOT NULL,
  vectorId TEXT NOT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,
  migrateTable: async function () {
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for DocumentVector migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  bulkInsert: async function (vectorRecords = []) {
    if (vectorRecords.length === 0) return;

    const db = await this.db();

    // Build a single query string with multiple placeholders for the INSERT operation
    const placeholders = vectorRecords.map(() => ""(?, ?)"").join("", "");

    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (docId, vectorId) VALUES ${placeholders}`
    );

    // Flatten the vectorRecords array to match the order of placeholders
    const values = vectorRecords.reduce(
      (arr, record) => arr.concat([record.docId, record.vectorId]),
      []
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      await stmt.run(values);
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();

    return { documentsInserted: vectorRecords.length };
  },
  deleteForWorkspace: async function (workspaceId) {
    const documents = await Document.forWorkspace(workspaceId);
    const docIds = [...new Set(documents.map((doc) => doc.docId))];
    const ids = (
      await this.where(`docId IN (${docIds.map((id) => `'${id}'`).join("","")})`)
    ).map((doc) => doc.id);
    await this.deleteIds(ids);
    return true;
  },
  where: async function (clause = """", limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );

    db.close();
    return results;
  },
  deleteIds: async function (ids = []) {
    const db = await this.db();
    await db.get(
      `DELETE FROM ${this.tablename} WHERE id IN (${ids.join("", "")}) `
    );
    db.close();
    return true;
  },
};

module.exports = { DocumentVectors };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR { VAR } = VAR(""./VAR"");   VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR = []) { VAR (VAR.VAR === 0) VAR; VAR VAR = VAR VAR.VAR();  VAR VAR = VAR.VAR(() => ""(?, ?)"").VAR("", ""); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR ${VAR}` );  VAR VAR = VAR.VAR( (VAR, VAR) => VAR.VAR([VAR.VAR, VAR.VAR]), [] ); VAR VAR.VAR(""VAR VAR""); VAR { VAR VAR.VAR(VAR); VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR { VAR: VAR.VAR }; }, VAR: VAR VAR (VAR) { VAR VAR = VAR VAR.VAR(VAR); VAR VAR = [...VAR VAR(VAR.VAR((VAR) => VAR.VAR))]; VAR VAR = ( VAR VAR.VAR(`VAR VAR (${VAR.VAR((VAR) => `'${VAR}'`).VAR("","")})`) ).VAR((VAR) => VAR.VAR); VAR VAR.VAR(VAR); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = []) { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR( `VAR VAR ${VAR.VAR} VAR VAR VAR (${VAR.VAR("", "")}) ` ); VAR.VAR(); VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/welcomeMessages.js,"const WelcomeMessages = {
  tablename: ""welcome_messages"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user TEXT NOT NULL,
  response TEXT NOT NULL,
  orderIndex INTEGER,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,

  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for Welcome Messages migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
    db.close();
  },

  migrations: function () {
    return [];
  },

  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) {
      db.on(""trace"", (sql) => console.log(sql));
    }

    return db;
  },

  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    db.close();
    return result;
  },

  where: async function (clause = null, limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();
    return results;
  },

  saveAll: async function (messages) {
    const db = await this.db();
    await db.run(`DELETE FROM ${this.tablename}`);
    for (const [index, message] of messages.entries()) {
      await db.run(
        `INSERT INTO ${this.tablename} (user, response, orderIndex) VALUES (?, ?, ?)`,
        [message.user, message.response, index]
      );
    }
    db.close();
  },

  getMessages: async function () {
    const db = await this.db();
    const results = await db.all(
      `SELECT user, response FROM ${this.tablename} ORDER BY orderIndex ASC`
    );
    db.close();
    return results;
  },
};

module.exports.WelcomeMessages = WelcomeMessages;",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); VAR.VAR(); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) { VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); } VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR}`); VAR (VAR [VAR, VAR] VAR VAR.VAR()) { VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR) VAR (?, ?, ?)`, [VAR.VAR, VAR.VAR, VAR] ); } VAR.VAR(); }, VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR, VAR VAR ${VAR.VAR} VAR VAR VAR VAR` ); VAR.VAR(); VAR VAR; }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/welcomeMessages.js,"const WelcomeMessages = {
  tablename: ""welcome_messages"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user TEXT NOT NULL,
  response TEXT NOT NULL,
  orderIndex INTEGER,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP
  `,

  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for Welcome Messages migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
    db.close();
  },

  migrations: function () {
    return [];
  },

  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) {
      db.on(""trace"", (sql) => console.log(sql));
    }

    return db;
  },

  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    db.close();
    return result;
  },

  where: async function (clause = null, limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();
    return results;
  },

  saveAll: async function (messages) {
    const db = await this.db();
    await db.run(`DELETE FROM ${this.tablename}`);
    for (const [index, message] of messages.entries()) {
      await db.run(
        `INSERT INTO ${this.tablename} (user, response, orderIndex) VALUES (?, ?, ?)`,
        [message.user, message.response, index]
      );
    }
    db.close();
  },

  getMessages: async function () {
    const db = await this.db();
    const results = await db.all(
      `SELECT user, response FROM ${this.tablename} ORDER BY orderIndex ASC`
    );
    db.close();
    return results;
  },
};

module.exports.WelcomeMessages = WelcomeMessages;",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR, VAR VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); VAR.VAR(); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) { VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); } VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR}`); VAR (VAR [VAR, VAR] VAR VAR.VAR()) { VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR) VAR (?, ?, ?)`, [VAR.VAR, VAR.VAR, VAR] ); } VAR.VAR(); }, VAR: VAR VAR () { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR, VAR VAR ${VAR.VAR} VAR VAR VAR VAR` ); VAR.VAR(); VAR VAR; }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/workspaceChats.js,"const { checkForMigrations } = require(""../utils/database"");

const WorkspaceChats = {
  tablename: ""workspace_chats"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  workspaceId INTEGER NOT NULL,
  prompt TEXT NOT NULL,
  response TEXT NOT NULL,
  include BOOL DEFAULT true,
  user_id INTEGER DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
  `,
  migrateTable: async function () {
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for WorkspaceChats migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [
      {
        colName: ""user_id"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN user_id INTEGER DEFAULT NULL`,
        doif: false,
      },
    ];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  new: async function ({ workspaceId, prompt, response = {}, user = null }) {
    const db = await this.db();
    const { id, success, message } = await db
      .run(
        `INSERT INTO ${this.tablename} (workspaceId, prompt, response, user_id) VALUES (?, ?, ?, ?)`,
        [workspaceId, prompt, JSON.stringify(response), user?.id || null]
      )
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });
    if (!success) {
      db.close();
      return { chat: null, message };
    }

    const chat = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id}`
    );
    db.close();

    return { chat, message: null };
  },
  forWorkspaceByUser: async function (
    workspaceId = null,
    userId = null,
    limit = null
  ) {
    if (!workspaceId || !userId) return [];
    return await this.where(
      `workspaceId = ${workspaceId} AND include = true AND user_id = ${userId}`,
      limit,
      ""ORDER BY id ASC""
    );
  },
  forWorkspace: async function (workspaceId = null, limit = null) {
    if (!workspaceId) return [];
    return await this.where(
      `workspaceId = ${workspaceId} AND include = true`,
      limit,
      ""ORDER BY id ASC""
    );
  },
  markHistoryInvalid: async function (workspaceId = null, user = null) {
    if (!workspaceId) return;
    const db = await this.db();
    await db.run(
      `UPDATE ${this.tablename} SET include = false WHERE workspaceId = ? ${
        user ? `AND user_id = ${user.id}` : """"
      }`,
      [workspaceId]
    );
    db.close();

    return;
  },
  get: async function (clause = """", limit = null, order = null) {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} WHERE ${clause} ${
          !!order ? order : """"
        } ${!!limit ? `LIMIT ${limit}` : """"}`
      )
      .then((res) => res || null);
    db.close();

    if (!result) return null;
    return result;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null, order = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!order ? order : """"
      } ${!!limit ? `LIMIT ${limit}` : """"}`
    );
    db.close();

    return results;
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  whereWithData: async function (clause = """", limit = null, order = null) {
    const { Workspace } = require(""./workspace"");
    const { User } = require(""./user"");
    const results = await this.where(clause, limit, order);
    for (const res of results) {
      const workspace = await Workspace.get(`id = ${res.workspaceId}`);
      res.workspace = workspace
        ? { name: workspace.name, slug: workspace.slug }
        : { name: ""deleted workspace"", slug: null };

      const user = await User.get(`id = ${res.user_id}`);
      res.user = user
        ? { username: user.username }
        : { username: ""deleted user"" };
    }
    return results;
  },
};

module.exports = { WorkspaceChats };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR (VAR) VAR VAR (VAR) VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR [ { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR`, VAR: VAR, }, ]; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR ({ VAR, VAR, VAR = {}, VAR = VAR }) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR, VAR) VAR (?, ?, ?, ?)`, [VAR, VAR, VAR.VAR(VAR), VAR?.VAR || VAR] ) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR { VAR: VAR, VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR}` ); VAR.VAR(); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR ( VAR = VAR, VAR = VAR, VAR = VAR ) { VAR (!VAR || !VAR) VAR []; VAR VAR VAR.VAR( `VAR = ${VAR} VAR VAR = VAR VAR VAR = ${VAR}`, VAR, ""VAR VAR VAR VAR"" ); }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR (!VAR) VAR []; VAR VAR VAR.VAR( `VAR = ${VAR} VAR VAR = VAR`, VAR, ""VAR VAR VAR VAR"" ); }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR (!VAR) VAR; VAR VAR = VAR VAR.VAR(); VAR VAR.VAR( `VAR ${VAR.VAR} VAR VAR = VAR VAR VAR = ? ${ VAR ? `VAR VAR = ${VAR.VAR}` : """" }`, [VAR] ); VAR.VAR(); VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} VAR ${VAR} ${ !!VAR ? VAR : """" } ${!!VAR ? `VAR ${VAR}` : """"}` ) .VAR((VAR) => VAR || VAR); VAR.VAR(); VAR (!VAR) VAR VAR; VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? VAR : """" } ${!!VAR ? `VAR ${VAR}` : """"}` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR { VAR } = VAR(""./VAR""); VAR { VAR } = VAR(""./VAR""); VAR VAR = VAR VAR.VAR(VAR, VAR, VAR); VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = VAR ? { VAR: VAR.VAR, VAR: VAR.VAR } : { VAR: ""VAR VAR"", VAR: VAR }; VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = VAR ? { VAR: VAR.VAR } : { VAR: ""VAR VAR"" }; } VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/workspaceChats.js,"const { checkForMigrations } = require(""../utils/database"");

const WorkspaceChats = {
  tablename: ""workspace_chats"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  workspaceId INTEGER NOT NULL,
  prompt TEXT NOT NULL,
  response TEXT NOT NULL,
  include BOOL DEFAULT true,
  user_id INTEGER DEFAULT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
  `,
  migrateTable: async function () {
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for WorkspaceChats migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [
      {
        colName: ""user_id"",
        execCmd: `ALTER TABLE ${this.tablename} ADD COLUMN user_id INTEGER DEFAULT NULL`,
        doif: false,
      },
    ];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  new: async function ({ workspaceId, prompt, response = {}, user = null }) {
    const db = await this.db();
    const { id, success, message } = await db
      .run(
        `INSERT INTO ${this.tablename} (workspaceId, prompt, response, user_id) VALUES (?, ?, ?, ?)`,
        [workspaceId, prompt, JSON.stringify(response), user?.id || null]
      )
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });
    if (!success) {
      db.close();
      return { chat: null, message };
    }

    const chat = await db.get(
      `SELECT * FROM ${this.tablename} WHERE id = ${id}`
    );
    db.close();

    return { chat, message: null };
  },
  forWorkspaceByUser: async function (
    workspaceId = null,
    userId = null,
    limit = null
  ) {
    if (!workspaceId || !userId) return [];
    return await this.where(
      `workspaceId = ${workspaceId} AND include = true AND user_id = ${userId}`,
      limit,
      ""ORDER BY id ASC""
    );
  },
  forWorkspace: async function (workspaceId = null, limit = null) {
    if (!workspaceId) return [];
    return await this.where(
      `workspaceId = ${workspaceId} AND include = true`,
      limit,
      ""ORDER BY id ASC""
    );
  },
  markHistoryInvalid: async function (workspaceId = null, user = null) {
    if (!workspaceId) return;
    const db = await this.db();
    await db.run(
      `UPDATE ${this.tablename} SET include = false WHERE workspaceId = ? ${
        user ? `AND user_id = ${user.id}` : """"
      }`,
      [workspaceId]
    );
    db.close();

    return;
  },
  get: async function (clause = """", limit = null, order = null) {
    const db = await this.db();
    const result = await db
      .get(
        `SELECT * FROM ${this.tablename} WHERE ${clause} ${
          !!order ? order : """"
        } ${!!limit ? `LIMIT ${limit}` : """"}`
      )
      .then((res) => res || null);
    db.close();

    if (!result) return null;
    return result;
  },
  delete: async function (clause = """") {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    db.close();

    return true;
  },
  where: async function (clause = """", limit = null, order = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!order ? order : """"
      } ${!!limit ? `LIMIT ${limit}` : """"}`
    );
    db.close();

    return results;
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      } `
    );
    db.close();

    return count;
  },
  whereWithData: async function (clause = """", limit = null, order = null) {
    const { Workspace } = require(""./workspace"");
    const { User } = require(""./user"");
    const results = await this.where(clause, limit, order);
    for (const res of results) {
      const workspace = await Workspace.get(`id = ${res.workspaceId}`);
      res.workspace = workspace
        ? { name: workspace.name, slug: workspace.slug }
        : { name: ""deleted workspace"", slug: null };

      const user = await User.get(`id = ${res.user_id}`);
      res.user = user
        ? { username: user.username }
        : { username: ""deleted user"" };
    }
    return results;
  },
};

module.exports = { WorkspaceChats };",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../VAR/VAR""); VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR (VAR) VAR VAR (VAR) VAR VAR VAR `, VAR: VAR VAR () { VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR [ { VAR: ""VAR"", VAR: `VAR VAR ${VAR.VAR} VAR VAR VAR VAR VAR VAR`, VAR: VAR, }, ]; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR ({ VAR, VAR, VAR = {}, VAR = VAR }) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR, VAR } = VAR VAR .VAR( `VAR VAR ${VAR.VAR} (VAR, VAR, VAR, VAR) VAR (?, ?, ?, ?)`, [VAR, VAR, VAR.VAR(VAR), VAR?.VAR || VAR] ) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR { VAR: VAR, VAR }; } VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} VAR VAR = ${VAR}` ); VAR.VAR(); VAR { VAR, VAR: VAR }; }, VAR: VAR VAR ( VAR = VAR, VAR = VAR, VAR = VAR ) { VAR (!VAR || !VAR) VAR []; VAR VAR VAR.VAR( `VAR = ${VAR} VAR VAR = VAR VAR VAR = ${VAR}`, VAR, ""VAR VAR VAR VAR"" ); }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR (!VAR) VAR []; VAR VAR VAR.VAR( `VAR = ${VAR} VAR VAR = VAR`, VAR, ""VAR VAR VAR VAR"" ); }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR (!VAR) VAR; VAR VAR = VAR VAR.VAR(); VAR VAR.VAR( `VAR ${VAR.VAR} VAR VAR = VAR VAR VAR = ? ${ VAR ? `VAR VAR = ${VAR.VAR}` : """" }`, [VAR] ); VAR.VAR(); VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR( `VAR * VAR ${VAR.VAR} VAR ${VAR} ${ !!VAR ? VAR : """" } ${!!VAR ? `VAR ${VAR}` : """"}` ) .VAR((VAR) => VAR || VAR); VAR.VAR(); VAR (!VAR) VAR VAR; VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? VAR : """" } ${!!VAR ? `VAR ${VAR}` : """"}` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" } ` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = """", VAR = VAR, VAR = VAR) { VAR { VAR } = VAR(""./VAR""); VAR { VAR } = VAR(""./VAR""); VAR VAR = VAR VAR.VAR(VAR, VAR, VAR); VAR (VAR VAR VAR VAR) { VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = VAR ? { VAR: VAR.VAR, VAR: VAR.VAR } : { VAR: ""VAR VAR"", VAR: VAR }; VAR VAR = VAR VAR.VAR(`VAR = ${VAR.VAR}`); VAR.VAR = VAR ? { VAR: VAR.VAR } : { VAR: ""VAR VAR"" }; } VAR VAR; }, }; VAR.VAR = { VAR }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/workspaceUsers.js,"const WorkspaceUser = {
  tablename: ""workspace_users"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  workspace_id INTEGER NOT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
  FOREIGN KEY (workspace_id) REFERENCES workspaces (id) ON DELETE CASCADE
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for Workspace User migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  createMany: async function (userId, workspaceIds = []) {
    if (workspaceIds.length === 0) return;
    const db = await this.db();
    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (user_id, workspace_id) VALUES (?,?)`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const workspaceId of workspaceIds) {
        await stmt.run([userId, workspaceId]);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    return;
  },
  createManyUsers: async function (userIds = [], workspaceId) {
    if (userIds.length === 0) return;
    const db = await this.db();
    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (user_id, workspace_id) VALUES (?,?)`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const userId of userIds) {
        await stmt.run([userId, workspaceId]);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    return;
  },
  create: async function (userId = 0, workspaceId = 0) {
    const db = await this.db();
    const { success, message } = await db
      .run(
        `INSERT INTO ${this.tablename} (user_id, workspace_id) VALUES (?, ?)`,
        [userId, workspaceId]
      )
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE WORKSPACE_USER RELATIONSHIP."", message);
      return false;
    }
    return true;
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    return result;
  },
  where: async function (clause = null, limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      }`
    );
    db.close();

    return count;
  },
  delete: async function (clause = null) {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    return;
  },
};

module.exports.WorkspaceUser = WorkspaceUser;",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR (VAR) VAR VAR (VAR) VAR VAR VAR, VAR VAR (VAR) VAR VAR (VAR) VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR (VAR.VAR === 0) VAR; VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?,?)` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR([VAR, VAR]); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR; }, VAR: VAR VAR (VAR = [], VAR) { VAR (VAR.VAR === 0) VAR; VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?,?)` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR([VAR, VAR]); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR; }, VAR: VAR VAR (VAR = 0, VAR = 0) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?, ?)`, [VAR, VAR] ) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR VAR."", VAR); VAR VAR; } VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR; }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/models/workspaceUsers.js,"const WorkspaceUser = {
  tablename: ""workspace_users"",
  colsInit: `
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_id INTEGER NOT NULL,
  workspace_id INTEGER NOT NULL,
  createdAt TEXT DEFAULT CURRENT_TIMESTAMP,
  lastUpdatedAt TEXT DEFAULT CURRENT_TIMESTAMP,

  FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
  FOREIGN KEY (workspace_id) REFERENCES workspaces (id) ON DELETE CASCADE
  `,
  migrateTable: async function () {
    const { checkForMigrations } = require(""../utils/database"");
    console.log(
      `\x1b[34m[MIGRATING]\x1b[0m Checking for Workspace User migrations`
    );
    const db = await this.db(false);
    await checkForMigrations(this, db);
  },
  migrations: function () {
    return [];
  },
  db: async function (tracing = true) {
    const sqlite3 = require(""sqlite3"").verbose();
    const { open } = require(""sqlite"");

    const db = await open({
      filename: `${
        !!process.env.STORAGE_DIR ? `${process.env.STORAGE_DIR}/` : ""storage/""
      }anythingllm.db`,
      driver: sqlite3.Database,
    });

    await db.exec(
      `PRAGMA foreign_keys = ON;CREATE TABLE IF NOT EXISTS ${this.tablename} (${this.colsInit})`
    );

    if (tracing) db.on(""trace"", (sql) => console.log(sql));
    return db;
  },
  createMany: async function (userId, workspaceIds = []) {
    if (workspaceIds.length === 0) return;
    const db = await this.db();
    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (user_id, workspace_id) VALUES (?,?)`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const workspaceId of workspaceIds) {
        await stmt.run([userId, workspaceId]);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    return;
  },
  createManyUsers: async function (userIds = [], workspaceId) {
    if (userIds.length === 0) return;
    const db = await this.db();
    const stmt = await db.prepare(
      `INSERT INTO ${this.tablename} (user_id, workspace_id) VALUES (?,?)`
    );

    await db.exec(""BEGIN TRANSACTION"");
    try {
      for (const userId of userIds) {
        await stmt.run([userId, workspaceId]);
      }
      await db.exec(""COMMIT"");
    } catch {
      await db.exec(""ROLLBACK"");
    }

    stmt.finalize();
    db.close();
    return;
  },
  create: async function (userId = 0, workspaceId = 0) {
    const db = await this.db();
    const { success, message } = await db
      .run(
        `INSERT INTO ${this.tablename} (user_id, workspace_id) VALUES (?, ?)`,
        [userId, workspaceId]
      )
      .then((res) => {
        return { id: res.lastID, success: true, message: null };
      })
      .catch((error) => {
        return { id: null, success: false, message: error.message };
      });

    if (!success) {
      db.close();
      console.error(""FAILED TO CREATE WORKSPACE_USER RELATIONSHIP."", message);
      return false;
    }
    return true;
  },
  get: async function (clause = """") {
    const db = await this.db();
    const result = await db
      .get(`SELECT * FROM ${this.tablename} WHERE ${clause}`)
      .then((res) => res || null);
    if (!result) return null;
    db.close();

    return result;
  },
  where: async function (clause = null, limit = null) {
    const db = await this.db();
    const results = await db.all(
      `SELECT * FROM ${this.tablename} ${clause ? `WHERE ${clause}` : """"} ${
        !!limit ? `LIMIT ${limit}` : """"
      }`
    );
    db.close();

    return results;
  },
  count: async function (clause = null) {
    const db = await this.db();
    const { count } = await db.get(
      `SELECT COUNT(*) as count FROM ${this.tablename} ${
        clause ? `WHERE ${clause}` : """"
      }`
    );
    db.close();

    return count;
  },
  delete: async function (clause = null) {
    const db = await this.db();
    await db.get(`DELETE FROM ${this.tablename} WHERE ${clause}`);
    return;
  },
};

module.exports.WorkspaceUser = WorkspaceUser;",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = { VAR: ""VAR"", VAR: ` VAR VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR VAR VAR, VAR VAR (VAR) VAR VAR (VAR) VAR VAR VAR, VAR VAR (VAR) VAR VAR (VAR) VAR VAR VAR `, VAR: VAR VAR () { VAR { VAR } = VAR(""../VAR/VAR""); VAR.VAR( `\VAR[34m[VAR]\VAR[0m VAR VAR VAR VAR VAR` ); VAR VAR = VAR VAR.VAR(VAR); VAR VAR(VAR, VAR); }, VAR: VAR () { VAR []; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR(""VAR"").VAR(); VAR { VAR } = VAR(""VAR""); VAR VAR = VAR VAR({ VAR: `${ !!VAR.VAR.VAR ? `${VAR.VAR.VAR}/` : ""VAR/"" }VAR.VAR`, VAR: VAR.VAR, }); VAR VAR.VAR( `VAR VAR = VAR;VAR VAR VAR VAR VAR ${VAR.VAR} (${VAR.VAR})` ); VAR (VAR) VAR.VAR(""VAR"", (VAR) => VAR.VAR(VAR)); VAR VAR; }, VAR: VAR VAR (VAR, VAR = []) { VAR (VAR.VAR === 0) VAR; VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?,?)` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR([VAR, VAR]); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR; }, VAR: VAR VAR (VAR = [], VAR) { VAR (VAR.VAR === 0) VAR; VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?,?)` ); VAR VAR.VAR(""VAR VAR""); VAR { VAR (VAR VAR VAR VAR) { VAR VAR.VAR([VAR, VAR]); } VAR VAR.VAR(""VAR""); } VAR { VAR VAR.VAR(""VAR""); } VAR.VAR(); VAR.VAR(); VAR; }, VAR: VAR VAR (VAR = 0, VAR = 0) { VAR VAR = VAR VAR.VAR(); VAR { VAR, VAR } = VAR VAR .VAR( `VAR VAR ${VAR.VAR} (VAR, VAR) VAR (?, ?)`, [VAR, VAR] ) .VAR((VAR) => { VAR { VAR: VAR.VAR, VAR: VAR, VAR: VAR }; }) .VAR((VAR) => { VAR { VAR: VAR, VAR: VAR, VAR: VAR.VAR }; }); VAR (!VAR) { VAR.VAR(); VAR.VAR(""VAR VAR VAR VAR VAR."", VAR); VAR VAR; } VAR VAR; }, VAR: VAR VAR (VAR = """") { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR .VAR(`VAR * VAR ${VAR.VAR} VAR ${VAR}`) .VAR((VAR) => VAR || VAR); VAR (!VAR) VAR VAR; VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR, VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR = VAR VAR.VAR( `VAR * VAR ${VAR.VAR} ${VAR ? `VAR ${VAR}` : """"} ${ !!VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR { VAR } = VAR VAR.VAR( `VAR VAR(*) VAR VAR VAR ${VAR.VAR} ${ VAR ? `VAR ${VAR}` : """" }` ); VAR.VAR(); VAR VAR; }, VAR: VAR VAR (VAR = VAR) { VAR VAR = VAR VAR.VAR(); VAR VAR.VAR(`VAR VAR ${VAR.VAR} VAR ${VAR}`); VAR; }, }; VAR.VAR.VAR = VAR; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/utils/database/index.js,"const { getGitVersion } = require(""../../endpoints/utils"");
const { Telemetry } = require(""../../models/telemetry"");

function checkColumnTemplate(tablename = null, column = null) {
  if (!tablename || !column)
    throw new Error(`Migration Error`, { tablename, column });
  return `SELECT COUNT(*) AS _exists FROM pragma_table_info('${tablename}') WHERE name='${column}'`;
}

// Note (tcarambat): Since there is no good way to track migrations in Node/SQLite we use this simple system
// Each model has a `migrations` method that will return an array like...
// { colName: 'stringColName', execCmd: `SQL Command to run when`, doif: boolean },
// colName = name of column
// execCmd = Command to run when doif matches the state of the DB
// doif = condition to match that determines if execCmd will run.
// eg: Table workspace has slug column.
// execCmd: ALTER TABLE DROP COLUMN slug;
// doif: true
// => Will drop the slug column if the workspace table has a column named 'slug' otherwise nothing happens.
// If you are adding a new table column if needs to exist in the Models `colsInit` and as a migration.
// So both new and existing DBs will get the column when code is pulled in.

async function checkForMigrations(model, db) {
  if (model.migrations().length === 0) return;
  const toMigrate = [];
  for (const { colName, execCmd, doif } of model.migrations()) {
    const { _exists } = await db.get(
      checkColumnTemplate(model.tablename, colName)
    );
    const colExists = _exists !== 0;
    if (colExists !== doif) continue;

    toMigrate.push(execCmd);
  }

  if (toMigrate.length === 0) return;

  console.log(`Running ${toMigrate.length} migrations`, toMigrate);
  await db.exec(toMigrate.join("";\n""));
  return;
}

// Note(tcarambat): When building in production via Docker the SQLite file will not exist
// and if this function tries to run on boot the file will not exist
// and the server will abort and the container will exit.
// This function will run each reload on dev but on production
// it will be stubbed until the /api/migrate endpoint is GET.
async function validateTablePragmas(force = false) {
  try {
    if (process.env.NODE_ENV !== ""development"" && force === false) {
      console.log(
        `\x1b[34m[MIGRATIONS STUBBED]\x1b[0m Please ping /migrate once server starts to run migrations`
      );
      return;
    }
    const { SystemSettings } = require(""../../models/systemSettings"");
    const { User } = require(""../../models/user"");
    const { Workspace } = require(""../../models/workspace"");
    const { WorkspaceUser } = require(""../../models/workspaceUsers"");
    const { Document } = require(""../../models/documents"");
    const { DocumentVectors } = require(""../../models/vectors"");
    const { WorkspaceChats } = require(""../../models/workspaceChats"");
    const { Invite } = require(""../../models/invite"");
    const { WelcomeMessages } = require(""../../models/welcomeMessages"");
    const { ApiKey } = require(""../../models/apiKeys"");

    await SystemSettings.migrateTable();
    await User.migrateTable();
    await Workspace.migrateTable();
    await WorkspaceUser.migrateTable();
    await Document.migrateTable();
    await DocumentVectors.migrateTable();
    await WorkspaceChats.migrateTable();
    await Invite.migrateTable();
    await WelcomeMessages.migrateTable();
    await ApiKey.migrateTable();
  } catch (e) {
    console.error(`validateTablePragmas: Migrations failed`, e);
  }
  return;
}

// Telemetry is anonymized and your data is never read. This can be disabled by setting
// DISABLE_TELEMETRY=true in the `.env` of however you setup. Telemetry helps us determine use
// of how AnythingLLM is used and how to improve this product!
// You can see all Telemetry events by ctrl+f `Telemetry.sendEvent` calls to verify this claim.
async function setupTelemetry() {
  if (process.env.DISABLE_TELEMETRY === ""true"") {
    console.log(
      `\x1b[31m[TELEMETRY DISABLED]\x1b[0m Telemetry is marked as disabled - no events will send. Telemetry helps Mintplex Labs Inc improve AnythingLLM.`
    );
    return true;
  }

  if (Telemetry.isDev()) {
    console.log(
      `\x1b[33m[TELEMETRY STUBBED]\x1b[0m Anonymous Telemetry stubbed in development.`
    );
    return;
  }

  console.log(
    `\x1b[32m[TELEMETRY ENABLED]\x1b[0m Anonymous Telemetry enabled. Telemetry helps Mintplex Labs Inc improve AnythingLLM.`
  );
  await Telemetry.findOrCreateId();
  await Telemetry.sendTelemetry(""server_boot"", {
    commit: getGitVersion(),
  });
  return;
}

module.exports = {
  checkForMigrations,
  validateTablePragmas,
  setupTelemetry,
};",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR VAR(VAR = VAR, VAR = VAR) { VAR (!VAR || !VAR) VAR VAR VAR(`VAR VAR`, { VAR, VAR }); VAR `VAR VAR(*) VAR VAR VAR VAR('${VAR}') VAR VAR='${VAR}'`; }             VAR VAR VAR(VAR, VAR) { VAR (VAR.VAR().VAR === 0) VAR; VAR VAR = []; VAR (VAR { VAR, VAR, VAR } VAR VAR.VAR()) { VAR { VAR } = VAR VAR.VAR( VAR(VAR.VAR, VAR) ); VAR VAR = VAR !== 0; VAR (VAR !== VAR) VAR; VAR.VAR(VAR); } VAR (VAR.VAR === 0) VAR; VAR.VAR(`VAR ${VAR.VAR} VAR`, VAR); VAR VAR.VAR(VAR.VAR("";\VAR"")); VAR; }      VAR VAR VAR(VAR = VAR) { VAR { VAR (VAR.VAR.VAR !== ""VAR"" && VAR === VAR) { VAR.VAR( `\VAR[34m[VAR VAR]\VAR[0m VAR VAR /VAR VAR VAR VAR VAR VAR VAR` ); VAR; } VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); } VAR (VAR) { VAR.VAR(`VAR: VAR VAR`, VAR); } VAR; }     VAR VAR VAR() { VAR (VAR.VAR.VAR === ""VAR"") { VAR.VAR( `\VAR[31m[VAR VAR]\VAR[0m VAR VAR VAR VAR VAR - VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR.` ); VAR VAR; } VAR (VAR.VAR()) { VAR.VAR( `\VAR[33m[VAR VAR]\VAR[0m VAR VAR VAR VAR VAR.` ); VAR; } VAR.VAR( `\VAR[32m[VAR VAR]\VAR[0m VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR.` ); VAR VAR.VAR(); VAR VAR.VAR(""VAR"", { VAR: VAR(), }); VAR; } VAR.VAR = { VAR, VAR, VAR, }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/utils/database/index.js,"const { getGitVersion } = require(""../../endpoints/utils"");
const { Telemetry } = require(""../../models/telemetry"");

function checkColumnTemplate(tablename = null, column = null) {
  if (!tablename || !column)
    throw new Error(`Migration Error`, { tablename, column });
  return `SELECT COUNT(*) AS _exists FROM pragma_table_info('${tablename}') WHERE name='${column}'`;
}

// Note (tcarambat): Since there is no good way to track migrations in Node/SQLite we use this simple system
// Each model has a `migrations` method that will return an array like...
// { colName: 'stringColName', execCmd: `SQL Command to run when`, doif: boolean },
// colName = name of column
// execCmd = Command to run when doif matches the state of the DB
// doif = condition to match that determines if execCmd will run.
// eg: Table workspace has slug column.
// execCmd: ALTER TABLE DROP COLUMN slug;
// doif: true
// => Will drop the slug column if the workspace table has a column named 'slug' otherwise nothing happens.
// If you are adding a new table column if needs to exist in the Models `colsInit` and as a migration.
// So both new and existing DBs will get the column when code is pulled in.

async function checkForMigrations(model, db) {
  if (model.migrations().length === 0) return;
  const toMigrate = [];
  for (const { colName, execCmd, doif } of model.migrations()) {
    const { _exists } = await db.get(
      checkColumnTemplate(model.tablename, colName)
    );
    const colExists = _exists !== 0;
    if (colExists !== doif) continue;

    toMigrate.push(execCmd);
  }

  if (toMigrate.length === 0) return;

  console.log(`Running ${toMigrate.length} migrations`, toMigrate);
  await db.exec(toMigrate.join("";\n""));
  return;
}

// Note(tcarambat): When building in production via Docker the SQLite file will not exist
// and if this function tries to run on boot the file will not exist
// and the server will abort and the container will exit.
// This function will run each reload on dev but on production
// it will be stubbed until the /api/migrate endpoint is GET.
async function validateTablePragmas(force = false) {
  try {
    if (process.env.NODE_ENV !== ""development"" && force === false) {
      console.log(
        `\x1b[34m[MIGRATIONS STUBBED]\x1b[0m Please ping /migrate once server starts to run migrations`
      );
      return;
    }
    const { SystemSettings } = require(""../../models/systemSettings"");
    const { User } = require(""../../models/user"");
    const { Workspace } = require(""../../models/workspace"");
    const { WorkspaceUser } = require(""../../models/workspaceUsers"");
    const { Document } = require(""../../models/documents"");
    const { DocumentVectors } = require(""../../models/vectors"");
    const { WorkspaceChats } = require(""../../models/workspaceChats"");
    const { Invite } = require(""../../models/invite"");
    const { WelcomeMessages } = require(""../../models/welcomeMessages"");
    const { ApiKey } = require(""../../models/apiKeys"");

    await SystemSettings.migrateTable();
    await User.migrateTable();
    await Workspace.migrateTable();
    await WorkspaceUser.migrateTable();
    await Document.migrateTable();
    await DocumentVectors.migrateTable();
    await WorkspaceChats.migrateTable();
    await Invite.migrateTable();
    await WelcomeMessages.migrateTable();
    await ApiKey.migrateTable();
  } catch (e) {
    console.error(`validateTablePragmas: Migrations failed`, e);
  }
  return;
}

// Telemetry is anonymized and your data is never read. This can be disabled by setting
// DISABLE_TELEMETRY=true in the `.env` of however you setup. Telemetry helps us determine use
// of how AnythingLLM is used and how to improve this product!
// You can see all Telemetry events by ctrl+f `Telemetry.sendEvent` calls to verify this claim.
async function setupTelemetry() {
  if (process.env.DISABLE_TELEMETRY === ""true"") {
    console.log(
      `\x1b[31m[TELEMETRY DISABLED]\x1b[0m Telemetry is marked as disabled - no events will send. Telemetry helps Mintplex Labs Inc improve AnythingLLM.`
    );
    return true;
  }

  if (Telemetry.isDev()) {
    console.log(
      `\x1b[33m[TELEMETRY STUBBED]\x1b[0m Anonymous Telemetry stubbed in development.`
    );
    return;
  }

  console.log(
    `\x1b[32m[TELEMETRY ENABLED]\x1b[0m Anonymous Telemetry enabled. Telemetry helps Mintplex Labs Inc improve AnythingLLM.`
  );
  await Telemetry.findOrCreateId();
  await Telemetry.sendTelemetry(""server_boot"", {
    commit: getGitVersion(),
  });
  return;
}

module.exports = {
  checkForMigrations,
  validateTablePragmas,
  setupTelemetry,
};",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR VAR(VAR = VAR, VAR = VAR) { VAR (!VAR || !VAR) VAR VAR VAR(`VAR VAR`, { VAR, VAR }); VAR `VAR VAR(*) VAR VAR VAR VAR('${VAR}') VAR VAR='${VAR}'`; }             VAR VAR VAR(VAR, VAR) { VAR (VAR.VAR().VAR === 0) VAR; VAR VAR = []; VAR (VAR { VAR, VAR, VAR } VAR VAR.VAR()) { VAR { VAR } = VAR VAR.VAR( VAR(VAR.VAR, VAR) ); VAR VAR = VAR !== 0; VAR (VAR !== VAR) VAR; VAR.VAR(VAR); } VAR (VAR.VAR === 0) VAR; VAR.VAR(`VAR ${VAR.VAR} VAR`, VAR); VAR VAR.VAR(VAR.VAR("";\VAR"")); VAR; }      VAR VAR VAR(VAR = VAR) { VAR { VAR (VAR.VAR.VAR !== ""VAR"" && VAR === VAR) { VAR.VAR( `\VAR[34m[VAR VAR]\VAR[0m VAR VAR /VAR VAR VAR VAR VAR VAR VAR` ); VAR; } VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR { VAR } = VAR(""../../VAR/VAR""); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); VAR VAR.VAR(); } VAR (VAR) { VAR.VAR(`VAR: VAR VAR`, VAR); } VAR; }     VAR VAR VAR() { VAR (VAR.VAR.VAR === ""VAR"") { VAR.VAR( `\VAR[31m[VAR VAR]\VAR[0m VAR VAR VAR VAR VAR - VAR VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR.` ); VAR VAR; } VAR (VAR.VAR()) { VAR.VAR( `\VAR[33m[VAR VAR]\VAR[0m VAR VAR VAR VAR VAR.` ); VAR; } VAR.VAR( `\VAR[32m[VAR VAR]\VAR[0m VAR VAR VAR. VAR VAR VAR VAR VAR VAR VAR.` ); VAR VAR.VAR(); VAR VAR.VAR(""VAR"", { VAR: VAR(), }); VAR; } VAR.VAR = { VAR, VAR, VAR, }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/utils/files/data.js,"const fs = require(""fs"");
const path = require(""path"");
const { v4 } = require(""uuid"");

async function exportData() {
  const uid = `anythingllm-export-${new Date()
    .toJSON()
    .slice(0, 10)}-${new Date().toJSON().slice(11, 19)}`;
  const folder =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage/exports/${uid}`)
      : path.resolve(process.env.STORAGE_DIR, `exports/${uid}`);
  const storageBase =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage`)
      : path.resolve(process.env.STORAGE_DIR);

  try {
    fs.mkdirSync(folder, { recursive: true });
    if (fs.existsSync(path.resolve(storageBase, `documents`))) {
      console.log(""\x1b[34m[EXPORTING DATA]\x1b[0m Copying documents!"");
      fs.cpSync(
        path.resolve(storageBase, `documents`),
        path.resolve(folder, ""documents""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(storageBase, `lancedb`))) {
      console.log(""\x1b[34m[EXPORTING DATA]\x1b[0m Copying LanceDB data!"");
      fs.cpSync(
        path.resolve(storageBase, `lancedb`),
        path.resolve(folder, ""lancedb""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(storageBase, `vector-cache`))) {
      console.log(""\x1b[34m[EXPORTING DATA]\x1b[0m Copying vector cache!"");
      fs.cpSync(
        path.resolve(storageBase, `vector-cache`),
        path.resolve(folder, ""vector-cache""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(storageBase, `anythingllm.db`))) {
      console.log(
        ""\x1b[34m[EXPORTING DATA]\x1b[0m Copying anythingllm database!""
      );
      fs.cpSync(
        path.resolve(storageBase, `anythingllm.db`),
        path.resolve(folder, ""anythingllm.db"")
      );
    }

    await zipDirectory(folder, path.resolve(folder, `../${uid}.zip`));
    fs.rmSync(folder, { recursive: true, force: true });
    return { filename: `${uid}.zip`, error: null };
  } catch (e) {
    // If anything goes wrong - abort and clean up
    console.error(e);
    if (fs.existsSync(folder))
      fs.rmSync(folder, { recursive: true, force: true });
    return { filename: null, error: e.message };
  }
}

async function unpackAndOverwriteImport(importFilename) {
  const importFilepath =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage/imports/${importFilename}`)
      : path.resolve(process.env.STORAGE_DIR, `imports/${importFilename}`);
  if (!fs.existsSync(importFilepath))
    return { success: false, error: ""Import file does not exist."" };

  const uid = v4();
  const outDir =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage/imports/${uid}`)
      : path.resolve(process.env.STORAGE_DIR, `imports/${uid}`);

  const storageBase =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage`)
      : path.resolve(process.env.STORAGE_DIR);

  try {
    console.log(
      ""\x1b[34m[EXTRACTING DATA]\x1b[0m Extracting data from zip into storage!""
    );
    const unzipProc = await unzipDirectory(importFilepath, outDir);
    if (!unzipProc.success) return unzipProc;

    if (fs.existsSync(path.resolve(outDir, `documents`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing documents!""
      );
      if (fs.existsSync(path.resolve(storageBase, `documents`)))
        fs.rmSync(path.resolve(storageBase, `documents`), {
          recursive: true,
          force: true,
        });
      fs.cpSync(
        path.resolve(outDir, `documents`),
        path.resolve(storageBase, ""documents""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(outDir, `lancedb`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing LanceDb!""
      );
      if (fs.existsSync(path.resolve(storageBase, `lancedb`)))
        fs.rmSync(path.resolve(storageBase, `lancedb`), {
          recursive: true,
          force: true,
        });
      fs.cpSync(
        path.resolve(outDir, `lancedb`),
        path.resolve(storageBase, ""lancedb""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(outDir, `vector-cache`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing Vector Cache!""
      );
      if (fs.existsSync(path.resolve(storageBase, `vector-cache`)))
        fs.rmSync(path.resolve(storageBase, `vector-cache`), {
          recursive: true,
          force: true,
        });
      fs.cpSync(
        path.resolve(outDir, `vector-cache`),
        path.resolve(storageBase, ""vector-cache""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(outDir, `anythingllm.db`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing AnythingLLM DB!""
      );
      if (fs.existsSync(path.resolve(storageBase, `anythingllm.db`)))
        fs.rmSync(path.resolve(storageBase, `anythingllm.db`), { force: true });
      fs.cpSync(
        path.resolve(outDir, `anythingllm.db`),
        path.resolve(storageBase, ""anythingllm.db"")
      );
    }

    fs.rmSync(outDir, { recursive: true, force: true });
    fs.rmSync(importFilepath, { force: true });
    return { success: true, error: null };
  } catch (e) {
    console.error(e);
    if (fs.existsSync(outDir))
      fs.rmSync(outDir, { recursive: true, force: true });
    if (fs.existsSync(importFilepath)) fs.rmSync(importFilepath);
    return { success: false, error: e.message };
  }
}

function zipDirectory(sourceDir, outPath) {
  const archiver = require(""archiver"");
  const archive = archiver(""zip"", { zlib: { level: 9 } });
  const stream = fs.createWriteStream(outPath);

  return new Promise((resolve, reject) => {
    archive
      .directory(sourceDir, false)
      .on(""error"", (err) => reject(err))
      .pipe(stream);

    stream.on(""close"", () => resolve());
    archive.finalize();
  });
}

async function unzipDirectory(sourcePath, outDir) {
  const extract = require(""extract-zip"");
  try {
    await extract(sourcePath, { dir: outDir });
    return { success: true, error: null };
  } catch (e) {
    console.error(""unzipToDirectory"", e);
    return { success: false, error: e.message };
  }
}

module.exports = {
  exportData,
  unpackAndOverwriteImport,
};",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4899,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = VAR(""VAR""); VAR VAR = VAR(""VAR""); VAR { VAR } = VAR(""VAR""); VAR VAR VAR() { VAR VAR = `VAR-VAR-${VAR VAR() .VAR() .VAR(0, 10)}-${VAR VAR().VAR().VAR(11, 19)}`; VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR/VAR/${VAR}`) : VAR.VAR(VAR.VAR.VAR, `VAR/${VAR}`); VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR`) : VAR.VAR(VAR.VAR.VAR); VAR { VAR.VAR(VAR, { VAR: VAR }); VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR(""\VAR[34m[VAR VAR]\VAR[0m VAR VAR!""); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR(""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR!""); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR-VAR`))) { VAR.VAR(""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR!""); VAR.VAR( VAR.VAR(VAR, `VAR-VAR`), VAR.VAR(VAR, ""VAR-VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR.VAR`))) { VAR.VAR( ""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR!"" ); VAR.VAR( VAR.VAR(VAR, `VAR.VAR`), VAR.VAR(VAR, ""VAR.VAR"") ); } VAR VAR(VAR, VAR.VAR(VAR, `../${VAR}.VAR`)); VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR { VAR: `${VAR}.VAR`, VAR: VAR }; } VAR (VAR) {  VAR.VAR(VAR); VAR (VAR.VAR(VAR)) VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR { VAR: VAR, VAR: VAR.VAR }; } } VAR VAR VAR(VAR) { VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR/VAR/${VAR}`) : VAR.VAR(VAR.VAR.VAR, `VAR/${VAR}`); VAR (!VAR.VAR(VAR)) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR VAR."" }; VAR VAR = VAR(); VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR/VAR/${VAR}`) : VAR.VAR(VAR.VAR.VAR, `VAR/${VAR}`); VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR`) : VAR.VAR(VAR.VAR.VAR); VAR { VAR.VAR( ""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR VAR VAR VAR!"" ); VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR.VAR) VAR VAR; VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR`), { VAR: VAR, VAR: VAR, }); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR`), { VAR: VAR, VAR: VAR, }); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR-VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR-VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR-VAR`), { VAR: VAR, VAR: VAR, }); VAR.VAR( VAR.VAR(VAR, `VAR-VAR`), VAR.VAR(VAR, ""VAR-VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR.VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR.VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR.VAR`), { VAR: VAR }); VAR.VAR( VAR.VAR(VAR, `VAR.VAR`), VAR.VAR(VAR, ""VAR.VAR"") ); } VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR.VAR(VAR, { VAR: VAR }); VAR { VAR: VAR, VAR: VAR }; } VAR (VAR) { VAR.VAR(VAR); VAR (VAR.VAR(VAR)) VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR (VAR.VAR(VAR)) VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR.VAR }; } } VAR VAR(VAR, VAR) { VAR VAR = VAR(""VAR""); VAR VAR = VAR(""VAR"", { VAR: { VAR: 9 } }); VAR VAR = VAR.VAR(VAR); VAR VAR VAR((VAR, VAR) => { VAR .VAR(VAR, VAR) .VAR(""VAR"", (VAR) => VAR(VAR)) .VAR(VAR); VAR.VAR(""VAR"", () => VAR()); VAR.VAR(); }); } VAR VAR VAR(VAR, VAR) { VAR VAR = VAR(""VAR-VAR""); VAR { VAR VAR(VAR, { VAR: VAR }); VAR { VAR: VAR, VAR: VAR }; } VAR (VAR) { VAR.VAR(""VAR"", VAR); VAR { VAR: VAR, VAR: VAR.VAR }; } } VAR.VAR = { VAR, VAR, }; ",0,12
anything-llm_dc3dfbf31495fe316b21ee184b9317b38101d30e,server/utils/files/data.js,"const fs = require(""fs"");
const path = require(""path"");
const { v4 } = require(""uuid"");

async function exportData() {
  const uid = `anythingllm-export-${new Date()
    .toJSON()
    .slice(0, 10)}-${new Date().toJSON().slice(11, 19)}`;
  const folder =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage/exports/${uid}`)
      : path.resolve(process.env.STORAGE_DIR, `exports/${uid}`);
  const storageBase =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage`)
      : path.resolve(process.env.STORAGE_DIR);

  try {
    fs.mkdirSync(folder, { recursive: true });
    if (fs.existsSync(path.resolve(storageBase, `documents`))) {
      console.log(""\x1b[34m[EXPORTING DATA]\x1b[0m Copying documents!"");
      fs.cpSync(
        path.resolve(storageBase, `documents`),
        path.resolve(folder, ""documents""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(storageBase, `lancedb`))) {
      console.log(""\x1b[34m[EXPORTING DATA]\x1b[0m Copying LanceDB data!"");
      fs.cpSync(
        path.resolve(storageBase, `lancedb`),
        path.resolve(folder, ""lancedb""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(storageBase, `vector-cache`))) {
      console.log(""\x1b[34m[EXPORTING DATA]\x1b[0m Copying vector cache!"");
      fs.cpSync(
        path.resolve(storageBase, `vector-cache`),
        path.resolve(folder, ""vector-cache""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(storageBase, `anythingllm.db`))) {
      console.log(
        ""\x1b[34m[EXPORTING DATA]\x1b[0m Copying anythingllm database!""
      );
      fs.cpSync(
        path.resolve(storageBase, `anythingllm.db`),
        path.resolve(folder, ""anythingllm.db"")
      );
    }

    await zipDirectory(folder, path.resolve(folder, `../${uid}.zip`));
    fs.rmSync(folder, { recursive: true, force: true });
    return { filename: `${uid}.zip`, error: null };
  } catch (e) {
    // If anything goes wrong - abort and clean up
    console.error(e);
    if (fs.existsSync(folder))
      fs.rmSync(folder, { recursive: true, force: true });
    return { filename: null, error: e.message };
  }
}

async function unpackAndOverwriteImport(importFilename) {
  const importFilepath =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage/imports/${importFilename}`)
      : path.resolve(process.env.STORAGE_DIR, `imports/${importFilename}`);
  if (!fs.existsSync(importFilepath))
    return { success: false, error: ""Import file does not exist."" };

  const uid = v4();
  const outDir =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage/imports/${uid}`)
      : path.resolve(process.env.STORAGE_DIR, `imports/${uid}`);

  const storageBase =
    process.env.NODE_ENV === ""development""
      ? path.resolve(__dirname, `../../storage`)
      : path.resolve(process.env.STORAGE_DIR);

  try {
    console.log(
      ""\x1b[34m[EXTRACTING DATA]\x1b[0m Extracting data from zip into storage!""
    );
    const unzipProc = await unzipDirectory(importFilepath, outDir);
    if (!unzipProc.success) return unzipProc;

    if (fs.existsSync(path.resolve(outDir, `documents`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing documents!""
      );
      if (fs.existsSync(path.resolve(storageBase, `documents`)))
        fs.rmSync(path.resolve(storageBase, `documents`), {
          recursive: true,
          force: true,
        });
      fs.cpSync(
        path.resolve(outDir, `documents`),
        path.resolve(storageBase, ""documents""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(outDir, `lancedb`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing LanceDb!""
      );
      if (fs.existsSync(path.resolve(storageBase, `lancedb`)))
        fs.rmSync(path.resolve(storageBase, `lancedb`), {
          recursive: true,
          force: true,
        });
      fs.cpSync(
        path.resolve(outDir, `lancedb`),
        path.resolve(storageBase, ""lancedb""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(outDir, `vector-cache`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing Vector Cache!""
      );
      if (fs.existsSync(path.resolve(storageBase, `vector-cache`)))
        fs.rmSync(path.resolve(storageBase, `vector-cache`), {
          recursive: true,
          force: true,
        });
      fs.cpSync(
        path.resolve(outDir, `vector-cache`),
        path.resolve(storageBase, ""vector-cache""),
        { recursive: true }
      );
    }

    if (fs.existsSync(path.resolve(outDir, `anythingllm.db`))) {
      console.log(
        ""\x1b[34m[OVERWRITE & IMPORT DATA]\x1b[0m Importing AnythingLLM DB!""
      );
      if (fs.existsSync(path.resolve(storageBase, `anythingllm.db`)))
        fs.rmSync(path.resolve(storageBase, `anythingllm.db`), { force: true });
      fs.cpSync(
        path.resolve(outDir, `anythingllm.db`),
        path.resolve(storageBase, ""anythingllm.db"")
      );
    }

    fs.rmSync(outDir, { recursive: true, force: true });
    fs.rmSync(importFilepath, { force: true });
    return { success: true, error: null };
  } catch (e) {
    console.error(e);
    if (fs.existsSync(outDir))
      fs.rmSync(outDir, { recursive: true, force: true });
    if (fs.existsSync(importFilepath)) fs.rmSync(importFilepath);
    return { success: false, error: e.message };
  }
}

function zipDirectory(sourceDir, outPath) {
  const archiver = require(""archiver"");
  const archive = archiver(""zip"", { zlib: { level: 9 } });
  const stream = fs.createWriteStream(outPath);

  return new Promise((resolve, reject) => {
    archive
      .directory(sourceDir, false)
      .on(""error"", (err) => reject(err))
      .pipe(stream);

    stream.on(""close"", () => resolve());
    archive.finalize();
  });
}

async function unzipDirectory(sourcePath, outDir) {
  const extract = require(""extract-zip"");
  try {
    await extract(sourcePath, { dir: outDir });
    return { success: true, error: null };
  } catch (e) {
    console.error(""unzipToDirectory"", e);
    return { success: false, error: e.message };
  }
}

module.exports = {
  exportData,
  unpackAndOverwriteImport,
};",,dc3dfbf31495fe316b21ee184b9317b38101d30e,CVE-2023-4898,dc3dfbf31495fe316b21ee184b9317b38101d30e,https://github.com/mintplex-labs/anything-llm,NVD_DIRECT_COMMIT,1337,COMPLETED,"VAR VAR = VAR(""VAR""); VAR VAR = VAR(""VAR""); VAR { VAR } = VAR(""VAR""); VAR VAR VAR() { VAR VAR = `VAR-VAR-${VAR VAR() .VAR() .VAR(0, 10)}-${VAR VAR().VAR().VAR(11, 19)}`; VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR/VAR/${VAR}`) : VAR.VAR(VAR.VAR.VAR, `VAR/${VAR}`); VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR`) : VAR.VAR(VAR.VAR.VAR); VAR { VAR.VAR(VAR, { VAR: VAR }); VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR(""\VAR[34m[VAR VAR]\VAR[0m VAR VAR!""); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR(""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR!""); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR-VAR`))) { VAR.VAR(""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR!""); VAR.VAR( VAR.VAR(VAR, `VAR-VAR`), VAR.VAR(VAR, ""VAR-VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR.VAR`))) { VAR.VAR( ""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR!"" ); VAR.VAR( VAR.VAR(VAR, `VAR.VAR`), VAR.VAR(VAR, ""VAR.VAR"") ); } VAR VAR(VAR, VAR.VAR(VAR, `../${VAR}.VAR`)); VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR { VAR: `${VAR}.VAR`, VAR: VAR }; } VAR (VAR) {  VAR.VAR(VAR); VAR (VAR.VAR(VAR)) VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR { VAR: VAR, VAR: VAR.VAR }; } } VAR VAR VAR(VAR) { VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR/VAR/${VAR}`) : VAR.VAR(VAR.VAR.VAR, `VAR/${VAR}`); VAR (!VAR.VAR(VAR)) VAR { VAR: VAR, VAR: ""VAR VAR VAR VAR VAR."" }; VAR VAR = VAR(); VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR/VAR/${VAR}`) : VAR.VAR(VAR.VAR.VAR, `VAR/${VAR}`); VAR VAR = VAR.VAR.VAR === ""VAR"" ? VAR.VAR(VAR, `../../VAR`) : VAR.VAR(VAR.VAR.VAR); VAR { VAR.VAR( ""\VAR[34m[VAR VAR]\VAR[0m VAR VAR VAR VAR VAR VAR!"" ); VAR VAR = VAR VAR(VAR, VAR); VAR (!VAR.VAR) VAR VAR; VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR`), { VAR: VAR, VAR: VAR, }); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR`), { VAR: VAR, VAR: VAR, }); VAR.VAR( VAR.VAR(VAR, `VAR`), VAR.VAR(VAR, ""VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR-VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR-VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR-VAR`), { VAR: VAR, VAR: VAR, }); VAR.VAR( VAR.VAR(VAR, `VAR-VAR`), VAR.VAR(VAR, ""VAR-VAR""), { VAR: VAR } ); } VAR (VAR.VAR(VAR.VAR(VAR, `VAR.VAR`))) { VAR.VAR( ""\VAR[34m[VAR & VAR VAR]\VAR[0m VAR VAR VAR!"" ); VAR (VAR.VAR(VAR.VAR(VAR, `VAR.VAR`))) VAR.VAR(VAR.VAR(VAR, `VAR.VAR`), { VAR: VAR }); VAR.VAR( VAR.VAR(VAR, `VAR.VAR`), VAR.VAR(VAR, ""VAR.VAR"") ); } VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR.VAR(VAR, { VAR: VAR }); VAR { VAR: VAR, VAR: VAR }; } VAR (VAR) { VAR.VAR(VAR); VAR (VAR.VAR(VAR)) VAR.VAR(VAR, { VAR: VAR, VAR: VAR }); VAR (VAR.VAR(VAR)) VAR.VAR(VAR); VAR { VAR: VAR, VAR: VAR.VAR }; } } VAR VAR(VAR, VAR) { VAR VAR = VAR(""VAR""); VAR VAR = VAR(""VAR"", { VAR: { VAR: 9 } }); VAR VAR = VAR.VAR(VAR); VAR VAR VAR((VAR, VAR) => { VAR .VAR(VAR, VAR) .VAR(""VAR"", (VAR) => VAR(VAR)) .VAR(VAR); VAR.VAR(""VAR"", () => VAR()); VAR.VAR(); }); } VAR VAR VAR(VAR, VAR) { VAR VAR = VAR(""VAR-VAR""); VAR { VAR VAR(VAR, { VAR: VAR }); VAR { VAR: VAR, VAR: VAR }; } VAR (VAR) { VAR.VAR(""VAR"", VAR); VAR { VAR: VAR, VAR: VAR.VAR }; } } VAR.VAR = { VAR, VAR, }; ",0,12
